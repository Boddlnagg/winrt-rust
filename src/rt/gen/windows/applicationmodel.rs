use crate::prelude::*;
RT_ENUM! { enum AddResourcePackageOptions: u32 {
    None = 0, ForceTargetAppShutdown = 1, ApplyUpdateIfAvailable = 2,
}}
DEFINE_IID!(IID_IAppDisplayInfo, 451612931, 58580, 16810, 164, 246, 196, 162, 118, 231, 158, 172);
RT_INTERFACE!{interface IAppDisplayInfo(IAppDisplayInfoVtbl): IInspectable [IID_IAppDisplayInfo] {
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetLogo(&self, size: foundation::Size, out: *mut <super::storage::streams::RandomAccessStreamReference as RtType>::Abi) -> HRESULT
}}
impl IAppDisplayInfo {
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Description)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_logo(&self, size: foundation::Size) -> Result<Option<super::storage::streams::RandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetLogo)(self.get_abi() as *const _ as *mut _, size, &mut out);
        if hr == S_OK { Ok(super::storage::streams::RandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppDisplayInfo: IAppDisplayInfo}
DEFINE_IID!(IID_IAppInfo, 3481229747, 27145, 19944, 166, 192, 87, 146, 213, 104, 128, 209);
RT_INTERFACE!{interface IAppInfo(IAppInfoVtbl): IInspectable [IID_IAppInfo] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppUserModelId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayInfo(&self, out: *mut <AppDisplayInfo as RtType>::Abi) -> HRESULT,
    fn get_PackageFamilyName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAppInfo {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_app_user_model_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppUserModelId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_info(&self) -> Result<Option<AppDisplayInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayInfo)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppDisplayInfo::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_package_family_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PackageFamilyName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppInfo: IAppInfo}
DEFINE_IID!(IID_IAppInstallerInfo, 699083456, 54518, 17059, 173, 205, 214, 88, 60, 101, 149, 8);
RT_INTERFACE!{interface IAppInstallerInfo(IAppInstallerInfoVtbl): IInspectable [IID_IAppInstallerInfo] {
    fn get_Uri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT
}}
impl IAppInstallerInfo {
    #[inline] pub fn get_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Uri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppInstallerInfo: IAppInstallerInfo}
DEFINE_IID!(IID_IAppInstance, 1734290247, 62047, 17714, 159, 214, 54, 51, 224, 99, 77, 1);
RT_INTERFACE!{interface IAppInstance(IAppInstanceVtbl): IInspectable [IID_IAppInstance] {
    fn get_Key(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsCurrentInstance(&self, out: *mut bool) -> HRESULT,
    fn RedirectActivationTo(&self) -> HRESULT
}}
impl IAppInstance {
    #[inline] pub fn get_key(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Key)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_current_instance(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsCurrentInstance)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn redirect_activation_to(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().RedirectActivationTo)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppInstance: IAppInstance}
impl RtActivatable<IAppInstanceStatics> for AppInstance {}
impl AppInstance {
    #[inline] pub fn get_recommended_instance() -> Result<Option<AppInstance>> {
        <Self as RtActivatable<IAppInstanceStatics>>::get_activation_factory().get_recommended_instance()
    }
    #[inline] pub fn get_activated_event_args() -> Result<Option<activation::IActivatedEventArgs>> {
        <Self as RtActivatable<IAppInstanceStatics>>::get_activation_factory().get_activated_event_args()
    }
    #[inline] pub fn find_or_register_instance_for_key(key: &HStringArg) -> Result<Option<AppInstance>> {
        <Self as RtActivatable<IAppInstanceStatics>>::get_activation_factory().find_or_register_instance_for_key(key)
    }
    #[inline] pub fn unregister() -> Result<()> {
        <Self as RtActivatable<IAppInstanceStatics>>::get_activation_factory().unregister()
    }
    #[inline] pub fn get_instances() -> Result<Option<foundation::collections::IVector<AppInstance>>> {
        <Self as RtActivatable<IAppInstanceStatics>>::get_activation_factory().get_instances()
    }
}
DEFINE_CLSID!(AppInstance(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,65,112,112,73,110,115,116,97,110,99,101,0]) [CLSID_AppInstance]);
DEFINE_IID!(IID_IAppInstanceStatics, 2635196287, 40614, 18351, 166, 236, 70, 120, 76, 91, 162, 84);
RT_INTERFACE!{static interface IAppInstanceStatics(IAppInstanceStaticsVtbl): IInspectable [IID_IAppInstanceStatics] {
    fn get_RecommendedInstance(&self, out: *mut <AppInstance as RtType>::Abi) -> HRESULT,
    fn GetActivatedEventArgs(&self, out: *mut <activation::IActivatedEventArgs as RtType>::Abi) -> HRESULT,
    fn FindOrRegisterInstanceForKey(&self, key: HSTRING, out: *mut <AppInstance as RtType>::Abi) -> HRESULT,
    fn Unregister(&self) -> HRESULT,
    fn GetInstances(&self, out: *mut <foundation::collections::IVector<AppInstance> as RtType>::Abi) -> HRESULT
}}
impl IAppInstanceStatics {
    #[inline] pub fn get_recommended_instance(&self) -> Result<Option<AppInstance>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RecommendedInstance)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppInstance::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_activated_event_args(&self) -> Result<Option<activation::IActivatedEventArgs>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetActivatedEventArgs)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(activation::IActivatedEventArgs::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_or_register_instance_for_key(&self, key: &HStringArg) -> Result<Option<AppInstance>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindOrRegisterInstanceForKey)(self.get_abi() as *const _ as *mut _, key.get(), &mut out);
        if hr == S_OK { Ok(AppInstance::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn unregister(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Unregister)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_instances(&self) -> Result<Option<foundation::collections::IVector<AppInstance>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetInstances)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class DesignMode}
impl RtActivatable<IDesignModeStatics> for DesignMode {}
impl RtActivatable<IDesignModeStatics2> for DesignMode {}
impl DesignMode {
    #[inline] pub fn get_design_mode_enabled() -> Result<bool> {
        <Self as RtActivatable<IDesignModeStatics>>::get_activation_factory().get_design_mode_enabled()
    }
    #[inline] pub fn get_design_mode2_enabled() -> Result<bool> {
        <Self as RtActivatable<IDesignModeStatics2>>::get_activation_factory().get_design_mode2_enabled()
    }
}
DEFINE_CLSID!(DesignMode(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,68,101,115,105,103,110,77,111,100,101,0]) [CLSID_DesignMode]);
DEFINE_IID!(IID_IDesignModeStatics, 741905356, 63514, 20090, 184, 87, 118, 168, 8, 135, 225, 133);
RT_INTERFACE!{static interface IDesignModeStatics(IDesignModeStaticsVtbl): IInspectable [IID_IDesignModeStatics] {
    fn get_DesignModeEnabled(&self, out: *mut bool) -> HRESULT
}}
impl IDesignModeStatics {
    #[inline] pub fn get_design_mode_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DesignModeEnabled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDesignModeStatics2, 2161082679, 45156, 18520, 190, 200, 62, 186, 34, 53, 117, 53);
RT_INTERFACE!{static interface IDesignModeStatics2(IDesignModeStatics2Vtbl): IInspectable [IID_IDesignModeStatics2] {
    fn get_DesignMode2Enabled(&self, out: *mut bool) -> HRESULT
}}
impl IDesignModeStatics2 {
    #[inline] pub fn get_design_mode2_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DesignMode2Enabled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IEnteredBackgroundEventArgs, 4146257090, 38951, 16445, 170, 237, 236, 202, 154, 193, 115, 152);
RT_INTERFACE!{interface IEnteredBackgroundEventArgs(IEnteredBackgroundEventArgsVtbl): IInspectable [IID_IEnteredBackgroundEventArgs] {
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IEnteredBackgroundEventArgs {
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EnteredBackgroundEventArgs: IEnteredBackgroundEventArgs}
RT_CLASS!{static class FullTrustProcessLauncher}
impl RtActivatable<IFullTrustProcessLauncherStatics> for FullTrustProcessLauncher {}
impl FullTrustProcessLauncher {
    #[inline] pub fn launch_full_trust_process_for_current_app_async() -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<IFullTrustProcessLauncherStatics>>::get_activation_factory().launch_full_trust_process_for_current_app_async()
    }
    #[inline] pub fn launch_full_trust_process_for_current_app_with_parameters_async(parameterGroupId: &HStringArg) -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<IFullTrustProcessLauncherStatics>>::get_activation_factory().launch_full_trust_process_for_current_app_with_parameters_async(parameterGroupId)
    }
    #[inline] pub fn launch_full_trust_process_for_app_async(fullTrustPackageRelativeAppId: &HStringArg) -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<IFullTrustProcessLauncherStatics>>::get_activation_factory().launch_full_trust_process_for_app_async(fullTrustPackageRelativeAppId)
    }
    #[inline] pub fn launch_full_trust_process_for_app_with_parameters_async(fullTrustPackageRelativeAppId: &HStringArg, parameterGroupId: &HStringArg) -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<IFullTrustProcessLauncherStatics>>::get_activation_factory().launch_full_trust_process_for_app_with_parameters_async(fullTrustPackageRelativeAppId, parameterGroupId)
    }
}
DEFINE_CLSID!(FullTrustProcessLauncher(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,70,117,108,108,84,114,117,115,116,80,114,111,99,101,115,115,76,97,117,110,99,104,101,114,0]) [CLSID_FullTrustProcessLauncher]);
DEFINE_IID!(IID_IFullTrustProcessLauncherStatics, 3615785855, 4352, 15467, 164, 85, 246, 38, 44, 195, 49, 182);
RT_INTERFACE!{static interface IFullTrustProcessLauncherStatics(IFullTrustProcessLauncherStaticsVtbl): IInspectable [IID_IFullTrustProcessLauncherStatics] {
    fn LaunchFullTrustProcessForCurrentAppAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn LaunchFullTrustProcessForCurrentAppWithParametersAsync(&self, parameterGroupId: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn LaunchFullTrustProcessForAppAsync(&self, fullTrustPackageRelativeAppId: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn LaunchFullTrustProcessForAppWithParametersAsync(&self, fullTrustPackageRelativeAppId: HSTRING, parameterGroupId: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IFullTrustProcessLauncherStatics {
    #[inline] pub fn launch_full_trust_process_for_current_app_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().LaunchFullTrustProcessForCurrentAppAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn launch_full_trust_process_for_current_app_with_parameters_async(&self, parameterGroupId: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().LaunchFullTrustProcessForCurrentAppWithParametersAsync)(self.get_abi() as *const _ as *mut _, parameterGroupId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn launch_full_trust_process_for_app_async(&self, fullTrustPackageRelativeAppId: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().LaunchFullTrustProcessForAppAsync)(self.get_abi() as *const _ as *mut _, fullTrustPackageRelativeAppId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn launch_full_trust_process_for_app_with_parameters_async(&self, fullTrustPackageRelativeAppId: &HStringArg, parameterGroupId: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().LaunchFullTrustProcessForAppWithParametersAsync)(self.get_abi() as *const _ as *mut _, fullTrustPackageRelativeAppId.get(), parameterGroupId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILeavingBackgroundEventArgs, 969338010, 44654, 18169, 160, 122, 207, 194, 63, 136, 115, 62);
RT_INTERFACE!{interface ILeavingBackgroundEventArgs(ILeavingBackgroundEventArgsVtbl): IInspectable [IID_ILeavingBackgroundEventArgs] {
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl ILeavingBackgroundEventArgs {
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LeavingBackgroundEventArgs: ILeavingBackgroundEventArgs}
DEFINE_IID!(IID_ILimitedAccessFeatureRequestResult, 3562100390, 7716, 24029, 171, 180, 97, 136, 171, 164, 213, 191);
RT_INTERFACE!{interface ILimitedAccessFeatureRequestResult(ILimitedAccessFeatureRequestResultVtbl): IInspectable [IID_ILimitedAccessFeatureRequestResult] {
    fn get_FeatureId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Status(&self, out: *mut LimitedAccessFeatureStatus) -> HRESULT,
    fn get_EstimatedRemovalDate(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT
}}
impl ILimitedAccessFeatureRequestResult {
    #[inline] pub fn get_feature_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_FeatureId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<LimitedAccessFeatureStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_estimated_removal_date(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EstimatedRemovalDate)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LimitedAccessFeatureRequestResult: ILimitedAccessFeatureRequestResult}
RT_CLASS!{static class LimitedAccessFeatures}
impl RtActivatable<ILimitedAccessFeaturesStatics> for LimitedAccessFeatures {}
impl LimitedAccessFeatures {
    #[inline] pub fn try_unlock_feature(featureId: &HStringArg, token: &HStringArg, attestation: &HStringArg) -> Result<Option<LimitedAccessFeatureRequestResult>> {
        <Self as RtActivatable<ILimitedAccessFeaturesStatics>>::get_activation_factory().try_unlock_feature(featureId, token, attestation)
    }
}
DEFINE_CLSID!(LimitedAccessFeatures(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,76,105,109,105,116,101,100,65,99,99,101,115,115,70,101,97,116,117,114,101,115,0]) [CLSID_LimitedAccessFeatures]);
DEFINE_IID!(IID_ILimitedAccessFeaturesStatics, 2347111124, 12331, 24511, 166, 50, 26, 153, 228, 62, 137, 37);
RT_INTERFACE!{static interface ILimitedAccessFeaturesStatics(ILimitedAccessFeaturesStaticsVtbl): IInspectable [IID_ILimitedAccessFeaturesStatics] {
    fn TryUnlockFeature(&self, featureId: HSTRING, token: HSTRING, attestation: HSTRING, out: *mut <LimitedAccessFeatureRequestResult as RtType>::Abi) -> HRESULT
}}
impl ILimitedAccessFeaturesStatics {
    #[inline] pub fn try_unlock_feature(&self, featureId: &HStringArg, token: &HStringArg, attestation: &HStringArg) -> Result<Option<LimitedAccessFeatureRequestResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryUnlockFeature)(self.get_abi() as *const _ as *mut _, featureId.get(), token.get(), attestation.get(), &mut out);
        if hr == S_OK { Ok(LimitedAccessFeatureRequestResult::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum LimitedAccessFeatureStatus: i32 {
    Unavailable = 0, Available = 1, AvailableWithoutToken = 2, Unknown = 3,
}}
DEFINE_IID!(IID_IPackage, 373061935, 48501, 16700, 191, 35, 177, 254, 123, 149, 216, 37);
RT_INTERFACE!{interface IPackage(IPackageVtbl): IInspectable [IID_IPackage] {
    fn get_Id(&self, out: *mut <PackageId as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_InstalledLocation(&self, out: *mut <super::storage::StorageFolder as RtType>::Abi) -> HRESULT,
    fn get_IsFramework(&self, out: *mut bool) -> HRESULT,
    fn get_Dependencies(&self, out: *mut <foundation::collections::IVectorView<Package> as RtType>::Abi) -> HRESULT
}}
impl IPackage {
    #[inline] pub fn get_id(&self) -> Result<Option<PackageId>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PackageId::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_installed_location(&self) -> Result<Option<super::storage::StorageFolder>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_InstalledLocation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::storage::StorageFolder::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_framework(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsFramework)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dependencies(&self) -> Result<Option<foundation::collections::IVectorView<Package>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Dependencies)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class Package: IPackage}
impl RtActivatable<IPackageStatics> for Package {}
impl Package {
    #[inline] pub fn get_current() -> Result<Option<Package>> {
        <Self as RtActivatable<IPackageStatics>>::get_activation_factory().get_current()
    }
}
DEFINE_CLSID!(Package(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,97,99,107,97,103,101,0]) [CLSID_Package]);
DEFINE_IID!(IID_IPackage2, 2791387062, 30344, 19150, 149, 251, 53, 149, 56, 231, 170, 1);
RT_INTERFACE!{interface IPackage2(IPackage2Vtbl): IInspectable [IID_IPackage2] {
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PublisherDisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Logo(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_IsResourcePackage(&self, out: *mut bool) -> HRESULT,
    fn get_IsBundle(&self, out: *mut bool) -> HRESULT,
    fn get_IsDevelopmentMode(&self, out: *mut bool) -> HRESULT
}}
impl IPackage2 {
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_publisher_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PublisherDisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Description)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_logo(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Logo)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_resource_package(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsResourcePackage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_bundle(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsBundle)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_development_mode(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsDevelopmentMode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPackage3, 1601407841, 63594, 18711, 147, 209, 241, 238, 157, 59, 53, 217);
RT_INTERFACE!{interface IPackage3(IPackage3Vtbl): IInspectable [IID_IPackage3] {
    fn get_Status(&self, out: *mut <PackageStatus as RtType>::Abi) -> HRESULT,
    fn get_InstalledDate(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn GetAppListEntriesAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<core::AppListEntry>> as RtType>::Abi) -> HRESULT
}}
impl IPackage3 {
    #[inline] pub fn get_status(&self) -> Result<Option<PackageStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PackageStatus::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_installed_date(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_InstalledDate)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_app_list_entries_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<core::AppListEntry>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetAppListEntriesAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPackage4, 1705955758, 47451, 17676, 136, 43, 98, 85, 24, 127, 57, 126);
RT_INTERFACE!{interface IPackage4(IPackage4Vtbl): IInspectable [IID_IPackage4] {
    fn get_SignatureKind(&self, out: *mut PackageSignatureKind) -> HRESULT,
    fn get_IsOptional(&self, out: *mut bool) -> HRESULT,
    fn VerifyContentIntegrityAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl IPackage4 {
    #[inline] pub fn get_signature_kind(&self) -> Result<PackageSignatureKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SignatureKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_optional(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsOptional)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn verify_content_integrity_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().VerifyContentIntegrityAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPackage5, 243543508, 55724, 17901, 154, 30, 116, 206, 5, 107, 38, 53);
RT_INTERFACE!{interface IPackage5(IPackage5Vtbl): IInspectable [IID_IPackage5] {
    fn GetContentGroupsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVector<PackageContentGroup>> as RtType>::Abi) -> HRESULT,
    fn GetContentGroupAsync(&self, name: HSTRING, out: *mut <foundation::IAsyncOperation<PackageContentGroup> as RtType>::Abi) -> HRESULT,
    fn StageContentGroupsAsync(&self, names: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVector<PackageContentGroup>> as RtType>::Abi) -> HRESULT,
    fn StageContentGroupsWithPriorityAsync(&self, names: <foundation::collections::IIterable<HString> as RtType>::Abi, moveToHeadOfQueue: bool, out: *mut <foundation::IAsyncOperation<foundation::collections::IVector<PackageContentGroup>> as RtType>::Abi) -> HRESULT,
    fn SetInUseAsync(&self, inUse: bool, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl IPackage5 {
    #[inline] pub fn get_content_groups_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVector<PackageContentGroup>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetContentGroupsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_content_group_async(&self, name: &HStringArg) -> Result<foundation::IAsyncOperation<PackageContentGroup>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetContentGroupAsync)(self.get_abi() as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn stage_content_groups_async(&self, names: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<foundation::collections::IVector<PackageContentGroup>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().StageContentGroupsAsync)(self.get_abi() as *const _ as *mut _, names.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn stage_content_groups_with_priority_async(&self, names: &foundation::collections::IIterable<HString>, moveToHeadOfQueue: bool) -> Result<foundation::IAsyncOperation<foundation::collections::IVector<PackageContentGroup>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().StageContentGroupsWithPriorityAsync)(self.get_abi() as *const _ as *mut _, names.get_abi() as *const _ as *mut _, moveToHeadOfQueue, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_in_use_async(&self, inUse: bool) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SetInUseAsync)(self.get_abi() as *const _ as *mut _, inUse, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPackage6, 2333792578, 4823, 18260, 174, 78, 99, 140, 188, 14, 58, 46);
RT_INTERFACE!{interface IPackage6(IPackage6Vtbl): IInspectable [IID_IPackage6] {
    fn GetAppInstallerInfo(&self, out: *mut <AppInstallerInfo as RtType>::Abi) -> HRESULT,
    fn CheckUpdateAvailabilityAsync(&self, out: *mut <foundation::IAsyncOperation<PackageUpdateAvailabilityResult> as RtType>::Abi) -> HRESULT
}}
impl IPackage6 {
    #[inline] pub fn get_app_installer_info(&self) -> Result<Option<AppInstallerInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetAppInstallerInfo)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppInstallerInfo::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn check_update_availability_async(&self) -> Result<foundation::IAsyncOperation<PackageUpdateAvailabilityResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CheckUpdateAvailabilityAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPackageCatalog, 587872081, 40419, 17477, 190, 116, 145, 251, 50, 90, 190, 254);
RT_INTERFACE!{interface IPackageCatalog(IPackageCatalogVtbl): IInspectable [IID_IPackageCatalog] {
    fn add_PackageStaging(&self, handler: <foundation::TypedEventHandler<PackageCatalog, PackageStagingEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PackageStaging(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PackageInstalling(&self, handler: <foundation::TypedEventHandler<PackageCatalog, PackageInstallingEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PackageInstalling(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PackageUpdating(&self, handler: <foundation::TypedEventHandler<PackageCatalog, PackageUpdatingEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PackageUpdating(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PackageUninstalling(&self, handler: <foundation::TypedEventHandler<PackageCatalog, PackageUninstallingEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PackageUninstalling(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PackageStatusChanged(&self, handler: <foundation::TypedEventHandler<PackageCatalog, PackageStatusChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PackageStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IPackageCatalog {
    #[inline] pub fn add_package_staging(&self, handler: &foundation::TypedEventHandler<PackageCatalog, PackageStagingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_PackageStaging)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_package_staging(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_PackageStaging)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_package_installing(&self, handler: &foundation::TypedEventHandler<PackageCatalog, PackageInstallingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_PackageInstalling)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_package_installing(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_PackageInstalling)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_package_updating(&self, handler: &foundation::TypedEventHandler<PackageCatalog, PackageUpdatingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_PackageUpdating)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_package_updating(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_PackageUpdating)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_package_uninstalling(&self, handler: &foundation::TypedEventHandler<PackageCatalog, PackageUninstallingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_PackageUninstalling)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_package_uninstalling(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_PackageUninstalling)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_package_status_changed(&self, handler: &foundation::TypedEventHandler<PackageCatalog, PackageStatusChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_PackageStatusChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_package_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_PackageStatusChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PackageCatalog: IPackageCatalog}
impl RtActivatable<IPackageCatalogStatics> for PackageCatalog {}
impl PackageCatalog {
    #[inline] pub fn open_for_current_package() -> Result<Option<PackageCatalog>> {
        <Self as RtActivatable<IPackageCatalogStatics>>::get_activation_factory().open_for_current_package()
    }
    #[inline] pub fn open_for_current_user() -> Result<Option<PackageCatalog>> {
        <Self as RtActivatable<IPackageCatalogStatics>>::get_activation_factory().open_for_current_user()
    }
}
DEFINE_CLSID!(PackageCatalog(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,97,99,107,97,103,101,67,97,116,97,108,111,103,0]) [CLSID_PackageCatalog]);
DEFINE_IID!(IID_IPackageCatalog2, 2527464502, 36855, 17220, 182, 191, 238, 100, 194, 32, 126, 210);
RT_INTERFACE!{interface IPackageCatalog2(IPackageCatalog2Vtbl): IInspectable [IID_IPackageCatalog2] {
    fn add_PackageContentGroupStaging(&self, handler: <foundation::TypedEventHandler<PackageCatalog, PackageContentGroupStagingEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PackageContentGroupStaging(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn AddOptionalPackageAsync(&self, optionalPackageFamilyName: HSTRING, out: *mut <foundation::IAsyncOperation<PackageCatalogAddOptionalPackageResult> as RtType>::Abi) -> HRESULT
}}
impl IPackageCatalog2 {
    #[inline] pub fn add_package_content_group_staging(&self, handler: &foundation::TypedEventHandler<PackageCatalog, PackageContentGroupStagingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_PackageContentGroupStaging)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_package_content_group_staging(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_PackageContentGroupStaging)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_optional_package_async(&self, optionalPackageFamilyName: &HStringArg) -> Result<foundation::IAsyncOperation<PackageCatalogAddOptionalPackageResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().AddOptionalPackageAsync)(self.get_abi() as *const _ as *mut _, optionalPackageFamilyName.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPackageCatalog3, 2531089544, 34871, 17401, 144, 21, 3, 52, 52, 186, 20, 243);
RT_INTERFACE!{interface IPackageCatalog3(IPackageCatalog3Vtbl): IInspectable [IID_IPackageCatalog3] {
    fn RemoveOptionalPackagesAsync(&self, optionalPackageFamilyNames: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PackageCatalogRemoveOptionalPackagesResult> as RtType>::Abi) -> HRESULT
}}
impl IPackageCatalog3 {
    #[inline] pub fn remove_optional_packages_async(&self, optionalPackageFamilyNames: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<PackageCatalogRemoveOptionalPackagesResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RemoveOptionalPackagesAsync)(self.get_abi() as *const _ as *mut _, optionalPackageFamilyNames.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPackageCatalog4, 3279698331, 17612, 19323, 139, 175, 121, 108, 4, 234, 211, 185);
RT_INTERFACE!{interface IPackageCatalog4(IPackageCatalog4Vtbl): IInspectable [IID_IPackageCatalog4] {
    fn AddResourcePackageAsync(&self, resourcePackageFamilyName: HSTRING, resourceID: HSTRING, options: AddResourcePackageOptions, out: *mut <foundation::IAsyncOperationWithProgress<PackageCatalogAddResourcePackageResult, PackageInstallProgress> as RtType>::Abi) -> HRESULT,
    fn RemoveResourcePackagesAsync(&self, resourcePackages: <foundation::collections::IIterable<Package> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PackageCatalogRemoveResourcePackagesResult> as RtType>::Abi) -> HRESULT
}}
impl IPackageCatalog4 {
    #[inline] pub fn add_resource_package_async(&self, resourcePackageFamilyName: &HStringArg, resourceID: &HStringArg, options: AddResourcePackageOptions) -> Result<foundation::IAsyncOperationWithProgress<PackageCatalogAddResourcePackageResult, PackageInstallProgress>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().AddResourcePackageAsync)(self.get_abi() as *const _ as *mut _, resourcePackageFamilyName.get(), resourceID.get(), options, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperationWithProgress::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn remove_resource_packages_async(&self, resourcePackages: &foundation::collections::IIterable<Package>) -> Result<foundation::IAsyncOperation<PackageCatalogRemoveResourcePackagesResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RemoveResourcePackagesAsync)(self.get_abi() as *const _ as *mut _, resourcePackages.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPackageCatalogAddOptionalPackageResult, 1005653204, 46303, 18355, 169, 99, 226, 250, 131, 47, 125, 211);
RT_INTERFACE!{interface IPackageCatalogAddOptionalPackageResult(IPackageCatalogAddOptionalPackageResultVtbl): IInspectable [IID_IPackageCatalogAddOptionalPackageResult] {
    fn get_Package(&self, out: *mut <Package as RtType>::Abi) -> HRESULT,
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl IPackageCatalogAddOptionalPackageResult {
    #[inline] pub fn get_package(&self) -> Result<Option<Package>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Package)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Package::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ExtendedError)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PackageCatalogAddOptionalPackageResult: IPackageCatalogAddOptionalPackageResult}
DEFINE_IID!(IID_IPackageCatalogAddResourcePackageResult, 2520174093, 15895, 18751, 170, 8, 204, 236, 111, 222, 246, 153);
RT_INTERFACE!{interface IPackageCatalogAddResourcePackageResult(IPackageCatalogAddResourcePackageResultVtbl): IInspectable [IID_IPackageCatalogAddResourcePackageResult] {
    fn get_Package(&self, out: *mut <Package as RtType>::Abi) -> HRESULT,
    fn get_IsComplete(&self, out: *mut bool) -> HRESULT,
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl IPackageCatalogAddResourcePackageResult {
    #[inline] pub fn get_package(&self) -> Result<Option<Package>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Package)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Package::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_complete(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsComplete)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ExtendedError)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PackageCatalogAddResourcePackageResult: IPackageCatalogAddResourcePackageResult}
DEFINE_IID!(IID_IPackageCatalogRemoveOptionalPackagesResult, 701692283, 55668, 20068, 147, 89, 34, 202, 223, 215, 152, 40);
RT_INTERFACE!{interface IPackageCatalogRemoveOptionalPackagesResult(IPackageCatalogRemoveOptionalPackagesResultVtbl): IInspectable [IID_IPackageCatalogRemoveOptionalPackagesResult] {
    fn get_PackagesRemoved(&self, out: *mut <foundation::collections::IVectorView<Package> as RtType>::Abi) -> HRESULT,
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl IPackageCatalogRemoveOptionalPackagesResult {
    #[inline] pub fn get_packages_removed(&self) -> Result<Option<foundation::collections::IVectorView<Package>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PackagesRemoved)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ExtendedError)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PackageCatalogRemoveOptionalPackagesResult: IPackageCatalogRemoveOptionalPackagesResult}
DEFINE_IID!(IID_IPackageCatalogRemoveResourcePackagesResult, 2926679817, 6738, 17185, 135, 179, 229, 161, 161, 121, 129, 167);
RT_INTERFACE!{interface IPackageCatalogRemoveResourcePackagesResult(IPackageCatalogRemoveResourcePackagesResultVtbl): IInspectable [IID_IPackageCatalogRemoveResourcePackagesResult] {
    fn get_PackagesRemoved(&self, out: *mut <foundation::collections::IVectorView<Package> as RtType>::Abi) -> HRESULT,
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl IPackageCatalogRemoveResourcePackagesResult {
    #[inline] pub fn get_packages_removed(&self) -> Result<Option<foundation::collections::IVectorView<Package>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PackagesRemoved)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ExtendedError)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PackageCatalogRemoveResourcePackagesResult: IPackageCatalogRemoveResourcePackagesResult}
DEFINE_IID!(IID_IPackageCatalogStatics, 2710345366, 58971, 17972, 186, 33, 94, 99, 235, 114, 68, 167);
RT_INTERFACE!{static interface IPackageCatalogStatics(IPackageCatalogStaticsVtbl): IInspectable [IID_IPackageCatalogStatics] {
    fn OpenForCurrentPackage(&self, out: *mut <PackageCatalog as RtType>::Abi) -> HRESULT,
    fn OpenForCurrentUser(&self, out: *mut <PackageCatalog as RtType>::Abi) -> HRESULT
}}
impl IPackageCatalogStatics {
    #[inline] pub fn open_for_current_package(&self) -> Result<Option<PackageCatalog>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().OpenForCurrentPackage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PackageCatalog::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn open_for_current_user(&self) -> Result<Option<PackageCatalog>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().OpenForCurrentUser)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PackageCatalog::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPackageContentGroup, 2405591389, 4618, 18328, 181, 225, 88, 0, 221, 168, 242, 225);
RT_INTERFACE!{interface IPackageContentGroup(IPackageContentGroupVtbl): IInspectable [IID_IPackageContentGroup] {
    fn get_Package(&self, out: *mut <Package as RtType>::Abi) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_State(&self, out: *mut PackageContentGroupState) -> HRESULT,
    fn get_IsRequired(&self, out: *mut bool) -> HRESULT
}}
impl IPackageContentGroup {
    #[inline] pub fn get_package(&self) -> Result<Option<Package>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Package)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Package::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Name)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_state(&self) -> Result<PackageContentGroupState> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_State)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_required(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsRequired)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PackageContentGroup: IPackageContentGroup}
impl RtActivatable<IPackageContentGroupStatics> for PackageContentGroup {}
impl PackageContentGroup {
    #[inline] pub fn get_required_group_name() -> Result<HString> {
        <Self as RtActivatable<IPackageContentGroupStatics>>::get_activation_factory().get_required_group_name()
    }
}
DEFINE_CLSID!(PackageContentGroup(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,97,99,107,97,103,101,67,111,110,116,101,110,116,71,114,111,117,112,0]) [CLSID_PackageContentGroup]);
DEFINE_IID!(IID_IPackageContentGroupStagingEventArgs, 1031520894, 28455, 17516, 152, 110, 212, 115, 61, 77, 145, 19);
RT_INTERFACE!{interface IPackageContentGroupStagingEventArgs(IPackageContentGroupStagingEventArgsVtbl): IInspectable [IID_IPackageContentGroupStagingEventArgs] {
    fn get_ActivityId(&self, out: *mut Guid) -> HRESULT,
    fn get_Package(&self, out: *mut <Package as RtType>::Abi) -> HRESULT,
    fn get_Progress(&self, out: *mut f64) -> HRESULT,
    fn get_IsComplete(&self, out: *mut bool) -> HRESULT,
    fn get_ErrorCode(&self, out: *mut foundation::HResult) -> HRESULT,
    fn get_ContentGroupName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsContentGroupRequired(&self, out: *mut bool) -> HRESULT
}}
impl IPackageContentGroupStagingEventArgs {
    #[inline] pub fn get_activity_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ActivityId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_package(&self) -> Result<Option<Package>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Package)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Package::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_progress(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Progress)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_complete(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsComplete)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error_code(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ErrorCode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_content_group_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContentGroupName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_content_group_required(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsContentGroupRequired)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PackageContentGroupStagingEventArgs: IPackageContentGroupStagingEventArgs}
RT_ENUM! { enum PackageContentGroupState: i32 {
    NotStaged = 0, Queued = 1, Staging = 2, Staged = 3,
}}
DEFINE_IID!(IID_IPackageContentGroupStatics, 1894675993, 24338, 19346, 185, 234, 108, 202, 218, 19, 188, 117);
RT_INTERFACE!{static interface IPackageContentGroupStatics(IPackageContentGroupStaticsVtbl): IInspectable [IID_IPackageContentGroupStatics] {
    fn get_RequiredGroupName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPackageContentGroupStatics {
    #[inline] pub fn get_required_group_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RequiredGroupName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPackageId, 450586206, 14279, 18320, 153, 128, 221, 122, 231, 78, 139, 178);
RT_INTERFACE!{interface IPackageId(IPackageIdVtbl): IInspectable [IID_IPackageId] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Version(&self, out: *mut PackageVersion) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-system")] fn get_Architecture(&self, out: *mut super::system::ProcessorArchitecture) -> HRESULT,
    fn get_ResourceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Publisher(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PublisherId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FullName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FamilyName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPackageId {
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Name)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_version(&self) -> Result<PackageVersion> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Version)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_architecture(&self) -> Result<super::system::ProcessorArchitecture> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Architecture)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_resource_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ResourceId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_publisher(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Publisher)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_publisher_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PublisherId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_full_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_FullName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_family_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_FamilyName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PackageId: IPackageId}
DEFINE_IID!(IID_IPackageIdWithMetadata, 1079474812, 3230, 17469, 144, 116, 133, 95, 92, 224, 160, 141);
RT_INTERFACE!{interface IPackageIdWithMetadata(IPackageIdWithMetadataVtbl): IInspectable [IID_IPackageIdWithMetadata] {
    fn get_ProductId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Author(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPackageIdWithMetadata {
    #[inline] pub fn get_product_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ProductId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_author(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Author)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPackageInstallingEventArgs, 2540969655, 43898, 16410, 139, 97, 235, 14, 127, 175, 242, 55);
RT_INTERFACE!{interface IPackageInstallingEventArgs(IPackageInstallingEventArgsVtbl): IInspectable [IID_IPackageInstallingEventArgs] {
    fn get_ActivityId(&self, out: *mut Guid) -> HRESULT,
    fn get_Package(&self, out: *mut <Package as RtType>::Abi) -> HRESULT,
    fn get_Progress(&self, out: *mut f64) -> HRESULT,
    fn get_IsComplete(&self, out: *mut bool) -> HRESULT,
    fn get_ErrorCode(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl IPackageInstallingEventArgs {
    #[inline] pub fn get_activity_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ActivityId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_package(&self) -> Result<Option<Package>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Package)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Package::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_progress(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Progress)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_complete(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsComplete)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error_code(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ErrorCode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PackageInstallingEventArgs: IPackageInstallingEventArgs}
RT_STRUCT! { struct PackageInstallProgress {
    PercentComplete: u32,
}}
RT_ENUM! { enum PackageSignatureKind: i32 {
    None = 0, Developer = 1, Enterprise = 2, Store = 3, System = 4,
}}
DEFINE_IID!(IID_IPackageStagingEventArgs, 272721965, 21730, 20305, 184, 40, 158, 247, 4, 108, 33, 15);
RT_INTERFACE!{interface IPackageStagingEventArgs(IPackageStagingEventArgsVtbl): IInspectable [IID_IPackageStagingEventArgs] {
    fn get_ActivityId(&self, out: *mut Guid) -> HRESULT,
    fn get_Package(&self, out: *mut <Package as RtType>::Abi) -> HRESULT,
    fn get_Progress(&self, out: *mut f64) -> HRESULT,
    fn get_IsComplete(&self, out: *mut bool) -> HRESULT,
    fn get_ErrorCode(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl IPackageStagingEventArgs {
    #[inline] pub fn get_activity_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ActivityId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_package(&self) -> Result<Option<Package>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Package)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Package::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_progress(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Progress)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_complete(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsComplete)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error_code(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ErrorCode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PackageStagingEventArgs: IPackageStagingEventArgs}
DEFINE_IID!(IID_IPackageStatics, 1314081759, 10592, 18552, 151, 164, 150, 36, 222, 183, 47, 45);
RT_INTERFACE!{static interface IPackageStatics(IPackageStaticsVtbl): IInspectable [IID_IPackageStatics] {
    fn get_Current(&self, out: *mut <Package as RtType>::Abi) -> HRESULT
}}
impl IPackageStatics {
    #[inline] pub fn get_current(&self) -> Result<Option<Package>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Current)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Package::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPackageStatus, 1608994673, 41829, 19465, 160, 45, 4, 109, 82, 94, 161, 218);
RT_INTERFACE!{interface IPackageStatus(IPackageStatusVtbl): IInspectable [IID_IPackageStatus] {
    fn VerifyIsOK(&self, out: *mut bool) -> HRESULT,
    fn get_NotAvailable(&self, out: *mut bool) -> HRESULT,
    fn get_PackageOffline(&self, out: *mut bool) -> HRESULT,
    fn get_DataOffline(&self, out: *mut bool) -> HRESULT,
    fn get_Disabled(&self, out: *mut bool) -> HRESULT,
    fn get_NeedsRemediation(&self, out: *mut bool) -> HRESULT,
    fn get_LicenseIssue(&self, out: *mut bool) -> HRESULT,
    fn get_Modified(&self, out: *mut bool) -> HRESULT,
    fn get_Tampered(&self, out: *mut bool) -> HRESULT,
    fn get_DependencyIssue(&self, out: *mut bool) -> HRESULT,
    fn get_Servicing(&self, out: *mut bool) -> HRESULT,
    fn get_DeploymentInProgress(&self, out: *mut bool) -> HRESULT
}}
impl IPackageStatus {
    #[inline] pub fn verify_is_ok(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().VerifyIsOK)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_not_available(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_NotAvailable)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_package_offline(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_PackageOffline)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_data_offline(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DataOffline)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_disabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Disabled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_needs_remediation(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_NeedsRemediation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_license_issue(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_LicenseIssue)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_modified(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Modified)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tampered(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Tampered)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dependency_issue(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DependencyIssue)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_servicing(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Servicing)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_deployment_in_progress(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DeploymentInProgress)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PackageStatus: IPackageStatus}
DEFINE_IID!(IID_IPackageStatus2, 4096326291, 31830, 18530, 172, 250, 171, 174, 220, 192, 105, 77);
RT_INTERFACE!{interface IPackageStatus2(IPackageStatus2Vtbl): IInspectable [IID_IPackageStatus2] {
    fn get_IsPartiallyStaged(&self, out: *mut bool) -> HRESULT
}}
impl IPackageStatus2 {
    #[inline] pub fn get_is_partially_staged(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsPartiallyStaged)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPackageStatusChangedEventArgs, 1132294477, 48512, 19056, 188, 80, 246, 231, 150, 80, 149, 117);
RT_INTERFACE!{interface IPackageStatusChangedEventArgs(IPackageStatusChangedEventArgsVtbl): IInspectable [IID_IPackageStatusChangedEventArgs] {
    fn get_Package(&self, out: *mut <Package as RtType>::Abi) -> HRESULT
}}
impl IPackageStatusChangedEventArgs {
    #[inline] pub fn get_package(&self) -> Result<Option<Package>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Package)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Package::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PackageStatusChangedEventArgs: IPackageStatusChangedEventArgs}
DEFINE_IID!(IID_IPackageUninstallingEventArgs, 1145285202, 43810, 17613, 130, 187, 78, 201, 184, 39, 54, 122);
RT_INTERFACE!{interface IPackageUninstallingEventArgs(IPackageUninstallingEventArgsVtbl): IInspectable [IID_IPackageUninstallingEventArgs] {
    fn get_ActivityId(&self, out: *mut Guid) -> HRESULT,
    fn get_Package(&self, out: *mut <Package as RtType>::Abi) -> HRESULT,
    fn get_Progress(&self, out: *mut f64) -> HRESULT,
    fn get_IsComplete(&self, out: *mut bool) -> HRESULT,
    fn get_ErrorCode(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl IPackageUninstallingEventArgs {
    #[inline] pub fn get_activity_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ActivityId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_package(&self) -> Result<Option<Package>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Package)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Package::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_progress(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Progress)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_complete(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsComplete)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error_code(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ErrorCode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PackageUninstallingEventArgs: IPackageUninstallingEventArgs}
RT_ENUM! { enum PackageUpdateAvailability: i32 {
    Unknown = 0, NoUpdates = 1, Available = 2, Required = 3, Error = 4,
}}
DEFINE_IID!(IID_IPackageUpdateAvailabilityResult, 290344969, 6554, 18593, 160, 121, 49, 60, 69, 99, 74, 113);
RT_INTERFACE!{interface IPackageUpdateAvailabilityResult(IPackageUpdateAvailabilityResultVtbl): IInspectable [IID_IPackageUpdateAvailabilityResult] {
    fn get_Availability(&self, out: *mut PackageUpdateAvailability) -> HRESULT,
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl IPackageUpdateAvailabilityResult {
    #[inline] pub fn get_availability(&self) -> Result<PackageUpdateAvailability> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Availability)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ExtendedError)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PackageUpdateAvailabilityResult: IPackageUpdateAvailabilityResult}
DEFINE_IID!(IID_IPackageUpdatingEventArgs, 3447407144, 64884, 17470, 177, 20, 35, 230, 119, 176, 232, 111);
RT_INTERFACE!{interface IPackageUpdatingEventArgs(IPackageUpdatingEventArgsVtbl): IInspectable [IID_IPackageUpdatingEventArgs] {
    fn get_ActivityId(&self, out: *mut Guid) -> HRESULT,
    fn get_SourcePackage(&self, out: *mut <Package as RtType>::Abi) -> HRESULT,
    fn get_TargetPackage(&self, out: *mut <Package as RtType>::Abi) -> HRESULT,
    fn get_Progress(&self, out: *mut f64) -> HRESULT,
    fn get_IsComplete(&self, out: *mut bool) -> HRESULT,
    fn get_ErrorCode(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl IPackageUpdatingEventArgs {
    #[inline] pub fn get_activity_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ActivityId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_source_package(&self) -> Result<Option<Package>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SourcePackage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Package::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_target_package(&self) -> Result<Option<Package>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TargetPackage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Package::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_progress(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Progress)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_complete(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsComplete)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error_code(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ErrorCode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PackageUpdatingEventArgs: IPackageUpdatingEventArgs}
RT_STRUCT! { struct PackageVersion {
    Major: u16, Minor: u16, Build: u16, Revision: u16,
}}
DEFINE_IID!(IID_IPackageWithMetadata, 2509543296, 7657, 16626, 180, 82, 13, 233, 241, 145, 0, 18);
RT_INTERFACE!{interface IPackageWithMetadata(IPackageWithMetadataVtbl): IInspectable [IID_IPackageWithMetadata] {
    fn get_InstallDate(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn GetThumbnailToken(&self, out: *mut HSTRING) -> HRESULT,
    fn Launch(&self, parameters: HSTRING) -> HRESULT
}}
impl IPackageWithMetadata {
    #[inline] pub fn get_install_date(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_InstallDate)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_thumbnail_token(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetThumbnailToken)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn launch(&self, parameters: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Launch)(self.get_abi() as *const _ as *mut _, parameters.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IStartupTask, 4150010824, 46578, 20332, 136, 221, 54, 203, 29, 89, 157, 23);
RT_INTERFACE!{interface IStartupTask(IStartupTaskVtbl): IInspectable [IID_IStartupTask] {
    fn RequestEnableAsync(&self, out: *mut <foundation::IAsyncOperation<StartupTaskState> as RtType>::Abi) -> HRESULT,
    fn Disable(&self) -> HRESULT,
    fn get_State(&self, out: *mut StartupTaskState) -> HRESULT,
    fn get_TaskId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IStartupTask {
    #[inline] pub fn request_enable_async(&self) -> Result<foundation::IAsyncOperation<StartupTaskState>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestEnableAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn disable(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Disable)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_state(&self) -> Result<StartupTaskState> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_State)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_task_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TaskId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class StartupTask: IStartupTask}
impl RtActivatable<IStartupTaskStatics> for StartupTask {}
impl StartupTask {
    #[inline] pub fn get_for_current_package_async() -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<StartupTask>>> {
        <Self as RtActivatable<IStartupTaskStatics>>::get_activation_factory().get_for_current_package_async()
    }
    #[inline] pub fn get_async(taskId: &HStringArg) -> Result<foundation::IAsyncOperation<StartupTask>> {
        <Self as RtActivatable<IStartupTaskStatics>>::get_activation_factory().get_async(taskId)
    }
}
DEFINE_CLSID!(StartupTask(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,83,116,97,114,116,117,112,84,97,115,107,0]) [CLSID_StartupTask]);
RT_ENUM! { enum StartupTaskState: i32 {
    Disabled = 0, DisabledByUser = 1, Enabled = 2, DisabledByPolicy = 3, EnabledByPolicy = 4,
}}
DEFINE_IID!(IID_IStartupTaskStatics, 3998965949, 41288, 16807, 178, 110, 232, 184, 138, 30, 98, 248);
RT_INTERFACE!{static interface IStartupTaskStatics(IStartupTaskStaticsVtbl): IInspectable [IID_IStartupTaskStatics] {
    fn GetForCurrentPackageAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<StartupTask>> as RtType>::Abi) -> HRESULT,
    fn GetAsync(&self, taskId: HSTRING, out: *mut <foundation::IAsyncOperation<StartupTask> as RtType>::Abi) -> HRESULT
}}
impl IStartupTaskStatics {
    #[inline] pub fn get_for_current_package_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<StartupTask>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetForCurrentPackageAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_async(&self, taskId: &HStringArg) -> Result<foundation::IAsyncOperation<StartupTask>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetAsync)(self.get_abi() as *const _ as *mut _, taskId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISuspendingDeferral, 1494484233, 35785, 20148, 182, 54, 218, 189, 196, 244, 111, 102);
RT_INTERFACE!{interface ISuspendingDeferral(ISuspendingDeferralVtbl): IInspectable [IID_ISuspendingDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl ISuspendingDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Complete)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SuspendingDeferral: ISuspendingDeferral}
DEFINE_IID!(IID_ISuspendingEventArgs, 2516982789, 11706, 19720, 176, 189, 43, 48, 161, 49, 198, 170);
RT_INTERFACE!{interface ISuspendingEventArgs(ISuspendingEventArgsVtbl): IInspectable [IID_ISuspendingEventArgs] {
    fn get_SuspendingOperation(&self, out: *mut <SuspendingOperation as RtType>::Abi) -> HRESULT
}}
impl ISuspendingEventArgs {
    #[inline] pub fn get_suspending_operation(&self) -> Result<Option<SuspendingOperation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SuspendingOperation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SuspendingOperation::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SuspendingEventArgs: ISuspendingEventArgs}
DEFINE_IID!(IID_ISuspendingOperation, 2644822593, 8417, 20123, 159, 101, 169, 244, 53, 52, 12, 58);
RT_INTERFACE!{interface ISuspendingOperation(ISuspendingOperationVtbl): IInspectable [IID_ISuspendingOperation] {
    fn GetDeferral(&self, out: *mut <SuspendingDeferral as RtType>::Abi) -> HRESULT,
    fn get_Deadline(&self, out: *mut foundation::DateTime) -> HRESULT
}}
impl ISuspendingOperation {
    #[inline] pub fn get_deferral(&self) -> Result<Option<SuspendingDeferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SuspendingDeferral::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deadline(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Deadline)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SuspendingOperation: ISuspendingOperation}
pub mod activation { // Windows.ApplicationModel.Activation
use crate::prelude::*;
DEFINE_IID!(IID_IActivatedEventArgs, 3479508755, 52488, 20440, 182, 151, 162, 129, 182, 84, 78, 46);
RT_INTERFACE!{interface IActivatedEventArgs(IActivatedEventArgsVtbl): IInspectable [IID_IActivatedEventArgs] {
    fn get_Kind(&self, out: *mut ActivationKind) -> HRESULT,
    fn get_PreviousExecutionState(&self, out: *mut ApplicationExecutionState) -> HRESULT,
    fn get_SplashScreen(&self, out: *mut <SplashScreen as RtType>::Abi) -> HRESULT
}}
impl IActivatedEventArgs {
    #[inline] pub fn get_kind(&self) -> Result<ActivationKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Kind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_previous_execution_state(&self) -> Result<ApplicationExecutionState> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_PreviousExecutionState)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_splash_screen(&self) -> Result<Option<SplashScreen>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SplashScreen)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SplashScreen::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IActivatedEventArgsWithUser, 485530526, 39266, 18742, 128, 255, 175, 200, 232, 174, 92, 140);
RT_INTERFACE!{interface IActivatedEventArgsWithUser(IActivatedEventArgsWithUserVtbl): IInspectable [IID_IActivatedEventArgsWithUser] {
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut <super::super::system::User as RtType>::Abi) -> HRESULT
}}
impl IActivatedEventArgsWithUser {
    #[cfg(feature="windows-system")] #[inline] pub fn get_user(&self) -> Result<Option<super::super::system::User>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_User)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::system::User::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ActivationKind: i32 {
    Launch = 0, Search = 1, ShareTarget = 2, File = 3, Protocol = 4, FileOpenPicker = 5, FileSavePicker = 6, CachedFileUpdater = 7, ContactPicker = 8, Device = 9, PrintTaskSettings = 10, CameraSettings = 11, RestrictedLaunch = 12, AppointmentsProvider = 13, Contact = 14, LockScreenCall = 15, VoiceCommand = 16, LockScreen = 17, PickerReturned = 1000, WalletAction = 1001, PickFileContinuation = 1002, PickSaveFileContinuation = 1003, PickFolderContinuation = 1004, WebAuthenticationBrokerContinuation = 1005, WebAccountProvider = 1006, ComponentUI = 1007, ProtocolForResults = 1009, ToastNotification = 1010, Print3DWorkflow = 1011, DialReceiver = 1012, DevicePairing = 1013, UserDataAccountsProvider = 1014, FilePickerExperience = 1015, LockScreenComponent = 1016, ContactPanel = 1017, PrintWorkflowForegroundTask = 1018, GameUIProvider = 1019, StartupTask = 1020, CommandLineLaunch = 1021, BarcodeScannerProvider = 1022,
}}
RT_ENUM! { enum ApplicationExecutionState: i32 {
    NotRunning = 0, Running = 1, Suspended = 2, Terminated = 3, ClosedByUser = 4,
}}
DEFINE_IID!(IID_IApplicationViewActivatedEventArgs, 2467098443, 47145, 16636, 136, 244, 133, 19, 232, 166, 71, 56);
RT_INTERFACE!{interface IApplicationViewActivatedEventArgs(IApplicationViewActivatedEventArgsVtbl): IInspectable [IID_IApplicationViewActivatedEventArgs] {
    fn get_CurrentlyShownApplicationViewId(&self, out: *mut i32) -> HRESULT
}}
impl IApplicationViewActivatedEventArgs {
    #[inline] pub fn get_currently_shown_application_view_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CurrentlyShownApplicationViewId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppointmentsProviderActivatedEventArgs, 862241797, 37692, 20093, 160, 52, 80, 15, 184, 220, 217, 243);
RT_INTERFACE!{interface IAppointmentsProviderActivatedEventArgs(IAppointmentsProviderActivatedEventArgsVtbl): IInspectable [IID_IAppointmentsProviderActivatedEventArgs] {
    fn get_Verb(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAppointmentsProviderActivatedEventArgs {
    #[inline] pub fn get_verb(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Verb)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppointmentsProviderAddAppointmentActivatedEventArgs, 2726695783, 52965, 20045, 158, 215, 65, 195, 78, 193, 139, 2);
RT_INTERFACE!{interface IAppointmentsProviderAddAppointmentActivatedEventArgs(IAppointmentsProviderAddAppointmentActivatedEventArgsVtbl): IInspectable [IID_IAppointmentsProviderAddAppointmentActivatedEventArgs] {
    fn get_AddAppointmentOperation(&self, out: *mut <super::appointments::appointmentsprovider::AddAppointmentOperation as RtType>::Abi) -> HRESULT
}}
impl IAppointmentsProviderAddAppointmentActivatedEventArgs {
    #[inline] pub fn get_add_appointment_operation(&self) -> Result<Option<super::appointments::appointmentsprovider::AddAppointmentOperation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AddAppointmentOperation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::appointments::appointmentsprovider::AddAppointmentOperation::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentsProviderAddAppointmentActivatedEventArgs: IAppointmentsProviderAddAppointmentActivatedEventArgs}
DEFINE_IID!(IID_IAppointmentsProviderRemoveAppointmentActivatedEventArgs, 1964980920, 2958, 17692, 159, 21, 150, 110, 105, 155, 172, 37);
RT_INTERFACE!{interface IAppointmentsProviderRemoveAppointmentActivatedEventArgs(IAppointmentsProviderRemoveAppointmentActivatedEventArgsVtbl): IInspectable [IID_IAppointmentsProviderRemoveAppointmentActivatedEventArgs] {
    fn get_RemoveAppointmentOperation(&self, out: *mut <super::appointments::appointmentsprovider::RemoveAppointmentOperation as RtType>::Abi) -> HRESULT
}}
impl IAppointmentsProviderRemoveAppointmentActivatedEventArgs {
    #[inline] pub fn get_remove_appointment_operation(&self) -> Result<Option<super::appointments::appointmentsprovider::RemoveAppointmentOperation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RemoveAppointmentOperation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::appointments::appointmentsprovider::RemoveAppointmentOperation::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentsProviderRemoveAppointmentActivatedEventArgs: IAppointmentsProviderRemoveAppointmentActivatedEventArgs}
DEFINE_IID!(IID_IAppointmentsProviderReplaceAppointmentActivatedEventArgs, 357677012, 43393, 16487, 138, 98, 5, 36, 228, 173, 225, 33);
RT_INTERFACE!{interface IAppointmentsProviderReplaceAppointmentActivatedEventArgs(IAppointmentsProviderReplaceAppointmentActivatedEventArgsVtbl): IInspectable [IID_IAppointmentsProviderReplaceAppointmentActivatedEventArgs] {
    fn get_ReplaceAppointmentOperation(&self, out: *mut <super::appointments::appointmentsprovider::ReplaceAppointmentOperation as RtType>::Abi) -> HRESULT
}}
impl IAppointmentsProviderReplaceAppointmentActivatedEventArgs {
    #[inline] pub fn get_replace_appointment_operation(&self) -> Result<Option<super::appointments::appointmentsprovider::ReplaceAppointmentOperation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ReplaceAppointmentOperation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::appointments::appointmentsprovider::ReplaceAppointmentOperation::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentsProviderReplaceAppointmentActivatedEventArgs: IAppointmentsProviderReplaceAppointmentActivatedEventArgs}
DEFINE_IID!(IID_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs, 962130021, 38977, 19621, 153, 155, 136, 81, 152, 185, 239, 42);
RT_INTERFACE!{interface IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgsVtbl): IInspectable [IID_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs] {
    fn get_InstanceStartDate(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_LocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RoamingId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs {
    #[inline] pub fn get_instance_start_date(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_InstanceStartDate)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_local_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LocalId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_roaming_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RoamingId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentsProviderShowAppointmentDetailsActivatedEventArgs: IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs}
DEFINE_IID!(IID_IAppointmentsProviderShowTimeFrameActivatedEventArgs, 2611915686, 3595, 18858, 186, 188, 18, 177, 220, 119, 73, 134);
RT_INTERFACE!{interface IAppointmentsProviderShowTimeFrameActivatedEventArgs(IAppointmentsProviderShowTimeFrameActivatedEventArgsVtbl): IInspectable [IID_IAppointmentsProviderShowTimeFrameActivatedEventArgs] {
    fn get_TimeToShow(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT
}}
impl IAppointmentsProviderShowTimeFrameActivatedEventArgs {
    #[inline] pub fn get_time_to_show(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_TimeToShow)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Duration)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentsProviderShowTimeFrameActivatedEventArgs: IAppointmentsProviderShowTimeFrameActivatedEventArgs}
DEFINE_IID!(IID_IBackgroundActivatedEventArgs, 2870263520, 59232, 17422, 169, 28, 68, 121, 109, 227, 169, 45);
RT_INTERFACE!{interface IBackgroundActivatedEventArgs(IBackgroundActivatedEventArgsVtbl): IInspectable [IID_IBackgroundActivatedEventArgs] {
    fn get_TaskInstance(&self, out: *mut <super::background::IBackgroundTaskInstance as RtType>::Abi) -> HRESULT
}}
impl IBackgroundActivatedEventArgs {
    #[inline] pub fn get_task_instance(&self) -> Result<Option<super::background::IBackgroundTaskInstance>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TaskInstance)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::background::IBackgroundTaskInstance::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BackgroundActivatedEventArgs: IBackgroundActivatedEventArgs}
DEFINE_IID!(IID_IBarcodeScannerPreviewActivatedEventArgs, 1735555452, 39359, 17225, 175, 34, 228, 18, 53, 96, 55, 28);
RT_INTERFACE!{interface IBarcodeScannerPreviewActivatedEventArgs(IBarcodeScannerPreviewActivatedEventArgsVtbl): IInspectable [IID_IBarcodeScannerPreviewActivatedEventArgs] {
    fn get_ConnectionId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IBarcodeScannerPreviewActivatedEventArgs {
    #[inline] pub fn get_connection_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ConnectionId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerPreviewActivatedEventArgs: IBarcodeScannerPreviewActivatedEventArgs}
DEFINE_IID!(IID_ICachedFileUpdaterActivatedEventArgs, 3496915399, 14341, 20171, 183, 87, 108, 241, 94, 38, 254, 243);
RT_INTERFACE!{interface ICachedFileUpdaterActivatedEventArgs(ICachedFileUpdaterActivatedEventArgsVtbl): IInspectable [IID_ICachedFileUpdaterActivatedEventArgs] {
    #[cfg(feature="windows-storage")] fn get_CachedFileUpdaterUI(&self, out: *mut <super::super::storage::provider::CachedFileUpdaterUI as RtType>::Abi) -> HRESULT
}}
impl ICachedFileUpdaterActivatedEventArgs {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_cached_file_updater_ui(&self) -> Result<Option<super::super::storage::provider::CachedFileUpdaterUI>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CachedFileUpdaterUI)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::provider::CachedFileUpdaterUI::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CachedFileUpdaterActivatedEventArgs: ICachedFileUpdaterActivatedEventArgs}
DEFINE_IID!(IID_ICameraSettingsActivatedEventArgs, 4217873672, 11693, 18698, 145, 112, 220, 160, 54, 235, 17, 75);
RT_INTERFACE!{interface ICameraSettingsActivatedEventArgs(ICameraSettingsActivatedEventArgsVtbl): IInspectable [IID_ICameraSettingsActivatedEventArgs] {
    fn get_VideoDeviceController(&self, out: *mut <IInspectable as RtType>::Abi) -> HRESULT,
    fn get_VideoDeviceExtension(&self, out: *mut <IInspectable as RtType>::Abi) -> HRESULT
}}
impl ICameraSettingsActivatedEventArgs {
    #[inline] pub fn get_video_device_controller(&self) -> Result<Option<IInspectable>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_VideoDeviceController)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IInspectable::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_device_extension(&self) -> Result<Option<IInspectable>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_VideoDeviceExtension)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IInspectable::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CameraSettingsActivatedEventArgs: ICameraSettingsActivatedEventArgs}
DEFINE_IID!(IID_ICommandLineActivatedEventArgs, 1158039340, 106, 18667, 138, 251, 208, 122, 178, 94, 51, 102);
RT_INTERFACE!{interface ICommandLineActivatedEventArgs(ICommandLineActivatedEventArgsVtbl): IInspectable [IID_ICommandLineActivatedEventArgs] {
    fn get_Operation(&self, out: *mut <CommandLineActivationOperation as RtType>::Abi) -> HRESULT
}}
impl ICommandLineActivatedEventArgs {
    #[inline] pub fn get_operation(&self) -> Result<Option<CommandLineActivationOperation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Operation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CommandLineActivationOperation::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CommandLineActivatedEventArgs: ICommandLineActivatedEventArgs}
DEFINE_IID!(IID_ICommandLineActivationOperation, 2571839553, 50590, 20329, 188, 253, 182, 30, 212, 230, 34, 235);
RT_INTERFACE!{interface ICommandLineActivationOperation(ICommandLineActivationOperationVtbl): IInspectable [IID_ICommandLineActivationOperation] {
    fn get_Arguments(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CurrentDirectoryPath(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ExitCode(&self, value: i32) -> HRESULT,
    fn get_ExitCode(&self, out: *mut i32) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl ICommandLineActivationOperation {
    #[inline] pub fn get_arguments(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Arguments)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_current_directory_path(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CurrentDirectoryPath)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_exit_code(&self, value: i32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ExitCode)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_exit_code(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ExitCode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CommandLineActivationOperation: ICommandLineActivationOperation}
DEFINE_IID!(IID_IContactActivatedEventArgs, 3592921540, 49189, 19521, 157, 239, 241, 234, 250, 208, 117, 231);
RT_INTERFACE!{interface IContactActivatedEventArgs(IContactActivatedEventArgsVtbl): IInspectable [IID_IContactActivatedEventArgs] {
    fn get_Verb(&self, out: *mut HSTRING) -> HRESULT
}}
impl IContactActivatedEventArgs {
    #[inline] pub fn get_verb(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Verb)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContactCallActivatedEventArgs, 3269399751, 12523, 16838, 179, 188, 91, 22, 148, 249, 218, 179);
RT_INTERFACE!{interface IContactCallActivatedEventArgs(IContactCallActivatedEventArgsVtbl): IInspectable [IID_IContactCallActivatedEventArgs] {
    fn get_ServiceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ServiceUserId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Contact(&self, out: *mut <super::contacts::Contact as RtType>::Abi) -> HRESULT
}}
impl IContactCallActivatedEventArgs {
    #[inline] pub fn get_service_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ServiceId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_service_user_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ServiceUserId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_contact(&self) -> Result<Option<super::contacts::Contact>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Contact)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::contacts::Contact::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactCallActivatedEventArgs: IContactCallActivatedEventArgs}
DEFINE_IID!(IID_IContactMapActivatedEventArgs, 3006003312, 61159, 19154, 170, 241, 168, 126, 255, 207, 0, 164);
RT_INTERFACE!{interface IContactMapActivatedEventArgs(IContactMapActivatedEventArgsVtbl): IInspectable [IID_IContactMapActivatedEventArgs] {
    fn get_Address(&self, out: *mut <super::contacts::ContactAddress as RtType>::Abi) -> HRESULT,
    fn get_Contact(&self, out: *mut <super::contacts::Contact as RtType>::Abi) -> HRESULT
}}
impl IContactMapActivatedEventArgs {
    #[inline] pub fn get_address(&self) -> Result<Option<super::contacts::ContactAddress>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Address)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::contacts::ContactAddress::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_contact(&self) -> Result<Option<super::contacts::Contact>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Contact)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::contacts::Contact::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactMapActivatedEventArgs: IContactMapActivatedEventArgs}
DEFINE_IID!(IID_IContactMessageActivatedEventArgs, 3730410930, 3587, 17328, 191, 86, 188, 196, 11, 49, 98, 223);
RT_INTERFACE!{interface IContactMessageActivatedEventArgs(IContactMessageActivatedEventArgsVtbl): IInspectable [IID_IContactMessageActivatedEventArgs] {
    fn get_ServiceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ServiceUserId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Contact(&self, out: *mut <super::contacts::Contact as RtType>::Abi) -> HRESULT
}}
impl IContactMessageActivatedEventArgs {
    #[inline] pub fn get_service_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ServiceId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_service_user_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ServiceUserId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_contact(&self) -> Result<Option<super::contacts::Contact>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Contact)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::contacts::Contact::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactMessageActivatedEventArgs: IContactMessageActivatedEventArgs}
DEFINE_IID!(IID_IContactPanelActivatedEventArgs, 1388012516, 54228, 19299, 128, 81, 74, 242, 8, 44, 171, 128);
RT_INTERFACE!{interface IContactPanelActivatedEventArgs(IContactPanelActivatedEventArgsVtbl): IInspectable [IID_IContactPanelActivatedEventArgs] {
    fn get_ContactPanel(&self, out: *mut <super::contacts::ContactPanel as RtType>::Abi) -> HRESULT,
    fn get_Contact(&self, out: *mut <super::contacts::Contact as RtType>::Abi) -> HRESULT
}}
impl IContactPanelActivatedEventArgs {
    #[inline] pub fn get_contact_panel(&self) -> Result<Option<super::contacts::ContactPanel>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContactPanel)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::contacts::ContactPanel::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_contact(&self) -> Result<Option<super::contacts::Contact>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Contact)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::contacts::Contact::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactPanelActivatedEventArgs: IContactPanelActivatedEventArgs}
DEFINE_IID!(IID_IContactPickerActivatedEventArgs, 3461851879, 25673, 17831, 151, 31, 209, 19, 190, 122, 137, 54);
RT_INTERFACE!{interface IContactPickerActivatedEventArgs(IContactPickerActivatedEventArgsVtbl): IInspectable [IID_IContactPickerActivatedEventArgs] {
    fn get_ContactPickerUI(&self, out: *mut <super::contacts::provider::ContactPickerUI as RtType>::Abi) -> HRESULT
}}
impl IContactPickerActivatedEventArgs {
    #[inline] pub fn get_contact_picker_ui(&self) -> Result<Option<super::contacts::provider::ContactPickerUI>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContactPickerUI)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::contacts::provider::ContactPickerUI::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactPickerActivatedEventArgs: IContactPickerActivatedEventArgs}
DEFINE_IID!(IID_IContactPostActivatedEventArgs, 3009035367, 61927, 18005, 173, 110, 72, 87, 88, 143, 85, 47);
RT_INTERFACE!{interface IContactPostActivatedEventArgs(IContactPostActivatedEventArgsVtbl): IInspectable [IID_IContactPostActivatedEventArgs] {
    fn get_ServiceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ServiceUserId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Contact(&self, out: *mut <super::contacts::Contact as RtType>::Abi) -> HRESULT
}}
impl IContactPostActivatedEventArgs {
    #[inline] pub fn get_service_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ServiceId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_service_user_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ServiceUserId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_contact(&self) -> Result<Option<super::contacts::Contact>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Contact)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::contacts::Contact::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactPostActivatedEventArgs: IContactPostActivatedEventArgs}
DEFINE_IID!(IID_IContactsProviderActivatedEventArgs, 1166073000, 22352, 18710, 170, 82, 192, 130, 149, 33, 235, 148);
RT_INTERFACE!{interface IContactsProviderActivatedEventArgs(IContactsProviderActivatedEventArgsVtbl): IInspectable [IID_IContactsProviderActivatedEventArgs] {
    fn get_Verb(&self, out: *mut HSTRING) -> HRESULT
}}
impl IContactsProviderActivatedEventArgs {
    #[inline] pub fn get_verb(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Verb)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContactVideoCallActivatedEventArgs, 1627889080, 58343, 19279, 133, 141, 92, 99, 169, 110, 246, 132);
RT_INTERFACE!{interface IContactVideoCallActivatedEventArgs(IContactVideoCallActivatedEventArgsVtbl): IInspectable [IID_IContactVideoCallActivatedEventArgs] {
    fn get_ServiceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ServiceUserId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Contact(&self, out: *mut <super::contacts::Contact as RtType>::Abi) -> HRESULT
}}
impl IContactVideoCallActivatedEventArgs {
    #[inline] pub fn get_service_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ServiceId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_service_user_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ServiceUserId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_contact(&self) -> Result<Option<super::contacts::Contact>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Contact)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::contacts::Contact::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactVideoCallActivatedEventArgs: IContactVideoCallActivatedEventArgs}
DEFINE_IID!(IID_IContinuationActivatedEventArgs, 3850438325, 5471, 19092, 167, 66, 199, 224, 143, 78, 24, 140);
RT_INTERFACE!{interface IContinuationActivatedEventArgs(IContinuationActivatedEventArgsVtbl): IInspectable [IID_IContinuationActivatedEventArgs] {
    fn get_ContinuationData(&self, out: *mut <foundation::collections::ValueSet as RtType>::Abi) -> HRESULT
}}
impl IContinuationActivatedEventArgs {
    #[inline] pub fn get_continuation_data(&self) -> Result<Option<foundation::collections::ValueSet>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContinuationData)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::ValueSet::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDeviceActivatedEventArgs, 3444619689, 52752, 17618, 130, 52, 195, 85, 160, 115, 239, 51);
RT_INTERFACE!{interface IDeviceActivatedEventArgs(IDeviceActivatedEventArgsVtbl): IInspectable [IID_IDeviceActivatedEventArgs] {
    fn get_DeviceInformationId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Verb(&self, out: *mut HSTRING) -> HRESULT
}}
impl IDeviceActivatedEventArgs {
    #[inline] pub fn get_device_information_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DeviceInformationId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_verb(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Verb)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceActivatedEventArgs: IDeviceActivatedEventArgs}
DEFINE_IID!(IID_IDevicePairingActivatedEventArgs, 3953185252, 60614, 16712, 148, 237, 244, 179, 126, 192, 91, 62);
RT_INTERFACE!{interface IDevicePairingActivatedEventArgs(IDevicePairingActivatedEventArgsVtbl): IInspectable [IID_IDevicePairingActivatedEventArgs] {
    #[cfg(feature="windows-devices")] fn get_DeviceInformation(&self, out: *mut <super::super::devices::enumeration::DeviceInformation as RtType>::Abi) -> HRESULT
}}
impl IDevicePairingActivatedEventArgs {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_device_information(&self) -> Result<Option<super::super::devices::enumeration::DeviceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DeviceInformation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::enumeration::DeviceInformation::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DevicePairingActivatedEventArgs: IDevicePairingActivatedEventArgs}
DEFINE_IID!(IID_IDialReceiverActivatedEventArgs, 4218912471, 34286, 17774, 164, 77, 133, 215, 48, 231, 10, 237);
RT_INTERFACE!{interface IDialReceiverActivatedEventArgs(IDialReceiverActivatedEventArgsVtbl): IInspectable [IID_IDialReceiverActivatedEventArgs] {
    fn get_AppName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IDialReceiverActivatedEventArgs {
    #[inline] pub fn get_app_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DialReceiverActivatedEventArgs: IDialReceiverActivatedEventArgs}
DEFINE_IID!(IID_IFileActivatedEventArgs, 3140156467, 37809, 17133, 139, 38, 35, 109, 217, 199, 132, 150);
RT_INTERFACE!{interface IFileActivatedEventArgs(IFileActivatedEventArgsVtbl): IInspectable [IID_IFileActivatedEventArgs] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Files(&self, out: *mut <foundation::collections::IVectorView<super::super::storage::IStorageItem> as RtType>::Abi) -> HRESULT,
    fn get_Verb(&self, out: *mut HSTRING) -> HRESULT
}}
impl IFileActivatedEventArgs {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_files(&self) -> Result<Option<foundation::collections::IVectorView<super::super::storage::IStorageItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Files)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_verb(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Verb)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class FileActivatedEventArgs: IFileActivatedEventArgs}
DEFINE_IID!(IID_IFileActivatedEventArgsWithCallerPackageFamilyName, 761327723, 53855, 19749, 134, 83, 225, 197, 225, 16, 131, 9);
RT_INTERFACE!{interface IFileActivatedEventArgsWithCallerPackageFamilyName(IFileActivatedEventArgsWithCallerPackageFamilyNameVtbl): IInspectable [IID_IFileActivatedEventArgsWithCallerPackageFamilyName] {
    fn get_CallerPackageFamilyName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IFileActivatedEventArgsWithCallerPackageFamilyName {
    #[inline] pub fn get_caller_package_family_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CallerPackageFamilyName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IFileActivatedEventArgsWithNeighboringFiles, 1127981476, 57826, 18685, 183, 252, 181, 214, 238, 230, 80, 51);
RT_INTERFACE!{interface IFileActivatedEventArgsWithNeighboringFiles(IFileActivatedEventArgsWithNeighboringFilesVtbl): IInspectable [IID_IFileActivatedEventArgsWithNeighboringFiles] {
    #[cfg(feature="windows-storage")] fn get_NeighboringFilesQuery(&self, out: *mut <super::super::storage::search::StorageFileQueryResult as RtType>::Abi) -> HRESULT
}}
impl IFileActivatedEventArgsWithNeighboringFiles {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_neighboring_files_query(&self) -> Result<Option<super::super::storage::search::StorageFileQueryResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_NeighboringFilesQuery)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::search::StorageFileQueryResult::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IFileOpenPickerActivatedEventArgs, 1921151106, 21797, 19442, 188, 9, 31, 80, 149, 212, 150, 77);
RT_INTERFACE!{interface IFileOpenPickerActivatedEventArgs(IFileOpenPickerActivatedEventArgsVtbl): IInspectable [IID_IFileOpenPickerActivatedEventArgs] {
    #[cfg(feature="windows-storage")] fn get_FileOpenPickerUI(&self, out: *mut <super::super::storage::pickers::provider::FileOpenPickerUI as RtType>::Abi) -> HRESULT
}}
impl IFileOpenPickerActivatedEventArgs {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_file_open_picker_ui(&self) -> Result<Option<super::super::storage::pickers::provider::FileOpenPickerUI>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_FileOpenPickerUI)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::pickers::provider::FileOpenPickerUI::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class FileOpenPickerActivatedEventArgs: IFileOpenPickerActivatedEventArgs}
DEFINE_IID!(IID_IFileOpenPickerActivatedEventArgs2, 1584602982, 36127, 17915, 175, 29, 115, 32, 92, 143, 199, 161);
RT_INTERFACE!{interface IFileOpenPickerActivatedEventArgs2(IFileOpenPickerActivatedEventArgs2Vtbl): IInspectable [IID_IFileOpenPickerActivatedEventArgs2] {
    fn get_CallerPackageFamilyName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IFileOpenPickerActivatedEventArgs2 {
    #[inline] pub fn get_caller_package_family_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CallerPackageFamilyName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IFileOpenPickerContinuationEventArgs, 4042932026, 54504, 19155, 156, 52, 35, 8, 243, 47, 206, 201);
RT_INTERFACE!{interface IFileOpenPickerContinuationEventArgs(IFileOpenPickerContinuationEventArgsVtbl): IInspectable [IID_IFileOpenPickerContinuationEventArgs] {
    #[cfg(feature="windows-storage")] fn get_Files(&self, out: *mut <foundation::collections::IVectorView<super::super::storage::StorageFile> as RtType>::Abi) -> HRESULT
}}
impl IFileOpenPickerContinuationEventArgs {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_files(&self) -> Result<Option<foundation::collections::IVectorView<super::super::storage::StorageFile>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Files)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class FileOpenPickerContinuationEventArgs: IFileOpenPickerContinuationEventArgs}
DEFINE_IID!(IID_IFileSavePickerActivatedEventArgs, 2176949489, 29926, 17287, 130, 235, 187, 143, 214, 75, 67, 70);
RT_INTERFACE!{interface IFileSavePickerActivatedEventArgs(IFileSavePickerActivatedEventArgsVtbl): IInspectable [IID_IFileSavePickerActivatedEventArgs] {
    #[cfg(feature="windows-storage")] fn get_FileSavePickerUI(&self, out: *mut <super::super::storage::pickers::provider::FileSavePickerUI as RtType>::Abi) -> HRESULT
}}
impl IFileSavePickerActivatedEventArgs {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_file_save_picker_ui(&self) -> Result<Option<super::super::storage::pickers::provider::FileSavePickerUI>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_FileSavePickerUI)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::pickers::provider::FileSavePickerUI::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class FileSavePickerActivatedEventArgs: IFileSavePickerActivatedEventArgs}
DEFINE_IID!(IID_IFileSavePickerActivatedEventArgs2, 1802763795, 11506, 19784, 140, 188, 175, 103, 210, 63, 28, 231);
RT_INTERFACE!{interface IFileSavePickerActivatedEventArgs2(IFileSavePickerActivatedEventArgs2Vtbl): IInspectable [IID_IFileSavePickerActivatedEventArgs2] {
    fn get_CallerPackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EnterpriseId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IFileSavePickerActivatedEventArgs2 {
    #[inline] pub fn get_caller_package_family_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CallerPackageFamilyName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_enterprise_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EnterpriseId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IFileSavePickerContinuationEventArgs, 746876897, 15277, 20275, 140, 139, 228, 111, 174, 130, 75, 75);
RT_INTERFACE!{interface IFileSavePickerContinuationEventArgs(IFileSavePickerContinuationEventArgsVtbl): IInspectable [IID_IFileSavePickerContinuationEventArgs] {
    #[cfg(feature="windows-storage")] fn get_File(&self, out: *mut <super::super::storage::StorageFile as RtType>::Abi) -> HRESULT
}}
impl IFileSavePickerContinuationEventArgs {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_file(&self) -> Result<Option<super::super::storage::StorageFile>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_File)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::StorageFile::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class FileSavePickerContinuationEventArgs: IFileSavePickerContinuationEventArgs}
DEFINE_IID!(IID_IFolderPickerContinuationEventArgs, 1367876454, 40779, 18831, 190, 176, 66, 104, 79, 110, 28, 41);
RT_INTERFACE!{interface IFolderPickerContinuationEventArgs(IFolderPickerContinuationEventArgsVtbl): IInspectable [IID_IFolderPickerContinuationEventArgs] {
    #[cfg(feature="windows-storage")] fn get_Folder(&self, out: *mut <super::super::storage::StorageFolder as RtType>::Abi) -> HRESULT
}}
impl IFolderPickerContinuationEventArgs {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_folder(&self) -> Result<Option<super::super::storage::StorageFolder>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Folder)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::StorageFolder::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class FolderPickerContinuationEventArgs: IFolderPickerContinuationEventArgs}
DEFINE_IID!(IID_ILaunchActivatedEventArgs, 4224269862, 41290, 19279, 130, 176, 51, 190, 217, 32, 175, 82);
RT_INTERFACE!{interface ILaunchActivatedEventArgs(ILaunchActivatedEventArgsVtbl): IInspectable [IID_ILaunchActivatedEventArgs] {
    fn get_Arguments(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TileId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ILaunchActivatedEventArgs {
    #[inline] pub fn get_arguments(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Arguments)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_tile_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TileId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LaunchActivatedEventArgs: ILaunchActivatedEventArgs}
DEFINE_IID!(IID_ILaunchActivatedEventArgs2, 265518780, 40393, 18101, 154, 206, 189, 149, 212, 86, 83, 69);
RT_INTERFACE!{interface ILaunchActivatedEventArgs2(ILaunchActivatedEventArgs2Vtbl): IInspectable [IID_ILaunchActivatedEventArgs2] {
    fn get_TileActivatedInfo(&self, out: *mut <TileActivatedInfo as RtType>::Abi) -> HRESULT
}}
impl ILaunchActivatedEventArgs2 {
    #[inline] pub fn get_tile_activated_info(&self) -> Result<Option<TileActivatedInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TileActivatedInfo)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(TileActivatedInfo::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILockScreenActivatedEventArgs, 1017608550, 24840, 19009, 130, 32, 238, 125, 19, 60, 133, 50);
RT_INTERFACE!{interface ILockScreenActivatedEventArgs(ILockScreenActivatedEventArgsVtbl): IInspectable [IID_ILockScreenActivatedEventArgs] {
    fn get_Info(&self, out: *mut <IInspectable as RtType>::Abi) -> HRESULT
}}
impl ILockScreenActivatedEventArgs {
    #[inline] pub fn get_info(&self) -> Result<Option<IInspectable>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Info)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IInspectable::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LockScreenActivatedEventArgs: ILockScreenActivatedEventArgs}
DEFINE_IID!(IID_ILockScreenCallActivatedEventArgs, 116621246, 46578, 17547, 177, 62, 227, 40, 172, 28, 81, 106);
RT_INTERFACE!{interface ILockScreenCallActivatedEventArgs(ILockScreenCallActivatedEventArgsVtbl): IInspectable [IID_ILockScreenCallActivatedEventArgs] {
    fn get_CallUI(&self, out: *mut <super::calls::LockScreenCallUI as RtType>::Abi) -> HRESULT
}}
impl ILockScreenCallActivatedEventArgs {
    #[inline] pub fn get_call_ui(&self) -> Result<Option<super::calls::LockScreenCallUI>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CallUI)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::calls::LockScreenCallUI::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LockScreenCallActivatedEventArgs: ILockScreenCallActivatedEventArgs}
RT_CLASS!{class LockScreenComponentActivatedEventArgs: IActivatedEventArgs}
DEFINE_IID!(IID_IPickerReturnedActivatedEventArgs, 906883001, 43475, 18820, 164, 237, 158, 199, 52, 96, 73, 33);
RT_INTERFACE!{interface IPickerReturnedActivatedEventArgs(IPickerReturnedActivatedEventArgsVtbl): IInspectable [IID_IPickerReturnedActivatedEventArgs] {
    fn get_PickerOperationId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPickerReturnedActivatedEventArgs {
    #[inline] pub fn get_picker_operation_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PickerOperationId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PickerReturnedActivatedEventArgs: IPickerReturnedActivatedEventArgs}
DEFINE_IID!(IID_IPrelaunchActivatedEventArgs, 205812091, 6647, 18646, 176, 70, 207, 34, 130, 110, 170, 116);
RT_INTERFACE!{interface IPrelaunchActivatedEventArgs(IPrelaunchActivatedEventArgsVtbl): IInspectable [IID_IPrelaunchActivatedEventArgs] {
    fn get_PrelaunchActivated(&self, out: *mut bool) -> HRESULT
}}
impl IPrelaunchActivatedEventArgs {
    #[inline] pub fn get_prelaunch_activated(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_PrelaunchActivated)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPrint3DWorkflowActivatedEventArgs, 1062725515, 62124, 17945, 131, 2, 239, 133, 94, 28, 155, 144);
RT_INTERFACE!{interface IPrint3DWorkflowActivatedEventArgs(IPrint3DWorkflowActivatedEventArgsVtbl): IInspectable [IID_IPrint3DWorkflowActivatedEventArgs] {
    #[cfg(feature="windows-devices")] fn get_Workflow(&self, out: *mut <super::super::devices::printers::extensions::Print3DWorkflow as RtType>::Abi) -> HRESULT
}}
impl IPrint3DWorkflowActivatedEventArgs {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_workflow(&self) -> Result<Option<super::super::devices::printers::extensions::Print3DWorkflow>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Workflow)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::printers::extensions::Print3DWorkflow::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class Print3DWorkflowActivatedEventArgs: IPrint3DWorkflowActivatedEventArgs}
DEFINE_IID!(IID_IPrintTaskSettingsActivatedEventArgs, 3996164297, 52822, 18533, 186, 142, 137, 84, 172, 39, 17, 7);
RT_INTERFACE!{interface IPrintTaskSettingsActivatedEventArgs(IPrintTaskSettingsActivatedEventArgsVtbl): IInspectable [IID_IPrintTaskSettingsActivatedEventArgs] {
    #[cfg(feature="windows-devices")] fn get_Configuration(&self, out: *mut <super::super::devices::printers::extensions::PrintTaskConfiguration as RtType>::Abi) -> HRESULT
}}
impl IPrintTaskSettingsActivatedEventArgs {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_configuration(&self) -> Result<Option<super::super::devices::printers::extensions::PrintTaskConfiguration>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Configuration)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::printers::extensions::PrintTaskConfiguration::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PrintTaskSettingsActivatedEventArgs: IPrintTaskSettingsActivatedEventArgs}
DEFINE_IID!(IID_IProtocolActivatedEventArgs, 1620440285, 47040, 18091, 129, 254, 217, 15, 54, 208, 13, 36);
RT_INTERFACE!{interface IProtocolActivatedEventArgs(IProtocolActivatedEventArgsVtbl): IInspectable [IID_IProtocolActivatedEventArgs] {
    fn get_Uri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT
}}
impl IProtocolActivatedEventArgs {
    #[inline] pub fn get_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Uri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ProtocolActivatedEventArgs: IProtocolActivatedEventArgs}
DEFINE_IID!(IID_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData, 3628731410, 23695, 17292, 131, 203, 194, 143, 204, 11, 47, 219);
RT_INTERFACE!{interface IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData(IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndDataVtbl): IInspectable [IID_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData] {
    fn get_CallerPackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Data(&self, out: *mut <foundation::collections::ValueSet as RtType>::Abi) -> HRESULT
}}
impl IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData {
    #[inline] pub fn get_caller_package_family_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CallerPackageFamilyName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_data(&self) -> Result<Option<foundation::collections::ValueSet>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Data)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::ValueSet::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IProtocolForResultsActivatedEventArgs, 3880858306, 31463, 17687, 128, 172, 219, 232, 215, 204, 91, 156);
RT_INTERFACE!{interface IProtocolForResultsActivatedEventArgs(IProtocolForResultsActivatedEventArgsVtbl): IInspectable [IID_IProtocolForResultsActivatedEventArgs] {
    #[cfg(feature="windows-system")] fn get_ProtocolForResultsOperation(&self, out: *mut <super::super::system::ProtocolForResultsOperation as RtType>::Abi) -> HRESULT
}}
impl IProtocolForResultsActivatedEventArgs {
    #[cfg(feature="windows-system")] #[inline] pub fn get_protocol_for_results_operation(&self) -> Result<Option<super::super::system::ProtocolForResultsOperation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ProtocolForResultsOperation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::system::ProtocolForResultsOperation::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ProtocolForResultsActivatedEventArgs: IProtocolForResultsActivatedEventArgs}
DEFINE_IID!(IID_IRestrictedLaunchActivatedEventArgs, 3770133633, 49091, 17220, 165, 218, 25, 253, 90, 39, 186, 174);
RT_INTERFACE!{interface IRestrictedLaunchActivatedEventArgs(IRestrictedLaunchActivatedEventArgsVtbl): IInspectable [IID_IRestrictedLaunchActivatedEventArgs] {
    fn get_SharedContext(&self, out: *mut <IInspectable as RtType>::Abi) -> HRESULT
}}
impl IRestrictedLaunchActivatedEventArgs {
    #[inline] pub fn get_shared_context(&self) -> Result<Option<IInspectable>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SharedContext)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IInspectable::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RestrictedLaunchActivatedEventArgs: IRestrictedLaunchActivatedEventArgs}
DEFINE_IID!(IID_ISearchActivatedEventArgs, 2360568145, 22728, 17379, 148, 188, 65, 211, 63, 139, 99, 14);
RT_INTERFACE!{interface ISearchActivatedEventArgs(ISearchActivatedEventArgsVtbl): IInspectable [IID_ISearchActivatedEventArgs] {
    fn get_QueryText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT
}}
impl ISearchActivatedEventArgs {
    #[inline] pub fn get_query_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_QueryText)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_language(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Language)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SearchActivatedEventArgs: ISearchActivatedEventArgs}
DEFINE_IID!(IID_ISearchActivatedEventArgsWithLinguisticDetails, 3231658970, 2219, 18737, 155, 124, 69, 16, 37, 242, 31, 129);
RT_INTERFACE!{interface ISearchActivatedEventArgsWithLinguisticDetails(ISearchActivatedEventArgsWithLinguisticDetailsVtbl): IInspectable [IID_ISearchActivatedEventArgsWithLinguisticDetails] {
    fn get_LinguisticDetails(&self, out: *mut <super::search::SearchPaneQueryLinguisticDetails as RtType>::Abi) -> HRESULT
}}
impl ISearchActivatedEventArgsWithLinguisticDetails {
    #[inline] pub fn get_linguistic_details(&self) -> Result<Option<super::search::SearchPaneQueryLinguisticDetails>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LinguisticDetails)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::search::SearchPaneQueryLinguisticDetails::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IShareTargetActivatedEventArgs, 1272641992, 52658, 19147, 191, 195, 102, 72, 86, 51, 120, 236);
RT_INTERFACE!{interface IShareTargetActivatedEventArgs(IShareTargetActivatedEventArgsVtbl): IInspectable [IID_IShareTargetActivatedEventArgs] {
    fn get_ShareOperation(&self, out: *mut <super::datatransfer::sharetarget::ShareOperation as RtType>::Abi) -> HRESULT
}}
impl IShareTargetActivatedEventArgs {
    #[inline] pub fn get_share_operation(&self) -> Result<Option<super::datatransfer::sharetarget::ShareOperation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ShareOperation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::datatransfer::sharetarget::ShareOperation::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ShareTargetActivatedEventArgs: IShareTargetActivatedEventArgs}
DEFINE_IID!(IID_ISplashScreen, 3394082652, 54486, 17392, 151, 192, 8, 51, 198, 57, 28, 36);
RT_INTERFACE!{interface ISplashScreen(ISplashScreenVtbl): IInspectable [IID_ISplashScreen] {
    fn get_ImageLocation(&self, out: *mut foundation::Rect) -> HRESULT,
    fn add_Dismissed(&self, handler: <foundation::TypedEventHandler<SplashScreen, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Dismissed(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ISplashScreen {
    #[inline] pub fn get_image_location(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ImageLocation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_dismissed(&self, handler: &foundation::TypedEventHandler<SplashScreen, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_Dismissed)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_dismissed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_Dismissed)(self.get_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SplashScreen: ISplashScreen}
DEFINE_IID!(IID_IStartupTaskActivatedEventArgs, 61938264, 21110, 19857, 134, 33, 84, 97, 24, 100, 213, 250);
RT_INTERFACE!{interface IStartupTaskActivatedEventArgs(IStartupTaskActivatedEventArgsVtbl): IInspectable [IID_IStartupTaskActivatedEventArgs] {
    fn get_TaskId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IStartupTaskActivatedEventArgs {
    #[inline] pub fn get_task_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TaskId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class StartupTaskActivatedEventArgs: IStartupTaskActivatedEventArgs}
DEFINE_IID!(IID_ITileActivatedInfo, 2162467761, 14720, 20247, 183, 56, 137, 25, 78, 11, 143, 101);
RT_INTERFACE!{interface ITileActivatedInfo(ITileActivatedInfoVtbl): IInspectable [IID_ITileActivatedInfo] {
    #[cfg(feature="windows-ui")] fn get_RecentlyShownNotifications(&self, out: *mut <foundation::collections::IVectorView<super::super::ui::notifications::ShownTileNotification> as RtType>::Abi) -> HRESULT
}}
impl ITileActivatedInfo {
    #[cfg(feature="windows-ui")] #[inline] pub fn get_recently_shown_notifications(&self) -> Result<Option<foundation::collections::IVectorView<super::super::ui::notifications::ShownTileNotification>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RecentlyShownNotifications)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class TileActivatedInfo: ITileActivatedInfo}
DEFINE_IID!(IID_IToastNotificationActivatedEventArgs, 2460512130, 21136, 17181, 190, 133, 196, 170, 238, 184, 104, 95);
RT_INTERFACE!{interface IToastNotificationActivatedEventArgs(IToastNotificationActivatedEventArgsVtbl): IInspectable [IID_IToastNotificationActivatedEventArgs] {
    fn get_Argument(&self, out: *mut HSTRING) -> HRESULT,
    fn get_UserInput(&self, out: *mut <foundation::collections::ValueSet as RtType>::Abi) -> HRESULT
}}
impl IToastNotificationActivatedEventArgs {
    #[inline] pub fn get_argument(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Argument)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_user_input(&self) -> Result<Option<foundation::collections::ValueSet>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_UserInput)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::ValueSet::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ToastNotificationActivatedEventArgs: IToastNotificationActivatedEventArgs}
DEFINE_IID!(IID_IUserDataAccountProviderActivatedEventArgs, 466220835, 36593, 19025, 166, 58, 254, 113, 30, 234, 182, 7);
RT_INTERFACE!{interface IUserDataAccountProviderActivatedEventArgs(IUserDataAccountProviderActivatedEventArgsVtbl): IInspectable [IID_IUserDataAccountProviderActivatedEventArgs] {
    fn get_Operation(&self, out: *mut <super::userdataaccounts::provider::IUserDataAccountProviderOperation as RtType>::Abi) -> HRESULT
}}
impl IUserDataAccountProviderActivatedEventArgs {
    #[inline] pub fn get_operation(&self) -> Result<Option<super::userdataaccounts::provider::IUserDataAccountProviderOperation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Operation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::userdataaccounts::provider::IUserDataAccountProviderOperation::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataAccountProviderActivatedEventArgs: IUserDataAccountProviderActivatedEventArgs}
DEFINE_IID!(IID_IViewSwitcherProvider, 871532710, 23596, 19751, 186, 199, 117, 54, 8, 143, 18, 25);
RT_INTERFACE!{interface IViewSwitcherProvider(IViewSwitcherProviderVtbl): IInspectable [IID_IViewSwitcherProvider] {
    #[cfg(feature="windows-ui")] fn get_ViewSwitcher(&self, out: *mut <super::super::ui::viewmanagement::ActivationViewSwitcher as RtType>::Abi) -> HRESULT
}}
impl IViewSwitcherProvider {
    #[cfg(feature="windows-ui")] #[inline] pub fn get_view_switcher(&self) -> Result<Option<super::super::ui::viewmanagement::ActivationViewSwitcher>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ViewSwitcher)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::ui::viewmanagement::ActivationViewSwitcher::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVoiceCommandActivatedEventArgs, 2878528765, 36163, 19942, 151, 117, 32, 112, 75, 88, 27, 0);
RT_INTERFACE!{interface IVoiceCommandActivatedEventArgs(IVoiceCommandActivatedEventArgsVtbl): IInspectable [IID_IVoiceCommandActivatedEventArgs] {
    #[cfg(feature="windows-media")] fn get_Result(&self, out: *mut <super::super::media::speechrecognition::SpeechRecognitionResult as RtType>::Abi) -> HRESULT
}}
impl IVoiceCommandActivatedEventArgs {
    #[cfg(feature="windows-media")] #[inline] pub fn get_result(&self) -> Result<Option<super::super::media::speechrecognition::SpeechRecognitionResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Result)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::media::speechrecognition::SpeechRecognitionResult::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VoiceCommandActivatedEventArgs: IVoiceCommandActivatedEventArgs}
DEFINE_IID!(IID_IWalletActionActivatedEventArgs, 4244374139, 6682, 19746, 146, 63, 174, 111, 69, 250, 82, 217);
RT_INTERFACE!{interface IWalletActionActivatedEventArgs(IWalletActionActivatedEventArgsVtbl): IInspectable [IID_IWalletActionActivatedEventArgs] {
    fn get_ItemId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ActionKind(&self, out: *mut super::wallet::WalletActionKind) -> HRESULT,
    fn get_ActionId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IWalletActionActivatedEventArgs {
    #[inline] pub fn get_item_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ItemId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_action_kind(&self) -> Result<super::wallet::WalletActionKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ActionKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_action_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ActionId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WalletActionActivatedEventArgs: IWalletActionActivatedEventArgs}
DEFINE_IID!(IID_IWebAccountProviderActivatedEventArgs, 1924601716, 39146, 19663, 151, 82, 70, 217, 5, 16, 4, 241);
RT_INTERFACE!{interface IWebAccountProviderActivatedEventArgs(IWebAccountProviderActivatedEventArgsVtbl): IInspectable [IID_IWebAccountProviderActivatedEventArgs] {
    #[cfg(feature="windows-security")] fn get_Operation(&self, out: *mut <super::super::security::authentication::web::provider::IWebAccountProviderOperation as RtType>::Abi) -> HRESULT
}}
impl IWebAccountProviderActivatedEventArgs {
    #[cfg(feature="windows-security")] #[inline] pub fn get_operation(&self) -> Result<Option<super::super::security::authentication::web::provider::IWebAccountProviderOperation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Operation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::security::authentication::web::provider::IWebAccountProviderOperation::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WebAccountProviderActivatedEventArgs: IWebAccountProviderActivatedEventArgs}
DEFINE_IID!(IID_IWebAuthenticationBrokerContinuationEventArgs, 1977459668, 30484, 17725, 183, 255, 185, 94, 58, 23, 9, 218);
RT_INTERFACE!{interface IWebAuthenticationBrokerContinuationEventArgs(IWebAuthenticationBrokerContinuationEventArgsVtbl): IInspectable [IID_IWebAuthenticationBrokerContinuationEventArgs] {
    #[cfg(feature="windows-security")] fn get_WebAuthenticationResult(&self, out: *mut <super::super::security::authentication::web::WebAuthenticationResult as RtType>::Abi) -> HRESULT
}}
impl IWebAuthenticationBrokerContinuationEventArgs {
    #[cfg(feature="windows-security")] #[inline] pub fn get_web_authentication_result(&self) -> Result<Option<super::super::security::authentication::web::WebAuthenticationResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_WebAuthenticationResult)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::security::authentication::web::WebAuthenticationResult::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WebAuthenticationBrokerContinuationEventArgs: IWebAuthenticationBrokerContinuationEventArgs}
} // Windows.ApplicationModel.Activation
pub mod appextensions { // Windows.ApplicationModel.AppExtensions
use crate::prelude::*;
DEFINE_IID!(IID_IAppExtension, 2219872300, 5613, 20399, 147, 234, 34, 55, 187, 248, 203, 214);
RT_INTERFACE!{interface IAppExtension(IAppExtensionVtbl): IInspectable [IID_IAppExtension] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Package(&self, out: *mut <super::Package as RtType>::Abi) -> HRESULT,
    fn get_AppInfo(&self, out: *mut <super::AppInfo as RtType>::Abi) -> HRESULT,
    fn GetExtensionPropertiesAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IPropertySet> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetPublicFolderAsync(&self, out: *mut <foundation::IAsyncOperation<super::super::storage::StorageFolder> as RtType>::Abi) -> HRESULT
}}
impl IAppExtension {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Description)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_package(&self) -> Result<Option<super::Package>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Package)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::Package::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_app_info(&self) -> Result<Option<super::AppInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppInfo)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::AppInfo::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_extension_properties_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IPropertySet>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetExtensionPropertiesAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_public_folder_async(&self) -> Result<foundation::IAsyncOperation<super::super::storage::StorageFolder>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetPublicFolderAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppExtension: IAppExtension}
DEFINE_IID!(IID_IAppExtensionCatalog, 2542215218, 33830, 19153, 144, 132, 146, 232, 140, 45, 162, 0);
RT_INTERFACE!{interface IAppExtensionCatalog(IAppExtensionCatalogVtbl): IInspectable [IID_IAppExtensionCatalog] {
    fn FindAllAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<AppExtension>> as RtType>::Abi) -> HRESULT,
    fn RequestRemovePackageAsync(&self, packageFullName: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn add_PackageInstalled(&self, handler: <foundation::TypedEventHandler<AppExtensionCatalog, AppExtensionPackageInstalledEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PackageInstalled(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PackageUpdating(&self, handler: <foundation::TypedEventHandler<AppExtensionCatalog, AppExtensionPackageUpdatingEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PackageUpdating(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PackageUpdated(&self, handler: <foundation::TypedEventHandler<AppExtensionCatalog, AppExtensionPackageUpdatedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PackageUpdated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PackageUninstalling(&self, handler: <foundation::TypedEventHandler<AppExtensionCatalog, AppExtensionPackageUninstallingEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PackageUninstalling(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PackageStatusChanged(&self, handler: <foundation::TypedEventHandler<AppExtensionCatalog, AppExtensionPackageStatusChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PackageStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAppExtensionCatalog {
    #[inline] pub fn find_all_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<AppExtension>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindAllAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_remove_package_async(&self, packageFullName: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestRemovePackageAsync)(self.get_abi() as *const _ as *mut _, packageFullName.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_package_installed(&self, handler: &foundation::TypedEventHandler<AppExtensionCatalog, AppExtensionPackageInstalledEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_PackageInstalled)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_package_installed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_PackageInstalled)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_package_updating(&self, handler: &foundation::TypedEventHandler<AppExtensionCatalog, AppExtensionPackageUpdatingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_PackageUpdating)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_package_updating(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_PackageUpdating)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_package_updated(&self, handler: &foundation::TypedEventHandler<AppExtensionCatalog, AppExtensionPackageUpdatedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_PackageUpdated)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_package_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_PackageUpdated)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_package_uninstalling(&self, handler: &foundation::TypedEventHandler<AppExtensionCatalog, AppExtensionPackageUninstallingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_PackageUninstalling)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_package_uninstalling(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_PackageUninstalling)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_package_status_changed(&self, handler: &foundation::TypedEventHandler<AppExtensionCatalog, AppExtensionPackageStatusChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_PackageStatusChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_package_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_PackageStatusChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppExtensionCatalog: IAppExtensionCatalog}
impl RtActivatable<IAppExtensionCatalogStatics> for AppExtensionCatalog {}
impl AppExtensionCatalog {
    #[inline] pub fn open(appExtensionName: &HStringArg) -> Result<Option<AppExtensionCatalog>> {
        <Self as RtActivatable<IAppExtensionCatalogStatics>>::get_activation_factory().open(appExtensionName)
    }
}
DEFINE_CLSID!(AppExtensionCatalog(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,65,112,112,69,120,116,101,110,115,105,111,110,115,46,65,112,112,69,120,116,101,110,115,105,111,110,67,97,116,97,108,111,103,0]) [CLSID_AppExtensionCatalog]);
DEFINE_IID!(IID_IAppExtensionCatalogStatics, 1010198154, 24344, 20235, 156, 229, 202, 182, 29, 25, 111, 17);
RT_INTERFACE!{static interface IAppExtensionCatalogStatics(IAppExtensionCatalogStaticsVtbl): IInspectable [IID_IAppExtensionCatalogStatics] {
    fn Open(&self, appExtensionName: HSTRING, out: *mut <AppExtensionCatalog as RtType>::Abi) -> HRESULT
}}
impl IAppExtensionCatalogStatics {
    #[inline] pub fn open(&self, appExtensionName: &HStringArg) -> Result<Option<AppExtensionCatalog>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Open)(self.get_abi() as *const _ as *mut _, appExtensionName.get(), &mut out);
        if hr == S_OK { Ok(AppExtensionCatalog::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppExtensionPackageInstalledEventArgs, 971346484, 13137, 19085, 151, 69, 231, 211, 221, 69, 188, 72);
RT_INTERFACE!{interface IAppExtensionPackageInstalledEventArgs(IAppExtensionPackageInstalledEventArgsVtbl): IInspectable [IID_IAppExtensionPackageInstalledEventArgs] {
    fn get_AppExtensionName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Package(&self, out: *mut <super::Package as RtType>::Abi) -> HRESULT,
    fn get_Extensions(&self, out: *mut <foundation::collections::IVectorView<AppExtension> as RtType>::Abi) -> HRESULT
}}
impl IAppExtensionPackageInstalledEventArgs {
    #[inline] pub fn get_app_extension_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppExtensionName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_package(&self) -> Result<Option<super::Package>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Package)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::Package::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_extensions(&self) -> Result<Option<foundation::collections::IVectorView<AppExtension>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Extensions)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppExtensionPackageInstalledEventArgs: IAppExtensionPackageInstalledEventArgs}
DEFINE_IID!(IID_IAppExtensionPackageStatusChangedEventArgs, 484537395, 4435, 17661, 135, 177, 138, 225, 5, 3, 3, 223);
RT_INTERFACE!{interface IAppExtensionPackageStatusChangedEventArgs(IAppExtensionPackageStatusChangedEventArgsVtbl): IInspectable [IID_IAppExtensionPackageStatusChangedEventArgs] {
    fn get_AppExtensionName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Package(&self, out: *mut <super::Package as RtType>::Abi) -> HRESULT
}}
impl IAppExtensionPackageStatusChangedEventArgs {
    #[inline] pub fn get_app_extension_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppExtensionName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_package(&self) -> Result<Option<super::Package>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Package)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::Package::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppExtensionPackageStatusChangedEventArgs: IAppExtensionPackageStatusChangedEventArgs}
DEFINE_IID!(IID_IAppExtensionPackageUninstallingEventArgs, 1626431685, 5918, 16639, 174, 152, 171, 44, 32, 221, 77, 117);
RT_INTERFACE!{interface IAppExtensionPackageUninstallingEventArgs(IAppExtensionPackageUninstallingEventArgsVtbl): IInspectable [IID_IAppExtensionPackageUninstallingEventArgs] {
    fn get_AppExtensionName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Package(&self, out: *mut <super::Package as RtType>::Abi) -> HRESULT
}}
impl IAppExtensionPackageUninstallingEventArgs {
    #[inline] pub fn get_app_extension_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppExtensionName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_package(&self) -> Result<Option<super::Package>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Package)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::Package::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppExtensionPackageUninstallingEventArgs: IAppExtensionPackageUninstallingEventArgs}
DEFINE_IID!(IID_IAppExtensionPackageUpdatedEventArgs, 981713983, 31102, 17589, 186, 36, 164, 200, 181, 165, 67, 215);
RT_INTERFACE!{interface IAppExtensionPackageUpdatedEventArgs(IAppExtensionPackageUpdatedEventArgsVtbl): IInspectable [IID_IAppExtensionPackageUpdatedEventArgs] {
    fn get_AppExtensionName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Package(&self, out: *mut <super::Package as RtType>::Abi) -> HRESULT,
    fn get_Extensions(&self, out: *mut <foundation::collections::IVectorView<AppExtension> as RtType>::Abi) -> HRESULT
}}
impl IAppExtensionPackageUpdatedEventArgs {
    #[inline] pub fn get_app_extension_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppExtensionName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_package(&self) -> Result<Option<super::Package>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Package)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::Package::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_extensions(&self) -> Result<Option<foundation::collections::IVectorView<AppExtension>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Extensions)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppExtensionPackageUpdatedEventArgs: IAppExtensionPackageUpdatedEventArgs}
DEFINE_IID!(IID_IAppExtensionPackageUpdatingEventArgs, 2127926057, 6757, 18432, 167, 0, 179, 33, 0, 158, 48, 106);
RT_INTERFACE!{interface IAppExtensionPackageUpdatingEventArgs(IAppExtensionPackageUpdatingEventArgsVtbl): IInspectable [IID_IAppExtensionPackageUpdatingEventArgs] {
    fn get_AppExtensionName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Package(&self, out: *mut <super::Package as RtType>::Abi) -> HRESULT
}}
impl IAppExtensionPackageUpdatingEventArgs {
    #[inline] pub fn get_app_extension_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppExtensionName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_package(&self) -> Result<Option<super::Package>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Package)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::Package::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppExtensionPackageUpdatingEventArgs: IAppExtensionPackageUpdatingEventArgs}
} // Windows.ApplicationModel.AppExtensions
pub mod appservice { // Windows.ApplicationModel.AppService
use crate::prelude::*;
RT_CLASS!{static class AppServiceCatalog}
impl RtActivatable<IAppServiceCatalogStatics> for AppServiceCatalog {}
impl AppServiceCatalog {
    #[inline] pub fn find_app_service_providers_async(appServiceName: &HStringArg) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<super::AppInfo>>> {
        <Self as RtActivatable<IAppServiceCatalogStatics>>::get_activation_factory().find_app_service_providers_async(appServiceName)
    }
}
DEFINE_CLSID!(AppServiceCatalog(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,65,112,112,83,101,114,118,105,99,101,46,65,112,112,83,101,114,118,105,99,101,67,97,116,97,108,111,103,0]) [CLSID_AppServiceCatalog]);
DEFINE_IID!(IID_IAppServiceCatalogStatics, 4010616071, 53554, 19589, 131, 149, 60, 49, 213, 161, 233, 65);
RT_INTERFACE!{static interface IAppServiceCatalogStatics(IAppServiceCatalogStaticsVtbl): IInspectable [IID_IAppServiceCatalogStatics] {
    fn FindAppServiceProvidersAsync(&self, appServiceName: HSTRING, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<super::AppInfo>> as RtType>::Abi) -> HRESULT
}}
impl IAppServiceCatalogStatics {
    #[inline] pub fn find_app_service_providers_async(&self, appServiceName: &HStringArg) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<super::AppInfo>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindAppServiceProvidersAsync)(self.get_abi() as *const _ as *mut _, appServiceName.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppServiceClosedEventArgs, 3730839286, 51971, 19765, 172, 141, 204, 99, 3, 35, 151, 49);
RT_INTERFACE!{interface IAppServiceClosedEventArgs(IAppServiceClosedEventArgsVtbl): IInspectable [IID_IAppServiceClosedEventArgs] {
    fn get_Status(&self, out: *mut AppServiceClosedStatus) -> HRESULT
}}
impl IAppServiceClosedEventArgs {
    #[inline] pub fn get_status(&self) -> Result<AppServiceClosedStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppServiceClosedEventArgs: IAppServiceClosedEventArgs}
RT_ENUM! { enum AppServiceClosedStatus: i32 {
    Completed = 0, Canceled = 1, ResourceLimitsExceeded = 2, Unknown = 3,
}}
DEFINE_IID!(IID_IAppServiceConnection, 2647946402, 34591, 19794, 137, 169, 158, 9, 5, 49, 189, 39);
RT_INTERFACE!{interface IAppServiceConnection(IAppServiceConnectionVtbl): IInspectable [IID_IAppServiceConnection] {
    fn get_AppServiceName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AppServiceName(&self, value: HSTRING) -> HRESULT,
    fn get_PackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PackageFamilyName(&self, value: HSTRING) -> HRESULT,
    fn OpenAsync(&self, out: *mut <foundation::IAsyncOperation<AppServiceConnectionStatus> as RtType>::Abi) -> HRESULT,
    fn SendMessageAsync(&self, message: <foundation::collections::ValueSet as RtType>::Abi, out: *mut <foundation::IAsyncOperation<AppServiceResponse> as RtType>::Abi) -> HRESULT,
    fn add_RequestReceived(&self, handler: <foundation::TypedEventHandler<AppServiceConnection, AppServiceRequestReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RequestReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ServiceClosed(&self, handler: <foundation::TypedEventHandler<AppServiceConnection, AppServiceClosedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ServiceClosed(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAppServiceConnection {
    #[inline] pub fn get_app_service_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppServiceName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_app_service_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AppServiceName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_package_family_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PackageFamilyName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_package_family_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_PackageFamilyName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn open_async(&self) -> Result<foundation::IAsyncOperation<AppServiceConnectionStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().OpenAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn send_message_async(&self, message: &foundation::collections::ValueSet) -> Result<foundation::IAsyncOperation<AppServiceResponse>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SendMessageAsync)(self.get_abi() as *const _ as *mut _, message.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_request_received(&self, handler: &foundation::TypedEventHandler<AppServiceConnection, AppServiceRequestReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_RequestReceived)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_request_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_RequestReceived)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_service_closed(&self, handler: &foundation::TypedEventHandler<AppServiceConnection, AppServiceClosedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_ServiceClosed)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_service_closed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_ServiceClosed)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppServiceConnection: IAppServiceConnection}
impl RtActivatable<IActivationFactory> for AppServiceConnection {}
DEFINE_CLSID!(AppServiceConnection(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,65,112,112,83,101,114,118,105,99,101,46,65,112,112,83,101,114,118,105,99,101,67,111,110,110,101,99,116,105,111,110,0]) [CLSID_AppServiceConnection]);
DEFINE_IID!(IID_IAppServiceConnection2, 2346700127, 8962, 20413, 128, 97, 82, 81, 28, 47, 139, 249);
RT_INTERFACE!{interface IAppServiceConnection2(IAppServiceConnection2Vtbl): IInspectable [IID_IAppServiceConnection2] {
    #[cfg(feature="windows-system")] fn OpenRemoteAsync(&self, remoteSystemConnectionRequest: <super::super::system::remotesystems::RemoteSystemConnectionRequest as RtType>::Abi, out: *mut <foundation::IAsyncOperation<AppServiceConnectionStatus> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut <super::super::system::User as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-system")] fn put_User(&self, value: <super::super::system::User as RtType>::Abi) -> HRESULT
}}
impl IAppServiceConnection2 {
    #[cfg(feature="windows-system")] #[inline] pub fn open_remote_async(&self, remoteSystemConnectionRequest: &super::super::system::remotesystems::RemoteSystemConnectionRequest) -> Result<foundation::IAsyncOperation<AppServiceConnectionStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().OpenRemoteAsync)(self.get_abi() as *const _ as *mut _, remoteSystemConnectionRequest.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_user(&self) -> Result<Option<super::super::system::User>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_User)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::system::User::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn set_user(&self, value: &super::super::system::User) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_User)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum AppServiceConnectionStatus: i32 {
    Success = 0, AppNotInstalled = 1, AppUnavailable = 2, AppServiceUnavailable = 3, Unknown = 4, RemoteSystemUnavailable = 5, RemoteSystemNotSupportedByApp = 6, NotAuthorized = 7,
}}
DEFINE_IID!(IID_IAppServiceDeferral, 2115719970, 60080, 16968, 174, 4, 253, 249, 56, 56, 228, 114);
RT_INTERFACE!{interface IAppServiceDeferral(IAppServiceDeferralVtbl): IInspectable [IID_IAppServiceDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IAppServiceDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Complete)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppServiceDeferral: IAppServiceDeferral}
DEFINE_IID!(IID_IAppServiceRequest, 551914909, 6366, 19201, 128, 186, 144, 167, 98, 4, 227, 200);
RT_INTERFACE!{interface IAppServiceRequest(IAppServiceRequestVtbl): IInspectable [IID_IAppServiceRequest] {
    fn get_Message(&self, out: *mut <foundation::collections::ValueSet as RtType>::Abi) -> HRESULT,
    fn SendResponseAsync(&self, message: <foundation::collections::ValueSet as RtType>::Abi, out: *mut <foundation::IAsyncOperation<AppServiceResponseStatus> as RtType>::Abi) -> HRESULT
}}
impl IAppServiceRequest {
    #[inline] pub fn get_message(&self) -> Result<Option<foundation::collections::ValueSet>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Message)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::ValueSet::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn send_response_async(&self, message: &foundation::collections::ValueSet) -> Result<foundation::IAsyncOperation<AppServiceResponseStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SendResponseAsync)(self.get_abi() as *const _ as *mut _, message.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppServiceRequest: IAppServiceRequest}
DEFINE_IID!(IID_IAppServiceRequestReceivedEventArgs, 1846682464, 65381, 17582, 158, 69, 133, 127, 228, 24, 6, 129);
RT_INTERFACE!{interface IAppServiceRequestReceivedEventArgs(IAppServiceRequestReceivedEventArgsVtbl): IInspectable [IID_IAppServiceRequestReceivedEventArgs] {
    fn get_Request(&self, out: *mut <AppServiceRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <AppServiceDeferral as RtType>::Abi) -> HRESULT
}}
impl IAppServiceRequestReceivedEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<AppServiceRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppServiceRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<AppServiceDeferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppServiceDeferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppServiceRequestReceivedEventArgs: IAppServiceRequestReceivedEventArgs}
DEFINE_IID!(IID_IAppServiceResponse, 2370845932, 39587, 20072, 149, 89, 157, 230, 62, 55, 44, 228);
RT_INTERFACE!{interface IAppServiceResponse(IAppServiceResponseVtbl): IInspectable [IID_IAppServiceResponse] {
    fn get_Message(&self, out: *mut <foundation::collections::ValueSet as RtType>::Abi) -> HRESULT,
    fn get_Status(&self, out: *mut AppServiceResponseStatus) -> HRESULT
}}
impl IAppServiceResponse {
    #[inline] pub fn get_message(&self) -> Result<Option<foundation::collections::ValueSet>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Message)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::ValueSet::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<AppServiceResponseStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppServiceResponse: IAppServiceResponse}
RT_ENUM! { enum AppServiceResponseStatus: i32 {
    Success = 0, Failure = 1, ResourceLimitsExceeded = 2, Unknown = 3, RemoteSystemUnavailable = 4, MessageSizeTooLarge = 5,
}}
DEFINE_IID!(IID_IAppServiceTriggerDetails, 2292374700, 44328, 16824, 128, 187, 189, 241, 178, 22, 158, 25);
RT_INTERFACE!{interface IAppServiceTriggerDetails(IAppServiceTriggerDetailsVtbl): IInspectable [IID_IAppServiceTriggerDetails] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CallerPackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppServiceConnection(&self, out: *mut <AppServiceConnection as RtType>::Abi) -> HRESULT
}}
impl IAppServiceTriggerDetails {
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Name)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_caller_package_family_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CallerPackageFamilyName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_app_service_connection(&self) -> Result<Option<AppServiceConnection>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppServiceConnection)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppServiceConnection::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppServiceTriggerDetails: IAppServiceTriggerDetails}
DEFINE_IID!(IID_IAppServiceTriggerDetails2, 3896333490, 10444, 17394, 180, 101, 192, 72, 46, 89, 226, 220);
RT_INTERFACE!{interface IAppServiceTriggerDetails2(IAppServiceTriggerDetails2Vtbl): IInspectable [IID_IAppServiceTriggerDetails2] {
    fn get_IsRemoteSystemConnection(&self, out: *mut bool) -> HRESULT
}}
impl IAppServiceTriggerDetails2 {
    #[inline] pub fn get_is_remote_system_connection(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsRemoteSystemConnection)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppServiceTriggerDetails3, 4225179169, 31033, 20072, 158, 60, 119, 128, 20, 122, 171, 182);
RT_INTERFACE!{interface IAppServiceTriggerDetails3(IAppServiceTriggerDetails3Vtbl): IInspectable [IID_IAppServiceTriggerDetails3] {
    fn CheckCallerForCapabilityAsync(&self, capabilityName: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl IAppServiceTriggerDetails3 {
    #[inline] pub fn check_caller_for_capability_async(&self, capabilityName: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CheckCallerForCapabilityAsync)(self.get_abi() as *const _ as *mut _, capabilityName.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
} // Windows.ApplicationModel.AppService
pub mod appointments { // Windows.ApplicationModel.Appointments
use crate::prelude::*;
DEFINE_IID!(IID_IAppointment, 3707776815, 11229, 16502, 144, 163, 34, 194, 117, 49, 41, 101);
RT_INTERFACE!{interface IAppointment(IAppointmentVtbl): IInspectable [IID_IAppointment] {
    fn get_StartTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn put_StartTime(&self, value: foundation::DateTime) -> HRESULT,
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_Duration(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_Location(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Location(&self, value: HSTRING) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Subject(&self, value: HSTRING) -> HRESULT,
    fn get_Details(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Details(&self, value: HSTRING) -> HRESULT,
    fn get_Reminder(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn put_Reminder(&self, value: <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_Organizer(&self, out: *mut <AppointmentOrganizer as RtType>::Abi) -> HRESULT,
    fn put_Organizer(&self, value: <AppointmentOrganizer as RtType>::Abi) -> HRESULT,
    fn get_Invitees(&self, out: *mut <foundation::collections::IVector<AppointmentInvitee> as RtType>::Abi) -> HRESULT,
    fn get_Recurrence(&self, out: *mut <AppointmentRecurrence as RtType>::Abi) -> HRESULT,
    fn put_Recurrence(&self, value: <AppointmentRecurrence as RtType>::Abi) -> HRESULT,
    fn get_BusyStatus(&self, out: *mut AppointmentBusyStatus) -> HRESULT,
    fn put_BusyStatus(&self, value: AppointmentBusyStatus) -> HRESULT,
    fn get_AllDay(&self, out: *mut bool) -> HRESULT,
    fn put_AllDay(&self, value: bool) -> HRESULT,
    fn get_Sensitivity(&self, out: *mut AppointmentSensitivity) -> HRESULT,
    fn put_Sensitivity(&self, value: AppointmentSensitivity) -> HRESULT,
    fn get_Uri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_Uri(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT
}}
impl IAppointment {
    #[inline] pub fn get_start_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_StartTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_start_time(&self, value: foundation::DateTime) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_StartTime)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Duration)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_duration(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Duration)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_location(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Location)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_location(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Location)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_subject(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Subject)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_subject(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Subject)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_details(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Details)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_details(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Details)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_reminder(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Reminder)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_reminder(&self, value: &foundation::IReference<foundation::TimeSpan>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Reminder)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_organizer(&self) -> Result<Option<AppointmentOrganizer>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Organizer)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppointmentOrganizer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_organizer(&self, value: &AppointmentOrganizer) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Organizer)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_invitees(&self) -> Result<Option<foundation::collections::IVector<AppointmentInvitee>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Invitees)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_recurrence(&self) -> Result<Option<AppointmentRecurrence>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Recurrence)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppointmentRecurrence::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_recurrence(&self, value: &AppointmentRecurrence) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Recurrence)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_busy_status(&self) -> Result<AppointmentBusyStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_BusyStatus)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_busy_status(&self, value: AppointmentBusyStatus) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_BusyStatus)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_all_day(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AllDay)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_all_day(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AllDay)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sensitivity(&self) -> Result<AppointmentSensitivity> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Sensitivity)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_sensitivity(&self, value: AppointmentSensitivity) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Sensitivity)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Uri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Uri)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Appointment: IAppointment}
impl RtActivatable<IActivationFactory> for Appointment {}
DEFINE_CLSID!(Appointment(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,65,112,112,111,105,110,116,109,101,110,116,115,46,65,112,112,111,105,110,116,109,101,110,116,0]) [CLSID_Appointment]);
DEFINE_IID!(IID_IAppointment2, 1585813564, 21519, 13394, 155, 92, 13, 215, 173, 76, 101, 162);
RT_INTERFACE!{interface IAppointment2(IAppointment2Vtbl): IInspectable [IID_IAppointment2] {
    fn get_LocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CalendarId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RoamingId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RoamingId(&self, value: HSTRING) -> HRESULT,
    fn get_OriginalStartTime(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_IsResponseRequested(&self, out: *mut bool) -> HRESULT,
    fn put_IsResponseRequested(&self, value: bool) -> HRESULT,
    fn get_AllowNewTimeProposal(&self, out: *mut bool) -> HRESULT,
    fn put_AllowNewTimeProposal(&self, value: bool) -> HRESULT,
    fn get_OnlineMeetingLink(&self, out: *mut HSTRING) -> HRESULT,
    fn put_OnlineMeetingLink(&self, value: HSTRING) -> HRESULT,
    fn get_ReplyTime(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn put_ReplyTime(&self, value: <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_UserResponse(&self, out: *mut AppointmentParticipantResponse) -> HRESULT,
    fn put_UserResponse(&self, value: AppointmentParticipantResponse) -> HRESULT,
    fn get_HasInvitees(&self, out: *mut bool) -> HRESULT,
    fn get_IsCanceledMeeting(&self, out: *mut bool) -> HRESULT,
    fn put_IsCanceledMeeting(&self, value: bool) -> HRESULT,
    fn get_IsOrganizedByUser(&self, out: *mut bool) -> HRESULT,
    fn put_IsOrganizedByUser(&self, value: bool) -> HRESULT
}}
impl IAppointment2 {
    #[inline] pub fn get_local_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LocalId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_calendar_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CalendarId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_roaming_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RoamingId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_roaming_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RoamingId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_original_start_time(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_OriginalStartTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_response_requested(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsResponseRequested)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_response_requested(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsResponseRequested)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_allow_new_time_proposal(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AllowNewTimeProposal)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_allow_new_time_proposal(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AllowNewTimeProposal)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_online_meeting_link(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_OnlineMeetingLink)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_online_meeting_link(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_OnlineMeetingLink)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_reply_time(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ReplyTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_reply_time(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ReplyTime)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_user_response(&self) -> Result<AppointmentParticipantResponse> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_UserResponse)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_user_response(&self, value: AppointmentParticipantResponse) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_UserResponse)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_has_invitees(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_HasInvitees)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_canceled_meeting(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsCanceledMeeting)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_canceled_meeting(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsCanceledMeeting)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_organized_by_user(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsOrganizedByUser)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_organized_by_user(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsOrganizedByUser)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppointment3, 3217835433, 35169, 18833, 147, 75, 196, 135, 104, 229, 169, 108);
RT_INTERFACE!{interface IAppointment3(IAppointment3Vtbl): IInspectable [IID_IAppointment3] {
    fn get_ChangeNumber(&self, out: *mut u64) -> HRESULT,
    fn get_RemoteChangeNumber(&self, out: *mut u64) -> HRESULT,
    fn put_RemoteChangeNumber(&self, value: u64) -> HRESULT,
    fn get_DetailsKind(&self, out: *mut AppointmentDetailsKind) -> HRESULT,
    fn put_DetailsKind(&self, value: AppointmentDetailsKind) -> HRESULT
}}
impl IAppointment3 {
    #[inline] pub fn get_change_number(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ChangeNumber)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_remote_change_number(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_RemoteChangeNumber)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_remote_change_number(&self, value: u64) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RemoteChangeNumber)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_details_kind(&self) -> Result<AppointmentDetailsKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DetailsKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_details_kind(&self, value: AppointmentDetailsKind) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DetailsKind)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum AppointmentBusyStatus: i32 {
    Busy = 0, Tentative = 1, Free = 2, OutOfOffice = 3, WorkingElsewhere = 4,
}}
DEFINE_IID!(IID_IAppointmentCalendar, 1383301533, 33593, 15695, 160, 47, 100, 8, 68, 82, 187, 93);
RT_INTERFACE!{interface IAppointmentCalendar(IAppointmentCalendarVtbl): IInspectable [IID_IAppointmentCalendar] {
    #[cfg(not(feature="windows-ui"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_DisplayColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_LocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsHidden(&self, out: *mut bool) -> HRESULT,
    fn get_OtherAppReadAccess(&self, out: *mut AppointmentCalendarOtherAppReadAccess) -> HRESULT,
    fn put_OtherAppReadAccess(&self, value: AppointmentCalendarOtherAppReadAccess) -> HRESULT,
    fn get_OtherAppWriteAccess(&self, out: *mut AppointmentCalendarOtherAppWriteAccess) -> HRESULT,
    fn put_OtherAppWriteAccess(&self, value: AppointmentCalendarOtherAppWriteAccess) -> HRESULT,
    fn get_SourceDisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SummaryCardView(&self, out: *mut AppointmentSummaryCardView) -> HRESULT,
    fn put_SummaryCardView(&self, value: AppointmentSummaryCardView) -> HRESULT,
    fn FindAppointmentsAsync(&self, rangeStart: foundation::DateTime, rangeLength: foundation::TimeSpan, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<Appointment>> as RtType>::Abi) -> HRESULT,
    fn FindAppointmentsAsyncWithOptions(&self, rangeStart: foundation::DateTime, rangeLength: foundation::TimeSpan, options: <FindAppointmentsOptions as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<Appointment>> as RtType>::Abi) -> HRESULT,
    fn FindExceptionsFromMasterAsync(&self, masterLocalId: HSTRING, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<AppointmentException>> as RtType>::Abi) -> HRESULT,
    fn FindAllInstancesAsync(&self, masterLocalId: HSTRING, rangeStart: foundation::DateTime, rangeLength: foundation::TimeSpan, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<Appointment>> as RtType>::Abi) -> HRESULT,
    fn FindAllInstancesAsyncWithOptions(&self, masterLocalId: HSTRING, rangeStart: foundation::DateTime, rangeLength: foundation::TimeSpan, pOptions: <FindAppointmentsOptions as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<Appointment>> as RtType>::Abi) -> HRESULT,
    fn GetAppointmentAsync(&self, localId: HSTRING, out: *mut <foundation::IAsyncOperation<Appointment> as RtType>::Abi) -> HRESULT,
    fn GetAppointmentInstanceAsync(&self, localId: HSTRING, instanceStartTime: foundation::DateTime, out: *mut <foundation::IAsyncOperation<Appointment> as RtType>::Abi) -> HRESULT,
    fn FindUnexpandedAppointmentsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<Appointment>> as RtType>::Abi) -> HRESULT,
    fn FindUnexpandedAppointmentsAsyncWithOptions(&self, options: <FindAppointmentsOptions as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<Appointment>> as RtType>::Abi) -> HRESULT,
    fn DeleteAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn SaveAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn DeleteAppointmentAsync(&self, localId: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn DeleteAppointmentInstanceAsync(&self, localId: HSTRING, instanceStartTime: foundation::DateTime, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn SaveAppointmentAsync(&self, pAppointment: <Appointment as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IAppointmentCalendar {
    #[cfg(feature="windows-ui")] #[inline] pub fn get_display_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DisplayColor)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_local_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LocalId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_hidden(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsHidden)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_other_app_read_access(&self) -> Result<AppointmentCalendarOtherAppReadAccess> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_OtherAppReadAccess)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_other_app_read_access(&self, value: AppointmentCalendarOtherAppReadAccess) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_OtherAppReadAccess)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_other_app_write_access(&self) -> Result<AppointmentCalendarOtherAppWriteAccess> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_OtherAppWriteAccess)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_other_app_write_access(&self, value: AppointmentCalendarOtherAppWriteAccess) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_OtherAppWriteAccess)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_source_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SourceDisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_summary_card_view(&self) -> Result<AppointmentSummaryCardView> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SummaryCardView)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_summary_card_view(&self, value: AppointmentSummaryCardView) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SummaryCardView)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn find_appointments_async(&self, rangeStart: foundation::DateTime, rangeLength: foundation::TimeSpan) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<Appointment>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindAppointmentsAsync)(self.get_abi() as *const _ as *mut _, rangeStart, rangeLength, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_appointments_async_with_options(&self, rangeStart: foundation::DateTime, rangeLength: foundation::TimeSpan, options: &FindAppointmentsOptions) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<Appointment>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindAppointmentsAsyncWithOptions)(self.get_abi() as *const _ as *mut _, rangeStart, rangeLength, options.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_exceptions_from_master_async(&self, masterLocalId: &HStringArg) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<AppointmentException>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindExceptionsFromMasterAsync)(self.get_abi() as *const _ as *mut _, masterLocalId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_instances_async(&self, masterLocalId: &HStringArg, rangeStart: foundation::DateTime, rangeLength: foundation::TimeSpan) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<Appointment>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindAllInstancesAsync)(self.get_abi() as *const _ as *mut _, masterLocalId.get(), rangeStart, rangeLength, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_instances_async_with_options(&self, masterLocalId: &HStringArg, rangeStart: foundation::DateTime, rangeLength: foundation::TimeSpan, pOptions: &FindAppointmentsOptions) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<Appointment>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindAllInstancesAsyncWithOptions)(self.get_abi() as *const _ as *mut _, masterLocalId.get(), rangeStart, rangeLength, pOptions.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_appointment_async(&self, localId: &HStringArg) -> Result<foundation::IAsyncOperation<Appointment>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetAppointmentAsync)(self.get_abi() as *const _ as *mut _, localId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_appointment_instance_async(&self, localId: &HStringArg, instanceStartTime: foundation::DateTime) -> Result<foundation::IAsyncOperation<Appointment>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetAppointmentInstanceAsync)(self.get_abi() as *const _ as *mut _, localId.get(), instanceStartTime, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_unexpanded_appointments_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<Appointment>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindUnexpandedAppointmentsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_unexpanded_appointments_async_with_options(&self, options: &FindAppointmentsOptions) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<Appointment>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindUnexpandedAppointmentsAsyncWithOptions)(self.get_abi() as *const _ as *mut _, options.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn save_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SaveAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_appointment_async(&self, localId: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteAppointmentAsync)(self.get_abi() as *const _ as *mut _, localId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_appointment_instance_async(&self, localId: &HStringArg, instanceStartTime: foundation::DateTime) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteAppointmentInstanceAsync)(self.get_abi() as *const _ as *mut _, localId.get(), instanceStartTime, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn save_appointment_async(&self, pAppointment: &Appointment) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SaveAppointmentAsync)(self.get_abi() as *const _ as *mut _, pAppointment.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentCalendar: IAppointmentCalendar}
DEFINE_IID!(IID_IAppointmentCalendar2, 417850402, 9319, 19996, 164, 89, 216, 162, 147, 3, 208, 146);
RT_INTERFACE!{interface IAppointmentCalendar2(IAppointmentCalendar2Vtbl): IInspectable [IID_IAppointmentCalendar2] {
    fn get_SyncManager(&self, out: *mut <AppointmentCalendarSyncManager as RtType>::Abi) -> HRESULT,
    fn get_RemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RemoteId(&self, value: HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_DisplayColor(&self, value: super::super::ui::Color) -> HRESULT,
    fn put_IsHidden(&self, value: bool) -> HRESULT,
    fn get_UserDataAccountId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CanCreateOrUpdateAppointments(&self, out: *mut bool) -> HRESULT,
    fn put_CanCreateOrUpdateAppointments(&self, value: bool) -> HRESULT,
    fn get_CanCancelMeetings(&self, out: *mut bool) -> HRESULT,
    fn put_CanCancelMeetings(&self, value: bool) -> HRESULT,
    fn get_CanForwardMeetings(&self, out: *mut bool) -> HRESULT,
    fn put_CanForwardMeetings(&self, value: bool) -> HRESULT,
    fn get_CanProposeNewTimeForMeetings(&self, out: *mut bool) -> HRESULT,
    fn put_CanProposeNewTimeForMeetings(&self, value: bool) -> HRESULT,
    fn get_CanUpdateMeetingResponses(&self, out: *mut bool) -> HRESULT,
    fn put_CanUpdateMeetingResponses(&self, value: bool) -> HRESULT,
    fn get_CanNotifyInvitees(&self, out: *mut bool) -> HRESULT,
    fn put_CanNotifyInvitees(&self, value: bool) -> HRESULT,
    fn get_MustNofityInvitees(&self, out: *mut bool) -> HRESULT,
    fn put_MustNofityInvitees(&self, value: bool) -> HRESULT,
    fn TryCreateOrUpdateAppointmentAsync(&self, appointment: <Appointment as RtType>::Abi, notifyInvitees: bool, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryCancelMeetingAsync(&self, meeting: <Appointment as RtType>::Abi, subject: HSTRING, comment: HSTRING, notifyInvitees: bool, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryForwardMeetingAsync(&self, meeting: <Appointment as RtType>::Abi, invitees: <foundation::collections::IIterable<AppointmentInvitee> as RtType>::Abi, subject: HSTRING, forwardHeader: HSTRING, comment: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryProposeNewTimeForMeetingAsync(&self, meeting: <Appointment as RtType>::Abi, newStartTime: foundation::DateTime, newDuration: foundation::TimeSpan, subject: HSTRING, comment: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryUpdateMeetingResponseAsync(&self, meeting: <Appointment as RtType>::Abi, response: AppointmentParticipantResponse, subject: HSTRING, comment: HSTRING, sendUpdate: bool, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl IAppointmentCalendar2 {
    #[inline] pub fn get_sync_manager(&self) -> Result<Option<AppointmentCalendarSyncManager>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SyncManager)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppointmentCalendarSyncManager::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_remote_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RemoteId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_remote_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RemoteId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_display_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayColor)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_is_hidden(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsHidden)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_user_data_account_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_UserDataAccountId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_can_create_or_update_appointments(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanCreateOrUpdateAppointments)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_can_create_or_update_appointments(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanCreateOrUpdateAppointments)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_can_cancel_meetings(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanCancelMeetings)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_can_cancel_meetings(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanCancelMeetings)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_can_forward_meetings(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanForwardMeetings)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_can_forward_meetings(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanForwardMeetings)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_can_propose_new_time_for_meetings(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanProposeNewTimeForMeetings)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_can_propose_new_time_for_meetings(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanProposeNewTimeForMeetings)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_can_update_meeting_responses(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanUpdateMeetingResponses)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_can_update_meeting_responses(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanUpdateMeetingResponses)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_can_notify_invitees(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanNotifyInvitees)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_can_notify_invitees(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanNotifyInvitees)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_must_nofity_invitees(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MustNofityInvitees)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_must_nofity_invitees(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MustNofityInvitees)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_create_or_update_appointment_async(&self, appointment: &Appointment, notifyInvitees: bool) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryCreateOrUpdateAppointmentAsync)(self.get_abi() as *const _ as *mut _, appointment.get_abi() as *const _ as *mut _, notifyInvitees, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_cancel_meeting_async(&self, meeting: &Appointment, subject: &HStringArg, comment: &HStringArg, notifyInvitees: bool) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryCancelMeetingAsync)(self.get_abi() as *const _ as *mut _, meeting.get_abi() as *const _ as *mut _, subject.get(), comment.get(), notifyInvitees, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_forward_meeting_async(&self, meeting: &Appointment, invitees: &foundation::collections::IIterable<AppointmentInvitee>, subject: &HStringArg, forwardHeader: &HStringArg, comment: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryForwardMeetingAsync)(self.get_abi() as *const _ as *mut _, meeting.get_abi() as *const _ as *mut _, invitees.get_abi() as *const _ as *mut _, subject.get(), forwardHeader.get(), comment.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_propose_new_time_for_meeting_async(&self, meeting: &Appointment, newStartTime: foundation::DateTime, newDuration: foundation::TimeSpan, subject: &HStringArg, comment: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryProposeNewTimeForMeetingAsync)(self.get_abi() as *const _ as *mut _, meeting.get_abi() as *const _ as *mut _, newStartTime, newDuration, subject.get(), comment.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_update_meeting_response_async(&self, meeting: &Appointment, response: AppointmentParticipantResponse, subject: &HStringArg, comment: &HStringArg, sendUpdate: bool) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryUpdateMeetingResponseAsync)(self.get_abi() as *const _ as *mut _, meeting.get_abi() as *const _ as *mut _, response, subject.get(), comment.get(), sendUpdate, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppointmentCalendar3, 3944993323, 42629, 17070, 132, 149, 179, 17, 154, 219, 65, 103);
RT_INTERFACE!{interface IAppointmentCalendar3(IAppointmentCalendar3Vtbl): IInspectable [IID_IAppointmentCalendar3] {
    fn RegisterSyncManagerAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IAppointmentCalendar3 {
    #[inline] pub fn register_sync_manager_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RegisterSyncManagerAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum AppointmentCalendarOtherAppReadAccess: i32 {
    SystemOnly = 0, Limited = 1, Full = 2, None = 3,
}}
RT_ENUM! { enum AppointmentCalendarOtherAppWriteAccess: i32 {
    None = 0, SystemOnly = 1, Limited = 2,
}}
DEFINE_IID!(IID_IAppointmentCalendarSyncManager, 723628960, 19199, 17298, 188, 95, 86, 69, 255, 207, 251, 23);
RT_INTERFACE!{interface IAppointmentCalendarSyncManager(IAppointmentCalendarSyncManagerVtbl): IInspectable [IID_IAppointmentCalendarSyncManager] {
    fn get_Status(&self, out: *mut AppointmentCalendarSyncStatus) -> HRESULT,
    fn get_LastSuccessfulSyncTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_LastAttemptedSyncTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn SyncAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn add_SyncStatusChanged(&self, handler: <foundation::TypedEventHandler<AppointmentCalendarSyncManager, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SyncStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAppointmentCalendarSyncManager {
    #[inline] pub fn get_status(&self) -> Result<AppointmentCalendarSyncStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_last_successful_sync_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_LastSuccessfulSyncTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_last_attempted_sync_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_LastAttemptedSyncTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn sync_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SyncAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_sync_status_changed(&self, handler: &foundation::TypedEventHandler<AppointmentCalendarSyncManager, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_SyncStatusChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_sync_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_SyncStatusChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentCalendarSyncManager: IAppointmentCalendarSyncManager}
DEFINE_IID!(IID_IAppointmentCalendarSyncManager2, 1685399725, 3369, 19580, 170, 167, 191, 153, 104, 5, 83, 124);
RT_INTERFACE!{interface IAppointmentCalendarSyncManager2(IAppointmentCalendarSyncManager2Vtbl): IInspectable [IID_IAppointmentCalendarSyncManager2] {
    fn put_Status(&self, value: AppointmentCalendarSyncStatus) -> HRESULT,
    fn put_LastSuccessfulSyncTime(&self, value: foundation::DateTime) -> HRESULT,
    fn put_LastAttemptedSyncTime(&self, value: foundation::DateTime) -> HRESULT
}}
impl IAppointmentCalendarSyncManager2 {
    #[inline] pub fn set_status(&self, value: AppointmentCalendarSyncStatus) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Status)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_last_successful_sync_time(&self, value: foundation::DateTime) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_LastSuccessfulSyncTime)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_last_attempted_sync_time(&self, value: foundation::DateTime) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_LastAttemptedSyncTime)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum AppointmentCalendarSyncStatus: i32 {
    Idle = 0, Syncing = 1, UpToDate = 2, AuthenticationError = 3, PolicyError = 4, UnknownError = 5, ManualAccountRemovalRequired = 6,
}}
DEFINE_IID!(IID_IAppointmentConflictResult, 3587043518, 12079, 15229, 175, 10, 167, 226, 15, 58, 70, 227);
RT_INTERFACE!{interface IAppointmentConflictResult(IAppointmentConflictResultVtbl): IInspectable [IID_IAppointmentConflictResult] {
    fn get_Type(&self, out: *mut AppointmentConflictType) -> HRESULT,
    fn get_Date(&self, out: *mut foundation::DateTime) -> HRESULT
}}
impl IAppointmentConflictResult {
    #[inline] pub fn get_type(&self) -> Result<AppointmentConflictType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Type)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_date(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Date)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentConflictResult: IAppointmentConflictResult}
RT_ENUM! { enum AppointmentConflictType: i32 {
    None = 0, Adjacent = 1, Overlap = 2,
}}
RT_ENUM! { enum AppointmentDaysOfWeek: u32 {
    None = 0, Sunday = 1, Monday = 2, Tuesday = 4, Wednesday = 8, Thursday = 16, Friday = 32, Saturday = 64,
}}
RT_ENUM! { enum AppointmentDetailsKind: i32 {
    PlainText = 0, Html = 1,
}}
DEFINE_IID!(IID_IAppointmentException, 2718394215, 5878, 19406, 159, 90, 134, 0, 184, 1, 159, 203);
RT_INTERFACE!{interface IAppointmentException(IAppointmentExceptionVtbl): IInspectable [IID_IAppointmentException] {
    fn get_Appointment(&self, out: *mut <Appointment as RtType>::Abi) -> HRESULT,
    fn get_ExceptionProperties(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT,
    fn get_IsDeleted(&self, out: *mut bool) -> HRESULT
}}
impl IAppointmentException {
    #[inline] pub fn get_appointment(&self) -> Result<Option<Appointment>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Appointment)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Appointment::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_exception_properties(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ExceptionProperties)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_deleted(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsDeleted)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentException: IAppointmentException}
DEFINE_IID!(IID_IAppointmentInvitee, 331286422, 38978, 18779, 176, 231, 239, 143, 121, 192, 112, 29);
RT_INTERFACE!{interface IAppointmentInvitee(IAppointmentInviteeVtbl): IInspectable [IID_IAppointmentInvitee] {
    fn get_Role(&self, out: *mut AppointmentParticipantRole) -> HRESULT,
    fn put_Role(&self, value: AppointmentParticipantRole) -> HRESULT,
    fn get_Response(&self, out: *mut AppointmentParticipantResponse) -> HRESULT,
    fn put_Response(&self, value: AppointmentParticipantResponse) -> HRESULT
}}
impl IAppointmentInvitee {
    #[inline] pub fn get_role(&self) -> Result<AppointmentParticipantRole> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Role)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_role(&self, value: AppointmentParticipantRole) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Role)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_response(&self) -> Result<AppointmentParticipantResponse> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Response)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_response(&self, value: AppointmentParticipantResponse) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Response)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentInvitee: IAppointmentInvitee}
impl RtActivatable<IActivationFactory> for AppointmentInvitee {}
DEFINE_CLSID!(AppointmentInvitee(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,65,112,112,111,105,110,116,109,101,110,116,115,46,65,112,112,111,105,110,116,109,101,110,116,73,110,118,105,116,101,101,0]) [CLSID_AppointmentInvitee]);
RT_CLASS!{static class AppointmentManager}
impl RtActivatable<IAppointmentManagerStatics> for AppointmentManager {}
impl RtActivatable<IAppointmentManagerStatics2> for AppointmentManager {}
impl RtActivatable<IAppointmentManagerStatics3> for AppointmentManager {}
impl AppointmentManager {
    #[inline] pub fn show_add_appointment_async(appointment: &Appointment, selection: foundation::Rect) -> Result<foundation::IAsyncOperation<HString>> {
        <Self as RtActivatable<IAppointmentManagerStatics>>::get_activation_factory().show_add_appointment_async(appointment, selection)
    }
    #[cfg(feature="windows-ui")] #[inline] pub fn show_add_appointment_with_placement_async(appointment: &Appointment, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<foundation::IAsyncOperation<HString>> {
        <Self as RtActivatable<IAppointmentManagerStatics>>::get_activation_factory().show_add_appointment_with_placement_async(appointment, selection, preferredPlacement)
    }
    #[inline] pub fn show_replace_appointment_async(appointmentId: &HStringArg, appointment: &Appointment, selection: foundation::Rect) -> Result<foundation::IAsyncOperation<HString>> {
        <Self as RtActivatable<IAppointmentManagerStatics>>::get_activation_factory().show_replace_appointment_async(appointmentId, appointment, selection)
    }
    #[cfg(feature="windows-ui")] #[inline] pub fn show_replace_appointment_with_placement_async(appointmentId: &HStringArg, appointment: &Appointment, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<foundation::IAsyncOperation<HString>> {
        <Self as RtActivatable<IAppointmentManagerStatics>>::get_activation_factory().show_replace_appointment_with_placement_async(appointmentId, appointment, selection, preferredPlacement)
    }
    #[cfg(feature="windows-ui")] #[inline] pub fn show_replace_appointment_with_placement_and_date_async(appointmentId: &HStringArg, appointment: &Appointment, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: foundation::DateTime) -> Result<foundation::IAsyncOperation<HString>> {
        <Self as RtActivatable<IAppointmentManagerStatics>>::get_activation_factory().show_replace_appointment_with_placement_and_date_async(appointmentId, appointment, selection, preferredPlacement, instanceStartDate)
    }
    #[inline] pub fn show_remove_appointment_async(appointmentId: &HStringArg, selection: foundation::Rect) -> Result<foundation::IAsyncOperation<bool>> {
        <Self as RtActivatable<IAppointmentManagerStatics>>::get_activation_factory().show_remove_appointment_async(appointmentId, selection)
    }
    #[cfg(feature="windows-ui")] #[inline] pub fn show_remove_appointment_with_placement_async(appointmentId: &HStringArg, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<foundation::IAsyncOperation<bool>> {
        <Self as RtActivatable<IAppointmentManagerStatics>>::get_activation_factory().show_remove_appointment_with_placement_async(appointmentId, selection, preferredPlacement)
    }
    #[cfg(feature="windows-ui")] #[inline] pub fn show_remove_appointment_with_placement_and_date_async(appointmentId: &HStringArg, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: foundation::DateTime) -> Result<foundation::IAsyncOperation<bool>> {
        <Self as RtActivatable<IAppointmentManagerStatics>>::get_activation_factory().show_remove_appointment_with_placement_and_date_async(appointmentId, selection, preferredPlacement, instanceStartDate)
    }
    #[inline] pub fn show_time_frame_async(timeToShow: foundation::DateTime, duration: foundation::TimeSpan) -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<IAppointmentManagerStatics>>::get_activation_factory().show_time_frame_async(timeToShow, duration)
    }
    #[inline] pub fn show_appointment_details_async(appointmentId: &HStringArg) -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<IAppointmentManagerStatics2>>::get_activation_factory().show_appointment_details_async(appointmentId)
    }
    #[inline] pub fn show_appointment_details_with_date_async(appointmentId: &HStringArg, instanceStartDate: foundation::DateTime) -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<IAppointmentManagerStatics2>>::get_activation_factory().show_appointment_details_with_date_async(appointmentId, instanceStartDate)
    }
    #[inline] pub fn show_edit_new_appointment_async(appointment: &Appointment) -> Result<foundation::IAsyncOperation<HString>> {
        <Self as RtActivatable<IAppointmentManagerStatics2>>::get_activation_factory().show_edit_new_appointment_async(appointment)
    }
    #[inline] pub fn request_store_async(options: AppointmentStoreAccessType) -> Result<foundation::IAsyncOperation<AppointmentStore>> {
        <Self as RtActivatable<IAppointmentManagerStatics2>>::get_activation_factory().request_store_async(options)
    }
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(user: &super::super::system::User) -> Result<Option<AppointmentManagerForUser>> {
        <Self as RtActivatable<IAppointmentManagerStatics3>>::get_activation_factory().get_for_user(user)
    }
}
DEFINE_CLSID!(AppointmentManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,65,112,112,111,105,110,116,109,101,110,116,115,46,65,112,112,111,105,110,116,109,101,110,116,77,97,110,97,103,101,114,0]) [CLSID_AppointmentManager]);
DEFINE_IID!(IID_IAppointmentManagerForUser, 1881543715, 29644, 18016, 179, 24, 176, 19, 101, 48, 42, 3);
RT_INTERFACE!{interface IAppointmentManagerForUser(IAppointmentManagerForUserVtbl): IInspectable [IID_IAppointmentManagerForUser] {
    fn ShowAddAppointmentAsync(&self, appointment: <Appointment as RtType>::Abi, selection: foundation::Rect, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowAddAppointmentWithPlacementAsync(&self, appointment: <Appointment as RtType>::Abi, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn ShowReplaceAppointmentAsync(&self, appointmentId: HSTRING, appointment: <Appointment as RtType>::Abi, selection: foundation::Rect, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowReplaceAppointmentWithPlacementAsync(&self, appointmentId: HSTRING, appointment: <Appointment as RtType>::Abi, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowReplaceAppointmentWithPlacementAndDateAsync(&self, appointmentId: HSTRING, appointment: <Appointment as RtType>::Abi, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: foundation::DateTime, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn ShowRemoveAppointmentAsync(&self, appointmentId: HSTRING, selection: foundation::Rect, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowRemoveAppointmentWithPlacementAsync(&self, appointmentId: HSTRING, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowRemoveAppointmentWithPlacementAndDateAsync(&self, appointmentId: HSTRING, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: foundation::DateTime, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn ShowTimeFrameAsync(&self, timeToShow: foundation::DateTime, duration: foundation::TimeSpan, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ShowAppointmentDetailsAsync(&self, appointmentId: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ShowAppointmentDetailsWithDateAsync(&self, appointmentId: HSTRING, instanceStartDate: foundation::DateTime, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ShowEditNewAppointmentAsync(&self, appointment: <Appointment as RtType>::Abi, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn RequestStoreAsync(&self, options: AppointmentStoreAccessType, out: *mut <foundation::IAsyncOperation<AppointmentStore> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut <super::super::system::User as RtType>::Abi) -> HRESULT
}}
impl IAppointmentManagerForUser {
    #[inline] pub fn show_add_appointment_async(&self, appointment: &Appointment, selection: foundation::Rect) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowAddAppointmentAsync)(self.get_abi() as *const _ as *mut _, appointment.get_abi() as *const _ as *mut _, selection, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_add_appointment_with_placement_async(&self, appointment: &Appointment, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowAddAppointmentWithPlacementAsync)(self.get_abi() as *const _ as *mut _, appointment.get_abi() as *const _ as *mut _, selection, preferredPlacement, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_replace_appointment_async(&self, appointmentId: &HStringArg, appointment: &Appointment, selection: foundation::Rect) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowReplaceAppointmentAsync)(self.get_abi() as *const _ as *mut _, appointmentId.get(), appointment.get_abi() as *const _ as *mut _, selection, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_replace_appointment_with_placement_async(&self, appointmentId: &HStringArg, appointment: &Appointment, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowReplaceAppointmentWithPlacementAsync)(self.get_abi() as *const _ as *mut _, appointmentId.get(), appointment.get_abi() as *const _ as *mut _, selection, preferredPlacement, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_replace_appointment_with_placement_and_date_async(&self, appointmentId: &HStringArg, appointment: &Appointment, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: foundation::DateTime) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowReplaceAppointmentWithPlacementAndDateAsync)(self.get_abi() as *const _ as *mut _, appointmentId.get(), appointment.get_abi() as *const _ as *mut _, selection, preferredPlacement, instanceStartDate, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_remove_appointment_async(&self, appointmentId: &HStringArg, selection: foundation::Rect) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowRemoveAppointmentAsync)(self.get_abi() as *const _ as *mut _, appointmentId.get(), selection, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_remove_appointment_with_placement_async(&self, appointmentId: &HStringArg, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowRemoveAppointmentWithPlacementAsync)(self.get_abi() as *const _ as *mut _, appointmentId.get(), selection, preferredPlacement, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_remove_appointment_with_placement_and_date_async(&self, appointmentId: &HStringArg, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: foundation::DateTime) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowRemoveAppointmentWithPlacementAndDateAsync)(self.get_abi() as *const _ as *mut _, appointmentId.get(), selection, preferredPlacement, instanceStartDate, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_time_frame_async(&self, timeToShow: foundation::DateTime, duration: foundation::TimeSpan) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowTimeFrameAsync)(self.get_abi() as *const _ as *mut _, timeToShow, duration, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_appointment_details_async(&self, appointmentId: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowAppointmentDetailsAsync)(self.get_abi() as *const _ as *mut _, appointmentId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_appointment_details_with_date_async(&self, appointmentId: &HStringArg, instanceStartDate: foundation::DateTime) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowAppointmentDetailsWithDateAsync)(self.get_abi() as *const _ as *mut _, appointmentId.get(), instanceStartDate, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_edit_new_appointment_async(&self, appointment: &Appointment) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowEditNewAppointmentAsync)(self.get_abi() as *const _ as *mut _, appointment.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_store_async(&self, options: AppointmentStoreAccessType) -> Result<foundation::IAsyncOperation<AppointmentStore>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestStoreAsync)(self.get_abi() as *const _ as *mut _, options, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_user(&self) -> Result<Option<super::super::system::User>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_User)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::system::User::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentManagerForUser: IAppointmentManagerForUser}
DEFINE_IID!(IID_IAppointmentManagerStatics, 976288257, 23616, 18845, 179, 63, 164, 48, 80, 247, 79, 196);
RT_INTERFACE!{static interface IAppointmentManagerStatics(IAppointmentManagerStaticsVtbl): IInspectable [IID_IAppointmentManagerStatics] {
    fn ShowAddAppointmentAsync(&self, appointment: <Appointment as RtType>::Abi, selection: foundation::Rect, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowAddAppointmentWithPlacementAsync(&self, appointment: <Appointment as RtType>::Abi, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn ShowReplaceAppointmentAsync(&self, appointmentId: HSTRING, appointment: <Appointment as RtType>::Abi, selection: foundation::Rect, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowReplaceAppointmentWithPlacementAsync(&self, appointmentId: HSTRING, appointment: <Appointment as RtType>::Abi, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowReplaceAppointmentWithPlacementAndDateAsync(&self, appointmentId: HSTRING, appointment: <Appointment as RtType>::Abi, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: foundation::DateTime, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn ShowRemoveAppointmentAsync(&self, appointmentId: HSTRING, selection: foundation::Rect, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowRemoveAppointmentWithPlacementAsync(&self, appointmentId: HSTRING, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowRemoveAppointmentWithPlacementAndDateAsync(&self, appointmentId: HSTRING, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: foundation::DateTime, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn ShowTimeFrameAsync(&self, timeToShow: foundation::DateTime, duration: foundation::TimeSpan, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IAppointmentManagerStatics {
    #[inline] pub fn show_add_appointment_async(&self, appointment: &Appointment, selection: foundation::Rect) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowAddAppointmentAsync)(self.get_abi() as *const _ as *mut _, appointment.get_abi() as *const _ as *mut _, selection, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_add_appointment_with_placement_async(&self, appointment: &Appointment, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowAddAppointmentWithPlacementAsync)(self.get_abi() as *const _ as *mut _, appointment.get_abi() as *const _ as *mut _, selection, preferredPlacement, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_replace_appointment_async(&self, appointmentId: &HStringArg, appointment: &Appointment, selection: foundation::Rect) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowReplaceAppointmentAsync)(self.get_abi() as *const _ as *mut _, appointmentId.get(), appointment.get_abi() as *const _ as *mut _, selection, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_replace_appointment_with_placement_async(&self, appointmentId: &HStringArg, appointment: &Appointment, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowReplaceAppointmentWithPlacementAsync)(self.get_abi() as *const _ as *mut _, appointmentId.get(), appointment.get_abi() as *const _ as *mut _, selection, preferredPlacement, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_replace_appointment_with_placement_and_date_async(&self, appointmentId: &HStringArg, appointment: &Appointment, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: foundation::DateTime) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowReplaceAppointmentWithPlacementAndDateAsync)(self.get_abi() as *const _ as *mut _, appointmentId.get(), appointment.get_abi() as *const _ as *mut _, selection, preferredPlacement, instanceStartDate, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_remove_appointment_async(&self, appointmentId: &HStringArg, selection: foundation::Rect) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowRemoveAppointmentAsync)(self.get_abi() as *const _ as *mut _, appointmentId.get(), selection, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_remove_appointment_with_placement_async(&self, appointmentId: &HStringArg, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowRemoveAppointmentWithPlacementAsync)(self.get_abi() as *const _ as *mut _, appointmentId.get(), selection, preferredPlacement, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_remove_appointment_with_placement_and_date_async(&self, appointmentId: &HStringArg, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: foundation::DateTime) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowRemoveAppointmentWithPlacementAndDateAsync)(self.get_abi() as *const _ as *mut _, appointmentId.get(), selection, preferredPlacement, instanceStartDate, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_time_frame_async(&self, timeToShow: foundation::DateTime, duration: foundation::TimeSpan) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowTimeFrameAsync)(self.get_abi() as *const _ as *mut _, timeToShow, duration, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppointmentManagerStatics2, 176289293, 53327, 16436, 175, 114, 163, 101, 115, 180, 95, 240);
RT_INTERFACE!{static interface IAppointmentManagerStatics2(IAppointmentManagerStatics2Vtbl): IInspectable [IID_IAppointmentManagerStatics2] {
    fn ShowAppointmentDetailsAsync(&self, appointmentId: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ShowAppointmentDetailsWithDateAsync(&self, appointmentId: HSTRING, instanceStartDate: foundation::DateTime, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ShowEditNewAppointmentAsync(&self, appointment: <Appointment as RtType>::Abi, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn RequestStoreAsync(&self, options: AppointmentStoreAccessType, out: *mut <foundation::IAsyncOperation<AppointmentStore> as RtType>::Abi) -> HRESULT
}}
impl IAppointmentManagerStatics2 {
    #[inline] pub fn show_appointment_details_async(&self, appointmentId: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowAppointmentDetailsAsync)(self.get_abi() as *const _ as *mut _, appointmentId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_appointment_details_with_date_async(&self, appointmentId: &HStringArg, instanceStartDate: foundation::DateTime) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowAppointmentDetailsWithDateAsync)(self.get_abi() as *const _ as *mut _, appointmentId.get(), instanceStartDate, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_edit_new_appointment_async(&self, appointment: &Appointment) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowEditNewAppointmentAsync)(self.get_abi() as *const _ as *mut _, appointment.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_store_async(&self, options: AppointmentStoreAccessType) -> Result<foundation::IAsyncOperation<AppointmentStore>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestStoreAsync)(self.get_abi() as *const _ as *mut _, options, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppointmentManagerStatics3, 798679196, 45900, 19911, 163, 93, 202, 253, 136, 174, 62, 198);
RT_INTERFACE!{static interface IAppointmentManagerStatics3(IAppointmentManagerStatics3Vtbl): IInspectable [IID_IAppointmentManagerStatics3] {
    #[cfg(feature="windows-system")] fn GetForUser(&self, user: <super::super::system::User as RtType>::Abi, out: *mut <AppointmentManagerForUser as RtType>::Abi) -> HRESULT
}}
impl IAppointmentManagerStatics3 {
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(&self, user: &super::super::system::User) -> Result<Option<AppointmentManagerForUser>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetForUser)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppointmentManagerForUser::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentOrganizer: IAppointmentParticipant}
impl RtActivatable<IActivationFactory> for AppointmentOrganizer {}
DEFINE_CLSID!(AppointmentOrganizer(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,65,112,112,111,105,110,116,109,101,110,116,115,46,65,112,112,111,105,110,116,109,101,110,116,79,114,103,97,110,105,122,101,114,0]) [CLSID_AppointmentOrganizer]);
DEFINE_IID!(IID_IAppointmentParticipant, 1633560834, 38680, 18043, 131, 251, 178, 147, 161, 145, 33, 222);
RT_INTERFACE!{interface IAppointmentParticipant(IAppointmentParticipantVtbl): IInspectable [IID_IAppointmentParticipant] {
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_Address(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Address(&self, value: HSTRING) -> HRESULT
}}
impl IAppointmentParticipant {
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_address(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Address)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_address(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Address)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum AppointmentParticipantResponse: i32 {
    None = 0, Tentative = 1, Accepted = 2, Declined = 3, Unknown = 4,
}}
RT_ENUM! { enum AppointmentParticipantRole: i32 {
    RequiredAttendee = 0, OptionalAttendee = 1, Resource = 2,
}}
RT_CLASS!{static class AppointmentProperties}
impl RtActivatable<IAppointmentPropertiesStatics> for AppointmentProperties {}
impl RtActivatable<IAppointmentPropertiesStatics2> for AppointmentProperties {}
impl AppointmentProperties {
    #[inline] pub fn get_subject() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_subject()
    }
    #[inline] pub fn get_location() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_location()
    }
    #[inline] pub fn get_start_time() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_start_time()
    }
    #[inline] pub fn get_duration() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_duration()
    }
    #[inline] pub fn get_reminder() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_reminder()
    }
    #[inline] pub fn get_busy_status() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_busy_status()
    }
    #[inline] pub fn get_sensitivity() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_sensitivity()
    }
    #[inline] pub fn get_original_start_time() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_original_start_time()
    }
    #[inline] pub fn get_is_response_requested() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_is_response_requested()
    }
    #[inline] pub fn get_allow_new_time_proposal() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_allow_new_time_proposal()
    }
    #[inline] pub fn get_all_day() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_all_day()
    }
    #[inline] pub fn get_details() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_details()
    }
    #[inline] pub fn get_online_meeting_link() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_online_meeting_link()
    }
    #[inline] pub fn get_reply_time() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_reply_time()
    }
    #[inline] pub fn get_organizer() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_organizer()
    }
    #[inline] pub fn get_user_response() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_user_response()
    }
    #[inline] pub fn get_has_invitees() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_has_invitees()
    }
    #[inline] pub fn get_is_canceled_meeting() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_is_canceled_meeting()
    }
    #[inline] pub fn get_is_organized_by_user() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_is_organized_by_user()
    }
    #[inline] pub fn get_recurrence() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_recurrence()
    }
    #[inline] pub fn get_uri() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_uri()
    }
    #[inline] pub fn get_invitees() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_invitees()
    }
    #[inline] pub fn get_default_properties() -> Result<Option<foundation::collections::IVector<HString>>> {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_default_properties()
    }
    #[inline] pub fn get_change_number() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics2>>::get_activation_factory().get_change_number()
    }
    #[inline] pub fn get_remote_change_number() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics2>>::get_activation_factory().get_remote_change_number()
    }
    #[inline] pub fn get_details_kind() -> Result<HString> {
        <Self as RtActivatable<IAppointmentPropertiesStatics2>>::get_activation_factory().get_details_kind()
    }
}
DEFINE_CLSID!(AppointmentProperties(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,65,112,112,111,105,110,116,109,101,110,116,115,46,65,112,112,111,105,110,116,109,101,110,116,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_AppointmentProperties]);
DEFINE_IID!(IID_IAppointmentPropertiesStatics, 622075881, 26798, 15022, 133, 95, 188, 68, 65, 202, 162, 52);
RT_INTERFACE!{static interface IAppointmentPropertiesStatics(IAppointmentPropertiesStaticsVtbl): IInspectable [IID_IAppointmentPropertiesStatics] {
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Location(&self, out: *mut HSTRING) -> HRESULT,
    fn get_StartTime(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Duration(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Reminder(&self, out: *mut HSTRING) -> HRESULT,
    fn get_BusyStatus(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Sensitivity(&self, out: *mut HSTRING) -> HRESULT,
    fn get_OriginalStartTime(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsResponseRequested(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AllowNewTimeProposal(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AllDay(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Details(&self, out: *mut HSTRING) -> HRESULT,
    fn get_OnlineMeetingLink(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ReplyTime(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Organizer(&self, out: *mut HSTRING) -> HRESULT,
    fn get_UserResponse(&self, out: *mut HSTRING) -> HRESULT,
    fn get_HasInvitees(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsCanceledMeeting(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsOrganizedByUser(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Recurrence(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Uri(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Invitees(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DefaultProperties(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT
}}
impl IAppointmentPropertiesStatics {
    #[inline] pub fn get_subject(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Subject)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_location(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Location)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_start_time(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_StartTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Duration)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_reminder(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Reminder)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_busy_status(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_BusyStatus)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sensitivity(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Sensitivity)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_original_start_time(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_OriginalStartTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_response_requested(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_IsResponseRequested)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_allow_new_time_proposal(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AllowNewTimeProposal)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_all_day(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AllDay)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_details(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Details)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_online_meeting_link(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_OnlineMeetingLink)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_reply_time(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ReplyTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_organizer(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Organizer)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_user_response(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_UserResponse)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_has_invitees(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_HasInvitees)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_canceled_meeting(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_IsCanceledMeeting)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_organized_by_user(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_IsOrganizedByUser)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_recurrence(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Recurrence)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_uri(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Uri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_invitees(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Invitees)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_properties(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DefaultProperties)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppointmentPropertiesStatics2, 3757851467, 45079, 17885, 138, 245, 209, 99, 209, 8, 1, 187);
RT_INTERFACE!{static interface IAppointmentPropertiesStatics2(IAppointmentPropertiesStatics2Vtbl): IInspectable [IID_IAppointmentPropertiesStatics2] {
    fn get_ChangeNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RemoteChangeNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DetailsKind(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAppointmentPropertiesStatics2 {
    #[inline] pub fn get_change_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ChangeNumber)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_remote_change_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RemoteChangeNumber)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_details_kind(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DetailsKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppointmentRecurrence, 3631955587, 5542, 18555, 185, 89, 12, 54, 30, 96, 233, 84);
RT_INTERFACE!{interface IAppointmentRecurrence(IAppointmentRecurrenceVtbl): IInspectable [IID_IAppointmentRecurrence] {
    fn get_Unit(&self, out: *mut AppointmentRecurrenceUnit) -> HRESULT,
    fn put_Unit(&self, value: AppointmentRecurrenceUnit) -> HRESULT,
    fn get_Occurrences(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn put_Occurrences(&self, value: <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_Until(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn put_Until(&self, value: <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_Interval(&self, out: *mut u32) -> HRESULT,
    fn put_Interval(&self, value: u32) -> HRESULT,
    fn get_DaysOfWeek(&self, out: *mut AppointmentDaysOfWeek) -> HRESULT,
    fn put_DaysOfWeek(&self, value: AppointmentDaysOfWeek) -> HRESULT,
    fn get_WeekOfMonth(&self, out: *mut AppointmentWeekOfMonth) -> HRESULT,
    fn put_WeekOfMonth(&self, value: AppointmentWeekOfMonth) -> HRESULT,
    fn get_Month(&self, out: *mut u32) -> HRESULT,
    fn put_Month(&self, value: u32) -> HRESULT,
    fn get_Day(&self, out: *mut u32) -> HRESULT,
    fn put_Day(&self, value: u32) -> HRESULT
}}
impl IAppointmentRecurrence {
    #[inline] pub fn get_unit(&self) -> Result<AppointmentRecurrenceUnit> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Unit)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_unit(&self, value: AppointmentRecurrenceUnit) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Unit)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_occurrences(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Occurrences)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_occurrences(&self, value: &foundation::IReference<u32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Occurrences)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_until(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Until)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_until(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Until)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Interval)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Interval)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_days_of_week(&self) -> Result<AppointmentDaysOfWeek> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DaysOfWeek)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_days_of_week(&self, value: AppointmentDaysOfWeek) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DaysOfWeek)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_week_of_month(&self) -> Result<AppointmentWeekOfMonth> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_WeekOfMonth)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_week_of_month(&self, value: AppointmentWeekOfMonth) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_WeekOfMonth)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_month(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Month)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_month(&self, value: u32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Month)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_day(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Day)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_day(&self, value: u32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Day)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentRecurrence: IAppointmentRecurrence}
impl RtActivatable<IActivationFactory> for AppointmentRecurrence {}
DEFINE_CLSID!(AppointmentRecurrence(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,65,112,112,111,105,110,116,109,101,110,116,115,46,65,112,112,111,105,110,116,109,101,110,116,82,101,99,117,114,114,101,110,99,101,0]) [CLSID_AppointmentRecurrence]);
DEFINE_IID!(IID_IAppointmentRecurrence2, 1039377120, 1447, 20304, 159, 134, 176, 63, 148, 54, 37, 77);
RT_INTERFACE!{interface IAppointmentRecurrence2(IAppointmentRecurrence2Vtbl): IInspectable [IID_IAppointmentRecurrence2] {
    fn get_RecurrenceType(&self, out: *mut RecurrenceType) -> HRESULT,
    fn get_TimeZone(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TimeZone(&self, value: HSTRING) -> HRESULT
}}
impl IAppointmentRecurrence2 {
    #[inline] pub fn get_recurrence_type(&self) -> Result<RecurrenceType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_RecurrenceType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_time_zone(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TimeZone)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_time_zone(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_TimeZone)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppointmentRecurrence3, 2315228889, 55885, 18967, 141, 210, 28, 235, 194, 181, 255, 157);
RT_INTERFACE!{interface IAppointmentRecurrence3(IAppointmentRecurrence3Vtbl): IInspectable [IID_IAppointmentRecurrence3] {
    fn get_CalendarIdentifier(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAppointmentRecurrence3 {
    #[inline] pub fn get_calendar_identifier(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CalendarIdentifier)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum AppointmentRecurrenceUnit: i32 {
    Daily = 0, Weekly = 1, Monthly = 2, MonthlyOnDay = 3, Yearly = 4, YearlyOnDay = 5,
}}
RT_ENUM! { enum AppointmentSensitivity: i32 {
    Public = 0, Private = 1,
}}
DEFINE_IID!(IID_IAppointmentStore, 2757857676, 31303, 19862, 150, 201, 21, 205, 138, 5, 167, 53);
RT_INTERFACE!{interface IAppointmentStore(IAppointmentStoreVtbl): IInspectable [IID_IAppointmentStore] {
    fn get_ChangeTracker(&self, out: *mut <AppointmentStoreChangeTracker as RtType>::Abi) -> HRESULT,
    fn CreateAppointmentCalendarAsync(&self, name: HSTRING, out: *mut <foundation::IAsyncOperation<AppointmentCalendar> as RtType>::Abi) -> HRESULT,
    fn GetAppointmentCalendarAsync(&self, calendarId: HSTRING, out: *mut <foundation::IAsyncOperation<AppointmentCalendar> as RtType>::Abi) -> HRESULT,
    fn GetAppointmentAsync(&self, localId: HSTRING, out: *mut <foundation::IAsyncOperation<Appointment> as RtType>::Abi) -> HRESULT,
    fn GetAppointmentInstanceAsync(&self, localId: HSTRING, instanceStartTime: foundation::DateTime, out: *mut <foundation::IAsyncOperation<Appointment> as RtType>::Abi) -> HRESULT,
    fn FindAppointmentCalendarsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<AppointmentCalendar>> as RtType>::Abi) -> HRESULT,
    fn FindAppointmentCalendarsAsyncWithOptions(&self, options: FindAppointmentCalendarsOptions, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<AppointmentCalendar>> as RtType>::Abi) -> HRESULT,
    fn FindAppointmentsAsync(&self, rangeStart: foundation::DateTime, rangeLength: foundation::TimeSpan, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<Appointment>> as RtType>::Abi) -> HRESULT,
    fn FindAppointmentsAsyncWithOptions(&self, rangeStart: foundation::DateTime, rangeLength: foundation::TimeSpan, options: <FindAppointmentsOptions as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<Appointment>> as RtType>::Abi) -> HRESULT,
    fn FindConflictAsync(&self, appointment: <Appointment as RtType>::Abi, out: *mut <foundation::IAsyncOperation<AppointmentConflictResult> as RtType>::Abi) -> HRESULT,
    fn FindConflictAsyncWithInstanceStart(&self, appointment: <Appointment as RtType>::Abi, instanceStartTime: foundation::DateTime, out: *mut <foundation::IAsyncOperation<AppointmentConflictResult> as RtType>::Abi) -> HRESULT,
    fn MoveAppointmentAsync(&self, appointment: <Appointment as RtType>::Abi, destinationCalendar: <AppointmentCalendar as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ShowAddAppointmentAsync(&self, appointment: <Appointment as RtType>::Abi, selection: foundation::Rect, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn ShowReplaceAppointmentAsync(&self, localId: HSTRING, appointment: <Appointment as RtType>::Abi, selection: foundation::Rect, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy14(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowReplaceAppointmentWithPlacementAndDateAsync(&self, localId: HSTRING, appointment: <Appointment as RtType>::Abi, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: foundation::DateTime, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn ShowRemoveAppointmentAsync(&self, localId: HSTRING, selection: foundation::Rect, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy16(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowRemoveAppointmentWithPlacementAndDateAsync(&self, localId: HSTRING, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: foundation::DateTime, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn ShowAppointmentDetailsAsync(&self, localId: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ShowAppointmentDetailsWithDateAsync(&self, localId: HSTRING, instanceStartDate: foundation::DateTime, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ShowEditNewAppointmentAsync(&self, appointment: <Appointment as RtType>::Abi, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn FindLocalIdsFromRoamingIdAsync(&self, roamingId: HSTRING, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<HString>> as RtType>::Abi) -> HRESULT
}}
impl IAppointmentStore {
    #[inline] pub fn get_change_tracker(&self) -> Result<Option<AppointmentStoreChangeTracker>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ChangeTracker)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppointmentStoreChangeTracker::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_appointment_calendar_async(&self, name: &HStringArg) -> Result<foundation::IAsyncOperation<AppointmentCalendar>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateAppointmentCalendarAsync)(self.get_abi() as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_appointment_calendar_async(&self, calendarId: &HStringArg) -> Result<foundation::IAsyncOperation<AppointmentCalendar>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetAppointmentCalendarAsync)(self.get_abi() as *const _ as *mut _, calendarId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_appointment_async(&self, localId: &HStringArg) -> Result<foundation::IAsyncOperation<Appointment>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetAppointmentAsync)(self.get_abi() as *const _ as *mut _, localId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_appointment_instance_async(&self, localId: &HStringArg, instanceStartTime: foundation::DateTime) -> Result<foundation::IAsyncOperation<Appointment>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetAppointmentInstanceAsync)(self.get_abi() as *const _ as *mut _, localId.get(), instanceStartTime, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_appointment_calendars_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<AppointmentCalendar>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindAppointmentCalendarsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_appointment_calendars_async_with_options(&self, options: FindAppointmentCalendarsOptions) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<AppointmentCalendar>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindAppointmentCalendarsAsyncWithOptions)(self.get_abi() as *const _ as *mut _, options, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_appointments_async(&self, rangeStart: foundation::DateTime, rangeLength: foundation::TimeSpan) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<Appointment>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindAppointmentsAsync)(self.get_abi() as *const _ as *mut _, rangeStart, rangeLength, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_appointments_async_with_options(&self, rangeStart: foundation::DateTime, rangeLength: foundation::TimeSpan, options: &FindAppointmentsOptions) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<Appointment>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindAppointmentsAsyncWithOptions)(self.get_abi() as *const _ as *mut _, rangeStart, rangeLength, options.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_conflict_async(&self, appointment: &Appointment) -> Result<foundation::IAsyncOperation<AppointmentConflictResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindConflictAsync)(self.get_abi() as *const _ as *mut _, appointment.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_conflict_async_with_instance_start(&self, appointment: &Appointment, instanceStartTime: foundation::DateTime) -> Result<foundation::IAsyncOperation<AppointmentConflictResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindConflictAsyncWithInstanceStart)(self.get_abi() as *const _ as *mut _, appointment.get_abi() as *const _ as *mut _, instanceStartTime, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn move_appointment_async(&self, appointment: &Appointment, destinationCalendar: &AppointmentCalendar) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().MoveAppointmentAsync)(self.get_abi() as *const _ as *mut _, appointment.get_abi() as *const _ as *mut _, destinationCalendar.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_add_appointment_async(&self, appointment: &Appointment, selection: foundation::Rect) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowAddAppointmentAsync)(self.get_abi() as *const _ as *mut _, appointment.get_abi() as *const _ as *mut _, selection, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_replace_appointment_async(&self, localId: &HStringArg, appointment: &Appointment, selection: foundation::Rect) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowReplaceAppointmentAsync)(self.get_abi() as *const _ as *mut _, localId.get(), appointment.get_abi() as *const _ as *mut _, selection, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_replace_appointment_with_placement_and_date_async(&self, localId: &HStringArg, appointment: &Appointment, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: foundation::DateTime) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowReplaceAppointmentWithPlacementAndDateAsync)(self.get_abi() as *const _ as *mut _, localId.get(), appointment.get_abi() as *const _ as *mut _, selection, preferredPlacement, instanceStartDate, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_remove_appointment_async(&self, localId: &HStringArg, selection: foundation::Rect) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowRemoveAppointmentAsync)(self.get_abi() as *const _ as *mut _, localId.get(), selection, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_remove_appointment_with_placement_and_date_async(&self, localId: &HStringArg, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: foundation::DateTime) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowRemoveAppointmentWithPlacementAndDateAsync)(self.get_abi() as *const _ as *mut _, localId.get(), selection, preferredPlacement, instanceStartDate, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_appointment_details_async(&self, localId: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowAppointmentDetailsAsync)(self.get_abi() as *const _ as *mut _, localId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_appointment_details_with_date_async(&self, localId: &HStringArg, instanceStartDate: foundation::DateTime) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowAppointmentDetailsWithDateAsync)(self.get_abi() as *const _ as *mut _, localId.get(), instanceStartDate, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_edit_new_appointment_async(&self, appointment: &Appointment) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowEditNewAppointmentAsync)(self.get_abi() as *const _ as *mut _, appointment.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_local_ids_from_roaming_id_async(&self, roamingId: &HStringArg) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindLocalIdsFromRoamingIdAsync)(self.get_abi() as *const _ as *mut _, roamingId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentStore: IAppointmentStore}
DEFINE_IID!(IID_IAppointmentStore2, 633637920, 7233, 16975, 128, 132, 103, 193, 207, 224, 168, 84);
RT_INTERFACE!{interface IAppointmentStore2(IAppointmentStore2Vtbl): IInspectable [IID_IAppointmentStore2] {
    fn add_StoreChanged(&self, pHandler: <foundation::TypedEventHandler<AppointmentStore, AppointmentStoreChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StoreChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn CreateAppointmentCalendarInAccountAsync(&self, name: HSTRING, userDataAccountId: HSTRING, out: *mut <foundation::IAsyncOperation<AppointmentCalendar> as RtType>::Abi) -> HRESULT
}}
impl IAppointmentStore2 {
    #[inline] pub fn add_store_changed(&self, pHandler: &foundation::TypedEventHandler<AppointmentStore, AppointmentStoreChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_StoreChanged)(self.get_abi() as *const _ as *mut _, pHandler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_store_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_StoreChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn create_appointment_calendar_in_account_async(&self, name: &HStringArg, userDataAccountId: &HStringArg) -> Result<foundation::IAsyncOperation<AppointmentCalendar>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateAppointmentCalendarInAccountAsync)(self.get_abi() as *const _ as *mut _, name.get(), userDataAccountId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppointmentStore3, 1112642571, 45176, 18186, 154, 64, 194, 224, 23, 97, 247, 47);
RT_INTERFACE!{interface IAppointmentStore3(IAppointmentStore3Vtbl): IInspectable [IID_IAppointmentStore3] {
    fn GetChangeTracker(&self, identity: HSTRING, out: *mut <AppointmentStoreChangeTracker as RtType>::Abi) -> HRESULT
}}
impl IAppointmentStore3 {
    #[inline] pub fn get_change_tracker(&self, identity: &HStringArg) -> Result<Option<AppointmentStoreChangeTracker>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetChangeTracker)(self.get_abi() as *const _ as *mut _, identity.get(), &mut out);
        if hr == S_OK { Ok(AppointmentStoreChangeTracker::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum AppointmentStoreAccessType: i32 {
    AppCalendarsReadWrite = 0, AllCalendarsReadOnly = 1, AllCalendarsReadWrite = 2,
}}
DEFINE_IID!(IID_IAppointmentStoreChange, 2779177013, 2611, 13908, 132, 99, 181, 67, 233, 12, 59, 121);
RT_INTERFACE!{interface IAppointmentStoreChange(IAppointmentStoreChangeVtbl): IInspectable [IID_IAppointmentStoreChange] {
    fn get_Appointment(&self, out: *mut <Appointment as RtType>::Abi) -> HRESULT,
    fn get_ChangeType(&self, out: *mut AppointmentStoreChangeType) -> HRESULT
}}
impl IAppointmentStoreChange {
    #[inline] pub fn get_appointment(&self) -> Result<Option<Appointment>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Appointment)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Appointment::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_change_type(&self) -> Result<AppointmentStoreChangeType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ChangeType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentStoreChange: IAppointmentStoreChange}
DEFINE_IID!(IID_IAppointmentStoreChange2, 3011317198, 21009, 17410, 166, 8, 169, 111, 231, 11, 142, 226);
RT_INTERFACE!{interface IAppointmentStoreChange2(IAppointmentStoreChange2Vtbl): IInspectable [IID_IAppointmentStoreChange2] {
    fn get_AppointmentCalendar(&self, out: *mut <AppointmentCalendar as RtType>::Abi) -> HRESULT
}}
impl IAppointmentStoreChange2 {
    #[inline] pub fn get_appointment_calendar(&self) -> Result<Option<AppointmentCalendar>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppointmentCalendar)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppointmentCalendar::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppointmentStoreChangedDeferral, 1287135270, 65243, 19395, 150, 98, 149, 169, 190, 253, 244, 223);
RT_INTERFACE!{interface IAppointmentStoreChangedDeferral(IAppointmentStoreChangedDeferralVtbl): IInspectable [IID_IAppointmentStoreChangedDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IAppointmentStoreChangedDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Complete)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentStoreChangedDeferral: IAppointmentStoreChangedDeferral}
DEFINE_IID!(IID_IAppointmentStoreChangedEventArgs, 579205305, 1937, 16766, 191, 234, 204, 109, 65, 99, 108, 140);
RT_INTERFACE!{interface IAppointmentStoreChangedEventArgs(IAppointmentStoreChangedEventArgsVtbl): IInspectable [IID_IAppointmentStoreChangedEventArgs] {
    fn GetDeferral(&self, out: *mut <AppointmentStoreChangedDeferral as RtType>::Abi) -> HRESULT
}}
impl IAppointmentStoreChangedEventArgs {
    #[inline] pub fn get_deferral(&self) -> Result<Option<AppointmentStoreChangedDeferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppointmentStoreChangedDeferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentStoreChangedEventArgs: IAppointmentStoreChangedEventArgs}
DEFINE_IID!(IID_IAppointmentStoreChangeReader, 2334394865, 26099, 17056, 150, 29, 76, 32, 155, 243, 3, 112);
RT_INTERFACE!{interface IAppointmentStoreChangeReader(IAppointmentStoreChangeReaderVtbl): IInspectable [IID_IAppointmentStoreChangeReader] {
    fn ReadBatchAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<AppointmentStoreChange>> as RtType>::Abi) -> HRESULT,
    fn AcceptChanges(&self) -> HRESULT,
    fn AcceptChangesThrough(&self, lastChangeToAccept: <AppointmentStoreChange as RtType>::Abi) -> HRESULT
}}
impl IAppointmentStoreChangeReader {
    #[inline] pub fn read_batch_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<AppointmentStoreChange>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReadBatchAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn accept_changes(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().AcceptChanges)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn accept_changes_through(&self, lastChangeToAccept: &AppointmentStoreChange) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().AcceptChangesThrough)(self.get_abi() as *const _ as *mut _, lastChangeToAccept.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentStoreChangeReader: IAppointmentStoreChangeReader}
DEFINE_IID!(IID_IAppointmentStoreChangeTracker, 455472305, 36558, 20247, 147, 200, 230, 65, 36, 88, 253, 92);
RT_INTERFACE!{interface IAppointmentStoreChangeTracker(IAppointmentStoreChangeTrackerVtbl): IInspectable [IID_IAppointmentStoreChangeTracker] {
    fn GetChangeReader(&self, out: *mut <AppointmentStoreChangeReader as RtType>::Abi) -> HRESULT,
    fn Enable(&self) -> HRESULT,
    fn Reset(&self) -> HRESULT
}}
impl IAppointmentStoreChangeTracker {
    #[inline] pub fn get_change_reader(&self) -> Result<Option<AppointmentStoreChangeReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetChangeReader)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppointmentStoreChangeReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn enable(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Enable)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn reset(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Reset)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentStoreChangeTracker: IAppointmentStoreChangeTracker}
DEFINE_IID!(IID_IAppointmentStoreChangeTracker2, 3060444997, 38210, 19703, 133, 80, 235, 55, 14, 12, 8, 211);
RT_INTERFACE!{interface IAppointmentStoreChangeTracker2(IAppointmentStoreChangeTracker2Vtbl): IInspectable [IID_IAppointmentStoreChangeTracker2] {
    fn get_IsTracking(&self, out: *mut bool) -> HRESULT
}}
impl IAppointmentStoreChangeTracker2 {
    #[inline] pub fn get_is_tracking(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsTracking)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum AppointmentStoreChangeType: i32 {
    AppointmentCreated = 0, AppointmentModified = 1, AppointmentDeleted = 2, ChangeTrackingLost = 3, CalendarCreated = 4, CalendarModified = 5, CalendarDeleted = 6,
}}
DEFINE_IID!(IID_IAppointmentStoreNotificationTriggerDetails, 2603862801, 49921, 16926, 175, 239, 4, 126, 207, 167, 106, 219);
RT_INTERFACE!{interface IAppointmentStoreNotificationTriggerDetails(IAppointmentStoreNotificationTriggerDetailsVtbl): IInspectable [IID_IAppointmentStoreNotificationTriggerDetails] {
    
}}
RT_CLASS!{class AppointmentStoreNotificationTriggerDetails: IAppointmentStoreNotificationTriggerDetails}
RT_ENUM! { enum AppointmentSummaryCardView: i32 {
    System = 0, App = 1,
}}
RT_ENUM! { enum AppointmentWeekOfMonth: i32 {
    First = 0, Second = 1, Third = 2, Fourth = 3, Last = 4,
}}
RT_ENUM! { enum FindAppointmentCalendarsOptions: u32 {
    None = 0, IncludeHidden = 1,
}}
DEFINE_IID!(IID_IFindAppointmentsOptions, 1442307157, 39234, 12422, 130, 181, 44, 178, 159, 100, 213, 245);
RT_INTERFACE!{interface IFindAppointmentsOptions(IFindAppointmentsOptionsVtbl): IInspectable [IID_IFindAppointmentsOptions] {
    fn get_CalendarIds(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT,
    fn get_FetchProperties(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT,
    fn get_IncludeHidden(&self, out: *mut bool) -> HRESULT,
    fn put_IncludeHidden(&self, value: bool) -> HRESULT,
    fn get_MaxCount(&self, out: *mut u32) -> HRESULT,
    fn put_MaxCount(&self, value: u32) -> HRESULT
}}
impl IFindAppointmentsOptions {
    #[inline] pub fn get_calendar_ids(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CalendarIds)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_fetch_properties(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_FetchProperties)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_include_hidden(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IncludeHidden)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_include_hidden(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IncludeHidden)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MaxCount)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_max_count(&self, value: u32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxCount)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class FindAppointmentsOptions: IFindAppointmentsOptions}
impl RtActivatable<IActivationFactory> for FindAppointmentsOptions {}
DEFINE_CLSID!(FindAppointmentsOptions(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,65,112,112,111,105,110,116,109,101,110,116,115,46,70,105,110,100,65,112,112,111,105,110,116,109,101,110,116,115,79,112,116,105,111,110,115,0]) [CLSID_FindAppointmentsOptions]);
RT_ENUM! { enum RecurrenceType: i32 {
    Master = 0, Instance = 1, ExceptionInstance = 2,
}}
pub mod appointmentsprovider { // Windows.ApplicationModel.Appointments.AppointmentsProvider
use crate::prelude::*;
DEFINE_IID!(IID_IAddAppointmentOperation, 3964312307, 25101, 19561, 173, 215, 151, 148, 233, 24, 8, 31);
RT_INTERFACE!{interface IAddAppointmentOperation(IAddAppointmentOperationVtbl): IInspectable [IID_IAddAppointmentOperation] {
    fn get_AppointmentInformation(&self, out: *mut <super::Appointment as RtType>::Abi) -> HRESULT,
    fn get_SourcePackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompleted(&self, itemId: HSTRING) -> HRESULT,
    fn ReportCanceled(&self) -> HRESULT,
    fn ReportError(&self, value: HSTRING) -> HRESULT,
    fn DismissUI(&self) -> HRESULT
}}
impl IAddAppointmentOperation {
    #[inline] pub fn get_appointment_information(&self) -> Result<Option<super::Appointment>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppointmentInformation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::Appointment::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_source_package_family_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SourcePackageFamilyName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed(&self, itemId: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportCompleted)(self.get_abi() as *const _ as *mut _, itemId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn report_canceled(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportCanceled)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn report_error(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportError)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn dismiss_ui(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().DismissUI)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AddAppointmentOperation: IAddAppointmentOperation}
RT_CLASS!{static class AppointmentsProviderLaunchActionVerbs}
impl RtActivatable<IAppointmentsProviderLaunchActionVerbsStatics> for AppointmentsProviderLaunchActionVerbs {}
impl RtActivatable<IAppointmentsProviderLaunchActionVerbsStatics2> for AppointmentsProviderLaunchActionVerbs {}
impl AppointmentsProviderLaunchActionVerbs {
    #[inline] pub fn get_add_appointment() -> Result<HString> {
        <Self as RtActivatable<IAppointmentsProviderLaunchActionVerbsStatics>>::get_activation_factory().get_add_appointment()
    }
    #[inline] pub fn get_replace_appointment() -> Result<HString> {
        <Self as RtActivatable<IAppointmentsProviderLaunchActionVerbsStatics>>::get_activation_factory().get_replace_appointment()
    }
    #[inline] pub fn get_remove_appointment() -> Result<HString> {
        <Self as RtActivatable<IAppointmentsProviderLaunchActionVerbsStatics>>::get_activation_factory().get_remove_appointment()
    }
    #[inline] pub fn get_show_time_frame() -> Result<HString> {
        <Self as RtActivatable<IAppointmentsProviderLaunchActionVerbsStatics>>::get_activation_factory().get_show_time_frame()
    }
    #[inline] pub fn get_show_appointment_details() -> Result<HString> {
        <Self as RtActivatable<IAppointmentsProviderLaunchActionVerbsStatics2>>::get_activation_factory().get_show_appointment_details()
    }
}
DEFINE_CLSID!(AppointmentsProviderLaunchActionVerbs(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,65,112,112,111,105,110,116,109,101,110,116,115,46,65,112,112,111,105,110,116,109,101,110,116,115,80,114,111,118,105,100,101,114,46,65,112,112,111,105,110,116,109,101,110,116,115,80,114,111,118,105,100,101,114,76,97,117,110,99,104,65,99,116,105,111,110,86,101,114,98,115,0]) [CLSID_AppointmentsProviderLaunchActionVerbs]);
DEFINE_IID!(IID_IAppointmentsProviderLaunchActionVerbsStatics, 920369704, 40494, 18886, 142, 247, 58, 183, 165, 220, 200, 184);
RT_INTERFACE!{static interface IAppointmentsProviderLaunchActionVerbsStatics(IAppointmentsProviderLaunchActionVerbsStaticsVtbl): IInspectable [IID_IAppointmentsProviderLaunchActionVerbsStatics] {
    fn get_AddAppointment(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ReplaceAppointment(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RemoveAppointment(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ShowTimeFrame(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAppointmentsProviderLaunchActionVerbsStatics {
    #[inline] pub fn get_add_appointment(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AddAppointment)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_replace_appointment(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ReplaceAppointment)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_remove_appointment(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RemoveAppointment)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_show_time_frame(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ShowTimeFrame)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppointmentsProviderLaunchActionVerbsStatics2, 4019210660, 44833, 18236, 136, 220, 118, 205, 137, 246, 12, 165);
RT_INTERFACE!{static interface IAppointmentsProviderLaunchActionVerbsStatics2(IAppointmentsProviderLaunchActionVerbsStatics2Vtbl): IInspectable [IID_IAppointmentsProviderLaunchActionVerbsStatics2] {
    fn get_ShowAppointmentDetails(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAppointmentsProviderLaunchActionVerbsStatics2 {
    #[inline] pub fn get_show_appointment_details(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ShowAppointmentDetails)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRemoveAppointmentOperation, 146172602, 65075, 18125, 165, 12, 168, 255, 179, 38, 5, 55);
RT_INTERFACE!{interface IRemoveAppointmentOperation(IRemoveAppointmentOperationVtbl): IInspectable [IID_IRemoveAppointmentOperation] {
    fn get_AppointmentId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_InstanceStartDate(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_SourcePackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompleted(&self) -> HRESULT,
    fn ReportCanceled(&self) -> HRESULT,
    fn ReportError(&self, value: HSTRING) -> HRESULT,
    fn DismissUI(&self) -> HRESULT
}}
impl IRemoveAppointmentOperation {
    #[inline] pub fn get_appointment_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppointmentId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_instance_start_date(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_InstanceStartDate)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_source_package_family_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SourcePackageFamilyName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportCompleted)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn report_canceled(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportCanceled)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn report_error(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportError)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn dismiss_ui(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().DismissUI)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class RemoveAppointmentOperation: IRemoveAppointmentOperation}
DEFINE_IID!(IID_IReplaceAppointmentOperation, 4103093659, 40545, 19938, 167, 50, 38, 135, 192, 125, 29, 232);
RT_INTERFACE!{interface IReplaceAppointmentOperation(IReplaceAppointmentOperationVtbl): IInspectable [IID_IReplaceAppointmentOperation] {
    fn get_AppointmentId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppointmentInformation(&self, out: *mut <super::Appointment as RtType>::Abi) -> HRESULT,
    fn get_InstanceStartDate(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_SourcePackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompleted(&self, itemId: HSTRING) -> HRESULT,
    fn ReportCanceled(&self) -> HRESULT,
    fn ReportError(&self, value: HSTRING) -> HRESULT,
    fn DismissUI(&self) -> HRESULT
}}
impl IReplaceAppointmentOperation {
    #[inline] pub fn get_appointment_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppointmentId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_appointment_information(&self) -> Result<Option<super::Appointment>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppointmentInformation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::Appointment::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_instance_start_date(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_InstanceStartDate)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_source_package_family_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SourcePackageFamilyName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed(&self, itemId: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportCompleted)(self.get_abi() as *const _ as *mut _, itemId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn report_canceled(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportCanceled)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn report_error(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportError)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn dismiss_ui(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().DismissUI)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ReplaceAppointmentOperation: IReplaceAppointmentOperation}
} // Windows.ApplicationModel.Appointments.AppointmentsProvider
pub mod dataprovider { // Windows.ApplicationModel.Appointments.DataProvider
use crate::prelude::*;
DEFINE_IID!(IID_IAppointmentCalendarCancelMeetingRequest, 1229328269, 25652, 16599, 173, 70, 98, 151, 65, 147, 20, 209);
RT_INTERFACE!{interface IAppointmentCalendarCancelMeetingRequest(IAppointmentCalendarCancelMeetingRequestVtbl): IInspectable [IID_IAppointmentCalendarCancelMeetingRequest] {
    fn get_AppointmentCalendarLocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppointmentLocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppointmentOriginalStartTime(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Comment(&self, out: *mut HSTRING) -> HRESULT,
    fn get_NotifyInvitees(&self, out: *mut bool) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IAppointmentCalendarCancelMeetingRequest {
    #[inline] pub fn get_appointment_calendar_local_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppointmentCalendarLocalId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_appointment_local_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppointmentLocalId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_appointment_original_start_time(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppointmentOriginalStartTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_subject(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Subject)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_comment(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Comment)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_notify_invitees(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_NotifyInvitees)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentCalendarCancelMeetingRequest: IAppointmentCalendarCancelMeetingRequest}
DEFINE_IID!(IID_IAppointmentCalendarCancelMeetingRequestEventArgs, 444186134, 32560, 20021, 190, 239, 157, 44, 123, 109, 202, 225);
RT_INTERFACE!{interface IAppointmentCalendarCancelMeetingRequestEventArgs(IAppointmentCalendarCancelMeetingRequestEventArgsVtbl): IInspectable [IID_IAppointmentCalendarCancelMeetingRequestEventArgs] {
    fn get_Request(&self, out: *mut <AppointmentCalendarCancelMeetingRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IAppointmentCalendarCancelMeetingRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<AppointmentCalendarCancelMeetingRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppointmentCalendarCancelMeetingRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentCalendarCancelMeetingRequestEventArgs: IAppointmentCalendarCancelMeetingRequestEventArgs}
DEFINE_IID!(IID_IAppointmentCalendarCreateOrUpdateAppointmentRequest, 778236594, 51862, 18604, 145, 36, 64, 107, 25, 254, 250, 112);
RT_INTERFACE!{interface IAppointmentCalendarCreateOrUpdateAppointmentRequest(IAppointmentCalendarCreateOrUpdateAppointmentRequestVtbl): IInspectable [IID_IAppointmentCalendarCreateOrUpdateAppointmentRequest] {
    fn get_AppointmentCalendarLocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Appointment(&self, out: *mut <super::Appointment as RtType>::Abi) -> HRESULT,
    fn get_NotifyInvitees(&self, out: *mut bool) -> HRESULT,
    fn get_ChangedProperties(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT,
    fn ReportCompletedAsync(&self, createdOrUpdatedAppointment: <super::Appointment as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IAppointmentCalendarCreateOrUpdateAppointmentRequest {
    #[inline] pub fn get_appointment_calendar_local_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppointmentCalendarLocalId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_appointment(&self) -> Result<Option<super::Appointment>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Appointment)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::Appointment::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_notify_invitees(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_NotifyInvitees)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_changed_properties(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ChangedProperties)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self, createdOrUpdatedAppointment: &super::Appointment) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, createdOrUpdatedAppointment.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentCalendarCreateOrUpdateAppointmentRequest: IAppointmentCalendarCreateOrUpdateAppointmentRequest}
DEFINE_IID!(IID_IAppointmentCalendarCreateOrUpdateAppointmentRequestEventArgs, 3482185000, 46, 19447, 142, 157, 94, 32, 212, 154, 163, 186);
RT_INTERFACE!{interface IAppointmentCalendarCreateOrUpdateAppointmentRequestEventArgs(IAppointmentCalendarCreateOrUpdateAppointmentRequestEventArgsVtbl): IInspectable [IID_IAppointmentCalendarCreateOrUpdateAppointmentRequestEventArgs] {
    fn get_Request(&self, out: *mut <AppointmentCalendarCreateOrUpdateAppointmentRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IAppointmentCalendarCreateOrUpdateAppointmentRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<AppointmentCalendarCreateOrUpdateAppointmentRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppointmentCalendarCreateOrUpdateAppointmentRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentCalendarCreateOrUpdateAppointmentRequestEventArgs: IAppointmentCalendarCreateOrUpdateAppointmentRequestEventArgs}
DEFINE_IID!(IID_IAppointmentCalendarForwardMeetingRequest, 2196106838, 9910, 16979, 138, 143, 108, 245, 242, 255, 120, 132);
RT_INTERFACE!{interface IAppointmentCalendarForwardMeetingRequest(IAppointmentCalendarForwardMeetingRequestVtbl): IInspectable [IID_IAppointmentCalendarForwardMeetingRequest] {
    fn get_AppointmentCalendarLocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppointmentLocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppointmentOriginalStartTime(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_Invitees(&self, out: *mut <foundation::collections::IVectorView<super::AppointmentInvitee> as RtType>::Abi) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ForwardHeader(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Comment(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IAppointmentCalendarForwardMeetingRequest {
    #[inline] pub fn get_appointment_calendar_local_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppointmentCalendarLocalId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_appointment_local_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppointmentLocalId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_appointment_original_start_time(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppointmentOriginalStartTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_invitees(&self) -> Result<Option<foundation::collections::IVectorView<super::AppointmentInvitee>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Invitees)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_subject(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Subject)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_forward_header(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ForwardHeader)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_comment(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Comment)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentCalendarForwardMeetingRequest: IAppointmentCalendarForwardMeetingRequest}
DEFINE_IID!(IID_IAppointmentCalendarForwardMeetingRequestEventArgs, 822678810, 9122, 17149, 156, 130, 201, 166, 13, 89, 248, 168);
RT_INTERFACE!{interface IAppointmentCalendarForwardMeetingRequestEventArgs(IAppointmentCalendarForwardMeetingRequestEventArgsVtbl): IInspectable [IID_IAppointmentCalendarForwardMeetingRequestEventArgs] {
    fn get_Request(&self, out: *mut <AppointmentCalendarForwardMeetingRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IAppointmentCalendarForwardMeetingRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<AppointmentCalendarForwardMeetingRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppointmentCalendarForwardMeetingRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentCalendarForwardMeetingRequestEventArgs: IAppointmentCalendarForwardMeetingRequestEventArgs}
DEFINE_IID!(IID_IAppointmentCalendarProposeNewTimeForMeetingRequest, 3457967093, 60918, 17347, 130, 183, 190, 107, 54, 140, 105, 0);
RT_INTERFACE!{interface IAppointmentCalendarProposeNewTimeForMeetingRequest(IAppointmentCalendarProposeNewTimeForMeetingRequestVtbl): IInspectable [IID_IAppointmentCalendarProposeNewTimeForMeetingRequest] {
    fn get_AppointmentCalendarLocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppointmentLocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppointmentOriginalStartTime(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_NewStartTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_NewDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Comment(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IAppointmentCalendarProposeNewTimeForMeetingRequest {
    #[inline] pub fn get_appointment_calendar_local_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppointmentCalendarLocalId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_appointment_local_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppointmentLocalId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_appointment_original_start_time(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppointmentOriginalStartTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_new_start_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_NewStartTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_new_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_NewDuration)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_subject(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Subject)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_comment(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Comment)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentCalendarProposeNewTimeForMeetingRequest: IAppointmentCalendarProposeNewTimeForMeetingRequest}
DEFINE_IID!(IID_IAppointmentCalendarProposeNewTimeForMeetingRequestEventArgs, 3537336280, 65233, 17024, 163, 186, 46, 31, 71, 96, 154, 162);
RT_INTERFACE!{interface IAppointmentCalendarProposeNewTimeForMeetingRequestEventArgs(IAppointmentCalendarProposeNewTimeForMeetingRequestEventArgsVtbl): IInspectable [IID_IAppointmentCalendarProposeNewTimeForMeetingRequestEventArgs] {
    fn get_Request(&self, out: *mut <AppointmentCalendarProposeNewTimeForMeetingRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IAppointmentCalendarProposeNewTimeForMeetingRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<AppointmentCalendarProposeNewTimeForMeetingRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppointmentCalendarProposeNewTimeForMeetingRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentCalendarProposeNewTimeForMeetingRequestEventArgs: IAppointmentCalendarProposeNewTimeForMeetingRequestEventArgs}
DEFINE_IID!(IID_IAppointmentCalendarSyncManagerSyncRequest, 313210923, 29027, 19030, 154, 78, 114, 35, 168, 74, 223, 70);
RT_INTERFACE!{interface IAppointmentCalendarSyncManagerSyncRequest(IAppointmentCalendarSyncManagerSyncRequestVtbl): IInspectable [IID_IAppointmentCalendarSyncManagerSyncRequest] {
    fn get_AppointmentCalendarLocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IAppointmentCalendarSyncManagerSyncRequest {
    #[inline] pub fn get_appointment_calendar_local_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppointmentCalendarLocalId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentCalendarSyncManagerSyncRequest: IAppointmentCalendarSyncManagerSyncRequest}
DEFINE_IID!(IID_IAppointmentCalendarSyncManagerSyncRequestEventArgs, 3390555895, 644, 20189, 135, 186, 77, 143, 105, 220, 245, 192);
RT_INTERFACE!{interface IAppointmentCalendarSyncManagerSyncRequestEventArgs(IAppointmentCalendarSyncManagerSyncRequestEventArgsVtbl): IInspectable [IID_IAppointmentCalendarSyncManagerSyncRequestEventArgs] {
    fn get_Request(&self, out: *mut <AppointmentCalendarSyncManagerSyncRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IAppointmentCalendarSyncManagerSyncRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<AppointmentCalendarSyncManagerSyncRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppointmentCalendarSyncManagerSyncRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentCalendarSyncManagerSyncRequestEventArgs: IAppointmentCalendarSyncManagerSyncRequestEventArgs}
DEFINE_IID!(IID_IAppointmentCalendarUpdateMeetingResponseRequest, 2741854348, 49821, 19348, 176, 134, 126, 159, 247, 189, 132, 160);
RT_INTERFACE!{interface IAppointmentCalendarUpdateMeetingResponseRequest(IAppointmentCalendarUpdateMeetingResponseRequestVtbl): IInspectable [IID_IAppointmentCalendarUpdateMeetingResponseRequest] {
    fn get_AppointmentCalendarLocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppointmentLocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppointmentOriginalStartTime(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_Response(&self, out: *mut super::AppointmentParticipantResponse) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Comment(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SendUpdate(&self, out: *mut bool) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IAppointmentCalendarUpdateMeetingResponseRequest {
    #[inline] pub fn get_appointment_calendar_local_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppointmentCalendarLocalId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_appointment_local_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppointmentLocalId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_appointment_original_start_time(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppointmentOriginalStartTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_response(&self) -> Result<super::AppointmentParticipantResponse> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Response)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_subject(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Subject)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_comment(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Comment)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_send_update(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SendUpdate)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentCalendarUpdateMeetingResponseRequest: IAppointmentCalendarUpdateMeetingResponseRequest}
DEFINE_IID!(IID_IAppointmentCalendarUpdateMeetingResponseRequestEventArgs, 2289408131, 38847, 18333, 174, 213, 11, 232, 206, 86, 125, 30);
RT_INTERFACE!{interface IAppointmentCalendarUpdateMeetingResponseRequestEventArgs(IAppointmentCalendarUpdateMeetingResponseRequestEventArgsVtbl): IInspectable [IID_IAppointmentCalendarUpdateMeetingResponseRequestEventArgs] {
    fn get_Request(&self, out: *mut <AppointmentCalendarUpdateMeetingResponseRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IAppointmentCalendarUpdateMeetingResponseRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<AppointmentCalendarUpdateMeetingResponseRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppointmentCalendarUpdateMeetingResponseRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentCalendarUpdateMeetingResponseRequestEventArgs: IAppointmentCalendarUpdateMeetingResponseRequestEventArgs}
DEFINE_IID!(IID_IAppointmentDataProviderConnection, 4091387267, 12884, 18015, 171, 219, 146, 128, 70, 85, 44, 244);
RT_INTERFACE!{interface IAppointmentDataProviderConnection(IAppointmentDataProviderConnectionVtbl): IInspectable [IID_IAppointmentDataProviderConnection] {
    fn add_SyncRequested(&self, handler: <foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarSyncManagerSyncRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SyncRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CreateOrUpdateAppointmentRequested(&self, handler: <foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarCreateOrUpdateAppointmentRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CreateOrUpdateAppointmentRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CancelMeetingRequested(&self, handler: <foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarCancelMeetingRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CancelMeetingRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ForwardMeetingRequested(&self, handler: <foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarForwardMeetingRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ForwardMeetingRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ProposeNewTimeForMeetingRequested(&self, handler: <foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarProposeNewTimeForMeetingRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ProposeNewTimeForMeetingRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_UpdateMeetingResponseRequested(&self, handler: <foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarUpdateMeetingResponseRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_UpdateMeetingResponseRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn Start(&self) -> HRESULT
}}
impl IAppointmentDataProviderConnection {
    #[inline] pub fn add_sync_requested(&self, handler: &foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarSyncManagerSyncRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_SyncRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_sync_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_SyncRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_create_or_update_appointment_requested(&self, handler: &foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarCreateOrUpdateAppointmentRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_CreateOrUpdateAppointmentRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_create_or_update_appointment_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_CreateOrUpdateAppointmentRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_cancel_meeting_requested(&self, handler: &foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarCancelMeetingRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_CancelMeetingRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_cancel_meeting_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_CancelMeetingRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_forward_meeting_requested(&self, handler: &foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarForwardMeetingRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_ForwardMeetingRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_forward_meeting_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_ForwardMeetingRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_propose_new_time_for_meeting_requested(&self, handler: &foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarProposeNewTimeForMeetingRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_ProposeNewTimeForMeetingRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_propose_new_time_for_meeting_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_ProposeNewTimeForMeetingRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_update_meeting_response_requested(&self, handler: &foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarUpdateMeetingResponseRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_UpdateMeetingResponseRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_update_meeting_response_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_UpdateMeetingResponseRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Start)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentDataProviderConnection: IAppointmentDataProviderConnection}
DEFINE_IID!(IID_IAppointmentDataProviderTriggerDetails, 3005758465, 32274, 20062, 177, 239, 116, 251, 104, 172, 111, 42);
RT_INTERFACE!{interface IAppointmentDataProviderTriggerDetails(IAppointmentDataProviderTriggerDetailsVtbl): IInspectable [IID_IAppointmentDataProviderTriggerDetails] {
    fn get_Connection(&self, out: *mut <AppointmentDataProviderConnection as RtType>::Abi) -> HRESULT
}}
impl IAppointmentDataProviderTriggerDetails {
    #[inline] pub fn get_connection(&self) -> Result<Option<AppointmentDataProviderConnection>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Connection)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppointmentDataProviderConnection::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppointmentDataProviderTriggerDetails: IAppointmentDataProviderTriggerDetails}
} // Windows.ApplicationModel.Appointments.DataProvider
} // Windows.ApplicationModel.Appointments
pub mod background { // Windows.ApplicationModel.Background
use crate::prelude::*;
DEFINE_IID!(IID_IActivitySensorTrigger, 3504161602, 58235, 18467, 165, 254, 107, 49, 223, 239, 222, 176);
RT_INTERFACE!{interface IActivitySensorTrigger(IActivitySensorTriggerVtbl): IInspectable [IID_IActivitySensorTrigger] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_SubscribedActivities(&self, out: *mut <foundation::collections::IVector<super::super::devices::sensors::ActivityType> as RtType>::Abi) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_SupportedActivities(&self, out: *mut <foundation::collections::IVectorView<super::super::devices::sensors::ActivityType> as RtType>::Abi) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT
}}
impl IActivitySensorTrigger {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_subscribed_activities(&self) -> Result<Option<foundation::collections::IVector<super::super::devices::sensors::ActivityType>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SubscribedActivities)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ReportInterval)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_supported_activities(&self) -> Result<Option<foundation::collections::IVectorView<super::super::devices::sensors::ActivityType>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SupportedActivities)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MinimumReportInterval)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ActivitySensorTrigger: IActivitySensorTrigger}
impl RtActivatable<IActivitySensorTriggerFactory> for ActivitySensorTrigger {}
impl ActivitySensorTrigger {
    #[inline] pub fn create(reportIntervalInMilliseconds: u32) -> Result<ActivitySensorTrigger> {
        <Self as RtActivatable<IActivitySensorTriggerFactory>>::get_activation_factory().create(reportIntervalInMilliseconds)
    }
}
DEFINE_CLSID!(ActivitySensorTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,65,99,116,105,118,105,116,121,83,101,110,115,111,114,84,114,105,103,103,101,114,0]) [CLSID_ActivitySensorTrigger]);
DEFINE_IID!(IID_IActivitySensorTriggerFactory, 2804322755, 14391, 17655, 131, 27, 1, 50, 204, 135, 43, 195);
RT_INTERFACE!{static interface IActivitySensorTriggerFactory(IActivitySensorTriggerFactoryVtbl): IInspectable [IID_IActivitySensorTriggerFactory] {
    fn Create(&self, reportIntervalInMilliseconds: u32, out: *mut <ActivitySensorTrigger as RtType>::Abi) -> HRESULT
}}
impl IActivitySensorTriggerFactory {
    #[inline] pub fn create(&self, reportIntervalInMilliseconds: u32) -> Result<ActivitySensorTrigger> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, reportIntervalInMilliseconds, &mut out);
        if hr == S_OK { Ok(ActivitySensorTrigger::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum AlarmAccessStatus: i32 {
    Unspecified = 0, AllowedWithWakeupCapability = 1, AllowedWithoutWakeupCapability = 2, Denied = 3,
}}
RT_CLASS!{static class AlarmApplicationManager}
impl RtActivatable<IAlarmApplicationManagerStatics> for AlarmApplicationManager {}
impl AlarmApplicationManager {
    #[inline] pub fn request_access_async() -> Result<foundation::IAsyncOperation<AlarmAccessStatus>> {
        <Self as RtActivatable<IAlarmApplicationManagerStatics>>::get_activation_factory().request_access_async()
    }
    #[inline] pub fn get_access_status() -> Result<AlarmAccessStatus> {
        <Self as RtActivatable<IAlarmApplicationManagerStatics>>::get_activation_factory().get_access_status()
    }
}
DEFINE_CLSID!(AlarmApplicationManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,65,108,97,114,109,65,112,112,108,105,99,97,116,105,111,110,77,97,110,97,103,101,114,0]) [CLSID_AlarmApplicationManager]);
DEFINE_IID!(IID_IAlarmApplicationManagerStatics, 3389258299, 52454, 19938, 176, 155, 150, 40, 189, 51, 187, 190);
RT_INTERFACE!{static interface IAlarmApplicationManagerStatics(IAlarmApplicationManagerStaticsVtbl): IInspectable [IID_IAlarmApplicationManagerStatics] {
    fn RequestAccessAsync(&self, out: *mut <foundation::IAsyncOperation<AlarmAccessStatus> as RtType>::Abi) -> HRESULT,
    fn GetAccessStatus(&self, out: *mut AlarmAccessStatus) -> HRESULT
}}
impl IAlarmApplicationManagerStatics {
    #[inline] pub fn request_access_async(&self) -> Result<foundation::IAsyncOperation<AlarmAccessStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestAccessAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_access_status(&self) -> Result<AlarmAccessStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().GetAccessStatus)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppBroadcastTrigger, 1960113302, 36151, 17644, 148, 129, 42, 11, 152, 84, 235, 72);
RT_INTERFACE!{interface IAppBroadcastTrigger(IAppBroadcastTriggerVtbl): IInspectable [IID_IAppBroadcastTrigger] {
    fn put_ProviderInfo(&self, value: <AppBroadcastTriggerProviderInfo as RtType>::Abi) -> HRESULT,
    fn get_ProviderInfo(&self, out: *mut <AppBroadcastTriggerProviderInfo as RtType>::Abi) -> HRESULT
}}
impl IAppBroadcastTrigger {
    #[inline] pub fn set_provider_info(&self, value: &AppBroadcastTriggerProviderInfo) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ProviderInfo)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_provider_info(&self) -> Result<Option<AppBroadcastTriggerProviderInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ProviderInfo)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastTriggerProviderInfo::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastTrigger: IAppBroadcastTrigger}
impl RtActivatable<IAppBroadcastTriggerFactory> for AppBroadcastTrigger {}
impl AppBroadcastTrigger {
    #[inline] pub fn create_app_broadcast_trigger(providerKey: &HStringArg) -> Result<AppBroadcastTrigger> {
        <Self as RtActivatable<IAppBroadcastTriggerFactory>>::get_activation_factory().create_app_broadcast_trigger(providerKey)
    }
}
DEFINE_CLSID!(AppBroadcastTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,65,112,112,66,114,111,97,100,99,97,115,116,84,114,105,103,103,101,114,0]) [CLSID_AppBroadcastTrigger]);
DEFINE_IID!(IID_IAppBroadcastTriggerFactory, 671850308, 8948, 17944, 160, 46, 231, 228, 17, 235, 114, 56);
RT_INTERFACE!{static interface IAppBroadcastTriggerFactory(IAppBroadcastTriggerFactoryVtbl): IInspectable [IID_IAppBroadcastTriggerFactory] {
    fn CreateAppBroadcastTrigger(&self, providerKey: HSTRING, out: *mut <AppBroadcastTrigger as RtType>::Abi) -> HRESULT
}}
impl IAppBroadcastTriggerFactory {
    #[inline] pub fn create_app_broadcast_trigger(&self, providerKey: &HStringArg) -> Result<AppBroadcastTrigger> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateAppBroadcastTrigger)(self.get_abi() as *const _ as *mut _, providerKey.get(), &mut out);
        if hr == S_OK { Ok(AppBroadcastTrigger::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppBroadcastTriggerProviderInfo, 4061738285, 40424, 17440, 156, 226, 94, 255, 143, 23, 55, 107);
RT_INTERFACE!{interface IAppBroadcastTriggerProviderInfo(IAppBroadcastTriggerProviderInfoVtbl): IInspectable [IID_IAppBroadcastTriggerProviderInfo] {
    fn put_DisplayNameResource(&self, value: HSTRING) -> HRESULT,
    fn get_DisplayNameResource(&self, out: *mut HSTRING) -> HRESULT,
    fn put_LogoResource(&self, value: HSTRING) -> HRESULT,
    fn get_LogoResource(&self, out: *mut HSTRING) -> HRESULT,
    fn put_VideoKeyFrameInterval(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_VideoKeyFrameInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_MaxVideoBitrate(&self, value: u32) -> HRESULT,
    fn get_MaxVideoBitrate(&self, out: *mut u32) -> HRESULT,
    fn put_MaxVideoWidth(&self, value: u32) -> HRESULT,
    fn get_MaxVideoWidth(&self, out: *mut u32) -> HRESULT,
    fn put_MaxVideoHeight(&self, value: u32) -> HRESULT,
    fn get_MaxVideoHeight(&self, out: *mut u32) -> HRESULT
}}
impl IAppBroadcastTriggerProviderInfo {
    #[inline] pub fn set_display_name_resource(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayNameResource)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name_resource(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayNameResource)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_logo_resource(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_LogoResource)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_logo_resource(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LogoResource)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_video_key_frame_interval(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_VideoKeyFrameInterval)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_video_key_frame_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_VideoKeyFrameInterval)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_max_video_bitrate(&self, value: u32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxVideoBitrate)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_video_bitrate(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MaxVideoBitrate)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_max_video_width(&self, value: u32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxVideoWidth)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_video_width(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MaxVideoWidth)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_max_video_height(&self, value: u32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxVideoHeight)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_video_height(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MaxVideoHeight)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastTriggerProviderInfo: IAppBroadcastTriggerProviderInfo}
DEFINE_IID!(IID_IApplicationTrigger, 189171248, 38260, 18732, 158, 147, 26, 58, 230, 51, 95, 233);
RT_INTERFACE!{interface IApplicationTrigger(IApplicationTriggerVtbl): IInspectable [IID_IApplicationTrigger] {
    fn RequestAsync(&self, out: *mut <foundation::IAsyncOperation<ApplicationTriggerResult> as RtType>::Abi) -> HRESULT,
    fn RequestAsyncWithArguments(&self, arguments: <foundation::collections::ValueSet as RtType>::Abi, out: *mut <foundation::IAsyncOperation<ApplicationTriggerResult> as RtType>::Abi) -> HRESULT
}}
impl IApplicationTrigger {
    #[inline] pub fn request_async(&self) -> Result<foundation::IAsyncOperation<ApplicationTriggerResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_async_with_arguments(&self, arguments: &foundation::collections::ValueSet) -> Result<foundation::IAsyncOperation<ApplicationTriggerResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestAsyncWithArguments)(self.get_abi() as *const _ as *mut _, arguments.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ApplicationTrigger: IApplicationTrigger}
impl RtActivatable<IActivationFactory> for ApplicationTrigger {}
DEFINE_CLSID!(ApplicationTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,65,112,112,108,105,99,97,116,105,111,110,84,114,105,103,103,101,114,0]) [CLSID_ApplicationTrigger]);
DEFINE_IID!(IID_IApplicationTriggerDetails, 2547804850, 8729, 19102, 156, 94, 65, 208, 71, 247, 110, 130);
RT_INTERFACE!{interface IApplicationTriggerDetails(IApplicationTriggerDetailsVtbl): IInspectable [IID_IApplicationTriggerDetails] {
    fn get_Arguments(&self, out: *mut <foundation::collections::ValueSet as RtType>::Abi) -> HRESULT
}}
impl IApplicationTriggerDetails {
    #[inline] pub fn get_arguments(&self) -> Result<Option<foundation::collections::ValueSet>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Arguments)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::ValueSet::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ApplicationTriggerDetails: IApplicationTriggerDetails}
RT_ENUM! { enum ApplicationTriggerResult: i32 {
    Allowed = 0, CurrentlyRunning = 1, DisabledByPolicy = 2, UnknownError = 3,
}}
DEFINE_IID!(IID_IAppointmentStoreNotificationTrigger, 1691616268, 49665, 17069, 170, 42, 226, 27, 163, 66, 91, 109);
RT_INTERFACE!{interface IAppointmentStoreNotificationTrigger(IAppointmentStoreNotificationTriggerVtbl): IInspectable [IID_IAppointmentStoreNotificationTrigger] {
    
}}
RT_CLASS!{class AppointmentStoreNotificationTrigger: IAppointmentStoreNotificationTrigger}
impl RtActivatable<IActivationFactory> for AppointmentStoreNotificationTrigger {}
DEFINE_CLSID!(AppointmentStoreNotificationTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,65,112,112,111,105,110,116,109,101,110,116,83,116,111,114,101,78,111,116,105,102,105,99,97,116,105,111,110,84,114,105,103,103,101,114,0]) [CLSID_AppointmentStoreNotificationTrigger]);
RT_ENUM! { enum BackgroundAccessRequestKind: i32 {
    AlwaysAllowed = 0, AllowedSubjectToSystemPolicy = 1,
}}
RT_ENUM! { enum BackgroundAccessStatus: i32 {
    Unspecified = 0, AllowedWithAlwaysOnRealTimeConnectivity = 1, AllowedMayUseActiveRealTimeConnectivity = 2, Denied = 3, AlwaysAllowed = 4, AllowedSubjectToSystemPolicy = 5, DeniedBySystemPolicy = 6, DeniedByUser = 7,
}}
DEFINE_IID!(IID_IBackgroundCondition, 2923995630, 35153, 16394, 131, 2, 156, 156, 154, 42, 58, 59);
RT_INTERFACE!{interface IBackgroundCondition(IBackgroundConditionVtbl): IInspectable [IID_IBackgroundCondition] {
    
}}
RT_CLASS!{static class BackgroundExecutionManager}
impl RtActivatable<IBackgroundExecutionManagerStatics> for BackgroundExecutionManager {}
impl RtActivatable<IBackgroundExecutionManagerStatics2> for BackgroundExecutionManager {}
impl BackgroundExecutionManager {
    #[inline] pub fn request_access_async() -> Result<foundation::IAsyncOperation<BackgroundAccessStatus>> {
        <Self as RtActivatable<IBackgroundExecutionManagerStatics>>::get_activation_factory().request_access_async()
    }
    #[inline] pub fn request_access_for_application_async(applicationId: &HStringArg) -> Result<foundation::IAsyncOperation<BackgroundAccessStatus>> {
        <Self as RtActivatable<IBackgroundExecutionManagerStatics>>::get_activation_factory().request_access_for_application_async(applicationId)
    }
    #[inline] pub fn remove_access() -> Result<()> {
        <Self as RtActivatable<IBackgroundExecutionManagerStatics>>::get_activation_factory().remove_access()
    }
    #[inline] pub fn remove_access_for_application(applicationId: &HStringArg) -> Result<()> {
        <Self as RtActivatable<IBackgroundExecutionManagerStatics>>::get_activation_factory().remove_access_for_application(applicationId)
    }
    #[inline] pub fn get_access_status() -> Result<BackgroundAccessStatus> {
        <Self as RtActivatable<IBackgroundExecutionManagerStatics>>::get_activation_factory().get_access_status()
    }
    #[inline] pub fn get_access_status_for_application(applicationId: &HStringArg) -> Result<BackgroundAccessStatus> {
        <Self as RtActivatable<IBackgroundExecutionManagerStatics>>::get_activation_factory().get_access_status_for_application(applicationId)
    }
    #[inline] pub fn request_access_kind_async(requestedAccess: BackgroundAccessRequestKind, reason: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> {
        <Self as RtActivatable<IBackgroundExecutionManagerStatics2>>::get_activation_factory().request_access_kind_async(requestedAccess, reason)
    }
}
DEFINE_CLSID!(BackgroundExecutionManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,66,97,99,107,103,114,111,117,110,100,69,120,101,99,117,116,105,111,110,77,97,110,97,103,101,114,0]) [CLSID_BackgroundExecutionManager]);
DEFINE_IID!(IID_IBackgroundExecutionManagerStatics, 3894864472, 26281, 19777, 131, 212, 180, 193, 140, 135, 184, 70);
RT_INTERFACE!{static interface IBackgroundExecutionManagerStatics(IBackgroundExecutionManagerStaticsVtbl): IInspectable [IID_IBackgroundExecutionManagerStatics] {
    fn RequestAccessAsync(&self, out: *mut <foundation::IAsyncOperation<BackgroundAccessStatus> as RtType>::Abi) -> HRESULT,
    fn RequestAccessForApplicationAsync(&self, applicationId: HSTRING, out: *mut <foundation::IAsyncOperation<BackgroundAccessStatus> as RtType>::Abi) -> HRESULT,
    fn RemoveAccess(&self) -> HRESULT,
    fn RemoveAccessForApplication(&self, applicationId: HSTRING) -> HRESULT,
    fn GetAccessStatus(&self, out: *mut BackgroundAccessStatus) -> HRESULT,
    fn GetAccessStatusForApplication(&self, applicationId: HSTRING, out: *mut BackgroundAccessStatus) -> HRESULT
}}
impl IBackgroundExecutionManagerStatics {
    #[inline] pub fn request_access_async(&self) -> Result<foundation::IAsyncOperation<BackgroundAccessStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestAccessAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_access_for_application_async(&self, applicationId: &HStringArg) -> Result<foundation::IAsyncOperation<BackgroundAccessStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestAccessForApplicationAsync)(self.get_abi() as *const _ as *mut _, applicationId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn remove_access(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().RemoveAccess)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove_access_for_application(&self, applicationId: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().RemoveAccessForApplication)(self.get_abi() as *const _ as *mut _, applicationId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_access_status(&self) -> Result<BackgroundAccessStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().GetAccessStatus)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_access_status_for_application(&self, applicationId: &HStringArg) -> Result<BackgroundAccessStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().GetAccessStatusForApplication)(self.get_abi() as *const _ as *mut _, applicationId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBackgroundExecutionManagerStatics2, 1184572655, 39867, 19992, 153, 154, 253, 101, 18, 147, 27, 233);
RT_INTERFACE!{static interface IBackgroundExecutionManagerStatics2(IBackgroundExecutionManagerStatics2Vtbl): IInspectable [IID_IBackgroundExecutionManagerStatics2] {
    fn RequestAccessKindAsync(&self, requestedAccess: BackgroundAccessRequestKind, reason: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl IBackgroundExecutionManagerStatics2 {
    #[inline] pub fn request_access_kind_async(&self, requestedAccess: BackgroundAccessRequestKind, reason: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestAccessKindAsync)(self.get_abi() as *const _ as *mut _, requestedAccess, reason.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBackgroundTask, 2098451764, 64786, 17358, 140, 34, 234, 31, 241, 60, 6, 223);
RT_INTERFACE!{interface IBackgroundTask(IBackgroundTaskVtbl): IInspectable [IID_IBackgroundTask] {
    fn Run(&self, taskInstance: <IBackgroundTaskInstance as RtType>::Abi) -> HRESULT
}}
impl IBackgroundTask {
    #[inline] pub fn run(&self, taskInstance: &IBackgroundTaskInstance) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Run)(self.get_abi() as *const _ as *mut _, taskInstance.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBackgroundTaskBuilder, 55661838, 15972, 17778, 169, 58, 132, 7, 90, 55, 201, 23);
RT_INTERFACE!{interface IBackgroundTaskBuilder(IBackgroundTaskBuilderVtbl): IInspectable [IID_IBackgroundTaskBuilder] {
    fn put_TaskEntryPoint(&self, value: HSTRING) -> HRESULT,
    fn get_TaskEntryPoint(&self, out: *mut HSTRING) -> HRESULT,
    fn SetTrigger(&self, trigger: <IBackgroundTrigger as RtType>::Abi) -> HRESULT,
    fn AddCondition(&self, condition: <IBackgroundCondition as RtType>::Abi) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn Register(&self, out: *mut <BackgroundTaskRegistration as RtType>::Abi) -> HRESULT
}}
impl IBackgroundTaskBuilder {
    #[inline] pub fn set_task_entry_point(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_TaskEntryPoint)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_task_entry_point(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TaskEntryPoint)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_trigger(&self, trigger: &IBackgroundTrigger) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetTrigger)(self.get_abi() as *const _ as *mut _, trigger.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_condition(&self, condition: &IBackgroundCondition) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().AddCondition)(self.get_abi() as *const _ as *mut _, condition.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Name)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Name)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn register(&self) -> Result<Option<BackgroundTaskRegistration>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Register)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BackgroundTaskRegistration::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BackgroundTaskBuilder: IBackgroundTaskBuilder}
impl RtActivatable<IActivationFactory> for BackgroundTaskBuilder {}
DEFINE_CLSID!(BackgroundTaskBuilder(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,66,97,99,107,103,114,111,117,110,100,84,97,115,107,66,117,105,108,100,101,114,0]) [CLSID_BackgroundTaskBuilder]);
DEFINE_IID!(IID_IBackgroundTaskBuilder2, 1793576881, 4175, 16493, 141, 182, 132, 74, 87, 15, 66, 187);
RT_INTERFACE!{interface IBackgroundTaskBuilder2(IBackgroundTaskBuilder2Vtbl): IInspectable [IID_IBackgroundTaskBuilder2] {
    fn put_CancelOnConditionLoss(&self, value: bool) -> HRESULT,
    fn get_CancelOnConditionLoss(&self, out: *mut bool) -> HRESULT
}}
impl IBackgroundTaskBuilder2 {
    #[inline] pub fn set_cancel_on_condition_loss(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CancelOnConditionLoss)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cancel_on_condition_loss(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CancelOnConditionLoss)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBackgroundTaskBuilder3, 684150602, 35753, 19465, 162, 79, 25, 104, 62, 44, 146, 76);
RT_INTERFACE!{interface IBackgroundTaskBuilder3(IBackgroundTaskBuilder3Vtbl): IInspectable [IID_IBackgroundTaskBuilder3] {
    fn put_IsNetworkRequested(&self, value: bool) -> HRESULT,
    fn get_IsNetworkRequested(&self, out: *mut bool) -> HRESULT
}}
impl IBackgroundTaskBuilder3 {
    #[inline] pub fn set_is_network_requested(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsNetworkRequested)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_network_requested(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsNetworkRequested)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBackgroundTaskBuilder4, 1196811554, 52130, 20021, 189, 22, 166, 218, 127, 28, 25, 170);
RT_INTERFACE!{interface IBackgroundTaskBuilder4(IBackgroundTaskBuilder4Vtbl): IInspectable [IID_IBackgroundTaskBuilder4] {
    fn get_TaskGroup(&self, out: *mut <BackgroundTaskRegistrationGroup as RtType>::Abi) -> HRESULT,
    fn put_TaskGroup(&self, value: <BackgroundTaskRegistrationGroup as RtType>::Abi) -> HRESULT
}}
impl IBackgroundTaskBuilder4 {
    #[inline] pub fn get_task_group(&self) -> Result<Option<BackgroundTaskRegistrationGroup>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TaskGroup)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BackgroundTaskRegistrationGroup::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_task_group(&self, value: &BackgroundTaskRegistrationGroup) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_TaskGroup)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_BackgroundTaskCanceledEventHandler, 2797910720, 20984, 19543, 172, 63, 21, 109, 209, 104, 12, 79);
RT_DELEGATE!{delegate BackgroundTaskCanceledEventHandler(BackgroundTaskCanceledEventHandlerVtbl, BackgroundTaskCanceledEventHandlerImpl) [IID_BackgroundTaskCanceledEventHandler] {
    fn Invoke(&self, sender: <IBackgroundTaskInstance as RtType>::Abi, reason: BackgroundTaskCancellationReason) -> HRESULT
}}
impl BackgroundTaskCanceledEventHandler {
    #[inline] pub fn invoke(&self, sender: &IBackgroundTaskInstance, reason: BackgroundTaskCancellationReason) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Invoke)(self.get_abi() as *const _ as *mut _, sender.get_abi() as *const _ as *mut _, reason);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum BackgroundTaskCancellationReason: i32 {
    Abort = 0, Terminating = 1, LoggingOff = 2, ServicingUpdate = 3, IdleTask = 4, Uninstall = 5, ConditionLoss = 6, SystemPolicy = 7, QuietHoursEntered = 8, ExecutionTimeExceeded = 9, ResourceRevocation = 10, EnergySaver = 11,
}}
DEFINE_IID!(IID_IBackgroundTaskCompletedEventArgs, 1448945103, 61961, 18676, 153, 103, 43, 24, 79, 123, 251, 240);
RT_INTERFACE!{interface IBackgroundTaskCompletedEventArgs(IBackgroundTaskCompletedEventArgsVtbl): IInspectable [IID_IBackgroundTaskCompletedEventArgs] {
    fn get_InstanceId(&self, out: *mut Guid) -> HRESULT,
    fn CheckResult(&self) -> HRESULT
}}
impl IBackgroundTaskCompletedEventArgs {
    #[inline] pub fn get_instance_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_InstanceId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn check_result(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().CheckResult)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BackgroundTaskCompletedEventArgs: IBackgroundTaskCompletedEventArgs}
DEFINE_IID!(IID_BackgroundTaskCompletedEventHandler, 1530456361, 41094, 18087, 166, 120, 67, 145, 53, 130, 43, 207);
RT_DELEGATE!{delegate BackgroundTaskCompletedEventHandler(BackgroundTaskCompletedEventHandlerVtbl, BackgroundTaskCompletedEventHandlerImpl) [IID_BackgroundTaskCompletedEventHandler] {
    fn Invoke(&self, sender: <BackgroundTaskRegistration as RtType>::Abi, args: <BackgroundTaskCompletedEventArgs as RtType>::Abi) -> HRESULT
}}
impl BackgroundTaskCompletedEventHandler {
    #[inline] pub fn invoke(&self, sender: &BackgroundTaskRegistration, args: &BackgroundTaskCompletedEventArgs) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Invoke)(self.get_abi() as *const _ as *mut _, sender.get_abi() as *const _ as *mut _, args.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBackgroundTaskDeferral, 2479625581, 44839, 19923, 132, 110, 36, 238, 64, 202, 221, 37);
RT_INTERFACE!{interface IBackgroundTaskDeferral(IBackgroundTaskDeferralVtbl): IInspectable [IID_IBackgroundTaskDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IBackgroundTaskDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Complete)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BackgroundTaskDeferral: IBackgroundTaskDeferral}
DEFINE_IID!(IID_IBackgroundTaskInstance, 2254166650, 8664, 17779, 143, 50, 146, 138, 27, 6, 65, 246);
RT_INTERFACE!{interface IBackgroundTaskInstance(IBackgroundTaskInstanceVtbl): IInspectable [IID_IBackgroundTaskInstance] {
    fn get_InstanceId(&self, out: *mut Guid) -> HRESULT,
    fn get_Task(&self, out: *mut <BackgroundTaskRegistration as RtType>::Abi) -> HRESULT,
    fn get_Progress(&self, out: *mut u32) -> HRESULT,
    fn put_Progress(&self, value: u32) -> HRESULT,
    fn get_TriggerDetails(&self, out: *mut <IInspectable as RtType>::Abi) -> HRESULT,
    fn add_Canceled(&self, cancelHandler: <BackgroundTaskCanceledEventHandler as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Canceled(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn get_SuspendedCount(&self, out: *mut u32) -> HRESULT,
    fn GetDeferral(&self, out: *mut <BackgroundTaskDeferral as RtType>::Abi) -> HRESULT
}}
impl IBackgroundTaskInstance {
    #[inline] pub fn get_instance_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_InstanceId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_task(&self) -> Result<Option<BackgroundTaskRegistration>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Task)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BackgroundTaskRegistration::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_progress(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Progress)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_progress(&self, value: u32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Progress)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_trigger_details(&self) -> Result<Option<IInspectable>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TriggerDetails)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IInspectable::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_canceled(&self, cancelHandler: &BackgroundTaskCanceledEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_Canceled)(self.get_abi() as *const _ as *mut _, cancelHandler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_canceled(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_Canceled)(self.get_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_suspended_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SuspendedCount)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<BackgroundTaskDeferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BackgroundTaskDeferral::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBackgroundTaskInstance2, 1333592438, 3190, 20404, 137, 109, 93, 225, 134, 65, 34, 246);
RT_INTERFACE!{interface IBackgroundTaskInstance2(IBackgroundTaskInstance2Vtbl): IInspectable [IID_IBackgroundTaskInstance2] {
    fn GetThrottleCount(&self, counter: BackgroundTaskThrottleCounter, out: *mut u32) -> HRESULT
}}
impl IBackgroundTaskInstance2 {
    #[inline] pub fn get_throttle_count(&self, counter: BackgroundTaskThrottleCounter) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().GetThrottleCount)(self.get_abi() as *const _ as *mut _, counter, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBackgroundTaskInstance4, 2133455420, 43524, 19208, 151, 176, 6, 216, 116, 205, 171, 245);
RT_INTERFACE!{interface IBackgroundTaskInstance4(IBackgroundTaskInstance4Vtbl): IInspectable [IID_IBackgroundTaskInstance4] {
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut <super::super::system::User as RtType>::Abi) -> HRESULT
}}
impl IBackgroundTaskInstance4 {
    #[cfg(feature="windows-system")] #[inline] pub fn get_user(&self) -> Result<Option<super::super::system::User>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_User)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::system::User::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBackgroundTaskProgressEventArgs, 4212418732, 33586, 19722, 149, 50, 3, 234, 230, 132, 218, 49);
RT_INTERFACE!{interface IBackgroundTaskProgressEventArgs(IBackgroundTaskProgressEventArgsVtbl): IInspectable [IID_IBackgroundTaskProgressEventArgs] {
    fn get_InstanceId(&self, out: *mut Guid) -> HRESULT,
    fn get_Progress(&self, out: *mut u32) -> HRESULT
}}
impl IBackgroundTaskProgressEventArgs {
    #[inline] pub fn get_instance_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_InstanceId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_progress(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Progress)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BackgroundTaskProgressEventArgs: IBackgroundTaskProgressEventArgs}
DEFINE_IID!(IID_BackgroundTaskProgressEventHandler, 1189111868, 35464, 19609, 128, 76, 118, 137, 127, 98, 119, 166);
RT_DELEGATE!{delegate BackgroundTaskProgressEventHandler(BackgroundTaskProgressEventHandlerVtbl, BackgroundTaskProgressEventHandlerImpl) [IID_BackgroundTaskProgressEventHandler] {
    fn Invoke(&self, sender: <BackgroundTaskRegistration as RtType>::Abi, args: <BackgroundTaskProgressEventArgs as RtType>::Abi) -> HRESULT
}}
impl BackgroundTaskProgressEventHandler {
    #[inline] pub fn invoke(&self, sender: &BackgroundTaskRegistration, args: &BackgroundTaskProgressEventArgs) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Invoke)(self.get_abi() as *const _ as *mut _, sender.get_abi() as *const _ as *mut _, args.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBackgroundTaskRegistration, 275074242, 41582, 17343, 140, 18, 31, 180, 13, 191, 191, 160);
RT_INTERFACE!{interface IBackgroundTaskRegistration(IBackgroundTaskRegistrationVtbl): IInspectable [IID_IBackgroundTaskRegistration] {
    fn get_TaskId(&self, out: *mut Guid) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn add_Progress(&self, handler: <BackgroundTaskProgressEventHandler as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Progress(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Completed(&self, handler: <BackgroundTaskCompletedEventHandler as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Completed(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn Unregister(&self, cancelTask: bool) -> HRESULT
}}
impl IBackgroundTaskRegistration {
    #[inline] pub fn get_task_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_TaskId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Name)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_progress(&self, handler: &BackgroundTaskProgressEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_Progress)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_progress(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_Progress)(self.get_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_completed(&self, handler: &BackgroundTaskCompletedEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_Completed)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_completed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_Completed)(self.get_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn unregister(&self, cancelTask: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Unregister)(self.get_abi() as *const _ as *mut _, cancelTask);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BackgroundTaskRegistration: IBackgroundTaskRegistration}
impl RtActivatable<IBackgroundTaskRegistrationStatics> for BackgroundTaskRegistration {}
impl RtActivatable<IBackgroundTaskRegistrationStatics2> for BackgroundTaskRegistration {}
impl BackgroundTaskRegistration {
    #[inline] pub fn get_all_tasks() -> Result<Option<foundation::collections::IMapView<Guid, IBackgroundTaskRegistration>>> {
        <Self as RtActivatable<IBackgroundTaskRegistrationStatics>>::get_activation_factory().get_all_tasks()
    }
    #[inline] pub fn get_all_task_groups() -> Result<Option<foundation::collections::IMapView<HString, BackgroundTaskRegistrationGroup>>> {
        <Self as RtActivatable<IBackgroundTaskRegistrationStatics2>>::get_activation_factory().get_all_task_groups()
    }
    #[inline] pub fn get_task_group(groupId: &HStringArg) -> Result<Option<BackgroundTaskRegistrationGroup>> {
        <Self as RtActivatable<IBackgroundTaskRegistrationStatics2>>::get_activation_factory().get_task_group(groupId)
    }
}
DEFINE_CLSID!(BackgroundTaskRegistration(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,66,97,99,107,103,114,111,117,110,100,84,97,115,107,82,101,103,105,115,116,114,97,116,105,111,110,0]) [CLSID_BackgroundTaskRegistration]);
DEFINE_IID!(IID_IBackgroundTaskRegistration2, 1631110915, 48006, 16658, 175, 195, 127, 147, 155, 22, 110, 59);
RT_INTERFACE!{interface IBackgroundTaskRegistration2(IBackgroundTaskRegistration2Vtbl): IInspectable [IID_IBackgroundTaskRegistration2] {
    fn get_Trigger(&self, out: *mut <IBackgroundTrigger as RtType>::Abi) -> HRESULT
}}
impl IBackgroundTaskRegistration2 {
    #[inline] pub fn get_trigger(&self) -> Result<Option<IBackgroundTrigger>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Trigger)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IBackgroundTrigger::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBackgroundTaskRegistration3, 4264788373, 37923, 19851, 131, 13, 177, 221, 44, 123, 173, 213);
RT_INTERFACE!{interface IBackgroundTaskRegistration3(IBackgroundTaskRegistration3Vtbl): IInspectable [IID_IBackgroundTaskRegistration3] {
    fn get_TaskGroup(&self, out: *mut <BackgroundTaskRegistrationGroup as RtType>::Abi) -> HRESULT
}}
impl IBackgroundTaskRegistration3 {
    #[inline] pub fn get_task_group(&self) -> Result<Option<BackgroundTaskRegistrationGroup>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TaskGroup)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BackgroundTaskRegistrationGroup::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBackgroundTaskRegistrationGroup, 716280218, 34587, 16743, 138, 118, 5, 92, 214, 123, 91, 35);
RT_INTERFACE!{interface IBackgroundTaskRegistrationGroup(IBackgroundTaskRegistrationGroupVtbl): IInspectable [IID_IBackgroundTaskRegistrationGroup] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn add_BackgroundActivated(&self, handler: <foundation::TypedEventHandler<BackgroundTaskRegistrationGroup, super::activation::BackgroundActivatedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BackgroundActivated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_AllTasks(&self, out: *mut <foundation::collections::IMapView<Guid, BackgroundTaskRegistration> as RtType>::Abi) -> HRESULT
}}
impl IBackgroundTaskRegistrationGroup {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Name)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_background_activated(&self, handler: &foundation::TypedEventHandler<BackgroundTaskRegistrationGroup, super::activation::BackgroundActivatedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_BackgroundActivated)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_background_activated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_BackgroundActivated)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_all_tasks(&self) -> Result<Option<foundation::collections::IMapView<Guid, BackgroundTaskRegistration>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AllTasks)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BackgroundTaskRegistrationGroup: IBackgroundTaskRegistrationGroup}
impl RtActivatable<IBackgroundTaskRegistrationGroupFactory> for BackgroundTaskRegistrationGroup {}
impl BackgroundTaskRegistrationGroup {
    #[inline] pub fn create(id: &HStringArg) -> Result<BackgroundTaskRegistrationGroup> {
        <Self as RtActivatable<IBackgroundTaskRegistrationGroupFactory>>::get_activation_factory().create(id)
    }
    #[inline] pub fn create_with_name(id: &HStringArg, name: &HStringArg) -> Result<BackgroundTaskRegistrationGroup> {
        <Self as RtActivatable<IBackgroundTaskRegistrationGroupFactory>>::get_activation_factory().create_with_name(id, name)
    }
}
DEFINE_CLSID!(BackgroundTaskRegistrationGroup(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,66,97,99,107,103,114,111,117,110,100,84,97,115,107,82,101,103,105,115,116,114,97,116,105,111,110,71,114,111,117,112,0]) [CLSID_BackgroundTaskRegistrationGroup]);
DEFINE_IID!(IID_IBackgroundTaskRegistrationGroupFactory, 2212047721, 17615, 17969, 151, 64, 3, 199, 216, 116, 27, 197);
RT_INTERFACE!{static interface IBackgroundTaskRegistrationGroupFactory(IBackgroundTaskRegistrationGroupFactoryVtbl): IInspectable [IID_IBackgroundTaskRegistrationGroupFactory] {
    fn Create(&self, id: HSTRING, out: *mut <BackgroundTaskRegistrationGroup as RtType>::Abi) -> HRESULT,
    fn CreateWithName(&self, id: HSTRING, name: HSTRING, out: *mut <BackgroundTaskRegistrationGroup as RtType>::Abi) -> HRESULT
}}
impl IBackgroundTaskRegistrationGroupFactory {
    #[inline] pub fn create(&self, id: &HStringArg) -> Result<BackgroundTaskRegistrationGroup> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(BackgroundTaskRegistrationGroup::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_name(&self, id: &HStringArg, name: &HStringArg) -> Result<BackgroundTaskRegistrationGroup> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWithName)(self.get_abi() as *const _ as *mut _, id.get(), name.get(), &mut out);
        if hr == S_OK { Ok(BackgroundTaskRegistrationGroup::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBackgroundTaskRegistrationStatics, 1280585577, 45056, 17082, 160, 147, 106, 86, 60, 101, 227, 248);
RT_INTERFACE!{static interface IBackgroundTaskRegistrationStatics(IBackgroundTaskRegistrationStaticsVtbl): IInspectable [IID_IBackgroundTaskRegistrationStatics] {
    fn get_AllTasks(&self, out: *mut <foundation::collections::IMapView<Guid, IBackgroundTaskRegistration> as RtType>::Abi) -> HRESULT
}}
impl IBackgroundTaskRegistrationStatics {
    #[inline] pub fn get_all_tasks(&self) -> Result<Option<foundation::collections::IMapView<Guid, IBackgroundTaskRegistration>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AllTasks)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBackgroundTaskRegistrationStatics2, 390817566, 45581, 20393, 173, 154, 233, 58, 214, 199, 30, 1);
RT_INTERFACE!{static interface IBackgroundTaskRegistrationStatics2(IBackgroundTaskRegistrationStatics2Vtbl): IInspectable [IID_IBackgroundTaskRegistrationStatics2] {
    fn get_AllTaskGroups(&self, out: *mut <foundation::collections::IMapView<HString, BackgroundTaskRegistrationGroup> as RtType>::Abi) -> HRESULT,
    fn GetTaskGroup(&self, groupId: HSTRING, out: *mut <BackgroundTaskRegistrationGroup as RtType>::Abi) -> HRESULT
}}
impl IBackgroundTaskRegistrationStatics2 {
    #[inline] pub fn get_all_task_groups(&self) -> Result<Option<foundation::collections::IMapView<HString, BackgroundTaskRegistrationGroup>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AllTaskGroups)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_task_group(&self, groupId: &HStringArg) -> Result<Option<BackgroundTaskRegistrationGroup>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetTaskGroup)(self.get_abi() as *const _ as *mut _, groupId.get(), &mut out);
        if hr == S_OK { Ok(BackgroundTaskRegistrationGroup::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum BackgroundTaskThrottleCounter: i32 {
    All = 0, Cpu = 1, Network = 2,
}}
DEFINE_IID!(IID_IBackgroundTrigger, 2226364504, 24615, 19335, 151, 144, 189, 243, 247, 87, 219, 215);
RT_INTERFACE!{interface IBackgroundTrigger(IBackgroundTriggerVtbl): IInspectable [IID_IBackgroundTrigger] {
    
}}
RT_CLASS!{static class BackgroundWorkCost}
impl RtActivatable<IBackgroundWorkCostStatics> for BackgroundWorkCost {}
impl BackgroundWorkCost {
    #[inline] pub fn get_current_background_work_cost() -> Result<BackgroundWorkCostValue> {
        <Self as RtActivatable<IBackgroundWorkCostStatics>>::get_activation_factory().get_current_background_work_cost()
    }
}
DEFINE_CLSID!(BackgroundWorkCost(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,66,97,99,107,103,114,111,117,110,100,87,111,114,107,67,111,115,116,0]) [CLSID_BackgroundWorkCost]);
DEFINE_IID!(IID_IBackgroundWorkCostStatics, 3342902882, 49936, 19330, 179, 227, 59, 207, 185, 228, 199, 125);
RT_INTERFACE!{static interface IBackgroundWorkCostStatics(IBackgroundWorkCostStaticsVtbl): IInspectable [IID_IBackgroundWorkCostStatics] {
    fn get_CurrentBackgroundWorkCost(&self, out: *mut BackgroundWorkCostValue) -> HRESULT
}}
impl IBackgroundWorkCostStatics {
    #[inline] pub fn get_current_background_work_cost(&self) -> Result<BackgroundWorkCostValue> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CurrentBackgroundWorkCost)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum BackgroundWorkCostValue: i32 {
    Low = 0, Medium = 1, High = 2,
}}
DEFINE_IID!(IID_IBluetoothLEAdvertisementPublisherTrigger, 2872976914, 9683, 18606, 135, 36, 216, 24, 119, 174, 97, 41);
RT_INTERFACE!{interface IBluetoothLEAdvertisementPublisherTrigger(IBluetoothLEAdvertisementPublisherTriggerVtbl): IInspectable [IID_IBluetoothLEAdvertisementPublisherTrigger] {
    #[cfg(feature="windows-devices")] fn get_Advertisement(&self, out: *mut <super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisement as RtType>::Abi) -> HRESULT
}}
impl IBluetoothLEAdvertisementPublisherTrigger {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_advertisement(&self) -> Result<Option<super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisement>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Advertisement)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisement::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisementPublisherTrigger: IBluetoothLEAdvertisementPublisherTrigger}
impl RtActivatable<IActivationFactory> for BluetoothLEAdvertisementPublisherTrigger {}
DEFINE_CLSID!(BluetoothLEAdvertisementPublisherTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,66,108,117,101,116,111,111,116,104,76,69,65,100,118,101,114,116,105,115,101,109,101,110,116,80,117,98,108,105,115,104,101,114,84,114,105,103,103,101,114,0]) [CLSID_BluetoothLEAdvertisementPublisherTrigger]);
DEFINE_IID!(IID_IBluetoothLEAdvertisementWatcherTrigger, 447420441, 48353, 18667, 168, 39, 89, 251, 124, 238, 82, 166);
RT_INTERFACE!{interface IBluetoothLEAdvertisementWatcherTrigger(IBluetoothLEAdvertisementWatcherTriggerVtbl): IInspectable [IID_IBluetoothLEAdvertisementWatcherTrigger] {
    fn get_MinSamplingInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_MaxSamplingInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_MinOutOfRangeTimeout(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_MaxOutOfRangeTimeout(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    #[cfg(feature="windows-devices")] fn get_SignalStrengthFilter(&self, out: *mut <super::super::devices::bluetooth::BluetoothSignalStrengthFilter as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-devices")] fn put_SignalStrengthFilter(&self, value: <super::super::devices::bluetooth::BluetoothSignalStrengthFilter as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-devices")] fn get_AdvertisementFilter(&self, out: *mut <super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisementFilter as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-devices")] fn put_AdvertisementFilter(&self, value: <super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisementFilter as RtType>::Abi) -> HRESULT
}}
impl IBluetoothLEAdvertisementWatcherTrigger {
    #[inline] pub fn get_min_sampling_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MinSamplingInterval)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_sampling_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MaxSamplingInterval)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_out_of_range_timeout(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MinOutOfRangeTimeout)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_out_of_range_timeout(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MaxOutOfRangeTimeout)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_signal_strength_filter(&self) -> Result<Option<super::super::devices::bluetooth::BluetoothSignalStrengthFilter>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SignalStrengthFilter)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::bluetooth::BluetoothSignalStrengthFilter::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn set_signal_strength_filter(&self, value: &super::super::devices::bluetooth::BluetoothSignalStrengthFilter) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SignalStrengthFilter)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_advertisement_filter(&self) -> Result<Option<super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisementFilter>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AdvertisementFilter)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisementFilter::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn set_advertisement_filter(&self, value: &super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisementFilter) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AdvertisementFilter)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisementWatcherTrigger: IBluetoothLEAdvertisementWatcherTrigger}
impl RtActivatable<IActivationFactory> for BluetoothLEAdvertisementWatcherTrigger {}
DEFINE_CLSID!(BluetoothLEAdvertisementWatcherTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,66,108,117,101,116,111,111,116,104,76,69,65,100,118,101,114,116,105,115,101,109,101,110,116,87,97,116,99,104,101,114,84,114,105,103,103,101,114,0]) [CLSID_BluetoothLEAdvertisementWatcherTrigger]);
DEFINE_IID!(IID_ICachedFileUpdaterTrigger, 3793530603, 13042, 19761, 181, 83, 185, 224, 27, 222, 55, 224);
RT_INTERFACE!{interface ICachedFileUpdaterTrigger(ICachedFileUpdaterTriggerVtbl): IInspectable [IID_ICachedFileUpdaterTrigger] {
    
}}
RT_CLASS!{class CachedFileUpdaterTrigger: ICachedFileUpdaterTrigger}
impl RtActivatable<IActivationFactory> for CachedFileUpdaterTrigger {}
DEFINE_CLSID!(CachedFileUpdaterTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,67,97,99,104,101,100,70,105,108,101,85,112,100,97,116,101,114,84,114,105,103,103,101,114,0]) [CLSID_CachedFileUpdaterTrigger]);
DEFINE_IID!(IID_ICachedFileUpdaterTriggerDetails, 1904446483, 4884, 18356, 149, 151, 220, 126, 36, 140, 23, 204);
RT_INTERFACE!{interface ICachedFileUpdaterTriggerDetails(ICachedFileUpdaterTriggerDetailsVtbl): IInspectable [IID_ICachedFileUpdaterTriggerDetails] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_UpdateTarget(&self, out: *mut super::super::storage::provider::CachedFileTarget) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_UpdateRequest(&self, out: *mut <super::super::storage::provider::FileUpdateRequest as RtType>::Abi) -> HRESULT,
    fn get_CanRequestUserInput(&self, out: *mut bool) -> HRESULT
}}
impl ICachedFileUpdaterTriggerDetails {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_update_target(&self) -> Result<super::super::storage::provider::CachedFileTarget> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_UpdateTarget)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_update_request(&self) -> Result<Option<super::super::storage::provider::FileUpdateRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_UpdateRequest)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::provider::FileUpdateRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_can_request_user_input(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanRequestUserInput)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CachedFileUpdaterTriggerDetails: ICachedFileUpdaterTriggerDetails}
DEFINE_IID!(IID_IChatMessageNotificationTrigger, 1362838463, 7488, 23645, 120, 245, 201, 35, 254, 227, 115, 158);
RT_INTERFACE!{interface IChatMessageNotificationTrigger(IChatMessageNotificationTriggerVtbl): IInspectable [IID_IChatMessageNotificationTrigger] {
    
}}
RT_CLASS!{class ChatMessageNotificationTrigger: IChatMessageNotificationTrigger}
impl RtActivatable<IActivationFactory> for ChatMessageNotificationTrigger {}
DEFINE_CLSID!(ChatMessageNotificationTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,67,104,97,116,77,101,115,115,97,103,101,78,111,116,105,102,105,99,97,116,105,111,110,84,114,105,103,103,101,114,0]) [CLSID_ChatMessageNotificationTrigger]);
DEFINE_IID!(IID_IChatMessageReceivedNotificationTrigger, 1050899982, 47861, 16503, 136, 233, 6, 12, 246, 240, 198, 213);
RT_INTERFACE!{interface IChatMessageReceivedNotificationTrigger(IChatMessageReceivedNotificationTriggerVtbl): IInspectable [IID_IChatMessageReceivedNotificationTrigger] {
    
}}
RT_CLASS!{class ChatMessageReceivedNotificationTrigger: IChatMessageReceivedNotificationTrigger}
impl RtActivatable<IActivationFactory> for ChatMessageReceivedNotificationTrigger {}
DEFINE_CLSID!(ChatMessageReceivedNotificationTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,67,104,97,116,77,101,115,115,97,103,101,82,101,99,101,105,118,101,100,78,111,116,105,102,105,99,97,116,105,111,110,84,114,105,103,103,101,114,0]) [CLSID_ChatMessageReceivedNotificationTrigger]);
DEFINE_IID!(IID_ICommunicationBlockingAppSetAsActiveTrigger, 4220646026, 5797, 18541, 151, 76, 120, 53, 168, 71, 123, 226);
RT_INTERFACE!{interface ICommunicationBlockingAppSetAsActiveTrigger(ICommunicationBlockingAppSetAsActiveTriggerVtbl): IInspectable [IID_ICommunicationBlockingAppSetAsActiveTrigger] {
    
}}
RT_CLASS!{class CommunicationBlockingAppSetAsActiveTrigger: ICommunicationBlockingAppSetAsActiveTrigger}
impl RtActivatable<IActivationFactory> for CommunicationBlockingAppSetAsActiveTrigger {}
DEFINE_CLSID!(CommunicationBlockingAppSetAsActiveTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,67,111,109,109,117,110,105,99,97,116,105,111,110,66,108,111,99,107,105,110,103,65,112,112,83,101,116,65,115,65,99,116,105,118,101,84,114,105,103,103,101,114,0]) [CLSID_CommunicationBlockingAppSetAsActiveTrigger]);
DEFINE_IID!(IID_IContactStoreNotificationTrigger, 3358802331, 18181, 17777, 154, 22, 6, 185, 151, 191, 156, 150);
RT_INTERFACE!{interface IContactStoreNotificationTrigger(IContactStoreNotificationTriggerVtbl): IInspectable [IID_IContactStoreNotificationTrigger] {
    
}}
RT_CLASS!{class ContactStoreNotificationTrigger: IContactStoreNotificationTrigger}
impl RtActivatable<IActivationFactory> for ContactStoreNotificationTrigger {}
DEFINE_CLSID!(ContactStoreNotificationTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,67,111,110,116,97,99,116,83,116,111,114,101,78,111,116,105,102,105,99,97,116,105,111,110,84,114,105,103,103,101,114,0]) [CLSID_ContactStoreNotificationTrigger]);
DEFINE_IID!(IID_IContentPrefetchTrigger, 1896228846, 1274, 17419, 128, 192, 23, 50, 2, 25, 158, 93);
RT_INTERFACE!{interface IContentPrefetchTrigger(IContentPrefetchTriggerVtbl): IInspectable [IID_IContentPrefetchTrigger] {
    fn get_WaitInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT
}}
impl IContentPrefetchTrigger {
    #[inline] pub fn get_wait_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_WaitInterval)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ContentPrefetchTrigger: IContentPrefetchTrigger}
impl RtActivatable<IContentPrefetchTriggerFactory> for ContentPrefetchTrigger {}
impl RtActivatable<IActivationFactory> for ContentPrefetchTrigger {}
impl ContentPrefetchTrigger {
    #[inline] pub fn create(waitInterval: foundation::TimeSpan) -> Result<ContentPrefetchTrigger> {
        <Self as RtActivatable<IContentPrefetchTriggerFactory>>::get_activation_factory().create(waitInterval)
    }
}
DEFINE_CLSID!(ContentPrefetchTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,67,111,110,116,101,110,116,80,114,101,102,101,116,99,104,84,114,105,103,103,101,114,0]) [CLSID_ContentPrefetchTrigger]);
DEFINE_IID!(IID_IContentPrefetchTriggerFactory, 3261349594, 35331, 16542, 184, 196, 136, 129, 76, 40, 204, 182);
RT_INTERFACE!{static interface IContentPrefetchTriggerFactory(IContentPrefetchTriggerFactoryVtbl): IInspectable [IID_IContentPrefetchTriggerFactory] {
    fn Create(&self, waitInterval: foundation::TimeSpan, out: *mut <ContentPrefetchTrigger as RtType>::Abi) -> HRESULT
}}
impl IContentPrefetchTriggerFactory {
    #[inline] pub fn create(&self, waitInterval: foundation::TimeSpan) -> Result<ContentPrefetchTrigger> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, waitInterval, &mut out);
        if hr == S_OK { Ok(ContentPrefetchTrigger::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICustomSystemEventTrigger, 4082722712, 53099, 20212, 160, 202, 41, 207, 74, 39, 140, 135);
RT_INTERFACE!{interface ICustomSystemEventTrigger(ICustomSystemEventTriggerVtbl): IInspectable [IID_ICustomSystemEventTrigger] {
    fn get_TriggerId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Recurrence(&self, out: *mut CustomSystemEventTriggerRecurrence) -> HRESULT
}}
impl ICustomSystemEventTrigger {
    #[inline] pub fn get_trigger_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TriggerId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_recurrence(&self) -> Result<CustomSystemEventTriggerRecurrence> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Recurrence)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CustomSystemEventTrigger: ICustomSystemEventTrigger}
impl RtActivatable<ICustomSystemEventTriggerFactory> for CustomSystemEventTrigger {}
impl CustomSystemEventTrigger {
    #[inline] pub fn create(triggerId: &HStringArg, recurrence: CustomSystemEventTriggerRecurrence) -> Result<CustomSystemEventTrigger> {
        <Self as RtActivatable<ICustomSystemEventTriggerFactory>>::get_activation_factory().create(triggerId, recurrence)
    }
}
DEFINE_CLSID!(CustomSystemEventTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,67,117,115,116,111,109,83,121,115,116,101,109,69,118,101,110,116,84,114,105,103,103,101,114,0]) [CLSID_CustomSystemEventTrigger]);
DEFINE_IID!(IID_ICustomSystemEventTriggerFactory, 1808471749, 62172, 16818, 158, 253, 185, 107, 220, 209, 60, 237);
RT_INTERFACE!{static interface ICustomSystemEventTriggerFactory(ICustomSystemEventTriggerFactoryVtbl): IInspectable [IID_ICustomSystemEventTriggerFactory] {
    fn Create(&self, triggerId: HSTRING, recurrence: CustomSystemEventTriggerRecurrence, out: *mut <CustomSystemEventTrigger as RtType>::Abi) -> HRESULT
}}
impl ICustomSystemEventTriggerFactory {
    #[inline] pub fn create(&self, triggerId: &HStringArg, recurrence: CustomSystemEventTriggerRecurrence) -> Result<CustomSystemEventTrigger> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, triggerId.get(), recurrence, &mut out);
        if hr == S_OK { Ok(CustomSystemEventTrigger::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum CustomSystemEventTriggerRecurrence: i32 {
    Once = 0, Always = 1,
}}
DEFINE_IID!(IID_IDeviceConnectionChangeTrigger, 2424790628, 15581, 20219, 171, 28, 91, 59, 106, 96, 206, 52);
RT_INTERFACE!{interface IDeviceConnectionChangeTrigger(IDeviceConnectionChangeTriggerVtbl): IInspectable [IID_IDeviceConnectionChangeTrigger] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CanMaintainConnection(&self, out: *mut bool) -> HRESULT,
    fn get_MaintainConnection(&self, out: *mut bool) -> HRESULT,
    fn put_MaintainConnection(&self, value: bool) -> HRESULT
}}
impl IDeviceConnectionChangeTrigger {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DeviceId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_can_maintain_connection(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanMaintainConnection)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_maintain_connection(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MaintainConnection)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_maintain_connection(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaintainConnection)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceConnectionChangeTrigger: IDeviceConnectionChangeTrigger}
impl RtActivatable<IDeviceConnectionChangeTriggerStatics> for DeviceConnectionChangeTrigger {}
impl DeviceConnectionChangeTrigger {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<DeviceConnectionChangeTrigger>> {
        <Self as RtActivatable<IDeviceConnectionChangeTriggerStatics>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(DeviceConnectionChangeTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,68,101,118,105,99,101,67,111,110,110,101,99,116,105,111,110,67,104,97,110,103,101,84,114,105,103,103,101,114,0]) [CLSID_DeviceConnectionChangeTrigger]);
DEFINE_IID!(IID_IDeviceConnectionChangeTriggerStatics, 3286901866, 20221, 17560, 170, 96, 164, 228, 227, 177, 122, 185);
RT_INTERFACE!{static interface IDeviceConnectionChangeTriggerStatics(IDeviceConnectionChangeTriggerStaticsVtbl): IInspectable [IID_IDeviceConnectionChangeTriggerStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<DeviceConnectionChangeTrigger> as RtType>::Abi) -> HRESULT
}}
impl IDeviceConnectionChangeTriggerStatics {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<DeviceConnectionChangeTrigger>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FromIdAsync)(self.get_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDeviceManufacturerNotificationTrigger, 2166852277, 16811, 5850, 134, 194, 127, 123, 240, 145, 47, 91);
RT_INTERFACE!{interface IDeviceManufacturerNotificationTrigger(IDeviceManufacturerNotificationTriggerVtbl): IInspectable [IID_IDeviceManufacturerNotificationTrigger] {
    fn get_TriggerQualifier(&self, out: *mut HSTRING) -> HRESULT,
    fn get_OneShot(&self, out: *mut bool) -> HRESULT
}}
impl IDeviceManufacturerNotificationTrigger {
    #[inline] pub fn get_trigger_qualifier(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TriggerQualifier)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_one_shot(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_OneShot)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceManufacturerNotificationTrigger: IDeviceManufacturerNotificationTrigger}
impl RtActivatable<IDeviceManufacturerNotificationTriggerFactory> for DeviceManufacturerNotificationTrigger {}
impl DeviceManufacturerNotificationTrigger {
    #[inline] pub fn create(triggerQualifier: &HStringArg, oneShot: bool) -> Result<DeviceManufacturerNotificationTrigger> {
        <Self as RtActivatable<IDeviceManufacturerNotificationTriggerFactory>>::get_activation_factory().create(triggerQualifier, oneShot)
    }
}
DEFINE_CLSID!(DeviceManufacturerNotificationTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,68,101,118,105,99,101,77,97,110,117,102,97,99,116,117,114,101,114,78,111,116,105,102,105,99,97,116,105,111,110,84,114,105,103,103,101,114,0]) [CLSID_DeviceManufacturerNotificationTrigger]);
DEFINE_IID!(IID_IDeviceManufacturerNotificationTriggerFactory, 2035670645, 9659, 16723, 161, 162, 48, 41, 252, 171, 182, 82);
RT_INTERFACE!{static interface IDeviceManufacturerNotificationTriggerFactory(IDeviceManufacturerNotificationTriggerFactoryVtbl): IInspectable [IID_IDeviceManufacturerNotificationTriggerFactory] {
    fn Create(&self, triggerQualifier: HSTRING, oneShot: bool, out: *mut <DeviceManufacturerNotificationTrigger as RtType>::Abi) -> HRESULT
}}
impl IDeviceManufacturerNotificationTriggerFactory {
    #[inline] pub fn create(&self, triggerQualifier: &HStringArg, oneShot: bool) -> Result<DeviceManufacturerNotificationTrigger> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, triggerQualifier.get(), oneShot, &mut out);
        if hr == S_OK { Ok(DeviceManufacturerNotificationTrigger::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDeviceServicingTrigger, 447879085, 28212, 18899, 158, 111, 23, 241, 182, 223, 168, 129);
RT_INTERFACE!{interface IDeviceServicingTrigger(IDeviceServicingTriggerVtbl): IInspectable [IID_IDeviceServicingTrigger] {
    fn RequestAsyncSimple(&self, deviceId: HSTRING, expectedDuration: foundation::TimeSpan, out: *mut <foundation::IAsyncOperation<DeviceTriggerResult> as RtType>::Abi) -> HRESULT,
    fn RequestAsyncWithArguments(&self, deviceId: HSTRING, expectedDuration: foundation::TimeSpan, arguments: HSTRING, out: *mut <foundation::IAsyncOperation<DeviceTriggerResult> as RtType>::Abi) -> HRESULT
}}
impl IDeviceServicingTrigger {
    #[inline] pub fn request_async_simple(&self, deviceId: &HStringArg, expectedDuration: foundation::TimeSpan) -> Result<foundation::IAsyncOperation<DeviceTriggerResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestAsyncSimple)(self.get_abi() as *const _ as *mut _, deviceId.get(), expectedDuration, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_async_with_arguments(&self, deviceId: &HStringArg, expectedDuration: foundation::TimeSpan, arguments: &HStringArg) -> Result<foundation::IAsyncOperation<DeviceTriggerResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestAsyncWithArguments)(self.get_abi() as *const _ as *mut _, deviceId.get(), expectedDuration, arguments.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceServicingTrigger: IDeviceServicingTrigger}
impl RtActivatable<IActivationFactory> for DeviceServicingTrigger {}
DEFINE_CLSID!(DeviceServicingTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,68,101,118,105,99,101,83,101,114,118,105,99,105,110,103,84,114,105,103,103,101,114,0]) [CLSID_DeviceServicingTrigger]);
RT_ENUM! { enum DeviceTriggerResult: i32 {
    Allowed = 0, DeniedByUser = 1, DeniedBySystem = 2, LowBattery = 3,
}}
DEFINE_IID!(IID_IDeviceUseTrigger, 229015569, 13135, 19799, 182, 236, 109, 202, 100, 180, 18, 228);
RT_INTERFACE!{interface IDeviceUseTrigger(IDeviceUseTriggerVtbl): IInspectable [IID_IDeviceUseTrigger] {
    fn RequestAsyncSimple(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<DeviceTriggerResult> as RtType>::Abi) -> HRESULT,
    fn RequestAsyncWithArguments(&self, deviceId: HSTRING, arguments: HSTRING, out: *mut <foundation::IAsyncOperation<DeviceTriggerResult> as RtType>::Abi) -> HRESULT
}}
impl IDeviceUseTrigger {
    #[inline] pub fn request_async_simple(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<DeviceTriggerResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestAsyncSimple)(self.get_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_async_with_arguments(&self, deviceId: &HStringArg, arguments: &HStringArg) -> Result<foundation::IAsyncOperation<DeviceTriggerResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestAsyncWithArguments)(self.get_abi() as *const _ as *mut _, deviceId.get(), arguments.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceUseTrigger: IDeviceUseTrigger}
impl RtActivatable<IActivationFactory> for DeviceUseTrigger {}
DEFINE_CLSID!(DeviceUseTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,68,101,118,105,99,101,85,115,101,84,114,105,103,103,101,114,0]) [CLSID_DeviceUseTrigger]);
DEFINE_IID!(IID_IDeviceWatcherTrigger, 2757853149, 34163, 16992, 190, 252, 91, 236, 137, 203, 105, 61);
RT_INTERFACE!{interface IDeviceWatcherTrigger(IDeviceWatcherTriggerVtbl): IInspectable [IID_IDeviceWatcherTrigger] {
    
}}
RT_CLASS!{class DeviceWatcherTrigger: IDeviceWatcherTrigger}
DEFINE_IID!(IID_IEmailStoreNotificationTrigger, 2557282010, 18411, 17000, 164, 242, 243, 247, 113, 136, 56, 138);
RT_INTERFACE!{interface IEmailStoreNotificationTrigger(IEmailStoreNotificationTriggerVtbl): IInspectable [IID_IEmailStoreNotificationTrigger] {
    
}}
RT_CLASS!{class EmailStoreNotificationTrigger: IEmailStoreNotificationTrigger}
impl RtActivatable<IActivationFactory> for EmailStoreNotificationTrigger {}
DEFINE_CLSID!(EmailStoreNotificationTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,69,109,97,105,108,83,116,111,114,101,78,111,116,105,102,105,99,97,116,105,111,110,84,114,105,103,103,101,114,0]) [CLSID_EmailStoreNotificationTrigger]);
DEFINE_IID!(IID_IGattCharacteristicNotificationTrigger, 3797913544, 1686, 18255, 167, 50, 242, 146, 176, 206, 188, 93);
RT_INTERFACE!{interface IGattCharacteristicNotificationTrigger(IGattCharacteristicNotificationTriggerVtbl): IInspectable [IID_IGattCharacteristicNotificationTrigger] {
    #[cfg(feature="windows-devices")] fn get_Characteristic(&self, out: *mut <super::super::devices::bluetooth::genericattributeprofile::GattCharacteristic as RtType>::Abi) -> HRESULT
}}
impl IGattCharacteristicNotificationTrigger {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_characteristic(&self) -> Result<Option<super::super::devices::bluetooth::genericattributeprofile::GattCharacteristic>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Characteristic)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::bluetooth::genericattributeprofile::GattCharacteristic::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattCharacteristicNotificationTrigger: IGattCharacteristicNotificationTrigger}
impl RtActivatable<IGattCharacteristicNotificationTriggerFactory> for GattCharacteristicNotificationTrigger {}
impl RtActivatable<IGattCharacteristicNotificationTriggerFactory2> for GattCharacteristicNotificationTrigger {}
impl GattCharacteristicNotificationTrigger {
    #[cfg(feature="windows-devices")] #[inline] pub fn create(characteristic: &super::super::devices::bluetooth::genericattributeprofile::GattCharacteristic) -> Result<GattCharacteristicNotificationTrigger> {
        <Self as RtActivatable<IGattCharacteristicNotificationTriggerFactory>>::get_activation_factory().create(characteristic)
    }
    #[cfg(feature="windows-devices")] #[inline] pub fn create_with_event_triggering_mode(characteristic: &super::super::devices::bluetooth::genericattributeprofile::GattCharacteristic, eventTriggeringMode: super::super::devices::bluetooth::background::BluetoothEventTriggeringMode) -> Result<GattCharacteristicNotificationTrigger> {
        <Self as RtActivatable<IGattCharacteristicNotificationTriggerFactory2>>::get_activation_factory().create_with_event_triggering_mode(characteristic, eventTriggeringMode)
    }
}
DEFINE_CLSID!(GattCharacteristicNotificationTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,71,97,116,116,67,104,97,114,97,99,116,101,114,105,115,116,105,99,78,111,116,105,102,105,99,97,116,105,111,110,84,114,105,103,103,101,114,0]) [CLSID_GattCharacteristicNotificationTrigger]);
DEFINE_IID!(IID_IGattCharacteristicNotificationTrigger2, 2468520644, 44558, 17138, 178, 140, 245, 19, 114, 230, 146, 69);
RT_INTERFACE!{interface IGattCharacteristicNotificationTrigger2(IGattCharacteristicNotificationTrigger2Vtbl): IInspectable [IID_IGattCharacteristicNotificationTrigger2] {
    #[cfg(feature="windows-devices")] fn get_EventTriggeringMode(&self, out: *mut super::super::devices::bluetooth::background::BluetoothEventTriggeringMode) -> HRESULT
}}
impl IGattCharacteristicNotificationTrigger2 {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_event_triggering_mode(&self) -> Result<super::super::devices::bluetooth::background::BluetoothEventTriggeringMode> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_EventTriggeringMode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattCharacteristicNotificationTriggerFactory, 1471814037, 45379, 17781, 159, 107, 253, 89, 217, 58, 206, 26);
RT_INTERFACE!{static interface IGattCharacteristicNotificationTriggerFactory(IGattCharacteristicNotificationTriggerFactoryVtbl): IInspectable [IID_IGattCharacteristicNotificationTriggerFactory] {
    #[cfg(feature="windows-devices")] fn Create(&self, characteristic: <super::super::devices::bluetooth::genericattributeprofile::GattCharacteristic as RtType>::Abi, out: *mut <GattCharacteristicNotificationTrigger as RtType>::Abi) -> HRESULT
}}
impl IGattCharacteristicNotificationTriggerFactory {
    #[cfg(feature="windows-devices")] #[inline] pub fn create(&self, characteristic: &super::super::devices::bluetooth::genericattributeprofile::GattCharacteristic) -> Result<GattCharacteristicNotificationTrigger> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, characteristic.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GattCharacteristicNotificationTrigger::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattCharacteristicNotificationTriggerFactory2, 1503193375, 35411, 20127, 163, 44, 35, 205, 51, 102, 76, 238);
RT_INTERFACE!{static interface IGattCharacteristicNotificationTriggerFactory2(IGattCharacteristicNotificationTriggerFactory2Vtbl): IInspectable [IID_IGattCharacteristicNotificationTriggerFactory2] {
    #[cfg(feature="windows-devices")] fn CreateWithEventTriggeringMode(&self, characteristic: <super::super::devices::bluetooth::genericattributeprofile::GattCharacteristic as RtType>::Abi, eventTriggeringMode: super::super::devices::bluetooth::background::BluetoothEventTriggeringMode, out: *mut <GattCharacteristicNotificationTrigger as RtType>::Abi) -> HRESULT
}}
impl IGattCharacteristicNotificationTriggerFactory2 {
    #[cfg(feature="windows-devices")] #[inline] pub fn create_with_event_triggering_mode(&self, characteristic: &super::super::devices::bluetooth::genericattributeprofile::GattCharacteristic, eventTriggeringMode: super::super::devices::bluetooth::background::BluetoothEventTriggeringMode) -> Result<GattCharacteristicNotificationTrigger> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWithEventTriggeringMode)(self.get_abi() as *const _ as *mut _, characteristic.get_abi() as *const _ as *mut _, eventTriggeringMode, &mut out);
        if hr == S_OK { Ok(GattCharacteristicNotificationTrigger::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattServiceProviderTrigger, 3720782825, 5463, 19416, 133, 66, 70, 138, 160, 198, 150, 246);
RT_INTERFACE!{interface IGattServiceProviderTrigger(IGattServiceProviderTriggerVtbl): IInspectable [IID_IGattServiceProviderTrigger] {
    fn get_TriggerId(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(feature="windows-devices")] fn get_Service(&self, out: *mut <super::super::devices::bluetooth::genericattributeprofile::GattLocalService as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-devices")] fn put_AdvertisingParameters(&self, value: <super::super::devices::bluetooth::genericattributeprofile::GattServiceProviderAdvertisingParameters as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-devices")] fn get_AdvertisingParameters(&self, out: *mut <super::super::devices::bluetooth::genericattributeprofile::GattServiceProviderAdvertisingParameters as RtType>::Abi) -> HRESULT
}}
impl IGattServiceProviderTrigger {
    #[inline] pub fn get_trigger_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TriggerId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_service(&self) -> Result<Option<super::super::devices::bluetooth::genericattributeprofile::GattLocalService>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Service)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::bluetooth::genericattributeprofile::GattLocalService::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn set_advertising_parameters(&self, value: &super::super::devices::bluetooth::genericattributeprofile::GattServiceProviderAdvertisingParameters) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AdvertisingParameters)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_advertising_parameters(&self) -> Result<Option<super::super::devices::bluetooth::genericattributeprofile::GattServiceProviderAdvertisingParameters>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AdvertisingParameters)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::bluetooth::genericattributeprofile::GattServiceProviderAdvertisingParameters::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattServiceProviderTrigger: IGattServiceProviderTrigger}
impl RtActivatable<IGattServiceProviderTriggerStatics> for GattServiceProviderTrigger {}
impl GattServiceProviderTrigger {
    #[inline] pub fn create_async(triggerId: &HStringArg, serviceUuid: Guid) -> Result<foundation::IAsyncOperation<GattServiceProviderTriggerResult>> {
        <Self as RtActivatable<IGattServiceProviderTriggerStatics>>::get_activation_factory().create_async(triggerId, serviceUuid)
    }
}
DEFINE_CLSID!(GattServiceProviderTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,71,97,116,116,83,101,114,118,105,99,101,80,114,111,118,105,100,101,114,84,114,105,103,103,101,114,0]) [CLSID_GattServiceProviderTrigger]);
DEFINE_IID!(IID_IGattServiceProviderTriggerResult, 1011257777, 45464, 20100, 186, 212, 207, 74, 210, 153, 237, 58);
RT_INTERFACE!{interface IGattServiceProviderTriggerResult(IGattServiceProviderTriggerResultVtbl): IInspectable [IID_IGattServiceProviderTriggerResult] {
    fn get_Trigger(&self, out: *mut <GattServiceProviderTrigger as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-devices")] fn get_Error(&self, out: *mut super::super::devices::bluetooth::BluetoothError) -> HRESULT
}}
impl IGattServiceProviderTriggerResult {
    #[inline] pub fn get_trigger(&self) -> Result<Option<GattServiceProviderTrigger>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Trigger)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GattServiceProviderTrigger::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_error(&self) -> Result<super::super::devices::bluetooth::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Error)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattServiceProviderTriggerResult: IGattServiceProviderTriggerResult}
DEFINE_IID!(IID_IGattServiceProviderTriggerStatics, 3021185898, 58004, 17809, 165, 166, 100, 137, 26, 130, 129, 83);
RT_INTERFACE!{static interface IGattServiceProviderTriggerStatics(IGattServiceProviderTriggerStaticsVtbl): IInspectable [IID_IGattServiceProviderTriggerStatics] {
    fn CreateAsync(&self, triggerId: HSTRING, serviceUuid: Guid, out: *mut <foundation::IAsyncOperation<GattServiceProviderTriggerResult> as RtType>::Abi) -> HRESULT
}}
impl IGattServiceProviderTriggerStatics {
    #[inline] pub fn create_async(&self, triggerId: &HStringArg, serviceUuid: Guid) -> Result<foundation::IAsyncOperation<GattServiceProviderTriggerResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateAsync)(self.get_abi() as *const _ as *mut _, triggerId.get(), serviceUuid, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeovisitTrigger, 1209593258, 1249, 16679, 154, 76, 25, 53, 27, 138, 128, 164);
RT_INTERFACE!{interface IGeovisitTrigger(IGeovisitTriggerVtbl): IInspectable [IID_IGeovisitTrigger] {
    #[cfg(feature="windows-devices")] fn get_MonitoringScope(&self, out: *mut super::super::devices::geolocation::VisitMonitoringScope) -> HRESULT,
    #[cfg(feature="windows-devices")] fn put_MonitoringScope(&self, value: super::super::devices::geolocation::VisitMonitoringScope) -> HRESULT
}}
impl IGeovisitTrigger {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_monitoring_scope(&self) -> Result<super::super::devices::geolocation::VisitMonitoringScope> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MonitoringScope)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn set_monitoring_scope(&self, value: super::super::devices::geolocation::VisitMonitoringScope) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MonitoringScope)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GeovisitTrigger: IGeovisitTrigger}
impl RtActivatable<IActivationFactory> for GeovisitTrigger {}
DEFINE_CLSID!(GeovisitTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,71,101,111,118,105,115,105,116,84,114,105,103,103,101,114,0]) [CLSID_GeovisitTrigger]);
DEFINE_IID!(IID_ILocationTrigger, 1197894172, 26743, 18462, 128, 38, 255, 126, 20, 168, 17, 160);
RT_INTERFACE!{interface ILocationTrigger(ILocationTriggerVtbl): IInspectable [IID_ILocationTrigger] {
    fn get_TriggerType(&self, out: *mut LocationTriggerType) -> HRESULT
}}
impl ILocationTrigger {
    #[inline] pub fn get_trigger_type(&self) -> Result<LocationTriggerType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_TriggerType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class LocationTrigger: ILocationTrigger}
impl RtActivatable<ILocationTriggerFactory> for LocationTrigger {}
impl LocationTrigger {
    #[inline] pub fn create(triggerType: LocationTriggerType) -> Result<LocationTrigger> {
        <Self as RtActivatable<ILocationTriggerFactory>>::get_activation_factory().create(triggerType)
    }
}
DEFINE_CLSID!(LocationTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,76,111,99,97,116,105,111,110,84,114,105,103,103,101,114,0]) [CLSID_LocationTrigger]);
DEFINE_IID!(IID_ILocationTriggerFactory, 285653767, 65385, 19977, 170, 139, 19, 132, 234, 71, 94, 152);
RT_INTERFACE!{static interface ILocationTriggerFactory(ILocationTriggerFactoryVtbl): IInspectable [IID_ILocationTriggerFactory] {
    fn Create(&self, triggerType: LocationTriggerType, out: *mut <LocationTrigger as RtType>::Abi) -> HRESULT
}}
impl ILocationTriggerFactory {
    #[inline] pub fn create(&self, triggerType: LocationTriggerType) -> Result<LocationTrigger> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, triggerType, &mut out);
        if hr == S_OK { Ok(LocationTrigger::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum LocationTriggerType: i32 {
    Geofence = 0,
}}
DEFINE_IID!(IID_IMaintenanceTrigger, 1746422915, 64546, 19685, 132, 26, 114, 57, 169, 129, 0, 71);
RT_INTERFACE!{interface IMaintenanceTrigger(IMaintenanceTriggerVtbl): IInspectable [IID_IMaintenanceTrigger] {
    fn get_FreshnessTime(&self, out: *mut u32) -> HRESULT,
    fn get_OneShot(&self, out: *mut bool) -> HRESULT
}}
impl IMaintenanceTrigger {
    #[inline] pub fn get_freshness_time(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_FreshnessTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_one_shot(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_OneShot)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MaintenanceTrigger: IMaintenanceTrigger}
impl RtActivatable<IMaintenanceTriggerFactory> for MaintenanceTrigger {}
impl MaintenanceTrigger {
    #[inline] pub fn create(freshnessTime: u32, oneShot: bool) -> Result<MaintenanceTrigger> {
        <Self as RtActivatable<IMaintenanceTriggerFactory>>::get_activation_factory().create(freshnessTime, oneShot)
    }
}
DEFINE_CLSID!(MaintenanceTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,77,97,105,110,116,101,110,97,110,99,101,84,114,105,103,103,101,114,0]) [CLSID_MaintenanceTrigger]);
DEFINE_IID!(IID_IMaintenanceTriggerFactory, 1262345006, 38877, 17961, 136, 176, 176, 108, 249, 72, 42, 229);
RT_INTERFACE!{static interface IMaintenanceTriggerFactory(IMaintenanceTriggerFactoryVtbl): IInspectable [IID_IMaintenanceTriggerFactory] {
    fn Create(&self, freshnessTime: u32, oneShot: bool, out: *mut <MaintenanceTrigger as RtType>::Abi) -> HRESULT
}}
impl IMaintenanceTriggerFactory {
    #[inline] pub fn create(&self, freshnessTime: u32, oneShot: bool) -> Result<MaintenanceTrigger> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, freshnessTime, oneShot, &mut out);
        if hr == S_OK { Ok(MaintenanceTrigger::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaProcessingTrigger, 2593504869, 35410, 19248, 144, 17, 207, 56, 4, 14, 168, 176);
RT_INTERFACE!{interface IMediaProcessingTrigger(IMediaProcessingTriggerVtbl): IInspectable [IID_IMediaProcessingTrigger] {
    fn RequestAsync(&self, out: *mut <foundation::IAsyncOperation<MediaProcessingTriggerResult> as RtType>::Abi) -> HRESULT,
    fn RequestAsyncWithArguments(&self, arguments: <foundation::collections::ValueSet as RtType>::Abi, out: *mut <foundation::IAsyncOperation<MediaProcessingTriggerResult> as RtType>::Abi) -> HRESULT
}}
impl IMediaProcessingTrigger {
    #[inline] pub fn request_async(&self) -> Result<foundation::IAsyncOperation<MediaProcessingTriggerResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_async_with_arguments(&self, arguments: &foundation::collections::ValueSet) -> Result<foundation::IAsyncOperation<MediaProcessingTriggerResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestAsyncWithArguments)(self.get_abi() as *const _ as *mut _, arguments.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaProcessingTrigger: IMediaProcessingTrigger}
impl RtActivatable<IActivationFactory> for MediaProcessingTrigger {}
DEFINE_CLSID!(MediaProcessingTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,77,101,100,105,97,80,114,111,99,101,115,115,105,110,103,84,114,105,103,103,101,114,0]) [CLSID_MediaProcessingTrigger]);
RT_ENUM! { enum MediaProcessingTriggerResult: i32 {
    Allowed = 0, CurrentlyRunning = 1, DisabledByPolicy = 2, UnknownError = 3,
}}
RT_CLASS!{class MobileBroadbandDeviceServiceNotificationTrigger: IBackgroundTrigger}
impl RtActivatable<IActivationFactory> for MobileBroadbandDeviceServiceNotificationTrigger {}
DEFINE_CLSID!(MobileBroadbandDeviceServiceNotificationTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,77,111,98,105,108,101,66,114,111,97,100,98,97,110,100,68,101,118,105,99,101,83,101,114,118,105,99,101,78,111,116,105,102,105,99,97,116,105,111,110,84,114,105,103,103,101,114,0]) [CLSID_MobileBroadbandDeviceServiceNotificationTrigger]);
RT_CLASS!{class MobileBroadbandPcoDataChangeTrigger: IBackgroundTrigger}
impl RtActivatable<IActivationFactory> for MobileBroadbandPcoDataChangeTrigger {}
DEFINE_CLSID!(MobileBroadbandPcoDataChangeTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,77,111,98,105,108,101,66,114,111,97,100,98,97,110,100,80,99,111,68,97,116,97,67,104,97,110,103,101,84,114,105,103,103,101,114,0]) [CLSID_MobileBroadbandPcoDataChangeTrigger]);
RT_CLASS!{class MobileBroadbandPinLockStateChangeTrigger: IBackgroundTrigger}
impl RtActivatable<IActivationFactory> for MobileBroadbandPinLockStateChangeTrigger {}
DEFINE_CLSID!(MobileBroadbandPinLockStateChangeTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,77,111,98,105,108,101,66,114,111,97,100,98,97,110,100,80,105,110,76,111,99,107,83,116,97,116,101,67,104,97,110,103,101,84,114,105,103,103,101,114,0]) [CLSID_MobileBroadbandPinLockStateChangeTrigger]);
RT_CLASS!{class MobileBroadbandRadioStateChangeTrigger: IBackgroundTrigger}
impl RtActivatable<IActivationFactory> for MobileBroadbandRadioStateChangeTrigger {}
DEFINE_CLSID!(MobileBroadbandRadioStateChangeTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,77,111,98,105,108,101,66,114,111,97,100,98,97,110,100,82,97,100,105,111,83,116,97,116,101,67,104,97,110,103,101,84,114,105,103,103,101,114,0]) [CLSID_MobileBroadbandRadioStateChangeTrigger]);
RT_CLASS!{class MobileBroadbandRegistrationStateChangeTrigger: IBackgroundTrigger}
impl RtActivatable<IActivationFactory> for MobileBroadbandRegistrationStateChangeTrigger {}
DEFINE_CLSID!(MobileBroadbandRegistrationStateChangeTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,77,111,98,105,108,101,66,114,111,97,100,98,97,110,100,82,101,103,105,115,116,114,97,116,105,111,110,83,116,97,116,101,67,104,97,110,103,101,84,114,105,103,103,101,114,0]) [CLSID_MobileBroadbandRegistrationStateChangeTrigger]);
RT_CLASS!{class NetworkOperatorDataUsageTrigger: IBackgroundTrigger}
impl RtActivatable<IActivationFactory> for NetworkOperatorDataUsageTrigger {}
DEFINE_CLSID!(NetworkOperatorDataUsageTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,78,101,116,119,111,114,107,79,112,101,114,97,116,111,114,68,97,116,97,85,115,97,103,101,84,114,105,103,103,101,114,0]) [CLSID_NetworkOperatorDataUsageTrigger]);
DEFINE_IID!(IID_INetworkOperatorHotspotAuthenticationTrigger, 3881224081, 12289, 19941, 131, 199, 222, 97, 216, 136, 49, 208);
RT_INTERFACE!{interface INetworkOperatorHotspotAuthenticationTrigger(INetworkOperatorHotspotAuthenticationTriggerVtbl): IInspectable [IID_INetworkOperatorHotspotAuthenticationTrigger] {
    
}}
RT_CLASS!{class NetworkOperatorHotspotAuthenticationTrigger: INetworkOperatorHotspotAuthenticationTrigger}
impl RtActivatable<IActivationFactory> for NetworkOperatorHotspotAuthenticationTrigger {}
DEFINE_CLSID!(NetworkOperatorHotspotAuthenticationTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,78,101,116,119,111,114,107,79,112,101,114,97,116,111,114,72,111,116,115,112,111,116,65,117,116,104,101,110,116,105,99,97,116,105,111,110,84,114,105,103,103,101,114,0]) [CLSID_NetworkOperatorHotspotAuthenticationTrigger]);
DEFINE_IID!(IID_INetworkOperatorNotificationTrigger, 2416483526, 25549, 18444, 149, 209, 110, 106, 239, 128, 30, 74);
RT_INTERFACE!{interface INetworkOperatorNotificationTrigger(INetworkOperatorNotificationTriggerVtbl): IInspectable [IID_INetworkOperatorNotificationTrigger] {
    fn get_NetworkAccountId(&self, out: *mut HSTRING) -> HRESULT
}}
impl INetworkOperatorNotificationTrigger {
    #[inline] pub fn get_network_account_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_NetworkAccountId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class NetworkOperatorNotificationTrigger: INetworkOperatorNotificationTrigger}
impl RtActivatable<INetworkOperatorNotificationTriggerFactory> for NetworkOperatorNotificationTrigger {}
impl NetworkOperatorNotificationTrigger {
    #[inline] pub fn create(networkAccountId: &HStringArg) -> Result<NetworkOperatorNotificationTrigger> {
        <Self as RtActivatable<INetworkOperatorNotificationTriggerFactory>>::get_activation_factory().create(networkAccountId)
    }
}
DEFINE_CLSID!(NetworkOperatorNotificationTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,78,101,116,119,111,114,107,79,112,101,114,97,116,111,114,78,111,116,105,102,105,99,97,116,105,111,110,84,114,105,103,103,101,114,0]) [CLSID_NetworkOperatorNotificationTrigger]);
DEFINE_IID!(IID_INetworkOperatorNotificationTriggerFactory, 170016256, 10199, 17235, 173, 185, 146, 101, 170, 234, 87, 157);
RT_INTERFACE!{static interface INetworkOperatorNotificationTriggerFactory(INetworkOperatorNotificationTriggerFactoryVtbl): IInspectable [IID_INetworkOperatorNotificationTriggerFactory] {
    fn Create(&self, networkAccountId: HSTRING, out: *mut <NetworkOperatorNotificationTrigger as RtType>::Abi) -> HRESULT
}}
impl INetworkOperatorNotificationTriggerFactory {
    #[inline] pub fn create(&self, networkAccountId: &HStringArg) -> Result<NetworkOperatorNotificationTrigger> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, networkAccountId.get(), &mut out);
        if hr == S_OK { Ok(NetworkOperatorNotificationTrigger::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PaymentAppCanMakePaymentTrigger: IBackgroundTrigger}
impl RtActivatable<IActivationFactory> for PaymentAppCanMakePaymentTrigger {}
DEFINE_CLSID!(PaymentAppCanMakePaymentTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,80,97,121,109,101,110,116,65,112,112,67,97,110,77,97,107,101,80,97,121,109,101,110,116,84,114,105,103,103,101,114,0]) [CLSID_PaymentAppCanMakePaymentTrigger]);
DEFINE_IID!(IID_IPhoneTrigger, 2379213211, 54469, 18929, 183, 211, 130, 232, 122, 14, 157, 222);
RT_INTERFACE!{interface IPhoneTrigger(IPhoneTriggerVtbl): IInspectable [IID_IPhoneTrigger] {
    fn get_OneShot(&self, out: *mut bool) -> HRESULT,
    fn get_TriggerType(&self, out: *mut super::calls::background::PhoneTriggerType) -> HRESULT
}}
impl IPhoneTrigger {
    #[inline] pub fn get_one_shot(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_OneShot)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_trigger_type(&self) -> Result<super::calls::background::PhoneTriggerType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_TriggerType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PhoneTrigger: IPhoneTrigger}
impl RtActivatable<IPhoneTriggerFactory> for PhoneTrigger {}
impl PhoneTrigger {
    #[inline] pub fn create(type_: super::calls::background::PhoneTriggerType, oneShot: bool) -> Result<PhoneTrigger> {
        <Self as RtActivatable<IPhoneTriggerFactory>>::get_activation_factory().create(type_, oneShot)
    }
}
DEFINE_CLSID!(PhoneTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,80,104,111,110,101,84,114,105,103,103,101,114,0]) [CLSID_PhoneTrigger]);
DEFINE_IID!(IID_IPhoneTriggerFactory, 2698591450, 24513, 18683, 165, 70, 50, 38, 32, 64, 21, 123);
RT_INTERFACE!{static interface IPhoneTriggerFactory(IPhoneTriggerFactoryVtbl): IInspectable [IID_IPhoneTriggerFactory] {
    fn Create(&self, type_: super::calls::background::PhoneTriggerType, oneShot: bool, out: *mut <PhoneTrigger as RtType>::Abi) -> HRESULT
}}
impl IPhoneTriggerFactory {
    #[inline] pub fn create(&self, type_: super::calls::background::PhoneTriggerType, oneShot: bool) -> Result<PhoneTrigger> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, type_, oneShot, &mut out);
        if hr == S_OK { Ok(PhoneTrigger::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PushNotificationTrigger: IBackgroundTrigger}
impl RtActivatable<IPushNotificationTriggerFactory> for PushNotificationTrigger {}
impl RtActivatable<IActivationFactory> for PushNotificationTrigger {}
impl PushNotificationTrigger {
    #[inline] pub fn create(applicationId: &HStringArg) -> Result<PushNotificationTrigger> {
        <Self as RtActivatable<IPushNotificationTriggerFactory>>::get_activation_factory().create(applicationId)
    }
}
DEFINE_CLSID!(PushNotificationTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,80,117,115,104,78,111,116,105,102,105,99,97,116,105,111,110,84,114,105,103,103,101,114,0]) [CLSID_PushNotificationTrigger]);
DEFINE_IID!(IID_IPushNotificationTriggerFactory, 1842933019, 17806, 20418, 188, 46, 213, 102, 79, 119, 237, 25);
RT_INTERFACE!{static interface IPushNotificationTriggerFactory(IPushNotificationTriggerFactoryVtbl): IInspectable [IID_IPushNotificationTriggerFactory] {
    fn Create(&self, applicationId: HSTRING, out: *mut <PushNotificationTrigger as RtType>::Abi) -> HRESULT
}}
impl IPushNotificationTriggerFactory {
    #[inline] pub fn create(&self, applicationId: &HStringArg) -> Result<PushNotificationTrigger> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, applicationId.get(), &mut out);
        if hr == S_OK { Ok(PushNotificationTrigger::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRcsEndUserMessageAvailableTrigger, 2557283690, 45814, 18047, 169, 120, 164, 64, 145, 193, 26, 102);
RT_INTERFACE!{interface IRcsEndUserMessageAvailableTrigger(IRcsEndUserMessageAvailableTriggerVtbl): IInspectable [IID_IRcsEndUserMessageAvailableTrigger] {
    
}}
RT_CLASS!{class RcsEndUserMessageAvailableTrigger: IRcsEndUserMessageAvailableTrigger}
impl RtActivatable<IActivationFactory> for RcsEndUserMessageAvailableTrigger {}
DEFINE_CLSID!(RcsEndUserMessageAvailableTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,82,99,115,69,110,100,85,115,101,114,77,101,115,115,97,103,101,65,118,97,105,108,97,98,108,101,84,114,105,103,103,101,114,0]) [CLSID_RcsEndUserMessageAvailableTrigger]);
DEFINE_IID!(IID_IRfcommConnectionTrigger, 3905211106, 2899, 17508, 147, 148, 253, 135, 86, 84, 222, 100);
RT_INTERFACE!{interface IRfcommConnectionTrigger(IRfcommConnectionTriggerVtbl): IInspectable [IID_IRfcommConnectionTrigger] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_InboundConnection(&self, out: *mut <super::super::devices::bluetooth::background::RfcommInboundConnectionInformation as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_OutboundConnection(&self, out: *mut <super::super::devices::bluetooth::background::RfcommOutboundConnectionInformation as RtType>::Abi) -> HRESULT,
    fn get_AllowMultipleConnections(&self, out: *mut bool) -> HRESULT,
    fn put_AllowMultipleConnections(&self, value: bool) -> HRESULT,
    #[cfg(feature="windows-networking")] fn get_ProtectionLevel(&self, out: *mut super::super::networking::sockets::SocketProtectionLevel) -> HRESULT,
    #[cfg(feature="windows-networking")] fn put_ProtectionLevel(&self, value: super::super::networking::sockets::SocketProtectionLevel) -> HRESULT,
    #[cfg(feature="windows-networking")] fn get_RemoteHostName(&self, out: *mut <super::super::networking::HostName as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-networking")] fn put_RemoteHostName(&self, value: <super::super::networking::HostName as RtType>::Abi) -> HRESULT
}}
impl IRfcommConnectionTrigger {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_inbound_connection(&self) -> Result<Option<super::super::devices::bluetooth::background::RfcommInboundConnectionInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_InboundConnection)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::bluetooth::background::RfcommInboundConnectionInformation::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_outbound_connection(&self) -> Result<Option<super::super::devices::bluetooth::background::RfcommOutboundConnectionInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_OutboundConnection)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::bluetooth::background::RfcommOutboundConnectionInformation::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_allow_multiple_connections(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AllowMultipleConnections)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_allow_multiple_connections(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AllowMultipleConnections)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn get_protection_level(&self) -> Result<super::super::networking::sockets::SocketProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ProtectionLevel)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn set_protection_level(&self, value: super::super::networking::sockets::SocketProtectionLevel) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ProtectionLevel)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn get_remote_host_name(&self) -> Result<Option<super::super::networking::HostName>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RemoteHostName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::networking::HostName::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn set_remote_host_name(&self, value: &super::super::networking::HostName) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RemoteHostName)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class RfcommConnectionTrigger: IRfcommConnectionTrigger}
impl RtActivatable<IActivationFactory> for RfcommConnectionTrigger {}
DEFINE_CLSID!(RfcommConnectionTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,82,102,99,111,109,109,67,111,110,110,101,99,116,105,111,110,84,114,105,103,103,101,114,0]) [CLSID_RfcommConnectionTrigger]);
DEFINE_IID!(IID_ISecondaryAuthenticationFactorAuthenticationTrigger, 4063752999, 20865, 20260, 150, 167, 112, 10, 78, 95, 172, 98);
RT_INTERFACE!{interface ISecondaryAuthenticationFactorAuthenticationTrigger(ISecondaryAuthenticationFactorAuthenticationTriggerVtbl): IInspectable [IID_ISecondaryAuthenticationFactorAuthenticationTrigger] {
    
}}
RT_CLASS!{class SecondaryAuthenticationFactorAuthenticationTrigger: ISecondaryAuthenticationFactorAuthenticationTrigger}
impl RtActivatable<IActivationFactory> for SecondaryAuthenticationFactorAuthenticationTrigger {}
DEFINE_CLSID!(SecondaryAuthenticationFactorAuthenticationTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,83,101,99,111,110,100,97,114,121,65,117,116,104,101,110,116,105,99,97,116,105,111,110,70,97,99,116,111,114,65,117,116,104,101,110,116,105,99,97,116,105,111,110,84,114,105,103,103,101,114,0]) [CLSID_SecondaryAuthenticationFactorAuthenticationTrigger]);
DEFINE_IID!(IID_ISensorDataThresholdTrigger, 1539371890, 54411, 19327, 171, 236, 21, 249, 186, 204, 18, 226);
RT_INTERFACE!{interface ISensorDataThresholdTrigger(ISensorDataThresholdTriggerVtbl): IInspectable [IID_ISensorDataThresholdTrigger] {
    
}}
RT_CLASS!{class SensorDataThresholdTrigger: ISensorDataThresholdTrigger}
impl RtActivatable<ISensorDataThresholdTriggerFactory> for SensorDataThresholdTrigger {}
impl SensorDataThresholdTrigger {
    #[cfg(feature="windows-devices")] #[inline] pub fn create(threshold: &super::super::devices::sensors::ISensorDataThreshold) -> Result<SensorDataThresholdTrigger> {
        <Self as RtActivatable<ISensorDataThresholdTriggerFactory>>::get_activation_factory().create(threshold)
    }
}
DEFINE_CLSID!(SensorDataThresholdTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,83,101,110,115,111,114,68,97,116,97,84,104,114,101,115,104,111,108,100,84,114,105,103,103,101,114,0]) [CLSID_SensorDataThresholdTrigger]);
DEFINE_IID!(IID_ISensorDataThresholdTriggerFactory, 2451564149, 32240, 19875, 151, 179, 229, 68, 238, 133, 127, 230);
RT_INTERFACE!{static interface ISensorDataThresholdTriggerFactory(ISensorDataThresholdTriggerFactoryVtbl): IInspectable [IID_ISensorDataThresholdTriggerFactory] {
    #[cfg(feature="windows-devices")] fn Create(&self, threshold: <super::super::devices::sensors::ISensorDataThreshold as RtType>::Abi, out: *mut <SensorDataThresholdTrigger as RtType>::Abi) -> HRESULT
}}
impl ISensorDataThresholdTriggerFactory {
    #[cfg(feature="windows-devices")] #[inline] pub fn create(&self, threshold: &super::super::devices::sensors::ISensorDataThreshold) -> Result<SensorDataThresholdTrigger> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, threshold.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SensorDataThresholdTrigger::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardTrigger, 4114335148, 33994, 18802, 140, 233, 229, 143, 151, 179, 122, 80);
RT_INTERFACE!{interface ISmartCardTrigger(ISmartCardTriggerVtbl): IInspectable [IID_ISmartCardTrigger] {
    #[cfg(feature="windows-devices")] fn get_TriggerType(&self, out: *mut super::super::devices::smartcards::SmartCardTriggerType) -> HRESULT
}}
impl ISmartCardTrigger {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_trigger_type(&self) -> Result<super::super::devices::smartcards::SmartCardTriggerType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_TriggerType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardTrigger: ISmartCardTrigger}
impl RtActivatable<ISmartCardTriggerFactory> for SmartCardTrigger {}
impl SmartCardTrigger {
    #[cfg(feature="windows-devices")] #[inline] pub fn create(triggerType: super::super::devices::smartcards::SmartCardTriggerType) -> Result<SmartCardTrigger> {
        <Self as RtActivatable<ISmartCardTriggerFactory>>::get_activation_factory().create(triggerType)
    }
}
DEFINE_CLSID!(SmartCardTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,83,109,97,114,116,67,97,114,100,84,114,105,103,103,101,114,0]) [CLSID_SmartCardTrigger]);
DEFINE_IID!(IID_ISmartCardTriggerFactory, 1673483459, 35265, 19968, 169, 211, 151, 198, 41, 38, 157, 173);
RT_INTERFACE!{static interface ISmartCardTriggerFactory(ISmartCardTriggerFactoryVtbl): IInspectable [IID_ISmartCardTriggerFactory] {
    #[cfg(feature="windows-devices")] fn Create(&self, triggerType: super::super::devices::smartcards::SmartCardTriggerType, out: *mut <SmartCardTrigger as RtType>::Abi) -> HRESULT
}}
impl ISmartCardTriggerFactory {
    #[cfg(feature="windows-devices")] #[inline] pub fn create(&self, triggerType: super::super::devices::smartcards::SmartCardTriggerType) -> Result<SmartCardTrigger> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, triggerType, &mut out);
        if hr == S_OK { Ok(SmartCardTrigger::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsMessageReceivedTrigger: IBackgroundTrigger}
impl RtActivatable<ISmsMessageReceivedTriggerFactory> for SmsMessageReceivedTrigger {}
impl SmsMessageReceivedTrigger {
    #[cfg(feature="windows-devices")] #[inline] pub fn create(filterRules: &super::super::devices::sms::SmsFilterRules) -> Result<SmsMessageReceivedTrigger> {
        <Self as RtActivatable<ISmsMessageReceivedTriggerFactory>>::get_activation_factory().create(filterRules)
    }
}
DEFINE_CLSID!(SmsMessageReceivedTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,83,109,115,77,101,115,115,97,103,101,82,101,99,101,105,118,101,100,84,114,105,103,103,101,114,0]) [CLSID_SmsMessageReceivedTrigger]);
DEFINE_IID!(IID_ISmsMessageReceivedTriggerFactory, 3929725128, 27556, 19122, 141, 33, 188, 107, 9, 199, 117, 100);
RT_INTERFACE!{static interface ISmsMessageReceivedTriggerFactory(ISmsMessageReceivedTriggerFactoryVtbl): IInspectable [IID_ISmsMessageReceivedTriggerFactory] {
    #[cfg(feature="windows-devices")] fn Create(&self, filterRules: <super::super::devices::sms::SmsFilterRules as RtType>::Abi, out: *mut <SmsMessageReceivedTrigger as RtType>::Abi) -> HRESULT
}}
impl ISmsMessageReceivedTriggerFactory {
    #[cfg(feature="windows-devices")] #[inline] pub fn create(&self, filterRules: &super::super::devices::sms::SmsFilterRules) -> Result<SmsMessageReceivedTrigger> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, filterRules.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmsMessageReceivedTrigger::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISocketActivityTrigger, 2847668240, 40414, 20362, 131, 227, 176, 224, 231, 165, 13, 112);
RT_INTERFACE!{interface ISocketActivityTrigger(ISocketActivityTriggerVtbl): IInspectable [IID_ISocketActivityTrigger] {
    fn get_IsWakeFromLowPowerSupported(&self, out: *mut bool) -> HRESULT
}}
impl ISocketActivityTrigger {
    #[inline] pub fn get_is_wake_from_low_power_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsWakeFromLowPowerSupported)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SocketActivityTrigger: IBackgroundTrigger}
impl RtActivatable<IActivationFactory> for SocketActivityTrigger {}
DEFINE_CLSID!(SocketActivityTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,83,111,99,107,101,116,65,99,116,105,118,105,116,121,84,114,105,103,103,101,114,0]) [CLSID_SocketActivityTrigger]);
RT_CLASS!{class StorageLibraryChangeTrackerTrigger: IBackgroundTrigger}
impl RtActivatable<IStorageLibraryChangeTrackerTriggerFactory> for StorageLibraryChangeTrackerTrigger {}
impl StorageLibraryChangeTrackerTrigger {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(tracker: &super::super::storage::StorageLibraryChangeTracker) -> Result<StorageLibraryChangeTrackerTrigger> {
        <Self as RtActivatable<IStorageLibraryChangeTrackerTriggerFactory>>::get_activation_factory().create(tracker)
    }
}
DEFINE_CLSID!(StorageLibraryChangeTrackerTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,83,116,111,114,97,103,101,76,105,98,114,97,114,121,67,104,97,110,103,101,84,114,97,99,107,101,114,84,114,105,103,103,101,114,0]) [CLSID_StorageLibraryChangeTrackerTrigger]);
DEFINE_IID!(IID_IStorageLibraryChangeTrackerTriggerFactory, 514916304, 23173, 18846, 168, 136, 130, 70, 7, 18, 79, 80);
RT_INTERFACE!{static interface IStorageLibraryChangeTrackerTriggerFactory(IStorageLibraryChangeTrackerTriggerFactoryVtbl): IInspectable [IID_IStorageLibraryChangeTrackerTriggerFactory] {
    #[cfg(feature="windows-storage")] fn Create(&self, tracker: <super::super::storage::StorageLibraryChangeTracker as RtType>::Abi, out: *mut <StorageLibraryChangeTrackerTrigger as RtType>::Abi) -> HRESULT
}}
impl IStorageLibraryChangeTrackerTriggerFactory {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(&self, tracker: &super::super::storage::StorageLibraryChangeTracker) -> Result<StorageLibraryChangeTrackerTrigger> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, tracker.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(StorageLibraryChangeTrackerTrigger::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IStorageLibraryContentChangedTrigger, 372760743, 33436, 17852, 146, 155, 161, 231, 234, 120, 216, 155);
RT_INTERFACE!{interface IStorageLibraryContentChangedTrigger(IStorageLibraryContentChangedTriggerVtbl): IInspectable [IID_IStorageLibraryContentChangedTrigger] {
    
}}
RT_CLASS!{class StorageLibraryContentChangedTrigger: IStorageLibraryContentChangedTrigger}
impl RtActivatable<IStorageLibraryContentChangedTriggerStatics> for StorageLibraryContentChangedTrigger {}
impl StorageLibraryContentChangedTrigger {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(storageLibrary: &super::super::storage::StorageLibrary) -> Result<Option<StorageLibraryContentChangedTrigger>> {
        <Self as RtActivatable<IStorageLibraryContentChangedTriggerStatics>>::get_activation_factory().create(storageLibrary)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_libraries(storageLibraries: &foundation::collections::IIterable<super::super::storage::StorageLibrary>) -> Result<Option<StorageLibraryContentChangedTrigger>> {
        <Self as RtActivatable<IStorageLibraryContentChangedTriggerStatics>>::get_activation_factory().create_from_libraries(storageLibraries)
    }
}
DEFINE_CLSID!(StorageLibraryContentChangedTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,83,116,111,114,97,103,101,76,105,98,114,97,114,121,67,111,110,116,101,110,116,67,104,97,110,103,101,100,84,114,105,103,103,101,114,0]) [CLSID_StorageLibraryContentChangedTrigger]);
DEFINE_IID!(IID_IStorageLibraryContentChangedTriggerStatics, 2141133625, 24464, 19986, 145, 78, 167, 216, 224, 187, 251, 24);
RT_INTERFACE!{static interface IStorageLibraryContentChangedTriggerStatics(IStorageLibraryContentChangedTriggerStaticsVtbl): IInspectable [IID_IStorageLibraryContentChangedTriggerStatics] {
    #[cfg(feature="windows-storage")] fn Create(&self, storageLibrary: <super::super::storage::StorageLibrary as RtType>::Abi, out: *mut <StorageLibraryContentChangedTrigger as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn CreateFromLibraries(&self, storageLibraries: <foundation::collections::IIterable<super::super::storage::StorageLibrary> as RtType>::Abi, out: *mut <StorageLibraryContentChangedTrigger as RtType>::Abi) -> HRESULT
}}
impl IStorageLibraryContentChangedTriggerStatics {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(&self, storageLibrary: &super::super::storage::StorageLibrary) -> Result<Option<StorageLibraryContentChangedTrigger>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, storageLibrary.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(StorageLibraryContentChangedTrigger::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_libraries(&self, storageLibraries: &foundation::collections::IIterable<super::super::storage::StorageLibrary>) -> Result<Option<StorageLibraryContentChangedTrigger>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateFromLibraries)(self.get_abi() as *const _ as *mut _, storageLibraries.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(StorageLibraryContentChangedTrigger::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISystemCondition, 3244274806, 35269, 16907, 171, 211, 251, 48, 48, 71, 33, 40);
RT_INTERFACE!{interface ISystemCondition(ISystemConditionVtbl): IInspectable [IID_ISystemCondition] {
    fn get_ConditionType(&self, out: *mut SystemConditionType) -> HRESULT
}}
impl ISystemCondition {
    #[inline] pub fn get_condition_type(&self) -> Result<SystemConditionType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ConditionType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SystemCondition: ISystemCondition}
impl RtActivatable<ISystemConditionFactory> for SystemCondition {}
impl SystemCondition {
    #[inline] pub fn create(conditionType: SystemConditionType) -> Result<SystemCondition> {
        <Self as RtActivatable<ISystemConditionFactory>>::get_activation_factory().create(conditionType)
    }
}
DEFINE_CLSID!(SystemCondition(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,83,121,115,116,101,109,67,111,110,100,105,116,105,111,110,0]) [CLSID_SystemCondition]);
DEFINE_IID!(IID_ISystemConditionFactory, 3530150385, 1447, 18862, 135, 215, 22, 178, 184, 185, 165, 83);
RT_INTERFACE!{static interface ISystemConditionFactory(ISystemConditionFactoryVtbl): IInspectable [IID_ISystemConditionFactory] {
    fn Create(&self, conditionType: SystemConditionType, out: *mut <SystemCondition as RtType>::Abi) -> HRESULT
}}
impl ISystemConditionFactory {
    #[inline] pub fn create(&self, conditionType: SystemConditionType) -> Result<SystemCondition> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, conditionType, &mut out);
        if hr == S_OK { Ok(SystemCondition::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SystemConditionType: i32 {
    Invalid = 0, UserPresent = 1, UserNotPresent = 2, InternetAvailable = 3, InternetNotAvailable = 4, SessionConnected = 5, SessionDisconnected = 6, FreeNetworkAvailable = 7, BackgroundWorkCostNotHigh = 8,
}}
DEFINE_IID!(IID_ISystemTrigger, 494978934, 14152, 17507, 141, 126, 39, 109, 193, 57, 172, 28);
RT_INTERFACE!{interface ISystemTrigger(ISystemTriggerVtbl): IInspectable [IID_ISystemTrigger] {
    fn get_OneShot(&self, out: *mut bool) -> HRESULT,
    fn get_TriggerType(&self, out: *mut SystemTriggerType) -> HRESULT
}}
impl ISystemTrigger {
    #[inline] pub fn get_one_shot(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_OneShot)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_trigger_type(&self) -> Result<SystemTriggerType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_TriggerType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SystemTrigger: ISystemTrigger}
impl RtActivatable<ISystemTriggerFactory> for SystemTrigger {}
impl SystemTrigger {
    #[inline] pub fn create(triggerType: SystemTriggerType, oneShot: bool) -> Result<SystemTrigger> {
        <Self as RtActivatable<ISystemTriggerFactory>>::get_activation_factory().create(triggerType, oneShot)
    }
}
DEFINE_CLSID!(SystemTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,83,121,115,116,101,109,84,114,105,103,103,101,114,0]) [CLSID_SystemTrigger]);
DEFINE_IID!(IID_ISystemTriggerFactory, 3892585428, 34705, 17785, 129, 38, 135, 236, 138, 170, 64, 122);
RT_INTERFACE!{static interface ISystemTriggerFactory(ISystemTriggerFactoryVtbl): IInspectable [IID_ISystemTriggerFactory] {
    fn Create(&self, triggerType: SystemTriggerType, oneShot: bool, out: *mut <SystemTrigger as RtType>::Abi) -> HRESULT
}}
impl ISystemTriggerFactory {
    #[inline] pub fn create(&self, triggerType: SystemTriggerType, oneShot: bool) -> Result<SystemTrigger> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, triggerType, oneShot, &mut out);
        if hr == S_OK { Ok(SystemTrigger::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SystemTriggerType: i32 {
    Invalid = 0, SmsReceived = 1, UserPresent = 2, UserAway = 3, NetworkStateChange = 4, ControlChannelReset = 5, InternetAvailable = 6, SessionConnected = 7, ServicingComplete = 8, LockScreenApplicationAdded = 9, LockScreenApplicationRemoved = 10, TimeZoneChange = 11, OnlineIdConnectedStateChange = 12, BackgroundWorkCostChange = 13, PowerStateChange = 14, DefaultSignInAccountChange = 15,
}}
RT_CLASS!{class TetheringEntitlementCheckTrigger: IBackgroundTrigger}
impl RtActivatable<IActivationFactory> for TetheringEntitlementCheckTrigger {}
DEFINE_CLSID!(TetheringEntitlementCheckTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,84,101,116,104,101,114,105,110,103,69,110,116,105,116,108,101,109,101,110,116,67,104,101,99,107,84,114,105,103,103,101,114,0]) [CLSID_TetheringEntitlementCheckTrigger]);
DEFINE_IID!(IID_ITimeTrigger, 1701729622, 2858, 17271, 186, 112, 59, 69, 169, 53, 84, 127);
RT_INTERFACE!{interface ITimeTrigger(ITimeTriggerVtbl): IInspectable [IID_ITimeTrigger] {
    fn get_FreshnessTime(&self, out: *mut u32) -> HRESULT,
    fn get_OneShot(&self, out: *mut bool) -> HRESULT
}}
impl ITimeTrigger {
    #[inline] pub fn get_freshness_time(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_FreshnessTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_one_shot(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_OneShot)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class TimeTrigger: ITimeTrigger}
impl RtActivatable<ITimeTriggerFactory> for TimeTrigger {}
impl TimeTrigger {
    #[inline] pub fn create(freshnessTime: u32, oneShot: bool) -> Result<TimeTrigger> {
        <Self as RtActivatable<ITimeTriggerFactory>>::get_activation_factory().create(freshnessTime, oneShot)
    }
}
DEFINE_CLSID!(TimeTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,84,105,109,101,84,114,105,103,103,101,114,0]) [CLSID_TimeTrigger]);
DEFINE_IID!(IID_ITimeTriggerFactory, 952533758, 39764, 17894, 178, 243, 38, 155, 135, 166, 247, 52);
RT_INTERFACE!{static interface ITimeTriggerFactory(ITimeTriggerFactoryVtbl): IInspectable [IID_ITimeTriggerFactory] {
    fn Create(&self, freshnessTime: u32, oneShot: bool, out: *mut <TimeTrigger as RtType>::Abi) -> HRESULT
}}
impl ITimeTriggerFactory {
    #[inline] pub fn create(&self, freshnessTime: u32, oneShot: bool) -> Result<TimeTrigger> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, freshnessTime, oneShot, &mut out);
        if hr == S_OK { Ok(TimeTrigger::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ToastNotificationActionTrigger: IBackgroundTrigger}
impl RtActivatable<IToastNotificationActionTriggerFactory> for ToastNotificationActionTrigger {}
impl RtActivatable<IActivationFactory> for ToastNotificationActionTrigger {}
impl ToastNotificationActionTrigger {
    #[inline] pub fn create(applicationId: &HStringArg) -> Result<ToastNotificationActionTrigger> {
        <Self as RtActivatable<IToastNotificationActionTriggerFactory>>::get_activation_factory().create(applicationId)
    }
}
DEFINE_CLSID!(ToastNotificationActionTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,84,111,97,115,116,78,111,116,105,102,105,99,97,116,105,111,110,65,99,116,105,111,110,84,114,105,103,103,101,114,0]) [CLSID_ToastNotificationActionTrigger]);
DEFINE_IID!(IID_IToastNotificationActionTriggerFactory, 2963143719, 25728, 17225, 129, 37, 151, 179, 239, 170, 10, 58);
RT_INTERFACE!{static interface IToastNotificationActionTriggerFactory(IToastNotificationActionTriggerFactoryVtbl): IInspectable [IID_IToastNotificationActionTriggerFactory] {
    fn Create(&self, applicationId: HSTRING, out: *mut <ToastNotificationActionTrigger as RtType>::Abi) -> HRESULT
}}
impl IToastNotificationActionTriggerFactory {
    #[inline] pub fn create(&self, applicationId: &HStringArg) -> Result<ToastNotificationActionTrigger> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, applicationId.get(), &mut out);
        if hr == S_OK { Ok(ToastNotificationActionTrigger::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ToastNotificationHistoryChangedTrigger: IBackgroundTrigger}
impl RtActivatable<IToastNotificationHistoryChangedTriggerFactory> for ToastNotificationHistoryChangedTrigger {}
impl RtActivatable<IActivationFactory> for ToastNotificationHistoryChangedTrigger {}
impl ToastNotificationHistoryChangedTrigger {
    #[inline] pub fn create(applicationId: &HStringArg) -> Result<ToastNotificationHistoryChangedTrigger> {
        <Self as RtActivatable<IToastNotificationHistoryChangedTriggerFactory>>::get_activation_factory().create(applicationId)
    }
}
DEFINE_CLSID!(ToastNotificationHistoryChangedTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,84,111,97,115,116,78,111,116,105,102,105,99,97,116,105,111,110,72,105,115,116,111,114,121,67,104,97,110,103,101,100,84,114,105,103,103,101,114,0]) [CLSID_ToastNotificationHistoryChangedTrigger]);
DEFINE_IID!(IID_IToastNotificationHistoryChangedTriggerFactory, 2177301165, 34711, 18309, 129, 180, 176, 204, 203, 115, 209, 217);
RT_INTERFACE!{static interface IToastNotificationHistoryChangedTriggerFactory(IToastNotificationHistoryChangedTriggerFactoryVtbl): IInspectable [IID_IToastNotificationHistoryChangedTriggerFactory] {
    fn Create(&self, applicationId: HSTRING, out: *mut <ToastNotificationHistoryChangedTrigger as RtType>::Abi) -> HRESULT
}}
impl IToastNotificationHistoryChangedTriggerFactory {
    #[inline] pub fn create(&self, applicationId: &HStringArg) -> Result<ToastNotificationHistoryChangedTrigger> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, applicationId.get(), &mut out);
        if hr == S_OK { Ok(ToastNotificationHistoryChangedTrigger::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserNotificationChangedTrigger: IBackgroundTrigger}
impl RtActivatable<IUserNotificationChangedTriggerFactory> for UserNotificationChangedTrigger {}
impl UserNotificationChangedTrigger {
    #[cfg(feature="windows-ui")] #[inline] pub fn create(notificationKinds: super::super::ui::notifications::NotificationKinds) -> Result<UserNotificationChangedTrigger> {
        <Self as RtActivatable<IUserNotificationChangedTriggerFactory>>::get_activation_factory().create(notificationKinds)
    }
}
DEFINE_CLSID!(UserNotificationChangedTrigger(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,66,97,99,107,103,114,111,117,110,100,46,85,115,101,114,78,111,116,105,102,105,99,97,116,105,111,110,67,104,97,110,103,101,100,84,114,105,103,103,101,114,0]) [CLSID_UserNotificationChangedTrigger]);
DEFINE_IID!(IID_IUserNotificationChangedTriggerFactory, 3402908524, 27051, 19992, 164, 138, 94, 210, 172, 67, 89, 87);
RT_INTERFACE!{static interface IUserNotificationChangedTriggerFactory(IUserNotificationChangedTriggerFactoryVtbl): IInspectable [IID_IUserNotificationChangedTriggerFactory] {
    #[cfg(feature="windows-ui")] fn Create(&self, notificationKinds: super::super::ui::notifications::NotificationKinds, out: *mut <UserNotificationChangedTrigger as RtType>::Abi) -> HRESULT
}}
impl IUserNotificationChangedTriggerFactory {
    #[cfg(feature="windows-ui")] #[inline] pub fn create(&self, notificationKinds: super::super::ui::notifications::NotificationKinds) -> Result<UserNotificationChangedTrigger> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, notificationKinds, &mut out);
        if hr == S_OK { Ok(UserNotificationChangedTrigger::wrap_nonnull(out)) } else { err(hr) }
    }}
}
} // Windows.ApplicationModel.Background
pub mod calls { // Windows.ApplicationModel.Calls
use crate::prelude::*;
DEFINE_IID!(IID_ICallAnswerEventArgs, 4252538391, 11735, 19596, 178, 189, 149, 209, 122, 91, 183, 51);
RT_INTERFACE!{interface ICallAnswerEventArgs(ICallAnswerEventArgsVtbl): IInspectable [IID_ICallAnswerEventArgs] {
    fn get_AcceptedMedia(&self, out: *mut VoipPhoneCallMedia) -> HRESULT
}}
impl ICallAnswerEventArgs {
    #[inline] pub fn get_accepted_media(&self) -> Result<VoipPhoneCallMedia> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AcceptedMedia)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CallAnswerEventArgs: ICallAnswerEventArgs}
DEFINE_IID!(IID_ICallRejectEventArgs, 3662150359, 5076, 19858, 161, 194, 183, 120, 17, 238, 55, 236);
RT_INTERFACE!{interface ICallRejectEventArgs(ICallRejectEventArgsVtbl): IInspectable [IID_ICallRejectEventArgs] {
    fn get_RejectReason(&self, out: *mut VoipPhoneCallRejectReason) -> HRESULT
}}
impl ICallRejectEventArgs {
    #[inline] pub fn get_reject_reason(&self) -> Result<VoipPhoneCallRejectReason> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_RejectReason)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CallRejectEventArgs: ICallRejectEventArgs}
DEFINE_IID!(IID_ICallStateChangeEventArgs, 3937547422, 26357, 18425, 159, 181, 69, 156, 81, 152, 199, 32);
RT_INTERFACE!{interface ICallStateChangeEventArgs(ICallStateChangeEventArgsVtbl): IInspectable [IID_ICallStateChangeEventArgs] {
    fn get_State(&self, out: *mut VoipPhoneCallState) -> HRESULT
}}
impl ICallStateChangeEventArgs {
    #[inline] pub fn get_state(&self) -> Result<VoipPhoneCallState> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_State)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CallStateChangeEventArgs: ICallStateChangeEventArgs}
RT_ENUM! { enum CellularDtmfMode: i32 {
    Continuous = 0, Burst = 1,
}}
DEFINE_IID!(IID_ILockScreenCallEndCallDeferral, 769125645, 39149, 16449, 150, 50, 80, 255, 129, 43, 119, 63);
RT_INTERFACE!{interface ILockScreenCallEndCallDeferral(ILockScreenCallEndCallDeferralVtbl): IInspectable [IID_ILockScreenCallEndCallDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl ILockScreenCallEndCallDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Complete)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LockScreenCallEndCallDeferral: ILockScreenCallEndCallDeferral}
DEFINE_IID!(IID_ILockScreenCallEndRequestedEventArgs, 2173739875, 28455, 18153, 174, 182, 192, 174, 131, 228, 125, 199);
RT_INTERFACE!{interface ILockScreenCallEndRequestedEventArgs(ILockScreenCallEndRequestedEventArgsVtbl): IInspectable [IID_ILockScreenCallEndRequestedEventArgs] {
    fn GetDeferral(&self, out: *mut <LockScreenCallEndCallDeferral as RtType>::Abi) -> HRESULT,
    fn get_Deadline(&self, out: *mut foundation::DateTime) -> HRESULT
}}
impl ILockScreenCallEndRequestedEventArgs {
    #[inline] pub fn get_deferral(&self) -> Result<Option<LockScreenCallEndCallDeferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(LockScreenCallEndCallDeferral::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deadline(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Deadline)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class LockScreenCallEndRequestedEventArgs: ILockScreenCallEndRequestedEventArgs}
DEFINE_IID!(IID_ILockScreenCallUI, 3315006861, 29641, 18964, 176, 33, 236, 28, 80, 163, 183, 39);
RT_INTERFACE!{interface ILockScreenCallUI(ILockScreenCallUIVtbl): IInspectable [IID_ILockScreenCallUI] {
    fn Dismiss(&self) -> HRESULT,
    fn add_EndRequested(&self, handler: <foundation::TypedEventHandler<LockScreenCallUI, LockScreenCallEndRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EndRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Closed(&self, handler: <foundation::TypedEventHandler<LockScreenCallUI, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_CallTitle(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CallTitle(&self, value: HSTRING) -> HRESULT
}}
impl ILockScreenCallUI {
    #[inline] pub fn dismiss(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Dismiss)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_end_requested(&self, handler: &foundation::TypedEventHandler<LockScreenCallUI, LockScreenCallEndRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_EndRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_end_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_EndRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_closed(&self, handler: &foundation::TypedEventHandler<LockScreenCallUI, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_Closed)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_closed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_Closed)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_call_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CallTitle)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_call_title(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CallTitle)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LockScreenCallUI: ILockScreenCallUI}
DEFINE_IID!(IID_IMuteChangeEventArgs, 2240143705, 3137, 17196, 129, 77, 197, 241, 253, 245, 48, 190);
RT_INTERFACE!{interface IMuteChangeEventArgs(IMuteChangeEventArgsVtbl): IInspectable [IID_IMuteChangeEventArgs] {
    fn get_Muted(&self, out: *mut bool) -> HRESULT
}}
impl IMuteChangeEventArgs {
    #[inline] pub fn get_muted(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Muted)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MuteChangeEventArgs: IMuteChangeEventArgs}
RT_ENUM! { enum PhoneAudioRoutingEndpoint: i32 {
    Default = 0, Bluetooth = 1, Speakerphone = 2,
}}
RT_CLASS!{static class PhoneCallBlocking}
impl RtActivatable<IPhoneCallBlockingStatics> for PhoneCallBlocking {}
impl PhoneCallBlocking {
    #[inline] pub fn get_block_unknown_numbers() -> Result<bool> {
        <Self as RtActivatable<IPhoneCallBlockingStatics>>::get_activation_factory().get_block_unknown_numbers()
    }
    #[inline] pub fn set_block_unknown_numbers(value: bool) -> Result<()> {
        <Self as RtActivatable<IPhoneCallBlockingStatics>>::get_activation_factory().set_block_unknown_numbers(value)
    }
    #[inline] pub fn get_block_private_numbers() -> Result<bool> {
        <Self as RtActivatable<IPhoneCallBlockingStatics>>::get_activation_factory().get_block_private_numbers()
    }
    #[inline] pub fn set_block_private_numbers(value: bool) -> Result<()> {
        <Self as RtActivatable<IPhoneCallBlockingStatics>>::get_activation_factory().set_block_private_numbers(value)
    }
    #[inline] pub fn set_call_blocking_list_async(phoneNumberList: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<bool>> {
        <Self as RtActivatable<IPhoneCallBlockingStatics>>::get_activation_factory().set_call_blocking_list_async(phoneNumberList)
    }
}
DEFINE_CLSID!(PhoneCallBlocking(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,97,108,108,115,46,80,104,111,110,101,67,97,108,108,66,108,111,99,107,105,110,103,0]) [CLSID_PhoneCallBlocking]);
DEFINE_IID!(IID_IPhoneCallBlockingStatics, 426012548, 11129, 9969, 164, 111, 105, 75, 224, 67, 243, 19);
RT_INTERFACE!{static interface IPhoneCallBlockingStatics(IPhoneCallBlockingStaticsVtbl): IInspectable [IID_IPhoneCallBlockingStatics] {
    fn get_BlockUnknownNumbers(&self, out: *mut bool) -> HRESULT,
    fn put_BlockUnknownNumbers(&self, value: bool) -> HRESULT,
    fn get_BlockPrivateNumbers(&self, out: *mut bool) -> HRESULT,
    fn put_BlockPrivateNumbers(&self, value: bool) -> HRESULT,
    fn SetCallBlockingListAsync(&self, phoneNumberList: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl IPhoneCallBlockingStatics {
    #[inline] pub fn get_block_unknown_numbers(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_BlockUnknownNumbers)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_block_unknown_numbers(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_BlockUnknownNumbers)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_block_private_numbers(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_BlockPrivateNumbers)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_block_private_numbers(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_BlockPrivateNumbers)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_call_blocking_list_async(&self, phoneNumberList: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SetCallBlockingListAsync)(self.get_abi() as *const _ as *mut _, phoneNumberList.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPhoneCallHistoryEntry, 4205895977, 12964, 19333, 131, 209, 249, 13, 140, 35, 168, 87);
RT_INTERFACE!{interface IPhoneCallHistoryEntry(IPhoneCallHistoryEntryVtbl): IInspectable [IID_IPhoneCallHistoryEntry] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Address(&self, out: *mut <PhoneCallHistoryEntryAddress as RtType>::Abi) -> HRESULT,
    fn put_Address(&self, value: <PhoneCallHistoryEntryAddress as RtType>::Abi) -> HRESULT,
    fn get_Duration(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn put_Duration(&self, value: <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_IsCallerIdBlocked(&self, out: *mut bool) -> HRESULT,
    fn put_IsCallerIdBlocked(&self, value: bool) -> HRESULT,
    fn get_IsEmergency(&self, out: *mut bool) -> HRESULT,
    fn put_IsEmergency(&self, value: bool) -> HRESULT,
    fn get_IsIncoming(&self, out: *mut bool) -> HRESULT,
    fn put_IsIncoming(&self, value: bool) -> HRESULT,
    fn get_IsMissed(&self, out: *mut bool) -> HRESULT,
    fn put_IsMissed(&self, value: bool) -> HRESULT,
    fn get_IsRinging(&self, out: *mut bool) -> HRESULT,
    fn put_IsRinging(&self, value: bool) -> HRESULT,
    fn get_IsSeen(&self, out: *mut bool) -> HRESULT,
    fn put_IsSeen(&self, value: bool) -> HRESULT,
    fn get_IsSuppressed(&self, out: *mut bool) -> HRESULT,
    fn put_IsSuppressed(&self, value: bool) -> HRESULT,
    fn get_IsVoicemail(&self, out: *mut bool) -> HRESULT,
    fn put_IsVoicemail(&self, value: bool) -> HRESULT,
    fn get_Media(&self, out: *mut PhoneCallHistoryEntryMedia) -> HRESULT,
    fn put_Media(&self, value: PhoneCallHistoryEntryMedia) -> HRESULT,
    fn get_OtherAppReadAccess(&self, out: *mut PhoneCallHistoryEntryOtherAppReadAccess) -> HRESULT,
    fn put_OtherAppReadAccess(&self, value: PhoneCallHistoryEntryOtherAppReadAccess) -> HRESULT,
    fn get_RemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RemoteId(&self, value: HSTRING) -> HRESULT,
    fn get_SourceDisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SourceId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SourceId(&self, value: HSTRING) -> HRESULT,
    fn get_SourceIdKind(&self, out: *mut PhoneCallHistorySourceIdKind) -> HRESULT,
    fn put_SourceIdKind(&self, value: PhoneCallHistorySourceIdKind) -> HRESULT,
    fn get_StartTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn put_StartTime(&self, value: foundation::DateTime) -> HRESULT
}}
impl IPhoneCallHistoryEntry {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_address(&self) -> Result<Option<PhoneCallHistoryEntryAddress>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Address)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PhoneCallHistoryEntryAddress::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_address(&self, value: &PhoneCallHistoryEntryAddress) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Address)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Duration)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_duration(&self, value: &foundation::IReference<foundation::TimeSpan>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Duration)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_caller_id_blocked(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsCallerIdBlocked)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_caller_id_blocked(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsCallerIdBlocked)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_emergency(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsEmergency)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_emergency(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsEmergency)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_incoming(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsIncoming)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_incoming(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsIncoming)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_missed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsMissed)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_missed(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsMissed)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_ringing(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsRinging)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_ringing(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsRinging)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_seen(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsSeen)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_seen(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsSeen)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_suppressed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsSuppressed)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_suppressed(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsSuppressed)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_voicemail(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsVoicemail)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_voicemail(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsVoicemail)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_media(&self) -> Result<PhoneCallHistoryEntryMedia> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Media)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_media(&self, value: PhoneCallHistoryEntryMedia) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Media)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_other_app_read_access(&self) -> Result<PhoneCallHistoryEntryOtherAppReadAccess> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_OtherAppReadAccess)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_other_app_read_access(&self, value: PhoneCallHistoryEntryOtherAppReadAccess) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_OtherAppReadAccess)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_remote_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RemoteId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_remote_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RemoteId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_source_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SourceDisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_source_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SourceId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_source_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SourceId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_source_id_kind(&self) -> Result<PhoneCallHistorySourceIdKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SourceIdKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_source_id_kind(&self, value: PhoneCallHistorySourceIdKind) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SourceIdKind)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_start_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_StartTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_start_time(&self, value: foundation::DateTime) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_StartTime)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PhoneCallHistoryEntry: IPhoneCallHistoryEntry}
impl RtActivatable<IActivationFactory> for PhoneCallHistoryEntry {}
DEFINE_CLSID!(PhoneCallHistoryEntry(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,97,108,108,115,46,80,104,111,110,101,67,97,108,108,72,105,115,116,111,114,121,69,110,116,114,121,0]) [CLSID_PhoneCallHistoryEntry]);
DEFINE_IID!(IID_IPhoneCallHistoryEntryAddress, 821123546, 14677, 16450, 132, 230, 102, 238, 191, 130, 230, 127);
RT_INTERFACE!{interface IPhoneCallHistoryEntryAddress(IPhoneCallHistoryEntryAddressVtbl): IInspectable [IID_IPhoneCallHistoryEntryAddress] {
    fn get_ContactId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ContactId(&self, value: HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_RawAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RawAddress(&self, value: HSTRING) -> HRESULT,
    fn get_RawAddressKind(&self, out: *mut PhoneCallHistoryEntryRawAddressKind) -> HRESULT,
    fn put_RawAddressKind(&self, value: PhoneCallHistoryEntryRawAddressKind) -> HRESULT
}}
impl IPhoneCallHistoryEntryAddress {
    #[inline] pub fn get_contact_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContactId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_contact_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ContactId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_raw_address(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RawAddress)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_raw_address(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RawAddress)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_raw_address_kind(&self) -> Result<PhoneCallHistoryEntryRawAddressKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_RawAddressKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_raw_address_kind(&self, value: PhoneCallHistoryEntryRawAddressKind) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RawAddressKind)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PhoneCallHistoryEntryAddress: IPhoneCallHistoryEntryAddress}
impl RtActivatable<IPhoneCallHistoryEntryAddressFactory> for PhoneCallHistoryEntryAddress {}
impl RtActivatable<IActivationFactory> for PhoneCallHistoryEntryAddress {}
impl PhoneCallHistoryEntryAddress {
    #[inline] pub fn create(rawAddress: &HStringArg, rawAddressKind: PhoneCallHistoryEntryRawAddressKind) -> Result<PhoneCallHistoryEntryAddress> {
        <Self as RtActivatable<IPhoneCallHistoryEntryAddressFactory>>::get_activation_factory().create(rawAddress, rawAddressKind)
    }
}
DEFINE_CLSID!(PhoneCallHistoryEntryAddress(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,97,108,108,115,46,80,104,111,110,101,67,97,108,108,72,105,115,116,111,114,121,69,110,116,114,121,65,100,100,114,101,115,115,0]) [CLSID_PhoneCallHistoryEntryAddress]);
DEFINE_IID!(IID_IPhoneCallHistoryEntryAddressFactory, 4212108730, 51184, 19382, 159, 107, 186, 93, 115, 32, 154, 202);
RT_INTERFACE!{static interface IPhoneCallHistoryEntryAddressFactory(IPhoneCallHistoryEntryAddressFactoryVtbl): IInspectable [IID_IPhoneCallHistoryEntryAddressFactory] {
    fn Create(&self, rawAddress: HSTRING, rawAddressKind: PhoneCallHistoryEntryRawAddressKind, out: *mut <PhoneCallHistoryEntryAddress as RtType>::Abi) -> HRESULT
}}
impl IPhoneCallHistoryEntryAddressFactory {
    #[inline] pub fn create(&self, rawAddress: &HStringArg, rawAddressKind: PhoneCallHistoryEntryRawAddressKind) -> Result<PhoneCallHistoryEntryAddress> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, rawAddress.get(), rawAddressKind, &mut out);
        if hr == S_OK { Ok(PhoneCallHistoryEntryAddress::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum PhoneCallHistoryEntryMedia: i32 {
    Audio = 0, Video = 1,
}}
RT_ENUM! { enum PhoneCallHistoryEntryOtherAppReadAccess: i32 {
    Full = 0, SystemOnly = 1,
}}
RT_ENUM! { enum PhoneCallHistoryEntryQueryDesiredMedia: u32 {
    None = 0, Audio = 1, Video = 2, All = 4294967295,
}}
DEFINE_IID!(IID_IPhoneCallHistoryEntryQueryOptions, 2623529308, 35821, 16586, 176, 110, 196, 202, 142, 174, 92, 135);
RT_INTERFACE!{interface IPhoneCallHistoryEntryQueryOptions(IPhoneCallHistoryEntryQueryOptionsVtbl): IInspectable [IID_IPhoneCallHistoryEntryQueryOptions] {
    fn get_DesiredMedia(&self, out: *mut PhoneCallHistoryEntryQueryDesiredMedia) -> HRESULT,
    fn put_DesiredMedia(&self, value: PhoneCallHistoryEntryQueryDesiredMedia) -> HRESULT,
    fn get_SourceIds(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT
}}
impl IPhoneCallHistoryEntryQueryOptions {
    #[inline] pub fn get_desired_media(&self) -> Result<PhoneCallHistoryEntryQueryDesiredMedia> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DesiredMedia)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_media(&self, value: PhoneCallHistoryEntryQueryDesiredMedia) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DesiredMedia)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_source_ids(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SourceIds)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PhoneCallHistoryEntryQueryOptions: IPhoneCallHistoryEntryQueryOptions}
impl RtActivatable<IActivationFactory> for PhoneCallHistoryEntryQueryOptions {}
DEFINE_CLSID!(PhoneCallHistoryEntryQueryOptions(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,97,108,108,115,46,80,104,111,110,101,67,97,108,108,72,105,115,116,111,114,121,69,110,116,114,121,81,117,101,114,121,79,112,116,105,111,110,115,0]) [CLSID_PhoneCallHistoryEntryQueryOptions]);
RT_ENUM! { enum PhoneCallHistoryEntryRawAddressKind: i32 {
    PhoneNumber = 0, Custom = 1,
}}
DEFINE_IID!(IID_IPhoneCallHistoryEntryReader, 1642915006, 36230, 18335, 132, 4, 169, 132, 105, 32, 254, 230);
RT_INTERFACE!{interface IPhoneCallHistoryEntryReader(IPhoneCallHistoryEntryReaderVtbl): IInspectable [IID_IPhoneCallHistoryEntryReader] {
    fn ReadBatchAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<PhoneCallHistoryEntry>> as RtType>::Abi) -> HRESULT
}}
impl IPhoneCallHistoryEntryReader {
    #[inline] pub fn read_batch_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<PhoneCallHistoryEntry>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReadBatchAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PhoneCallHistoryEntryReader: IPhoneCallHistoryEntryReader}
RT_CLASS!{static class PhoneCallHistoryManager}
impl RtActivatable<IPhoneCallHistoryManagerStatics> for PhoneCallHistoryManager {}
impl RtActivatable<IPhoneCallHistoryManagerStatics2> for PhoneCallHistoryManager {}
impl PhoneCallHistoryManager {
    #[inline] pub fn request_store_async(accessType: PhoneCallHistoryStoreAccessType) -> Result<foundation::IAsyncOperation<PhoneCallHistoryStore>> {
        <Self as RtActivatable<IPhoneCallHistoryManagerStatics>>::get_activation_factory().request_store_async(accessType)
    }
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(user: &super::super::system::User) -> Result<Option<PhoneCallHistoryManagerForUser>> {
        <Self as RtActivatable<IPhoneCallHistoryManagerStatics2>>::get_activation_factory().get_for_user(user)
    }
}
DEFINE_CLSID!(PhoneCallHistoryManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,97,108,108,115,46,80,104,111,110,101,67,97,108,108,72,105,115,116,111,114,121,77,97,110,97,103,101,114,0]) [CLSID_PhoneCallHistoryManager]);
DEFINE_IID!(IID_IPhoneCallHistoryManagerForUser, 3643131171, 62815, 17235, 157, 180, 2, 5, 165, 38, 90, 85);
RT_INTERFACE!{interface IPhoneCallHistoryManagerForUser(IPhoneCallHistoryManagerForUserVtbl): IInspectable [IID_IPhoneCallHistoryManagerForUser] {
    fn RequestStoreAsync(&self, accessType: PhoneCallHistoryStoreAccessType, out: *mut <foundation::IAsyncOperation<PhoneCallHistoryStore> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut <super::super::system::User as RtType>::Abi) -> HRESULT
}}
impl IPhoneCallHistoryManagerForUser {
    #[inline] pub fn request_store_async(&self, accessType: PhoneCallHistoryStoreAccessType) -> Result<foundation::IAsyncOperation<PhoneCallHistoryStore>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestStoreAsync)(self.get_abi() as *const _ as *mut _, accessType, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_user(&self) -> Result<Option<super::super::system::User>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_User)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::system::User::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PhoneCallHistoryManagerForUser: IPhoneCallHistoryManagerForUser}
DEFINE_IID!(IID_IPhoneCallHistoryManagerStatics, 4121352761, 45855, 20293, 172, 142, 27, 8, 137, 60, 27, 80);
RT_INTERFACE!{static interface IPhoneCallHistoryManagerStatics(IPhoneCallHistoryManagerStaticsVtbl): IInspectable [IID_IPhoneCallHistoryManagerStatics] {
    fn RequestStoreAsync(&self, accessType: PhoneCallHistoryStoreAccessType, out: *mut <foundation::IAsyncOperation<PhoneCallHistoryStore> as RtType>::Abi) -> HRESULT
}}
impl IPhoneCallHistoryManagerStatics {
    #[inline] pub fn request_store_async(&self, accessType: PhoneCallHistoryStoreAccessType) -> Result<foundation::IAsyncOperation<PhoneCallHistoryStore>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestStoreAsync)(self.get_abi() as *const _ as *mut _, accessType, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPhoneCallHistoryManagerStatics2, 4023678192, 41691, 16776, 158, 146, 188, 60, 250, 104, 19, 207);
RT_INTERFACE!{static interface IPhoneCallHistoryManagerStatics2(IPhoneCallHistoryManagerStatics2Vtbl): IInspectable [IID_IPhoneCallHistoryManagerStatics2] {
    #[cfg(feature="windows-system")] fn GetForUser(&self, user: <super::super::system::User as RtType>::Abi, out: *mut <PhoneCallHistoryManagerForUser as RtType>::Abi) -> HRESULT
}}
impl IPhoneCallHistoryManagerStatics2 {
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(&self, user: &super::super::system::User) -> Result<Option<PhoneCallHistoryManagerForUser>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetForUser)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PhoneCallHistoryManagerForUser::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum PhoneCallHistorySourceIdKind: i32 {
    CellularPhoneLineId = 0, PackageFamilyName = 1,
}}
DEFINE_IID!(IID_IPhoneCallHistoryStore, 797998520, 46094, 16939, 133, 69, 203, 25, 16, 166, 28, 82);
RT_INTERFACE!{interface IPhoneCallHistoryStore(IPhoneCallHistoryStoreVtbl): IInspectable [IID_IPhoneCallHistoryStore] {
    fn GetEntryAsync(&self, callHistoryEntryId: HSTRING, out: *mut <foundation::IAsyncOperation<PhoneCallHistoryEntry> as RtType>::Abi) -> HRESULT,
    fn GetEntryReader(&self, out: *mut <PhoneCallHistoryEntryReader as RtType>::Abi) -> HRESULT,
    fn GetEntryReaderWithOptions(&self, queryOptions: <PhoneCallHistoryEntryQueryOptions as RtType>::Abi, out: *mut <PhoneCallHistoryEntryReader as RtType>::Abi) -> HRESULT,
    fn SaveEntryAsync(&self, callHistoryEntry: <PhoneCallHistoryEntry as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn DeleteEntryAsync(&self, callHistoryEntry: <PhoneCallHistoryEntry as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn DeleteEntriesAsync(&self, callHistoryEntries: <foundation::collections::IIterable<PhoneCallHistoryEntry> as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn MarkEntryAsSeenAsync(&self, callHistoryEntry: <PhoneCallHistoryEntry as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn MarkEntriesAsSeenAsync(&self, callHistoryEntries: <foundation::collections::IIterable<PhoneCallHistoryEntry> as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn GetUnseenCountAsync(&self, out: *mut <foundation::IAsyncOperation<u32> as RtType>::Abi) -> HRESULT,
    fn MarkAllAsSeenAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn GetSourcesUnseenCountAsync(&self, sourceIds: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<u32> as RtType>::Abi) -> HRESULT,
    fn MarkSourcesAsSeenAsync(&self, sourceIds: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IPhoneCallHistoryStore {
    #[inline] pub fn get_entry_async(&self, callHistoryEntryId: &HStringArg) -> Result<foundation::IAsyncOperation<PhoneCallHistoryEntry>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetEntryAsync)(self.get_abi() as *const _ as *mut _, callHistoryEntryId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_entry_reader(&self) -> Result<Option<PhoneCallHistoryEntryReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetEntryReader)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PhoneCallHistoryEntryReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_entry_reader_with_options(&self, queryOptions: &PhoneCallHistoryEntryQueryOptions) -> Result<Option<PhoneCallHistoryEntryReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetEntryReaderWithOptions)(self.get_abi() as *const _ as *mut _, queryOptions.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PhoneCallHistoryEntryReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn save_entry_async(&self, callHistoryEntry: &PhoneCallHistoryEntry) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SaveEntryAsync)(self.get_abi() as *const _ as *mut _, callHistoryEntry.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_entry_async(&self, callHistoryEntry: &PhoneCallHistoryEntry) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteEntryAsync)(self.get_abi() as *const _ as *mut _, callHistoryEntry.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_entries_async(&self, callHistoryEntries: &foundation::collections::IIterable<PhoneCallHistoryEntry>) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteEntriesAsync)(self.get_abi() as *const _ as *mut _, callHistoryEntries.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn mark_entry_as_seen_async(&self, callHistoryEntry: &PhoneCallHistoryEntry) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().MarkEntryAsSeenAsync)(self.get_abi() as *const _ as *mut _, callHistoryEntry.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn mark_entries_as_seen_async(&self, callHistoryEntries: &foundation::collections::IIterable<PhoneCallHistoryEntry>) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().MarkEntriesAsSeenAsync)(self.get_abi() as *const _ as *mut _, callHistoryEntries.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_unseen_count_async(&self) -> Result<foundation::IAsyncOperation<u32>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetUnseenCountAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn mark_all_as_seen_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().MarkAllAsSeenAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sources_unseen_count_async(&self, sourceIds: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<u32>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetSourcesUnseenCountAsync)(self.get_abi() as *const _ as *mut _, sourceIds.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn mark_sources_as_seen_async(&self, sourceIds: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().MarkSourcesAsSeenAsync)(self.get_abi() as *const _ as *mut _, sourceIds.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PhoneCallHistoryStore: IPhoneCallHistoryStore}
RT_ENUM! { enum PhoneCallHistoryStoreAccessType: i32 {
    AppEntriesReadWrite = 0, AllEntriesLimitedReadWrite = 1, AllEntriesReadWrite = 2,
}}
RT_CLASS!{static class PhoneCallManager}
impl RtActivatable<IPhoneCallManagerStatics> for PhoneCallManager {}
impl RtActivatable<IPhoneCallManagerStatics2> for PhoneCallManager {}
impl PhoneCallManager {
    #[inline] pub fn show_phone_call_ui(phoneNumber: &HStringArg, displayName: &HStringArg) -> Result<()> {
        <Self as RtActivatable<IPhoneCallManagerStatics>>::get_activation_factory().show_phone_call_ui(phoneNumber, displayName)
    }
    #[inline] pub fn add_call_state_changed(handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IPhoneCallManagerStatics2>>::get_activation_factory().add_call_state_changed(handler)
    }
    #[inline] pub fn remove_call_state_changed(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IPhoneCallManagerStatics2>>::get_activation_factory().remove_call_state_changed(token)
    }
    #[inline] pub fn get_is_call_active() -> Result<bool> {
        <Self as RtActivatable<IPhoneCallManagerStatics2>>::get_activation_factory().get_is_call_active()
    }
    #[inline] pub fn get_is_call_incoming() -> Result<bool> {
        <Self as RtActivatable<IPhoneCallManagerStatics2>>::get_activation_factory().get_is_call_incoming()
    }
    #[inline] pub fn show_phone_call_settings_ui() -> Result<()> {
        <Self as RtActivatable<IPhoneCallManagerStatics2>>::get_activation_factory().show_phone_call_settings_ui()
    }
    #[inline] pub fn request_store_async() -> Result<foundation::IAsyncOperation<PhoneCallStore>> {
        <Self as RtActivatable<IPhoneCallManagerStatics2>>::get_activation_factory().request_store_async()
    }
}
DEFINE_CLSID!(PhoneCallManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,97,108,108,115,46,80,104,111,110,101,67,97,108,108,77,97,110,97,103,101,114,0]) [CLSID_PhoneCallManager]);
DEFINE_IID!(IID_IPhoneCallManagerStatics, 1626188920, 30886, 18546, 163, 239, 152, 50, 94, 200, 184, 67);
RT_INTERFACE!{static interface IPhoneCallManagerStatics(IPhoneCallManagerStaticsVtbl): IInspectable [IID_IPhoneCallManagerStatics] {
    fn ShowPhoneCallUI(&self, phoneNumber: HSTRING, displayName: HSTRING) -> HRESULT
}}
impl IPhoneCallManagerStatics {
    #[inline] pub fn show_phone_call_ui(&self, phoneNumber: &HStringArg, displayName: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ShowPhoneCallUI)(self.get_abi() as *const _ as *mut _, phoneNumber.get(), displayName.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPhoneCallManagerStatics2, 3353594044, 9072, 17180, 152, 253, 67, 190, 95, 3, 8, 109);
RT_INTERFACE!{static interface IPhoneCallManagerStatics2(IPhoneCallManagerStatics2Vtbl): IInspectable [IID_IPhoneCallManagerStatics2] {
    fn add_CallStateChanged(&self, handler: <foundation::EventHandler<IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CallStateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_IsCallActive(&self, out: *mut bool) -> HRESULT,
    fn get_IsCallIncoming(&self, out: *mut bool) -> HRESULT,
    fn ShowPhoneCallSettingsUI(&self) -> HRESULT,
    fn RequestStoreAsync(&self, out: *mut <foundation::IAsyncOperation<PhoneCallStore> as RtType>::Abi) -> HRESULT
}}
impl IPhoneCallManagerStatics2 {
    #[inline] pub fn add_call_state_changed(&self, handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_CallStateChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_call_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_CallStateChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_call_active(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsCallActive)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_call_incoming(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsCallIncoming)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn show_phone_call_settings_ui(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ShowPhoneCallSettingsUI)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn request_store_async(&self) -> Result<foundation::IAsyncOperation<PhoneCallStore>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestStoreAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum PhoneCallMedia: i32 {
    Audio = 0, AudioAndVideo = 1, AudioAndRealTimeText = 2,
}}
DEFINE_IID!(IID_IPhoneCallStore, 1600194376, 6310, 16755, 134, 209, 40, 190, 157, 198, 45, 186);
RT_INTERFACE!{interface IPhoneCallStore(IPhoneCallStoreVtbl): IInspectable [IID_IPhoneCallStore] {
    fn IsEmergencyPhoneNumberAsync(&self, number: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn GetDefaultLineAsync(&self, out: *mut <foundation::IAsyncOperation<Guid> as RtType>::Abi) -> HRESULT,
    fn RequestLineWatcher(&self, out: *mut <PhoneLineWatcher as RtType>::Abi) -> HRESULT
}}
impl IPhoneCallStore {
    #[inline] pub fn is_emergency_phone_number_async(&self, number: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().IsEmergencyPhoneNumberAsync)(self.get_abi() as *const _ as *mut _, number.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_line_async(&self) -> Result<foundation::IAsyncOperation<Guid>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDefaultLineAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_line_watcher(&self) -> Result<Option<PhoneLineWatcher>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestLineWatcher)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PhoneLineWatcher::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PhoneCallStore: IPhoneCallStore}
DEFINE_IID!(IID_IPhoneCallVideoCapabilities, 37234566, 45418, 20443, 190, 59, 196, 36, 14, 19, 173, 13);
RT_INTERFACE!{interface IPhoneCallVideoCapabilities(IPhoneCallVideoCapabilitiesVtbl): IInspectable [IID_IPhoneCallVideoCapabilities] {
    fn get_IsVideoCallingCapable(&self, out: *mut bool) -> HRESULT
}}
impl IPhoneCallVideoCapabilities {
    #[inline] pub fn get_is_video_calling_capable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsVideoCallingCapable)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PhoneCallVideoCapabilities: IPhoneCallVideoCapabilities}
RT_CLASS!{static class PhoneCallVideoCapabilitiesManager}
impl RtActivatable<IPhoneCallVideoCapabilitiesManagerStatics> for PhoneCallVideoCapabilitiesManager {}
impl PhoneCallVideoCapabilitiesManager {
    #[inline] pub fn get_capabilities_async(phoneNumber: &HStringArg) -> Result<foundation::IAsyncOperation<PhoneCallVideoCapabilities>> {
        <Self as RtActivatable<IPhoneCallVideoCapabilitiesManagerStatics>>::get_activation_factory().get_capabilities_async(phoneNumber)
    }
}
DEFINE_CLSID!(PhoneCallVideoCapabilitiesManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,97,108,108,115,46,80,104,111,110,101,67,97,108,108,86,105,100,101,111,67,97,112,97,98,105,108,105,116,105,101,115,77,97,110,97,103,101,114,0]) [CLSID_PhoneCallVideoCapabilitiesManager]);
DEFINE_IID!(IID_IPhoneCallVideoCapabilitiesManagerStatics, 4089858902, 61451, 18972, 160, 198, 238, 25, 16, 116, 156, 231);
RT_INTERFACE!{static interface IPhoneCallVideoCapabilitiesManagerStatics(IPhoneCallVideoCapabilitiesManagerStaticsVtbl): IInspectable [IID_IPhoneCallVideoCapabilitiesManagerStatics] {
    fn GetCapabilitiesAsync(&self, phoneNumber: HSTRING, out: *mut <foundation::IAsyncOperation<PhoneCallVideoCapabilities> as RtType>::Abi) -> HRESULT
}}
impl IPhoneCallVideoCapabilitiesManagerStatics {
    #[inline] pub fn get_capabilities_async(&self, phoneNumber: &HStringArg) -> Result<foundation::IAsyncOperation<PhoneCallVideoCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetCapabilitiesAsync)(self.get_abi() as *const _ as *mut _, phoneNumber.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPhoneDialOptions, 3057239224, 61551, 14027, 168, 99, 130, 55, 66, 181, 242, 212);
RT_INTERFACE!{interface IPhoneDialOptions(IPhoneDialOptionsVtbl): IInspectable [IID_IPhoneDialOptions] {
    fn get_Number(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Number(&self, value: HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_Contact(&self, out: *mut <super::contacts::Contact as RtType>::Abi) -> HRESULT,
    fn put_Contact(&self, value: <super::contacts::Contact as RtType>::Abi) -> HRESULT,
    fn get_ContactPhone(&self, out: *mut <super::contacts::ContactPhone as RtType>::Abi) -> HRESULT,
    fn put_ContactPhone(&self, value: <super::contacts::ContactPhone as RtType>::Abi) -> HRESULT,
    fn get_Media(&self, out: *mut PhoneCallMedia) -> HRESULT,
    fn put_Media(&self, value: PhoneCallMedia) -> HRESULT,
    fn get_AudioEndpoint(&self, out: *mut PhoneAudioRoutingEndpoint) -> HRESULT,
    fn put_AudioEndpoint(&self, value: PhoneAudioRoutingEndpoint) -> HRESULT
}}
impl IPhoneDialOptions {
    #[inline] pub fn get_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Number)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_number(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Number)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_contact(&self) -> Result<Option<super::contacts::Contact>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Contact)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::contacts::Contact::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_contact(&self, value: &super::contacts::Contact) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Contact)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_contact_phone(&self) -> Result<Option<super::contacts::ContactPhone>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContactPhone)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::contacts::ContactPhone::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_contact_phone(&self, value: &super::contacts::ContactPhone) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ContactPhone)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_media(&self) -> Result<PhoneCallMedia> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Media)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_media(&self, value: PhoneCallMedia) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Media)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_endpoint(&self) -> Result<PhoneAudioRoutingEndpoint> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AudioEndpoint)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_audio_endpoint(&self, value: PhoneAudioRoutingEndpoint) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AudioEndpoint)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PhoneDialOptions: IPhoneDialOptions}
impl RtActivatable<IActivationFactory> for PhoneDialOptions {}
DEFINE_CLSID!(PhoneDialOptions(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,97,108,108,115,46,80,104,111,110,101,68,105,97,108,79,112,116,105,111,110,115,0]) [CLSID_PhoneDialOptions]);
DEFINE_IID!(IID_IPhoneLine, 667316016, 27241, 13514, 162, 186, 101, 48, 37, 48, 195, 17);
RT_INTERFACE!{interface IPhoneLine(IPhoneLineVtbl): IInspectable [IID_IPhoneLine] {
    fn add_LineChanged(&self, handler: <foundation::TypedEventHandler<PhoneLine, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LineChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Id(&self, out: *mut Guid) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_DisplayColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    fn get_NetworkState(&self, out: *mut PhoneNetworkState) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Voicemail(&self, out: *mut <PhoneVoicemail as RtType>::Abi) -> HRESULT,
    fn get_NetworkName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CellularDetails(&self, out: *mut <PhoneLineCellularDetails as RtType>::Abi) -> HRESULT,
    fn get_Transport(&self, out: *mut PhoneLineTransport) -> HRESULT,
    fn get_CanDial(&self, out: *mut bool) -> HRESULT,
    fn get_SupportsTile(&self, out: *mut bool) -> HRESULT,
    fn get_VideoCallingCapabilities(&self, out: *mut <PhoneCallVideoCapabilities as RtType>::Abi) -> HRESULT,
    fn get_LineConfiguration(&self, out: *mut <PhoneLineConfiguration as RtType>::Abi) -> HRESULT,
    fn IsImmediateDialNumberAsync(&self, number: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn Dial(&self, number: HSTRING, displayName: HSTRING) -> HRESULT,
    fn DialWithOptions(&self, options: <PhoneDialOptions as RtType>::Abi) -> HRESULT
}}
impl IPhoneLine {
    #[inline] pub fn add_line_changed(&self, handler: &foundation::TypedEventHandler<PhoneLine, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_LineChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_line_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_LineChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_display_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DisplayColor)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_network_state(&self) -> Result<PhoneNetworkState> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_NetworkState)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_voicemail(&self) -> Result<Option<PhoneVoicemail>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Voicemail)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PhoneVoicemail::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_network_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_NetworkName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_cellular_details(&self) -> Result<Option<PhoneLineCellularDetails>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CellularDetails)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PhoneLineCellularDetails::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_transport(&self) -> Result<PhoneLineTransport> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Transport)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_dial(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanDial)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supports_tile(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SupportsTile)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_video_calling_capabilities(&self) -> Result<Option<PhoneCallVideoCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_VideoCallingCapabilities)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PhoneCallVideoCapabilities::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_line_configuration(&self) -> Result<Option<PhoneLineConfiguration>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LineConfiguration)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PhoneLineConfiguration::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_immediate_dial_number_async(&self, number: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().IsImmediateDialNumberAsync)(self.get_abi() as *const _ as *mut _, number.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn dial(&self, number: &HStringArg, displayName: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Dial)(self.get_abi() as *const _ as *mut _, number.get(), displayName.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn dial_with_options(&self, options: &PhoneDialOptions) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().DialWithOptions)(self.get_abi() as *const _ as *mut _, options.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PhoneLine: IPhoneLine}
impl RtActivatable<IPhoneLineStatics> for PhoneLine {}
impl PhoneLine {
    #[inline] pub fn from_id_async(lineId: Guid) -> Result<foundation::IAsyncOperation<PhoneLine>> {
        <Self as RtActivatable<IPhoneLineStatics>>::get_activation_factory().from_id_async(lineId)
    }
}
DEFINE_CLSID!(PhoneLine(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,97,108,108,115,46,80,104,111,110,101,76,105,110,101,0]) [CLSID_PhoneLine]);
DEFINE_IID!(IID_IPhoneLineCellularDetails, 421921237, 5244, 18281, 182, 115, 152, 165, 236, 132, 38, 203);
RT_INTERFACE!{interface IPhoneLineCellularDetails(IPhoneLineCellularDetailsVtbl): IInspectable [IID_IPhoneLineCellularDetails] {
    fn get_SimState(&self, out: *mut PhoneSimState) -> HRESULT,
    fn get_SimSlotIndex(&self, out: *mut i32) -> HRESULT,
    fn get_IsModemOn(&self, out: *mut bool) -> HRESULT,
    fn get_RegistrationRejectCode(&self, out: *mut i32) -> HRESULT,
    fn GetNetworkOperatorDisplayText(&self, location: PhoneLineNetworkOperatorDisplayTextLocation, out: *mut HSTRING) -> HRESULT
}}
impl IPhoneLineCellularDetails {
    #[inline] pub fn get_sim_state(&self) -> Result<PhoneSimState> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SimState)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sim_slot_index(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SimSlotIndex)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_modem_on(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsModemOn)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_registration_reject_code(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_RegistrationRejectCode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_network_operator_display_text(&self, location: PhoneLineNetworkOperatorDisplayTextLocation) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetNetworkOperatorDisplayText)(self.get_abi() as *const _ as *mut _, location, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PhoneLineCellularDetails: IPhoneLineCellularDetails}
DEFINE_IID!(IID_IPhoneLineConfiguration, 4263925858, 63055, 17170, 178, 168, 78, 37, 119, 33, 170, 149);
RT_INTERFACE!{interface IPhoneLineConfiguration(IPhoneLineConfigurationVtbl): IInspectable [IID_IPhoneLineConfiguration] {
    fn get_IsVideoCallingEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_ExtendedProperties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl IPhoneLineConfiguration {
    #[inline] pub fn get_is_video_calling_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsVideoCallingEnabled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ExtendedProperties)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PhoneLineConfiguration: IPhoneLineConfiguration}
RT_ENUM! { enum PhoneLineNetworkOperatorDisplayTextLocation: i32 {
    Default = 0, Tile = 1, Dialer = 2, InCallUI = 3,
}}
DEFINE_IID!(IID_IPhoneLineStatics, 4085997347, 52912, 16463, 188, 242, 186, 159, 105, 125, 138, 223);
RT_INTERFACE!{static interface IPhoneLineStatics(IPhoneLineStaticsVtbl): IInspectable [IID_IPhoneLineStatics] {
    fn FromIdAsync(&self, lineId: Guid, out: *mut <foundation::IAsyncOperation<PhoneLine> as RtType>::Abi) -> HRESULT
}}
impl IPhoneLineStatics {
    #[inline] pub fn from_id_async(&self, lineId: Guid) -> Result<foundation::IAsyncOperation<PhoneLine>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FromIdAsync)(self.get_abi() as *const _ as *mut _, lineId, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum PhoneLineTransport: i32 {
    Cellular = 0, VoipApp = 1,
}}
DEFINE_IID!(IID_IPhoneLineWatcher, 2319830282, 25379, 17632, 166, 246, 159, 33, 246, 77, 201, 10);
RT_INTERFACE!{interface IPhoneLineWatcher(IPhoneLineWatcherVtbl): IInspectable [IID_IPhoneLineWatcher] {
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn add_LineAdded(&self, handler: <foundation::TypedEventHandler<PhoneLineWatcher, PhoneLineWatcherEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LineAdded(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_LineRemoved(&self, handler: <foundation::TypedEventHandler<PhoneLineWatcher, PhoneLineWatcherEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LineRemoved(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_LineUpdated(&self, handler: <foundation::TypedEventHandler<PhoneLineWatcher, PhoneLineWatcherEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LineUpdated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_EnumerationCompleted(&self, handler: <foundation::TypedEventHandler<PhoneLineWatcher, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EnumerationCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Stopped(&self, handler: <foundation::TypedEventHandler<PhoneLineWatcher, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Stopped(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Status(&self, out: *mut PhoneLineWatcherStatus) -> HRESULT
}}
impl IPhoneLineWatcher {
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Start)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Stop)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_line_added(&self, handler: &foundation::TypedEventHandler<PhoneLineWatcher, PhoneLineWatcherEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_LineAdded)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_line_added(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_LineAdded)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_line_removed(&self, handler: &foundation::TypedEventHandler<PhoneLineWatcher, PhoneLineWatcherEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_LineRemoved)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_line_removed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_LineRemoved)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_line_updated(&self, handler: &foundation::TypedEventHandler<PhoneLineWatcher, PhoneLineWatcherEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_LineUpdated)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_line_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_LineUpdated)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_enumeration_completed(&self, handler: &foundation::TypedEventHandler<PhoneLineWatcher, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_EnumerationCompleted)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_enumeration_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_EnumerationCompleted)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stopped(&self, handler: &foundation::TypedEventHandler<PhoneLineWatcher, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_Stopped)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stopped(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_Stopped)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<PhoneLineWatcherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PhoneLineWatcher: IPhoneLineWatcher}
DEFINE_IID!(IID_IPhoneLineWatcherEventArgs, 3497817406, 40466, 18999, 130, 183, 173, 83, 93, 173, 106, 103);
RT_INTERFACE!{interface IPhoneLineWatcherEventArgs(IPhoneLineWatcherEventArgsVtbl): IInspectable [IID_IPhoneLineWatcherEventArgs] {
    fn get_LineId(&self, out: *mut Guid) -> HRESULT
}}
impl IPhoneLineWatcherEventArgs {
    #[inline] pub fn get_line_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_LineId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PhoneLineWatcherEventArgs: IPhoneLineWatcherEventArgs}
RT_ENUM! { enum PhoneLineWatcherStatus: i32 {
    Created = 0, Started = 1, EnumerationCompleted = 2, Stopped = 3,
}}
RT_ENUM! { enum PhoneNetworkState: i32 {
    Unknown = 0, NoSignal = 1, Deregistered = 2, Denied = 3, Searching = 4, Home = 5, RoamingInternational = 6, RoamingDomestic = 7,
}}
RT_ENUM! { enum PhoneSimState: i32 {
    Unknown = 0, PinNotRequired = 1, PinUnlocked = 2, PinLocked = 3, PukLocked = 4, NotInserted = 5, Invalid = 6, Disabled = 7,
}}
DEFINE_IID!(IID_IPhoneVoicemail, 3385751542, 28319, 14987, 183, 39, 110, 12, 246, 153, 130, 36);
RT_INTERFACE!{interface IPhoneVoicemail(IPhoneVoicemailVtbl): IInspectable [IID_IPhoneVoicemail] {
    fn get_Number(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MessageCount(&self, out: *mut i32) -> HRESULT,
    fn get_Type(&self, out: *mut PhoneVoicemailType) -> HRESULT,
    fn DialVoicemailAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IPhoneVoicemail {
    #[inline] pub fn get_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Number)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MessageCount)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_type(&self) -> Result<PhoneVoicemailType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Type)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn dial_voicemail_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DialVoicemailAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PhoneVoicemail: IPhoneVoicemail}
RT_ENUM! { enum PhoneVoicemailType: i32 {
    None = 0, Traditional = 1, Visual = 2,
}}
DEFINE_IID!(IID_IVoipCallCoordinator, 1326549967, 59631, 17460, 156, 95, 168, 216, 147, 250, 254, 121);
RT_INTERFACE!{interface IVoipCallCoordinator(IVoipCallCoordinatorVtbl): IInspectable [IID_IVoipCallCoordinator] {
    fn ReserveCallResourcesAsync(&self, taskEntryPoint: HSTRING, out: *mut <foundation::IAsyncOperation<VoipPhoneCallResourceReservationStatus> as RtType>::Abi) -> HRESULT,
    fn add_MuteStateChanged(&self, muteChangeHandler: <foundation::TypedEventHandler<VoipCallCoordinator, MuteChangeEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MuteStateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn RequestNewIncomingCall(&self, context: HSTRING, contactName: HSTRING, contactNumber: HSTRING, contactImage: <foundation::Uri as RtType>::Abi, serviceName: HSTRING, brandingImage: <foundation::Uri as RtType>::Abi, callDetails: HSTRING, ringtone: <foundation::Uri as RtType>::Abi, media: VoipPhoneCallMedia, ringTimeout: foundation::TimeSpan, out: *mut <VoipPhoneCall as RtType>::Abi) -> HRESULT,
    fn RequestNewOutgoingCall(&self, context: HSTRING, contactName: HSTRING, serviceName: HSTRING, media: VoipPhoneCallMedia, out: *mut <VoipPhoneCall as RtType>::Abi) -> HRESULT,
    fn NotifyMuted(&self) -> HRESULT,
    fn NotifyUnmuted(&self) -> HRESULT,
    fn RequestOutgoingUpgradeToVideoCall(&self, callUpgradeGuid: Guid, context: HSTRING, contactName: HSTRING, serviceName: HSTRING, out: *mut <VoipPhoneCall as RtType>::Abi) -> HRESULT,
    fn RequestIncomingUpgradeToVideoCall(&self, context: HSTRING, contactName: HSTRING, contactNumber: HSTRING, contactImage: <foundation::Uri as RtType>::Abi, serviceName: HSTRING, brandingImage: <foundation::Uri as RtType>::Abi, callDetails: HSTRING, ringtone: <foundation::Uri as RtType>::Abi, ringTimeout: foundation::TimeSpan, out: *mut <VoipPhoneCall as RtType>::Abi) -> HRESULT,
    fn TerminateCellularCall(&self, callUpgradeGuid: Guid) -> HRESULT,
    fn CancelUpgrade(&self, callUpgradeGuid: Guid) -> HRESULT
}}
impl IVoipCallCoordinator {
    #[inline] pub fn reserve_call_resources_async(&self, taskEntryPoint: &HStringArg) -> Result<foundation::IAsyncOperation<VoipPhoneCallResourceReservationStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReserveCallResourcesAsync)(self.get_abi() as *const _ as *mut _, taskEntryPoint.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_mute_state_changed(&self, muteChangeHandler: &foundation::TypedEventHandler<VoipCallCoordinator, MuteChangeEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_MuteStateChanged)(self.get_abi() as *const _ as *mut _, muteChangeHandler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_mute_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_MuteStateChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn request_new_incoming_call(&self, context: &HStringArg, contactName: &HStringArg, contactNumber: &HStringArg, contactImage: &foundation::Uri, serviceName: &HStringArg, brandingImage: &foundation::Uri, callDetails: &HStringArg, ringtone: &foundation::Uri, media: VoipPhoneCallMedia, ringTimeout: foundation::TimeSpan) -> Result<Option<VoipPhoneCall>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestNewIncomingCall)(self.get_abi() as *const _ as *mut _, context.get(), contactName.get(), contactNumber.get(), contactImage.get_abi() as *const _ as *mut _, serviceName.get(), brandingImage.get_abi() as *const _ as *mut _, callDetails.get(), ringtone.get_abi() as *const _ as *mut _, media, ringTimeout, &mut out);
        if hr == S_OK { Ok(VoipPhoneCall::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_new_outgoing_call(&self, context: &HStringArg, contactName: &HStringArg, serviceName: &HStringArg, media: VoipPhoneCallMedia) -> Result<Option<VoipPhoneCall>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestNewOutgoingCall)(self.get_abi() as *const _ as *mut _, context.get(), contactName.get(), serviceName.get(), media, &mut out);
        if hr == S_OK { Ok(VoipPhoneCall::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn notify_muted(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().NotifyMuted)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_unmuted(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().NotifyUnmuted)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn request_outgoing_upgrade_to_video_call(&self, callUpgradeGuid: Guid, context: &HStringArg, contactName: &HStringArg, serviceName: &HStringArg) -> Result<Option<VoipPhoneCall>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestOutgoingUpgradeToVideoCall)(self.get_abi() as *const _ as *mut _, callUpgradeGuid, context.get(), contactName.get(), serviceName.get(), &mut out);
        if hr == S_OK { Ok(VoipPhoneCall::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_incoming_upgrade_to_video_call(&self, context: &HStringArg, contactName: &HStringArg, contactNumber: &HStringArg, contactImage: &foundation::Uri, serviceName: &HStringArg, brandingImage: &foundation::Uri, callDetails: &HStringArg, ringtone: &foundation::Uri, ringTimeout: foundation::TimeSpan) -> Result<Option<VoipPhoneCall>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestIncomingUpgradeToVideoCall)(self.get_abi() as *const _ as *mut _, context.get(), contactName.get(), contactNumber.get(), contactImage.get_abi() as *const _ as *mut _, serviceName.get(), brandingImage.get_abi() as *const _ as *mut _, callDetails.get(), ringtone.get_abi() as *const _ as *mut _, ringTimeout, &mut out);
        if hr == S_OK { Ok(VoipPhoneCall::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn terminate_cellular_call(&self, callUpgradeGuid: Guid) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().TerminateCellularCall)(self.get_abi() as *const _ as *mut _, callUpgradeGuid);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn cancel_upgrade(&self, callUpgradeGuid: Guid) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().CancelUpgrade)(self.get_abi() as *const _ as *mut _, callUpgradeGuid);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class VoipCallCoordinator: IVoipCallCoordinator}
impl RtActivatable<IVoipCallCoordinatorStatics> for VoipCallCoordinator {}
impl VoipCallCoordinator {
    #[inline] pub fn get_default() -> Result<Option<VoipCallCoordinator>> {
        <Self as RtActivatable<IVoipCallCoordinatorStatics>>::get_activation_factory().get_default()
    }
}
DEFINE_CLSID!(VoipCallCoordinator(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,97,108,108,115,46,86,111,105,112,67,97,108,108,67,111,111,114,100,105,110,97,116,111,114,0]) [CLSID_VoipCallCoordinator]);
DEFINE_IID!(IID_IVoipCallCoordinator2, 3199511027, 50948, 16948, 137, 206, 232, 140, 192, 210, 143, 190);
RT_INTERFACE!{interface IVoipCallCoordinator2(IVoipCallCoordinator2Vtbl): IInspectable [IID_IVoipCallCoordinator2] {
    fn SetupNewAcceptedCall(&self, context: HSTRING, contactName: HSTRING, contactNumber: HSTRING, serviceName: HSTRING, media: VoipPhoneCallMedia, out: *mut <VoipPhoneCall as RtType>::Abi) -> HRESULT
}}
impl IVoipCallCoordinator2 {
    #[inline] pub fn setup_new_accepted_call(&self, context: &HStringArg, contactName: &HStringArg, contactNumber: &HStringArg, serviceName: &HStringArg, media: VoipPhoneCallMedia) -> Result<Option<VoipPhoneCall>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SetupNewAcceptedCall)(self.get_abi() as *const _ as *mut _, context.get(), contactName.get(), contactNumber.get(), serviceName.get(), media, &mut out);
        if hr == S_OK { Ok(VoipPhoneCall::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVoipCallCoordinator3, 864881855, 39765, 16417, 135, 202, 230, 75, 155, 214, 102, 199);
RT_INTERFACE!{interface IVoipCallCoordinator3(IVoipCallCoordinator3Vtbl): IInspectable [IID_IVoipCallCoordinator3] {
    fn RequestNewAppInitiatedCall(&self, context: HSTRING, contactName: HSTRING, contactNumber: HSTRING, serviceName: HSTRING, media: VoipPhoneCallMedia, out: *mut <VoipPhoneCall as RtType>::Abi) -> HRESULT,
    fn RequestNewIncomingCallWithContactRemoteId(&self, context: HSTRING, contactName: HSTRING, contactNumber: HSTRING, contactImage: <foundation::Uri as RtType>::Abi, serviceName: HSTRING, brandingImage: <foundation::Uri as RtType>::Abi, callDetails: HSTRING, ringtone: <foundation::Uri as RtType>::Abi, media: VoipPhoneCallMedia, ringTimeout: foundation::TimeSpan, contactRemoteId: HSTRING, out: *mut <VoipPhoneCall as RtType>::Abi) -> HRESULT
}}
impl IVoipCallCoordinator3 {
    #[inline] pub fn request_new_app_initiated_call(&self, context: &HStringArg, contactName: &HStringArg, contactNumber: &HStringArg, serviceName: &HStringArg, media: VoipPhoneCallMedia) -> Result<Option<VoipPhoneCall>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestNewAppInitiatedCall)(self.get_abi() as *const _ as *mut _, context.get(), contactName.get(), contactNumber.get(), serviceName.get(), media, &mut out);
        if hr == S_OK { Ok(VoipPhoneCall::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_new_incoming_call_with_contact_remote_id(&self, context: &HStringArg, contactName: &HStringArg, contactNumber: &HStringArg, contactImage: &foundation::Uri, serviceName: &HStringArg, brandingImage: &foundation::Uri, callDetails: &HStringArg, ringtone: &foundation::Uri, media: VoipPhoneCallMedia, ringTimeout: foundation::TimeSpan, contactRemoteId: &HStringArg) -> Result<Option<VoipPhoneCall>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestNewIncomingCallWithContactRemoteId)(self.get_abi() as *const _ as *mut _, context.get(), contactName.get(), contactNumber.get(), contactImage.get_abi() as *const _ as *mut _, serviceName.get(), brandingImage.get_abi() as *const _ as *mut _, callDetails.get(), ringtone.get_abi() as *const _ as *mut _, media, ringTimeout, contactRemoteId.get(), &mut out);
        if hr == S_OK { Ok(VoipPhoneCall::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVoipCallCoordinator4, 2205381177, 37649, 18063, 187, 73, 71, 224, 223, 181, 217, 62);
RT_INTERFACE!{interface IVoipCallCoordinator4(IVoipCallCoordinator4Vtbl): IInspectable [IID_IVoipCallCoordinator4] {
    fn ReserveOneProcessCallResourcesAsync(&self, out: *mut <foundation::IAsyncOperation<VoipPhoneCallResourceReservationStatus> as RtType>::Abi) -> HRESULT
}}
impl IVoipCallCoordinator4 {
    #[inline] pub fn reserve_one_process_call_resources_async(&self) -> Result<foundation::IAsyncOperation<VoipPhoneCallResourceReservationStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReserveOneProcessCallResourcesAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVoipCallCoordinatorStatics, 2136809259, 57418, 19728, 179, 26, 165, 92, 146, 44, 194, 251);
RT_INTERFACE!{static interface IVoipCallCoordinatorStatics(IVoipCallCoordinatorStaticsVtbl): IInspectable [IID_IVoipCallCoordinatorStatics] {
    fn GetDefault(&self, out: *mut <VoipCallCoordinator as RtType>::Abi) -> HRESULT
}}
impl IVoipCallCoordinatorStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<VoipCallCoordinator>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDefault)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VoipCallCoordinator::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVoipPhoneCall, 1827795354, 30612, 19034, 140, 104, 174, 135, 148, 122, 105, 144);
RT_INTERFACE!{interface IVoipPhoneCall(IVoipPhoneCallVtbl): IInspectable [IID_IVoipPhoneCall] {
    fn add_EndRequested(&self, handler: <foundation::TypedEventHandler<VoipPhoneCall, CallStateChangeEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EndRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_HoldRequested(&self, handler: <foundation::TypedEventHandler<VoipPhoneCall, CallStateChangeEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_HoldRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ResumeRequested(&self, handler: <foundation::TypedEventHandler<VoipPhoneCall, CallStateChangeEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ResumeRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_AnswerRequested(&self, acceptHandler: <foundation::TypedEventHandler<VoipPhoneCall, CallAnswerEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AnswerRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_RejectRequested(&self, rejectHandler: <foundation::TypedEventHandler<VoipPhoneCall, CallRejectEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RejectRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn NotifyCallHeld(&self) -> HRESULT,
    fn NotifyCallActive(&self) -> HRESULT,
    fn NotifyCallEnded(&self) -> HRESULT,
    fn get_ContactName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ContactName(&self, value: HSTRING) -> HRESULT,
    fn get_StartTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn put_StartTime(&self, value: foundation::DateTime) -> HRESULT,
    fn get_CallMedia(&self, out: *mut VoipPhoneCallMedia) -> HRESULT,
    fn put_CallMedia(&self, value: VoipPhoneCallMedia) -> HRESULT,
    fn NotifyCallReady(&self) -> HRESULT
}}
impl IVoipPhoneCall {
    #[inline] pub fn add_end_requested(&self, handler: &foundation::TypedEventHandler<VoipPhoneCall, CallStateChangeEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_EndRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_end_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_EndRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_hold_requested(&self, handler: &foundation::TypedEventHandler<VoipPhoneCall, CallStateChangeEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_HoldRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_hold_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_HoldRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_resume_requested(&self, handler: &foundation::TypedEventHandler<VoipPhoneCall, CallStateChangeEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_ResumeRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_resume_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_ResumeRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_answer_requested(&self, acceptHandler: &foundation::TypedEventHandler<VoipPhoneCall, CallAnswerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_AnswerRequested)(self.get_abi() as *const _ as *mut _, acceptHandler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_answer_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_AnswerRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_reject_requested(&self, rejectHandler: &foundation::TypedEventHandler<VoipPhoneCall, CallRejectEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_RejectRequested)(self.get_abi() as *const _ as *mut _, rejectHandler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reject_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_RejectRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_call_held(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().NotifyCallHeld)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_call_active(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().NotifyCallActive)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_call_ended(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().NotifyCallEnded)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_contact_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContactName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_contact_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ContactName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_start_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_StartTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_start_time(&self, value: foundation::DateTime) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_StartTime)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_call_media(&self) -> Result<VoipPhoneCallMedia> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CallMedia)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_call_media(&self, value: VoipPhoneCallMedia) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CallMedia)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_call_ready(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().NotifyCallReady)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class VoipPhoneCall: IVoipPhoneCall}
DEFINE_IID!(IID_IVoipPhoneCall2, 1947944673, 9311, 16883, 147, 153, 49, 65, 210, 91, 82, 227);
RT_INTERFACE!{interface IVoipPhoneCall2(IVoipPhoneCall2Vtbl): IInspectable [IID_IVoipPhoneCall2] {
    fn TryShowAppUI(&self) -> HRESULT
}}
impl IVoipPhoneCall2 {
    #[inline] pub fn try_show_app_ui(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().TryShowAppUI)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVoipPhoneCall3, 227087650, 57944, 19113, 144, 122, 26, 164, 19, 194, 85, 35);
RT_INTERFACE!{interface IVoipPhoneCall3(IVoipPhoneCall3Vtbl): IInspectable [IID_IVoipPhoneCall3] {
    fn NotifyCallAccepted(&self, media: VoipPhoneCallMedia) -> HRESULT
}}
impl IVoipPhoneCall3 {
    #[inline] pub fn notify_call_accepted(&self, media: VoipPhoneCallMedia) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().NotifyCallAccepted)(self.get_abi() as *const _ as *mut _, media);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum VoipPhoneCallMedia: u32 {
    None = 0, Audio = 1, Video = 2,
}}
RT_ENUM! { enum VoipPhoneCallRejectReason: i32 {
    UserIgnored = 0, TimedOut = 1, OtherIncomingCall = 2, EmergencyCallExists = 3, InvalidCallState = 4,
}}
RT_ENUM! { enum VoipPhoneCallResourceReservationStatus: i32 {
    Success = 0, ResourcesNotAvailable = 1,
}}
RT_ENUM! { enum VoipPhoneCallState: i32 {
    Ended = 0, Held = 1, Active = 2, Incoming = 3, Outgoing = 4,
}}
pub mod background { // Windows.ApplicationModel.Calls.Background
use crate::prelude::*;
RT_ENUM! { enum PhoneCallBlockedReason: i32 {
    InCallBlockingList = 0, PrivateNumber = 1, UnknownNumber = 2,
}}
DEFINE_IID!(IID_IPhoneCallBlockedTriggerDetails, 2762379426, 58561, 17023, 134, 78, 228, 112, 71, 125, 219, 103);
RT_INTERFACE!{interface IPhoneCallBlockedTriggerDetails(IPhoneCallBlockedTriggerDetailsVtbl): IInspectable [IID_IPhoneCallBlockedTriggerDetails] {
    fn get_PhoneNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn get_LineId(&self, out: *mut Guid) -> HRESULT,
    fn get_CallBlockedReason(&self, out: *mut PhoneCallBlockedReason) -> HRESULT
}}
impl IPhoneCallBlockedTriggerDetails {
    #[inline] pub fn get_phone_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PhoneNumber)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_line_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_LineId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_call_blocked_reason(&self) -> Result<PhoneCallBlockedReason> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CallBlockedReason)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PhoneCallBlockedTriggerDetails: IPhoneCallBlockedTriggerDetails}
DEFINE_IID!(IID_IPhoneCallOriginDataRequestTriggerDetails, 1855675199, 50507, 20098, 76, 201, 227, 41, 164, 24, 69, 146);
RT_INTERFACE!{interface IPhoneCallOriginDataRequestTriggerDetails(IPhoneCallOriginDataRequestTriggerDetailsVtbl): IInspectable [IID_IPhoneCallOriginDataRequestTriggerDetails] {
    fn get_RequestId(&self, out: *mut Guid) -> HRESULT,
    fn get_PhoneNumber(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPhoneCallOriginDataRequestTriggerDetails {
    #[inline] pub fn get_request_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_RequestId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_phone_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PhoneNumber)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PhoneCallOriginDataRequestTriggerDetails: IPhoneCallOriginDataRequestTriggerDetails}
DEFINE_IID!(IID_IPhoneLineChangedTriggerDetails, 3335725543, 53533, 16600, 178, 183, 228, 10, 1, 214, 98, 73);
RT_INTERFACE!{interface IPhoneLineChangedTriggerDetails(IPhoneLineChangedTriggerDetailsVtbl): IInspectable [IID_IPhoneLineChangedTriggerDetails] {
    fn get_LineId(&self, out: *mut Guid) -> HRESULT,
    fn get_ChangeType(&self, out: *mut PhoneLineChangeKind) -> HRESULT,
    fn HasLinePropertyChanged(&self, lineProperty: PhoneLineProperties, out: *mut bool) -> HRESULT
}}
impl IPhoneLineChangedTriggerDetails {
    #[inline] pub fn get_line_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_LineId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_change_type(&self) -> Result<PhoneLineChangeKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ChangeType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn has_line_property_changed(&self, lineProperty: PhoneLineProperties) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().HasLinePropertyChanged)(self.get_abi() as *const _ as *mut _, lineProperty, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PhoneLineChangedTriggerDetails: IPhoneLineChangedTriggerDetails}
RT_ENUM! { enum PhoneLineChangeKind: i32 {
    Added = 0, Removed = 1, PropertiesChanged = 2,
}}
RT_ENUM! { enum PhoneLineProperties: u32 {
    None = 0, BrandingOptions = 1, CanDial = 2, CellularDetails = 4, DisplayColor = 8, DisplayName = 16, NetworkName = 32, NetworkState = 64, Transport = 128, Voicemail = 256,
}}
DEFINE_IID!(IID_IPhoneNewVoicemailMessageTriggerDetails, 329826331, 47153, 18643, 139, 169, 141, 34, 166, 88, 13, 207);
RT_INTERFACE!{interface IPhoneNewVoicemailMessageTriggerDetails(IPhoneNewVoicemailMessageTriggerDetailsVtbl): IInspectable [IID_IPhoneNewVoicemailMessageTriggerDetails] {
    fn get_LineId(&self, out: *mut Guid) -> HRESULT,
    fn get_VoicemailCount(&self, out: *mut i32) -> HRESULT,
    fn get_OperatorMessage(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPhoneNewVoicemailMessageTriggerDetails {
    #[inline] pub fn get_line_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_LineId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_voicemail_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_VoicemailCount)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_operator_message(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_OperatorMessage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PhoneNewVoicemailMessageTriggerDetails: IPhoneNewVoicemailMessageTriggerDetails}
RT_ENUM! { enum PhoneTriggerType: i32 {
    NewVoicemailMessage = 0, CallHistoryChanged = 1, LineChanged = 2, AirplaneModeDisabledForEmergencyCall = 3, CallOriginDataRequest = 4, CallBlocked = 5,
}}
} // Windows.ApplicationModel.Calls.Background
pub mod provider { // Windows.ApplicationModel.Calls.Provider
use crate::prelude::*;
DEFINE_IID!(IID_IPhoneCallOrigin, 543241337, 3833, 17492, 135, 28, 175, 182, 106, 20, 182, 165);
RT_INTERFACE!{interface IPhoneCallOrigin(IPhoneCallOriginVtbl): IInspectable [IID_IPhoneCallOrigin] {
    fn get_Category(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Category(&self, value: HSTRING) -> HRESULT,
    fn get_CategoryDescription(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CategoryDescription(&self, value: HSTRING) -> HRESULT,
    fn get_Location(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Location(&self, value: HSTRING) -> HRESULT
}}
impl IPhoneCallOrigin {
    #[inline] pub fn get_category(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Category)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_category(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Category)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_category_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CategoryDescription)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_category_description(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CategoryDescription)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_location(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Location)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_location(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Location)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PhoneCallOrigin: IPhoneCallOrigin}
impl RtActivatable<IActivationFactory> for PhoneCallOrigin {}
DEFINE_CLSID!(PhoneCallOrigin(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,97,108,108,115,46,80,114,111,118,105,100,101,114,46,80,104,111,110,101,67,97,108,108,79,114,105,103,105,110,0]) [CLSID_PhoneCallOrigin]);
DEFINE_IID!(IID_IPhoneCallOrigin2, 80210304, 39618, 18280, 181, 54, 182, 141, 164, 149, 125, 2);
RT_INTERFACE!{interface IPhoneCallOrigin2(IPhoneCallOrigin2Vtbl): IInspectable [IID_IPhoneCallOrigin2] {
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT
}}
impl IPhoneCallOrigin2 {
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPhoneCallOrigin3, 1228083124, 53671, 17314, 174, 238, 192, 123, 109, 186, 240, 104);
RT_INTERFACE!{interface IPhoneCallOrigin3(IPhoneCallOrigin3Vtbl): IInspectable [IID_IPhoneCallOrigin3] {
    #[cfg(feature="windows-storage")] fn get_DisplayPicture(&self, out: *mut <crate::windows::storage::StorageFile as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_DisplayPicture(&self, value: <crate::windows::storage::StorageFile as RtType>::Abi) -> HRESULT
}}
impl IPhoneCallOrigin3 {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_display_picture(&self) -> Result<Option<crate::windows::storage::StorageFile>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayPicture)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::StorageFile::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_display_picture(&self, value: &crate::windows::storage::StorageFile) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayPicture)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{static class PhoneCallOriginManager}
impl RtActivatable<IPhoneCallOriginManagerStatics> for PhoneCallOriginManager {}
impl RtActivatable<IPhoneCallOriginManagerStatics2> for PhoneCallOriginManager {}
impl PhoneCallOriginManager {
    #[inline] pub fn get_is_current_app_active_call_origin_app() -> Result<bool> {
        <Self as RtActivatable<IPhoneCallOriginManagerStatics>>::get_activation_factory().get_is_current_app_active_call_origin_app()
    }
    #[inline] pub fn show_phone_call_origin_settings_ui() -> Result<()> {
        <Self as RtActivatable<IPhoneCallOriginManagerStatics>>::get_activation_factory().show_phone_call_origin_settings_ui()
    }
    #[inline] pub fn set_call_origin(requestId: Guid, callOrigin: &PhoneCallOrigin) -> Result<()> {
        <Self as RtActivatable<IPhoneCallOriginManagerStatics>>::get_activation_factory().set_call_origin(requestId, callOrigin)
    }
    #[inline] pub fn request_set_as_active_call_origin_app_async() -> Result<foundation::IAsyncOperation<bool>> {
        <Self as RtActivatable<IPhoneCallOriginManagerStatics2>>::get_activation_factory().request_set_as_active_call_origin_app_async()
    }
}
DEFINE_CLSID!(PhoneCallOriginManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,97,108,108,115,46,80,114,111,118,105,100,101,114,46,80,104,111,110,101,67,97,108,108,79,114,105,103,105,110,77,97,110,97,103,101,114,0]) [CLSID_PhoneCallOriginManager]);
DEFINE_IID!(IID_IPhoneCallOriginManagerStatics, 3439090186, 39671, 24905, 57, 208, 224, 118, 252, 206, 19, 149);
RT_INTERFACE!{static interface IPhoneCallOriginManagerStatics(IPhoneCallOriginManagerStaticsVtbl): IInspectable [IID_IPhoneCallOriginManagerStatics] {
    fn get_IsCurrentAppActiveCallOriginApp(&self, out: *mut bool) -> HRESULT,
    fn ShowPhoneCallOriginSettingsUI(&self) -> HRESULT,
    fn SetCallOrigin(&self, requestId: Guid, callOrigin: <PhoneCallOrigin as RtType>::Abi) -> HRESULT
}}
impl IPhoneCallOriginManagerStatics {
    #[inline] pub fn get_is_current_app_active_call_origin_app(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsCurrentAppActiveCallOriginApp)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn show_phone_call_origin_settings_ui(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ShowPhoneCallOriginSettingsUI)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_call_origin(&self, requestId: Guid, callOrigin: &PhoneCallOrigin) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetCallOrigin)(self.get_abi() as *const _ as *mut _, requestId, callOrigin.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPhoneCallOriginManagerStatics2, 2348019263, 16628, 17280, 140, 124, 174, 162, 201, 184, 221, 122);
RT_INTERFACE!{static interface IPhoneCallOriginManagerStatics2(IPhoneCallOriginManagerStatics2Vtbl): IInspectable [IID_IPhoneCallOriginManagerStatics2] {
    fn RequestSetAsActiveCallOriginAppAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl IPhoneCallOriginManagerStatics2 {
    #[inline] pub fn request_set_as_active_call_origin_app_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestSetAsActiveCallOriginAppAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
} // Windows.ApplicationModel.Calls.Provider
} // Windows.ApplicationModel.Calls
pub mod chat { // Windows.ApplicationModel.Chat
use crate::prelude::*;
DEFINE_IID!(IID_IChatCapabilities, 989820860, 14793, 19921, 173, 45, 57, 100, 221, 157, 64, 63);
RT_INTERFACE!{interface IChatCapabilities(IChatCapabilitiesVtbl): IInspectable [IID_IChatCapabilities] {
    fn get_IsOnline(&self, out: *mut bool) -> HRESULT,
    fn get_IsChatCapable(&self, out: *mut bool) -> HRESULT,
    fn get_IsFileTransferCapable(&self, out: *mut bool) -> HRESULT,
    fn get_IsGeoLocationPushCapable(&self, out: *mut bool) -> HRESULT,
    fn get_IsIntegratedMessagingCapable(&self, out: *mut bool) -> HRESULT
}}
impl IChatCapabilities {
    #[inline] pub fn get_is_online(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsOnline)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_chat_capable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsChatCapable)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_file_transfer_capable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsFileTransferCapable)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_geo_location_push_capable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsGeoLocationPushCapable)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_integrated_messaging_capable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsIntegratedMessagingCapable)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatCapabilities: IChatCapabilities}
RT_CLASS!{static class ChatCapabilitiesManager}
impl RtActivatable<IChatCapabilitiesManagerStatics> for ChatCapabilitiesManager {}
impl RtActivatable<IChatCapabilitiesManagerStatics2> for ChatCapabilitiesManager {}
impl ChatCapabilitiesManager {
    #[inline] pub fn get_cached_capabilities_async(address: &HStringArg) -> Result<foundation::IAsyncOperation<ChatCapabilities>> {
        <Self as RtActivatable<IChatCapabilitiesManagerStatics>>::get_activation_factory().get_cached_capabilities_async(address)
    }
    #[inline] pub fn get_capabilities_from_network_async(address: &HStringArg) -> Result<foundation::IAsyncOperation<ChatCapabilities>> {
        <Self as RtActivatable<IChatCapabilitiesManagerStatics>>::get_activation_factory().get_capabilities_from_network_async(address)
    }
    #[inline] pub fn get_cached_capabilities_for_transport_async(address: &HStringArg, transportId: &HStringArg) -> Result<foundation::IAsyncOperation<ChatCapabilities>> {
        <Self as RtActivatable<IChatCapabilitiesManagerStatics2>>::get_activation_factory().get_cached_capabilities_for_transport_async(address, transportId)
    }
    #[inline] pub fn get_capabilities_from_network_for_transport_async(address: &HStringArg, transportId: &HStringArg) -> Result<foundation::IAsyncOperation<ChatCapabilities>> {
        <Self as RtActivatable<IChatCapabilitiesManagerStatics2>>::get_activation_factory().get_capabilities_from_network_for_transport_async(address, transportId)
    }
}
DEFINE_CLSID!(ChatCapabilitiesManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,104,97,116,46,67,104,97,116,67,97,112,97,98,105,108,105,116,105,101,115,77,97,110,97,103,101,114,0]) [CLSID_ChatCapabilitiesManager]);
DEFINE_IID!(IID_IChatCapabilitiesManagerStatics, 3044683568, 28737, 17806, 176, 207, 124, 13, 159, 234, 51, 58);
RT_INTERFACE!{static interface IChatCapabilitiesManagerStatics(IChatCapabilitiesManagerStaticsVtbl): IInspectable [IID_IChatCapabilitiesManagerStatics] {
    fn GetCachedCapabilitiesAsync(&self, address: HSTRING, out: *mut <foundation::IAsyncOperation<ChatCapabilities> as RtType>::Abi) -> HRESULT,
    fn GetCapabilitiesFromNetworkAsync(&self, address: HSTRING, out: *mut <foundation::IAsyncOperation<ChatCapabilities> as RtType>::Abi) -> HRESULT
}}
impl IChatCapabilitiesManagerStatics {
    #[inline] pub fn get_cached_capabilities_async(&self, address: &HStringArg) -> Result<foundation::IAsyncOperation<ChatCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetCachedCapabilitiesAsync)(self.get_abi() as *const _ as *mut _, address.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_capabilities_from_network_async(&self, address: &HStringArg) -> Result<foundation::IAsyncOperation<ChatCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetCapabilitiesFromNetworkAsync)(self.get_abi() as *const _ as *mut _, address.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IChatCapabilitiesManagerStatics2, 3809297012, 54721, 19145, 159, 252, 64, 230, 145, 132, 254, 200);
RT_INTERFACE!{static interface IChatCapabilitiesManagerStatics2(IChatCapabilitiesManagerStatics2Vtbl): IInspectable [IID_IChatCapabilitiesManagerStatics2] {
    fn GetCachedCapabilitiesForTransportAsync(&self, address: HSTRING, transportId: HSTRING, out: *mut <foundation::IAsyncOperation<ChatCapabilities> as RtType>::Abi) -> HRESULT,
    fn GetCapabilitiesFromNetworkForTransportAsync(&self, address: HSTRING, transportId: HSTRING, out: *mut <foundation::IAsyncOperation<ChatCapabilities> as RtType>::Abi) -> HRESULT
}}
impl IChatCapabilitiesManagerStatics2 {
    #[inline] pub fn get_cached_capabilities_for_transport_async(&self, address: &HStringArg, transportId: &HStringArg) -> Result<foundation::IAsyncOperation<ChatCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetCachedCapabilitiesForTransportAsync)(self.get_abi() as *const _ as *mut _, address.get(), transportId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_capabilities_from_network_for_transport_async(&self, address: &HStringArg, transportId: &HStringArg) -> Result<foundation::IAsyncOperation<ChatCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetCapabilitiesFromNetworkForTransportAsync)(self.get_abi() as *const _ as *mut _, address.get(), transportId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IChatConversation, 2777417741, 6767, 18140, 143, 61, 245, 2, 134, 96, 182, 238);
RT_INTERFACE!{interface IChatConversation(IChatConversationVtbl): IInspectable [IID_IChatConversation] {
    fn get_HasUnreadMessages(&self, out: *mut bool) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Subject(&self, value: HSTRING) -> HRESULT,
    fn get_IsConversationMuted(&self, out: *mut bool) -> HRESULT,
    fn put_IsConversationMuted(&self, value: bool) -> HRESULT,
    fn get_MostRecentMessageId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Participants(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT,
    fn get_ThreadingInfo(&self, out: *mut <ChatConversationThreadingInfo as RtType>::Abi) -> HRESULT,
    fn DeleteAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn GetMessageReader(&self, out: *mut <ChatMessageReader as RtType>::Abi) -> HRESULT,
    fn MarkAllMessagesAsReadAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn MarkMessagesAsReadAsync(&self, value: foundation::DateTime, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn SaveAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn NotifyLocalParticipantComposing(&self, transportId: HSTRING, participantAddress: HSTRING, isComposing: bool) -> HRESULT,
    fn NotifyRemoteParticipantComposing(&self, transportId: HSTRING, participantAddress: HSTRING, isComposing: bool) -> HRESULT,
    fn add_RemoteParticipantComposingChanged(&self, handler: <foundation::TypedEventHandler<ChatConversation, RemoteParticipantComposingChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RemoteParticipantComposingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IChatConversation {
    #[inline] pub fn get_has_unread_messages(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_HasUnreadMessages)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_subject(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Subject)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_subject(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Subject)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_conversation_muted(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsConversationMuted)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_conversation_muted(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsConversationMuted)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_most_recent_message_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MostRecentMessageId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_participants(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Participants)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_threading_info(&self) -> Result<Option<ChatConversationThreadingInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ThreadingInfo)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ChatConversationThreadingInfo::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_reader(&self) -> Result<Option<ChatMessageReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetMessageReader)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ChatMessageReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn mark_all_messages_as_read_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().MarkAllMessagesAsReadAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn mark_messages_as_read_async(&self, value: foundation::DateTime) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().MarkMessagesAsReadAsync)(self.get_abi() as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn save_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SaveAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn notify_local_participant_composing(&self, transportId: &HStringArg, participantAddress: &HStringArg, isComposing: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().NotifyLocalParticipantComposing)(self.get_abi() as *const _ as *mut _, transportId.get(), participantAddress.get(), isComposing);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_remote_participant_composing(&self, transportId: &HStringArg, participantAddress: &HStringArg, isComposing: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().NotifyRemoteParticipantComposing)(self.get_abi() as *const _ as *mut _, transportId.get(), participantAddress.get(), isComposing);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_remote_participant_composing_changed(&self, handler: &foundation::TypedEventHandler<ChatConversation, RemoteParticipantComposingChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_RemoteParticipantComposingChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_remote_participant_composing_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_RemoteParticipantComposingChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatConversation: IChatConversation}
DEFINE_IID!(IID_IChatConversation2, 167972049, 38970, 18346, 154, 144, 238, 72, 238, 153, 123, 89);
RT_INTERFACE!{interface IChatConversation2(IChatConversation2Vtbl): IInspectable [IID_IChatConversation2] {
    fn get_CanModifyParticipants(&self, out: *mut bool) -> HRESULT,
    fn put_CanModifyParticipants(&self, value: bool) -> HRESULT
}}
impl IChatConversation2 {
    #[inline] pub fn get_can_modify_participants(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanModifyParticipants)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_can_modify_participants(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanModifyParticipants)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IChatConversationReader, 89208530, 56882, 19015, 169, 58, 179, 220, 8, 51, 133, 43);
RT_INTERFACE!{interface IChatConversationReader(IChatConversationReaderVtbl): IInspectable [IID_IChatConversationReader] {
    fn ReadBatchAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<ChatConversation>> as RtType>::Abi) -> HRESULT,
    fn ReadBatchWithCountAsync(&self, count: i32, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<ChatConversation>> as RtType>::Abi) -> HRESULT
}}
impl IChatConversationReader {
    #[inline] pub fn read_batch_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<ChatConversation>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReadBatchAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn read_batch_with_count_async(&self, count: i32) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<ChatConversation>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReadBatchWithCountAsync)(self.get_abi() as *const _ as *mut _, count, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatConversationReader: IChatConversationReader}
DEFINE_IID!(IID_IChatConversationThreadingInfo, 857481692, 31239, 17442, 163, 44, 36, 190, 124, 109, 171, 36);
RT_INTERFACE!{interface IChatConversationThreadingInfo(IChatConversationThreadingInfoVtbl): IInspectable [IID_IChatConversationThreadingInfo] {
    fn get_ContactId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ContactId(&self, value: HSTRING) -> HRESULT,
    fn get_Custom(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Custom(&self, value: HSTRING) -> HRESULT,
    fn get_ConversationId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ConversationId(&self, value: HSTRING) -> HRESULT,
    fn get_Participants(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT,
    fn get_Kind(&self, out: *mut ChatConversationThreadingKind) -> HRESULT,
    fn put_Kind(&self, value: ChatConversationThreadingKind) -> HRESULT
}}
impl IChatConversationThreadingInfo {
    #[inline] pub fn get_contact_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContactId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_contact_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ContactId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_custom(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Custom)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_custom(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Custom)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_conversation_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ConversationId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_conversation_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ConversationId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_participants(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Participants)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_kind(&self) -> Result<ChatConversationThreadingKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Kind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_kind(&self, value: ChatConversationThreadingKind) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Kind)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatConversationThreadingInfo: IChatConversationThreadingInfo}
impl RtActivatable<IActivationFactory> for ChatConversationThreadingInfo {}
DEFINE_CLSID!(ChatConversationThreadingInfo(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,104,97,116,46,67,104,97,116,67,111,110,118,101,114,115,97,116,105,111,110,84,104,114,101,97,100,105,110,103,73,110,102,111,0]) [CLSID_ChatConversationThreadingInfo]);
RT_ENUM! { enum ChatConversationThreadingKind: i32 {
    Participants = 0, ContactId = 1, ConversationId = 2, Custom = 3,
}}
DEFINE_IID!(IID_IChatItem, 2270285824, 52913, 16963, 184, 3, 21, 212, 90, 29, 212, 40);
RT_INTERFACE!{interface IChatItem(IChatItemVtbl): IInspectable [IID_IChatItem] {
    fn get_ItemKind(&self, out: *mut ChatItemKind) -> HRESULT
}}
impl IChatItem {
    #[inline] pub fn get_item_kind(&self) -> Result<ChatItemKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ItemKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum ChatItemKind: i32 {
    Message = 0, Conversation = 1,
}}
DEFINE_IID!(IID_IChatMessage, 1262028074, 4418, 20617, 118, 218, 242, 219, 61, 23, 205, 5);
RT_INTERFACE!{interface IChatMessage(IChatMessageVtbl): IInspectable [IID_IChatMessage] {
    fn get_Attachments(&self, out: *mut <foundation::collections::IVector<ChatMessageAttachment> as RtType>::Abi) -> HRESULT,
    fn get_Body(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Body(&self, value: HSTRING) -> HRESULT,
    fn get_From(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsForwardingDisabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsIncoming(&self, out: *mut bool) -> HRESULT,
    fn get_IsRead(&self, out: *mut bool) -> HRESULT,
    fn get_LocalTimestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_NetworkTimestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_Recipients(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT,
    fn get_RecipientSendStatuses(&self, out: *mut <foundation::collections::IMapView<HString, ChatMessageStatus> as RtType>::Abi) -> HRESULT,
    fn get_Status(&self, out: *mut ChatMessageStatus) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TransportFriendlyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TransportId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TransportId(&self, value: HSTRING) -> HRESULT
}}
impl IChatMessage {
    #[inline] pub fn get_attachments(&self) -> Result<Option<foundation::collections::IVector<ChatMessageAttachment>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Attachments)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_body(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Body)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_body(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Body)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_from(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_From)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_forwarding_disabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsForwardingDisabled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_incoming(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsIncoming)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_read(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsRead)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_local_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_LocalTimestamp)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_network_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_NetworkTimestamp)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_recipients(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Recipients)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_recipient_send_statuses(&self) -> Result<Option<foundation::collections::IMapView<HString, ChatMessageStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RecipientSendStatuses)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<ChatMessageStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_subject(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Subject)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_transport_friendly_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TransportFriendlyName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_transport_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TransportId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_transport_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_TransportId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatMessage: IChatMessage}
impl RtActivatable<IActivationFactory> for ChatMessage {}
DEFINE_CLSID!(ChatMessage(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,104,97,116,46,67,104,97,116,77,101,115,115,97,103,101,0]) [CLSID_ChatMessage]);
DEFINE_IID!(IID_IChatMessage2, 2254865202, 21567, 18933, 172, 113, 108, 42, 252, 101, 101, 253);
RT_INTERFACE!{interface IChatMessage2(IChatMessage2Vtbl): IInspectable [IID_IChatMessage2] {
    fn get_EstimatedDownloadSize(&self, out: *mut u64) -> HRESULT,
    fn put_EstimatedDownloadSize(&self, value: u64) -> HRESULT,
    fn put_From(&self, value: HSTRING) -> HRESULT,
    fn get_IsAutoReply(&self, out: *mut bool) -> HRESULT,
    fn put_IsAutoReply(&self, value: bool) -> HRESULT,
    fn put_IsForwardingDisabled(&self, value: bool) -> HRESULT,
    fn get_IsReplyDisabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsIncoming(&self, value: bool) -> HRESULT,
    fn put_IsRead(&self, value: bool) -> HRESULT,
    fn get_IsSeen(&self, out: *mut bool) -> HRESULT,
    fn put_IsSeen(&self, value: bool) -> HRESULT,
    fn get_IsSimMessage(&self, out: *mut bool) -> HRESULT,
    fn put_LocalTimestamp(&self, value: foundation::DateTime) -> HRESULT,
    fn get_MessageKind(&self, out: *mut ChatMessageKind) -> HRESULT,
    fn put_MessageKind(&self, value: ChatMessageKind) -> HRESULT,
    fn get_MessageOperatorKind(&self, out: *mut ChatMessageOperatorKind) -> HRESULT,
    fn put_MessageOperatorKind(&self, value: ChatMessageOperatorKind) -> HRESULT,
    fn put_NetworkTimestamp(&self, value: foundation::DateTime) -> HRESULT,
    fn get_IsReceivedDuringQuietHours(&self, out: *mut bool) -> HRESULT,
    fn put_IsReceivedDuringQuietHours(&self, value: bool) -> HRESULT,
    fn put_RemoteId(&self, value: HSTRING) -> HRESULT,
    fn put_Status(&self, value: ChatMessageStatus) -> HRESULT,
    fn put_Subject(&self, value: HSTRING) -> HRESULT,
    fn get_ShouldSuppressNotification(&self, out: *mut bool) -> HRESULT,
    fn put_ShouldSuppressNotification(&self, value: bool) -> HRESULT,
    fn get_ThreadingInfo(&self, out: *mut <ChatConversationThreadingInfo as RtType>::Abi) -> HRESULT,
    fn put_ThreadingInfo(&self, value: <ChatConversationThreadingInfo as RtType>::Abi) -> HRESULT,
    fn get_RecipientsDeliveryInfos(&self, out: *mut <foundation::collections::IVector<ChatRecipientDeliveryInfo> as RtType>::Abi) -> HRESULT
}}
impl IChatMessage2 {
    #[inline] pub fn get_estimated_download_size(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_EstimatedDownloadSize)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_estimated_download_size(&self, value: u64) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_EstimatedDownloadSize)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_from(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_From)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_auto_reply(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsAutoReply)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_auto_reply(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsAutoReply)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_is_forwarding_disabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsForwardingDisabled)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_reply_disabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsReplyDisabled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_incoming(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsIncoming)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_is_read(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsRead)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_seen(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsSeen)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_seen(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsSeen)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_sim_message(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsSimMessage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_local_timestamp(&self, value: foundation::DateTime) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_LocalTimestamp)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_message_kind(&self) -> Result<ChatMessageKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MessageKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_message_kind(&self, value: ChatMessageKind) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MessageKind)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_message_operator_kind(&self) -> Result<ChatMessageOperatorKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MessageOperatorKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_message_operator_kind(&self, value: ChatMessageOperatorKind) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MessageOperatorKind)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_network_timestamp(&self, value: foundation::DateTime) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_NetworkTimestamp)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_received_during_quiet_hours(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsReceivedDuringQuietHours)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_received_during_quiet_hours(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsReceivedDuringQuietHours)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_remote_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RemoteId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_status(&self, value: ChatMessageStatus) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Status)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_subject(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Subject)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_should_suppress_notification(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ShouldSuppressNotification)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_should_suppress_notification(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ShouldSuppressNotification)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_threading_info(&self) -> Result<Option<ChatConversationThreadingInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ThreadingInfo)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ChatConversationThreadingInfo::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_threading_info(&self, value: &ChatConversationThreadingInfo) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ThreadingInfo)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_recipients_delivery_infos(&self) -> Result<Option<foundation::collections::IVector<ChatRecipientDeliveryInfo>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RecipientsDeliveryInfos)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IChatMessage3, 1961570224, 15271, 17823, 142, 11, 232, 175, 15, 235, 217, 173);
RT_INTERFACE!{interface IChatMessage3(IChatMessage3Vtbl): IInspectable [IID_IChatMessage3] {
    fn get_RemoteId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IChatMessage3 {
    #[inline] pub fn get_remote_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RemoteId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IChatMessage4, 756304655, 53951, 17932, 170, 104, 109, 63, 132, 131, 201, 191);
RT_INTERFACE!{interface IChatMessage4(IChatMessage4Vtbl): IInspectable [IID_IChatMessage4] {
    fn get_SyncId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SyncId(&self, value: HSTRING) -> HRESULT
}}
impl IChatMessage4 {
    #[inline] pub fn get_sync_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SyncId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_sync_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SyncId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IChatMessageAttachment, 3351575924, 48995, 22763, 80, 140, 139, 134, 63, 241, 107, 103);
RT_INTERFACE!{interface IChatMessageAttachment(IChatMessageAttachmentVtbl): IInspectable [IID_IChatMessageAttachment] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_DataStreamReference(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_DataStreamReference(&self, value: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    fn get_GroupId(&self, out: *mut u32) -> HRESULT,
    fn put_GroupId(&self, value: u32) -> HRESULT,
    fn get_MimeType(&self, out: *mut HSTRING) -> HRESULT,
    fn put_MimeType(&self, value: HSTRING) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Text(&self, value: HSTRING) -> HRESULT
}}
impl IChatMessageAttachment {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_data_stream_reference(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DataStreamReference)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_data_stream_reference(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DataStreamReference)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_group_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_GroupId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_group_id(&self, value: u32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_GroupId)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_mime_type(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MimeType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_mime_type(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MimeType)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Text)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_text(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Text)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatMessageAttachment: IChatMessageAttachment}
impl RtActivatable<IChatMessageAttachmentFactory> for ChatMessageAttachment {}
impl ChatMessageAttachment {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_chat_message_attachment(mimeType: &HStringArg, dataStreamReference: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<ChatMessageAttachment> {
        <Self as RtActivatable<IChatMessageAttachmentFactory>>::get_activation_factory().create_chat_message_attachment(mimeType, dataStreamReference)
    }
}
DEFINE_CLSID!(ChatMessageAttachment(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,104,97,116,46,67,104,97,116,77,101,115,115,97,103,101,65,116,116,97,99,104,109,101,110,116,0]) [CLSID_ChatMessageAttachment]);
DEFINE_IID!(IID_IChatMessageAttachment2, 1591317104, 32209, 19079, 168, 206, 172, 221, 135, 216, 13, 200);
RT_INTERFACE!{interface IChatMessageAttachment2(IChatMessageAttachment2Vtbl): IInspectable [IID_IChatMessageAttachment2] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Thumbnail(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Thumbnail(&self, value: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    fn get_TransferProgress(&self, out: *mut f64) -> HRESULT,
    fn put_TransferProgress(&self, value: f64) -> HRESULT,
    fn get_OriginalFileName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_OriginalFileName(&self, value: HSTRING) -> HRESULT
}}
impl IChatMessageAttachment2 {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_thumbnail(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Thumbnail)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_thumbnail(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Thumbnail)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_transfer_progress(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_TransferProgress)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_transfer_progress(&self, value: f64) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_TransferProgress)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_original_file_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_OriginalFileName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_original_file_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_OriginalFileName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IChatMessageAttachmentFactory, 542659234, 41814, 23409, 108, 169, 102, 201, 133, 183, 208, 213);
RT_INTERFACE!{static interface IChatMessageAttachmentFactory(IChatMessageAttachmentFactoryVtbl): IInspectable [IID_IChatMessageAttachmentFactory] {
    #[cfg(feature="windows-storage")] fn CreateChatMessageAttachment(&self, mimeType: HSTRING, dataStreamReference: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi, out: *mut <ChatMessageAttachment as RtType>::Abi) -> HRESULT
}}
impl IChatMessageAttachmentFactory {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_chat_message_attachment(&self, mimeType: &HStringArg, dataStreamReference: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<ChatMessageAttachment> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateChatMessageAttachment)(self.get_abi() as *const _ as *mut _, mimeType.get(), dataStreamReference.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ChatMessageAttachment::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class ChatMessageBlocking}
impl RtActivatable<IChatMessageBlockingStatic> for ChatMessageBlocking {}
impl ChatMessageBlocking {
    #[inline] pub fn mark_message_as_blocked_async(localChatMessageId: &HStringArg, blocked: bool) -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<IChatMessageBlockingStatic>>::get_activation_factory().mark_message_as_blocked_async(localChatMessageId, blocked)
    }
}
DEFINE_CLSID!(ChatMessageBlocking(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,104,97,116,46,67,104,97,116,77,101,115,115,97,103,101,66,108,111,99,107,105,110,103,0]) [CLSID_ChatMessageBlocking]);
DEFINE_IID!(IID_IChatMessageBlockingStatic, 4139361152, 52714, 4580, 136, 48, 8, 0, 32, 12, 154, 102);
RT_INTERFACE!{static interface IChatMessageBlockingStatic(IChatMessageBlockingStaticVtbl): IInspectable [IID_IChatMessageBlockingStatic] {
    fn MarkMessageAsBlockedAsync(&self, localChatMessageId: HSTRING, blocked: bool, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IChatMessageBlockingStatic {
    #[inline] pub fn mark_message_as_blocked_async(&self, localChatMessageId: &HStringArg, blocked: bool) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().MarkMessageAsBlockedAsync)(self.get_abi() as *const _ as *mut _, localChatMessageId.get(), blocked, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IChatMessageChange, 471384917, 16926, 21688, 109, 56, 107, 58, 108, 130, 252, 204);
RT_INTERFACE!{interface IChatMessageChange(IChatMessageChangeVtbl): IInspectable [IID_IChatMessageChange] {
    fn get_ChangeType(&self, out: *mut ChatMessageChangeType) -> HRESULT,
    fn get_Message(&self, out: *mut <ChatMessage as RtType>::Abi) -> HRESULT
}}
impl IChatMessageChange {
    #[inline] pub fn get_change_type(&self) -> Result<ChatMessageChangeType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ChangeType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_message(&self) -> Result<Option<ChatMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Message)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ChatMessage::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatMessageChange: IChatMessageChange}
DEFINE_IID!(IID_IChatMessageChangedDeferral, 4224103180, 30860, 19916, 172, 231, 98, 130, 56, 41, 104, 207);
RT_INTERFACE!{interface IChatMessageChangedDeferral(IChatMessageChangedDeferralVtbl): IInspectable [IID_IChatMessageChangedDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IChatMessageChangedDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Complete)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatMessageChangedDeferral: IChatMessageChangedDeferral}
DEFINE_IID!(IID_IChatMessageChangedEventArgs, 3065462317, 26908, 20191, 134, 96, 110, 185, 137, 104, 146, 227);
RT_INTERFACE!{interface IChatMessageChangedEventArgs(IChatMessageChangedEventArgsVtbl): IInspectable [IID_IChatMessageChangedEventArgs] {
    fn GetDeferral(&self, out: *mut <ChatMessageChangedDeferral as RtType>::Abi) -> HRESULT
}}
impl IChatMessageChangedEventArgs {
    #[inline] pub fn get_deferral(&self) -> Result<Option<ChatMessageChangedDeferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ChatMessageChangedDeferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatMessageChangedEventArgs: IChatMessageChangedEventArgs}
DEFINE_IID!(IID_IChatMessageChangeReader, 338063392, 10446, 24358, 123, 5, 154, 92, 124, 206, 135, 202);
RT_INTERFACE!{interface IChatMessageChangeReader(IChatMessageChangeReaderVtbl): IInspectable [IID_IChatMessageChangeReader] {
    fn AcceptChanges(&self) -> HRESULT,
    fn AcceptChangesThrough(&self, lastChangeToAcknowledge: <ChatMessageChange as RtType>::Abi) -> HRESULT,
    fn ReadBatchAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<ChatMessageChange>> as RtType>::Abi) -> HRESULT
}}
impl IChatMessageChangeReader {
    #[inline] pub fn accept_changes(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().AcceptChanges)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn accept_changes_through(&self, lastChangeToAcknowledge: &ChatMessageChange) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().AcceptChangesThrough)(self.get_abi() as *const _ as *mut _, lastChangeToAcknowledge.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn read_batch_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<ChatMessageChange>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReadBatchAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatMessageChangeReader: IChatMessageChangeReader}
DEFINE_IID!(IID_IChatMessageChangeTracker, 1622667366, 28832, 21028, 80, 140, 36, 46, 247, 193, 208, 111);
RT_INTERFACE!{interface IChatMessageChangeTracker(IChatMessageChangeTrackerVtbl): IInspectable [IID_IChatMessageChangeTracker] {
    fn Enable(&self) -> HRESULT,
    fn GetChangeReader(&self, out: *mut <ChatMessageChangeReader as RtType>::Abi) -> HRESULT,
    fn Reset(&self) -> HRESULT
}}
impl IChatMessageChangeTracker {
    #[inline] pub fn enable(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Enable)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_change_reader(&self) -> Result<Option<ChatMessageChangeReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetChangeReader)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ChatMessageChangeReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn reset(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Reset)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatMessageChangeTracker: IChatMessageChangeTracker}
RT_ENUM! { enum ChatMessageChangeType: i32 {
    MessageCreated = 0, MessageModified = 1, MessageDeleted = 2, ChangeTrackingLost = 3,
}}
RT_ENUM! { enum ChatMessageKind: i32 {
    Standard = 0, FileTransferRequest = 1, TransportCustom = 2, JoinedConversation = 3, LeftConversation = 4, OtherParticipantJoinedConversation = 5, OtherParticipantLeftConversation = 6,
}}
RT_CLASS!{static class ChatMessageManager}
impl RtActivatable<IChatMessageManager2Statics> for ChatMessageManager {}
impl RtActivatable<IChatMessageManagerStatic> for ChatMessageManager {}
impl RtActivatable<IChatMessageManagerStatics3> for ChatMessageManager {}
impl ChatMessageManager {
    #[inline] pub fn register_transport_async() -> Result<foundation::IAsyncOperation<HString>> {
        <Self as RtActivatable<IChatMessageManager2Statics>>::get_activation_factory().register_transport_async()
    }
    #[inline] pub fn get_transport_async(transportId: &HStringArg) -> Result<foundation::IAsyncOperation<ChatMessageTransport>> {
        <Self as RtActivatable<IChatMessageManager2Statics>>::get_activation_factory().get_transport_async(transportId)
    }
    #[inline] pub fn get_transports_async() -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<ChatMessageTransport>>> {
        <Self as RtActivatable<IChatMessageManagerStatic>>::get_activation_factory().get_transports_async()
    }
    #[inline] pub fn request_store_async() -> Result<foundation::IAsyncOperation<ChatMessageStore>> {
        <Self as RtActivatable<IChatMessageManagerStatic>>::get_activation_factory().request_store_async()
    }
    #[inline] pub fn show_compose_sms_message_async(message: &ChatMessage) -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<IChatMessageManagerStatic>>::get_activation_factory().show_compose_sms_message_async(message)
    }
    #[inline] pub fn show_sms_settings() -> Result<()> {
        <Self as RtActivatable<IChatMessageManagerStatic>>::get_activation_factory().show_sms_settings()
    }
    #[inline] pub fn request_sync_manager_async() -> Result<foundation::IAsyncOperation<ChatSyncManager>> {
        <Self as RtActivatable<IChatMessageManagerStatics3>>::get_activation_factory().request_sync_manager_async()
    }
}
DEFINE_CLSID!(ChatMessageManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,104,97,116,46,67,104,97,116,77,101,115,115,97,103,101,77,97,110,97,103,101,114,0]) [CLSID_ChatMessageManager]);
DEFINE_IID!(IID_IChatMessageManager2Statics, 491075855, 40783, 20021, 150, 78, 27, 156, 166, 26, 192, 68);
RT_INTERFACE!{static interface IChatMessageManager2Statics(IChatMessageManager2StaticsVtbl): IInspectable [IID_IChatMessageManager2Statics] {
    fn RegisterTransportAsync(&self, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn GetTransportAsync(&self, transportId: HSTRING, out: *mut <foundation::IAsyncOperation<ChatMessageTransport> as RtType>::Abi) -> HRESULT
}}
impl IChatMessageManager2Statics {
    #[inline] pub fn register_transport_async(&self) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RegisterTransportAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_transport_async(&self, transportId: &HStringArg) -> Result<foundation::IAsyncOperation<ChatMessageTransport>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetTransportAsync)(self.get_abi() as *const _ as *mut _, transportId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IChatMessageManagerStatic, 4049363191, 54760, 24210, 85, 109, 224, 59, 96, 37, 49, 4);
RT_INTERFACE!{static interface IChatMessageManagerStatic(IChatMessageManagerStaticVtbl): IInspectable [IID_IChatMessageManagerStatic] {
    fn GetTransportsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<ChatMessageTransport>> as RtType>::Abi) -> HRESULT,
    fn RequestStoreAsync(&self, out: *mut <foundation::IAsyncOperation<ChatMessageStore> as RtType>::Abi) -> HRESULT,
    fn ShowComposeSmsMessageAsync(&self, message: <ChatMessage as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ShowSmsSettings(&self) -> HRESULT
}}
impl IChatMessageManagerStatic {
    #[inline] pub fn get_transports_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<ChatMessageTransport>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetTransportsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_store_async(&self) -> Result<foundation::IAsyncOperation<ChatMessageStore>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestStoreAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_compose_sms_message_async(&self, message: &ChatMessage) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowComposeSmsMessageAsync)(self.get_abi() as *const _ as *mut _, message.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_sms_settings(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ShowSmsSettings)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IChatMessageManagerStatics3, 546013965, 26453, 18636, 154, 179, 253, 3, 196, 99, 252, 146);
RT_INTERFACE!{static interface IChatMessageManagerStatics3(IChatMessageManagerStatics3Vtbl): IInspectable [IID_IChatMessageManagerStatics3] {
    fn RequestSyncManagerAsync(&self, out: *mut <foundation::IAsyncOperation<ChatSyncManager> as RtType>::Abi) -> HRESULT
}}
impl IChatMessageManagerStatics3 {
    #[inline] pub fn request_sync_manager_async(&self) -> Result<foundation::IAsyncOperation<ChatSyncManager>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestSyncManagerAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IChatMessageNotificationTriggerDetails, 4248063483, 12387, 19991, 133, 134, 198, 192, 130, 98, 230, 192);
RT_INTERFACE!{interface IChatMessageNotificationTriggerDetails(IChatMessageNotificationTriggerDetailsVtbl): IInspectable [IID_IChatMessageNotificationTriggerDetails] {
    fn get_ChatMessage(&self, out: *mut <ChatMessage as RtType>::Abi) -> HRESULT
}}
impl IChatMessageNotificationTriggerDetails {
    #[inline] pub fn get_chat_message(&self) -> Result<Option<ChatMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ChatMessage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ChatMessage::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatMessageNotificationTriggerDetails: IChatMessageNotificationTriggerDetails}
DEFINE_IID!(IID_IChatMessageNotificationTriggerDetails2, 1807033056, 43527, 20433, 148, 113, 119, 147, 79, 183, 94, 230);
RT_INTERFACE!{interface IChatMessageNotificationTriggerDetails2(IChatMessageNotificationTriggerDetails2Vtbl): IInspectable [IID_IChatMessageNotificationTriggerDetails2] {
    fn get_ShouldDisplayToast(&self, out: *mut bool) -> HRESULT,
    fn get_ShouldUpdateDetailText(&self, out: *mut bool) -> HRESULT,
    fn get_ShouldUpdateBadge(&self, out: *mut bool) -> HRESULT,
    fn get_ShouldUpdateActionCenter(&self, out: *mut bool) -> HRESULT
}}
impl IChatMessageNotificationTriggerDetails2 {
    #[inline] pub fn get_should_display_toast(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ShouldDisplayToast)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_should_update_detail_text(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ShouldUpdateDetailText)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_should_update_badge(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ShouldUpdateBadge)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_should_update_action_center(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ShouldUpdateActionCenter)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum ChatMessageOperatorKind: i32 {
    Unspecified = 0, Sms = 1, Mms = 2, Rcs = 3,
}}
DEFINE_IID!(IID_IChatMessageReader, 3068819662, 17545, 22265, 118, 170, 226, 4, 104, 37, 20, 207);
RT_INTERFACE!{interface IChatMessageReader(IChatMessageReaderVtbl): IInspectable [IID_IChatMessageReader] {
    fn ReadBatchAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<ChatMessage>> as RtType>::Abi) -> HRESULT
}}
impl IChatMessageReader {
    #[inline] pub fn read_batch_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<ChatMessage>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReadBatchAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatMessageReader: IChatMessageReader}
DEFINE_IID!(IID_IChatMessageReader2, 2305046147, 25787, 18189, 157, 244, 13, 232, 190, 26, 5, 191);
RT_INTERFACE!{interface IChatMessageReader2(IChatMessageReader2Vtbl): IInspectable [IID_IChatMessageReader2] {
    fn ReadBatchWithCountAsync(&self, count: i32, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<ChatMessage>> as RtType>::Abi) -> HRESULT
}}
impl IChatMessageReader2 {
    #[inline] pub fn read_batch_with_count_async(&self, count: i32) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<ChatMessage>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReadBatchWithCountAsync)(self.get_abi() as *const _ as *mut _, count, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ChatMessageStatus: i32 {
    Draft = 0, Sending = 1, Sent = 2, SendRetryNeeded = 3, SendFailed = 4, Received = 5, ReceiveDownloadNeeded = 6, ReceiveDownloadFailed = 7, ReceiveDownloading = 8, Deleted = 9, Declined = 10, Cancelled = 11, Recalled = 12, ReceiveRetryNeeded = 13,
}}
DEFINE_IID!(IID_IChatMessageStore, 838008065, 52470, 22539, 73, 118, 10, 7, 221, 93, 59, 71);
RT_INTERFACE!{interface IChatMessageStore(IChatMessageStoreVtbl): IInspectable [IID_IChatMessageStore] {
    fn get_ChangeTracker(&self, out: *mut <ChatMessageChangeTracker as RtType>::Abi) -> HRESULT,
    fn DeleteMessageAsync(&self, localMessageId: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn DownloadMessageAsync(&self, localChatMessageId: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn GetMessageAsync(&self, localChatMessageId: HSTRING, out: *mut <foundation::IAsyncOperation<ChatMessage> as RtType>::Abi) -> HRESULT,
    fn GetMessageReader1(&self, out: *mut <ChatMessageReader as RtType>::Abi) -> HRESULT,
    fn GetMessageReader2(&self, recentTimeLimit: foundation::TimeSpan, out: *mut <ChatMessageReader as RtType>::Abi) -> HRESULT,
    fn MarkMessageReadAsync(&self, localChatMessageId: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn RetrySendMessageAsync(&self, localChatMessageId: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn SendMessageAsync(&self, chatMessage: <ChatMessage as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ValidateMessage(&self, chatMessage: <ChatMessage as RtType>::Abi, out: *mut <ChatMessageValidationResult as RtType>::Abi) -> HRESULT,
    fn add_MessageChanged(&self, value: <foundation::TypedEventHandler<ChatMessageStore, ChatMessageChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MessageChanged(&self, value: foundation::EventRegistrationToken) -> HRESULT
}}
impl IChatMessageStore {
    #[inline] pub fn get_change_tracker(&self) -> Result<Option<ChatMessageChangeTracker>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ChangeTracker)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ChatMessageChangeTracker::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_message_async(&self, localMessageId: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteMessageAsync)(self.get_abi() as *const _ as *mut _, localMessageId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn download_message_async(&self, localChatMessageId: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DownloadMessageAsync)(self.get_abi() as *const _ as *mut _, localChatMessageId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_async(&self, localChatMessageId: &HStringArg) -> Result<foundation::IAsyncOperation<ChatMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetMessageAsync)(self.get_abi() as *const _ as *mut _, localChatMessageId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_reader1(&self) -> Result<Option<ChatMessageReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetMessageReader1)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ChatMessageReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_reader2(&self, recentTimeLimit: foundation::TimeSpan) -> Result<Option<ChatMessageReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetMessageReader2)(self.get_abi() as *const _ as *mut _, recentTimeLimit, &mut out);
        if hr == S_OK { Ok(ChatMessageReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn mark_message_read_async(&self, localChatMessageId: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().MarkMessageReadAsync)(self.get_abi() as *const _ as *mut _, localChatMessageId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn retry_send_message_async(&self, localChatMessageId: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RetrySendMessageAsync)(self.get_abi() as *const _ as *mut _, localChatMessageId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn send_message_async(&self, chatMessage: &ChatMessage) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SendMessageAsync)(self.get_abi() as *const _ as *mut _, chatMessage.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn validate_message(&self, chatMessage: &ChatMessage) -> Result<Option<ChatMessageValidationResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ValidateMessage)(self.get_abi() as *const _ as *mut _, chatMessage.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ChatMessageValidationResult::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_message_changed(&self, value: &foundation::TypedEventHandler<ChatMessageStore, ChatMessageChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_MessageChanged)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_message_changed(&self, value: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_MessageChanged)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatMessageStore: IChatMessageStore}
DEFINE_IID!(IID_IChatMessageStore2, 2907555054, 15060, 18715, 179, 17, 171, 223, 155, 178, 39, 104);
RT_INTERFACE!{interface IChatMessageStore2(IChatMessageStore2Vtbl): IInspectable [IID_IChatMessageStore2] {
    fn ForwardMessageAsync(&self, localChatMessageId: HSTRING, addresses: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<ChatMessage> as RtType>::Abi) -> HRESULT,
    fn GetConversationAsync(&self, conversationId: HSTRING, out: *mut <foundation::IAsyncOperation<ChatConversation> as RtType>::Abi) -> HRESULT,
    fn GetConversationForTransportsAsync(&self, conversationId: HSTRING, transportIds: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<ChatConversation> as RtType>::Abi) -> HRESULT,
    fn GetConversationFromThreadingInfoAsync(&self, threadingInfo: <ChatConversationThreadingInfo as RtType>::Abi, out: *mut <foundation::IAsyncOperation<ChatConversation> as RtType>::Abi) -> HRESULT,
    fn GetConversationReader(&self, out: *mut <ChatConversationReader as RtType>::Abi) -> HRESULT,
    fn GetConversationForTransportsReader(&self, transportIds: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <ChatConversationReader as RtType>::Abi) -> HRESULT,
    fn GetMessageByRemoteIdAsync(&self, transportId: HSTRING, remoteId: HSTRING, out: *mut <foundation::IAsyncOperation<ChatMessage> as RtType>::Abi) -> HRESULT,
    fn GetUnseenCountAsync(&self, out: *mut <foundation::IAsyncOperation<i32> as RtType>::Abi) -> HRESULT,
    fn GetUnseenCountForTransportsReaderAsync(&self, transportIds: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<i32> as RtType>::Abi) -> HRESULT,
    fn MarkAsSeenAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn MarkAsSeenForTransportsAsync(&self, transportIds: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn GetSearchReader(&self, value: <ChatQueryOptions as RtType>::Abi, out: *mut <ChatSearchReader as RtType>::Abi) -> HRESULT,
    fn SaveMessageAsync(&self, chatMessage: <ChatMessage as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn TryCancelDownloadMessageAsync(&self, localChatMessageId: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryCancelSendMessageAsync(&self, localChatMessageId: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn add_StoreChanged(&self, handler: <foundation::TypedEventHandler<ChatMessageStore, ChatMessageStoreChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StoreChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IChatMessageStore2 {
    #[inline] pub fn forward_message_async(&self, localChatMessageId: &HStringArg, addresses: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<ChatMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ForwardMessageAsync)(self.get_abi() as *const _ as *mut _, localChatMessageId.get(), addresses.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_conversation_async(&self, conversationId: &HStringArg) -> Result<foundation::IAsyncOperation<ChatConversation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetConversationAsync)(self.get_abi() as *const _ as *mut _, conversationId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_conversation_for_transports_async(&self, conversationId: &HStringArg, transportIds: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<ChatConversation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetConversationForTransportsAsync)(self.get_abi() as *const _ as *mut _, conversationId.get(), transportIds.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_conversation_from_threading_info_async(&self, threadingInfo: &ChatConversationThreadingInfo) -> Result<foundation::IAsyncOperation<ChatConversation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetConversationFromThreadingInfoAsync)(self.get_abi() as *const _ as *mut _, threadingInfo.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_conversation_reader(&self) -> Result<Option<ChatConversationReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetConversationReader)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ChatConversationReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_conversation_for_transports_reader(&self, transportIds: &foundation::collections::IIterable<HString>) -> Result<Option<ChatConversationReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetConversationForTransportsReader)(self.get_abi() as *const _ as *mut _, transportIds.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ChatConversationReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_by_remote_id_async(&self, transportId: &HStringArg, remoteId: &HStringArg) -> Result<foundation::IAsyncOperation<ChatMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetMessageByRemoteIdAsync)(self.get_abi() as *const _ as *mut _, transportId.get(), remoteId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_unseen_count_async(&self) -> Result<foundation::IAsyncOperation<i32>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetUnseenCountAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_unseen_count_for_transports_reader_async(&self, transportIds: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<i32>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetUnseenCountForTransportsReaderAsync)(self.get_abi() as *const _ as *mut _, transportIds.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn mark_as_seen_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().MarkAsSeenAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn mark_as_seen_for_transports_async(&self, transportIds: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().MarkAsSeenForTransportsAsync)(self.get_abi() as *const _ as *mut _, transportIds.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_search_reader(&self, value: &ChatQueryOptions) -> Result<Option<ChatSearchReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetSearchReader)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ChatSearchReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn save_message_async(&self, chatMessage: &ChatMessage) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SaveMessageAsync)(self.get_abi() as *const _ as *mut _, chatMessage.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_cancel_download_message_async(&self, localChatMessageId: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryCancelDownloadMessageAsync)(self.get_abi() as *const _ as *mut _, localChatMessageId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_cancel_send_message_async(&self, localChatMessageId: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryCancelSendMessageAsync)(self.get_abi() as *const _ as *mut _, localChatMessageId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_store_changed(&self, handler: &foundation::TypedEventHandler<ChatMessageStore, ChatMessageStoreChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_StoreChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_store_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_StoreChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IChatMessageStore3, 2598091529, 17221, 20161, 139, 116, 183, 51, 130, 67, 113, 156);
RT_INTERFACE!{interface IChatMessageStore3(IChatMessageStore3Vtbl): IInspectable [IID_IChatMessageStore3] {
    fn GetMessageBySyncIdAsync(&self, syncId: HSTRING, out: *mut <foundation::IAsyncOperation<ChatMessage> as RtType>::Abi) -> HRESULT
}}
impl IChatMessageStore3 {
    #[inline] pub fn get_message_by_sync_id_async(&self, syncId: &HStringArg) -> Result<foundation::IAsyncOperation<ChatMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetMessageBySyncIdAsync)(self.get_abi() as *const _ as *mut _, syncId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IChatMessageStoreChangedEventArgs, 1707503532, 65164, 18132, 145, 25, 87, 184, 65, 3, 17, 213);
RT_INTERFACE!{interface IChatMessageStoreChangedEventArgs(IChatMessageStoreChangedEventArgsVtbl): IInspectable [IID_IChatMessageStoreChangedEventArgs] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Kind(&self, out: *mut ChatStoreChangedEventKind) -> HRESULT
}}
impl IChatMessageStoreChangedEventArgs {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_kind(&self) -> Result<ChatStoreChangedEventKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Kind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatMessageStoreChangedEventArgs: IChatMessageStoreChangedEventArgs}
DEFINE_IID!(IID_IChatMessageTransport, 1672076280, 59059, 23706, 95, 133, 212, 121, 37, 185, 189, 24);
RT_INTERFACE!{interface IChatMessageTransport(IChatMessageTransportVtbl): IInspectable [IID_IChatMessageTransport] {
    fn get_IsAppSetAsNotificationProvider(&self, out: *mut bool) -> HRESULT,
    fn get_IsActive(&self, out: *mut bool) -> HRESULT,
    fn get_TransportFriendlyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TransportId(&self, out: *mut HSTRING) -> HRESULT,
    fn RequestSetAsNotificationProviderAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IChatMessageTransport {
    #[inline] pub fn get_is_app_set_as_notification_provider(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsAppSetAsNotificationProvider)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_active(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsActive)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_transport_friendly_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TransportFriendlyName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_transport_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TransportId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_set_as_notification_provider_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestSetAsNotificationProviderAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatMessageTransport: IChatMessageTransport}
DEFINE_IID!(IID_IChatMessageTransport2, 2426885666, 55370, 19490, 169, 77, 84, 68, 68, 237, 200, 161);
RT_INTERFACE!{interface IChatMessageTransport2(IChatMessageTransport2Vtbl): IInspectable [IID_IChatMessageTransport2] {
    fn get_Configuration(&self, out: *mut <ChatMessageTransportConfiguration as RtType>::Abi) -> HRESULT,
    fn get_TransportKind(&self, out: *mut ChatMessageTransportKind) -> HRESULT
}}
impl IChatMessageTransport2 {
    #[inline] pub fn get_configuration(&self) -> Result<Option<ChatMessageTransportConfiguration>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Configuration)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ChatMessageTransportConfiguration::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_transport_kind(&self) -> Result<ChatMessageTransportKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_TransportKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IChatMessageTransportConfiguration, 2275407653, 6664, 19146, 160, 117, 51, 85, 18, 99, 18, 230);
RT_INTERFACE!{interface IChatMessageTransportConfiguration(IChatMessageTransportConfigurationVtbl): IInspectable [IID_IChatMessageTransportConfiguration] {
    fn get_MaxAttachmentCount(&self, out: *mut i32) -> HRESULT,
    fn get_MaxMessageSizeInKilobytes(&self, out: *mut i32) -> HRESULT,
    fn get_MaxRecipientCount(&self, out: *mut i32) -> HRESULT,
    #[cfg(not(feature="windows-media"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-media")] fn get_SupportedVideoFormat(&self, out: *mut <super::super::media::mediaproperties::MediaEncodingProfile as RtType>::Abi) -> HRESULT,
    fn get_ExtendedProperties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl IChatMessageTransportConfiguration {
    #[inline] pub fn get_max_attachment_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MaxAttachmentCount)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_message_size_in_kilobytes(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MaxMessageSizeInKilobytes)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_recipient_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MaxRecipientCount)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-media")] #[inline] pub fn get_supported_video_format(&self) -> Result<Option<super::super::media::mediaproperties::MediaEncodingProfile>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SupportedVideoFormat)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::media::mediaproperties::MediaEncodingProfile::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ExtendedProperties)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatMessageTransportConfiguration: IChatMessageTransportConfiguration}
RT_ENUM! { enum ChatMessageTransportKind: i32 {
    Text = 0, Untriaged = 1, Blocked = 2, Custom = 3,
}}
DEFINE_IID!(IID_IChatMessageValidationResult, 636041731, 10476, 22665, 86, 155, 126, 72, 107, 18, 111, 24);
RT_INTERFACE!{interface IChatMessageValidationResult(IChatMessageValidationResultVtbl): IInspectable [IID_IChatMessageValidationResult] {
    fn get_MaxPartCount(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_PartCount(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_RemainingCharacterCountInPart(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_Status(&self, out: *mut ChatMessageValidationStatus) -> HRESULT
}}
impl IChatMessageValidationResult {
    #[inline] pub fn get_max_part_count(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxPartCount)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_part_count(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PartCount)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_remaining_character_count_in_part(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RemainingCharacterCountInPart)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<ChatMessageValidationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatMessageValidationResult: IChatMessageValidationResult}
RT_ENUM! { enum ChatMessageValidationStatus: i32 {
    Valid = 0, NoRecipients = 1, InvalidData = 2, MessageTooLarge = 3, TooManyRecipients = 4, TransportInactive = 5, TransportNotFound = 6, TooManyAttachments = 7, InvalidRecipients = 8, InvalidBody = 9, InvalidOther = 10, ValidWithLargeMessage = 11, VoiceRoamingRestriction = 12, DataRoamingRestriction = 13,
}}
DEFINE_IID!(IID_IChatQueryOptions, 802383014, 48950, 17143, 183, 231, 146, 60, 10, 171, 254, 22);
RT_INTERFACE!{interface IChatQueryOptions(IChatQueryOptionsVtbl): IInspectable [IID_IChatQueryOptions] {
    fn get_SearchString(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SearchString(&self, value: HSTRING) -> HRESULT
}}
impl IChatQueryOptions {
    #[inline] pub fn get_search_string(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SearchString)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_search_string(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SearchString)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatQueryOptions: IChatQueryOptions}
impl RtActivatable<IActivationFactory> for ChatQueryOptions {}
DEFINE_CLSID!(ChatQueryOptions(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,104,97,116,46,67,104,97,116,81,117,101,114,121,79,112,116,105,111,110,115,0]) [CLSID_ChatQueryOptions]);
DEFINE_IID!(IID_IChatRecipientDeliveryInfo, 4291277474, 10300, 19466, 138, 14, 140, 51, 189, 191, 5, 69);
RT_INTERFACE!{interface IChatRecipientDeliveryInfo(IChatRecipientDeliveryInfoVtbl): IInspectable [IID_IChatRecipientDeliveryInfo] {
    fn get_TransportAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TransportAddress(&self, value: HSTRING) -> HRESULT,
    fn get_DeliveryTime(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn put_DeliveryTime(&self, value: <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_ReadTime(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn put_ReadTime(&self, value: <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_TransportErrorCodeCategory(&self, out: *mut ChatTransportErrorCodeCategory) -> HRESULT,
    fn get_TransportInterpretedErrorCode(&self, out: *mut ChatTransportInterpretedErrorCode) -> HRESULT,
    fn get_TransportErrorCode(&self, out: *mut i32) -> HRESULT,
    fn get_IsErrorPermanent(&self, out: *mut bool) -> HRESULT,
    fn get_Status(&self, out: *mut ChatMessageStatus) -> HRESULT
}}
impl IChatRecipientDeliveryInfo {
    #[inline] pub fn get_transport_address(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TransportAddress)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_transport_address(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_TransportAddress)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_delivery_time(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DeliveryTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_delivery_time(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DeliveryTime)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_read_time(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ReadTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_read_time(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ReadTime)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_transport_error_code_category(&self) -> Result<ChatTransportErrorCodeCategory> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_TransportErrorCodeCategory)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_transport_interpreted_error_code(&self) -> Result<ChatTransportInterpretedErrorCode> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_TransportInterpretedErrorCode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_transport_error_code(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_TransportErrorCode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_error_permanent(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsErrorPermanent)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<ChatMessageStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatRecipientDeliveryInfo: IChatRecipientDeliveryInfo}
impl RtActivatable<IActivationFactory> for ChatRecipientDeliveryInfo {}
DEFINE_CLSID!(ChatRecipientDeliveryInfo(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,104,97,116,46,67,104,97,116,82,101,99,105,112,105,101,110,116,68,101,108,105,118,101,114,121,73,110,102,111,0]) [CLSID_ChatRecipientDeliveryInfo]);
RT_ENUM! { enum ChatRestoreHistorySpan: i32 {
    LastMonth = 0, LastYear = 1, AnyTime = 2,
}}
DEFINE_IID!(IID_IChatSearchReader, 1181089353, 36896, 18258, 152, 13, 57, 97, 35, 37, 245, 137);
RT_INTERFACE!{interface IChatSearchReader(IChatSearchReaderVtbl): IInspectable [IID_IChatSearchReader] {
    fn ReadBatchAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<IChatItem>> as RtType>::Abi) -> HRESULT,
    fn ReadBatchWithCountAsync(&self, count: i32, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<IChatItem>> as RtType>::Abi) -> HRESULT
}}
impl IChatSearchReader {
    #[inline] pub fn read_batch_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<IChatItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReadBatchAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn read_batch_with_count_async(&self, count: i32) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<IChatItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReadBatchWithCountAsync)(self.get_abi() as *const _ as *mut _, count, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatSearchReader: IChatSearchReader}
RT_ENUM! { enum ChatStoreChangedEventKind: i32 {
    NotificationsMissed = 0, StoreModified = 1, MessageCreated = 2, MessageModified = 3, MessageDeleted = 4, ConversationModified = 5, ConversationDeleted = 6, ConversationTransportDeleted = 7,
}}
DEFINE_IID!(IID_IChatSyncConfiguration, 167274930, 27124, 19199, 130, 182, 6, 153, 47, 244, 2, 210);
RT_INTERFACE!{interface IChatSyncConfiguration(IChatSyncConfigurationVtbl): IInspectable [IID_IChatSyncConfiguration] {
    fn get_IsSyncEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsSyncEnabled(&self, value: bool) -> HRESULT,
    fn get_RestoreHistorySpan(&self, out: *mut ChatRestoreHistorySpan) -> HRESULT,
    fn put_RestoreHistorySpan(&self, value: ChatRestoreHistorySpan) -> HRESULT
}}
impl IChatSyncConfiguration {
    #[inline] pub fn get_is_sync_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsSyncEnabled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_sync_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsSyncEnabled)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_restore_history_span(&self) -> Result<ChatRestoreHistorySpan> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_RestoreHistorySpan)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_restore_history_span(&self, value: ChatRestoreHistorySpan) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RestoreHistorySpan)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatSyncConfiguration: IChatSyncConfiguration}
DEFINE_IID!(IID_IChatSyncManager, 2074422371, 9808, 18543, 180, 180, 107, 217, 211, 214, 60, 132);
RT_INTERFACE!{interface IChatSyncManager(IChatSyncManagerVtbl): IInspectable [IID_IChatSyncManager] {
    fn get_Configuration(&self, out: *mut <ChatSyncConfiguration as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-security")] fn AssociateAccountAsync(&self, webAccount: <super::super::security::credentials::WebAccount as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn UnassociateAccountAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-security")] fn IsAccountAssociated(&self, webAccount: <super::super::security::credentials::WebAccount as RtType>::Abi, out: *mut bool) -> HRESULT,
    fn StartSync(&self) -> HRESULT,
    fn SetConfigurationAsync(&self, configuration: <ChatSyncConfiguration as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IChatSyncManager {
    #[inline] pub fn get_configuration(&self) -> Result<Option<ChatSyncConfiguration>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Configuration)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ChatSyncConfiguration::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn associate_account_async(&self, webAccount: &super::super::security::credentials::WebAccount) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().AssociateAccountAsync)(self.get_abi() as *const _ as *mut _, webAccount.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn unassociate_account_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().UnassociateAccountAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn is_account_associated(&self, webAccount: &super::super::security::credentials::WebAccount) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().IsAccountAssociated)(self.get_abi() as *const _ as *mut _, webAccount.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn start_sync(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().StartSync)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_configuration_async(&self, configuration: &ChatSyncConfiguration) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SetConfigurationAsync)(self.get_abi() as *const _ as *mut _, configuration.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ChatSyncManager: IChatSyncManager}
RT_ENUM! { enum ChatTransportErrorCodeCategory: i32 {
    None = 0, Http = 1, Network = 2, MmsServer = 3,
}}
RT_ENUM! { enum ChatTransportInterpretedErrorCode: i32 {
    None = 0, Unknown = 1, InvalidRecipientAddress = 2, NetworkConnectivity = 3, ServiceDenied = 4, Timeout = 5,
}}
DEFINE_IID!(IID_IRcsEndUserMessage, 3620578795, 52183, 20283, 133, 38, 181, 6, 222, 195, 92, 83);
RT_INTERFACE!{interface IRcsEndUserMessage(IRcsEndUserMessageVtbl): IInspectable [IID_IRcsEndUserMessage] {
    fn get_TransportId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsPinRequired(&self, out: *mut bool) -> HRESULT,
    fn get_Actions(&self, out: *mut <foundation::collections::IVectorView<RcsEndUserMessageAction> as RtType>::Abi) -> HRESULT,
    fn SendResponseAsync(&self, action: <RcsEndUserMessageAction as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn SendResponseWithPinAsync(&self, action: <RcsEndUserMessageAction as RtType>::Abi, pin: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IRcsEndUserMessage {
    #[inline] pub fn get_transport_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TransportId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Title)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Text)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_pin_required(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsPinRequired)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_actions(&self) -> Result<Option<foundation::collections::IVectorView<RcsEndUserMessageAction>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Actions)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn send_response_async(&self, action: &RcsEndUserMessageAction) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SendResponseAsync)(self.get_abi() as *const _ as *mut _, action.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn send_response_with_pin_async(&self, action: &RcsEndUserMessageAction, pin: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SendResponseWithPinAsync)(self.get_abi() as *const _ as *mut _, action.get_abi() as *const _ as *mut _, pin.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RcsEndUserMessage: IRcsEndUserMessage}
DEFINE_IID!(IID_IRcsEndUserMessageAction, 2453112631, 39746, 18131, 157, 94, 60, 27, 45, 174, 124, 184);
RT_INTERFACE!{interface IRcsEndUserMessageAction(IRcsEndUserMessageActionVtbl): IInspectable [IID_IRcsEndUserMessageAction] {
    fn get_Label(&self, out: *mut HSTRING) -> HRESULT
}}
impl IRcsEndUserMessageAction {
    #[inline] pub fn get_label(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Label)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RcsEndUserMessageAction: IRcsEndUserMessageAction}
DEFINE_IID!(IID_IRcsEndUserMessageAvailableEventArgs, 759541249, 16265, 16874, 151, 2, 158, 158, 212, 17, 170, 152);
RT_INTERFACE!{interface IRcsEndUserMessageAvailableEventArgs(IRcsEndUserMessageAvailableEventArgsVtbl): IInspectable [IID_IRcsEndUserMessageAvailableEventArgs] {
    fn get_IsMessageAvailable(&self, out: *mut bool) -> HRESULT,
    fn get_Message(&self, out: *mut <RcsEndUserMessage as RtType>::Abi) -> HRESULT
}}
impl IRcsEndUserMessageAvailableEventArgs {
    #[inline] pub fn get_is_message_available(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsMessageAvailable)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_message(&self) -> Result<Option<RcsEndUserMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Message)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(RcsEndUserMessage::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RcsEndUserMessageAvailableEventArgs: IRcsEndUserMessageAvailableEventArgs}
DEFINE_IID!(IID_IRcsEndUserMessageAvailableTriggerDetails, 1536652333, 13599, 18066, 180, 30, 27, 3, 93, 193, 137, 134);
RT_INTERFACE!{interface IRcsEndUserMessageAvailableTriggerDetails(IRcsEndUserMessageAvailableTriggerDetailsVtbl): IInspectable [IID_IRcsEndUserMessageAvailableTriggerDetails] {
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT
}}
impl IRcsEndUserMessageAvailableTriggerDetails {
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Title)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Text)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RcsEndUserMessageAvailableTriggerDetails: IRcsEndUserMessageAvailableTriggerDetails}
DEFINE_IID!(IID_IRcsEndUserMessageManager, 810856026, 19743, 19289, 148, 51, 18, 108, 115, 78, 134, 166);
RT_INTERFACE!{interface IRcsEndUserMessageManager(IRcsEndUserMessageManagerVtbl): IInspectable [IID_IRcsEndUserMessageManager] {
    fn add_MessageAvailableChanged(&self, handler: <foundation::TypedEventHandler<RcsEndUserMessageManager, RcsEndUserMessageAvailableEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MessageAvailableChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IRcsEndUserMessageManager {
    #[inline] pub fn add_message_available_changed(&self, handler: &foundation::TypedEventHandler<RcsEndUserMessageManager, RcsEndUserMessageAvailableEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_MessageAvailableChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_message_available_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_MessageAvailableChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class RcsEndUserMessageManager: IRcsEndUserMessageManager}
RT_CLASS!{static class RcsManager}
impl RtActivatable<IRcsManagerStatics> for RcsManager {}
impl RtActivatable<IRcsManagerStatics2> for RcsManager {}
impl RcsManager {
    #[inline] pub fn get_end_user_message_manager() -> Result<Option<RcsEndUserMessageManager>> {
        <Self as RtActivatable<IRcsManagerStatics>>::get_activation_factory().get_end_user_message_manager()
    }
    #[inline] pub fn get_transports_async() -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<RcsTransport>>> {
        <Self as RtActivatable<IRcsManagerStatics>>::get_activation_factory().get_transports_async()
    }
    #[inline] pub fn get_transport_async(transportId: &HStringArg) -> Result<foundation::IAsyncOperation<RcsTransport>> {
        <Self as RtActivatable<IRcsManagerStatics>>::get_activation_factory().get_transport_async(transportId)
    }
    #[inline] pub fn leave_conversation_async(conversation: &ChatConversation) -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<IRcsManagerStatics>>::get_activation_factory().leave_conversation_async(conversation)
    }
    #[inline] pub fn add_transport_list_changed(handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IRcsManagerStatics2>>::get_activation_factory().add_transport_list_changed(handler)
    }
    #[inline] pub fn remove_transport_list_changed(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IRcsManagerStatics2>>::get_activation_factory().remove_transport_list_changed(token)
    }
}
DEFINE_CLSID!(RcsManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,104,97,116,46,82,99,115,77,97,110,97,103,101,114,0]) [CLSID_RcsManager]);
DEFINE_IID!(IID_IRcsManagerStatics, 2099710661, 2749, 20273, 155, 153, 165, 158, 113, 167, 183, 49);
RT_INTERFACE!{static interface IRcsManagerStatics(IRcsManagerStaticsVtbl): IInspectable [IID_IRcsManagerStatics] {
    fn GetEndUserMessageManager(&self, out: *mut <RcsEndUserMessageManager as RtType>::Abi) -> HRESULT,
    fn GetTransportsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<RcsTransport>> as RtType>::Abi) -> HRESULT,
    fn GetTransportAsync(&self, transportId: HSTRING, out: *mut <foundation::IAsyncOperation<RcsTransport> as RtType>::Abi) -> HRESULT,
    fn LeaveConversationAsync(&self, conversation: <ChatConversation as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IRcsManagerStatics {
    #[inline] pub fn get_end_user_message_manager(&self) -> Result<Option<RcsEndUserMessageManager>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetEndUserMessageManager)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(RcsEndUserMessageManager::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_transports_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<RcsTransport>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetTransportsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_transport_async(&self, transportId: &HStringArg) -> Result<foundation::IAsyncOperation<RcsTransport>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetTransportAsync)(self.get_abi() as *const _ as *mut _, transportId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn leave_conversation_async(&self, conversation: &ChatConversation) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().LeaveConversationAsync)(self.get_abi() as *const _ as *mut _, conversation.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRcsManagerStatics2, 3444157720, 44426, 17066, 142, 235, 167, 152, 168, 128, 137, 89);
RT_INTERFACE!{static interface IRcsManagerStatics2(IRcsManagerStatics2Vtbl): IInspectable [IID_IRcsManagerStatics2] {
    fn add_TransportListChanged(&self, handler: <foundation::EventHandler<IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TransportListChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IRcsManagerStatics2 {
    #[inline] pub fn add_transport_list_changed(&self, handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_TransportListChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_transport_list_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_TransportListChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum RcsServiceKind: i32 {
    Chat = 0, GroupChat = 1, FileTransfer = 2, Capability = 3,
}}
DEFINE_IID!(IID_IRcsServiceKindSupportedChangedEventArgs, 4101939780, 59267, 18534, 179, 167, 78, 92, 207, 2, 48, 112);
RT_INTERFACE!{interface IRcsServiceKindSupportedChangedEventArgs(IRcsServiceKindSupportedChangedEventArgsVtbl): IInspectable [IID_IRcsServiceKindSupportedChangedEventArgs] {
    fn get_ServiceKind(&self, out: *mut RcsServiceKind) -> HRESULT
}}
impl IRcsServiceKindSupportedChangedEventArgs {
    #[inline] pub fn get_service_kind(&self) -> Result<RcsServiceKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ServiceKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class RcsServiceKindSupportedChangedEventArgs: IRcsServiceKindSupportedChangedEventArgs}
DEFINE_IID!(IID_IRcsTransport, 4272113497, 62332, 17177, 133, 70, 236, 132, 210, 29, 48, 255);
RT_INTERFACE!{interface IRcsTransport(IRcsTransportVtbl): IInspectable [IID_IRcsTransport] {
    fn get_ExtendedProperties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT,
    fn get_IsActive(&self, out: *mut bool) -> HRESULT,
    fn get_TransportFriendlyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TransportId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Configuration(&self, out: *mut <RcsTransportConfiguration as RtType>::Abi) -> HRESULT,
    fn IsStoreAndForwardEnabled(&self, serviceKind: RcsServiceKind, out: *mut bool) -> HRESULT,
    fn IsServiceKindSupported(&self, serviceKind: RcsServiceKind, out: *mut bool) -> HRESULT,
    fn add_ServiceKindSupportedChanged(&self, handler: <foundation::TypedEventHandler<RcsTransport, RcsServiceKindSupportedChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ServiceKindSupportedChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IRcsTransport {
    #[inline] pub fn get_extended_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ExtendedProperties)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_active(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsActive)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_transport_friendly_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TransportFriendlyName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_transport_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TransportId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_configuration(&self) -> Result<Option<RcsTransportConfiguration>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Configuration)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(RcsTransportConfiguration::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_store_and_forward_enabled(&self, serviceKind: RcsServiceKind) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().IsStoreAndForwardEnabled)(self.get_abi() as *const _ as *mut _, serviceKind, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_service_kind_supported(&self, serviceKind: RcsServiceKind) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().IsServiceKindSupported)(self.get_abi() as *const _ as *mut _, serviceKind, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_service_kind_supported_changed(&self, handler: &foundation::TypedEventHandler<RcsTransport, RcsServiceKindSupportedChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_ServiceKindSupportedChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_service_kind_supported_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_ServiceKindSupportedChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class RcsTransport: IRcsTransport}
DEFINE_IID!(IID_IRcsTransportConfiguration, 533508354, 9330, 19385, 153, 136, 193, 33, 28, 131, 232, 169);
RT_INTERFACE!{interface IRcsTransportConfiguration(IRcsTransportConfigurationVtbl): IInspectable [IID_IRcsTransportConfiguration] {
    fn get_MaxAttachmentCount(&self, out: *mut i32) -> HRESULT,
    fn get_MaxMessageSizeInKilobytes(&self, out: *mut i32) -> HRESULT,
    fn get_MaxGroupMessageSizeInKilobytes(&self, out: *mut i32) -> HRESULT,
    fn get_MaxRecipientCount(&self, out: *mut i32) -> HRESULT,
    fn get_MaxFileSizeInKilobytes(&self, out: *mut i32) -> HRESULT,
    fn get_WarningFileSizeInKilobytes(&self, out: *mut i32) -> HRESULT
}}
impl IRcsTransportConfiguration {
    #[inline] pub fn get_max_attachment_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MaxAttachmentCount)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_message_size_in_kilobytes(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MaxMessageSizeInKilobytes)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_group_message_size_in_kilobytes(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MaxGroupMessageSizeInKilobytes)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_recipient_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MaxRecipientCount)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_file_size_in_kilobytes(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MaxFileSizeInKilobytes)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_warning_file_size_in_kilobytes(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_WarningFileSizeInKilobytes)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class RcsTransportConfiguration: IRcsTransportConfiguration}
DEFINE_IID!(IID_IRemoteParticipantComposingChangedEventArgs, 515917223, 53193, 17865, 152, 118, 68, 159, 43, 193, 128, 245);
RT_INTERFACE!{interface IRemoteParticipantComposingChangedEventArgs(IRemoteParticipantComposingChangedEventArgsVtbl): IInspectable [IID_IRemoteParticipantComposingChangedEventArgs] {
    fn get_TransportId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ParticipantAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsComposing(&self, out: *mut bool) -> HRESULT
}}
impl IRemoteParticipantComposingChangedEventArgs {
    #[inline] pub fn get_transport_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TransportId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_participant_address(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ParticipantAddress)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_composing(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsComposing)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class RemoteParticipantComposingChangedEventArgs: IRemoteParticipantComposingChangedEventArgs}
} // Windows.ApplicationModel.Chat
pub mod communicationblocking { // Windows.ApplicationModel.CommunicationBlocking
use crate::prelude::*;
RT_CLASS!{static class CommunicationBlockingAccessManager}
impl RtActivatable<ICommunicationBlockingAccessManagerStatics> for CommunicationBlockingAccessManager {}
impl CommunicationBlockingAccessManager {
    #[inline] pub fn get_is_blocking_active() -> Result<bool> {
        <Self as RtActivatable<ICommunicationBlockingAccessManagerStatics>>::get_activation_factory().get_is_blocking_active()
    }
    #[inline] pub fn is_blocked_number_async(number: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> {
        <Self as RtActivatable<ICommunicationBlockingAccessManagerStatics>>::get_activation_factory().is_blocked_number_async(number)
    }
    #[inline] pub fn show_block_numbers_ui(phoneNumbers: &foundation::collections::IIterable<HString>) -> Result<bool> {
        <Self as RtActivatable<ICommunicationBlockingAccessManagerStatics>>::get_activation_factory().show_block_numbers_ui(phoneNumbers)
    }
    #[inline] pub fn show_unblock_numbers_ui(phoneNumbers: &foundation::collections::IIterable<HString>) -> Result<bool> {
        <Self as RtActivatable<ICommunicationBlockingAccessManagerStatics>>::get_activation_factory().show_unblock_numbers_ui(phoneNumbers)
    }
    #[inline] pub fn show_blocked_calls_ui() -> Result<()> {
        <Self as RtActivatable<ICommunicationBlockingAccessManagerStatics>>::get_activation_factory().show_blocked_calls_ui()
    }
    #[inline] pub fn show_blocked_messages_ui() -> Result<()> {
        <Self as RtActivatable<ICommunicationBlockingAccessManagerStatics>>::get_activation_factory().show_blocked_messages_ui()
    }
}
DEFINE_CLSID!(CommunicationBlockingAccessManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,109,109,117,110,105,99,97,116,105,111,110,66,108,111,99,107,105,110,103,46,67,111,109,109,117,110,105,99,97,116,105,111,110,66,108,111,99,107,105,110,103,65,99,99,101,115,115,77,97,110,97,103,101,114,0]) [CLSID_CommunicationBlockingAccessManager]);
DEFINE_IID!(IID_ICommunicationBlockingAccessManagerStatics, 479631768, 40234, 23991, 237, 213, 12, 228, 7, 252, 37, 149);
RT_INTERFACE!{static interface ICommunicationBlockingAccessManagerStatics(ICommunicationBlockingAccessManagerStaticsVtbl): IInspectable [IID_ICommunicationBlockingAccessManagerStatics] {
    fn get_IsBlockingActive(&self, out: *mut bool) -> HRESULT,
    fn IsBlockedNumberAsync(&self, number: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn ShowBlockNumbersUI(&self, phoneNumbers: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut bool) -> HRESULT,
    fn ShowUnblockNumbersUI(&self, phoneNumbers: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut bool) -> HRESULT,
    fn ShowBlockedCallsUI(&self) -> HRESULT,
    fn ShowBlockedMessagesUI(&self) -> HRESULT
}}
impl ICommunicationBlockingAccessManagerStatics {
    #[inline] pub fn get_is_blocking_active(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsBlockingActive)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_blocked_number_async(&self, number: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().IsBlockedNumberAsync)(self.get_abi() as *const _ as *mut _, number.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_block_numbers_ui(&self, phoneNumbers: &foundation::collections::IIterable<HString>) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().ShowBlockNumbersUI)(self.get_abi() as *const _ as *mut _, phoneNumbers.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn show_unblock_numbers_ui(&self, phoneNumbers: &foundation::collections::IIterable<HString>) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().ShowUnblockNumbersUI)(self.get_abi() as *const _ as *mut _, phoneNumbers.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn show_blocked_calls_ui(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ShowBlockedCallsUI)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn show_blocked_messages_ui(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ShowBlockedMessagesUI)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{static class CommunicationBlockingAppManager}
impl RtActivatable<ICommunicationBlockingAppManagerStatics> for CommunicationBlockingAppManager {}
impl RtActivatable<ICommunicationBlockingAppManagerStatics2> for CommunicationBlockingAppManager {}
impl CommunicationBlockingAppManager {
    #[inline] pub fn get_is_current_app_active_blocking_app() -> Result<bool> {
        <Self as RtActivatable<ICommunicationBlockingAppManagerStatics>>::get_activation_factory().get_is_current_app_active_blocking_app()
    }
    #[inline] pub fn show_communication_blocking_settings_ui() -> Result<()> {
        <Self as RtActivatable<ICommunicationBlockingAppManagerStatics>>::get_activation_factory().show_communication_blocking_settings_ui()
    }
    #[inline] pub fn request_set_as_active_blocking_app_async() -> Result<foundation::IAsyncOperation<bool>> {
        <Self as RtActivatable<ICommunicationBlockingAppManagerStatics2>>::get_activation_factory().request_set_as_active_blocking_app_async()
    }
}
DEFINE_CLSID!(CommunicationBlockingAppManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,109,109,117,110,105,99,97,116,105,111,110,66,108,111,99,107,105,110,103,46,67,111,109,109,117,110,105,99,97,116,105,111,110,66,108,111,99,107,105,110,103,65,112,112,77,97,110,97,103,101,114,0]) [CLSID_CommunicationBlockingAppManager]);
DEFINE_IID!(IID_ICommunicationBlockingAppManagerStatics, 2010863852, 5286, 19370, 148, 42, 106, 103, 61, 153, 155, 242);
RT_INTERFACE!{static interface ICommunicationBlockingAppManagerStatics(ICommunicationBlockingAppManagerStaticsVtbl): IInspectable [IID_ICommunicationBlockingAppManagerStatics] {
    fn get_IsCurrentAppActiveBlockingApp(&self, out: *mut bool) -> HRESULT,
    fn ShowCommunicationBlockingSettingsUI(&self) -> HRESULT
}}
impl ICommunicationBlockingAppManagerStatics {
    #[inline] pub fn get_is_current_app_active_blocking_app(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsCurrentAppActiveBlockingApp)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn show_communication_blocking_settings_ui(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ShowCommunicationBlockingSettingsUI)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICommunicationBlockingAppManagerStatics2, 346459869, 60808, 17786, 163, 100, 163, 99, 77, 111, 22, 109);
RT_INTERFACE!{static interface ICommunicationBlockingAppManagerStatics2(ICommunicationBlockingAppManagerStatics2Vtbl): IInspectable [IID_ICommunicationBlockingAppManagerStatics2] {
    fn RequestSetAsActiveBlockingAppAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl ICommunicationBlockingAppManagerStatics2 {
    #[inline] pub fn request_set_as_active_blocking_app_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestSetAsActiveBlockingAppAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
} // Windows.ApplicationModel.CommunicationBlocking
pub mod contacts { // Windows.ApplicationModel.Contacts
use crate::prelude::*;
DEFINE_IID!(IID_IAggregateContactManager, 58316253, 56154, 20435, 181, 78, 77, 241, 121, 23, 162, 18);
RT_INTERFACE!{interface IAggregateContactManager(IAggregateContactManagerVtbl): IInspectable [IID_IAggregateContactManager] {
    fn FindRawContactsAsync(&self, contact: <Contact as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<Contact>> as RtType>::Abi) -> HRESULT,
    fn TryLinkContactsAsync(&self, primaryContact: <Contact as RtType>::Abi, secondaryContact: <Contact as RtType>::Abi, out: *mut <foundation::IAsyncOperation<Contact> as RtType>::Abi) -> HRESULT,
    fn UnlinkRawContactAsync(&self, contact: <Contact as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn TrySetPreferredSourceForPictureAsync(&self, aggregateContact: <Contact as RtType>::Abi, rawContact: <Contact as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl IAggregateContactManager {
    #[inline] pub fn find_raw_contacts_async(&self, contact: &Contact) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<Contact>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindRawContactsAsync)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_link_contacts_async(&self, primaryContact: &Contact, secondaryContact: &Contact) -> Result<foundation::IAsyncOperation<Contact>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryLinkContactsAsync)(self.get_abi() as *const _ as *mut _, primaryContact.get_abi() as *const _ as *mut _, secondaryContact.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn unlink_raw_contact_async(&self, contact: &Contact) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().UnlinkRawContactAsync)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_set_preferred_source_for_picture_async(&self, aggregateContact: &Contact, rawContact: &Contact) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TrySetPreferredSourceForPictureAsync)(self.get_abi() as *const _ as *mut _, aggregateContact.get_abi() as *const _ as *mut _, rawContact.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AggregateContactManager: IAggregateContactManager}
DEFINE_IID!(IID_IAggregateContactManager2, 1586283224, 43469, 17456, 156, 75, 1, 52, 141, 178, 202, 80);
RT_INTERFACE!{interface IAggregateContactManager2(IAggregateContactManager2Vtbl): IInspectable [IID_IAggregateContactManager2] {
    fn SetRemoteIdentificationInformationAsync(&self, contactListId: HSTRING, remoteSourceId: HSTRING, accountId: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IAggregateContactManager2 {
    #[inline] pub fn set_remote_identification_information_async(&self, contactListId: &HStringArg, remoteSourceId: &HStringArg, accountId: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SetRemoteIdentificationInformationAsync)(self.get_abi() as *const _ as *mut _, contactListId.get(), remoteSourceId.get(), accountId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContact, 3959452403, 8472, 16457, 158, 188, 23, 240, 171, 105, 43, 100);
RT_INTERFACE!{interface IContact(IContactVtbl): IInspectable [IID_IContact] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Thumbnail(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Thumbnail(&self, value: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    fn get_Fields(&self, out: *mut <foundation::collections::IVector<IContactField> as RtType>::Abi) -> HRESULT
}}
impl IContact {
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Name)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Name)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_thumbnail(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Thumbnail)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_thumbnail(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Thumbnail)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_fields(&self) -> Result<Option<foundation::collections::IVector<IContactField>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Fields)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class Contact: IContact}
impl RtActivatable<IActivationFactory> for Contact {}
DEFINE_CLSID!(Contact(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,110,116,97,99,116,115,46,67,111,110,116,97,99,116,0]) [CLSID_Contact]);
DEFINE_IID!(IID_IContact2, 4078105445, 47991, 19604, 128, 45, 131, 40, 206, 228, 12, 8);
RT_INTERFACE!{interface IContact2(IContact2Vtbl): IInspectable [IID_IContact2] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Id(&self, value: HSTRING) -> HRESULT,
    fn get_Notes(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Notes(&self, value: HSTRING) -> HRESULT,
    fn get_Phones(&self, out: *mut <foundation::collections::IVector<ContactPhone> as RtType>::Abi) -> HRESULT,
    fn get_Emails(&self, out: *mut <foundation::collections::IVector<ContactEmail> as RtType>::Abi) -> HRESULT,
    fn get_Addresses(&self, out: *mut <foundation::collections::IVector<ContactAddress> as RtType>::Abi) -> HRESULT,
    fn get_ConnectedServiceAccounts(&self, out: *mut <foundation::collections::IVector<ContactConnectedServiceAccount> as RtType>::Abi) -> HRESULT,
    fn get_ImportantDates(&self, out: *mut <foundation::collections::IVector<ContactDate> as RtType>::Abi) -> HRESULT,
    fn get_DataSuppliers(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT,
    fn get_JobInfo(&self, out: *mut <foundation::collections::IVector<ContactJobInfo> as RtType>::Abi) -> HRESULT,
    fn get_SignificantOthers(&self, out: *mut <foundation::collections::IVector<ContactSignificantOther> as RtType>::Abi) -> HRESULT,
    fn get_Websites(&self, out: *mut <foundation::collections::IVector<ContactWebsite> as RtType>::Abi) -> HRESULT,
    fn get_ProviderProperties(&self, out: *mut <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT
}}
impl IContact2 {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Id)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_notes(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Notes)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_notes(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Notes)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_phones(&self) -> Result<Option<foundation::collections::IVector<ContactPhone>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Phones)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_emails(&self) -> Result<Option<foundation::collections::IVector<ContactEmail>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Emails)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_addresses(&self) -> Result<Option<foundation::collections::IVector<ContactAddress>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Addresses)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connected_service_accounts(&self) -> Result<Option<foundation::collections::IVector<ContactConnectedServiceAccount>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ConnectedServiceAccounts)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_important_dates(&self) -> Result<Option<foundation::collections::IVector<ContactDate>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ImportantDates)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_data_suppliers(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DataSuppliers)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_job_info(&self) -> Result<Option<foundation::collections::IVector<ContactJobInfo>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_JobInfo)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_significant_others(&self) -> Result<Option<foundation::collections::IVector<ContactSignificantOther>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SignificantOthers)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_websites(&self) -> Result<Option<foundation::collections::IVector<ContactWebsite>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Websites)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_provider_properties(&self) -> Result<Option<foundation::collections::IPropertySet>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ProviderProperties)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IPropertySet::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContact3, 1210064487, 57486, 17060, 181, 97, 65, 208, 140, 169, 87, 93);
RT_INTERFACE!{interface IContact3(IContact3Vtbl): IInspectable [IID_IContact3] {
    fn get_ContactListId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayPictureUserUpdateTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn put_DisplayPictureUserUpdateTime(&self, value: foundation::DateTime) -> HRESULT,
    fn get_IsMe(&self, out: *mut bool) -> HRESULT,
    fn get_AggregateId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RemoteId(&self, value: HSTRING) -> HRESULT,
    fn get_RingToneToken(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RingToneToken(&self, value: HSTRING) -> HRESULT,
    fn get_IsDisplayPictureManuallySet(&self, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy10(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_LargeDisplayPicture(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy11(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_SmallDisplayPicture(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy12(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_SourceDisplayPicture(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy13(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_SourceDisplayPicture(&self, value: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    fn get_TextToneToken(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TextToneToken(&self, value: HSTRING) -> HRESULT,
    fn get_IsAggregate(&self, out: *mut bool) -> HRESULT,
    fn get_FullName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayNameOverride(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayNameOverride(&self, value: HSTRING) -> HRESULT,
    fn get_Nickname(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Nickname(&self, value: HSTRING) -> HRESULT,
    fn get_SortName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IContact3 {
    #[inline] pub fn get_contact_list_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContactListId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_picture_user_update_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DisplayPictureUserUpdateTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_display_picture_user_update_time(&self, value: foundation::DateTime) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayPictureUserUpdateTime)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_me(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsMe)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_aggregate_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AggregateId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_remote_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RemoteId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_remote_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RemoteId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_ring_tone_token(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RingToneToken)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_ring_tone_token(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RingToneToken)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_display_picture_manually_set(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsDisplayPictureManuallySet)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_large_display_picture(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LargeDisplayPicture)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_small_display_picture(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SmallDisplayPicture)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_source_display_picture(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SourceDisplayPicture)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_source_display_picture(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SourceDisplayPicture)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_text_tone_token(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TextToneToken)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_text_tone_token(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_TextToneToken)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_aggregate(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsAggregate)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_full_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_FullName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name_override(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayNameOverride)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_name_override(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayNameOverride)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_nickname(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Nickname)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_nickname(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Nickname)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sort_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SortName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContactAddress, 2537149338, 17102, 18546, 141, 112, 48, 99, 170, 88, 75, 112);
RT_INTERFACE!{interface IContactAddress(IContactAddressVtbl): IInspectable [IID_IContactAddress] {
    fn get_StreetAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn put_StreetAddress(&self, value: HSTRING) -> HRESULT,
    fn get_Locality(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Locality(&self, value: HSTRING) -> HRESULT,
    fn get_Region(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Region(&self, value: HSTRING) -> HRESULT,
    fn get_Country(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Country(&self, value: HSTRING) -> HRESULT,
    fn get_PostalCode(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PostalCode(&self, value: HSTRING) -> HRESULT,
    fn get_Kind(&self, out: *mut ContactAddressKind) -> HRESULT,
    fn put_Kind(&self, value: ContactAddressKind) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT
}}
impl IContactAddress {
    #[inline] pub fn get_street_address(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_StreetAddress)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_street_address(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_StreetAddress)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_locality(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Locality)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_locality(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Locality)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_region(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Region)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_region(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Region)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_country(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Country)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_country(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Country)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_postal_code(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PostalCode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_postal_code(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_PostalCode)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_kind(&self) -> Result<ContactAddressKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Kind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_kind(&self, value: ContactAddressKind) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Kind)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Description)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_description(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Description)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactAddress: IContactAddress}
impl RtActivatable<IActivationFactory> for ContactAddress {}
DEFINE_CLSID!(ContactAddress(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,110,116,97,99,116,115,46,67,111,110,116,97,99,116,65,100,100,114,101,115,115,0]) [CLSID_ContactAddress]);
RT_ENUM! { enum ContactAddressKind: i32 {
    Home = 0, Work = 1, Other = 2,
}}
DEFINE_IID!(IID_IContactAnnotation, 2183119599, 32065, 17570, 132, 195, 96, 162, 129, 221, 123, 134);
RT_INTERFACE!{interface IContactAnnotation(IContactAnnotationVtbl): IInspectable [IID_IContactAnnotation] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AnnotationListId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ContactId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ContactId(&self, value: HSTRING) -> HRESULT,
    fn get_RemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RemoteId(&self, value: HSTRING) -> HRESULT,
    fn get_SupportedOperations(&self, out: *mut ContactAnnotationOperations) -> HRESULT,
    fn put_SupportedOperations(&self, value: ContactAnnotationOperations) -> HRESULT,
    fn get_IsDisabled(&self, out: *mut bool) -> HRESULT,
    fn get_ProviderProperties(&self, out: *mut <foundation::collections::ValueSet as RtType>::Abi) -> HRESULT
}}
impl IContactAnnotation {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_annotation_list_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AnnotationListId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_contact_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContactId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_contact_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ContactId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_remote_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RemoteId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_remote_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RemoteId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_operations(&self) -> Result<ContactAnnotationOperations> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SupportedOperations)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_supported_operations(&self, value: ContactAnnotationOperations) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SupportedOperations)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_disabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsDisabled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_provider_properties(&self) -> Result<Option<foundation::collections::ValueSet>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ProviderProperties)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::ValueSet::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactAnnotation: IContactAnnotation}
impl RtActivatable<IActivationFactory> for ContactAnnotation {}
DEFINE_CLSID!(ContactAnnotation(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,110,116,97,99,116,115,46,67,111,110,116,97,99,116,65,110,110,111,116,97,116,105,111,110,0]) [CLSID_ContactAnnotation]);
DEFINE_IID!(IID_IContactAnnotation2, 3063016691, 19127, 18975, 153, 65, 12, 156, 243, 23, 27, 117);
RT_INTERFACE!{interface IContactAnnotation2(IContactAnnotation2Vtbl): IInspectable [IID_IContactAnnotation2] {
    fn get_ContactListId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ContactListId(&self, value: HSTRING) -> HRESULT
}}
impl IContactAnnotation2 {
    #[inline] pub fn get_contact_list_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContactListId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_contact_list_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ContactListId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContactAnnotationList, 2460255914, 23688, 17849, 170, 208, 70, 24, 136, 230, 141, 138);
RT_INTERFACE!{interface IContactAnnotationList(IContactAnnotationListVtbl): IInspectable [IID_IContactAnnotationList] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ProviderPackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_UserDataAccountId(&self, out: *mut HSTRING) -> HRESULT,
    fn DeleteAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn TrySaveAnnotationAsync(&self, annotation: <ContactAnnotation as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn GetAnnotationAsync(&self, annotationId: HSTRING, out: *mut <foundation::IAsyncOperation<ContactAnnotation> as RtType>::Abi) -> HRESULT,
    fn FindAnnotationsByRemoteIdAsync(&self, remoteId: HSTRING, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<ContactAnnotation>> as RtType>::Abi) -> HRESULT,
    fn FindAnnotationsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<ContactAnnotation>> as RtType>::Abi) -> HRESULT,
    fn DeleteAnnotationAsync(&self, annotation: <ContactAnnotation as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IContactAnnotationList {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_provider_package_family_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ProviderPackageFamilyName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_user_data_account_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_UserDataAccountId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_save_annotation_async(&self, annotation: &ContactAnnotation) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TrySaveAnnotationAsync)(self.get_abi() as *const _ as *mut _, annotation.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_annotation_async(&self, annotationId: &HStringArg) -> Result<foundation::IAsyncOperation<ContactAnnotation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetAnnotationAsync)(self.get_abi() as *const _ as *mut _, annotationId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_annotations_by_remote_id_async(&self, remoteId: &HStringArg) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<ContactAnnotation>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindAnnotationsByRemoteIdAsync)(self.get_abi() as *const _ as *mut _, remoteId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_annotations_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<ContactAnnotation>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindAnnotationsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_annotation_async(&self, annotation: &ContactAnnotation) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteAnnotationAsync)(self.get_abi() as *const _ as *mut _, annotation.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactAnnotationList: IContactAnnotationList}
RT_ENUM! { enum ContactAnnotationOperations: u32 {
    None = 0, ContactProfile = 1, Message = 2, AudioCall = 4, VideoCall = 8, SocialFeeds = 16, Share = 32,
}}
DEFINE_IID!(IID_IContactAnnotationStore, 598537386, 31351, 17789, 130, 3, 152, 127, 75, 49, 175, 9);
RT_INTERFACE!{interface IContactAnnotationStore(IContactAnnotationStoreVtbl): IInspectable [IID_IContactAnnotationStore] {
    fn FindContactIdsByEmailAsync(&self, emailAddress: HSTRING, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<HString>> as RtType>::Abi) -> HRESULT,
    fn FindContactIdsByPhoneNumberAsync(&self, phoneNumber: HSTRING, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<HString>> as RtType>::Abi) -> HRESULT,
    fn FindAnnotationsForContactAsync(&self, contact: <Contact as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<ContactAnnotation>> as RtType>::Abi) -> HRESULT,
    fn DisableAnnotationAsync(&self, annotation: <ContactAnnotation as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn CreateAnnotationListAsync(&self, out: *mut <foundation::IAsyncOperation<ContactAnnotationList> as RtType>::Abi) -> HRESULT,
    fn CreateAnnotationListInAccountAsync(&self, userDataAccountId: HSTRING, out: *mut <foundation::IAsyncOperation<ContactAnnotationList> as RtType>::Abi) -> HRESULT,
    fn GetAnnotationListAsync(&self, annotationListId: HSTRING, out: *mut <foundation::IAsyncOperation<ContactAnnotationList> as RtType>::Abi) -> HRESULT,
    fn FindAnnotationListsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<ContactAnnotationList>> as RtType>::Abi) -> HRESULT
}}
impl IContactAnnotationStore {
    #[inline] pub fn find_contact_ids_by_email_async(&self, emailAddress: &HStringArg) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindContactIdsByEmailAsync)(self.get_abi() as *const _ as *mut _, emailAddress.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_contact_ids_by_phone_number_async(&self, phoneNumber: &HStringArg) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindContactIdsByPhoneNumberAsync)(self.get_abi() as *const _ as *mut _, phoneNumber.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_annotations_for_contact_async(&self, contact: &Contact) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<ContactAnnotation>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindAnnotationsForContactAsync)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn disable_annotation_async(&self, annotation: &ContactAnnotation) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DisableAnnotationAsync)(self.get_abi() as *const _ as *mut _, annotation.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_annotation_list_async(&self) -> Result<foundation::IAsyncOperation<ContactAnnotationList>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateAnnotationListAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_annotation_list_in_account_async(&self, userDataAccountId: &HStringArg) -> Result<foundation::IAsyncOperation<ContactAnnotationList>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateAnnotationListInAccountAsync)(self.get_abi() as *const _ as *mut _, userDataAccountId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_annotation_list_async(&self, annotationListId: &HStringArg) -> Result<foundation::IAsyncOperation<ContactAnnotationList>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetAnnotationListAsync)(self.get_abi() as *const _ as *mut _, annotationListId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_annotation_lists_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<ContactAnnotationList>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindAnnotationListsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactAnnotationStore: IContactAnnotationStore}
DEFINE_IID!(IID_IContactAnnotationStore2, 2128487421, 25063, 18791, 142, 197, 189, 242, 128, 162, 64, 99);
RT_INTERFACE!{interface IContactAnnotationStore2(IContactAnnotationStore2Vtbl): IInspectable [IID_IContactAnnotationStore2] {
    fn FindAnnotationsForContactListAsync(&self, contactListId: HSTRING, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<ContactAnnotation>> as RtType>::Abi) -> HRESULT
}}
impl IContactAnnotationStore2 {
    #[inline] pub fn find_annotations_for_contact_list_async(&self, contactListId: &HStringArg) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<ContactAnnotation>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindAnnotationsForContactListAsync)(self.get_abi() as *const _ as *mut _, contactListId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ContactAnnotationStoreAccessType: i32 {
    AppAnnotationsReadWrite = 0, AllAnnotationsReadWrite = 1,
}}
DEFINE_IID!(IID_IContactBatch, 902928173, 49102, 18107, 147, 248, 165, 176, 110, 197, 226, 1);
RT_INTERFACE!{interface IContactBatch(IContactBatchVtbl): IInspectable [IID_IContactBatch] {
    fn get_Contacts(&self, out: *mut <foundation::collections::IVectorView<Contact> as RtType>::Abi) -> HRESULT,
    fn get_Status(&self, out: *mut ContactBatchStatus) -> HRESULT
}}
impl IContactBatch {
    #[inline] pub fn get_contacts(&self) -> Result<Option<foundation::collections::IVectorView<Contact>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Contacts)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<ContactBatchStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactBatch: IContactBatch}
RT_ENUM! { enum ContactBatchStatus: i32 {
    Success = 0, ServerSearchSyncManagerError = 1, ServerSearchUnknownError = 2,
}}
DEFINE_IID!(IID_IContactCardDelayedDataLoader, 3054172418, 5446, 17229, 134, 156, 110, 53, 32, 118, 14, 243);
RT_INTERFACE!{interface IContactCardDelayedDataLoader(IContactCardDelayedDataLoaderVtbl): IInspectable [IID_IContactCardDelayedDataLoader] {
    fn SetData(&self, contact: <Contact as RtType>::Abi) -> HRESULT
}}
impl IContactCardDelayedDataLoader {
    #[inline] pub fn set_data(&self, contact: &Contact) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetData)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactCardDelayedDataLoader: IContactCardDelayedDataLoader}
RT_ENUM! { enum ContactCardHeaderKind: i32 {
    Default = 0, Basic = 1, Enterprise = 2,
}}
DEFINE_IID!(IID_IContactCardOptions, 2349485950, 27318, 20287, 190, 114, 129, 114, 54, 238, 234, 91);
RT_INTERFACE!{interface IContactCardOptions(IContactCardOptionsVtbl): IInspectable [IID_IContactCardOptions] {
    fn get_HeaderKind(&self, out: *mut ContactCardHeaderKind) -> HRESULT,
    fn put_HeaderKind(&self, value: ContactCardHeaderKind) -> HRESULT,
    fn get_InitialTabKind(&self, out: *mut ContactCardTabKind) -> HRESULT,
    fn put_InitialTabKind(&self, value: ContactCardTabKind) -> HRESULT
}}
impl IContactCardOptions {
    #[inline] pub fn get_header_kind(&self) -> Result<ContactCardHeaderKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_HeaderKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_header_kind(&self, value: ContactCardHeaderKind) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_HeaderKind)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_initial_tab_kind(&self) -> Result<ContactCardTabKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_InitialTabKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_initial_tab_kind(&self, value: ContactCardTabKind) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_InitialTabKind)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactCardOptions: IContactCardOptions}
impl RtActivatable<IActivationFactory> for ContactCardOptions {}
DEFINE_CLSID!(ContactCardOptions(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,110,116,97,99,116,115,46,67,111,110,116,97,99,116,67,97,114,100,79,112,116,105,111,110,115,0]) [CLSID_ContactCardOptions]);
DEFINE_IID!(IID_IContactCardOptions2, 2401704864, 55115, 19654, 159, 83, 27, 14, 181, 209, 39, 60);
RT_INTERFACE!{interface IContactCardOptions2(IContactCardOptions2Vtbl): IInspectable [IID_IContactCardOptions2] {
    fn get_ServerSearchContactListIds(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT
}}
impl IContactCardOptions2 {
    #[inline] pub fn get_server_search_contact_list_ids(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ServerSearchContactListIds)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ContactCardTabKind: i32 {
    Default = 0, Email = 1, Messaging = 2, Phone = 3, Video = 4, OrganizationalHierarchy = 5,
}}
DEFINE_IID!(IID_IContactChange, 2501724944, 27225, 18208, 164, 225, 54, 61, 152, 193, 53, 213);
RT_INTERFACE!{interface IContactChange(IContactChangeVtbl): IInspectable [IID_IContactChange] {
    fn get_ChangeType(&self, out: *mut ContactChangeType) -> HRESULT,
    fn get_Contact(&self, out: *mut <Contact as RtType>::Abi) -> HRESULT
}}
impl IContactChange {
    #[inline] pub fn get_change_type(&self) -> Result<ContactChangeType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ChangeType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_contact(&self) -> Result<Option<Contact>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Contact)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Contact::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactChange: IContactChange}
DEFINE_IID!(IID_IContactChangedDeferral, 3306437352, 6915, 18168, 182, 148, 165, 35, 232, 60, 252, 182);
RT_INTERFACE!{interface IContactChangedDeferral(IContactChangedDeferralVtbl): IInspectable [IID_IContactChangedDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IContactChangedDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Complete)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactChangedDeferral: IContactChangedDeferral}
DEFINE_IID!(IID_IContactChangedEventArgs, 1381924817, 29683, 19325, 169, 24, 88, 11, 228, 54, 97, 33);
RT_INTERFACE!{interface IContactChangedEventArgs(IContactChangedEventArgsVtbl): IInspectable [IID_IContactChangedEventArgs] {
    fn GetDeferral(&self, out: *mut <ContactChangedDeferral as RtType>::Abi) -> HRESULT
}}
impl IContactChangedEventArgs {
    #[inline] pub fn get_deferral(&self) -> Result<Option<ContactChangedDeferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContactChangedDeferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactChangedEventArgs: IContactChangedEventArgs}
DEFINE_IID!(IID_IContactChangeReader, 561191418, 11532, 17120, 169, 218, 62, 205, 86, 167, 138, 71);
RT_INTERFACE!{interface IContactChangeReader(IContactChangeReaderVtbl): IInspectable [IID_IContactChangeReader] {
    fn AcceptChanges(&self) -> HRESULT,
    fn AcceptChangesThrough(&self, lastChangeToAccept: <ContactChange as RtType>::Abi) -> HRESULT,
    fn ReadBatchAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<ContactChange>> as RtType>::Abi) -> HRESULT
}}
impl IContactChangeReader {
    #[inline] pub fn accept_changes(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().AcceptChanges)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn accept_changes_through(&self, lastChangeToAccept: &ContactChange) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().AcceptChangesThrough)(self.get_abi() as *const _ as *mut _, lastChangeToAccept.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn read_batch_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<ContactChange>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReadBatchAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactChangeReader: IContactChangeReader}
DEFINE_IID!(IID_IContactChangeTracker, 1855531346, 12443, 16461, 151, 18, 179, 123, 211, 2, 120, 170);
RT_INTERFACE!{interface IContactChangeTracker(IContactChangeTrackerVtbl): IInspectable [IID_IContactChangeTracker] {
    fn Enable(&self) -> HRESULT,
    fn GetChangeReader(&self, out: *mut <ContactChangeReader as RtType>::Abi) -> HRESULT,
    fn Reset(&self) -> HRESULT
}}
impl IContactChangeTracker {
    #[inline] pub fn enable(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Enable)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_change_reader(&self) -> Result<Option<ContactChangeReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetChangeReader)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContactChangeReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn reset(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Reset)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactChangeTracker: IContactChangeTracker}
DEFINE_IID!(IID_IContactChangeTracker2, 2139803900, 37665, 19736, 156, 9, 215, 8, 198, 63, 205, 49);
RT_INTERFACE!{interface IContactChangeTracker2(IContactChangeTracker2Vtbl): IInspectable [IID_IContactChangeTracker2] {
    fn get_IsTracking(&self, out: *mut bool) -> HRESULT
}}
impl IContactChangeTracker2 {
    #[inline] pub fn get_is_tracking(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsTracking)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum ContactChangeType: i32 {
    Created = 0, Modified = 1, Deleted = 2, ChangeTrackingLost = 3,
}}
DEFINE_IID!(IID_IContactConnectedServiceAccount, 4143461715, 43559, 18225, 142, 74, 61, 236, 92, 233, 238, 201);
RT_INTERFACE!{interface IContactConnectedServiceAccount(IContactConnectedServiceAccountVtbl): IInspectable [IID_IContactConnectedServiceAccount] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Id(&self, value: HSTRING) -> HRESULT,
    fn get_ServiceName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ServiceName(&self, value: HSTRING) -> HRESULT
}}
impl IContactConnectedServiceAccount {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Id)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_service_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ServiceName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_service_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ServiceName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactConnectedServiceAccount: IContactConnectedServiceAccount}
impl RtActivatable<IActivationFactory> for ContactConnectedServiceAccount {}
DEFINE_CLSID!(ContactConnectedServiceAccount(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,110,116,97,99,116,115,46,67,111,110,116,97,99,116,67,111,110,110,101,99,116,101,100,83,101,114,118,105,99,101,65,99,99,111,117,110,116,0]) [CLSID_ContactConnectedServiceAccount]);
DEFINE_IID!(IID_IContactDate, 4271418982, 45573, 18740, 145, 116, 15, 242, 176, 86, 87, 7);
RT_INTERFACE!{interface IContactDate(IContactDateVtbl): IInspectable [IID_IContactDate] {
    fn get_Day(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn put_Day(&self, value: <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_Month(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn put_Month(&self, value: <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_Year(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_Year(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_Kind(&self, out: *mut ContactDateKind) -> HRESULT,
    fn put_Kind(&self, value: ContactDateKind) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT
}}
impl IContactDate {
    #[inline] pub fn get_day(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Day)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_day(&self, value: &foundation::IReference<u32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Day)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_month(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Month)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_month(&self, value: &foundation::IReference<u32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Month)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_year(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Year)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_year(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Year)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_kind(&self) -> Result<ContactDateKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Kind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_kind(&self, value: ContactDateKind) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Kind)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Description)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_description(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Description)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactDate: IContactDate}
impl RtActivatable<IActivationFactory> for ContactDate {}
DEFINE_CLSID!(ContactDate(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,110,116,97,99,116,115,46,67,111,110,116,97,99,116,68,97,116,101,0]) [CLSID_ContactDate]);
RT_ENUM! { enum ContactDateKind: i32 {
    Birthday = 0, Anniversary = 1, Other = 2,
}}
DEFINE_IID!(IID_IContactEmail, 2426542505, 58323, 19811, 153, 59, 5, 185, 165, 57, 58, 191);
RT_INTERFACE!{interface IContactEmail(IContactEmailVtbl): IInspectable [IID_IContactEmail] {
    fn get_Address(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Address(&self, value: HSTRING) -> HRESULT,
    fn get_Kind(&self, out: *mut ContactEmailKind) -> HRESULT,
    fn put_Kind(&self, value: ContactEmailKind) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT
}}
impl IContactEmail {
    #[inline] pub fn get_address(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Address)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_address(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Address)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_kind(&self) -> Result<ContactEmailKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Kind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_kind(&self, value: ContactEmailKind) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Kind)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Description)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_description(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Description)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactEmail: IContactEmail}
impl RtActivatable<IActivationFactory> for ContactEmail {}
DEFINE_CLSID!(ContactEmail(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,110,116,97,99,116,115,46,67,111,110,116,97,99,116,69,109,97,105,108,0]) [CLSID_ContactEmail]);
RT_ENUM! { enum ContactEmailKind: i32 {
    Personal = 0, Work = 1, Other = 2,
}}
DEFINE_IID!(IID_IContactField, 2977319018, 53907, 18732, 160, 88, 219, 87, 91, 62, 60, 15);
RT_INTERFACE!{interface IContactField(IContactFieldVtbl): IInspectable [IID_IContactField] {
    fn get_Type(&self, out: *mut ContactFieldType) -> HRESULT,
    fn get_Category(&self, out: *mut ContactFieldCategory) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Value(&self, out: *mut HSTRING) -> HRESULT
}}
impl IContactField {
    #[inline] pub fn get_type(&self) -> Result<ContactFieldType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Type)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_category(&self) -> Result<ContactFieldCategory> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Category)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Name)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Value)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactField: IContactField}
impl RtActivatable<IContactFieldFactory> for ContactField {}
impl ContactField {
    #[inline] pub fn create_field_default(value: &HStringArg, type_: ContactFieldType) -> Result<ContactField> {
        <Self as RtActivatable<IContactFieldFactory>>::get_activation_factory().create_field_default(value, type_)
    }
    #[inline] pub fn create_field_category(value: &HStringArg, type_: ContactFieldType, category: ContactFieldCategory) -> Result<ContactField> {
        <Self as RtActivatable<IContactFieldFactory>>::get_activation_factory().create_field_category(value, type_, category)
    }
    #[inline] pub fn create_field_custom(name: &HStringArg, value: &HStringArg, type_: ContactFieldType, category: ContactFieldCategory) -> Result<ContactField> {
        <Self as RtActivatable<IContactFieldFactory>>::get_activation_factory().create_field_custom(name, value, type_, category)
    }
}
DEFINE_CLSID!(ContactField(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,110,116,97,99,116,115,46,67,111,110,116,97,99,116,70,105,101,108,100,0]) [CLSID_ContactField]);
RT_ENUM! { enum ContactFieldCategory: i32 {
    None = 0, Home = 1, Work = 2, Mobile = 3, Other = 4,
}}
DEFINE_IID!(IID_IContactFieldFactory, 2246218047, 3658, 19006, 137, 148, 64, 106, 231, 237, 100, 110);
RT_INTERFACE!{static interface IContactFieldFactory(IContactFieldFactoryVtbl): IInspectable [IID_IContactFieldFactory] {
    fn CreateField_Default(&self, value: HSTRING, type_: ContactFieldType, out: *mut <ContactField as RtType>::Abi) -> HRESULT,
    fn CreateField_Category(&self, value: HSTRING, type_: ContactFieldType, category: ContactFieldCategory, out: *mut <ContactField as RtType>::Abi) -> HRESULT,
    fn CreateField_Custom(&self, name: HSTRING, value: HSTRING, type_: ContactFieldType, category: ContactFieldCategory, out: *mut <ContactField as RtType>::Abi) -> HRESULT
}}
impl IContactFieldFactory {
    #[inline] pub fn create_field_default(&self, value: &HStringArg, type_: ContactFieldType) -> Result<ContactField> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateField_Default)(self.get_abi() as *const _ as *mut _, value.get(), type_, &mut out);
        if hr == S_OK { Ok(ContactField::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_field_category(&self, value: &HStringArg, type_: ContactFieldType, category: ContactFieldCategory) -> Result<ContactField> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateField_Category)(self.get_abi() as *const _ as *mut _, value.get(), type_, category, &mut out);
        if hr == S_OK { Ok(ContactField::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_field_custom(&self, name: &HStringArg, value: &HStringArg, type_: ContactFieldType, category: ContactFieldCategory) -> Result<ContactField> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateField_Custom)(self.get_abi() as *const _ as *mut _, name.get(), value.get(), type_, category, &mut out);
        if hr == S_OK { Ok(ContactField::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactFieldFactory: IContactFieldFactory}
impl RtActivatable<IActivationFactory> for ContactFieldFactory {}
DEFINE_CLSID!(ContactFieldFactory(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,110,116,97,99,116,115,46,67,111,110,116,97,99,116,70,105,101,108,100,70,97,99,116,111,114,121,0]) [CLSID_ContactFieldFactory]);
RT_ENUM! { enum ContactFieldType: i32 {
    Email = 0, PhoneNumber = 1, Location = 2, InstantMessage = 3, Custom = 4, ConnectedServiceAccount = 5, ImportantDate = 6, Address = 7, SignificantOther = 8, Notes = 9, Website = 10, JobInfo = 11,
}}
DEFINE_IID!(IID_IContactGroup, 1505618689, 40602, 18269, 191, 229, 163, 123, 128, 109, 133, 44);
RT_INTERFACE!{interface IContactGroup(IContactGroupVtbl): IInspectable [IID_IContactGroup] {
    
}}
RT_CLASS!{class ContactGroup: IContactGroup}
DEFINE_IID!(IID_IContactInformation, 660518612, 27182, 17016, 169, 20, 228, 96, 213, 240, 136, 246);
RT_INTERFACE!{interface IContactInformation(IContactInformationVtbl): IInspectable [IID_IContactInformation] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn GetThumbnailAsync(&self, out: *mut <foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamWithContentType> as RtType>::Abi) -> HRESULT,
    fn get_Emails(&self, out: *mut <foundation::collections::IVectorView<ContactField> as RtType>::Abi) -> HRESULT,
    fn get_PhoneNumbers(&self, out: *mut <foundation::collections::IVectorView<ContactField> as RtType>::Abi) -> HRESULT,
    fn get_Locations(&self, out: *mut <foundation::collections::IVectorView<ContactLocationField> as RtType>::Abi) -> HRESULT,
    fn get_InstantMessages(&self, out: *mut <foundation::collections::IVectorView<ContactInstantMessageField> as RtType>::Abi) -> HRESULT,
    fn get_CustomFields(&self, out: *mut <foundation::collections::IVectorView<ContactField> as RtType>::Abi) -> HRESULT,
    fn QueryCustomFields(&self, customName: HSTRING, out: *mut <foundation::collections::IVectorView<ContactField> as RtType>::Abi) -> HRESULT
}}
impl IContactInformation {
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Name)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_thumbnail_async(&self) -> Result<foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamWithContentType>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetThumbnailAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_emails(&self) -> Result<Option<foundation::collections::IVectorView<ContactField>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Emails)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_phone_numbers(&self) -> Result<Option<foundation::collections::IVectorView<ContactField>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PhoneNumbers)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_locations(&self) -> Result<Option<foundation::collections::IVectorView<ContactLocationField>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Locations)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_instant_messages(&self) -> Result<Option<foundation::collections::IVectorView<ContactInstantMessageField>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_InstantMessages)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_custom_fields(&self) -> Result<Option<foundation::collections::IVectorView<ContactField>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CustomFields)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn query_custom_fields(&self, customName: &HStringArg) -> Result<Option<foundation::collections::IVectorView<ContactField>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().QueryCustomFields)(self.get_abi() as *const _ as *mut _, customName.get(), &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactInformation: IContactInformation}
DEFINE_IID!(IID_IContactInstantMessageField, 3437443895, 3461, 16890, 180, 61, 218, 89, 156, 62, 176, 9);
RT_INTERFACE!{interface IContactInstantMessageField(IContactInstantMessageFieldVtbl): IInspectable [IID_IContactInstantMessageField] {
    fn get_UserName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Service(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_LaunchUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT
}}
impl IContactInstantMessageField {
    #[inline] pub fn get_user_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_UserName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_service(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Service)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayText)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_launch_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LaunchUri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactInstantMessageField: IContactInstantMessageField}
impl RtActivatable<IContactInstantMessageFieldFactory> for ContactInstantMessageField {}
impl ContactInstantMessageField {
    #[inline] pub fn create_instant_message_default(userName: &HStringArg) -> Result<ContactInstantMessageField> {
        <Self as RtActivatable<IContactInstantMessageFieldFactory>>::get_activation_factory().create_instant_message_default(userName)
    }
    #[inline] pub fn create_instant_message_category(userName: &HStringArg, category: ContactFieldCategory) -> Result<ContactInstantMessageField> {
        <Self as RtActivatable<IContactInstantMessageFieldFactory>>::get_activation_factory().create_instant_message_category(userName, category)
    }
    #[inline] pub fn create_instant_message_all(userName: &HStringArg, category: ContactFieldCategory, service: &HStringArg, displayText: &HStringArg, verb: &foundation::Uri) -> Result<ContactInstantMessageField> {
        <Self as RtActivatable<IContactInstantMessageFieldFactory>>::get_activation_factory().create_instant_message_all(userName, category, service, displayText, verb)
    }
}
DEFINE_CLSID!(ContactInstantMessageField(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,110,116,97,99,116,115,46,67,111,110,116,97,99,116,73,110,115,116,97,110,116,77,101,115,115,97,103,101,70,105,101,108,100,0]) [CLSID_ContactInstantMessageField]);
DEFINE_IID!(IID_IContactInstantMessageFieldFactory, 3121309588, 37283, 19378, 177, 185, 105, 165, 223, 240, 186, 9);
RT_INTERFACE!{static interface IContactInstantMessageFieldFactory(IContactInstantMessageFieldFactoryVtbl): IInspectable [IID_IContactInstantMessageFieldFactory] {
    fn CreateInstantMessage_Default(&self, userName: HSTRING, out: *mut <ContactInstantMessageField as RtType>::Abi) -> HRESULT,
    fn CreateInstantMessage_Category(&self, userName: HSTRING, category: ContactFieldCategory, out: *mut <ContactInstantMessageField as RtType>::Abi) -> HRESULT,
    fn CreateInstantMessage_All(&self, userName: HSTRING, category: ContactFieldCategory, service: HSTRING, displayText: HSTRING, verb: <foundation::Uri as RtType>::Abi, out: *mut <ContactInstantMessageField as RtType>::Abi) -> HRESULT
}}
impl IContactInstantMessageFieldFactory {
    #[inline] pub fn create_instant_message_default(&self, userName: &HStringArg) -> Result<ContactInstantMessageField> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateInstantMessage_Default)(self.get_abi() as *const _ as *mut _, userName.get(), &mut out);
        if hr == S_OK { Ok(ContactInstantMessageField::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_instant_message_category(&self, userName: &HStringArg, category: ContactFieldCategory) -> Result<ContactInstantMessageField> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateInstantMessage_Category)(self.get_abi() as *const _ as *mut _, userName.get(), category, &mut out);
        if hr == S_OK { Ok(ContactInstantMessageField::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_instant_message_all(&self, userName: &HStringArg, category: ContactFieldCategory, service: &HStringArg, displayText: &HStringArg, verb: &foundation::Uri) -> Result<ContactInstantMessageField> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateInstantMessage_All)(self.get_abi() as *const _ as *mut _, userName.get(), category, service.get(), displayText.get(), verb.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContactInstantMessageField::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContactJobInfo, 1829862220, 52816, 19267, 158, 105, 177, 130, 88, 234, 83, 21);
RT_INTERFACE!{interface IContactJobInfo(IContactJobInfoVtbl): IInspectable [IID_IContactJobInfo] {
    fn get_CompanyName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CompanyName(&self, value: HSTRING) -> HRESULT,
    fn get_CompanyYomiName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CompanyYomiName(&self, value: HSTRING) -> HRESULT,
    fn get_Department(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Department(&self, value: HSTRING) -> HRESULT,
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    fn get_Manager(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Manager(&self, value: HSTRING) -> HRESULT,
    fn get_Office(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Office(&self, value: HSTRING) -> HRESULT,
    fn get_CompanyAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CompanyAddress(&self, value: HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT
}}
impl IContactJobInfo {
    #[inline] pub fn get_company_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CompanyName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_company_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CompanyName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_company_yomi_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CompanyYomiName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_company_yomi_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CompanyYomiName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_department(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Department)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_department(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Department)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Title)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_title(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Title)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_manager(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Manager)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_manager(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Manager)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_office(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Office)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_office(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Office)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_company_address(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CompanyAddress)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_company_address(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CompanyAddress)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Description)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_description(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Description)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactJobInfo: IContactJobInfo}
impl RtActivatable<IActivationFactory> for ContactJobInfo {}
DEFINE_CLSID!(ContactJobInfo(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,110,116,97,99,116,115,46,67,111,110,116,97,99,116,74,111,98,73,110,102,111,0]) [CLSID_ContactJobInfo]);
RT_CLASS!{static class ContactLaunchActionVerbs}
impl RtActivatable<IContactLaunchActionVerbsStatics> for ContactLaunchActionVerbs {}
impl ContactLaunchActionVerbs {
    #[inline] pub fn get_call() -> Result<HString> {
        <Self as RtActivatable<IContactLaunchActionVerbsStatics>>::get_activation_factory().get_call()
    }
    #[inline] pub fn get_message() -> Result<HString> {
        <Self as RtActivatable<IContactLaunchActionVerbsStatics>>::get_activation_factory().get_message()
    }
    #[inline] pub fn get_map() -> Result<HString> {
        <Self as RtActivatable<IContactLaunchActionVerbsStatics>>::get_activation_factory().get_map()
    }
    #[inline] pub fn get_post() -> Result<HString> {
        <Self as RtActivatable<IContactLaunchActionVerbsStatics>>::get_activation_factory().get_post()
    }
    #[inline] pub fn get_video_call() -> Result<HString> {
        <Self as RtActivatable<IContactLaunchActionVerbsStatics>>::get_activation_factory().get_video_call()
    }
}
DEFINE_CLSID!(ContactLaunchActionVerbs(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,110,116,97,99,116,115,46,67,111,110,116,97,99,116,76,97,117,110,99,104,65,99,116,105,111,110,86,101,114,98,115,0]) [CLSID_ContactLaunchActionVerbs]);
DEFINE_IID!(IID_IContactLaunchActionVerbsStatics, 4212273878, 61043, 18151, 135, 97, 17, 205, 1, 87, 114, 143);
RT_INTERFACE!{static interface IContactLaunchActionVerbsStatics(IContactLaunchActionVerbsStaticsVtbl): IInspectable [IID_IContactLaunchActionVerbsStatics] {
    fn get_Call(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Message(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Map(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Post(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoCall(&self, out: *mut HSTRING) -> HRESULT
}}
impl IContactLaunchActionVerbsStatics {
    #[inline] pub fn get_call(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Call)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Message)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_map(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Map)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_post(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Post)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_call(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_VideoCall)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContactList, 383642741, 14636, 18501, 157, 251, 81, 163, 231, 239, 62, 66);
RT_INTERFACE!{interface IContactList(IContactListVtbl): IInspectable [IID_IContactList] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_SourceDisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsHidden(&self, out: *mut bool) -> HRESULT,
    fn put_IsHidden(&self, value: bool) -> HRESULT,
    fn get_OtherAppReadAccess(&self, out: *mut ContactListOtherAppReadAccess) -> HRESULT,
    fn put_OtherAppReadAccess(&self, value: ContactListOtherAppReadAccess) -> HRESULT,
    fn get_OtherAppWriteAccess(&self, out: *mut ContactListOtherAppWriteAccess) -> HRESULT,
    fn put_OtherAppWriteAccess(&self, value: ContactListOtherAppWriteAccess) -> HRESULT,
    fn get_ChangeTracker(&self, out: *mut <ContactChangeTracker as RtType>::Abi) -> HRESULT,
    fn get_SyncManager(&self, out: *mut <ContactListSyncManager as RtType>::Abi) -> HRESULT,
    fn get_SupportsServerSearch(&self, out: *mut bool) -> HRESULT,
    fn get_UserDataAccountId(&self, out: *mut HSTRING) -> HRESULT,
    fn add_ContactChanged(&self, value: <foundation::TypedEventHandler<ContactList, ContactChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ContactChanged(&self, value: foundation::EventRegistrationToken) -> HRESULT,
    fn SaveAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn DeleteAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn GetContactFromRemoteIdAsync(&self, remoteId: HSTRING, out: *mut <foundation::IAsyncOperation<Contact> as RtType>::Abi) -> HRESULT,
    fn GetMeContactAsync(&self, out: *mut <foundation::IAsyncOperation<Contact> as RtType>::Abi) -> HRESULT,
    fn GetContactReader(&self, out: *mut <ContactReader as RtType>::Abi) -> HRESULT,
    fn GetContactReaderWithOptions(&self, options: <ContactQueryOptions as RtType>::Abi, out: *mut <ContactReader as RtType>::Abi) -> HRESULT,
    fn SaveContactAsync(&self, contact: <Contact as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn DeleteContactAsync(&self, contact: <Contact as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn GetContactAsync(&self, contactId: HSTRING, out: *mut <foundation::IAsyncOperation<Contact> as RtType>::Abi) -> HRESULT
}}
impl IContactList {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_source_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SourceDisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_hidden(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsHidden)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_hidden(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsHidden)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_other_app_read_access(&self) -> Result<ContactListOtherAppReadAccess> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_OtherAppReadAccess)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_other_app_read_access(&self, value: ContactListOtherAppReadAccess) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_OtherAppReadAccess)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_other_app_write_access(&self) -> Result<ContactListOtherAppWriteAccess> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_OtherAppWriteAccess)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_other_app_write_access(&self, value: ContactListOtherAppWriteAccess) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_OtherAppWriteAccess)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_change_tracker(&self) -> Result<Option<ContactChangeTracker>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ChangeTracker)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContactChangeTracker::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sync_manager(&self) -> Result<Option<ContactListSyncManager>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SyncManager)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContactListSyncManager::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supports_server_search(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SupportsServerSearch)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_user_data_account_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_UserDataAccountId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_contact_changed(&self, value: &foundation::TypedEventHandler<ContactList, ContactChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_ContactChanged)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_contact_changed(&self, value: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_ContactChanged)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn save_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SaveAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_contact_from_remote_id_async(&self, remoteId: &HStringArg) -> Result<foundation::IAsyncOperation<Contact>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetContactFromRemoteIdAsync)(self.get_abi() as *const _ as *mut _, remoteId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_me_contact_async(&self) -> Result<foundation::IAsyncOperation<Contact>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetMeContactAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_contact_reader(&self) -> Result<Option<ContactReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetContactReader)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContactReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_contact_reader_with_options(&self, options: &ContactQueryOptions) -> Result<Option<ContactReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetContactReaderWithOptions)(self.get_abi() as *const _ as *mut _, options.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContactReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn save_contact_async(&self, contact: &Contact) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SaveContactAsync)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_contact_async(&self, contact: &Contact) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteContactAsync)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_contact_async(&self, contactId: &HStringArg) -> Result<foundation::IAsyncOperation<Contact>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetContactAsync)(self.get_abi() as *const _ as *mut _, contactId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactList: IContactList}
DEFINE_IID!(IID_IContactList2, 3409527732, 17744, 19915, 146, 41, 64, 255, 145, 251, 2, 3);
RT_INTERFACE!{interface IContactList2(IContactList2Vtbl): IInspectable [IID_IContactList2] {
    fn RegisterSyncManagerAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn put_SupportsServerSearch(&self, value: bool) -> HRESULT,
    fn get_SyncConstraints(&self, out: *mut <ContactListSyncConstraints as RtType>::Abi) -> HRESULT
}}
impl IContactList2 {
    #[inline] pub fn register_sync_manager_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RegisterSyncManagerAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_supports_server_search(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SupportsServerSearch)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sync_constraints(&self) -> Result<Option<ContactListSyncConstraints>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SyncConstraints)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContactListSyncConstraints::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContactList3, 360246871, 9980, 16872, 168, 80, 90, 163, 37, 20, 172, 169);
RT_INTERFACE!{interface IContactList3(IContactList3Vtbl): IInspectable [IID_IContactList3] {
    fn get_LimitedWriteOperations(&self, out: *mut <ContactListLimitedWriteOperations as RtType>::Abi) -> HRESULT,
    fn GetChangeTracker(&self, identity: HSTRING, out: *mut <ContactChangeTracker as RtType>::Abi) -> HRESULT
}}
impl IContactList3 {
    #[inline] pub fn get_limited_write_operations(&self) -> Result<Option<ContactListLimitedWriteOperations>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LimitedWriteOperations)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContactListLimitedWriteOperations::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_change_tracker(&self, identity: &HStringArg) -> Result<Option<ContactChangeTracker>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetChangeTracker)(self.get_abi() as *const _ as *mut _, identity.get(), &mut out);
        if hr == S_OK { Ok(ContactChangeTracker::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContactListLimitedWriteOperations, 3784840154, 18955, 17592, 154, 31, 160, 243, 210, 24, 23, 95);
RT_INTERFACE!{interface IContactListLimitedWriteOperations(IContactListLimitedWriteOperationsVtbl): IInspectable [IID_IContactListLimitedWriteOperations] {
    fn TryCreateOrUpdateContactAsync(&self, contact: <Contact as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryDeleteContactAsync(&self, contactId: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl IContactListLimitedWriteOperations {
    #[inline] pub fn try_create_or_update_contact_async(&self, contact: &Contact) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryCreateOrUpdateContactAsync)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_delete_contact_async(&self, contactId: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryDeleteContactAsync)(self.get_abi() as *const _ as *mut _, contactId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactListLimitedWriteOperations: IContactListLimitedWriteOperations}
RT_ENUM! { enum ContactListOtherAppReadAccess: i32 {
    SystemOnly = 0, Limited = 1, Full = 2, None = 3,
}}
RT_ENUM! { enum ContactListOtherAppWriteAccess: i32 {
    None = 0, SystemOnly = 1, Limited = 2,
}}
DEFINE_IID!(IID_IContactListSyncConstraints, 2997927681, 12386, 20014, 150, 157, 1, 141, 25, 135, 243, 20);
RT_INTERFACE!{interface IContactListSyncConstraints(IContactListSyncConstraintsVtbl): IInspectable [IID_IContactListSyncConstraints] {
    fn get_CanSyncDescriptions(&self, out: *mut bool) -> HRESULT,
    fn put_CanSyncDescriptions(&self, value: bool) -> HRESULT,
    fn get_MaxHomePhoneNumbers(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxHomePhoneNumbers(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxMobilePhoneNumbers(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxMobilePhoneNumbers(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxWorkPhoneNumbers(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxWorkPhoneNumbers(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxOtherPhoneNumbers(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxOtherPhoneNumbers(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxPagerPhoneNumbers(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxPagerPhoneNumbers(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxBusinessFaxPhoneNumbers(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxBusinessFaxPhoneNumbers(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxHomeFaxPhoneNumbers(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxHomeFaxPhoneNumbers(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxCompanyPhoneNumbers(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxCompanyPhoneNumbers(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxAssistantPhoneNumbers(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxAssistantPhoneNumbers(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxRadioPhoneNumbers(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxRadioPhoneNumbers(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxPersonalEmailAddresses(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxPersonalEmailAddresses(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxWorkEmailAddresses(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxWorkEmailAddresses(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxOtherEmailAddresses(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxOtherEmailAddresses(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxHomeAddresses(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxHomeAddresses(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxWorkAddresses(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxWorkAddresses(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxOtherAddresses(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxOtherAddresses(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxBirthdayDates(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxBirthdayDates(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxAnniversaryDates(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxAnniversaryDates(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxOtherDates(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxOtherDates(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxOtherRelationships(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxOtherRelationships(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxSpouseRelationships(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxSpouseRelationships(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxPartnerRelationships(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxPartnerRelationships(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxSiblingRelationships(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxSiblingRelationships(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxParentRelationships(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxParentRelationships(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxChildRelationships(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxChildRelationships(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxJobInfo(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxJobInfo(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxWebsites(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_MaxWebsites(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT
}}
impl IContactListSyncConstraints {
    #[inline] pub fn get_can_sync_descriptions(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanSyncDescriptions)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_can_sync_descriptions(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanSyncDescriptions)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_home_phone_numbers(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxHomePhoneNumbers)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_home_phone_numbers(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxHomePhoneNumbers)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_mobile_phone_numbers(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxMobilePhoneNumbers)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_mobile_phone_numbers(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxMobilePhoneNumbers)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_work_phone_numbers(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxWorkPhoneNumbers)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_work_phone_numbers(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxWorkPhoneNumbers)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_other_phone_numbers(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxOtherPhoneNumbers)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_other_phone_numbers(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxOtherPhoneNumbers)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_pager_phone_numbers(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxPagerPhoneNumbers)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_pager_phone_numbers(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxPagerPhoneNumbers)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_business_fax_phone_numbers(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxBusinessFaxPhoneNumbers)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_business_fax_phone_numbers(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxBusinessFaxPhoneNumbers)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_home_fax_phone_numbers(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxHomeFaxPhoneNumbers)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_home_fax_phone_numbers(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxHomeFaxPhoneNumbers)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_company_phone_numbers(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxCompanyPhoneNumbers)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_company_phone_numbers(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxCompanyPhoneNumbers)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_assistant_phone_numbers(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxAssistantPhoneNumbers)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_assistant_phone_numbers(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxAssistantPhoneNumbers)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_radio_phone_numbers(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxRadioPhoneNumbers)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_radio_phone_numbers(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxRadioPhoneNumbers)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_personal_email_addresses(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxPersonalEmailAddresses)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_personal_email_addresses(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxPersonalEmailAddresses)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_work_email_addresses(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxWorkEmailAddresses)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_work_email_addresses(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxWorkEmailAddresses)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_other_email_addresses(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxOtherEmailAddresses)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_other_email_addresses(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxOtherEmailAddresses)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_home_addresses(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxHomeAddresses)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_home_addresses(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxHomeAddresses)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_work_addresses(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxWorkAddresses)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_work_addresses(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxWorkAddresses)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_other_addresses(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxOtherAddresses)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_other_addresses(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxOtherAddresses)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_birthday_dates(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxBirthdayDates)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_birthday_dates(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxBirthdayDates)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_anniversary_dates(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxAnniversaryDates)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_anniversary_dates(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxAnniversaryDates)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_other_dates(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxOtherDates)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_other_dates(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxOtherDates)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_other_relationships(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxOtherRelationships)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_other_relationships(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxOtherRelationships)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_spouse_relationships(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxSpouseRelationships)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_spouse_relationships(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxSpouseRelationships)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_partner_relationships(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxPartnerRelationships)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_partner_relationships(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxPartnerRelationships)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_sibling_relationships(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxSiblingRelationships)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_sibling_relationships(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxSiblingRelationships)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_parent_relationships(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxParentRelationships)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_parent_relationships(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxParentRelationships)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_child_relationships(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxChildRelationships)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_child_relationships(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxChildRelationships)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_job_info(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxJobInfo)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_job_info(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxJobInfo)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_websites(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MaxWebsites)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_websites(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MaxWebsites)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactListSyncConstraints: IContactListSyncConstraints}
DEFINE_IID!(IID_IContactListSyncManager, 342787006, 31013, 19148, 157, 229, 33, 221, 208, 111, 134, 116);
RT_INTERFACE!{interface IContactListSyncManager(IContactListSyncManagerVtbl): IInspectable [IID_IContactListSyncManager] {
    fn get_Status(&self, out: *mut ContactListSyncStatus) -> HRESULT,
    fn get_LastSuccessfulSyncTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_LastAttemptedSyncTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn SyncAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn add_SyncStatusChanged(&self, handler: <foundation::TypedEventHandler<ContactListSyncManager, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SyncStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IContactListSyncManager {
    #[inline] pub fn get_status(&self) -> Result<ContactListSyncStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_last_successful_sync_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_LastSuccessfulSyncTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_last_attempted_sync_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_LastAttemptedSyncTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn sync_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SyncAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_sync_status_changed(&self, handler: &foundation::TypedEventHandler<ContactListSyncManager, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_SyncStatusChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_sync_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_SyncStatusChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactListSyncManager: IContactListSyncManager}
DEFINE_IID!(IID_IContactListSyncManager2, 2841186887, 47957, 20003, 129, 40, 55, 1, 52, 168, 93, 13);
RT_INTERFACE!{interface IContactListSyncManager2(IContactListSyncManager2Vtbl): IInspectable [IID_IContactListSyncManager2] {
    fn put_Status(&self, value: ContactListSyncStatus) -> HRESULT,
    fn put_LastSuccessfulSyncTime(&self, value: foundation::DateTime) -> HRESULT,
    fn put_LastAttemptedSyncTime(&self, value: foundation::DateTime) -> HRESULT
}}
impl IContactListSyncManager2 {
    #[inline] pub fn set_status(&self, value: ContactListSyncStatus) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Status)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_last_successful_sync_time(&self, value: foundation::DateTime) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_LastSuccessfulSyncTime)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_last_attempted_sync_time(&self, value: foundation::DateTime) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_LastAttemptedSyncTime)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum ContactListSyncStatus: i32 {
    Idle = 0, Syncing = 1, UpToDate = 2, AuthenticationError = 3, PolicyError = 4, UnknownError = 5, ManualAccountRemovalRequired = 6,
}}
DEFINE_IID!(IID_IContactLocationField, 2663387010, 43886, 19254, 137, 227, 178, 59, 192, 161, 218, 204);
RT_INTERFACE!{interface IContactLocationField(IContactLocationFieldVtbl): IInspectable [IID_IContactLocationField] {
    fn get_UnstructuredAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Street(&self, out: *mut HSTRING) -> HRESULT,
    fn get_City(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Region(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Country(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PostalCode(&self, out: *mut HSTRING) -> HRESULT
}}
impl IContactLocationField {
    #[inline] pub fn get_unstructured_address(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_UnstructuredAddress)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_street(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Street)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_city(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_City)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_region(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Region)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_country(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Country)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_postal_code(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PostalCode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactLocationField: IContactLocationField}
impl RtActivatable<IContactLocationFieldFactory> for ContactLocationField {}
impl ContactLocationField {
    #[inline] pub fn create_location_default(unstructuredAddress: &HStringArg) -> Result<ContactLocationField> {
        <Self as RtActivatable<IContactLocationFieldFactory>>::get_activation_factory().create_location_default(unstructuredAddress)
    }
    #[inline] pub fn create_location_category(unstructuredAddress: &HStringArg, category: ContactFieldCategory) -> Result<ContactLocationField> {
        <Self as RtActivatable<IContactLocationFieldFactory>>::get_activation_factory().create_location_category(unstructuredAddress, category)
    }
    #[inline] pub fn create_location_all(unstructuredAddress: &HStringArg, category: ContactFieldCategory, street: &HStringArg, city: &HStringArg, region: &HStringArg, country: &HStringArg, postalCode: &HStringArg) -> Result<ContactLocationField> {
        <Self as RtActivatable<IContactLocationFieldFactory>>::get_activation_factory().create_location_all(unstructuredAddress, category, street, city, region, country, postalCode)
    }
}
DEFINE_CLSID!(ContactLocationField(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,110,116,97,99,116,115,46,67,111,110,116,97,99,116,76,111,99,97,116,105,111,110,70,105,101,108,100,0]) [CLSID_ContactLocationField]);
DEFINE_IID!(IID_IContactLocationFieldFactory, 4154012375, 12255, 17406, 143, 24, 65, 137, 115, 144, 188, 254);
RT_INTERFACE!{static interface IContactLocationFieldFactory(IContactLocationFieldFactoryVtbl): IInspectable [IID_IContactLocationFieldFactory] {
    fn CreateLocation_Default(&self, unstructuredAddress: HSTRING, out: *mut <ContactLocationField as RtType>::Abi) -> HRESULT,
    fn CreateLocation_Category(&self, unstructuredAddress: HSTRING, category: ContactFieldCategory, out: *mut <ContactLocationField as RtType>::Abi) -> HRESULT,
    fn CreateLocation_All(&self, unstructuredAddress: HSTRING, category: ContactFieldCategory, street: HSTRING, city: HSTRING, region: HSTRING, country: HSTRING, postalCode: HSTRING, out: *mut <ContactLocationField as RtType>::Abi) -> HRESULT
}}
impl IContactLocationFieldFactory {
    #[inline] pub fn create_location_default(&self, unstructuredAddress: &HStringArg) -> Result<ContactLocationField> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateLocation_Default)(self.get_abi() as *const _ as *mut _, unstructuredAddress.get(), &mut out);
        if hr == S_OK { Ok(ContactLocationField::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_location_category(&self, unstructuredAddress: &HStringArg, category: ContactFieldCategory) -> Result<ContactLocationField> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateLocation_Category)(self.get_abi() as *const _ as *mut _, unstructuredAddress.get(), category, &mut out);
        if hr == S_OK { Ok(ContactLocationField::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_location_all(&self, unstructuredAddress: &HStringArg, category: ContactFieldCategory, street: &HStringArg, city: &HStringArg, region: &HStringArg, country: &HStringArg, postalCode: &HStringArg) -> Result<ContactLocationField> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateLocation_All)(self.get_abi() as *const _ as *mut _, unstructuredAddress.get(), category, street.get(), city.get(), region.get(), country.get(), postalCode.get(), &mut out);
        if hr == S_OK { Ok(ContactLocationField::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class ContactManager}
impl RtActivatable<IContactManagerStatics> for ContactManager {}
impl RtActivatable<IContactManagerStatics2> for ContactManager {}
impl RtActivatable<IContactManagerStatics3> for ContactManager {}
impl RtActivatable<IContactManagerStatics4> for ContactManager {}
impl RtActivatable<IContactManagerStatics5> for ContactManager {}
impl ContactManager {
    #[inline] pub fn show_contact_card(contact: &Contact, selection: foundation::Rect) -> Result<()> {
        <Self as RtActivatable<IContactManagerStatics>>::get_activation_factory().show_contact_card(contact, selection)
    }
    #[cfg(feature="windows-ui")] #[inline] pub fn show_contact_card_with_placement(contact: &Contact, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<()> {
        <Self as RtActivatable<IContactManagerStatics>>::get_activation_factory().show_contact_card_with_placement(contact, selection, preferredPlacement)
    }
    #[cfg(feature="windows-ui")] #[inline] pub fn show_delay_loaded_contact_card(contact: &Contact, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<Option<ContactCardDelayedDataLoader>> {
        <Self as RtActivatable<IContactManagerStatics>>::get_activation_factory().show_delay_loaded_contact_card(contact, selection, preferredPlacement)
    }
    #[inline] pub fn request_store_async() -> Result<foundation::IAsyncOperation<ContactStore>> {
        <Self as RtActivatable<IContactManagerStatics2>>::get_activation_factory().request_store_async()
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn convert_contact_to_vcard_async(contact: &Contact) -> Result<foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference>> {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().convert_contact_to_vcard_async(contact)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn convert_contact_to_vcard_async_with_max_bytes(contact: &Contact, maxBytes: u32) -> Result<foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference>> {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().convert_contact_to_vcard_async_with_max_bytes(contact, maxBytes)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn convert_vcard_to_contact_async(vCard: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<foundation::IAsyncOperation<Contact>> {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().convert_vcard_to_contact_async(vCard)
    }
    #[inline] pub fn request_store_async_with_access_type(accessType: ContactStoreAccessType) -> Result<foundation::IAsyncOperation<ContactStore>> {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().request_store_async_with_access_type(accessType)
    }
    #[inline] pub fn request_annotation_store_async(accessType: ContactAnnotationStoreAccessType) -> Result<foundation::IAsyncOperation<ContactAnnotationStore>> {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().request_annotation_store_async(accessType)
    }
    #[inline] pub fn is_show_contact_card_supported() -> Result<bool> {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().is_show_contact_card_supported()
    }
    #[cfg(feature="windows-ui")] #[inline] pub fn show_contact_card_with_options(contact: &Contact, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, contactCardOptions: &ContactCardOptions) -> Result<()> {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().show_contact_card_with_options(contact, selection, preferredPlacement, contactCardOptions)
    }
    #[inline] pub fn is_show_delay_loaded_contact_card_supported() -> Result<bool> {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().is_show_delay_loaded_contact_card_supported()
    }
    #[cfg(feature="windows-ui")] #[inline] pub fn show_delay_loaded_contact_card_with_options(contact: &Contact, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, contactCardOptions: &ContactCardOptions) -> Result<Option<ContactCardDelayedDataLoader>> {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().show_delay_loaded_contact_card_with_options(contact, selection, preferredPlacement, contactCardOptions)
    }
    #[inline] pub fn show_full_contact_card(contact: &Contact, fullContactCardOptions: &FullContactCardOptions) -> Result<()> {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().show_full_contact_card(contact, fullContactCardOptions)
    }
    #[inline] pub fn get_system_display_name_order() -> Result<ContactNameOrder> {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().get_system_display_name_order()
    }
    #[inline] pub fn set_system_display_name_order(value: ContactNameOrder) -> Result<()> {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().set_system_display_name_order(value)
    }
    #[inline] pub fn get_system_sort_order() -> Result<ContactNameOrder> {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().get_system_sort_order()
    }
    #[inline] pub fn set_system_sort_order(value: ContactNameOrder) -> Result<()> {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().set_system_sort_order(value)
    }
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(user: &super::super::system::User) -> Result<Option<ContactManagerForUser>> {
        <Self as RtActivatable<IContactManagerStatics4>>::get_activation_factory().get_for_user(user)
    }
    #[inline] pub fn is_show_full_contact_card_supported_async() -> Result<foundation::IAsyncOperation<bool>> {
        <Self as RtActivatable<IContactManagerStatics5>>::get_activation_factory().is_show_full_contact_card_supported_async()
    }
    #[inline] pub fn get_include_middle_name_in_system_display_and_sort() -> Result<bool> {
        <Self as RtActivatable<IContactManagerStatics5>>::get_activation_factory().get_include_middle_name_in_system_display_and_sort()
    }
    #[inline] pub fn set_include_middle_name_in_system_display_and_sort(value: bool) -> Result<()> {
        <Self as RtActivatable<IContactManagerStatics5>>::get_activation_factory().set_include_middle_name_in_system_display_and_sort(value)
    }
}
DEFINE_CLSID!(ContactManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,110,116,97,99,116,115,46,67,111,110,116,97,99,116,77,97,110,97,103,101,114,0]) [CLSID_ContactManager]);
DEFINE_IID!(IID_IContactManagerForUser, 3075193431, 4214, 19439, 174, 243, 84, 104, 109, 24, 56, 125);
RT_INTERFACE!{interface IContactManagerForUser(IContactManagerForUserVtbl): IInspectable [IID_IContactManagerForUser] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn ConvertContactToVCardAsync(&self, contact: <Contact as RtType>::Abi, out: *mut <foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn ConvertContactToVCardAsyncWithMaxBytes(&self, contact: <Contact as RtType>::Abi, maxBytes: u32, out: *mut <foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn ConvertVCardToContactAsync(&self, vCard: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi, out: *mut <foundation::IAsyncOperation<Contact> as RtType>::Abi) -> HRESULT,
    fn RequestStoreAsync(&self, accessType: ContactStoreAccessType, out: *mut <foundation::IAsyncOperation<ContactStore> as RtType>::Abi) -> HRESULT,
    fn RequestAnnotationStoreAsync(&self, accessType: ContactAnnotationStoreAccessType, out: *mut <foundation::IAsyncOperation<ContactAnnotationStore> as RtType>::Abi) -> HRESULT,
    fn get_SystemDisplayNameOrder(&self, out: *mut ContactNameOrder) -> HRESULT,
    fn put_SystemDisplayNameOrder(&self, value: ContactNameOrder) -> HRESULT,
    fn get_SystemSortOrder(&self, out: *mut ContactNameOrder) -> HRESULT,
    fn put_SystemSortOrder(&self, value: ContactNameOrder) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut <super::super::system::User as RtType>::Abi) -> HRESULT
}}
impl IContactManagerForUser {
    #[cfg(feature="windows-storage")] #[inline] pub fn convert_contact_to_vcard_async(&self, contact: &Contact) -> Result<foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ConvertContactToVCardAsync)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn convert_contact_to_vcard_async_with_max_bytes(&self, contact: &Contact, maxBytes: u32) -> Result<foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ConvertContactToVCardAsyncWithMaxBytes)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, maxBytes, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn convert_vcard_to_contact_async(&self, vCard: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<foundation::IAsyncOperation<Contact>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ConvertVCardToContactAsync)(self.get_abi() as *const _ as *mut _, vCard.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_store_async(&self, accessType: ContactStoreAccessType) -> Result<foundation::IAsyncOperation<ContactStore>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestStoreAsync)(self.get_abi() as *const _ as *mut _, accessType, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_annotation_store_async(&self, accessType: ContactAnnotationStoreAccessType) -> Result<foundation::IAsyncOperation<ContactAnnotationStore>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestAnnotationStoreAsync)(self.get_abi() as *const _ as *mut _, accessType, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_system_display_name_order(&self) -> Result<ContactNameOrder> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SystemDisplayNameOrder)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_system_display_name_order(&self, value: ContactNameOrder) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SystemDisplayNameOrder)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_system_sort_order(&self) -> Result<ContactNameOrder> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SystemSortOrder)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_system_sort_order(&self, value: ContactNameOrder) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SystemSortOrder)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_user(&self) -> Result<Option<super::super::system::User>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_User)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::system::User::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactManagerForUser: IContactManagerForUser}
DEFINE_IID!(IID_IContactManagerForUser2, 1296473134, 15221, 19059, 187, 48, 115, 102, 69, 71, 34, 86);
RT_INTERFACE!{interface IContactManagerForUser2(IContactManagerForUser2Vtbl): IInspectable [IID_IContactManagerForUser2] {
    fn ShowFullContactCard(&self, contact: <Contact as RtType>::Abi, fullContactCardOptions: <FullContactCardOptions as RtType>::Abi) -> HRESULT
}}
impl IContactManagerForUser2 {
    #[inline] pub fn show_full_contact_card(&self, contact: &Contact, fullContactCardOptions: &FullContactCardOptions) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ShowFullContactCard)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, fullContactCardOptions.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContactManagerStatics, 2180127424, 63073, 18184, 186, 79, 211, 134, 189, 13, 98, 46);
RT_INTERFACE!{static interface IContactManagerStatics(IContactManagerStaticsVtbl): IInspectable [IID_IContactManagerStatics] {
    fn ShowContactCard(&self, contact: <Contact as RtType>::Abi, selection: foundation::Rect) -> HRESULT,
    #[cfg(feature="windows-ui")] fn ShowContactCardWithPlacement(&self, contact: <Contact as RtType>::Abi, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> HRESULT,
    #[cfg(feature="windows-ui")] fn ShowDelayLoadedContactCard(&self, contact: <Contact as RtType>::Abi, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, out: *mut <ContactCardDelayedDataLoader as RtType>::Abi) -> HRESULT
}}
impl IContactManagerStatics {
    #[inline] pub fn show_contact_card(&self, contact: &Contact, selection: foundation::Rect) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ShowContactCard)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, selection);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_contact_card_with_placement(&self, contact: &Contact, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ShowContactCardWithPlacement)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, selection, preferredPlacement);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_delay_loaded_contact_card(&self, contact: &Contact, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<Option<ContactCardDelayedDataLoader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowDelayLoadedContactCard)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, selection, preferredPlacement, &mut out);
        if hr == S_OK { Ok(ContactCardDelayedDataLoader::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContactManagerStatics2, 2709055008, 18392, 18636, 150, 60, 149, 146, 182, 229, 16, 198);
RT_INTERFACE!{static interface IContactManagerStatics2(IContactManagerStatics2Vtbl): IInspectable [IID_IContactManagerStatics2] {
    fn RequestStoreAsync(&self, out: *mut <foundation::IAsyncOperation<ContactStore> as RtType>::Abi) -> HRESULT
}}
impl IContactManagerStatics2 {
    #[inline] pub fn request_store_async(&self) -> Result<foundation::IAsyncOperation<ContactStore>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestStoreAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContactManagerStatics3, 3301719362, 30086, 18730, 147, 11, 123, 193, 56, 252, 33, 57);
RT_INTERFACE!{static interface IContactManagerStatics3(IContactManagerStatics3Vtbl): IInspectable [IID_IContactManagerStatics3] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn ConvertContactToVCardAsync(&self, contact: <Contact as RtType>::Abi, out: *mut <foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn ConvertContactToVCardAsyncWithMaxBytes(&self, contact: <Contact as RtType>::Abi, maxBytes: u32, out: *mut <foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn ConvertVCardToContactAsync(&self, vCard: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi, out: *mut <foundation::IAsyncOperation<Contact> as RtType>::Abi) -> HRESULT,
    fn RequestStoreAsyncWithAccessType(&self, accessType: ContactStoreAccessType, out: *mut <foundation::IAsyncOperation<ContactStore> as RtType>::Abi) -> HRESULT,
    fn RequestAnnotationStoreAsync(&self, accessType: ContactAnnotationStoreAccessType, out: *mut <foundation::IAsyncOperation<ContactAnnotationStore> as RtType>::Abi) -> HRESULT,
    fn IsShowContactCardSupported(&self, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowContactCardWithOptions(&self, contact: <Contact as RtType>::Abi, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, contactCardOptions: <ContactCardOptions as RtType>::Abi) -> HRESULT,
    fn IsShowDelayLoadedContactCardSupported(&self, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowDelayLoadedContactCardWithOptions(&self, contact: <Contact as RtType>::Abi, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, contactCardOptions: <ContactCardOptions as RtType>::Abi, out: *mut <ContactCardDelayedDataLoader as RtType>::Abi) -> HRESULT,
    fn ShowFullContactCard(&self, contact: <Contact as RtType>::Abi, fullContactCardOptions: <FullContactCardOptions as RtType>::Abi) -> HRESULT,
    fn get_SystemDisplayNameOrder(&self, out: *mut ContactNameOrder) -> HRESULT,
    fn put_SystemDisplayNameOrder(&self, value: ContactNameOrder) -> HRESULT,
    fn get_SystemSortOrder(&self, out: *mut ContactNameOrder) -> HRESULT,
    fn put_SystemSortOrder(&self, value: ContactNameOrder) -> HRESULT
}}
impl IContactManagerStatics3 {
    #[cfg(feature="windows-storage")] #[inline] pub fn convert_contact_to_vcard_async(&self, contact: &Contact) -> Result<foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ConvertContactToVCardAsync)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn convert_contact_to_vcard_async_with_max_bytes(&self, contact: &Contact, maxBytes: u32) -> Result<foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ConvertContactToVCardAsyncWithMaxBytes)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, maxBytes, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn convert_vcard_to_contact_async(&self, vCard: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<foundation::IAsyncOperation<Contact>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ConvertVCardToContactAsync)(self.get_abi() as *const _ as *mut _, vCard.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_store_async_with_access_type(&self, accessType: ContactStoreAccessType) -> Result<foundation::IAsyncOperation<ContactStore>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestStoreAsyncWithAccessType)(self.get_abi() as *const _ as *mut _, accessType, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_annotation_store_async(&self, accessType: ContactAnnotationStoreAccessType) -> Result<foundation::IAsyncOperation<ContactAnnotationStore>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestAnnotationStoreAsync)(self.get_abi() as *const _ as *mut _, accessType, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_show_contact_card_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().IsShowContactCardSupported)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_contact_card_with_options(&self, contact: &Contact, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, contactCardOptions: &ContactCardOptions) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ShowContactCardWithOptions)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, selection, preferredPlacement, contactCardOptions.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn is_show_delay_loaded_contact_card_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().IsShowDelayLoadedContactCardSupported)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_delay_loaded_contact_card_with_options(&self, contact: &Contact, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, contactCardOptions: &ContactCardOptions) -> Result<Option<ContactCardDelayedDataLoader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowDelayLoadedContactCardWithOptions)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, selection, preferredPlacement, contactCardOptions.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContactCardDelayedDataLoader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_full_contact_card(&self, contact: &Contact, fullContactCardOptions: &FullContactCardOptions) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ShowFullContactCard)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, fullContactCardOptions.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_system_display_name_order(&self) -> Result<ContactNameOrder> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SystemDisplayNameOrder)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_system_display_name_order(&self, value: ContactNameOrder) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SystemDisplayNameOrder)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_system_sort_order(&self) -> Result<ContactNameOrder> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SystemSortOrder)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_system_sort_order(&self, value: ContactNameOrder) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SystemSortOrder)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContactManagerStatics4, 613950066, 13435, 18140, 141, 149, 81, 189, 65, 225, 90, 175);
RT_INTERFACE!{static interface IContactManagerStatics4(IContactManagerStatics4Vtbl): IInspectable [IID_IContactManagerStatics4] {
    #[cfg(feature="windows-system")] fn GetForUser(&self, user: <super::super::system::User as RtType>::Abi, out: *mut <ContactManagerForUser as RtType>::Abi) -> HRESULT
}}
impl IContactManagerStatics4 {
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(&self, user: &super::super::system::User) -> Result<Option<ContactManagerForUser>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetForUser)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContactManagerForUser::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContactManagerStatics5, 4149811847, 44215, 20397, 144, 242, 168, 171, 100, 205, 187, 164);
RT_INTERFACE!{static interface IContactManagerStatics5(IContactManagerStatics5Vtbl): IInspectable [IID_IContactManagerStatics5] {
    fn IsShowFullContactCardSupportedAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn get_IncludeMiddleNameInSystemDisplayAndSort(&self, out: *mut bool) -> HRESULT,
    fn put_IncludeMiddleNameInSystemDisplayAndSort(&self, value: bool) -> HRESULT
}}
impl IContactManagerStatics5 {
    #[inline] pub fn is_show_full_contact_card_supported_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().IsShowFullContactCardSupportedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_include_middle_name_in_system_display_and_sort(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IncludeMiddleNameInSystemDisplayAndSort)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_include_middle_name_in_system_display_and_sort(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IncludeMiddleNameInSystemDisplayAndSort)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContactMatchReason, 3163694340, 59352, 16702, 149, 244, 183, 92, 84, 199, 64, 119);
RT_INTERFACE!{interface IContactMatchReason(IContactMatchReasonVtbl): IInspectable [IID_IContactMatchReason] {
    fn get_Field(&self, out: *mut ContactMatchReasonKind) -> HRESULT,
    #[cfg(not(feature="windows-data"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-data")] fn get_Segments(&self, out: *mut <foundation::collections::IVectorView<super::super::data::text::TextSegment> as RtType>::Abi) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT
}}
impl IContactMatchReason {
    #[inline] pub fn get_field(&self) -> Result<ContactMatchReasonKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Field)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-data")] #[inline] pub fn get_segments(&self) -> Result<Option<foundation::collections::IVectorView<super::super::data::text::TextSegment>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Segments)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Text)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactMatchReason: IContactMatchReason}
RT_ENUM! { enum ContactMatchReasonKind: i32 {
    Name = 0, EmailAddress = 1, PhoneNumber = 2, JobInfo = 3, YomiName = 4, Other = 5,
}}
DEFINE_IID!(IID_IContactName, 4093962619, 36916, 17724, 142, 191, 20, 10, 56, 200, 111, 29);
RT_INTERFACE!{interface IContactName(IContactNameVtbl): IInspectable [IID_IContactName] {
    fn get_FirstName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_FirstName(&self, value: HSTRING) -> HRESULT,
    fn get_LastName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_LastName(&self, value: HSTRING) -> HRESULT,
    fn get_MiddleName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_MiddleName(&self, value: HSTRING) -> HRESULT,
    fn get_YomiGivenName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_YomiGivenName(&self, value: HSTRING) -> HRESULT,
    fn get_YomiFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_YomiFamilyName(&self, value: HSTRING) -> HRESULT,
    fn get_HonorificNameSuffix(&self, out: *mut HSTRING) -> HRESULT,
    fn put_HonorificNameSuffix(&self, value: HSTRING) -> HRESULT,
    fn get_HonorificNamePrefix(&self, out: *mut HSTRING) -> HRESULT,
    fn put_HonorificNamePrefix(&self, value: HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_YomiDisplayName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IContactName {
    #[inline] pub fn get_first_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_FirstName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_first_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_FirstName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_last_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LastName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_last_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_LastName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_middle_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MiddleName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_middle_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MiddleName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_yomi_given_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_YomiGivenName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_yomi_given_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_YomiGivenName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_yomi_family_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_YomiFamilyName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_yomi_family_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_YomiFamilyName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_honorific_name_suffix(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_HonorificNameSuffix)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_honorific_name_suffix(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_HonorificNameSuffix)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_honorific_name_prefix(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_HonorificNamePrefix)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_honorific_name_prefix(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_HonorificNamePrefix)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_yomi_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_YomiDisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ContactNameOrder: i32 {
    FirstNameLastName = 0, LastNameFirstName = 1,
}}
DEFINE_IID!(IID_IContactPanel, 1103041125, 53998, 19351, 168, 10, 125, 141, 100, 204, 166, 245);
RT_INTERFACE!{interface IContactPanel(IContactPanelVtbl): IInspectable [IID_IContactPanel] {
    fn ClosePanel(&self) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_HeaderColor(&self, out: *mut <foundation::IReference<super::super::ui::Color> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_HeaderColor(&self, value: <foundation::IReference<super::super::ui::Color> as RtType>::Abi) -> HRESULT,
    fn add_LaunchFullAppRequested(&self, handler: <foundation::TypedEventHandler<ContactPanel, ContactPanelLaunchFullAppRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LaunchFullAppRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Closing(&self, handler: <foundation::TypedEventHandler<ContactPanel, ContactPanelClosingEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closing(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IContactPanel {
    #[inline] pub fn close_panel(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ClosePanel)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_header_color(&self) -> Result<Option<foundation::IReference<super::super::ui::Color>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_HeaderColor)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_header_color(&self, value: &foundation::IReference<super::super::ui::Color>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_HeaderColor)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_launch_full_app_requested(&self, handler: &foundation::TypedEventHandler<ContactPanel, ContactPanelLaunchFullAppRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_LaunchFullAppRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_launch_full_app_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_LaunchFullAppRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_closing(&self, handler: &foundation::TypedEventHandler<ContactPanel, ContactPanelClosingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_Closing)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_closing(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_Closing)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactPanel: IContactPanel}
DEFINE_IID!(IID_IContactPanelClosingEventArgs, 572617939, 53067, 18135, 183, 57, 110, 220, 22, 17, 11, 251);
RT_INTERFACE!{interface IContactPanelClosingEventArgs(IContactPanelClosingEventArgsVtbl): IInspectable [IID_IContactPanelClosingEventArgs] {
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IContactPanelClosingEventArgs {
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactPanelClosingEventArgs: IContactPanelClosingEventArgs}
DEFINE_IID!(IID_IContactPanelLaunchFullAppRequestedEventArgs, 2295733262, 9140, 19432, 138, 252, 7, 44, 37, 164, 25, 13);
RT_INTERFACE!{interface IContactPanelLaunchFullAppRequestedEventArgs(IContactPanelLaunchFullAppRequestedEventArgsVtbl): IInspectable [IID_IContactPanelLaunchFullAppRequestedEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT
}}
impl IContactPanelLaunchFullAppRequestedEventArgs {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Handled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Handled)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactPanelLaunchFullAppRequestedEventArgs: IContactPanelLaunchFullAppRequestedEventArgs}
DEFINE_IID!(IID_IContactPhone, 1182640997, 10002, 20306, 183, 131, 158, 168, 17, 28, 99, 205);
RT_INTERFACE!{interface IContactPhone(IContactPhoneVtbl): IInspectable [IID_IContactPhone] {
    fn get_Number(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Number(&self, value: HSTRING) -> HRESULT,
    fn get_Kind(&self, out: *mut ContactPhoneKind) -> HRESULT,
    fn put_Kind(&self, value: ContactPhoneKind) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT
}}
impl IContactPhone {
    #[inline] pub fn get_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Number)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_number(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Number)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_kind(&self) -> Result<ContactPhoneKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Kind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_kind(&self, value: ContactPhoneKind) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Kind)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Description)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_description(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Description)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactPhone: IContactPhone}
impl RtActivatable<IActivationFactory> for ContactPhone {}
DEFINE_CLSID!(ContactPhone(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,110,116,97,99,116,115,46,67,111,110,116,97,99,116,80,104,111,110,101,0]) [CLSID_ContactPhone]);
RT_ENUM! { enum ContactPhoneKind: i32 {
    Home = 0, Mobile = 1, Work = 2, Other = 3, Pager = 4, BusinessFax = 5, HomeFax = 6, Company = 7, Assistant = 8, Radio = 9,
}}
DEFINE_IID!(IID_IContactPicker, 235535761, 17144, 16469, 144, 160, 137, 111, 150, 115, 137, 54);
RT_INTERFACE!{interface IContactPicker(IContactPickerVtbl): IInspectable [IID_IContactPicker] {
    fn get_CommitButtonText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CommitButtonText(&self, value: HSTRING) -> HRESULT,
    fn get_SelectionMode(&self, out: *mut ContactSelectionMode) -> HRESULT,
    fn put_SelectionMode(&self, value: ContactSelectionMode) -> HRESULT,
    fn get_DesiredFields(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT,
    fn PickSingleContactAsync(&self, out: *mut <foundation::IAsyncOperation<ContactInformation> as RtType>::Abi) -> HRESULT,
    fn PickMultipleContactsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<ContactInformation>> as RtType>::Abi) -> HRESULT
}}
impl IContactPicker {
    #[inline] pub fn get_commit_button_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CommitButtonText)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_commit_button_text(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CommitButtonText)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_selection_mode(&self) -> Result<ContactSelectionMode> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SelectionMode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_selection_mode(&self, value: ContactSelectionMode) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SelectionMode)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_desired_fields(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DesiredFields)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn pick_single_contact_async(&self) -> Result<foundation::IAsyncOperation<ContactInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().PickSingleContactAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn pick_multiple_contacts_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<ContactInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().PickMultipleContactsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactPicker: IContactPicker}
impl RtActivatable<IContactPickerStatics> for ContactPicker {}
impl RtActivatable<IActivationFactory> for ContactPicker {}
impl ContactPicker {
    #[cfg(feature="windows-system")] #[inline] pub fn create_for_user(user: &super::super::system::User) -> Result<Option<ContactPicker>> {
        <Self as RtActivatable<IContactPickerStatics>>::get_activation_factory().create_for_user(user)
    }
    #[inline] pub fn is_supported_async() -> Result<foundation::IAsyncOperation<bool>> {
        <Self as RtActivatable<IContactPickerStatics>>::get_activation_factory().is_supported_async()
    }
}
DEFINE_CLSID!(ContactPicker(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,110,116,97,99,116,115,46,67,111,110,116,97,99,116,80,105,99,107,101,114,0]) [CLSID_ContactPicker]);
DEFINE_IID!(IID_IContactPicker2, 3008369103, 23791, 19748, 170, 12, 52, 12, 82, 8, 114, 93);
RT_INTERFACE!{interface IContactPicker2(IContactPicker2Vtbl): IInspectable [IID_IContactPicker2] {
    fn get_DesiredFieldsWithContactFieldType(&self, out: *mut <foundation::collections::IVector<ContactFieldType> as RtType>::Abi) -> HRESULT,
    fn PickContactAsync(&self, out: *mut <foundation::IAsyncOperation<Contact> as RtType>::Abi) -> HRESULT,
    fn PickContactsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVector<Contact>> as RtType>::Abi) -> HRESULT
}}
impl IContactPicker2 {
    #[inline] pub fn get_desired_fields_with_contact_field_type(&self) -> Result<Option<foundation::collections::IVector<ContactFieldType>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DesiredFieldsWithContactFieldType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn pick_contact_async(&self) -> Result<foundation::IAsyncOperation<Contact>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().PickContactAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn pick_contacts_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVector<Contact>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().PickContactsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContactPicker3, 242365205, 45635, 19437, 133, 22, 34, 177, 167, 172, 10, 206);
RT_INTERFACE!{interface IContactPicker3(IContactPicker3Vtbl): IInspectable [IID_IContactPicker3] {
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut <super::super::system::User as RtType>::Abi) -> HRESULT
}}
impl IContactPicker3 {
    #[cfg(feature="windows-system")] #[inline] pub fn get_user(&self) -> Result<Option<super::super::system::User>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_User)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::system::User::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContactPickerStatics, 1955119145, 27219, 16984, 163, 233, 98, 223, 246, 120, 75, 108);
RT_INTERFACE!{static interface IContactPickerStatics(IContactPickerStaticsVtbl): IInspectable [IID_IContactPickerStatics] {
    #[cfg(not(feature="windows-system"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-system")] fn CreateForUser(&self, user: <super::super::system::User as RtType>::Abi, out: *mut <ContactPicker as RtType>::Abi) -> HRESULT,
    fn IsSupportedAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl IContactPickerStatics {
    #[cfg(feature="windows-system")] #[inline] pub fn create_for_user(&self, user: &super::super::system::User) -> Result<Option<ContactPicker>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateForUser)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContactPicker::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_supported_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().IsSupportedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ContactQueryDesiredFields: u32 {
    None = 0, PhoneNumber = 1, EmailAddress = 2, PostalAddress = 4,
}}
DEFINE_IID!(IID_IContactQueryOptions, 1141427358, 32124, 17136, 138, 199, 245, 7, 51, 236, 219, 193);
RT_INTERFACE!{interface IContactQueryOptions(IContactQueryOptionsVtbl): IInspectable [IID_IContactQueryOptions] {
    fn get_TextSearch(&self, out: *mut <ContactQueryTextSearch as RtType>::Abi) -> HRESULT,
    fn get_ContactListIds(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT,
    fn get_IncludeContactsFromHiddenLists(&self, out: *mut bool) -> HRESULT,
    fn put_IncludeContactsFromHiddenLists(&self, value: bool) -> HRESULT,
    fn get_DesiredFields(&self, out: *mut ContactQueryDesiredFields) -> HRESULT,
    fn put_DesiredFields(&self, value: ContactQueryDesiredFields) -> HRESULT,
    fn get_DesiredOperations(&self, out: *mut ContactAnnotationOperations) -> HRESULT,
    fn put_DesiredOperations(&self, value: ContactAnnotationOperations) -> HRESULT,
    fn get_AnnotationListIds(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT
}}
impl IContactQueryOptions {
    #[inline] pub fn get_text_search(&self) -> Result<Option<ContactQueryTextSearch>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TextSearch)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContactQueryTextSearch::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_contact_list_ids(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContactListIds)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_include_contacts_from_hidden_lists(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IncludeContactsFromHiddenLists)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_include_contacts_from_hidden_lists(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IncludeContactsFromHiddenLists)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_desired_fields(&self) -> Result<ContactQueryDesiredFields> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DesiredFields)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_fields(&self, value: ContactQueryDesiredFields) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DesiredFields)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_desired_operations(&self) -> Result<ContactAnnotationOperations> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DesiredOperations)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_operations(&self, value: ContactAnnotationOperations) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DesiredOperations)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_annotation_list_ids(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AnnotationListIds)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactQueryOptions: IContactQueryOptions}
impl RtActivatable<IContactQueryOptionsFactory> for ContactQueryOptions {}
impl RtActivatable<IActivationFactory> for ContactQueryOptions {}
impl ContactQueryOptions {
    #[inline] pub fn create_with_text(text: &HStringArg) -> Result<ContactQueryOptions> {
        <Self as RtActivatable<IContactQueryOptionsFactory>>::get_activation_factory().create_with_text(text)
    }
    #[inline] pub fn create_with_text_and_fields(text: &HStringArg, fields: ContactQuerySearchFields) -> Result<ContactQueryOptions> {
        <Self as RtActivatable<IContactQueryOptionsFactory>>::get_activation_factory().create_with_text_and_fields(text, fields)
    }
}
DEFINE_CLSID!(ContactQueryOptions(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,110,116,97,99,116,115,46,67,111,110,116,97,99,116,81,117,101,114,121,79,112,116,105,111,110,115,0]) [CLSID_ContactQueryOptions]);
DEFINE_IID!(IID_IContactQueryOptionsFactory, 1413462599, 36071, 18123, 157, 172, 154, 164, 42, 27, 200, 226);
RT_INTERFACE!{static interface IContactQueryOptionsFactory(IContactQueryOptionsFactoryVtbl): IInspectable [IID_IContactQueryOptionsFactory] {
    fn CreateWithText(&self, text: HSTRING, out: *mut <ContactQueryOptions as RtType>::Abi) -> HRESULT,
    fn CreateWithTextAndFields(&self, text: HSTRING, fields: ContactQuerySearchFields, out: *mut <ContactQueryOptions as RtType>::Abi) -> HRESULT
}}
impl IContactQueryOptionsFactory {
    #[inline] pub fn create_with_text(&self, text: &HStringArg) -> Result<ContactQueryOptions> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWithText)(self.get_abi() as *const _ as *mut _, text.get(), &mut out);
        if hr == S_OK { Ok(ContactQueryOptions::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_text_and_fields(&self, text: &HStringArg, fields: ContactQuerySearchFields) -> Result<ContactQueryOptions> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWithTextAndFields)(self.get_abi() as *const _ as *mut _, text.get(), fields, &mut out);
        if hr == S_OK { Ok(ContactQueryOptions::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ContactQuerySearchFields: u32 {
    None = 0, Name = 1, Email = 2, Phone = 4, All = 4294967295,
}}
RT_ENUM! { enum ContactQuerySearchScope: i32 {
    Local = 0, Server = 1,
}}
DEFINE_IID!(IID_IContactQueryTextSearch, 4158912971, 43351, 17307, 160, 183, 28, 2, 161, 150, 63, 240);
RT_INTERFACE!{interface IContactQueryTextSearch(IContactQueryTextSearchVtbl): IInspectable [IID_IContactQueryTextSearch] {
    fn get_Fields(&self, out: *mut ContactQuerySearchFields) -> HRESULT,
    fn put_Fields(&self, value: ContactQuerySearchFields) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Text(&self, value: HSTRING) -> HRESULT,
    fn get_SearchScope(&self, out: *mut ContactQuerySearchScope) -> HRESULT,
    fn put_SearchScope(&self, value: ContactQuerySearchScope) -> HRESULT
}}
impl IContactQueryTextSearch {
    #[inline] pub fn get_fields(&self) -> Result<ContactQuerySearchFields> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Fields)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_fields(&self, value: ContactQuerySearchFields) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Fields)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Text)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_text(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Text)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_search_scope(&self) -> Result<ContactQuerySearchScope> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SearchScope)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_search_scope(&self, value: ContactQuerySearchScope) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SearchScope)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactQueryTextSearch: IContactQueryTextSearch}
DEFINE_IID!(IID_IContactReader, 3549946926, 5256, 17138, 191, 100, 37, 63, 72, 132, 191, 237);
RT_INTERFACE!{interface IContactReader(IContactReaderVtbl): IInspectable [IID_IContactReader] {
    fn ReadBatchAsync(&self, out: *mut <foundation::IAsyncOperation<ContactBatch> as RtType>::Abi) -> HRESULT,
    fn GetMatchingPropertiesWithMatchReason(&self, contact: <Contact as RtType>::Abi, out: *mut <foundation::collections::IVectorView<ContactMatchReason> as RtType>::Abi) -> HRESULT
}}
impl IContactReader {
    #[inline] pub fn read_batch_async(&self) -> Result<foundation::IAsyncOperation<ContactBatch>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReadBatchAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_matching_properties_with_match_reason(&self, contact: &Contact) -> Result<Option<foundation::collections::IVectorView<ContactMatchReason>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetMatchingPropertiesWithMatchReason)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactReader: IContactReader}
RT_ENUM! { enum ContactRelationship: i32 {
    Other = 0, Spouse = 1, Partner = 2, Sibling = 3, Parent = 4, Child = 5,
}}
RT_ENUM! { enum ContactSelectionMode: i32 {
    Contacts = 0, Fields = 1,
}}
DEFINE_IID!(IID_IContactSignificantOther, 2289284523, 50683, 18136, 147, 254, 218, 63, 241, 147, 64, 84);
RT_INTERFACE!{interface IContactSignificantOther(IContactSignificantOtherVtbl): IInspectable [IID_IContactSignificantOther] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT
}}
impl IContactSignificantOther {
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Name)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Name)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Description)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_description(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Description)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactSignificantOther: IContactSignificantOther}
impl RtActivatable<IActivationFactory> for ContactSignificantOther {}
DEFINE_CLSID!(ContactSignificantOther(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,110,116,97,99,116,115,46,67,111,110,116,97,99,116,83,105,103,110,105,102,105,99,97,110,116,79,116,104,101,114,0]) [CLSID_ContactSignificantOther]);
DEFINE_IID!(IID_IContactSignificantOther2, 2373702772, 16131, 17912, 186, 15, 196, 237, 55, 214, 66, 25);
RT_INTERFACE!{interface IContactSignificantOther2(IContactSignificantOther2Vtbl): IInspectable [IID_IContactSignificantOther2] {
    fn get_Relationship(&self, out: *mut ContactRelationship) -> HRESULT,
    fn put_Relationship(&self, value: ContactRelationship) -> HRESULT
}}
impl IContactSignificantOther2 {
    #[inline] pub fn get_relationship(&self) -> Result<ContactRelationship> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Relationship)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_relationship(&self, value: ContactRelationship) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Relationship)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContactStore, 740428560, 14956, 17043, 185, 188, 254, 152, 127, 110, 13, 82);
RT_INTERFACE!{interface IContactStore(IContactStoreVtbl): IInspectable [IID_IContactStore] {
    fn FindContactsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<Contact>> as RtType>::Abi) -> HRESULT,
    fn FindContactsWithSearchTextAsync(&self, searchText: HSTRING, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<Contact>> as RtType>::Abi) -> HRESULT,
    fn GetContactAsync(&self, contactId: HSTRING, out: *mut <foundation::IAsyncOperation<Contact> as RtType>::Abi) -> HRESULT
}}
impl IContactStore {
    #[inline] pub fn find_contacts_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<Contact>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindContactsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_contacts_with_search_text_async(&self, searchText: &HStringArg) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<Contact>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindContactsWithSearchTextAsync)(self.get_abi() as *const _ as *mut _, searchText.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_contact_async(&self, contactId: &HStringArg) -> Result<foundation::IAsyncOperation<Contact>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetContactAsync)(self.get_abi() as *const _ as *mut _, contactId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactStore: IContactStore}
DEFINE_IID!(IID_IContactStore2, 416160802, 60373, 19451, 182, 144, 95, 79, 39, 196, 240, 232);
RT_INTERFACE!{interface IContactStore2(IContactStore2Vtbl): IInspectable [IID_IContactStore2] {
    fn get_ChangeTracker(&self, out: *mut <ContactChangeTracker as RtType>::Abi) -> HRESULT,
    fn add_ContactChanged(&self, value: <foundation::TypedEventHandler<ContactStore, ContactChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ContactChanged(&self, value: foundation::EventRegistrationToken) -> HRESULT,
    fn get_AggregateContactManager(&self, out: *mut <AggregateContactManager as RtType>::Abi) -> HRESULT,
    fn FindContactListsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<ContactList>> as RtType>::Abi) -> HRESULT,
    fn GetContactListAsync(&self, contactListId: HSTRING, out: *mut <foundation::IAsyncOperation<ContactList> as RtType>::Abi) -> HRESULT,
    fn CreateContactListAsync(&self, displayName: HSTRING, out: *mut <foundation::IAsyncOperation<ContactList> as RtType>::Abi) -> HRESULT,
    fn GetMeContactAsync(&self, out: *mut <foundation::IAsyncOperation<Contact> as RtType>::Abi) -> HRESULT,
    fn GetContactReader(&self, out: *mut <ContactReader as RtType>::Abi) -> HRESULT,
    fn GetContactReaderWithOptions(&self, options: <ContactQueryOptions as RtType>::Abi, out: *mut <ContactReader as RtType>::Abi) -> HRESULT,
    fn CreateContactListInAccountAsync(&self, displayName: HSTRING, userDataAccountId: HSTRING, out: *mut <foundation::IAsyncOperation<ContactList> as RtType>::Abi) -> HRESULT
}}
impl IContactStore2 {
    #[inline] pub fn get_change_tracker(&self) -> Result<Option<ContactChangeTracker>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ChangeTracker)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContactChangeTracker::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_contact_changed(&self, value: &foundation::TypedEventHandler<ContactStore, ContactChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_ContactChanged)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_contact_changed(&self, value: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_ContactChanged)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_aggregate_contact_manager(&self) -> Result<Option<AggregateContactManager>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AggregateContactManager)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AggregateContactManager::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_contact_lists_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<ContactList>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindContactListsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_contact_list_async(&self, contactListId: &HStringArg) -> Result<foundation::IAsyncOperation<ContactList>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetContactListAsync)(self.get_abi() as *const _ as *mut _, contactListId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_contact_list_async(&self, displayName: &HStringArg) -> Result<foundation::IAsyncOperation<ContactList>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateContactListAsync)(self.get_abi() as *const _ as *mut _, displayName.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_me_contact_async(&self) -> Result<foundation::IAsyncOperation<Contact>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetMeContactAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_contact_reader(&self) -> Result<Option<ContactReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetContactReader)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContactReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_contact_reader_with_options(&self, options: &ContactQueryOptions) -> Result<Option<ContactReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetContactReaderWithOptions)(self.get_abi() as *const _ as *mut _, options.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContactReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_contact_list_in_account_async(&self, displayName: &HStringArg, userDataAccountId: &HStringArg) -> Result<foundation::IAsyncOperation<ContactList>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateContactListInAccountAsync)(self.get_abi() as *const _ as *mut _, displayName.get(), userDataAccountId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContactStore3, 3414699116, 78, 16464, 135, 240, 132, 4, 7, 238, 104, 24);
RT_INTERFACE!{interface IContactStore3(IContactStore3Vtbl): IInspectable [IID_IContactStore3] {
    fn GetChangeTracker(&self, identity: HSTRING, out: *mut <ContactChangeTracker as RtType>::Abi) -> HRESULT
}}
impl IContactStore3 {
    #[inline] pub fn get_change_tracker(&self, identity: &HStringArg) -> Result<Option<ContactChangeTracker>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetChangeTracker)(self.get_abi() as *const _ as *mut _, identity.get(), &mut out);
        if hr == S_OK { Ok(ContactChangeTracker::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ContactStoreAccessType: i32 {
    AppContactsReadWrite = 0, AllContactsReadOnly = 1, AllContactsReadWrite = 2,
}}
DEFINE_IID!(IID_IContactStoreNotificationTriggerDetails, 2880608470, 34698, 20363, 169, 206, 70, 187, 125, 28, 132, 206);
RT_INTERFACE!{interface IContactStoreNotificationTriggerDetails(IContactStoreNotificationTriggerDetailsVtbl): IInspectable [IID_IContactStoreNotificationTriggerDetails] {
    
}}
RT_CLASS!{class ContactStoreNotificationTriggerDetails: IContactStoreNotificationTriggerDetails}
DEFINE_IID!(IID_IContactWebsite, 2668822902, 56347, 16469, 173, 102, 101, 47, 57, 217, 144, 232);
RT_INTERFACE!{interface IContactWebsite(IContactWebsiteVtbl): IInspectable [IID_IContactWebsite] {
    fn get_Uri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_Uri(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT
}}
impl IContactWebsite {
    #[inline] pub fn get_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Uri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Uri)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Description)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_description(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Description)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactWebsite: IContactWebsite}
impl RtActivatable<IActivationFactory> for ContactWebsite {}
DEFINE_CLSID!(ContactWebsite(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,110,116,97,99,116,115,46,67,111,110,116,97,99,116,87,101,98,115,105,116,101,0]) [CLSID_ContactWebsite]);
DEFINE_IID!(IID_IContactWebsite2, 4169066782, 22087, 16488, 187, 94, 75, 111, 67, 124, 227, 8);
RT_INTERFACE!{interface IContactWebsite2(IContactWebsite2Vtbl): IInspectable [IID_IContactWebsite2] {
    fn get_RawValue(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RawValue(&self, value: HSTRING) -> HRESULT
}}
impl IContactWebsite2 {
    #[inline] pub fn get_raw_value(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RawValue)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_raw_value(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RawValue)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IFullContactCardOptions, 2269397868, 23801, 18051, 189, 202, 161, 253, 235, 248, 219, 206);
RT_INTERFACE!{interface IFullContactCardOptions(IFullContactCardOptionsVtbl): IInspectable [IID_IFullContactCardOptions] {
    #[cfg(feature="windows-ui")] fn get_DesiredRemainingView(&self, out: *mut super::super::ui::viewmanagement::ViewSizePreference) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_DesiredRemainingView(&self, value: super::super::ui::viewmanagement::ViewSizePreference) -> HRESULT
}}
impl IFullContactCardOptions {
    #[cfg(feature="windows-ui")] #[inline] pub fn get_desired_remaining_view(&self) -> Result<super::super::ui::viewmanagement::ViewSizePreference> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DesiredRemainingView)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_desired_remaining_view(&self, value: super::super::ui::viewmanagement::ViewSizePreference) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DesiredRemainingView)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class FullContactCardOptions: IFullContactCardOptions}
impl RtActivatable<IActivationFactory> for FullContactCardOptions {}
DEFINE_CLSID!(FullContactCardOptions(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,110,116,97,99,116,115,46,70,117,108,108,67,111,110,116,97,99,116,67,97,114,100,79,112,116,105,111,110,115,0]) [CLSID_FullContactCardOptions]);
RT_CLASS!{static class KnownContactField}
impl RtActivatable<IKnownContactFieldStatics> for KnownContactField {}
impl KnownContactField {
    #[inline] pub fn get_email() -> Result<HString> {
        <Self as RtActivatable<IKnownContactFieldStatics>>::get_activation_factory().get_email()
    }
    #[inline] pub fn get_phone_number() -> Result<HString> {
        <Self as RtActivatable<IKnownContactFieldStatics>>::get_activation_factory().get_phone_number()
    }
    #[inline] pub fn get_location() -> Result<HString> {
        <Self as RtActivatable<IKnownContactFieldStatics>>::get_activation_factory().get_location()
    }
    #[inline] pub fn get_instant_message() -> Result<HString> {
        <Self as RtActivatable<IKnownContactFieldStatics>>::get_activation_factory().get_instant_message()
    }
    #[inline] pub fn convert_name_to_type(name: &HStringArg) -> Result<ContactFieldType> {
        <Self as RtActivatable<IKnownContactFieldStatics>>::get_activation_factory().convert_name_to_type(name)
    }
    #[inline] pub fn convert_type_to_name(type_: ContactFieldType) -> Result<HString> {
        <Self as RtActivatable<IKnownContactFieldStatics>>::get_activation_factory().convert_type_to_name(type_)
    }
}
DEFINE_CLSID!(KnownContactField(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,110,116,97,99,116,115,46,75,110,111,119,110,67,111,110,116,97,99,116,70,105,101,108,100,0]) [CLSID_KnownContactField]);
DEFINE_IID!(IID_IKnownContactFieldStatics, 772676370, 54823, 20426, 186, 212, 31, 175, 22, 140, 125, 20);
RT_INTERFACE!{static interface IKnownContactFieldStatics(IKnownContactFieldStaticsVtbl): IInspectable [IID_IKnownContactFieldStatics] {
    fn get_Email(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PhoneNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Location(&self, out: *mut HSTRING) -> HRESULT,
    fn get_InstantMessage(&self, out: *mut HSTRING) -> HRESULT,
    fn ConvertNameToType(&self, name: HSTRING, out: *mut ContactFieldType) -> HRESULT,
    fn ConvertTypeToName(&self, type_: ContactFieldType, out: *mut HSTRING) -> HRESULT
}}
impl IKnownContactFieldStatics {
    #[inline] pub fn get_email(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Email)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_phone_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PhoneNumber)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_location(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Location)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_instant_message(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_InstantMessage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn convert_name_to_type(&self, name: &HStringArg) -> Result<ContactFieldType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().ConvertNameToType)(self.get_abi() as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn convert_type_to_name(&self, type_: ContactFieldType) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ConvertTypeToName)(self.get_abi() as *const _ as *mut _, type_, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPinnedContactIdsQueryResult, 2107319634, 5497, 19932, 135, 31, 163, 10, 58, 234, 155, 161);
RT_INTERFACE!{interface IPinnedContactIdsQueryResult(IPinnedContactIdsQueryResultVtbl): IInspectable [IID_IPinnedContactIdsQueryResult] {
    fn get_ContactIds(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT
}}
impl IPinnedContactIdsQueryResult {
    #[inline] pub fn get_contact_ids(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContactIds)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PinnedContactIdsQueryResult: IPinnedContactIdsQueryResult}
DEFINE_IID!(IID_IPinnedContactManager, 4240208908, 57814, 17859, 184, 182, 163, 86, 4, 225, 103, 160);
RT_INTERFACE!{interface IPinnedContactManager(IPinnedContactManagerVtbl): IInspectable [IID_IPinnedContactManager] {
    #[cfg(not(feature="windows-system"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut <super::super::system::User as RtType>::Abi) -> HRESULT,
    fn IsPinSurfaceSupported(&self, surface: PinnedContactSurface, out: *mut bool) -> HRESULT,
    fn IsContactPinned(&self, contact: <Contact as RtType>::Abi, surface: PinnedContactSurface, out: *mut bool) -> HRESULT,
    fn RequestPinContactAsync(&self, contact: <Contact as RtType>::Abi, surface: PinnedContactSurface, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn RequestPinContactsAsync(&self, contacts: <foundation::collections::IIterable<Contact> as RtType>::Abi, surface: PinnedContactSurface, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn RequestUnpinContactAsync(&self, contact: <Contact as RtType>::Abi, surface: PinnedContactSurface, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn SignalContactActivity(&self, contact: <Contact as RtType>::Abi) -> HRESULT,
    fn GetPinnedContactIdsAsync(&self, out: *mut <foundation::IAsyncOperation<PinnedContactIdsQueryResult> as RtType>::Abi) -> HRESULT
}}
impl IPinnedContactManager {
    #[cfg(feature="windows-system")] #[inline] pub fn get_user(&self) -> Result<Option<super::super::system::User>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_User)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::system::User::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_pin_surface_supported(&self, surface: PinnedContactSurface) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().IsPinSurfaceSupported)(self.get_abi() as *const _ as *mut _, surface, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_contact_pinned(&self, contact: &Contact, surface: PinnedContactSurface) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().IsContactPinned)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, surface, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn request_pin_contact_async(&self, contact: &Contact, surface: PinnedContactSurface) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestPinContactAsync)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, surface, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_pin_contacts_async(&self, contacts: &foundation::collections::IIterable<Contact>, surface: PinnedContactSurface) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestPinContactsAsync)(self.get_abi() as *const _ as *mut _, contacts.get_abi() as *const _ as *mut _, surface, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_unpin_contact_async(&self, contact: &Contact, surface: PinnedContactSurface) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestUnpinContactAsync)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, surface, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn signal_contact_activity(&self, contact: &Contact) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SignalContactActivity)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_pinned_contact_ids_async(&self) -> Result<foundation::IAsyncOperation<PinnedContactIdsQueryResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetPinnedContactIdsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PinnedContactManager: IPinnedContactManager}
impl RtActivatable<IPinnedContactManagerStatics> for PinnedContactManager {}
impl PinnedContactManager {
    #[inline] pub fn get_default() -> Result<Option<PinnedContactManager>> {
        <Self as RtActivatable<IPinnedContactManagerStatics>>::get_activation_factory().get_default()
    }
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(user: &super::super::system::User) -> Result<Option<PinnedContactManager>> {
        <Self as RtActivatable<IPinnedContactManagerStatics>>::get_activation_factory().get_for_user(user)
    }
    #[inline] pub fn is_supported() -> Result<bool> {
        <Self as RtActivatable<IPinnedContactManagerStatics>>::get_activation_factory().is_supported()
    }
}
DEFINE_CLSID!(PinnedContactManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,110,116,97,99,116,115,46,80,105,110,110,101,100,67,111,110,116,97,99,116,77,97,110,97,103,101,114,0]) [CLSID_PinnedContactManager]);
DEFINE_IID!(IID_IPinnedContactManagerStatics, 4133276798, 65017, 18538, 172, 233, 188, 49, 29, 10, 231, 240);
RT_INTERFACE!{static interface IPinnedContactManagerStatics(IPinnedContactManagerStaticsVtbl): IInspectable [IID_IPinnedContactManagerStatics] {
    fn GetDefault(&self, out: *mut <PinnedContactManager as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-system")] fn GetForUser(&self, user: <super::super::system::User as RtType>::Abi, out: *mut <PinnedContactManager as RtType>::Abi) -> HRESULT,
    fn IsSupported(&self, out: *mut bool) -> HRESULT
}}
impl IPinnedContactManagerStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<PinnedContactManager>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDefault)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PinnedContactManager::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(&self, user: &super::super::system::User) -> Result<Option<PinnedContactManager>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetForUser)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PinnedContactManager::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().IsSupported)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum PinnedContactSurface: i32 {
    StartMenu = 0, Taskbar = 1,
}}
pub mod dataprovider { // Windows.ApplicationModel.Contacts.DataProvider
use crate::prelude::*;
DEFINE_IID!(IID_IContactDataProviderConnection, 439978578, 35997, 19823, 164, 224, 17, 30, 154, 18, 90, 48);
RT_INTERFACE!{interface IContactDataProviderConnection(IContactDataProviderConnectionVtbl): IInspectable [IID_IContactDataProviderConnection] {
    fn add_SyncRequested(&self, handler: <foundation::TypedEventHandler<ContactDataProviderConnection, ContactListSyncManagerSyncRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SyncRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ServerSearchReadBatchRequested(&self, handler: <foundation::TypedEventHandler<ContactDataProviderConnection, ContactListServerSearchReadBatchRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ServerSearchReadBatchRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn Start(&self) -> HRESULT
}}
impl IContactDataProviderConnection {
    #[inline] pub fn add_sync_requested(&self, handler: &foundation::TypedEventHandler<ContactDataProviderConnection, ContactListSyncManagerSyncRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_SyncRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_sync_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_SyncRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_server_search_read_batch_requested(&self, handler: &foundation::TypedEventHandler<ContactDataProviderConnection, ContactListServerSearchReadBatchRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_ServerSearchReadBatchRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_server_search_read_batch_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_ServerSearchReadBatchRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Start)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactDataProviderConnection: IContactDataProviderConnection}
DEFINE_IID!(IID_IContactDataProviderConnection2, 2714970032, 6508, 19453, 143, 15, 198, 141, 103, 242, 73, 211);
RT_INTERFACE!{interface IContactDataProviderConnection2(IContactDataProviderConnection2Vtbl): IInspectable [IID_IContactDataProviderConnection2] {
    fn add_CreateOrUpdateContactRequested(&self, handler: <foundation::TypedEventHandler<ContactDataProviderConnection, ContactListCreateOrUpdateContactRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CreateOrUpdateContactRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_DeleteContactRequested(&self, handler: <foundation::TypedEventHandler<ContactDataProviderConnection, ContactListDeleteContactRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DeleteContactRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IContactDataProviderConnection2 {
    #[inline] pub fn add_create_or_update_contact_requested(&self, handler: &foundation::TypedEventHandler<ContactDataProviderConnection, ContactListCreateOrUpdateContactRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_CreateOrUpdateContactRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_create_or_update_contact_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_CreateOrUpdateContactRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_delete_contact_requested(&self, handler: &foundation::TypedEventHandler<ContactDataProviderConnection, ContactListDeleteContactRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_DeleteContactRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_delete_contact_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_DeleteContactRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContactDataProviderTriggerDetails, 1383138494, 15458, 17352, 154, 231, 219, 83, 22, 133, 205, 153);
RT_INTERFACE!{interface IContactDataProviderTriggerDetails(IContactDataProviderTriggerDetailsVtbl): IInspectable [IID_IContactDataProviderTriggerDetails] {
    fn get_Connection(&self, out: *mut <ContactDataProviderConnection as RtType>::Abi) -> HRESULT
}}
impl IContactDataProviderTriggerDetails {
    #[inline] pub fn get_connection(&self) -> Result<Option<ContactDataProviderConnection>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Connection)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContactDataProviderConnection::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactDataProviderTriggerDetails: IContactDataProviderTriggerDetails}
DEFINE_IID!(IID_IContactListCreateOrUpdateContactRequest, 3031384351, 51273, 18384, 177, 25, 145, 207, 96, 91, 47, 42);
RT_INTERFACE!{interface IContactListCreateOrUpdateContactRequest(IContactListCreateOrUpdateContactRequestVtbl): IInspectable [IID_IContactListCreateOrUpdateContactRequest] {
    fn get_ContactListId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Contact(&self, out: *mut <super::Contact as RtType>::Abi) -> HRESULT,
    fn ReportCompletedAsync(&self, createdOrUpdatedContact: <super::Contact as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IContactListCreateOrUpdateContactRequest {
    #[inline] pub fn get_contact_list_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContactListId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_contact(&self) -> Result<Option<super::Contact>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Contact)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::Contact::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self, createdOrUpdatedContact: &super::Contact) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, createdOrUpdatedContact.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactListCreateOrUpdateContactRequest: IContactListCreateOrUpdateContactRequest}
DEFINE_IID!(IID_IContactListCreateOrUpdateContactRequestEventArgs, 2233210512, 6737, 19212, 174, 239, 18, 64, 172, 91, 237, 117);
RT_INTERFACE!{interface IContactListCreateOrUpdateContactRequestEventArgs(IContactListCreateOrUpdateContactRequestEventArgsVtbl): IInspectable [IID_IContactListCreateOrUpdateContactRequestEventArgs] {
    fn get_Request(&self, out: *mut <ContactListCreateOrUpdateContactRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IContactListCreateOrUpdateContactRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<ContactListCreateOrUpdateContactRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContactListCreateOrUpdateContactRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactListCreateOrUpdateContactRequestEventArgs: IContactListCreateOrUpdateContactRequestEventArgs}
DEFINE_IID!(IID_IContactListDeleteContactRequest, 1578190471, 52739, 19941, 133, 87, 156, 207, 85, 45, 71, 42);
RT_INTERFACE!{interface IContactListDeleteContactRequest(IContactListDeleteContactRequestVtbl): IInspectable [IID_IContactListDeleteContactRequest] {
    fn get_ContactListId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ContactId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IContactListDeleteContactRequest {
    #[inline] pub fn get_contact_list_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContactListId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_contact_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContactId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactListDeleteContactRequest: IContactListDeleteContactRequest}
DEFINE_IID!(IID_IContactListDeleteContactRequestEventArgs, 2988463265, 59642, 19893, 147, 137, 45, 18, 238, 125, 21, 238);
RT_INTERFACE!{interface IContactListDeleteContactRequestEventArgs(IContactListDeleteContactRequestEventArgsVtbl): IInspectable [IID_IContactListDeleteContactRequestEventArgs] {
    fn get_Request(&self, out: *mut <ContactListDeleteContactRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IContactListDeleteContactRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<ContactListDeleteContactRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContactListDeleteContactRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactListDeleteContactRequestEventArgs: IContactListDeleteContactRequestEventArgs}
DEFINE_IID!(IID_IContactListServerSearchReadBatchRequest, 3128388247, 16432, 18725, 159, 180, 20, 59, 41, 94, 101, 59);
RT_INTERFACE!{interface IContactListServerSearchReadBatchRequest(IContactListServerSearchReadBatchRequestVtbl): IInspectable [IID_IContactListServerSearchReadBatchRequest] {
    fn get_SessionId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ContactListId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Options(&self, out: *mut <super::ContactQueryOptions as RtType>::Abi) -> HRESULT,
    fn get_SuggestedBatchSize(&self, out: *mut u32) -> HRESULT,
    fn SaveContactAsync(&self, contact: <super::Contact as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, batchStatus: super::ContactBatchStatus, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IContactListServerSearchReadBatchRequest {
    #[inline] pub fn get_session_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SessionId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_contact_list_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContactListId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_options(&self) -> Result<Option<super::ContactQueryOptions>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Options)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::ContactQueryOptions::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_suggested_batch_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SuggestedBatchSize)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn save_contact_async(&self, contact: &super::Contact) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SaveContactAsync)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self, batchStatus: super::ContactBatchStatus) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, batchStatus, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactListServerSearchReadBatchRequest: IContactListServerSearchReadBatchRequest}
DEFINE_IID!(IID_IContactListServerSearchReadBatchRequestEventArgs, 438823035, 27095, 20046, 128, 66, 134, 28, 186, 97, 71, 30);
RT_INTERFACE!{interface IContactListServerSearchReadBatchRequestEventArgs(IContactListServerSearchReadBatchRequestEventArgsVtbl): IInspectable [IID_IContactListServerSearchReadBatchRequestEventArgs] {
    fn get_Request(&self, out: *mut <ContactListServerSearchReadBatchRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IContactListServerSearchReadBatchRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<ContactListServerSearchReadBatchRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContactListServerSearchReadBatchRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactListServerSearchReadBatchRequestEventArgs: IContactListServerSearchReadBatchRequestEventArgs}
DEFINE_IID!(IID_IContactListSyncManagerSyncRequest, 1007572900, 50407, 18800, 154, 143, 154, 102, 162, 187, 108, 26);
RT_INTERFACE!{interface IContactListSyncManagerSyncRequest(IContactListSyncManagerSyncRequestVtbl): IInspectable [IID_IContactListSyncManagerSyncRequest] {
    fn get_ContactListId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IContactListSyncManagerSyncRequest {
    #[inline] pub fn get_contact_list_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContactListId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactListSyncManagerSyncRequest: IContactListSyncManagerSyncRequest}
DEFINE_IID!(IID_IContactListSyncManagerSyncRequestEventArgs, 361647532, 17517, 20240, 175, 194, 2, 104, 62, 197, 51, 166);
RT_INTERFACE!{interface IContactListSyncManagerSyncRequestEventArgs(IContactListSyncManagerSyncRequestEventArgsVtbl): IInspectable [IID_IContactListSyncManagerSyncRequestEventArgs] {
    fn get_Request(&self, out: *mut <ContactListSyncManagerSyncRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IContactListSyncManagerSyncRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<ContactListSyncManagerSyncRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContactListSyncManagerSyncRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactListSyncManagerSyncRequestEventArgs: IContactListSyncManagerSyncRequestEventArgs}
} // Windows.ApplicationModel.Contacts.DataProvider
pub mod provider { // Windows.ApplicationModel.Contacts.Provider
use crate::prelude::*;
RT_ENUM! { enum AddContactResult: i32 {
    Added = 0, AlreadyAdded = 1, Unavailable = 2,
}}
DEFINE_IID!(IID_IContactPickerUI, 3805025126, 53094, 17348, 169, 106, 165, 161, 18, 219, 71, 70);
RT_INTERFACE!{interface IContactPickerUI(IContactPickerUIVtbl): IInspectable [IID_IContactPickerUI] {
    fn AddContact(&self, id: HSTRING, contact: <super::Contact as RtType>::Abi, out: *mut AddContactResult) -> HRESULT,
    fn RemoveContact(&self, id: HSTRING) -> HRESULT,
    fn ContainsContact(&self, id: HSTRING, out: *mut bool) -> HRESULT,
    fn get_DesiredFields(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT,
    fn get_SelectionMode(&self, out: *mut super::ContactSelectionMode) -> HRESULT,
    fn add_ContactRemoved(&self, handler: <foundation::TypedEventHandler<ContactPickerUI, ContactRemovedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ContactRemoved(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IContactPickerUI {
    #[inline] pub fn add_contact(&self, id: &HStringArg, contact: &super::Contact) -> Result<AddContactResult> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().AddContact)(self.get_abi() as *const _ as *mut _, id.get(), contact.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_contact(&self, id: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().RemoveContact)(self.get_abi() as *const _ as *mut _, id.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn contains_contact(&self, id: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().ContainsContact)(self.get_abi() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_desired_fields(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DesiredFields)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_selection_mode(&self) -> Result<super::ContactSelectionMode> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SelectionMode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_contact_removed(&self, handler: &foundation::TypedEventHandler<ContactPickerUI, ContactRemovedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_ContactRemoved)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_contact_removed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_ContactRemoved)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactPickerUI: IContactPickerUI}
DEFINE_IID!(IID_IContactPickerUI2, 1849990696, 31525, 18841, 155, 11, 135, 84, 0, 161, 232, 200);
RT_INTERFACE!{interface IContactPickerUI2(IContactPickerUI2Vtbl): IInspectable [IID_IContactPickerUI2] {
    fn AddContact(&self, contact: <super::Contact as RtType>::Abi, out: *mut AddContactResult) -> HRESULT,
    fn get_DesiredFieldsWithContactFieldType(&self, out: *mut <foundation::collections::IVector<super::ContactFieldType> as RtType>::Abi) -> HRESULT
}}
impl IContactPickerUI2 {
    #[inline] pub fn add_contact(&self, contact: &super::Contact) -> Result<AddContactResult> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().AddContact)(self.get_abi() as *const _ as *mut _, contact.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_desired_fields_with_contact_field_type(&self) -> Result<Option<foundation::collections::IVector<super::ContactFieldType>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DesiredFieldsWithContactFieldType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContactRemovedEventArgs, 1865761592, 13058, 19731, 173, 141, 173, 204, 15, 249, 228, 124);
RT_INTERFACE!{interface IContactRemovedEventArgs(IContactRemovedEventArgsVtbl): IInspectable [IID_IContactRemovedEventArgs] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT
}}
impl IContactRemovedEventArgs {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContactRemovedEventArgs: IContactRemovedEventArgs}
} // Windows.ApplicationModel.Contacts.Provider
} // Windows.ApplicationModel.Contacts
pub mod core { // Windows.ApplicationModel.Core
use crate::prelude::*;
DEFINE_IID!(IID_IAppListEntry, 4009816191, 8456, 18698, 135, 122, 138, 159, 23, 194, 95, 173);
RT_INTERFACE!{interface IAppListEntry(IAppListEntryVtbl): IInspectable [IID_IAppListEntry] {
    fn get_DisplayInfo(&self, out: *mut <super::AppDisplayInfo as RtType>::Abi) -> HRESULT,
    fn LaunchAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl IAppListEntry {
    #[inline] pub fn get_display_info(&self) -> Result<Option<super::AppDisplayInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayInfo)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::AppDisplayInfo::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn launch_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().LaunchAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppListEntry: IAppListEntry}
DEFINE_IID!(IID_IAppListEntry2, 3500546221, 48949, 17068, 172, 6, 134, 238, 235, 65, 208, 75);
RT_INTERFACE!{interface IAppListEntry2(IAppListEntry2Vtbl): IInspectable [IID_IAppListEntry2] {
    fn get_AppUserModelId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAppListEntry2 {
    #[inline] pub fn get_app_user_model_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppUserModelId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppListEntry3, 1620701837, 64562, 18186, 188, 105, 75, 6, 26, 118, 239, 46);
RT_INTERFACE!{interface IAppListEntry3(IAppListEntry3Vtbl): IInspectable [IID_IAppListEntry3] {
    #[cfg(feature="windows-system")] fn LaunchForUserAsync(&self, user: <super::super::system::User as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl IAppListEntry3 {
    #[cfg(feature="windows-system")] #[inline] pub fn launch_for_user_async(&self, user: &super::super::system::User) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().LaunchForUserAsync)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum AppRestartFailureReason: i32 {
    RestartPending = 0, NotInForeground = 1, InvalidUser = 2, Other = 3,
}}
DEFINE_IID!(IID_ICoreApplication, 179107748, 24093, 18911, 128, 52, 251, 106, 104, 188, 94, 209);
RT_INTERFACE!{static interface ICoreApplication(ICoreApplicationVtbl): IInspectable [IID_ICoreApplication] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn add_Suspending(&self, handler: <foundation::EventHandler<super::SuspendingEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Suspending(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Resuming(&self, handler: <foundation::EventHandler<IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Resuming(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT,
    fn GetCurrentView(&self, out: *mut <CoreApplicationView as RtType>::Abi) -> HRESULT,
    fn Run(&self, viewSource: <IFrameworkViewSource as RtType>::Abi) -> HRESULT,
    fn RunWithActivationFactories(&self, activationFactoryCallback: <foundation::IGetActivationFactory as RtType>::Abi) -> HRESULT
}}
impl ICoreApplication {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_suspending(&self, handler: &foundation::EventHandler<super::SuspendingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_Suspending)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_suspending(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_Suspending)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_resuming(&self, handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_Resuming)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_resuming(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_Resuming)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IPropertySet>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Properties)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IPropertySet::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_current_view(&self) -> Result<Option<CoreApplicationView>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetCurrentView)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CoreApplicationView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn run(&self, viewSource: &IFrameworkViewSource) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Run)(self.get_abi() as *const _ as *mut _, viewSource.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn run_with_activation_factories(&self, activationFactoryCallback: &foundation::IGetActivationFactory) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().RunWithActivationFactories)(self.get_abi() as *const _ as *mut _, activationFactoryCallback.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{static class CoreApplication}
impl RtActivatable<ICoreApplication> for CoreApplication {}
impl RtActivatable<ICoreApplication2> for CoreApplication {}
impl RtActivatable<ICoreApplication3> for CoreApplication {}
impl RtActivatable<ICoreApplicationExit> for CoreApplication {}
impl RtActivatable<ICoreApplicationUnhandledError> for CoreApplication {}
impl RtActivatable<ICoreApplicationUseCount> for CoreApplication {}
impl RtActivatable<ICoreImmersiveApplication> for CoreApplication {}
impl RtActivatable<ICoreImmersiveApplication2> for CoreApplication {}
impl RtActivatable<ICoreImmersiveApplication3> for CoreApplication {}
impl CoreApplication {
    #[inline] pub fn get_id() -> Result<HString> {
        <Self as RtActivatable<ICoreApplication>>::get_activation_factory().get_id()
    }
    #[inline] pub fn add_suspending(handler: &foundation::EventHandler<super::SuspendingEventArgs>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<ICoreApplication>>::get_activation_factory().add_suspending(handler)
    }
    #[inline] pub fn remove_suspending(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<ICoreApplication>>::get_activation_factory().remove_suspending(token)
    }
    #[inline] pub fn add_resuming(handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<ICoreApplication>>::get_activation_factory().add_resuming(handler)
    }
    #[inline] pub fn remove_resuming(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<ICoreApplication>>::get_activation_factory().remove_resuming(token)
    }
    #[inline] pub fn get_properties() -> Result<Option<foundation::collections::IPropertySet>> {
        <Self as RtActivatable<ICoreApplication>>::get_activation_factory().get_properties()
    }
    #[inline] pub fn get_current_view() -> Result<Option<CoreApplicationView>> {
        <Self as RtActivatable<ICoreApplication>>::get_activation_factory().get_current_view()
    }
    #[inline] pub fn run(viewSource: &IFrameworkViewSource) -> Result<()> {
        <Self as RtActivatable<ICoreApplication>>::get_activation_factory().run(viewSource)
    }
    #[inline] pub fn run_with_activation_factories(activationFactoryCallback: &foundation::IGetActivationFactory) -> Result<()> {
        <Self as RtActivatable<ICoreApplication>>::get_activation_factory().run_with_activation_factories(activationFactoryCallback)
    }
    #[inline] pub fn add_background_activated(handler: &foundation::EventHandler<super::activation::BackgroundActivatedEventArgs>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<ICoreApplication2>>::get_activation_factory().add_background_activated(handler)
    }
    #[inline] pub fn remove_background_activated(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<ICoreApplication2>>::get_activation_factory().remove_background_activated(token)
    }
    #[inline] pub fn add_leaving_background(handler: &foundation::EventHandler<super::LeavingBackgroundEventArgs>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<ICoreApplication2>>::get_activation_factory().add_leaving_background(handler)
    }
    #[inline] pub fn remove_leaving_background(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<ICoreApplication2>>::get_activation_factory().remove_leaving_background(token)
    }
    #[inline] pub fn add_entered_background(handler: &foundation::EventHandler<super::EnteredBackgroundEventArgs>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<ICoreApplication2>>::get_activation_factory().add_entered_background(handler)
    }
    #[inline] pub fn remove_entered_background(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<ICoreApplication2>>::get_activation_factory().remove_entered_background(token)
    }
    #[inline] pub fn enable_prelaunch(value: bool) -> Result<()> {
        <Self as RtActivatable<ICoreApplication2>>::get_activation_factory().enable_prelaunch(value)
    }
    #[inline] pub fn request_restart_async(launchArguments: &HStringArg) -> Result<foundation::IAsyncOperation<AppRestartFailureReason>> {
        <Self as RtActivatable<ICoreApplication3>>::get_activation_factory().request_restart_async(launchArguments)
    }
    #[cfg(feature="windows-system")] #[inline] pub fn request_restart_for_user_async(user: &super::super::system::User, launchArguments: &HStringArg) -> Result<foundation::IAsyncOperation<AppRestartFailureReason>> {
        <Self as RtActivatable<ICoreApplication3>>::get_activation_factory().request_restart_for_user_async(user, launchArguments)
    }
    #[inline] pub fn exit() -> Result<()> {
        <Self as RtActivatable<ICoreApplicationExit>>::get_activation_factory().exit()
    }
    #[inline] pub fn add_exiting(handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<ICoreApplicationExit>>::get_activation_factory().add_exiting(handler)
    }
    #[inline] pub fn remove_exiting(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<ICoreApplicationExit>>::get_activation_factory().remove_exiting(token)
    }
    #[inline] pub fn add_unhandled_error_detected(handler: &foundation::EventHandler<UnhandledErrorDetectedEventArgs>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<ICoreApplicationUnhandledError>>::get_activation_factory().add_unhandled_error_detected(handler)
    }
    #[inline] pub fn remove_unhandled_error_detected(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<ICoreApplicationUnhandledError>>::get_activation_factory().remove_unhandled_error_detected(token)
    }
    #[inline] pub fn increment_application_use_count() -> Result<()> {
        <Self as RtActivatable<ICoreApplicationUseCount>>::get_activation_factory().increment_application_use_count()
    }
    #[inline] pub fn decrement_application_use_count() -> Result<()> {
        <Self as RtActivatable<ICoreApplicationUseCount>>::get_activation_factory().decrement_application_use_count()
    }
    #[inline] pub fn get_views() -> Result<Option<foundation::collections::IVectorView<CoreApplicationView>>> {
        <Self as RtActivatable<ICoreImmersiveApplication>>::get_activation_factory().get_views()
    }
    #[inline] pub fn create_new_view(runtimeType: &HStringArg, entryPoint: &HStringArg) -> Result<Option<CoreApplicationView>> {
        <Self as RtActivatable<ICoreImmersiveApplication>>::get_activation_factory().create_new_view(runtimeType, entryPoint)
    }
    #[inline] pub fn get_main_view() -> Result<Option<CoreApplicationView>> {
        <Self as RtActivatable<ICoreImmersiveApplication>>::get_activation_factory().get_main_view()
    }
    #[inline] pub fn create_new_view_from_main_view() -> Result<Option<CoreApplicationView>> {
        <Self as RtActivatable<ICoreImmersiveApplication2>>::get_activation_factory().create_new_view_from_main_view()
    }
    #[inline] pub fn create_new_view_with_view_source(viewSource: &IFrameworkViewSource) -> Result<Option<CoreApplicationView>> {
        <Self as RtActivatable<ICoreImmersiveApplication3>>::get_activation_factory().create_new_view_with_view_source(viewSource)
    }
}
DEFINE_CLSID!(CoreApplication(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,67,111,114,101,46,67,111,114,101,65,112,112,108,105,99,97,116,105,111,110,0]) [CLSID_CoreApplication]);
DEFINE_IID!(IID_ICoreApplication2, 2575729147, 6838, 19327, 190, 74, 154, 6, 69, 34, 76, 4);
RT_INTERFACE!{static interface ICoreApplication2(ICoreApplication2Vtbl): IInspectable [IID_ICoreApplication2] {
    fn add_BackgroundActivated(&self, handler: <foundation::EventHandler<super::activation::BackgroundActivatedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BackgroundActivated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_LeavingBackground(&self, handler: <foundation::EventHandler<super::LeavingBackgroundEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LeavingBackground(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_EnteredBackground(&self, handler: <foundation::EventHandler<super::EnteredBackgroundEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EnteredBackground(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn EnablePrelaunch(&self, value: bool) -> HRESULT
}}
impl ICoreApplication2 {
    #[inline] pub fn add_background_activated(&self, handler: &foundation::EventHandler<super::activation::BackgroundActivatedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_BackgroundActivated)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_background_activated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_BackgroundActivated)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_leaving_background(&self, handler: &foundation::EventHandler<super::LeavingBackgroundEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_LeavingBackground)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_leaving_background(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_LeavingBackground)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_entered_background(&self, handler: &foundation::EventHandler<super::EnteredBackgroundEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_EnteredBackground)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_entered_background(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_EnteredBackground)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn enable_prelaunch(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().EnablePrelaunch)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreApplication3, 4276882745, 22923, 17671, 138, 103, 119, 38, 50, 88, 10, 87);
RT_INTERFACE!{static interface ICoreApplication3(ICoreApplication3Vtbl): IInspectable [IID_ICoreApplication3] {
    fn RequestRestartAsync(&self, launchArguments: HSTRING, out: *mut <foundation::IAsyncOperation<AppRestartFailureReason> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-system")] fn RequestRestartForUserAsync(&self, user: <super::super::system::User as RtType>::Abi, launchArguments: HSTRING, out: *mut <foundation::IAsyncOperation<AppRestartFailureReason> as RtType>::Abi) -> HRESULT
}}
impl ICoreApplication3 {
    #[inline] pub fn request_restart_async(&self, launchArguments: &HStringArg) -> Result<foundation::IAsyncOperation<AppRestartFailureReason>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestRestartAsync)(self.get_abi() as *const _ as *mut _, launchArguments.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn request_restart_for_user_async(&self, user: &super::super::system::User, launchArguments: &HStringArg) -> Result<foundation::IAsyncOperation<AppRestartFailureReason>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestRestartForUserAsync)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, launchArguments.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreApplicationExit, 3481683485, 9758, 19314, 154, 205, 68, 237, 42, 206, 106, 41);
RT_INTERFACE!{static interface ICoreApplicationExit(ICoreApplicationExitVtbl): IInspectable [IID_ICoreApplicationExit] {
    fn Exit(&self) -> HRESULT,
    fn add_Exiting(&self, handler: <foundation::EventHandler<IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Exiting(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICoreApplicationExit {
    #[inline] pub fn exit(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Exit)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_exiting(&self, handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_Exiting)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_exiting(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_Exiting)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreApplicationUnhandledError, 4041362096, 56585, 17121, 176, 188, 224, 225, 49, 247, 141, 126);
RT_INTERFACE!{interface ICoreApplicationUnhandledError(ICoreApplicationUnhandledErrorVtbl): IInspectable [IID_ICoreApplicationUnhandledError] {
    fn add_UnhandledErrorDetected(&self, handler: <foundation::EventHandler<UnhandledErrorDetectedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_UnhandledErrorDetected(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICoreApplicationUnhandledError {
    #[inline] pub fn add_unhandled_error_detected(&self, handler: &foundation::EventHandler<UnhandledErrorDetectedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_UnhandledErrorDetected)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_unhandled_error_detected(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_UnhandledErrorDetected)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreApplicationUseCount, 1368245256, 49271, 18267, 128, 158, 11, 192, 197, 126, 75, 116);
RT_INTERFACE!{static interface ICoreApplicationUseCount(ICoreApplicationUseCountVtbl): IInspectable [IID_ICoreApplicationUseCount] {
    fn IncrementApplicationUseCount(&self) -> HRESULT,
    fn DecrementApplicationUseCount(&self) -> HRESULT
}}
impl ICoreApplicationUseCount {
    #[inline] pub fn increment_application_use_count(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().IncrementApplicationUseCount)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn decrement_application_use_count(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().DecrementApplicationUseCount)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreApplicationView, 1670099675, 17693, 18017, 176, 153, 65, 79, 52, 255, 185, 241);
RT_INTERFACE!{interface ICoreApplicationView(ICoreApplicationViewVtbl): IInspectable [IID_ICoreApplicationView] {
    #[cfg(not(feature="windows-ui"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_CoreWindow(&self, out: *mut <super::super::ui::core::CoreWindow as RtType>::Abi) -> HRESULT,
    fn add_Activated(&self, handler: <foundation::TypedEventHandler<CoreApplicationView, super::activation::IActivatedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Activated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_IsMain(&self, out: *mut bool) -> HRESULT,
    fn get_IsHosted(&self, out: *mut bool) -> HRESULT
}}
impl ICoreApplicationView {
    #[cfg(feature="windows-ui")] #[inline] pub fn get_core_window(&self) -> Result<Option<super::super::ui::core::CoreWindow>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CoreWindow)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::ui::core::CoreWindow::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_activated(&self, handler: &foundation::TypedEventHandler<CoreApplicationView, super::activation::IActivatedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_Activated)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_activated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_Activated)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_main(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsMain)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_hosted(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsHosted)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreApplicationView: ICoreApplicationView}
DEFINE_IID!(IID_ICoreApplicationView2, 1760262879, 37247, 18667, 154, 235, 125, 229, 62, 8, 106, 177);
RT_INTERFACE!{interface ICoreApplicationView2(ICoreApplicationView2Vtbl): IInspectable [IID_ICoreApplicationView2] {
    #[cfg(feature="windows-ui")] fn get_Dispatcher(&self, out: *mut <super::super::ui::core::CoreDispatcher as RtType>::Abi) -> HRESULT
}}
impl ICoreApplicationView2 {
    #[cfg(feature="windows-ui")] #[inline] pub fn get_dispatcher(&self) -> Result<Option<super::super::ui::core::CoreDispatcher>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Dispatcher)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::ui::core::CoreDispatcher::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreApplicationView3, 132899251, 42191, 17744, 171, 112, 176, 126, 133, 51, 11, 200);
RT_INTERFACE!{interface ICoreApplicationView3(ICoreApplicationView3Vtbl): IInspectable [IID_ICoreApplicationView3] {
    fn get_IsComponent(&self, out: *mut bool) -> HRESULT,
    fn get_TitleBar(&self, out: *mut <CoreApplicationViewTitleBar as RtType>::Abi) -> HRESULT,
    fn add_HostedViewClosing(&self, handler: <foundation::TypedEventHandler<CoreApplicationView, HostedViewClosingEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_HostedViewClosing(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICoreApplicationView3 {
    #[inline] pub fn get_is_component(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsComponent)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_title_bar(&self) -> Result<Option<CoreApplicationViewTitleBar>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TitleBar)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CoreApplicationViewTitleBar::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_hosted_view_closing(&self, handler: &foundation::TypedEventHandler<CoreApplicationView, HostedViewClosingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_HostedViewClosing)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_hosted_view_closing(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_HostedViewClosing)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreApplicationView5, 734041512, 36592, 17517, 158, 96, 58, 62, 4, 40, 198, 113);
RT_INTERFACE!{interface ICoreApplicationView5(ICoreApplicationView5Vtbl): IInspectable [IID_ICoreApplicationView5] {
    fn get_Properties(&self, out: *mut <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT
}}
impl ICoreApplicationView5 {
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IPropertySet>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Properties)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IPropertySet::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreApplicationView6, 3239695514, 1657, 18874, 128, 63, 183, 156, 92, 243, 76, 202);
RT_INTERFACE!{interface ICoreApplicationView6(ICoreApplicationView6Vtbl): IInspectable [IID_ICoreApplicationView6] {
    #[cfg(feature="windows-system")] fn get_DispatcherQueue(&self, out: *mut <super::super::system::DispatcherQueue as RtType>::Abi) -> HRESULT
}}
impl ICoreApplicationView6 {
    #[cfg(feature="windows-system")] #[inline] pub fn get_dispatcher_queue(&self) -> Result<Option<super::super::system::DispatcherQueue>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DispatcherQueue)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::system::DispatcherQueue::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreApplicationViewTitleBar, 7157219, 57841, 17179, 149, 8, 41, 185, 105, 38, 172, 83);
RT_INTERFACE!{interface ICoreApplicationViewTitleBar(ICoreApplicationViewTitleBarVtbl): IInspectable [IID_ICoreApplicationViewTitleBar] {
    fn put_ExtendViewIntoTitleBar(&self, value: bool) -> HRESULT,
    fn get_ExtendViewIntoTitleBar(&self, out: *mut bool) -> HRESULT,
    fn get_SystemOverlayLeftInset(&self, out: *mut f64) -> HRESULT,
    fn get_SystemOverlayRightInset(&self, out: *mut f64) -> HRESULT,
    fn get_Height(&self, out: *mut f64) -> HRESULT,
    fn add_LayoutMetricsChanged(&self, handler: <foundation::TypedEventHandler<CoreApplicationViewTitleBar, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LayoutMetricsChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_IsVisible(&self, out: *mut bool) -> HRESULT,
    fn add_IsVisibleChanged(&self, handler: <foundation::TypedEventHandler<CoreApplicationViewTitleBar, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_IsVisibleChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICoreApplicationViewTitleBar {
    #[inline] pub fn set_extend_view_into_title_bar(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ExtendViewIntoTitleBar)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_extend_view_into_title_bar(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ExtendViewIntoTitleBar)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_system_overlay_left_inset(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SystemOverlayLeftInset)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_system_overlay_right_inset(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SystemOverlayRightInset)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_height(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Height)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_layout_metrics_changed(&self, handler: &foundation::TypedEventHandler<CoreApplicationViewTitleBar, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_LayoutMetricsChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_layout_metrics_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_LayoutMetricsChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_visible(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsVisible)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_is_visible_changed(&self, handler: &foundation::TypedEventHandler<CoreApplicationViewTitleBar, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_IsVisibleChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_is_visible_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_IsVisibleChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreApplicationViewTitleBar: ICoreApplicationViewTitleBar}
DEFINE_IID!(IID_ICoreImmersiveApplication, 450498110, 58530, 16675, 180, 81, 220, 150, 191, 128, 4, 25);
RT_INTERFACE!{static interface ICoreImmersiveApplication(ICoreImmersiveApplicationVtbl): IInspectable [IID_ICoreImmersiveApplication] {
    fn get_Views(&self, out: *mut <foundation::collections::IVectorView<CoreApplicationView> as RtType>::Abi) -> HRESULT,
    fn CreateNewView(&self, runtimeType: HSTRING, entryPoint: HSTRING, out: *mut <CoreApplicationView as RtType>::Abi) -> HRESULT,
    fn get_MainView(&self, out: *mut <CoreApplicationView as RtType>::Abi) -> HRESULT
}}
impl ICoreImmersiveApplication {
    #[inline] pub fn get_views(&self) -> Result<Option<foundation::collections::IVectorView<CoreApplicationView>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Views)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_new_view(&self, runtimeType: &HStringArg, entryPoint: &HStringArg) -> Result<Option<CoreApplicationView>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateNewView)(self.get_abi() as *const _ as *mut _, runtimeType.get(), entryPoint.get(), &mut out);
        if hr == S_OK { Ok(CoreApplicationView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_main_view(&self) -> Result<Option<CoreApplicationView>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MainView)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CoreApplicationView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreImmersiveApplication2, 2190351926, 59875, 19708, 155, 102, 72, 183, 142, 169, 187, 44);
RT_INTERFACE!{static interface ICoreImmersiveApplication2(ICoreImmersiveApplication2Vtbl): IInspectable [IID_ICoreImmersiveApplication2] {
    fn CreateNewViewFromMainView(&self, out: *mut <CoreApplicationView as RtType>::Abi) -> HRESULT
}}
impl ICoreImmersiveApplication2 {
    #[inline] pub fn create_new_view_from_main_view(&self) -> Result<Option<CoreApplicationView>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateNewViewFromMainView)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CoreApplicationView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreImmersiveApplication3, 882924335, 60941, 16869, 131, 20, 207, 16, 201, 27, 240, 175);
RT_INTERFACE!{static interface ICoreImmersiveApplication3(ICoreImmersiveApplication3Vtbl): IInspectable [IID_ICoreImmersiveApplication3] {
    fn CreateNewViewWithViewSource(&self, viewSource: <IFrameworkViewSource as RtType>::Abi, out: *mut <CoreApplicationView as RtType>::Abi) -> HRESULT
}}
impl ICoreImmersiveApplication3 {
    #[inline] pub fn create_new_view_with_view_source(&self, viewSource: &IFrameworkViewSource) -> Result<Option<CoreApplicationView>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateNewViewWithViewSource)(self.get_abi() as *const _ as *mut _, viewSource.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CoreApplicationView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IFrameworkView, 4205534416, 35108, 17836, 173, 15, 160, 143, 174, 93, 3, 36);
RT_INTERFACE!{interface IFrameworkView(IFrameworkViewVtbl): IInspectable [IID_IFrameworkView] {
    fn Initialize(&self, applicationView: <CoreApplicationView as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn SetWindow(&self, window: <super::super::ui::core::CoreWindow as RtType>::Abi) -> HRESULT,
    fn Load(&self, entryPoint: HSTRING) -> HRESULT,
    fn Run(&self) -> HRESULT,
    fn Uninitialize(&self) -> HRESULT
}}
impl IFrameworkView {
    #[inline] pub fn initialize(&self, applicationView: &CoreApplicationView) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Initialize)(self.get_abi() as *const _ as *mut _, applicationView.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_window(&self, window: &super::super::ui::core::CoreWindow) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetWindow)(self.get_abi() as *const _ as *mut _, window.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn load(&self, entryPoint: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Load)(self.get_abi() as *const _ as *mut _, entryPoint.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn run(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Run)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn uninitialize(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Uninitialize)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IFrameworkViewSource, 3447129620, 26052, 17004, 148, 148, 52, 252, 67, 85, 72, 98);
RT_INTERFACE!{interface IFrameworkViewSource(IFrameworkViewSourceVtbl): IInspectable [IID_IFrameworkViewSource] {
    fn CreateView(&self, out: *mut <IFrameworkView as RtType>::Abi) -> HRESULT
}}
impl IFrameworkViewSource {
    #[inline] pub fn create_view(&self) -> Result<Option<IFrameworkView>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateView)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IFrameworkView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IHostedViewClosingEventArgs, 3526923324, 45646, 18320, 172, 181, 62, 66, 67, 196, 255, 135);
RT_INTERFACE!{interface IHostedViewClosingEventArgs(IHostedViewClosingEventArgsVtbl): IInspectable [IID_IHostedViewClosingEventArgs] {
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IHostedViewClosingEventArgs {
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class HostedViewClosingEventArgs: IHostedViewClosingEventArgs}
DEFINE_IID!(IID_IUnhandledError, 2488907558, 21429, 18054, 158, 175, 250, 129, 98, 220, 57, 128);
RT_INTERFACE!{interface IUnhandledError(IUnhandledErrorVtbl): IInspectable [IID_IUnhandledError] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn Propagate(&self) -> HRESULT
}}
impl IUnhandledError {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Handled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn propagate(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Propagate)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UnhandledError: IUnhandledError}
DEFINE_IID!(IID_IUnhandledErrorDetectedEventArgs, 1738192779, 45878, 18466, 172, 64, 13, 117, 15, 11, 122, 43);
RT_INTERFACE!{interface IUnhandledErrorDetectedEventArgs(IUnhandledErrorDetectedEventArgsVtbl): IInspectable [IID_IUnhandledErrorDetectedEventArgs] {
    fn get_UnhandledError(&self, out: *mut <UnhandledError as RtType>::Abi) -> HRESULT
}}
impl IUnhandledErrorDetectedEventArgs {
    #[inline] pub fn get_unhandled_error(&self) -> Result<Option<UnhandledError>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_UnhandledError)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UnhandledError::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UnhandledErrorDetectedEventArgs: IUnhandledErrorDetectedEventArgs}
} // Windows.ApplicationModel.Core
pub mod datatransfer { // Windows.ApplicationModel.DataTransfer
use crate::prelude::*;
RT_CLASS!{static class Clipboard}
impl RtActivatable<IClipboardStatics> for Clipboard {}
impl RtActivatable<IClipboardStatics2> for Clipboard {}
impl Clipboard {
    #[inline] pub fn get_content() -> Result<Option<DataPackageView>> {
        <Self as RtActivatable<IClipboardStatics>>::get_activation_factory().get_content()
    }
    #[inline] pub fn set_content(content: &DataPackage) -> Result<()> {
        <Self as RtActivatable<IClipboardStatics>>::get_activation_factory().set_content(content)
    }
    #[inline] pub fn flush() -> Result<()> {
        <Self as RtActivatable<IClipboardStatics>>::get_activation_factory().flush()
    }
    #[inline] pub fn clear() -> Result<()> {
        <Self as RtActivatable<IClipboardStatics>>::get_activation_factory().clear()
    }
    #[inline] pub fn add_content_changed(handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IClipboardStatics>>::get_activation_factory().add_content_changed(handler)
    }
    #[inline] pub fn remove_content_changed(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IClipboardStatics>>::get_activation_factory().remove_content_changed(token)
    }
    #[inline] pub fn get_history_items_async() -> Result<foundation::IAsyncOperation<ClipboardHistoryItemsResult>> {
        <Self as RtActivatable<IClipboardStatics2>>::get_activation_factory().get_history_items_async()
    }
    #[inline] pub fn clear_history() -> Result<bool> {
        <Self as RtActivatable<IClipboardStatics2>>::get_activation_factory().clear_history()
    }
    #[inline] pub fn delete_item_from_history(item: &ClipboardHistoryItem) -> Result<bool> {
        <Self as RtActivatable<IClipboardStatics2>>::get_activation_factory().delete_item_from_history(item)
    }
    #[inline] pub fn set_history_item_as_content(item: &ClipboardHistoryItem) -> Result<SetHistoryItemAsContentStatus> {
        <Self as RtActivatable<IClipboardStatics2>>::get_activation_factory().set_history_item_as_content(item)
    }
    #[inline] pub fn is_history_enabled() -> Result<bool> {
        <Self as RtActivatable<IClipboardStatics2>>::get_activation_factory().is_history_enabled()
    }
    #[inline] pub fn is_roaming_enabled() -> Result<bool> {
        <Self as RtActivatable<IClipboardStatics2>>::get_activation_factory().is_roaming_enabled()
    }
    #[inline] pub fn set_content_with_options(content: &DataPackage, options: &ClipboardContentOptions) -> Result<bool> {
        <Self as RtActivatable<IClipboardStatics2>>::get_activation_factory().set_content_with_options(content, options)
    }
    #[inline] pub fn add_history_changed(handler: &foundation::EventHandler<ClipboardHistoryChangedEventArgs>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IClipboardStatics2>>::get_activation_factory().add_history_changed(handler)
    }
    #[inline] pub fn remove_history_changed(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IClipboardStatics2>>::get_activation_factory().remove_history_changed(token)
    }
    #[inline] pub fn add_roaming_enabled_changed(handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IClipboardStatics2>>::get_activation_factory().add_roaming_enabled_changed(handler)
    }
    #[inline] pub fn remove_roaming_enabled_changed(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IClipboardStatics2>>::get_activation_factory().remove_roaming_enabled_changed(token)
    }
    #[inline] pub fn add_history_enabled_changed(handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IClipboardStatics2>>::get_activation_factory().add_history_enabled_changed(handler)
    }
    #[inline] pub fn remove_history_enabled_changed(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IClipboardStatics2>>::get_activation_factory().remove_history_enabled_changed(token)
    }
}
DEFINE_CLSID!(Clipboard(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,68,97,116,97,84,114,97,110,115,102,101,114,46,67,108,105,112,98,111,97,114,100,0]) [CLSID_Clipboard]);
DEFINE_IID!(IID_IClipboardContentOptions, 3901270412, 44363, 21575, 160, 86, 171, 53, 86, 39, 109, 43);
RT_INTERFACE!{interface IClipboardContentOptions(IClipboardContentOptionsVtbl): IInspectable [IID_IClipboardContentOptions] {
    fn get_IsRoamable(&self, out: *mut bool) -> HRESULT,
    fn put_IsRoamable(&self, value: bool) -> HRESULT,
    fn get_IsAllowedInHistory(&self, out: *mut bool) -> HRESULT,
    fn put_IsAllowedInHistory(&self, value: bool) -> HRESULT,
    fn get_RoamingFormats(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT,
    fn get_HistoryFormats(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT
}}
impl IClipboardContentOptions {
    #[inline] pub fn get_is_roamable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsRoamable)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_roamable(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsRoamable)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_allowed_in_history(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsAllowedInHistory)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_allowed_in_history(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsAllowedInHistory)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_roaming_formats(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RoamingFormats)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_history_formats(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_HistoryFormats)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ClipboardContentOptions: IClipboardContentOptions}
impl RtActivatable<IActivationFactory> for ClipboardContentOptions {}
DEFINE_CLSID!(ClipboardContentOptions(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,68,97,116,97,84,114,97,110,115,102,101,114,46,67,108,105,112,98,111,97,114,100,67,111,110,116,101,110,116,79,112,116,105,111,110,115,0]) [CLSID_ClipboardContentOptions]);
DEFINE_IID!(IID_IClipboardHistoryChangedEventArgs, 3233695039, 36514, 21454, 154, 186, 141, 34, 18, 87, 52, 82);
RT_INTERFACE!{interface IClipboardHistoryChangedEventArgs(IClipboardHistoryChangedEventArgsVtbl): IInspectable [IID_IClipboardHistoryChangedEventArgs] {
    
}}
RT_CLASS!{class ClipboardHistoryChangedEventArgs: IClipboardHistoryChangedEventArgs}
DEFINE_IID!(IID_IClipboardHistoryItem, 24362378, 45055, 23632, 171, 146, 61, 25, 244, 129, 236, 88);
RT_INTERFACE!{interface IClipboardHistoryItem(IClipboardHistoryItemVtbl): IInspectable [IID_IClipboardHistoryItem] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_Content(&self, out: *mut <DataPackageView as RtType>::Abi) -> HRESULT
}}
impl IClipboardHistoryItem {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Timestamp)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_content(&self) -> Result<Option<DataPackageView>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Content)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DataPackageView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ClipboardHistoryItem: IClipboardHistoryItem}
DEFINE_IID!(IID_IClipboardHistoryItemsResult, 3873431270, 3810, 21219, 133, 43, 242, 149, 219, 101, 147, 154);
RT_INTERFACE!{interface IClipboardHistoryItemsResult(IClipboardHistoryItemsResultVtbl): IInspectable [IID_IClipboardHistoryItemsResult] {
    fn get_Status(&self, out: *mut ClipboardHistoryItemsResultStatus) -> HRESULT,
    fn get_Items(&self, out: *mut <foundation::collections::IVectorView<ClipboardHistoryItem> as RtType>::Abi) -> HRESULT
}}
impl IClipboardHistoryItemsResult {
    #[inline] pub fn get_status(&self) -> Result<ClipboardHistoryItemsResultStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_items(&self) -> Result<Option<foundation::collections::IVectorView<ClipboardHistoryItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Items)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ClipboardHistoryItemsResult: IClipboardHistoryItemsResult}
RT_ENUM! { enum ClipboardHistoryItemsResultStatus: i32 {
    Success = 0, AccessDenied = 1, ClipboardHistoryDisabled = 2,
}}
DEFINE_IID!(IID_IClipboardStatics, 3324502673, 13538, 18787, 142, 237, 147, 203, 176, 234, 61, 112);
RT_INTERFACE!{static interface IClipboardStatics(IClipboardStaticsVtbl): IInspectable [IID_IClipboardStatics] {
    fn GetContent(&self, out: *mut <DataPackageView as RtType>::Abi) -> HRESULT,
    fn SetContent(&self, content: <DataPackage as RtType>::Abi) -> HRESULT,
    fn Flush(&self) -> HRESULT,
    fn Clear(&self) -> HRESULT,
    fn add_ContentChanged(&self, handler: <foundation::EventHandler<IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ContentChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IClipboardStatics {
    #[inline] pub fn get_content(&self) -> Result<Option<DataPackageView>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetContent)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DataPackageView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_content(&self, content: &DataPackage) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetContent)(self.get_abi() as *const _ as *mut _, content.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn flush(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Flush)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn clear(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Clear)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_content_changed(&self, handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_ContentChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_content_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_ContentChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IClipboardStatics2, 3534494570, 53919, 21835, 179, 3, 240, 69, 35, 69, 254, 2);
RT_INTERFACE!{static interface IClipboardStatics2(IClipboardStatics2Vtbl): IInspectable [IID_IClipboardStatics2] {
    fn GetHistoryItemsAsync(&self, out: *mut <foundation::IAsyncOperation<ClipboardHistoryItemsResult> as RtType>::Abi) -> HRESULT,
    fn ClearHistory(&self, out: *mut bool) -> HRESULT,
    fn DeleteItemFromHistory(&self, item: <ClipboardHistoryItem as RtType>::Abi, out: *mut bool) -> HRESULT,
    fn SetHistoryItemAsContent(&self, item: <ClipboardHistoryItem as RtType>::Abi, out: *mut SetHistoryItemAsContentStatus) -> HRESULT,
    fn IsHistoryEnabled(&self, out: *mut bool) -> HRESULT,
    fn IsRoamingEnabled(&self, out: *mut bool) -> HRESULT,
    fn SetContentWithOptions(&self, content: <DataPackage as RtType>::Abi, options: <ClipboardContentOptions as RtType>::Abi, out: *mut bool) -> HRESULT,
    fn add_HistoryChanged(&self, handler: <foundation::EventHandler<ClipboardHistoryChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_HistoryChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_RoamingEnabledChanged(&self, handler: <foundation::EventHandler<IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RoamingEnabledChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_HistoryEnabledChanged(&self, handler: <foundation::EventHandler<IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_HistoryEnabledChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IClipboardStatics2 {
    #[inline] pub fn get_history_items_async(&self) -> Result<foundation::IAsyncOperation<ClipboardHistoryItemsResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetHistoryItemsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn clear_history(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().ClearHistory)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn delete_item_from_history(&self, item: &ClipboardHistoryItem) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().DeleteItemFromHistory)(self.get_abi() as *const _ as *mut _, item.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_history_item_as_content(&self, item: &ClipboardHistoryItem) -> Result<SetHistoryItemAsContentStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().SetHistoryItemAsContent)(self.get_abi() as *const _ as *mut _, item.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_history_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().IsHistoryEnabled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_roaming_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().IsRoamingEnabled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_content_with_options(&self, content: &DataPackage, options: &ClipboardContentOptions) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().SetContentWithOptions)(self.get_abi() as *const _ as *mut _, content.get_abi() as *const _ as *mut _, options.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_history_changed(&self, handler: &foundation::EventHandler<ClipboardHistoryChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_HistoryChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_history_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_HistoryChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_roaming_enabled_changed(&self, handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_RoamingEnabledChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_roaming_enabled_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_RoamingEnabledChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_history_enabled_changed(&self, handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_HistoryEnabledChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_history_enabled_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_HistoryEnabledChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDataPackage, 1642853831, 61418, 17222, 149, 84, 152, 29, 126, 25, 143, 254);
RT_INTERFACE!{interface IDataPackage(IDataPackageVtbl): IInspectable [IID_IDataPackage] {
    fn GetView(&self, out: *mut <DataPackageView as RtType>::Abi) -> HRESULT,
    fn get_Properties(&self, out: *mut <DataPackagePropertySet as RtType>::Abi) -> HRESULT,
    fn get_RequestedOperation(&self, out: *mut DataPackageOperation) -> HRESULT,
    fn put_RequestedOperation(&self, value: DataPackageOperation) -> HRESULT,
    fn add_OperationCompleted(&self, handler: <foundation::TypedEventHandler<DataPackage, OperationCompletedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_OperationCompleted(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Destroyed(&self, handler: <foundation::TypedEventHandler<DataPackage, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Destroyed(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT,
    fn SetData(&self, formatId: HSTRING, value: <IInspectable as RtType>::Abi) -> HRESULT,
    fn SetDataProvider(&self, formatId: HSTRING, delayRenderer: <DataProviderHandler as RtType>::Abi) -> HRESULT,
    fn SetText(&self, value: HSTRING) -> HRESULT,
    fn SetUri(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn SetHtmlFormat(&self, value: HSTRING) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_ResourceMap(&self, out: *mut <foundation::collections::IMap<HString, super::super::storage::streams::RandomAccessStreamReference> as RtType>::Abi) -> HRESULT,
    fn SetRtf(&self, value: HSTRING) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SetBitmap(&self, value: <super::super::storage::streams::RandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SetStorageItemsReadOnly(&self, value: <foundation::collections::IIterable<super::super::storage::IStorageItem> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SetStorageItems(&self, value: <foundation::collections::IIterable<super::super::storage::IStorageItem> as RtType>::Abi, readOnly: bool) -> HRESULT
}}
impl IDataPackage {
    #[inline] pub fn get_view(&self) -> Result<Option<DataPackageView>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetView)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DataPackageView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<DataPackagePropertySet>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Properties)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DataPackagePropertySet::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_requested_operation(&self) -> Result<DataPackageOperation> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_RequestedOperation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_requested_operation(&self, value: DataPackageOperation) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RequestedOperation)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_operation_completed(&self, handler: &foundation::TypedEventHandler<DataPackage, OperationCompletedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_OperationCompleted)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_operation_completed(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_OperationCompleted)(self.get_abi() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_destroyed(&self, handler: &foundation::TypedEventHandler<DataPackage, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_Destroyed)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_destroyed(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_Destroyed)(self.get_abi() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_data(&self, formatId: &HStringArg, value: &IInspectable) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetData)(self.get_abi() as *const _ as *mut _, formatId.get(), value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_data_provider(&self, formatId: &HStringArg, delayRenderer: &DataProviderHandler) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetDataProvider)(self.get_abi() as *const _ as *mut _, formatId.get(), delayRenderer.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_text(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetText)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetUri)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_html_format(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetHtmlFormat)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_resource_map(&self) -> Result<Option<foundation::collections::IMap<HString, super::super::storage::streams::RandomAccessStreamReference>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ResourceMap)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMap::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_rtf(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetRtf)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_bitmap(&self, value: &super::super::storage::streams::RandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetBitmap)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_storage_items_read_only(&self, value: &foundation::collections::IIterable<super::super::storage::IStorageItem>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetStorageItemsReadOnly)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_storage_items(&self, value: &foundation::collections::IIterable<super::super::storage::IStorageItem>, readOnly: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetStorageItems)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _, readOnly);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DataPackage: IDataPackage}
impl RtActivatable<IActivationFactory> for DataPackage {}
DEFINE_CLSID!(DataPackage(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,68,97,116,97,84,114,97,110,115,102,101,114,46,68,97,116,97,80,97,99,107,97,103,101,0]) [CLSID_DataPackage]);
DEFINE_IID!(IID_IDataPackage2, 68952041, 9225, 17889, 165, 56, 76, 83, 238, 238, 4, 167);
RT_INTERFACE!{interface IDataPackage2(IDataPackage2Vtbl): IInspectable [IID_IDataPackage2] {
    fn SetApplicationLink(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn SetWebLink(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT
}}
impl IDataPackage2 {
    #[inline] pub fn set_application_link(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetApplicationLink)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_web_link(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetWebLink)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDataPackage3, 2297634653, 30843, 19762, 150, 90, 169, 131, 129, 5, 160, 86);
RT_INTERFACE!{interface IDataPackage3(IDataPackage3Vtbl): IInspectable [IID_IDataPackage3] {
    fn add_ShareCompleted(&self, handler: <foundation::TypedEventHandler<DataPackage, ShareCompletedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ShareCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IDataPackage3 {
    #[inline] pub fn add_share_completed(&self, handler: &foundation::TypedEventHandler<DataPackage, ShareCompletedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_ShareCompleted)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_share_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_ShareCompleted)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum DataPackageOperation: u32 {
    None = 0, Copy = 1, Move = 2, Link = 4,
}}
DEFINE_IID!(IID_IDataPackagePropertySet, 3441202155, 19532, 17466, 168, 211, 245, 194, 65, 233, 22, 137);
RT_INTERFACE!{interface IDataPackagePropertySet(IDataPackagePropertySetVtbl): IInspectable [IID_IDataPackagePropertySet] {
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Thumbnail(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Thumbnail(&self, value: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    fn get_FileTypes(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT,
    fn get_ApplicationName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ApplicationName(&self, value: HSTRING) -> HRESULT,
    fn get_ApplicationListingUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_ApplicationListingUri(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT
}}
impl IDataPackagePropertySet {
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Title)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_title(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Title)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Description)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_description(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Description)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_thumbnail(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Thumbnail)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_thumbnail(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Thumbnail)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_file_types(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_FileTypes)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_application_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ApplicationName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_application_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ApplicationName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_application_listing_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ApplicationListingUri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_application_listing_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ApplicationListingUri)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DataPackagePropertySet: IDataPackagePropertySet}
DEFINE_IID!(IID_IDataPackagePropertySet2, 3947912522, 38912, 18090, 177, 129, 123, 111, 15, 43, 145, 154);
RT_INTERFACE!{interface IDataPackagePropertySet2(IDataPackagePropertySet2Vtbl): IInspectable [IID_IDataPackagePropertySet2] {
    fn get_ContentSourceWebLink(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_ContentSourceWebLink(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_ContentSourceApplicationLink(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_ContentSourceApplicationLink(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_PackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PackageFamilyName(&self, value: HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Square30x30Logo(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Square30x30Logo(&self, value: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_LogoBackgroundColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_LogoBackgroundColor(&self, value: super::super::ui::Color) -> HRESULT
}}
impl IDataPackagePropertySet2 {
    #[inline] pub fn get_content_source_web_link(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContentSourceWebLink)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_content_source_web_link(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ContentSourceWebLink)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_content_source_application_link(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContentSourceApplicationLink)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_content_source_application_link(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ContentSourceApplicationLink)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_package_family_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PackageFamilyName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_package_family_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_PackageFamilyName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_square_30x30_logo(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Square30x30Logo)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_square_30x30_logo(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Square30x30Logo)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_logo_background_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_LogoBackgroundColor)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_logo_background_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_LogoBackgroundColor)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDataPackagePropertySet3, 2659712411, 20997, 16411, 135, 74, 69, 86, 83, 189, 57, 232);
RT_INTERFACE!{interface IDataPackagePropertySet3(IDataPackagePropertySet3Vtbl): IInspectable [IID_IDataPackagePropertySet3] {
    fn get_EnterpriseId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_EnterpriseId(&self, value: HSTRING) -> HRESULT
}}
impl IDataPackagePropertySet3 {
    #[inline] pub fn get_enterprise_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EnterpriseId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_enterprise_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_EnterpriseId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDataPackagePropertySet4, 1670441973, 5945, 19572, 178, 47, 134, 95, 171, 94, 133, 69);
RT_INTERFACE!{interface IDataPackagePropertySet4(IDataPackagePropertySet4Vtbl): IInspectable [IID_IDataPackagePropertySet4] {
    fn get_ContentSourceUserActivityJson(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ContentSourceUserActivityJson(&self, value: HSTRING) -> HRESULT
}}
impl IDataPackagePropertySet4 {
    #[inline] pub fn get_content_source_user_activity_json(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContentSourceUserActivityJson)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_content_source_user_activity_json(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ContentSourceUserActivityJson)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDataPackagePropertySetView, 3108826113, 3098, 19543, 190, 85, 117, 208, 18, 137, 115, 93);
RT_INTERFACE!{interface IDataPackagePropertySetView(IDataPackagePropertySetViewVtbl): IInspectable [IID_IDataPackagePropertySetView] {
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Thumbnail(&self, out: *mut <super::super::storage::streams::RandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    fn get_FileTypes(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT,
    fn get_ApplicationName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ApplicationListingUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT
}}
impl IDataPackagePropertySetView {
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Title)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Description)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_thumbnail(&self) -> Result<Option<super::super::storage::streams::RandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Thumbnail)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::RandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_file_types(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_FileTypes)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_application_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ApplicationName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_application_listing_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ApplicationListingUri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DataPackagePropertySetView: IDataPackagePropertySetView}
DEFINE_IID!(IID_IDataPackagePropertySetView2, 1616138395, 36542, 20459, 156, 30, 117, 230, 157, 229, 75, 132);
RT_INTERFACE!{interface IDataPackagePropertySetView2(IDataPackagePropertySetView2Vtbl): IInspectable [IID_IDataPackagePropertySetView2] {
    fn get_PackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ContentSourceWebLink(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_ContentSourceApplicationLink(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Square30x30Logo(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_LogoBackgroundColor(&self, out: *mut super::super::ui::Color) -> HRESULT
}}
impl IDataPackagePropertySetView2 {
    #[inline] pub fn get_package_family_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PackageFamilyName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_content_source_web_link(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContentSourceWebLink)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_content_source_application_link(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContentSourceApplicationLink)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_square_30x30_logo(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Square30x30Logo)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_logo_background_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_LogoBackgroundColor)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDataPackagePropertySetView3, 3681963237, 53620, 18780, 132, 252, 26, 81, 246, 171, 69, 215);
RT_INTERFACE!{interface IDataPackagePropertySetView3(IDataPackagePropertySetView3Vtbl): IInspectable [IID_IDataPackagePropertySetView3] {
    fn get_EnterpriseId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IDataPackagePropertySetView3 {
    #[inline] pub fn get_enterprise_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EnterpriseId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDataPackagePropertySetView4, 1148504077, 53615, 16558, 149, 128, 111, 133, 98, 185, 66, 53);
RT_INTERFACE!{interface IDataPackagePropertySetView4(IDataPackagePropertySetView4Vtbl): IInspectable [IID_IDataPackagePropertySetView4] {
    fn get_ContentSourceUserActivityJson(&self, out: *mut HSTRING) -> HRESULT
}}
impl IDataPackagePropertySetView4 {
    #[inline] pub fn get_content_source_user_activity_json(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContentSourceUserActivityJson)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDataPackagePropertySetView5, 1862964293, 14176, 20667, 133, 35, 196, 32, 45, 237, 125, 120);
RT_INTERFACE!{interface IDataPackagePropertySetView5(IDataPackagePropertySetView5Vtbl): IInspectable [IID_IDataPackagePropertySetView5] {
    fn get_IsFromRoamingClipboard(&self, out: *mut bool) -> HRESULT
}}
impl IDataPackagePropertySetView5 {
    #[inline] pub fn get_is_from_roaming_clipboard(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsFromRoamingClipboard)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDataPackageView, 2072249457, 22784, 19845, 169, 11, 16, 203, 133, 254, 53, 82);
RT_INTERFACE!{interface IDataPackageView(IDataPackageViewVtbl): IInspectable [IID_IDataPackageView] {
    fn get_Properties(&self, out: *mut <DataPackagePropertySetView as RtType>::Abi) -> HRESULT,
    fn get_RequestedOperation(&self, out: *mut DataPackageOperation) -> HRESULT,
    fn ReportOperationCompleted(&self, value: DataPackageOperation) -> HRESULT,
    fn get_AvailableFormats(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT,
    fn Contains(&self, formatId: HSTRING, out: *mut bool) -> HRESULT,
    fn GetDataAsync(&self, formatId: HSTRING, out: *mut <foundation::IAsyncOperation<IInspectable> as RtType>::Abi) -> HRESULT,
    fn GetTextAsync(&self, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn GetCustomTextAsync(&self, formatId: HSTRING, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn GetUriAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::Uri> as RtType>::Abi) -> HRESULT,
    fn GetHtmlFormatAsync(&self, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetResourceMapAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IMapView<HString, super::super::storage::streams::RandomAccessStreamReference>> as RtType>::Abi) -> HRESULT,
    fn GetRtfAsync(&self, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetBitmapAsync(&self, out: *mut <foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetStorageItemsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<super::super::storage::IStorageItem>> as RtType>::Abi) -> HRESULT
}}
impl IDataPackageView {
    #[inline] pub fn get_properties(&self) -> Result<Option<DataPackagePropertySetView>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Properties)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DataPackagePropertySetView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_requested_operation(&self) -> Result<DataPackageOperation> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_RequestedOperation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn report_operation_completed(&self, value: DataPackageOperation) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportOperationCompleted)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_available_formats(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AvailableFormats)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn contains(&self, formatId: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().Contains)(self.get_abi() as *const _ as *mut _, formatId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_data_async(&self, formatId: &HStringArg) -> Result<foundation::IAsyncOperation<IInspectable>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDataAsync)(self.get_abi() as *const _ as *mut _, formatId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_text_async(&self) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetTextAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_custom_text_async(&self, formatId: &HStringArg) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetCustomTextAsync)(self.get_abi() as *const _ as *mut _, formatId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_uri_async(&self) -> Result<foundation::IAsyncOperation<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetUriAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_html_format_async(&self) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetHtmlFormatAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_resource_map_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IMapView<HString, super::super::storage::streams::RandomAccessStreamReference>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetResourceMapAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_rtf_async(&self) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetRtfAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_bitmap_async(&self) -> Result<foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetBitmapAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_storage_items_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<super::super::storage::IStorageItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetStorageItemsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DataPackageView: IDataPackageView}
DEFINE_IID!(IID_IDataPackageView2, 1089256085, 9296, 19485, 182, 180, 237, 69, 70, 61, 238, 156);
RT_INTERFACE!{interface IDataPackageView2(IDataPackageView2Vtbl): IInspectable [IID_IDataPackageView2] {
    fn GetApplicationLinkAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::Uri> as RtType>::Abi) -> HRESULT,
    fn GetWebLinkAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::Uri> as RtType>::Abi) -> HRESULT
}}
impl IDataPackageView2 {
    #[inline] pub fn get_application_link_async(&self) -> Result<foundation::IAsyncOperation<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetApplicationLinkAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_web_link_async(&self) -> Result<foundation::IAsyncOperation<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetWebLinkAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDataPackageView3, 3547820456, 56749, 17032, 132, 40, 209, 202, 227, 148, 18, 139);
RT_INTERFACE!{interface IDataPackageView3(IDataPackageView3Vtbl): IInspectable [IID_IDataPackageView3] {
    #[cfg(feature="windows-security")] fn RequestAccessAsync(&self, out: *mut <foundation::IAsyncOperation<super::super::security::enterprisedata::ProtectionPolicyEvaluationResult> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-security")] fn RequestAccessWithEnterpriseIdAsync(&self, enterpriseId: HSTRING, out: *mut <foundation::IAsyncOperation<super::super::security::enterprisedata::ProtectionPolicyEvaluationResult> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-security")] fn UnlockAndAssumeEnterpriseIdentity(&self, out: *mut super::super::security::enterprisedata::ProtectionPolicyEvaluationResult) -> HRESULT
}}
impl IDataPackageView3 {
    #[cfg(feature="windows-security")] #[inline] pub fn request_access_async(&self) -> Result<foundation::IAsyncOperation<super::super::security::enterprisedata::ProtectionPolicyEvaluationResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestAccessAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn request_access_with_enterprise_id_async(&self, enterpriseId: &HStringArg) -> Result<foundation::IAsyncOperation<super::super::security::enterprisedata::ProtectionPolicyEvaluationResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestAccessWithEnterpriseIdAsync)(self.get_abi() as *const _ as *mut _, enterpriseId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn unlock_and_assume_enterprise_identity(&self) -> Result<super::super::security::enterprisedata::ProtectionPolicyEvaluationResult> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().UnlockAndAssumeEnterpriseIdentity)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDataPackageView4, 3756617503, 57410, 17459, 160, 159, 38, 214, 255, 218, 139, 133);
RT_INTERFACE!{interface IDataPackageView4(IDataPackageView4Vtbl): IInspectable [IID_IDataPackageView4] {
    fn SetAcceptedFormatId(&self, formatId: HSTRING) -> HRESULT
}}
impl IDataPackageView4 {
    #[inline] pub fn set_accepted_format_id(&self, formatId: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetAcceptedFormatId)(self.get_abi() as *const _ as *mut _, formatId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDataProviderDeferral, 3268354931, 11558, 17369, 182, 157, 220, 184, 109, 3, 246, 218);
RT_INTERFACE!{interface IDataProviderDeferral(IDataProviderDeferralVtbl): IInspectable [IID_IDataProviderDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IDataProviderDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Complete)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DataProviderDeferral: IDataProviderDeferral}
DEFINE_IID!(IID_DataProviderHandler, 3891058464, 62196, 18989, 146, 14, 23, 10, 47, 72, 42, 39);
RT_DELEGATE!{delegate DataProviderHandler(DataProviderHandlerVtbl, DataProviderHandlerImpl) [IID_DataProviderHandler] {
    fn Invoke(&self, request: <DataProviderRequest as RtType>::Abi) -> HRESULT
}}
impl DataProviderHandler {
    #[inline] pub fn invoke(&self, request: &DataProviderRequest) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Invoke)(self.get_abi() as *const _ as *mut _, request.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDataProviderRequest, 3954995543, 54216, 18394, 172, 222, 248, 35, 136, 213, 247, 22);
RT_INTERFACE!{interface IDataProviderRequest(IDataProviderRequestVtbl): IInspectable [IID_IDataProviderRequest] {
    fn get_FormatId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Deadline(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn GetDeferral(&self, out: *mut <DataProviderDeferral as RtType>::Abi) -> HRESULT,
    fn SetData(&self, value: <IInspectable as RtType>::Abi) -> HRESULT
}}
impl IDataProviderRequest {
    #[inline] pub fn get_format_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_FormatId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deadline(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Deadline)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<DataProviderDeferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DataProviderDeferral::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_data(&self, value: &IInspectable) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetData)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DataProviderRequest: IDataProviderRequest}
DEFINE_IID!(IID_IDataRequest, 1128377915, 64530, 20051, 140, 2, 172, 113, 76, 65, 90, 39);
RT_INTERFACE!{interface IDataRequest(IDataRequestVtbl): IInspectable [IID_IDataRequest] {
    fn get_Data(&self, out: *mut <DataPackage as RtType>::Abi) -> HRESULT,
    fn put_Data(&self, value: <DataPackage as RtType>::Abi) -> HRESULT,
    fn get_Deadline(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn FailWithDisplayText(&self, value: HSTRING) -> HRESULT,
    fn GetDeferral(&self, out: *mut <DataRequestDeferral as RtType>::Abi) -> HRESULT
}}
impl IDataRequest {
    #[inline] pub fn get_data(&self) -> Result<Option<DataPackage>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Data)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DataPackage::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_data(&self, value: &DataPackage) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Data)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deadline(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Deadline)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn fail_with_display_text(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().FailWithDisplayText)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<DataRequestDeferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DataRequestDeferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DataRequest: IDataRequest}
DEFINE_IID!(IID_IDataRequestDeferral, 1841608863, 902, 16995, 135, 193, 237, 125, 206, 48, 137, 14);
RT_INTERFACE!{interface IDataRequestDeferral(IDataRequestDeferralVtbl): IInspectable [IID_IDataRequestDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IDataRequestDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Complete)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DataRequestDeferral: IDataRequestDeferral}
DEFINE_IID!(IID_IDataRequestedEventArgs, 3414927367, 27333, 17353, 138, 197, 155, 162, 50, 22, 49, 130);
RT_INTERFACE!{interface IDataRequestedEventArgs(IDataRequestedEventArgsVtbl): IInspectable [IID_IDataRequestedEventArgs] {
    fn get_Request(&self, out: *mut <DataRequest as RtType>::Abi) -> HRESULT
}}
impl IDataRequestedEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<DataRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DataRequest::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DataRequestedEventArgs: IDataRequestedEventArgs}
DEFINE_IID!(IID_IDataTransferManager, 2781539995, 34568, 18897, 141, 54, 103, 210, 90, 141, 160, 12);
RT_INTERFACE!{interface IDataTransferManager(IDataTransferManagerVtbl): IInspectable [IID_IDataTransferManager] {
    fn add_DataRequested(&self, eventHandler: <foundation::TypedEventHandler<DataTransferManager, DataRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DataRequested(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_TargetApplicationChosen(&self, eventHandler: <foundation::TypedEventHandler<DataTransferManager, TargetApplicationChosenEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TargetApplicationChosen(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl IDataTransferManager {
    #[inline] pub fn add_data_requested(&self, eventHandler: &foundation::TypedEventHandler<DataTransferManager, DataRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_DataRequested)(self.get_abi() as *const _ as *mut _, eventHandler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_data_requested(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_DataRequested)(self.get_abi() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_target_application_chosen(&self, eventHandler: &foundation::TypedEventHandler<DataTransferManager, TargetApplicationChosenEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_TargetApplicationChosen)(self.get_abi() as *const _ as *mut _, eventHandler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_target_application_chosen(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_TargetApplicationChosen)(self.get_abi() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DataTransferManager: IDataTransferManager}
impl RtActivatable<IDataTransferManagerStatics> for DataTransferManager {}
impl RtActivatable<IDataTransferManagerStatics2> for DataTransferManager {}
impl RtActivatable<IDataTransferManagerStatics3> for DataTransferManager {}
impl DataTransferManager {
    #[inline] pub fn show_share_ui() -> Result<()> {
        <Self as RtActivatable<IDataTransferManagerStatics>>::get_activation_factory().show_share_ui()
    }
    #[inline] pub fn get_for_current_view() -> Result<Option<DataTransferManager>> {
        <Self as RtActivatable<IDataTransferManagerStatics>>::get_activation_factory().get_for_current_view()
    }
    #[inline] pub fn is_supported() -> Result<bool> {
        <Self as RtActivatable<IDataTransferManagerStatics2>>::get_activation_factory().is_supported()
    }
    #[inline] pub fn show_share_ui_with_options(options: &ShareUIOptions) -> Result<()> {
        <Self as RtActivatable<IDataTransferManagerStatics3>>::get_activation_factory().show_share_ui_with_options(options)
    }
}
DEFINE_CLSID!(DataTransferManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,68,97,116,97,84,114,97,110,115,102,101,114,46,68,97,116,97,84,114,97,110,115,102,101,114,77,97,110,97,103,101,114,0]) [CLSID_DataTransferManager]);
DEFINE_IID!(IID_IDataTransferManager2, 816741745, 35752, 19458, 142, 63, 221, 178, 59, 56, 135, 21);
RT_INTERFACE!{interface IDataTransferManager2(IDataTransferManager2Vtbl): IInspectable [IID_IDataTransferManager2] {
    fn add_ShareProvidersRequested(&self, handler: <foundation::TypedEventHandler<DataTransferManager, ShareProvidersRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ShareProvidersRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IDataTransferManager2 {
    #[inline] pub fn add_share_providers_requested(&self, handler: &foundation::TypedEventHandler<DataTransferManager, ShareProvidersRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_ShareProvidersRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_share_providers_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_ShareProvidersRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDataTransferManagerStatics, 2849636778, 57358, 19710, 170, 68, 45, 217, 50, 220, 163, 216);
RT_INTERFACE!{static interface IDataTransferManagerStatics(IDataTransferManagerStaticsVtbl): IInspectable [IID_IDataTransferManagerStatics] {
    fn ShowShareUI(&self) -> HRESULT,
    fn GetForCurrentView(&self, out: *mut <DataTransferManager as RtType>::Abi) -> HRESULT
}}
impl IDataTransferManagerStatics {
    #[inline] pub fn show_share_ui(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ShowShareUI)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<DataTransferManager>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetForCurrentView)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DataTransferManager::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDataTransferManagerStatics2, 3310273260, 40855, 19811, 152, 104, 57, 94, 39, 26, 216, 245);
RT_INTERFACE!{static interface IDataTransferManagerStatics2(IDataTransferManagerStatics2Vtbl): IInspectable [IID_IDataTransferManagerStatics2] {
    fn IsSupported(&self, out: *mut bool) -> HRESULT
}}
impl IDataTransferManagerStatics2 {
    #[inline] pub fn is_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().IsSupported)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDataTransferManagerStatics3, 92558451, 27778, 20316, 172, 35, 98, 228, 88, 54, 31, 172);
RT_INTERFACE!{static interface IDataTransferManagerStatics3(IDataTransferManagerStatics3Vtbl): IInspectable [IID_IDataTransferManagerStatics3] {
    fn ShowShareUIWithOptions(&self, options: <ShareUIOptions as RtType>::Abi) -> HRESULT
}}
impl IDataTransferManagerStatics3 {
    #[inline] pub fn show_share_ui_with_options(&self, options: &ShareUIOptions) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ShowShareUIWithOptions)(self.get_abi() as *const _ as *mut _, options.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{static class HtmlFormatHelper}
impl RtActivatable<IHtmlFormatHelperStatics> for HtmlFormatHelper {}
impl HtmlFormatHelper {
    #[inline] pub fn get_static_fragment(htmlFormat: &HStringArg) -> Result<HString> {
        <Self as RtActivatable<IHtmlFormatHelperStatics>>::get_activation_factory().get_static_fragment(htmlFormat)
    }
    #[inline] pub fn create_html_format(htmlFragment: &HStringArg) -> Result<HString> {
        <Self as RtActivatable<IHtmlFormatHelperStatics>>::get_activation_factory().create_html_format(htmlFragment)
    }
}
DEFINE_CLSID!(HtmlFormatHelper(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,68,97,116,97,84,114,97,110,115,102,101,114,46,72,116,109,108,70,111,114,109,97,116,72,101,108,112,101,114,0]) [CLSID_HtmlFormatHelper]);
DEFINE_IID!(IID_IHtmlFormatHelperStatics, 3794696009, 56688, 17519, 174, 252, 97, 206, 229, 159, 101, 94);
RT_INTERFACE!{static interface IHtmlFormatHelperStatics(IHtmlFormatHelperStaticsVtbl): IInspectable [IID_IHtmlFormatHelperStatics] {
    fn GetStaticFragment(&self, htmlFormat: HSTRING, out: *mut HSTRING) -> HRESULT,
    fn CreateHtmlFormat(&self, htmlFragment: HSTRING, out: *mut HSTRING) -> HRESULT
}}
impl IHtmlFormatHelperStatics {
    #[inline] pub fn get_static_fragment(&self, htmlFormat: &HStringArg) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetStaticFragment)(self.get_abi() as *const _ as *mut _, htmlFormat.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_html_format(&self, htmlFragment: &HStringArg) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateHtmlFormat)(self.get_abi() as *const _ as *mut _, htmlFragment.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IOperationCompletedEventArgs, 3887018653, 1309, 20395, 177, 169, 71, 253, 119, 247, 10, 65);
RT_INTERFACE!{interface IOperationCompletedEventArgs(IOperationCompletedEventArgsVtbl): IInspectable [IID_IOperationCompletedEventArgs] {
    fn get_Operation(&self, out: *mut DataPackageOperation) -> HRESULT
}}
impl IOperationCompletedEventArgs {
    #[inline] pub fn get_operation(&self) -> Result<DataPackageOperation> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Operation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class OperationCompletedEventArgs: IOperationCompletedEventArgs}
DEFINE_IID!(IID_IOperationCompletedEventArgs2, 2240782451, 7705, 16645, 178, 247, 200, 71, 136, 8, 213, 98);
RT_INTERFACE!{interface IOperationCompletedEventArgs2(IOperationCompletedEventArgs2Vtbl): IInspectable [IID_IOperationCompletedEventArgs2] {
    fn get_AcceptedFormatId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IOperationCompletedEventArgs2 {
    #[inline] pub fn get_accepted_format_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AcceptedFormatId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SetHistoryItemAsContentStatus: i32 {
    Success = 0, AccessDenied = 1, ItemDeleted = 2,
}}
DEFINE_IID!(IID_IShareCompletedEventArgs, 1165280322, 63763, 20320, 157, 247, 204, 64, 96, 171, 25, 22);
RT_INTERFACE!{interface IShareCompletedEventArgs(IShareCompletedEventArgsVtbl): IInspectable [IID_IShareCompletedEventArgs] {
    fn get_ShareTarget(&self, out: *mut <ShareTargetInfo as RtType>::Abi) -> HRESULT
}}
impl IShareCompletedEventArgs {
    #[inline] pub fn get_share_target(&self) -> Result<Option<ShareTargetInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ShareTarget)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ShareTargetInfo::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ShareCompletedEventArgs: IShareCompletedEventArgs}
RT_CLASS!{static class SharedStorageAccessManager}
impl RtActivatable<ISharedStorageAccessManagerStatics> for SharedStorageAccessManager {}
impl SharedStorageAccessManager {
    #[cfg(feature="windows-storage")] #[inline] pub fn add_file(file: &super::super::storage::IStorageFile) -> Result<HString> {
        <Self as RtActivatable<ISharedStorageAccessManagerStatics>>::get_activation_factory().add_file(file)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn redeem_token_for_file_async(token: &HStringArg) -> Result<foundation::IAsyncOperation<super::super::storage::StorageFile>> {
        <Self as RtActivatable<ISharedStorageAccessManagerStatics>>::get_activation_factory().redeem_token_for_file_async(token)
    }
    #[inline] pub fn remove_file(token: &HStringArg) -> Result<()> {
        <Self as RtActivatable<ISharedStorageAccessManagerStatics>>::get_activation_factory().remove_file(token)
    }
}
DEFINE_CLSID!(SharedStorageAccessManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,68,97,116,97,84,114,97,110,115,102,101,114,46,83,104,97,114,101,100,83,116,111,114,97,103,101,65,99,99,101,115,115,77,97,110,97,103,101,114,0]) [CLSID_SharedStorageAccessManager]);
DEFINE_IID!(IID_ISharedStorageAccessManagerStatics, 3323144922, 13489, 18505, 189, 95, 208, 159, 238, 49, 88, 197);
RT_INTERFACE!{static interface ISharedStorageAccessManagerStatics(ISharedStorageAccessManagerStaticsVtbl): IInspectable [IID_ISharedStorageAccessManagerStatics] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn AddFile(&self, file: <super::super::storage::IStorageFile as RtType>::Abi, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn RedeemTokenForFileAsync(&self, token: HSTRING, out: *mut <foundation::IAsyncOperation<super::super::storage::StorageFile> as RtType>::Abi) -> HRESULT,
    fn RemoveFile(&self, token: HSTRING) -> HRESULT
}}
impl ISharedStorageAccessManagerStatics {
    #[cfg(feature="windows-storage")] #[inline] pub fn add_file(&self, file: &super::super::storage::IStorageFile) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().AddFile)(self.get_abi() as *const _ as *mut _, file.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn redeem_token_for_file_async(&self, token: &HStringArg) -> Result<foundation::IAsyncOperation<super::super::storage::StorageFile>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RedeemTokenForFileAsync)(self.get_abi() as *const _ as *mut _, token.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn remove_file(&self, token: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().RemoveFile)(self.get_abi() as *const _ as *mut _, token.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IShareProvider, 799793190, 17470, 19674, 175, 37, 141, 129, 7, 14, 253, 128);
RT_INTERFACE!{interface IShareProvider(IShareProviderVtbl): IInspectable [IID_IShareProvider] {
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_DisplayIcon(&self, out: *mut <super::super::storage::streams::RandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_BackgroundColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    fn get_Tag(&self, out: *mut <IInspectable as RtType>::Abi) -> HRESULT,
    fn put_Tag(&self, value: <IInspectable as RtType>::Abi) -> HRESULT
}}
impl IShareProvider {
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Title)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_display_icon(&self) -> Result<Option<super::super::storage::streams::RandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayIcon)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::RandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_background_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_BackgroundColor)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tag(&self) -> Result<Option<IInspectable>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Tag)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IInspectable::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_tag(&self, value: &IInspectable) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Tag)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ShareProvider: IShareProvider}
impl RtActivatable<IShareProviderFactory> for ShareProvider {}
impl ShareProvider {
    #[cfg(all(feature="windows-storage",feature="windows-ui"))] #[inline] pub fn create(title: &HStringArg, displayIcon: &super::super::storage::streams::RandomAccessStreamReference, backgroundColor: super::super::ui::Color, handler: &ShareProviderHandler) -> Result<ShareProvider> {
        <Self as RtActivatable<IShareProviderFactory>>::get_activation_factory().create(title, displayIcon, backgroundColor, handler)
    }
}
DEFINE_CLSID!(ShareProvider(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,68,97,116,97,84,114,97,110,115,102,101,114,46,83,104,97,114,101,80,114,111,118,105,100,101,114,0]) [CLSID_ShareProvider]);
DEFINE_IID!(IID_IShareProviderFactory, 388634444, 59294, 20333, 176, 125, 18, 143, 70, 158, 2, 150);
RT_INTERFACE!{static interface IShareProviderFactory(IShareProviderFactoryVtbl): IInspectable [IID_IShareProviderFactory] {
    #[cfg(all(feature="windows-storage",feature="windows-ui"))] fn Create(&self, title: HSTRING, displayIcon: <super::super::storage::streams::RandomAccessStreamReference as RtType>::Abi, backgroundColor: super::super::ui::Color, handler: <ShareProviderHandler as RtType>::Abi, out: *mut <ShareProvider as RtType>::Abi) -> HRESULT
}}
impl IShareProviderFactory {
    #[cfg(all(feature="windows-storage",feature="windows-ui"))] #[inline] pub fn create(&self, title: &HStringArg, displayIcon: &super::super::storage::streams::RandomAccessStreamReference, backgroundColor: super::super::ui::Color, handler: &ShareProviderHandler) -> Result<ShareProvider> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, title.get(), displayIcon.get_abi() as *const _ as *mut _, backgroundColor, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ShareProvider::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ShareProviderHandler, 3891911098, 57786, 20045, 189, 101, 212, 56, 69, 211, 33, 47);
RT_DELEGATE!{delegate ShareProviderHandler(ShareProviderHandlerVtbl, ShareProviderHandlerImpl) [IID_ShareProviderHandler] {
    fn Invoke(&self, operation: <ShareProviderOperation as RtType>::Abi) -> HRESULT
}}
impl ShareProviderHandler {
    #[inline] pub fn invoke(&self, operation: &ShareProviderOperation) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Invoke)(self.get_abi() as *const _ as *mut _, operation.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IShareProviderOperation, 432994615, 54325, 16761, 182, 175, 20, 224, 73, 43, 105, 246);
RT_INTERFACE!{interface IShareProviderOperation(IShareProviderOperationVtbl): IInspectable [IID_IShareProviderOperation] {
    fn get_Data(&self, out: *mut <DataPackageView as RtType>::Abi) -> HRESULT,
    fn get_Provider(&self, out: *mut <ShareProvider as RtType>::Abi) -> HRESULT,
    fn ReportCompleted(&self) -> HRESULT
}}
impl IShareProviderOperation {
    #[inline] pub fn get_data(&self) -> Result<Option<DataPackageView>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Data)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DataPackageView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_provider(&self) -> Result<Option<ShareProvider>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Provider)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ShareProvider::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportCompleted)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ShareProviderOperation: IShareProviderOperation}
DEFINE_IID!(IID_IShareProvidersRequestedEventArgs, 4169724758, 41976, 20430, 133, 228, 136, 38, 230, 59, 231, 153);
RT_INTERFACE!{interface IShareProvidersRequestedEventArgs(IShareProvidersRequestedEventArgsVtbl): IInspectable [IID_IShareProvidersRequestedEventArgs] {
    fn get_Providers(&self, out: *mut <foundation::collections::IVector<ShareProvider> as RtType>::Abi) -> HRESULT,
    fn get_Data(&self, out: *mut <DataPackageView as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IShareProvidersRequestedEventArgs {
    #[inline] pub fn get_providers(&self) -> Result<Option<foundation::collections::IVector<ShareProvider>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Providers)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_data(&self) -> Result<Option<DataPackageView>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Data)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DataPackageView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ShareProvidersRequestedEventArgs: IShareProvidersRequestedEventArgs}
DEFINE_IID!(IID_IShareTargetInfo, 945546759, 50920, 16660, 178, 148, 40, 243, 187, 111, 153, 4);
RT_INTERFACE!{interface IShareTargetInfo(IShareTargetInfoVtbl): IInspectable [IID_IShareTargetInfo] {
    fn get_AppUserModelId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ShareProvider(&self, out: *mut <ShareProvider as RtType>::Abi) -> HRESULT
}}
impl IShareTargetInfo {
    #[inline] pub fn get_app_user_model_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppUserModelId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_share_provider(&self) -> Result<Option<ShareProvider>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ShareProvider)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ShareProvider::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ShareTargetInfo: IShareTargetInfo}
DEFINE_IID!(IID_IShareUIOptions, 1929022080, 13359, 19856, 149, 81, 42, 224, 78, 55, 104, 12);
RT_INTERFACE!{interface IShareUIOptions(IShareUIOptionsVtbl): IInspectable [IID_IShareUIOptions] {
    fn get_Theme(&self, out: *mut ShareUITheme) -> HRESULT,
    fn put_Theme(&self, value: ShareUITheme) -> HRESULT,
    fn get_SelectionRect(&self, out: *mut <foundation::IReference<foundation::Rect> as RtType>::Abi) -> HRESULT,
    fn put_SelectionRect(&self, value: <foundation::IReference<foundation::Rect> as RtType>::Abi) -> HRESULT
}}
impl IShareUIOptions {
    #[inline] pub fn get_theme(&self) -> Result<ShareUITheme> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Theme)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_theme(&self, value: ShareUITheme) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Theme)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_selection_rect(&self) -> Result<Option<foundation::IReference<foundation::Rect>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SelectionRect)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_selection_rect(&self, value: &foundation::IReference<foundation::Rect>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SelectionRect)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ShareUIOptions: IShareUIOptions}
impl RtActivatable<IActivationFactory> for ShareUIOptions {}
DEFINE_CLSID!(ShareUIOptions(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,68,97,116,97,84,114,97,110,115,102,101,114,46,83,104,97,114,101,85,73,79,112,116,105,111,110,115,0]) [CLSID_ShareUIOptions]);
RT_ENUM! { enum ShareUITheme: i32 {
    Default = 0, Light = 1, Dark = 2,
}}
RT_CLASS!{static class StandardDataFormats}
impl RtActivatable<IStandardDataFormatsStatics> for StandardDataFormats {}
impl RtActivatable<IStandardDataFormatsStatics2> for StandardDataFormats {}
impl RtActivatable<IStandardDataFormatsStatics3> for StandardDataFormats {}
impl StandardDataFormats {
    #[inline] pub fn get_text() -> Result<HString> {
        <Self as RtActivatable<IStandardDataFormatsStatics>>::get_activation_factory().get_text()
    }
    #[inline] pub fn get_uri() -> Result<HString> {
        <Self as RtActivatable<IStandardDataFormatsStatics>>::get_activation_factory().get_uri()
    }
    #[inline] pub fn get_html() -> Result<HString> {
        <Self as RtActivatable<IStandardDataFormatsStatics>>::get_activation_factory().get_html()
    }
    #[inline] pub fn get_rtf() -> Result<HString> {
        <Self as RtActivatable<IStandardDataFormatsStatics>>::get_activation_factory().get_rtf()
    }
    #[inline] pub fn get_bitmap() -> Result<HString> {
        <Self as RtActivatable<IStandardDataFormatsStatics>>::get_activation_factory().get_bitmap()
    }
    #[inline] pub fn get_storage_items() -> Result<HString> {
        <Self as RtActivatable<IStandardDataFormatsStatics>>::get_activation_factory().get_storage_items()
    }
    #[inline] pub fn get_web_link() -> Result<HString> {
        <Self as RtActivatable<IStandardDataFormatsStatics2>>::get_activation_factory().get_web_link()
    }
    #[inline] pub fn get_application_link() -> Result<HString> {
        <Self as RtActivatable<IStandardDataFormatsStatics2>>::get_activation_factory().get_application_link()
    }
    #[inline] pub fn get_user_activity_json_array() -> Result<HString> {
        <Self as RtActivatable<IStandardDataFormatsStatics3>>::get_activation_factory().get_user_activity_json_array()
    }
}
DEFINE_CLSID!(StandardDataFormats(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,68,97,116,97,84,114,97,110,115,102,101,114,46,83,116,97,110,100,97,114,100,68,97,116,97,70,111,114,109,97,116,115,0]) [CLSID_StandardDataFormats]);
DEFINE_IID!(IID_IStandardDataFormatsStatics, 2127987105, 43136, 16585, 180, 237, 11, 238, 30, 21, 245, 73);
RT_INTERFACE!{static interface IStandardDataFormatsStatics(IStandardDataFormatsStaticsVtbl): IInspectable [IID_IStandardDataFormatsStatics] {
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Uri(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Html(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Rtf(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Bitmap(&self, out: *mut HSTRING) -> HRESULT,
    fn get_StorageItems(&self, out: *mut HSTRING) -> HRESULT
}}
impl IStandardDataFormatsStatics {
    #[inline] pub fn get_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Text)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_uri(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Uri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_html(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Html)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_rtf(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Rtf)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_bitmap(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Bitmap)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_storage_items(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_StorageItems)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IStandardDataFormatsStatics2, 1117934836, 40310, 17128, 134, 27, 71, 194, 93, 208, 207, 113);
RT_INTERFACE!{static interface IStandardDataFormatsStatics2(IStandardDataFormatsStatics2Vtbl): IInspectable [IID_IStandardDataFormatsStatics2] {
    fn get_WebLink(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ApplicationLink(&self, out: *mut HSTRING) -> HRESULT
}}
impl IStandardDataFormatsStatics2 {
    #[inline] pub fn get_web_link(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_WebLink)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_application_link(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ApplicationLink)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IStandardDataFormatsStatics3, 995602537, 468, 18252, 139, 95, 188, 142, 39, 243, 139, 33);
RT_INTERFACE!{static interface IStandardDataFormatsStatics3(IStandardDataFormatsStatics3Vtbl): IInspectable [IID_IStandardDataFormatsStatics3] {
    fn get_UserActivityJsonArray(&self, out: *mut HSTRING) -> HRESULT
}}
impl IStandardDataFormatsStatics3 {
    #[inline] pub fn get_user_activity_json_array(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_UserActivityJsonArray)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ITargetApplicationChosenEventArgs, 3396319404, 10631, 20195, 156, 84, 216, 175, 188, 184, 108, 29);
RT_INTERFACE!{interface ITargetApplicationChosenEventArgs(ITargetApplicationChosenEventArgsVtbl): IInspectable [IID_ITargetApplicationChosenEventArgs] {
    fn get_ApplicationName(&self, out: *mut HSTRING) -> HRESULT
}}
impl ITargetApplicationChosenEventArgs {
    #[inline] pub fn get_application_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ApplicationName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class TargetApplicationChosenEventArgs: ITargetApplicationChosenEventArgs}
pub mod dragdrop { // Windows.ApplicationModel.DataTransfer.DragDrop
use crate::prelude::*;
RT_ENUM! { enum DragDropModifiers: u32 {
    None = 0, Shift = 1, Control = 2, Alt = 4, LeftButton = 8, MiddleButton = 16, RightButton = 32,
}}
pub mod core { // Windows.ApplicationModel.DataTransfer.DragDrop.Core
use crate::prelude::*;
DEFINE_IID!(IID_ICoreDragDropManager, 2102842180, 33892, 20399, 170, 73, 55, 234, 110, 45, 123, 209);
RT_INTERFACE!{interface ICoreDragDropManager(ICoreDragDropManagerVtbl): IInspectable [IID_ICoreDragDropManager] {
    fn add_TargetRequested(&self, value: <foundation::TypedEventHandler<CoreDragDropManager, CoreDropOperationTargetRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TargetRequested(&self, value: foundation::EventRegistrationToken) -> HRESULT,
    fn get_AreConcurrentOperationsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_AreConcurrentOperationsEnabled(&self, value: bool) -> HRESULT
}}
impl ICoreDragDropManager {
    #[inline] pub fn add_target_requested(&self, value: &foundation::TypedEventHandler<CoreDragDropManager, CoreDropOperationTargetRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_TargetRequested)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_target_requested(&self, value: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_TargetRequested)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_are_concurrent_operations_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AreConcurrentOperationsEnabled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_are_concurrent_operations_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AreConcurrentOperationsEnabled)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreDragDropManager: ICoreDragDropManager}
impl RtActivatable<ICoreDragDropManagerStatics> for CoreDragDropManager {}
impl CoreDragDropManager {
    #[inline] pub fn get_for_current_view() -> Result<Option<CoreDragDropManager>> {
        <Self as RtActivatable<ICoreDragDropManagerStatics>>::get_activation_factory().get_for_current_view()
    }
}
DEFINE_CLSID!(CoreDragDropManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,68,97,116,97,84,114,97,110,115,102,101,114,46,68,114,97,103,68,114,111,112,46,67,111,114,101,46,67,111,114,101,68,114,97,103,68,114,111,112,77,97,110,97,103,101,114,0]) [CLSID_CoreDragDropManager]);
DEFINE_IID!(IID_ICoreDragDropManagerStatics, 2504195530, 55826, 19484, 141, 6, 4, 29, 178, 151, 51, 195);
RT_INTERFACE!{static interface ICoreDragDropManagerStatics(ICoreDragDropManagerStaticsVtbl): IInspectable [IID_ICoreDragDropManagerStatics] {
    fn GetForCurrentView(&self, out: *mut <CoreDragDropManager as RtType>::Abi) -> HRESULT
}}
impl ICoreDragDropManagerStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<CoreDragDropManager>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetForCurrentView)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CoreDragDropManager::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreDragInfo, 1211447947, 52048, 17998, 149, 117, 205, 78, 58, 122, 176, 40);
RT_INTERFACE!{interface ICoreDragInfo(ICoreDragInfoVtbl): IInspectable [IID_ICoreDragInfo] {
    fn get_Data(&self, out: *mut <super::super::DataPackageView as RtType>::Abi) -> HRESULT,
    fn get_Modifiers(&self, out: *mut super::DragDropModifiers) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::Point) -> HRESULT
}}
impl ICoreDragInfo {
    #[inline] pub fn get_data(&self) -> Result<Option<super::super::DataPackageView>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Data)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::DataPackageView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_modifiers(&self) -> Result<super::DragDropModifiers> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Modifiers)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Position)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreDragInfo: ICoreDragInfo}
DEFINE_IID!(IID_ICoreDragInfo2, 3309736421, 59131, 19828, 180, 177, 138, 60, 23, 242, 94, 158);
RT_INTERFACE!{interface ICoreDragInfo2(ICoreDragInfo2Vtbl): IInspectable [IID_ICoreDragInfo2] {
    fn get_AllowedOperations(&self, out: *mut super::super::DataPackageOperation) -> HRESULT
}}
impl ICoreDragInfo2 {
    #[inline] pub fn get_allowed_operations(&self) -> Result<super::super::DataPackageOperation> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AllowedOperations)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreDragOperation, 3423002191, 28080, 20066, 171, 27, 167, 74, 2, 220, 109, 133);
RT_INTERFACE!{interface ICoreDragOperation(ICoreDragOperationVtbl): IInspectable [IID_ICoreDragOperation] {
    fn get_Data(&self, out: *mut <super::super::DataPackage as RtType>::Abi) -> HRESULT,
    fn SetPointerId(&self, pointerId: u32) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-graphics")] fn SetDragUIContentFromSoftwareBitmap(&self, softwareBitmap: <crate::windows::graphics::imaging::SoftwareBitmap as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-graphics")] fn SetDragUIContentFromSoftwareBitmapWithAnchorPoint(&self, softwareBitmap: <crate::windows::graphics::imaging::SoftwareBitmap as RtType>::Abi, anchorPoint: foundation::Point) -> HRESULT,
    fn get_DragUIContentMode(&self, out: *mut CoreDragUIContentMode) -> HRESULT,
    fn put_DragUIContentMode(&self, value: CoreDragUIContentMode) -> HRESULT,
    fn StartAsync(&self, out: *mut <foundation::IAsyncOperation<super::super::DataPackageOperation> as RtType>::Abi) -> HRESULT
}}
impl ICoreDragOperation {
    #[inline] pub fn get_data(&self) -> Result<Option<super::super::DataPackage>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Data)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::DataPackage::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_pointer_id(&self, pointerId: u32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetPointerId)(self.get_abi() as *const _ as *mut _, pointerId);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_drag_ui_content_from_software_bitmap(&self, softwareBitmap: &crate::windows::graphics::imaging::SoftwareBitmap) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetDragUIContentFromSoftwareBitmap)(self.get_abi() as *const _ as *mut _, softwareBitmap.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_drag_ui_content_from_software_bitmap_with_anchor_point(&self, softwareBitmap: &crate::windows::graphics::imaging::SoftwareBitmap, anchorPoint: foundation::Point) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetDragUIContentFromSoftwareBitmapWithAnchorPoint)(self.get_abi() as *const _ as *mut _, softwareBitmap.get_abi() as *const _ as *mut _, anchorPoint);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_drag_ui_content_mode(&self) -> Result<CoreDragUIContentMode> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DragUIContentMode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_drag_ui_content_mode(&self, value: CoreDragUIContentMode) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DragUIContentMode)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_async(&self) -> Result<foundation::IAsyncOperation<super::super::DataPackageOperation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().StartAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreDragOperation: ICoreDragOperation}
impl RtActivatable<IActivationFactory> for CoreDragOperation {}
DEFINE_CLSID!(CoreDragOperation(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,68,97,116,97,84,114,97,110,115,102,101,114,46,68,114,97,103,68,114,111,112,46,67,111,114,101,46,67,111,114,101,68,114,97,103,79,112,101,114,97,116,105,111,110,0]) [CLSID_CoreDragOperation]);
DEFINE_IID!(IID_ICoreDragOperation2, 2185961004, 55706, 20419, 133, 7, 108, 24, 47, 51, 180, 106);
RT_INTERFACE!{interface ICoreDragOperation2(ICoreDragOperation2Vtbl): IInspectable [IID_ICoreDragOperation2] {
    fn get_AllowedOperations(&self, out: *mut super::super::DataPackageOperation) -> HRESULT,
    fn put_AllowedOperations(&self, value: super::super::DataPackageOperation) -> HRESULT
}}
impl ICoreDragOperation2 {
    #[inline] pub fn get_allowed_operations(&self) -> Result<super::super::DataPackageOperation> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AllowedOperations)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_allowed_operations(&self, value: super::super::DataPackageOperation) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AllowedOperations)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum CoreDragUIContentMode: u32 {
    Auto = 0, Deferred = 1,
}}
DEFINE_IID!(IID_ICoreDragUIOverride, 2309509220, 13193, 20303, 136, 151, 126, 138, 63, 251, 60, 147);
RT_INTERFACE!{interface ICoreDragUIOverride(ICoreDragUIOverrideVtbl): IInspectable [IID_ICoreDragUIOverride] {
    #[cfg(not(feature="windows-graphics"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-graphics")] fn SetContentFromSoftwareBitmap(&self, softwareBitmap: <crate::windows::graphics::imaging::SoftwareBitmap as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-graphics")] fn SetContentFromSoftwareBitmapWithAnchorPoint(&self, softwareBitmap: <crate::windows::graphics::imaging::SoftwareBitmap as RtType>::Abi, anchorPoint: foundation::Point) -> HRESULT,
    fn get_IsContentVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsContentVisible(&self, value: bool) -> HRESULT,
    fn get_Caption(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Caption(&self, value: HSTRING) -> HRESULT,
    fn get_IsCaptionVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsCaptionVisible(&self, value: bool) -> HRESULT,
    fn get_IsGlyphVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsGlyphVisible(&self, value: bool) -> HRESULT,
    fn Clear(&self) -> HRESULT
}}
impl ICoreDragUIOverride {
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_content_from_software_bitmap(&self, softwareBitmap: &crate::windows::graphics::imaging::SoftwareBitmap) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetContentFromSoftwareBitmap)(self.get_abi() as *const _ as *mut _, softwareBitmap.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_content_from_software_bitmap_with_anchor_point(&self, softwareBitmap: &crate::windows::graphics::imaging::SoftwareBitmap, anchorPoint: foundation::Point) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetContentFromSoftwareBitmapWithAnchorPoint)(self.get_abi() as *const _ as *mut _, softwareBitmap.get_abi() as *const _ as *mut _, anchorPoint);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_content_visible(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsContentVisible)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_content_visible(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsContentVisible)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_caption(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Caption)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_caption(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Caption)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_caption_visible(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsCaptionVisible)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_caption_visible(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsCaptionVisible)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_glyph_visible(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsGlyphVisible)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_glyph_visible(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsGlyphVisible)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn clear(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Clear)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreDragUIOverride: ICoreDragUIOverride}
DEFINE_IID!(IID_ICoreDropOperationTarget, 3641860502, 19547, 16765, 187, 55, 118, 56, 29, 239, 141, 180);
RT_INTERFACE!{interface ICoreDropOperationTarget(ICoreDropOperationTargetVtbl): IInspectable [IID_ICoreDropOperationTarget] {
    fn EnterAsync(&self, dragInfo: <CoreDragInfo as RtType>::Abi, dragUIOverride: <CoreDragUIOverride as RtType>::Abi, out: *mut <foundation::IAsyncOperation<super::super::DataPackageOperation> as RtType>::Abi) -> HRESULT,
    fn OverAsync(&self, dragInfo: <CoreDragInfo as RtType>::Abi, dragUIOverride: <CoreDragUIOverride as RtType>::Abi, out: *mut <foundation::IAsyncOperation<super::super::DataPackageOperation> as RtType>::Abi) -> HRESULT,
    fn LeaveAsync(&self, dragInfo: <CoreDragInfo as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn DropAsync(&self, dragInfo: <CoreDragInfo as RtType>::Abi, out: *mut <foundation::IAsyncOperation<super::super::DataPackageOperation> as RtType>::Abi) -> HRESULT
}}
impl ICoreDropOperationTarget {
    #[inline] pub fn enter_async(&self, dragInfo: &CoreDragInfo, dragUIOverride: &CoreDragUIOverride) -> Result<foundation::IAsyncOperation<super::super::DataPackageOperation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().EnterAsync)(self.get_abi() as *const _ as *mut _, dragInfo.get_abi() as *const _ as *mut _, dragUIOverride.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn over_async(&self, dragInfo: &CoreDragInfo, dragUIOverride: &CoreDragUIOverride) -> Result<foundation::IAsyncOperation<super::super::DataPackageOperation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().OverAsync)(self.get_abi() as *const _ as *mut _, dragInfo.get_abi() as *const _ as *mut _, dragUIOverride.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn leave_async(&self, dragInfo: &CoreDragInfo) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().LeaveAsync)(self.get_abi() as *const _ as *mut _, dragInfo.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn drop_async(&self, dragInfo: &CoreDragInfo) -> Result<foundation::IAsyncOperation<super::super::DataPackageOperation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DropAsync)(self.get_abi() as *const _ as *mut _, dragInfo.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreDropOperationTargetRequestedEventArgs, 717918874, 24104, 20134, 130, 158, 41, 19, 78, 102, 93, 109);
RT_INTERFACE!{interface ICoreDropOperationTargetRequestedEventArgs(ICoreDropOperationTargetRequestedEventArgsVtbl): IInspectable [IID_ICoreDropOperationTargetRequestedEventArgs] {
    fn SetTarget(&self, target: <ICoreDropOperationTarget as RtType>::Abi) -> HRESULT
}}
impl ICoreDropOperationTargetRequestedEventArgs {
    #[inline] pub fn set_target(&self, target: &ICoreDropOperationTarget) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetTarget)(self.get_abi() as *const _ as *mut _, target.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreDropOperationTargetRequestedEventArgs: ICoreDropOperationTargetRequestedEventArgs}
} // Windows.ApplicationModel.DataTransfer.DragDrop.Core
} // Windows.ApplicationModel.DataTransfer.DragDrop
pub mod sharetarget { // Windows.ApplicationModel.DataTransfer.ShareTarget
use crate::prelude::*;
DEFINE_IID!(IID_IQuickLink, 1614693128, 61630, 19164, 172, 201, 139, 39, 171, 156, 245, 86);
RT_INTERFACE!{interface IQuickLink(IQuickLinkVtbl): IInspectable [IID_IQuickLink] {
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Thumbnail(&self, out: *mut <crate::windows::storage::streams::RandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Thumbnail(&self, value: <crate::windows::storage::streams::RandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Id(&self, value: HSTRING) -> HRESULT,
    fn get_SupportedDataFormats(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT,
    fn get_SupportedFileTypes(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT
}}
impl IQuickLink {
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Title)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_title(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Title)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_thumbnail(&self) -> Result<Option<crate::windows::storage::streams::RandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Thumbnail)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::RandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_thumbnail(&self, value: &crate::windows::storage::streams::RandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Thumbnail)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Id)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_data_formats(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SupportedDataFormats)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_file_types(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SupportedFileTypes)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class QuickLink: IQuickLink}
impl RtActivatable<IActivationFactory> for QuickLink {}
DEFINE_CLSID!(QuickLink(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,68,97,116,97,84,114,97,110,115,102,101,114,46,83,104,97,114,101,84,97,114,103,101,116,46,81,117,105,99,107,76,105,110,107,0]) [CLSID_QuickLink]);
DEFINE_IID!(IID_IShareOperation, 575060664, 53496, 16833, 168, 42, 65, 55, 219, 101, 4, 251);
RT_INTERFACE!{interface IShareOperation(IShareOperationVtbl): IInspectable [IID_IShareOperation] {
    fn get_Data(&self, out: *mut <super::DataPackageView as RtType>::Abi) -> HRESULT,
    fn get_QuickLinkId(&self, out: *mut HSTRING) -> HRESULT,
    fn RemoveThisQuickLink(&self) -> HRESULT,
    fn ReportStarted(&self) -> HRESULT,
    fn ReportDataRetrieved(&self) -> HRESULT,
    fn ReportSubmittedBackgroundTask(&self) -> HRESULT,
    fn ReportCompletedWithQuickLink(&self, quicklink: <QuickLink as RtType>::Abi) -> HRESULT,
    fn ReportCompleted(&self) -> HRESULT,
    fn ReportError(&self, value: HSTRING) -> HRESULT
}}
impl IShareOperation {
    #[inline] pub fn get_data(&self) -> Result<Option<super::DataPackageView>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Data)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::DataPackageView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_quick_link_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_QuickLinkId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn remove_this_quick_link(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().RemoveThisQuickLink)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn report_started(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportStarted)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn report_data_retrieved(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportDataRetrieved)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn report_submitted_background_task(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportSubmittedBackgroundTask)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_with_quick_link(&self, quicklink: &QuickLink) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportCompletedWithQuickLink)(self.get_abi() as *const _ as *mut _, quicklink.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn report_completed(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportCompleted)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn report_error(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportError)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ShareOperation: IShareOperation}
DEFINE_IID!(IID_IShareOperation2, 268146625, 38776, 18953, 142, 91, 203, 94, 72, 45, 5, 85);
RT_INTERFACE!{interface IShareOperation2(IShareOperation2Vtbl): IInspectable [IID_IShareOperation2] {
    fn DismissUI(&self) -> HRESULT
}}
impl IShareOperation2 {
    #[inline] pub fn dismiss_ui(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().DismissUI)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IShareOperation3, 1593226114, 47015, 17777, 162, 166, 153, 74, 3, 73, 136, 178);
RT_INTERFACE!{interface IShareOperation3(IShareOperation3Vtbl): IInspectable [IID_IShareOperation3] {
    fn get_Contacts(&self, out: *mut <foundation::collections::IVectorView<super::super::contacts::Contact> as RtType>::Abi) -> HRESULT
}}
impl IShareOperation3 {
    #[inline] pub fn get_contacts(&self) -> Result<Option<foundation::collections::IVectorView<super::super::contacts::Contact>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Contacts)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
} // Windows.ApplicationModel.DataTransfer.ShareTarget
} // Windows.ApplicationModel.DataTransfer
pub mod email { // Windows.ApplicationModel.Email
use crate::prelude::*;
DEFINE_IID!(IID_IEmailAttachment, 4082354937, 22472, 19163, 185, 146, 96, 252, 235, 88, 79, 84);
RT_INTERFACE!{interface IEmailAttachment(IEmailAttachmentVtbl): IInspectable [IID_IEmailAttachment] {
    fn get_FileName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_FileName(&self, value: HSTRING) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_Data(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_Data(&self, value: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT
}}
impl IEmailAttachment {
    #[inline] pub fn get_file_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_FileName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_file_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_FileName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_data(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Data)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_data(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Data)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailAttachment: IEmailAttachment}
impl RtActivatable<IEmailAttachmentFactory> for EmailAttachment {}
impl RtActivatable<IEmailAttachmentFactory2> for EmailAttachment {}
impl RtActivatable<IActivationFactory> for EmailAttachment {}
impl EmailAttachment {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(fileName: &HStringArg, data: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<EmailAttachment> {
        <Self as RtActivatable<IEmailAttachmentFactory>>::get_activation_factory().create(fileName, data)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn create2(fileName: &HStringArg, data: &super::super::storage::streams::IRandomAccessStreamReference, mimeType: &HStringArg) -> Result<EmailAttachment> {
        <Self as RtActivatable<IEmailAttachmentFactory2>>::get_activation_factory().create(fileName, data, mimeType)
    }
}
DEFINE_CLSID!(EmailAttachment(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,69,109,97,105,108,46,69,109,97,105,108,65,116,116,97,99,104,109,101,110,116,0]) [CLSID_EmailAttachment]);
DEFINE_IID!(IID_IEmailAttachment2, 576655472, 45311, 17777, 157, 84, 167, 6, 196, 141, 85, 198);
RT_INTERFACE!{interface IEmailAttachment2(IEmailAttachment2Vtbl): IInspectable [IID_IEmailAttachment2] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ContentId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ContentId(&self, value: HSTRING) -> HRESULT,
    fn get_ContentLocation(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ContentLocation(&self, value: HSTRING) -> HRESULT,
    fn get_DownloadState(&self, out: *mut EmailAttachmentDownloadState) -> HRESULT,
    fn put_DownloadState(&self, value: EmailAttachmentDownloadState) -> HRESULT,
    fn get_EstimatedDownloadSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn put_EstimatedDownloadSizeInBytes(&self, value: u64) -> HRESULT,
    fn get_IsFromBaseMessage(&self, out: *mut bool) -> HRESULT,
    fn get_IsInline(&self, out: *mut bool) -> HRESULT,
    fn put_IsInline(&self, value: bool) -> HRESULT,
    fn get_MimeType(&self, out: *mut HSTRING) -> HRESULT,
    fn put_MimeType(&self, value: HSTRING) -> HRESULT
}}
impl IEmailAttachment2 {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_content_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContentId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_content_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ContentId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_content_location(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContentLocation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_content_location(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ContentLocation)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_download_state(&self) -> Result<EmailAttachmentDownloadState> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DownloadState)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_download_state(&self, value: EmailAttachmentDownloadState) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DownloadState)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_estimated_download_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_EstimatedDownloadSizeInBytes)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_estimated_download_size_in_bytes(&self, value: u64) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_EstimatedDownloadSizeInBytes)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_from_base_message(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsFromBaseMessage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_inline(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsInline)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_inline(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsInline)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_mime_type(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MimeType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_mime_type(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MimeType)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum EmailAttachmentDownloadState: i32 {
    NotDownloaded = 0, Downloading = 1, Downloaded = 2, Failed = 3,
}}
DEFINE_IID!(IID_IEmailAttachmentFactory, 2037296198, 60758, 18809, 135, 8, 171, 184, 188, 133, 75, 125);
RT_INTERFACE!{static interface IEmailAttachmentFactory(IEmailAttachmentFactoryVtbl): IInspectable [IID_IEmailAttachmentFactory] {
    #[cfg(feature="windows-storage")] fn Create(&self, fileName: HSTRING, data: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi, out: *mut <EmailAttachment as RtType>::Abi) -> HRESULT
}}
impl IEmailAttachmentFactory {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(&self, fileName: &HStringArg, data: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<EmailAttachment> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, fileName.get(), data.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailAttachment::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IEmailAttachmentFactory2, 589665333, 20985, 17021, 173, 205, 36, 16, 35, 200, 207, 183);
RT_INTERFACE!{static interface IEmailAttachmentFactory2(IEmailAttachmentFactory2Vtbl): IInspectable [IID_IEmailAttachmentFactory2] {
    #[cfg(feature="windows-storage")] fn Create(&self, fileName: HSTRING, data: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi, mimeType: HSTRING, out: *mut <EmailAttachment as RtType>::Abi) -> HRESULT
}}
impl IEmailAttachmentFactory2 {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(&self, fileName: &HStringArg, data: &super::super::storage::streams::IRandomAccessStreamReference, mimeType: &HStringArg) -> Result<EmailAttachment> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, fileName.get(), data.get_abi() as *const _ as *mut _, mimeType.get(), &mut out);
        if hr == S_OK { Ok(EmailAttachment::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum EmailBatchStatus: i32 {
    Success = 0, ServerSearchSyncManagerError = 1, ServerSearchUnknownError = 2,
}}
RT_ENUM! { enum EmailCertificateValidationStatus: i32 {
    Success = 0, NoMatch = 1, InvalidUsage = 2, InvalidCertificate = 3, Revoked = 4, ChainRevoked = 5, RevocationServerFailure = 6, Expired = 7, Untrusted = 8, ServerError = 9, UnknownFailure = 10,
}}
DEFINE_IID!(IID_IEmailConversation, 3659055688, 41148, 17225, 144, 45, 144, 246, 99, 137, 245, 27);
RT_INTERFACE!{interface IEmailConversation(IEmailConversationVtbl): IInspectable [IID_IEmailConversation] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FlagState(&self, out: *mut EmailFlagState) -> HRESULT,
    fn get_HasAttachment(&self, out: *mut bool) -> HRESULT,
    fn get_Importance(&self, out: *mut EmailImportance) -> HRESULT,
    fn get_LastEmailResponseKind(&self, out: *mut EmailMessageResponseKind) -> HRESULT,
    fn get_MessageCount(&self, out: *mut u32) -> HRESULT,
    fn get_MostRecentMessageId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MostRecentMessageTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_Preview(&self, out: *mut HSTRING) -> HRESULT,
    fn get_LatestSender(&self, out: *mut <EmailRecipient as RtType>::Abi) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn get_UnreadMessageCount(&self, out: *mut u32) -> HRESULT,
    fn FindMessagesAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<EmailMessage>> as RtType>::Abi) -> HRESULT,
    fn FindMessagesWithCountAsync(&self, count: u32, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<EmailMessage>> as RtType>::Abi) -> HRESULT
}}
impl IEmailConversation {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_mailbox_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MailboxId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_flag_state(&self) -> Result<EmailFlagState> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_FlagState)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_has_attachment(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_HasAttachment)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_importance(&self) -> Result<EmailImportance> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Importance)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_last_email_response_kind(&self) -> Result<EmailMessageResponseKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_LastEmailResponseKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_message_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MessageCount)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_most_recent_message_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MostRecentMessageId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_most_recent_message_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MostRecentMessageTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_preview(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Preview)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_latest_sender(&self) -> Result<Option<EmailRecipient>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LatestSender)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailRecipient::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_subject(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Subject)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_unread_message_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_UnreadMessageCount)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn find_messages_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<EmailMessage>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindMessagesAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_messages_with_count_async(&self, count: u32) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<EmailMessage>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindMessagesWithCountAsync)(self.get_abi() as *const _ as *mut _, count, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailConversation: IEmailConversation}
DEFINE_IID!(IID_IEmailConversationBatch, 3099700097, 453, 17194, 157, 241, 254, 133, 217, 138, 39, 154);
RT_INTERFACE!{interface IEmailConversationBatch(IEmailConversationBatchVtbl): IInspectable [IID_IEmailConversationBatch] {
    fn get_Conversations(&self, out: *mut <foundation::collections::IVectorView<EmailConversation> as RtType>::Abi) -> HRESULT,
    fn get_Status(&self, out: *mut EmailBatchStatus) -> HRESULT
}}
impl IEmailConversationBatch {
    #[inline] pub fn get_conversations(&self) -> Result<Option<foundation::collections::IVectorView<EmailConversation>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Conversations)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<EmailBatchStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailConversationBatch: IEmailConversationBatch}
DEFINE_IID!(IID_IEmailConversationReader, 3026390914, 10357, 17608, 155, 140, 133, 190, 179, 163, 198, 83);
RT_INTERFACE!{interface IEmailConversationReader(IEmailConversationReaderVtbl): IInspectable [IID_IEmailConversationReader] {
    fn ReadBatchAsync(&self, out: *mut <foundation::IAsyncOperation<EmailConversationBatch> as RtType>::Abi) -> HRESULT
}}
impl IEmailConversationReader {
    #[inline] pub fn read_batch_async(&self) -> Result<foundation::IAsyncOperation<EmailConversationBatch>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReadBatchAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailConversationReader: IEmailConversationReader}
RT_ENUM! { enum EmailFlagState: i32 {
    Unflagged = 0, Flagged = 1, Completed = 2, Cleared = 3,
}}
DEFINE_IID!(IID_IEmailFolder, 2723116913, 39276, 18532, 177, 186, 237, 18, 64, 229, 125, 17);
RT_INTERFACE!{interface IEmailFolder(IEmailFolderVtbl): IInspectable [IID_IEmailFolder] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RemoteId(&self, value: HSTRING) -> HRESULT,
    fn get_MailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ParentFolderId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_IsSyncEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsSyncEnabled(&self, value: bool) -> HRESULT,
    fn get_LastSuccessfulSyncTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn put_LastSuccessfulSyncTime(&self, value: foundation::DateTime) -> HRESULT,
    fn get_Kind(&self, out: *mut EmailSpecialFolderKind) -> HRESULT,
    fn CreateFolderAsync(&self, name: HSTRING, out: *mut <foundation::IAsyncOperation<EmailFolder> as RtType>::Abi) -> HRESULT,
    fn DeleteAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn FindChildFoldersAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<EmailFolder>> as RtType>::Abi) -> HRESULT,
    fn GetConversationReader(&self, out: *mut <EmailConversationReader as RtType>::Abi) -> HRESULT,
    fn GetConversationReaderWithOptions(&self, options: <EmailQueryOptions as RtType>::Abi, out: *mut <EmailConversationReader as RtType>::Abi) -> HRESULT,
    fn GetMessageAsync(&self, id: HSTRING, out: *mut <foundation::IAsyncOperation<EmailMessage> as RtType>::Abi) -> HRESULT,
    fn GetMessageReader(&self, out: *mut <EmailMessageReader as RtType>::Abi) -> HRESULT,
    fn GetMessageReaderWithOptions(&self, options: <EmailQueryOptions as RtType>::Abi, out: *mut <EmailMessageReader as RtType>::Abi) -> HRESULT,
    fn GetMessageCountsAsync(&self, out: *mut <foundation::IAsyncOperation<EmailItemCounts> as RtType>::Abi) -> HRESULT,
    fn TryMoveAsync(&self, newParentFolder: <EmailFolder as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryMoveWithNewNameAsync(&self, newParentFolder: <EmailFolder as RtType>::Abi, newFolderName: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TrySaveAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn SaveMessageAsync(&self, message: <EmailMessage as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IEmailFolder {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_remote_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RemoteId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_remote_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RemoteId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_mailbox_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MailboxId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_parent_folder_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ParentFolderId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_sync_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsSyncEnabled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_sync_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsSyncEnabled)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_last_successful_sync_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_LastSuccessfulSyncTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_last_successful_sync_time(&self, value: foundation::DateTime) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_LastSuccessfulSyncTime)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_kind(&self) -> Result<EmailSpecialFolderKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Kind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn create_folder_async(&self, name: &HStringArg) -> Result<foundation::IAsyncOperation<EmailFolder>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateFolderAsync)(self.get_abi() as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_child_folders_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<EmailFolder>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindChildFoldersAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_conversation_reader(&self) -> Result<Option<EmailConversationReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetConversationReader)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailConversationReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_conversation_reader_with_options(&self, options: &EmailQueryOptions) -> Result<Option<EmailConversationReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetConversationReaderWithOptions)(self.get_abi() as *const _ as *mut _, options.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailConversationReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_async(&self, id: &HStringArg) -> Result<foundation::IAsyncOperation<EmailMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetMessageAsync)(self.get_abi() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_reader(&self) -> Result<Option<EmailMessageReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetMessageReader)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMessageReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_reader_with_options(&self, options: &EmailQueryOptions) -> Result<Option<EmailMessageReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetMessageReaderWithOptions)(self.get_abi() as *const _ as *mut _, options.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMessageReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_counts_async(&self) -> Result<foundation::IAsyncOperation<EmailItemCounts>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetMessageCountsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_move_async(&self, newParentFolder: &EmailFolder) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryMoveAsync)(self.get_abi() as *const _ as *mut _, newParentFolder.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_move_with_new_name_async(&self, newParentFolder: &EmailFolder, newFolderName: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryMoveWithNewNameAsync)(self.get_abi() as *const _ as *mut _, newParentFolder.get_abi() as *const _ as *mut _, newFolderName.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_save_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TrySaveAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn save_message_async(&self, message: &EmailMessage) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SaveMessageAsync)(self.get_abi() as *const _ as *mut _, message.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailFolder: IEmailFolder}
RT_ENUM! { enum EmailImportance: i32 {
    Normal = 0, High = 1, Low = 2,
}}
DEFINE_IID!(IID_IEmailIrmInfo, 2431984019, 45472, 20157, 166, 182, 221, 202, 85, 96, 110, 14);
RT_INTERFACE!{interface IEmailIrmInfo(IEmailIrmInfoVtbl): IInspectable [IID_IEmailIrmInfo] {
    fn get_CanEdit(&self, out: *mut bool) -> HRESULT,
    fn put_CanEdit(&self, value: bool) -> HRESULT,
    fn get_CanExtractData(&self, out: *mut bool) -> HRESULT,
    fn put_CanExtractData(&self, value: bool) -> HRESULT,
    fn get_CanForward(&self, out: *mut bool) -> HRESULT,
    fn put_CanForward(&self, value: bool) -> HRESULT,
    fn get_CanModifyRecipientsOnResponse(&self, out: *mut bool) -> HRESULT,
    fn put_CanModifyRecipientsOnResponse(&self, value: bool) -> HRESULT,
    fn get_CanPrintData(&self, out: *mut bool) -> HRESULT,
    fn put_CanPrintData(&self, value: bool) -> HRESULT,
    fn get_CanRemoveIrmOnResponse(&self, out: *mut bool) -> HRESULT,
    fn put_CanRemoveIrmOnResponse(&self, value: bool) -> HRESULT,
    fn get_CanReply(&self, out: *mut bool) -> HRESULT,
    fn put_CanReply(&self, value: bool) -> HRESULT,
    fn get_CanReplyAll(&self, out: *mut bool) -> HRESULT,
    fn put_CanReplyAll(&self, value: bool) -> HRESULT,
    fn get_ExpirationDate(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn put_ExpirationDate(&self, value: foundation::DateTime) -> HRESULT,
    fn get_IsIrmOriginator(&self, out: *mut bool) -> HRESULT,
    fn put_IsIrmOriginator(&self, value: bool) -> HRESULT,
    fn get_IsProgramaticAccessAllowed(&self, out: *mut bool) -> HRESULT,
    fn put_IsProgramaticAccessAllowed(&self, value: bool) -> HRESULT,
    fn get_Template(&self, out: *mut <EmailIrmTemplate as RtType>::Abi) -> HRESULT,
    fn put_Template(&self, value: <EmailIrmTemplate as RtType>::Abi) -> HRESULT
}}
impl IEmailIrmInfo {
    #[inline] pub fn get_can_edit(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanEdit)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_can_edit(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanEdit)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_can_extract_data(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanExtractData)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_can_extract_data(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanExtractData)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_can_forward(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanForward)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_can_forward(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanForward)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_can_modify_recipients_on_response(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanModifyRecipientsOnResponse)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_can_modify_recipients_on_response(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanModifyRecipientsOnResponse)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_can_print_data(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanPrintData)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_can_print_data(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanPrintData)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_can_remove_irm_on_response(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanRemoveIrmOnResponse)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_can_remove_irm_on_response(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanRemoveIrmOnResponse)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_can_reply(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanReply)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_can_reply(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanReply)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_can_reply_all(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanReplyAll)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_can_reply_all(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanReplyAll)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_expiration_date(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ExpirationDate)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_expiration_date(&self, value: foundation::DateTime) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ExpirationDate)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_irm_originator(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsIrmOriginator)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_irm_originator(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsIrmOriginator)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_programatic_access_allowed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsProgramaticAccessAllowed)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_programatic_access_allowed(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsProgramaticAccessAllowed)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_template(&self) -> Result<Option<EmailIrmTemplate>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Template)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailIrmTemplate::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_template(&self, value: &EmailIrmTemplate) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Template)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailIrmInfo: IEmailIrmInfo}
impl RtActivatable<IEmailIrmInfoFactory> for EmailIrmInfo {}
impl RtActivatable<IActivationFactory> for EmailIrmInfo {}
impl EmailIrmInfo {
    #[inline] pub fn create(expiration: foundation::DateTime, irmTemplate: &EmailIrmTemplate) -> Result<EmailIrmInfo> {
        <Self as RtActivatable<IEmailIrmInfoFactory>>::get_activation_factory().create(expiration, irmTemplate)
    }
}
DEFINE_CLSID!(EmailIrmInfo(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,69,109,97,105,108,46,69,109,97,105,108,73,114,109,73,110,102,111,0]) [CLSID_EmailIrmInfo]);
DEFINE_IID!(IID_IEmailIrmInfoFactory, 827044236, 58342, 19835, 190, 141, 145, 169, 99, 17, 176, 27);
RT_INTERFACE!{static interface IEmailIrmInfoFactory(IEmailIrmInfoFactoryVtbl): IInspectable [IID_IEmailIrmInfoFactory] {
    fn Create(&self, expiration: foundation::DateTime, irmTemplate: <EmailIrmTemplate as RtType>::Abi, out: *mut <EmailIrmInfo as RtType>::Abi) -> HRESULT
}}
impl IEmailIrmInfoFactory {
    #[inline] pub fn create(&self, expiration: foundation::DateTime, irmTemplate: &EmailIrmTemplate) -> Result<EmailIrmInfo> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, expiration, irmTemplate.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailIrmInfo::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IEmailIrmTemplate, 4079449485, 21613, 19434, 169, 99, 84, 163, 139, 44, 192, 22);
RT_INTERFACE!{interface IEmailIrmTemplate(IEmailIrmTemplateVtbl): IInspectable [IID_IEmailIrmTemplate] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Id(&self, value: HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT
}}
impl IEmailIrmTemplate {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Id)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Description)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_description(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Description)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Name)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Name)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailIrmTemplate: IEmailIrmTemplate}
impl RtActivatable<IEmailIrmTemplateFactory> for EmailIrmTemplate {}
impl RtActivatable<IActivationFactory> for EmailIrmTemplate {}
impl EmailIrmTemplate {
    #[inline] pub fn create(id: &HStringArg, name: &HStringArg, description: &HStringArg) -> Result<EmailIrmTemplate> {
        <Self as RtActivatable<IEmailIrmTemplateFactory>>::get_activation_factory().create(id, name, description)
    }
}
DEFINE_CLSID!(EmailIrmTemplate(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,69,109,97,105,108,46,69,109,97,105,108,73,114,109,84,101,109,112,108,97,116,101,0]) [CLSID_EmailIrmTemplate]);
DEFINE_IID!(IID_IEmailIrmTemplateFactory, 1034098806, 34616, 17432, 185, 203, 71, 27, 147, 111, 231, 30);
RT_INTERFACE!{static interface IEmailIrmTemplateFactory(IEmailIrmTemplateFactoryVtbl): IInspectable [IID_IEmailIrmTemplateFactory] {
    fn Create(&self, id: HSTRING, name: HSTRING, description: HSTRING, out: *mut <EmailIrmTemplate as RtType>::Abi) -> HRESULT
}}
impl IEmailIrmTemplateFactory {
    #[inline] pub fn create(&self, id: &HStringArg, name: &HStringArg, description: &HStringArg) -> Result<EmailIrmTemplate> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, id.get(), name.get(), description.get(), &mut out);
        if hr == S_OK { Ok(EmailIrmTemplate::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IEmailItemCounts, 1540436769, 65224, 19371, 131, 186, 11, 175, 60, 31, 108, 189);
RT_INTERFACE!{interface IEmailItemCounts(IEmailItemCountsVtbl): IInspectable [IID_IEmailItemCounts] {
    fn get_Flagged(&self, out: *mut u32) -> HRESULT,
    fn get_Important(&self, out: *mut u32) -> HRESULT,
    fn get_Total(&self, out: *mut u32) -> HRESULT,
    fn get_Unread(&self, out: *mut u32) -> HRESULT
}}
impl IEmailItemCounts {
    #[inline] pub fn get_flagged(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Flagged)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_important(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Important)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_total(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Total)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_unread(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Unread)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailItemCounts: IEmailItemCounts}
DEFINE_IID!(IID_IEmailMailbox, 2826503753, 53083, 16667, 128, 177, 74, 106, 20, 132, 206, 37);
RT_INTERFACE!{interface IEmailMailbox(IEmailMailboxVtbl): IInspectable [IID_IEmailMailbox] {
    fn get_Capabilities(&self, out: *mut <EmailMailboxCapabilities as RtType>::Abi) -> HRESULT,
    fn get_ChangeTracker(&self, out: *mut <EmailMailboxChangeTracker as RtType>::Abi) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsOwnedByCurrentApp(&self, out: *mut bool) -> HRESULT,
    fn get_IsDataEncryptedUnderLock(&self, out: *mut bool) -> HRESULT,
    fn get_MailAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn put_MailAddress(&self, value: HSTRING) -> HRESULT,
    fn get_MailAddressAliases(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT,
    fn get_OtherAppReadAccess(&self, out: *mut EmailMailboxOtherAppReadAccess) -> HRESULT,
    fn put_OtherAppReadAccess(&self, value: EmailMailboxOtherAppReadAccess) -> HRESULT,
    fn get_OtherAppWriteAccess(&self, out: *mut EmailMailboxOtherAppWriteAccess) -> HRESULT,
    fn put_OtherAppWriteAccess(&self, value: EmailMailboxOtherAppWriteAccess) -> HRESULT,
    fn get_Policies(&self, out: *mut <EmailMailboxPolicies as RtType>::Abi) -> HRESULT,
    fn get_SourceDisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SyncManager(&self, out: *mut <EmailMailboxSyncManager as RtType>::Abi) -> HRESULT,
    fn get_UserDataAccountId(&self, out: *mut HSTRING) -> HRESULT,
    fn GetConversationReader(&self, out: *mut <EmailConversationReader as RtType>::Abi) -> HRESULT,
    fn GetConversationReaderWithOptions(&self, options: <EmailQueryOptions as RtType>::Abi, out: *mut <EmailConversationReader as RtType>::Abi) -> HRESULT,
    fn GetMessageReader(&self, out: *mut <EmailMessageReader as RtType>::Abi) -> HRESULT,
    fn GetMessageReaderWithOptions(&self, options: <EmailQueryOptions as RtType>::Abi, out: *mut <EmailMessageReader as RtType>::Abi) -> HRESULT,
    fn DeleteAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn GetConversationAsync(&self, id: HSTRING, out: *mut <foundation::IAsyncOperation<EmailConversation> as RtType>::Abi) -> HRESULT,
    fn GetFolderAsync(&self, id: HSTRING, out: *mut <foundation::IAsyncOperation<EmailFolder> as RtType>::Abi) -> HRESULT,
    fn GetMessageAsync(&self, id: HSTRING, out: *mut <foundation::IAsyncOperation<EmailMessage> as RtType>::Abi) -> HRESULT,
    fn GetSpecialFolderAsync(&self, folderType: EmailSpecialFolderKind, out: *mut <foundation::IAsyncOperation<EmailFolder> as RtType>::Abi) -> HRESULT,
    fn SaveAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn MarkMessageAsSeenAsync(&self, messageId: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn MarkFolderAsSeenAsync(&self, folderId: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn MarkMessageReadAsync(&self, messageId: HSTRING, isRead: bool, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ChangeMessageFlagStateAsync(&self, messageId: HSTRING, flagState: EmailFlagState, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn TryMoveMessageAsync(&self, messageId: HSTRING, newParentFolderId: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryMoveFolderAsync(&self, folderId: HSTRING, newParentFolderId: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryMoveFolderWithNewNameAsync(&self, folderId: HSTRING, newParentFolderId: HSTRING, newFolderName: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn DeleteMessageAsync(&self, messageId: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn MarkFolderSyncEnabledAsync(&self, folderId: HSTRING, isSyncEnabled: bool, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn SendMessageAsync(&self, message: <EmailMessage as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn SaveDraftAsync(&self, message: <EmailMessage as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn DownloadMessageAsync(&self, messageId: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn DownloadAttachmentAsync(&self, attachmentId: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn CreateResponseMessageAsync(&self, messageId: HSTRING, responseType: EmailMessageResponseKind, subject: HSTRING, responseHeaderType: EmailMessageBodyKind, responseHeader: HSTRING, out: *mut <foundation::IAsyncOperation<EmailMessage> as RtType>::Abi) -> HRESULT,
    fn TryUpdateMeetingResponseAsync(&self, meeting: <EmailMessage as RtType>::Abi, response: EmailMeetingResponseType, subject: HSTRING, comment: HSTRING, sendUpdate: bool, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryForwardMeetingAsync(&self, meeting: <EmailMessage as RtType>::Abi, recipients: <foundation::collections::IIterable<EmailRecipient> as RtType>::Abi, subject: HSTRING, forwardHeaderType: EmailMessageBodyKind, forwardHeader: HSTRING, comment: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryProposeNewTimeForMeetingAsync(&self, meeting: <EmailMessage as RtType>::Abi, newStartTime: foundation::DateTime, newDuration: foundation::TimeSpan, subject: HSTRING, comment: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn add_MailboxChanged(&self, pHandler: <foundation::TypedEventHandler<EmailMailbox, EmailMailboxChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MailboxChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn SmartSendMessageAsync(&self, message: <EmailMessage as RtType>::Abi, smartSend: bool, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn TrySetAutoReplySettingsAsync(&self, autoReplySettings: <EmailMailboxAutoReplySettings as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryGetAutoReplySettingsAsync(&self, requestedFormat: EmailMailboxAutoReplyMessageResponseKind, out: *mut <foundation::IAsyncOperation<EmailMailboxAutoReplySettings> as RtType>::Abi) -> HRESULT
}}
impl IEmailMailbox {
    #[inline] pub fn get_capabilities(&self) -> Result<Option<EmailMailboxCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Capabilities)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxCapabilities::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_change_tracker(&self) -> Result<Option<EmailMailboxChangeTracker>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ChangeTracker)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxChangeTracker::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_owned_by_current_app(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsOwnedByCurrentApp)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_data_encrypted_under_lock(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsDataEncryptedUnderLock)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_mail_address(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MailAddress)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_mail_address(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MailAddress)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_mail_address_aliases(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MailAddressAliases)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_other_app_read_access(&self) -> Result<EmailMailboxOtherAppReadAccess> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_OtherAppReadAccess)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_other_app_read_access(&self, value: EmailMailboxOtherAppReadAccess) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_OtherAppReadAccess)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_other_app_write_access(&self) -> Result<EmailMailboxOtherAppWriteAccess> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_OtherAppWriteAccess)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_other_app_write_access(&self, value: EmailMailboxOtherAppWriteAccess) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_OtherAppWriteAccess)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_policies(&self) -> Result<Option<EmailMailboxPolicies>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Policies)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxPolicies::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_source_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SourceDisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sync_manager(&self) -> Result<Option<EmailMailboxSyncManager>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SyncManager)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxSyncManager::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_user_data_account_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_UserDataAccountId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_conversation_reader(&self) -> Result<Option<EmailConversationReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetConversationReader)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailConversationReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_conversation_reader_with_options(&self, options: &EmailQueryOptions) -> Result<Option<EmailConversationReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetConversationReaderWithOptions)(self.get_abi() as *const _ as *mut _, options.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailConversationReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_reader(&self) -> Result<Option<EmailMessageReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetMessageReader)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMessageReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_reader_with_options(&self, options: &EmailQueryOptions) -> Result<Option<EmailMessageReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetMessageReaderWithOptions)(self.get_abi() as *const _ as *mut _, options.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMessageReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_conversation_async(&self, id: &HStringArg) -> Result<foundation::IAsyncOperation<EmailConversation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetConversationAsync)(self.get_abi() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_folder_async(&self, id: &HStringArg) -> Result<foundation::IAsyncOperation<EmailFolder>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetFolderAsync)(self.get_abi() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_async(&self, id: &HStringArg) -> Result<foundation::IAsyncOperation<EmailMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetMessageAsync)(self.get_abi() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_special_folder_async(&self, folderType: EmailSpecialFolderKind) -> Result<foundation::IAsyncOperation<EmailFolder>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetSpecialFolderAsync)(self.get_abi() as *const _ as *mut _, folderType, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn save_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SaveAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn mark_message_as_seen_async(&self, messageId: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().MarkMessageAsSeenAsync)(self.get_abi() as *const _ as *mut _, messageId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn mark_folder_as_seen_async(&self, folderId: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().MarkFolderAsSeenAsync)(self.get_abi() as *const _ as *mut _, folderId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn mark_message_read_async(&self, messageId: &HStringArg, isRead: bool) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().MarkMessageReadAsync)(self.get_abi() as *const _ as *mut _, messageId.get(), isRead, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn change_message_flag_state_async(&self, messageId: &HStringArg, flagState: EmailFlagState) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ChangeMessageFlagStateAsync)(self.get_abi() as *const _ as *mut _, messageId.get(), flagState, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_move_message_async(&self, messageId: &HStringArg, newParentFolderId: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryMoveMessageAsync)(self.get_abi() as *const _ as *mut _, messageId.get(), newParentFolderId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_move_folder_async(&self, folderId: &HStringArg, newParentFolderId: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryMoveFolderAsync)(self.get_abi() as *const _ as *mut _, folderId.get(), newParentFolderId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_move_folder_with_new_name_async(&self, folderId: &HStringArg, newParentFolderId: &HStringArg, newFolderName: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryMoveFolderWithNewNameAsync)(self.get_abi() as *const _ as *mut _, folderId.get(), newParentFolderId.get(), newFolderName.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_message_async(&self, messageId: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteMessageAsync)(self.get_abi() as *const _ as *mut _, messageId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn mark_folder_sync_enabled_async(&self, folderId: &HStringArg, isSyncEnabled: bool) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().MarkFolderSyncEnabledAsync)(self.get_abi() as *const _ as *mut _, folderId.get(), isSyncEnabled, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn send_message_async(&self, message: &EmailMessage) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SendMessageAsync)(self.get_abi() as *const _ as *mut _, message.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn save_draft_async(&self, message: &EmailMessage) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SaveDraftAsync)(self.get_abi() as *const _ as *mut _, message.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn download_message_async(&self, messageId: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DownloadMessageAsync)(self.get_abi() as *const _ as *mut _, messageId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn download_attachment_async(&self, attachmentId: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DownloadAttachmentAsync)(self.get_abi() as *const _ as *mut _, attachmentId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_response_message_async(&self, messageId: &HStringArg, responseType: EmailMessageResponseKind, subject: &HStringArg, responseHeaderType: EmailMessageBodyKind, responseHeader: &HStringArg) -> Result<foundation::IAsyncOperation<EmailMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateResponseMessageAsync)(self.get_abi() as *const _ as *mut _, messageId.get(), responseType, subject.get(), responseHeaderType, responseHeader.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_update_meeting_response_async(&self, meeting: &EmailMessage, response: EmailMeetingResponseType, subject: &HStringArg, comment: &HStringArg, sendUpdate: bool) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryUpdateMeetingResponseAsync)(self.get_abi() as *const _ as *mut _, meeting.get_abi() as *const _ as *mut _, response, subject.get(), comment.get(), sendUpdate, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_forward_meeting_async(&self, meeting: &EmailMessage, recipients: &foundation::collections::IIterable<EmailRecipient>, subject: &HStringArg, forwardHeaderType: EmailMessageBodyKind, forwardHeader: &HStringArg, comment: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryForwardMeetingAsync)(self.get_abi() as *const _ as *mut _, meeting.get_abi() as *const _ as *mut _, recipients.get_abi() as *const _ as *mut _, subject.get(), forwardHeaderType, forwardHeader.get(), comment.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_propose_new_time_for_meeting_async(&self, meeting: &EmailMessage, newStartTime: foundation::DateTime, newDuration: foundation::TimeSpan, subject: &HStringArg, comment: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryProposeNewTimeForMeetingAsync)(self.get_abi() as *const _ as *mut _, meeting.get_abi() as *const _ as *mut _, newStartTime, newDuration, subject.get(), comment.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_mailbox_changed(&self, pHandler: &foundation::TypedEventHandler<EmailMailbox, EmailMailboxChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_MailboxChanged)(self.get_abi() as *const _ as *mut _, pHandler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_mailbox_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_MailboxChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn smart_send_message_async(&self, message: &EmailMessage, smartSend: bool) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SmartSendMessageAsync)(self.get_abi() as *const _ as *mut _, message.get_abi() as *const _ as *mut _, smartSend, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_set_auto_reply_settings_async(&self, autoReplySettings: &EmailMailboxAutoReplySettings) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TrySetAutoReplySettingsAsync)(self.get_abi() as *const _ as *mut _, autoReplySettings.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_auto_reply_settings_async(&self, requestedFormat: EmailMailboxAutoReplyMessageResponseKind) -> Result<foundation::IAsyncOperation<EmailMailboxAutoReplySettings>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryGetAutoReplySettingsAsync)(self.get_abi() as *const _ as *mut _, requestedFormat, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailbox: IEmailMailbox}
DEFINE_IID!(IID_IEmailMailbox2, 351855620, 27810, 19122, 146, 65, 121, 205, 123, 244, 99, 70);
RT_INTERFACE!{interface IEmailMailbox2(IEmailMailbox2Vtbl): IInspectable [IID_IEmailMailbox2] {
    fn get_LinkedMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_NetworkAccountId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_NetworkId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IEmailMailbox2 {
    #[inline] pub fn get_linked_mailbox_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LinkedMailboxId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_network_account_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_NetworkAccountId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_network_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_NetworkId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IEmailMailbox3, 1034258811, 17803, 16522, 142, 55, 172, 139, 5, 216, 175, 86);
RT_INTERFACE!{interface IEmailMailbox3(IEmailMailbox3Vtbl): IInspectable [IID_IEmailMailbox3] {
    fn ResolveRecipientsAsync(&self, recipients: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<EmailRecipientResolutionResult>> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-security")] fn ValidateCertificatesAsync(&self, certificates: <foundation::collections::IIterable<super::super::security::cryptography::certificates::Certificate> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<EmailCertificateValidationStatus>> as RtType>::Abi) -> HRESULT,
    fn TryEmptyFolderAsync(&self, folderId: HSTRING, out: *mut <foundation::IAsyncOperation<EmailMailboxEmptyFolderStatus> as RtType>::Abi) -> HRESULT,
    fn TryCreateFolderAsync(&self, parentFolderId: HSTRING, name: HSTRING, out: *mut <foundation::IAsyncOperation<EmailMailboxCreateFolderResult> as RtType>::Abi) -> HRESULT,
    fn TryDeleteFolderAsync(&self, folderId: HSTRING, out: *mut <foundation::IAsyncOperation<EmailMailboxDeleteFolderStatus> as RtType>::Abi) -> HRESULT
}}
impl IEmailMailbox3 {
    #[inline] pub fn resolve_recipients_async(&self, recipients: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<EmailRecipientResolutionResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ResolveRecipientsAsync)(self.get_abi() as *const _ as *mut _, recipients.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn validate_certificates_async(&self, certificates: &foundation::collections::IIterable<super::super::security::cryptography::certificates::Certificate>) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<EmailCertificateValidationStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ValidateCertificatesAsync)(self.get_abi() as *const _ as *mut _, certificates.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_empty_folder_async(&self, folderId: &HStringArg) -> Result<foundation::IAsyncOperation<EmailMailboxEmptyFolderStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryEmptyFolderAsync)(self.get_abi() as *const _ as *mut _, folderId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_create_folder_async(&self, parentFolderId: &HStringArg, name: &HStringArg) -> Result<foundation::IAsyncOperation<EmailMailboxCreateFolderResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryCreateFolderAsync)(self.get_abi() as *const _ as *mut _, parentFolderId.get(), name.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_delete_folder_async(&self, folderId: &HStringArg) -> Result<foundation::IAsyncOperation<EmailMailboxDeleteFolderStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryDeleteFolderAsync)(self.get_abi() as *const _ as *mut _, folderId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IEmailMailbox4, 1562325019, 61986, 18599, 183, 182, 113, 99, 86, 205, 38, 161);
RT_INTERFACE!{interface IEmailMailbox4(IEmailMailbox4Vtbl): IInspectable [IID_IEmailMailbox4] {
    fn RegisterSyncManagerAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IEmailMailbox4 {
    #[inline] pub fn register_sync_manager_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RegisterSyncManagerAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IEmailMailbox5, 966160519, 146, 18878, 189, 14, 93, 77, 201, 217, 109, 144);
RT_INTERFACE!{interface IEmailMailbox5(IEmailMailbox5Vtbl): IInspectable [IID_IEmailMailbox5] {
    fn GetChangeTracker(&self, identity: HSTRING, out: *mut <EmailMailboxChangeTracker as RtType>::Abi) -> HRESULT
}}
impl IEmailMailbox5 {
    #[inline] pub fn get_change_tracker(&self, identity: &HStringArg) -> Result<Option<EmailMailboxChangeTracker>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetChangeTracker)(self.get_abi() as *const _ as *mut _, identity.get(), &mut out);
        if hr == S_OK { Ok(EmailMailboxChangeTracker::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IEmailMailboxAction, 2895677946, 8698, 18727, 146, 16, 212, 16, 88, 47, 223, 62);
RT_INTERFACE!{interface IEmailMailboxAction(IEmailMailboxActionVtbl): IInspectable [IID_IEmailMailboxAction] {
    fn get_Kind(&self, out: *mut EmailMailboxActionKind) -> HRESULT,
    fn get_ChangeNumber(&self, out: *mut u64) -> HRESULT
}}
impl IEmailMailboxAction {
    #[inline] pub fn get_kind(&self) -> Result<EmailMailboxActionKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Kind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_change_number(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ChangeNumber)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxAction: IEmailMailboxAction}
RT_ENUM! { enum EmailMailboxActionKind: i32 {
    MarkMessageAsSeen = 0, MarkMessageRead = 1, ChangeMessageFlagState = 2, MoveMessage = 3, SaveDraft = 4, SendMessage = 5, CreateResponseReplyMessage = 6, CreateResponseReplyAllMessage = 7, CreateResponseForwardMessage = 8, MoveFolder = 9, MarkFolderForSyncEnabled = 10,
}}
RT_ENUM! { enum EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation: i32 {
    None = 0, StrongAlgorithm = 1, AnyAlgorithm = 2,
}}
DEFINE_IID!(IID_IEmailMailboxAutoReply, 3793954124, 35508, 18523, 179, 31, 4, 209, 84, 118, 189, 89);
RT_INTERFACE!{interface IEmailMailboxAutoReply(IEmailMailboxAutoReplyVtbl): IInspectable [IID_IEmailMailboxAutoReply] {
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsEnabled(&self, value: bool) -> HRESULT,
    fn get_Response(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Response(&self, value: HSTRING) -> HRESULT
}}
impl IEmailMailboxAutoReply {
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsEnabled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsEnabled)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_response(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Response)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_response(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Response)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxAutoReply: IEmailMailboxAutoReply}
RT_ENUM! { enum EmailMailboxAutoReplyMessageResponseKind: i32 {
    Html = 0, PlainText = 1,
}}
DEFINE_IID!(IID_IEmailMailboxAutoReplySettings, 2826608552, 2758, 19319, 186, 119, 166, 185, 158, 154, 39, 184);
RT_INTERFACE!{interface IEmailMailboxAutoReplySettings(IEmailMailboxAutoReplySettingsVtbl): IInspectable [IID_IEmailMailboxAutoReplySettings] {
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsEnabled(&self, value: bool) -> HRESULT,
    fn get_ResponseKind(&self, out: *mut EmailMailboxAutoReplyMessageResponseKind) -> HRESULT,
    fn put_ResponseKind(&self, value: EmailMailboxAutoReplyMessageResponseKind) -> HRESULT,
    fn get_StartTime(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn put_StartTime(&self, value: <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_EndTime(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn put_EndTime(&self, value: <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_InternalReply(&self, out: *mut <EmailMailboxAutoReply as RtType>::Abi) -> HRESULT,
    fn get_KnownExternalReply(&self, out: *mut <EmailMailboxAutoReply as RtType>::Abi) -> HRESULT,
    fn get_UnknownExternalReply(&self, out: *mut <EmailMailboxAutoReply as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxAutoReplySettings {
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsEnabled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsEnabled)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_response_kind(&self) -> Result<EmailMailboxAutoReplyMessageResponseKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ResponseKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_response_kind(&self, value: EmailMailboxAutoReplyMessageResponseKind) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ResponseKind)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_start_time(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_StartTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_start_time(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_StartTime)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_end_time(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EndTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_end_time(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_EndTime)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_internal_reply(&self) -> Result<Option<EmailMailboxAutoReply>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_InternalReply)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxAutoReply::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_known_external_reply(&self) -> Result<Option<EmailMailboxAutoReply>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_KnownExternalReply)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxAutoReply::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_unknown_external_reply(&self) -> Result<Option<EmailMailboxAutoReply>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_UnknownExternalReply)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxAutoReply::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxAutoReplySettings: IEmailMailboxAutoReplySettings}
impl RtActivatable<IActivationFactory> for EmailMailboxAutoReplySettings {}
DEFINE_CLSID!(EmailMailboxAutoReplySettings(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,69,109,97,105,108,46,69,109,97,105,108,77,97,105,108,98,111,120,65,117,116,111,82,101,112,108,121,83,101,116,116,105,110,103,115,0]) [CLSID_EmailMailboxAutoReplySettings]);
DEFINE_IID!(IID_IEmailMailboxCapabilities, 4007576486, 35291, 17157, 130, 196, 67, 158, 10, 51, 218, 17);
RT_INTERFACE!{interface IEmailMailboxCapabilities(IEmailMailboxCapabilitiesVtbl): IInspectable [IID_IEmailMailboxCapabilities] {
    fn get_CanForwardMeetings(&self, out: *mut bool) -> HRESULT,
    fn get_CanGetAndSetExternalAutoReplies(&self, out: *mut bool) -> HRESULT,
    fn get_CanGetAndSetInternalAutoReplies(&self, out: *mut bool) -> HRESULT,
    fn get_CanUpdateMeetingResponses(&self, out: *mut bool) -> HRESULT,
    fn get_CanServerSearchFolders(&self, out: *mut bool) -> HRESULT,
    fn get_CanServerSearchMailbox(&self, out: *mut bool) -> HRESULT,
    fn get_CanProposeNewTimeForMeetings(&self, out: *mut bool) -> HRESULT,
    fn get_CanSmartSend(&self, out: *mut bool) -> HRESULT
}}
impl IEmailMailboxCapabilities {
    #[inline] pub fn get_can_forward_meetings(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanForwardMeetings)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_get_and_set_external_auto_replies(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanGetAndSetExternalAutoReplies)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_get_and_set_internal_auto_replies(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanGetAndSetInternalAutoReplies)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_update_meeting_responses(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanUpdateMeetingResponses)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_server_search_folders(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanServerSearchFolders)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_server_search_mailbox(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanServerSearchMailbox)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_propose_new_time_for_meetings(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanProposeNewTimeForMeetings)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_smart_send(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanSmartSend)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxCapabilities: IEmailMailboxCapabilities}
DEFINE_IID!(IID_IEmailMailboxCapabilities2, 1769094884, 12065, 19644, 136, 171, 46, 118, 2, 164, 128, 107);
RT_INTERFACE!{interface IEmailMailboxCapabilities2(IEmailMailboxCapabilities2Vtbl): IInspectable [IID_IEmailMailboxCapabilities2] {
    fn get_CanResolveRecipients(&self, out: *mut bool) -> HRESULT,
    fn get_CanValidateCertificates(&self, out: *mut bool) -> HRESULT,
    fn get_CanEmptyFolder(&self, out: *mut bool) -> HRESULT,
    fn get_CanCreateFolder(&self, out: *mut bool) -> HRESULT,
    fn get_CanDeleteFolder(&self, out: *mut bool) -> HRESULT,
    fn get_CanMoveFolder(&self, out: *mut bool) -> HRESULT
}}
impl IEmailMailboxCapabilities2 {
    #[inline] pub fn get_can_resolve_recipients(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanResolveRecipients)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_validate_certificates(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanValidateCertificates)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_empty_folder(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanEmptyFolder)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_create_folder(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanCreateFolder)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_delete_folder(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanDeleteFolder)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_move_folder(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanMoveFolder)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IEmailMailboxCapabilities3, 4136692036, 22258, 17834, 135, 44, 12, 233, 243, 219, 11, 92);
RT_INTERFACE!{interface IEmailMailboxCapabilities3(IEmailMailboxCapabilities3Vtbl): IInspectable [IID_IEmailMailboxCapabilities3] {
    fn put_CanForwardMeetings(&self, value: bool) -> HRESULT,
    fn put_CanGetAndSetExternalAutoReplies(&self, value: bool) -> HRESULT,
    fn put_CanGetAndSetInternalAutoReplies(&self, value: bool) -> HRESULT,
    fn put_CanUpdateMeetingResponses(&self, value: bool) -> HRESULT,
    fn put_CanServerSearchFolders(&self, value: bool) -> HRESULT,
    fn put_CanServerSearchMailbox(&self, value: bool) -> HRESULT,
    fn put_CanProposeNewTimeForMeetings(&self, value: bool) -> HRESULT,
    fn put_CanSmartSend(&self, value: bool) -> HRESULT,
    fn put_CanResolveRecipients(&self, value: bool) -> HRESULT,
    fn put_CanValidateCertificates(&self, value: bool) -> HRESULT,
    fn put_CanEmptyFolder(&self, value: bool) -> HRESULT,
    fn put_CanCreateFolder(&self, value: bool) -> HRESULT,
    fn put_CanDeleteFolder(&self, value: bool) -> HRESULT,
    fn put_CanMoveFolder(&self, value: bool) -> HRESULT
}}
impl IEmailMailboxCapabilities3 {
    #[inline] pub fn set_can_forward_meetings(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanForwardMeetings)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_can_get_and_set_external_auto_replies(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanGetAndSetExternalAutoReplies)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_can_get_and_set_internal_auto_replies(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanGetAndSetInternalAutoReplies)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_can_update_meeting_responses(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanUpdateMeetingResponses)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_can_server_search_folders(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanServerSearchFolders)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_can_server_search_mailbox(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanServerSearchMailbox)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_can_propose_new_time_for_meetings(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanProposeNewTimeForMeetings)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_can_smart_send(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanSmartSend)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_can_resolve_recipients(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanResolveRecipients)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_can_validate_certificates(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanValidateCertificates)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_can_empty_folder(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanEmptyFolder)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_can_create_folder(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanCreateFolder)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_can_delete_folder(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanDeleteFolder)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_can_move_folder(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanMoveFolder)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IEmailMailboxChange, 1642984779, 4591, 16396, 173, 222, 140, 222, 101, 200, 94, 102);
RT_INTERFACE!{interface IEmailMailboxChange(IEmailMailboxChangeVtbl): IInspectable [IID_IEmailMailboxChange] {
    fn get_ChangeType(&self, out: *mut EmailMailboxChangeType) -> HRESULT,
    fn get_MailboxActions(&self, out: *mut <foundation::collections::IVector<EmailMailboxAction> as RtType>::Abi) -> HRESULT,
    fn get_Message(&self, out: *mut <EmailMessage as RtType>::Abi) -> HRESULT,
    fn get_Folder(&self, out: *mut <EmailFolder as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxChange {
    #[inline] pub fn get_change_type(&self) -> Result<EmailMailboxChangeType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ChangeType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_mailbox_actions(&self) -> Result<Option<foundation::collections::IVector<EmailMailboxAction>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MailboxActions)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message(&self) -> Result<Option<EmailMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Message)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMessage::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_folder(&self) -> Result<Option<EmailFolder>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Folder)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailFolder::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxChange: IEmailMailboxChange}
DEFINE_IID!(IID_IEmailMailboxChangedDeferral, 2006611137, 38853, 19284, 179, 13, 48, 98, 50, 98, 62, 109);
RT_INTERFACE!{interface IEmailMailboxChangedDeferral(IEmailMailboxChangedDeferralVtbl): IInspectable [IID_IEmailMailboxChangedDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IEmailMailboxChangedDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Complete)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxChangedDeferral: IEmailMailboxChangedDeferral}
DEFINE_IID!(IID_IEmailMailboxChangedEventArgs, 1023237998, 468, 20042, 164, 76, 178, 45, 212, 46, 194, 7);
RT_INTERFACE!{interface IEmailMailboxChangedEventArgs(IEmailMailboxChangedEventArgsVtbl): IInspectable [IID_IEmailMailboxChangedEventArgs] {
    fn GetDeferral(&self, out: *mut <EmailMailboxChangedDeferral as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxChangedEventArgs {
    #[inline] pub fn get_deferral(&self) -> Result<Option<EmailMailboxChangedDeferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxChangedDeferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxChangedEventArgs: IEmailMailboxChangedEventArgs}
DEFINE_IID!(IID_IEmailMailboxChangeReader, 3183283899, 50493, 17201, 151, 190, 190, 117, 162, 20, 106, 117);
RT_INTERFACE!{interface IEmailMailboxChangeReader(IEmailMailboxChangeReaderVtbl): IInspectable [IID_IEmailMailboxChangeReader] {
    fn AcceptChanges(&self) -> HRESULT,
    fn AcceptChangesThrough(&self, lastChangeToAcknowledge: <EmailMailboxChange as RtType>::Abi) -> HRESULT,
    fn ReadBatchAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<EmailMailboxChange>> as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxChangeReader {
    #[inline] pub fn accept_changes(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().AcceptChanges)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn accept_changes_through(&self, lastChangeToAcknowledge: &EmailMailboxChange) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().AcceptChangesThrough)(self.get_abi() as *const _ as *mut _, lastChangeToAcknowledge.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn read_batch_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<EmailMailboxChange>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReadBatchAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxChangeReader: IEmailMailboxChangeReader}
DEFINE_IID!(IID_IEmailMailboxChangeTracker, 2061796920, 20838, 17079, 136, 130, 253, 33, 201, 43, 221, 75);
RT_INTERFACE!{interface IEmailMailboxChangeTracker(IEmailMailboxChangeTrackerVtbl): IInspectable [IID_IEmailMailboxChangeTracker] {
    fn get_IsTracking(&self, out: *mut bool) -> HRESULT,
    fn Enable(&self) -> HRESULT,
    fn GetChangeReader(&self, out: *mut <EmailMailboxChangeReader as RtType>::Abi) -> HRESULT,
    fn Reset(&self) -> HRESULT
}}
impl IEmailMailboxChangeTracker {
    #[inline] pub fn get_is_tracking(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsTracking)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn enable(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Enable)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_change_reader(&self) -> Result<Option<EmailMailboxChangeReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetChangeReader)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxChangeReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn reset(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Reset)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxChangeTracker: IEmailMailboxChangeTracker}
RT_ENUM! { enum EmailMailboxChangeType: i32 {
    MessageCreated = 0, MessageModified = 1, MessageDeleted = 2, FolderCreated = 3, FolderModified = 4, FolderDeleted = 5, ChangeTrackingLost = 6,
}}
DEFINE_IID!(IID_IEmailMailboxCreateFolderResult, 2988987775, 10373, 18840, 181, 149, 138, 45, 55, 76, 233, 80);
RT_INTERFACE!{interface IEmailMailboxCreateFolderResult(IEmailMailboxCreateFolderResultVtbl): IInspectable [IID_IEmailMailboxCreateFolderResult] {
    fn get_Status(&self, out: *mut EmailMailboxCreateFolderStatus) -> HRESULT,
    fn get_Folder(&self, out: *mut <EmailFolder as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxCreateFolderResult {
    #[inline] pub fn get_status(&self) -> Result<EmailMailboxCreateFolderStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_folder(&self) -> Result<Option<EmailFolder>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Folder)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailFolder::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxCreateFolderResult: IEmailMailboxCreateFolderResult}
RT_ENUM! { enum EmailMailboxCreateFolderStatus: i32 {
    Success = 0, NetworkError = 1, PermissionsError = 2, ServerError = 3, UnknownFailure = 4, NameCollision = 5, ServerRejected = 6,
}}
RT_ENUM! { enum EmailMailboxDeleteFolderStatus: i32 {
    Success = 0, NetworkError = 1, PermissionsError = 2, ServerError = 3, UnknownFailure = 4, CouldNotDeleteEverything = 5,
}}
RT_ENUM! { enum EmailMailboxEmptyFolderStatus: i32 {
    Success = 0, NetworkError = 1, PermissionsError = 2, ServerError = 3, UnknownFailure = 4, CouldNotDeleteEverything = 5,
}}
RT_ENUM! { enum EmailMailboxOtherAppReadAccess: i32 {
    SystemOnly = 0, Full = 1, None = 2,
}}
RT_ENUM! { enum EmailMailboxOtherAppWriteAccess: i32 {
    None = 0, Limited = 1,
}}
DEFINE_IID!(IID_IEmailMailboxPolicies, 523453893, 7227, 19911, 180, 16, 99, 115, 120, 62, 84, 93);
RT_INTERFACE!{interface IEmailMailboxPolicies(IEmailMailboxPoliciesVtbl): IInspectable [IID_IEmailMailboxPolicies] {
    fn get_AllowedSmimeEncryptionAlgorithmNegotiation(&self, out: *mut EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation) -> HRESULT,
    fn get_AllowSmimeSoftCertificates(&self, out: *mut bool) -> HRESULT,
    fn get_RequiredSmimeEncryptionAlgorithm(&self, out: *mut <foundation::IReference<EmailMailboxSmimeEncryptionAlgorithm> as RtType>::Abi) -> HRESULT,
    fn get_RequiredSmimeSigningAlgorithm(&self, out: *mut <foundation::IReference<EmailMailboxSmimeSigningAlgorithm> as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxPolicies {
    #[inline] pub fn get_allowed_smime_encryption_algorithm_negotiation(&self) -> Result<EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AllowedSmimeEncryptionAlgorithmNegotiation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_allow_smime_soft_certificates(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AllowSmimeSoftCertificates)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_required_smime_encryption_algorithm(&self) -> Result<Option<foundation::IReference<EmailMailboxSmimeEncryptionAlgorithm>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RequiredSmimeEncryptionAlgorithm)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_required_smime_signing_algorithm(&self) -> Result<Option<foundation::IReference<EmailMailboxSmimeSigningAlgorithm>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RequiredSmimeSigningAlgorithm)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxPolicies: IEmailMailboxPolicies}
DEFINE_IID!(IID_IEmailMailboxPolicies2, 3132459771, 41291, 18812, 168, 226, 85, 234, 194, 156, 196, 181);
RT_INTERFACE!{interface IEmailMailboxPolicies2(IEmailMailboxPolicies2Vtbl): IInspectable [IID_IEmailMailboxPolicies2] {
    fn get_MustEncryptSmimeMessages(&self, out: *mut bool) -> HRESULT,
    fn get_MustSignSmimeMessages(&self, out: *mut bool) -> HRESULT
}}
impl IEmailMailboxPolicies2 {
    #[inline] pub fn get_must_encrypt_smime_messages(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MustEncryptSmimeMessages)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_must_sign_smime_messages(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MustSignSmimeMessages)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IEmailMailboxPolicies3, 3184828447, 18535, 16714, 129, 162, 128, 57, 25, 196, 65, 145);
RT_INTERFACE!{interface IEmailMailboxPolicies3(IEmailMailboxPolicies3Vtbl): IInspectable [IID_IEmailMailboxPolicies3] {
    fn put_AllowedSmimeEncryptionAlgorithmNegotiation(&self, value: EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation) -> HRESULT,
    fn put_AllowSmimeSoftCertificates(&self, value: bool) -> HRESULT,
    fn put_RequiredSmimeEncryptionAlgorithm(&self, value: <foundation::IReference<EmailMailboxSmimeEncryptionAlgorithm> as RtType>::Abi) -> HRESULT,
    fn put_RequiredSmimeSigningAlgorithm(&self, value: <foundation::IReference<EmailMailboxSmimeSigningAlgorithm> as RtType>::Abi) -> HRESULT,
    fn put_MustEncryptSmimeMessages(&self, value: bool) -> HRESULT,
    fn put_MustSignSmimeMessages(&self, value: bool) -> HRESULT
}}
impl IEmailMailboxPolicies3 {
    #[inline] pub fn set_allowed_smime_encryption_algorithm_negotiation(&self, value: EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AllowedSmimeEncryptionAlgorithmNegotiation)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_allow_smime_soft_certificates(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AllowSmimeSoftCertificates)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_required_smime_encryption_algorithm(&self, value: &foundation::IReference<EmailMailboxSmimeEncryptionAlgorithm>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RequiredSmimeEncryptionAlgorithm)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_required_smime_signing_algorithm(&self, value: &foundation::IReference<EmailMailboxSmimeSigningAlgorithm>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RequiredSmimeSigningAlgorithm)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_must_encrypt_smime_messages(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MustEncryptSmimeMessages)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_must_sign_smime_messages(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MustSignSmimeMessages)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum EmailMailboxSmimeEncryptionAlgorithm: i32 {
    Any = 0, TripleDes = 1, Des = 2, RC2128Bit = 3, RC264Bit = 4, RC240Bit = 5,
}}
RT_ENUM! { enum EmailMailboxSmimeSigningAlgorithm: i32 {
    Any = 0, Sha1 = 1, MD5 = 2,
}}
DEFINE_IID!(IID_IEmailMailboxSyncManager, 1367000410, 13713, 19293, 133, 188, 199, 29, 222, 134, 34, 99);
RT_INTERFACE!{interface IEmailMailboxSyncManager(IEmailMailboxSyncManagerVtbl): IInspectable [IID_IEmailMailboxSyncManager] {
    fn get_Status(&self, out: *mut EmailMailboxSyncStatus) -> HRESULT,
    fn get_LastSuccessfulSyncTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_LastAttemptedSyncTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn SyncAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn add_SyncStatusChanged(&self, handler: <foundation::TypedEventHandler<EmailMailboxSyncManager, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SyncStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IEmailMailboxSyncManager {
    #[inline] pub fn get_status(&self) -> Result<EmailMailboxSyncStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_last_successful_sync_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_LastSuccessfulSyncTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_last_attempted_sync_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_LastAttemptedSyncTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn sync_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SyncAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_sync_status_changed(&self, handler: &foundation::TypedEventHandler<EmailMailboxSyncManager, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_SyncStatusChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_sync_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_SyncStatusChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxSyncManager: IEmailMailboxSyncManager}
DEFINE_IID!(IID_IEmailMailboxSyncManager2, 3448621438, 38337, 20361, 129, 183, 230, 174, 203, 102, 149, 252);
RT_INTERFACE!{interface IEmailMailboxSyncManager2(IEmailMailboxSyncManager2Vtbl): IInspectable [IID_IEmailMailboxSyncManager2] {
    fn put_Status(&self, value: EmailMailboxSyncStatus) -> HRESULT,
    fn put_LastSuccessfulSyncTime(&self, value: foundation::DateTime) -> HRESULT,
    fn put_LastAttemptedSyncTime(&self, value: foundation::DateTime) -> HRESULT
}}
impl IEmailMailboxSyncManager2 {
    #[inline] pub fn set_status(&self, value: EmailMailboxSyncStatus) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Status)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_last_successful_sync_time(&self, value: foundation::DateTime) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_LastSuccessfulSyncTime)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_last_attempted_sync_time(&self, value: foundation::DateTime) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_LastAttemptedSyncTime)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum EmailMailboxSyncStatus: i32 {
    Idle = 0, Syncing = 1, UpToDate = 2, AuthenticationError = 3, PolicyError = 4, UnknownError = 5, ManualAccountRemovalRequired = 6,
}}
RT_CLASS!{static class EmailManager}
impl RtActivatable<IEmailManagerStatics> for EmailManager {}
impl RtActivatable<IEmailManagerStatics2> for EmailManager {}
impl RtActivatable<IEmailManagerStatics3> for EmailManager {}
impl EmailManager {
    #[inline] pub fn show_compose_new_email_async(message: &EmailMessage) -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<IEmailManagerStatics>>::get_activation_factory().show_compose_new_email_async(message)
    }
    #[inline] pub fn request_store_async(accessType: EmailStoreAccessType) -> Result<foundation::IAsyncOperation<EmailStore>> {
        <Self as RtActivatable<IEmailManagerStatics2>>::get_activation_factory().request_store_async(accessType)
    }
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(user: &super::super::system::User) -> Result<Option<EmailManagerForUser>> {
        <Self as RtActivatable<IEmailManagerStatics3>>::get_activation_factory().get_for_user(user)
    }
}
DEFINE_CLSID!(EmailManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,69,109,97,105,108,46,69,109,97,105,108,77,97,110,97,103,101,114,0]) [CLSID_EmailManager]);
DEFINE_IID!(IID_IEmailManagerForUser, 4151565983, 15525, 19215, 144, 193, 21, 110, 64, 23, 76, 229);
RT_INTERFACE!{interface IEmailManagerForUser(IEmailManagerForUserVtbl): IInspectable [IID_IEmailManagerForUser] {
    fn ShowComposeNewEmailAsync(&self, message: <EmailMessage as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn RequestStoreAsync(&self, accessType: EmailStoreAccessType, out: *mut <foundation::IAsyncOperation<EmailStore> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut <super::super::system::User as RtType>::Abi) -> HRESULT
}}
impl IEmailManagerForUser {
    #[inline] pub fn show_compose_new_email_async(&self, message: &EmailMessage) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowComposeNewEmailAsync)(self.get_abi() as *const _ as *mut _, message.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_store_async(&self, accessType: EmailStoreAccessType) -> Result<foundation::IAsyncOperation<EmailStore>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestStoreAsync)(self.get_abi() as *const _ as *mut _, accessType, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_user(&self) -> Result<Option<super::super::system::User>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_User)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::system::User::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailManagerForUser: IEmailManagerForUser}
DEFINE_IID!(IID_IEmailManagerStatics, 4111631956, 21957, 18576, 168, 36, 33, 108, 38, 24, 206, 127);
RT_INTERFACE!{static interface IEmailManagerStatics(IEmailManagerStaticsVtbl): IInspectable [IID_IEmailManagerStatics] {
    fn ShowComposeNewEmailAsync(&self, message: <EmailMessage as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IEmailManagerStatics {
    #[inline] pub fn show_compose_new_email_async(&self, message: &EmailMessage) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowComposeNewEmailAsync)(self.get_abi() as *const _ as *mut _, message.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IEmailManagerStatics2, 2886020515, 45460, 16989, 182, 217, 208, 240, 65, 53, 237, 162);
RT_INTERFACE!{static interface IEmailManagerStatics2(IEmailManagerStatics2Vtbl): IInspectable [IID_IEmailManagerStatics2] {
    fn RequestStoreAsync(&self, accessType: EmailStoreAccessType, out: *mut <foundation::IAsyncOperation<EmailStore> as RtType>::Abi) -> HRESULT
}}
impl IEmailManagerStatics2 {
    #[inline] pub fn request_store_async(&self, accessType: EmailStoreAccessType) -> Result<foundation::IAsyncOperation<EmailStore>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestStoreAsync)(self.get_abi() as *const _ as *mut _, accessType, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IEmailManagerStatics3, 1248994197, 33854, 18757, 179, 170, 52, 158, 7, 163, 98, 197);
RT_INTERFACE!{static interface IEmailManagerStatics3(IEmailManagerStatics3Vtbl): IInspectable [IID_IEmailManagerStatics3] {
    #[cfg(feature="windows-system")] fn GetForUser(&self, user: <super::super::system::User as RtType>::Abi, out: *mut <EmailManagerForUser as RtType>::Abi) -> HRESULT
}}
impl IEmailManagerStatics3 {
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(&self, user: &super::super::system::User) -> Result<Option<EmailManagerForUser>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetForUser)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailManagerForUser::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IEmailMeetingInfo, 834682793, 31027, 16735, 162, 117, 209, 101, 186, 7, 2, 107);
RT_INTERFACE!{interface IEmailMeetingInfo(IEmailMeetingInfoVtbl): IInspectable [IID_IEmailMeetingInfo] {
    fn get_AllowNewTimeProposal(&self, out: *mut bool) -> HRESULT,
    fn put_AllowNewTimeProposal(&self, value: bool) -> HRESULT,
    fn get_AppointmentRoamingId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AppointmentRoamingId(&self, value: HSTRING) -> HRESULT,
    fn get_AppointmentOriginalStartTime(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn put_AppointmentOriginalStartTime(&self, value: <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_Duration(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_IsAllDay(&self, out: *mut bool) -> HRESULT,
    fn put_IsAllDay(&self, value: bool) -> HRESULT,
    fn get_IsResponseRequested(&self, out: *mut bool) -> HRESULT,
    fn put_IsResponseRequested(&self, value: bool) -> HRESULT,
    fn get_Location(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Location(&self, value: HSTRING) -> HRESULT,
    fn get_ProposedStartTime(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn put_ProposedStartTime(&self, proposedStartTime: <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_ProposedDuration(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn put_ProposedDuration(&self, duration: <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_RecurrenceStartTime(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn put_RecurrenceStartTime(&self, value: <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_Recurrence(&self, out: *mut <super::appointments::AppointmentRecurrence as RtType>::Abi) -> HRESULT,
    fn put_Recurrence(&self, value: <super::appointments::AppointmentRecurrence as RtType>::Abi) -> HRESULT,
    fn get_RemoteChangeNumber(&self, out: *mut u64) -> HRESULT,
    fn put_RemoteChangeNumber(&self, value: u64) -> HRESULT,
    fn get_StartTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn put_StartTime(&self, value: foundation::DateTime) -> HRESULT
}}
impl IEmailMeetingInfo {
    #[inline] pub fn get_allow_new_time_proposal(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AllowNewTimeProposal)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_allow_new_time_proposal(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AllowNewTimeProposal)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_appointment_roaming_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppointmentRoamingId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_appointment_roaming_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AppointmentRoamingId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_appointment_original_start_time(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppointmentOriginalStartTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_appointment_original_start_time(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AppointmentOriginalStartTime)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Duration)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_duration(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Duration)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_all_day(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsAllDay)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_all_day(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsAllDay)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_response_requested(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsResponseRequested)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_response_requested(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsResponseRequested)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_location(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Location)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_location(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Location)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_proposed_start_time(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ProposedStartTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_proposed_start_time(&self, proposedStartTime: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ProposedStartTime)(self.get_abi() as *const _ as *mut _, proposedStartTime.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_proposed_duration(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ProposedDuration)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_proposed_duration(&self, duration: &foundation::IReference<foundation::TimeSpan>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ProposedDuration)(self.get_abi() as *const _ as *mut _, duration.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_recurrence_start_time(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RecurrenceStartTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_recurrence_start_time(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RecurrenceStartTime)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_recurrence(&self) -> Result<Option<super::appointments::AppointmentRecurrence>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Recurrence)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::appointments::AppointmentRecurrence::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_recurrence(&self, value: &super::appointments::AppointmentRecurrence) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Recurrence)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_remote_change_number(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_RemoteChangeNumber)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_remote_change_number(&self, value: u64) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RemoteChangeNumber)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_start_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_StartTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_start_time(&self, value: foundation::DateTime) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_StartTime)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMeetingInfo: IEmailMeetingInfo}
impl RtActivatable<IActivationFactory> for EmailMeetingInfo {}
DEFINE_CLSID!(EmailMeetingInfo(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,69,109,97,105,108,46,69,109,97,105,108,77,101,101,116,105,110,103,73,110,102,111,0]) [CLSID_EmailMeetingInfo]);
DEFINE_IID!(IID_IEmailMeetingInfo2, 2119776365, 45273, 20453, 134, 124, 227, 30, 210, 181, 136, 184);
RT_INTERFACE!{interface IEmailMeetingInfo2(IEmailMeetingInfo2Vtbl): IInspectable [IID_IEmailMeetingInfo2] {
    fn get_IsReportedOutOfDateByServer(&self, out: *mut bool) -> HRESULT
}}
impl IEmailMeetingInfo2 {
    #[inline] pub fn get_is_reported_out_of_date_by_server(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsReportedOutOfDateByServer)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum EmailMeetingResponseType: i32 {
    Accept = 0, Decline = 1, Tentative = 2,
}}
DEFINE_IID!(IID_IEmailMessage, 1819120781, 32949, 18680, 176, 177, 224, 78, 67, 15, 68, 229);
RT_INTERFACE!{interface IEmailMessage(IEmailMessageVtbl): IInspectable [IID_IEmailMessage] {
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Subject(&self, value: HSTRING) -> HRESULT,
    fn get_Body(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Body(&self, value: HSTRING) -> HRESULT,
    fn get_To(&self, out: *mut <foundation::collections::IVector<EmailRecipient> as RtType>::Abi) -> HRESULT,
    fn get_CC(&self, out: *mut <foundation::collections::IVector<EmailRecipient> as RtType>::Abi) -> HRESULT,
    fn get_Bcc(&self, out: *mut <foundation::collections::IVector<EmailRecipient> as RtType>::Abi) -> HRESULT,
    fn get_Attachments(&self, out: *mut <foundation::collections::IVector<EmailAttachment> as RtType>::Abi) -> HRESULT
}}
impl IEmailMessage {
    #[inline] pub fn get_subject(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Subject)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_subject(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Subject)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_body(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Body)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_body(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Body)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_to(&self) -> Result<Option<foundation::collections::IVector<EmailRecipient>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_To)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_cc(&self) -> Result<Option<foundation::collections::IVector<EmailRecipient>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CC)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_bcc(&self) -> Result<Option<foundation::collections::IVector<EmailRecipient>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Bcc)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_attachments(&self) -> Result<Option<foundation::collections::IVector<EmailAttachment>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Attachments)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMessage: IEmailMessage}
impl RtActivatable<IActivationFactory> for EmailMessage {}
DEFINE_CLSID!(EmailMessage(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,69,109,97,105,108,46,69,109,97,105,108,77,101,115,115,97,103,101,0]) [CLSID_EmailMessage]);
DEFINE_IID!(IID_IEmailMessage2, 4257752203, 40730, 17627, 189, 60, 101, 195, 132, 119, 15, 134);
RT_INTERFACE!{interface IEmailMessage2(IEmailMessage2Vtbl): IInspectable [IID_IEmailMessage2] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RemoteId(&self, value: HSTRING) -> HRESULT,
    fn get_MailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ConversationId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FolderId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AllowInternetImages(&self, out: *mut bool) -> HRESULT,
    fn put_AllowInternetImages(&self, value: bool) -> HRESULT,
    fn get_ChangeNumber(&self, out: *mut u64) -> HRESULT,
    fn get_DownloadState(&self, out: *mut EmailMessageDownloadState) -> HRESULT,
    fn put_DownloadState(&self, value: EmailMessageDownloadState) -> HRESULT,
    fn get_EstimatedDownloadSizeInBytes(&self, out: *mut u32) -> HRESULT,
    fn put_EstimatedDownloadSizeInBytes(&self, value: u32) -> HRESULT,
    fn get_FlagState(&self, out: *mut EmailFlagState) -> HRESULT,
    fn put_FlagState(&self, value: EmailFlagState) -> HRESULT,
    fn get_HasPartialBodies(&self, out: *mut bool) -> HRESULT,
    fn get_Importance(&self, out: *mut EmailImportance) -> HRESULT,
    fn put_Importance(&self, value: EmailImportance) -> HRESULT,
    fn get_InResponseToMessageId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IrmInfo(&self, out: *mut <EmailIrmInfo as RtType>::Abi) -> HRESULT,
    fn put_IrmInfo(&self, value: <EmailIrmInfo as RtType>::Abi) -> HRESULT,
    fn get_IsDraftMessage(&self, out: *mut bool) -> HRESULT,
    fn get_IsRead(&self, out: *mut bool) -> HRESULT,
    fn put_IsRead(&self, value: bool) -> HRESULT,
    fn get_IsSeen(&self, out: *mut bool) -> HRESULT,
    fn put_IsSeen(&self, value: bool) -> HRESULT,
    fn get_IsServerSearchMessage(&self, out: *mut bool) -> HRESULT,
    fn get_IsSmartSendable(&self, out: *mut bool) -> HRESULT,
    fn get_MessageClass(&self, out: *mut HSTRING) -> HRESULT,
    fn put_MessageClass(&self, value: HSTRING) -> HRESULT,
    fn get_NormalizedSubject(&self, out: *mut HSTRING) -> HRESULT,
    fn get_OriginalCodePage(&self, out: *mut i32) -> HRESULT,
    fn put_OriginalCodePage(&self, value: i32) -> HRESULT,
    fn get_Preview(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Preview(&self, value: HSTRING) -> HRESULT,
    fn get_LastResponseKind(&self, out: *mut EmailMessageResponseKind) -> HRESULT,
    fn put_LastResponseKind(&self, value: EmailMessageResponseKind) -> HRESULT,
    fn get_Sender(&self, out: *mut <EmailRecipient as RtType>::Abi) -> HRESULT,
    fn put_Sender(&self, value: <EmailRecipient as RtType>::Abi) -> HRESULT,
    fn get_SentTime(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn put_SentTime(&self, value: <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_MeetingInfo(&self, out: *mut <EmailMeetingInfo as RtType>::Abi) -> HRESULT,
    fn put_MeetingInfo(&self, value: <EmailMeetingInfo as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetBodyStream(&self, type_: EmailMessageBodyKind, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SetBodyStream(&self, type_: EmailMessageBodyKind, stream: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT
}}
impl IEmailMessage2 {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_remote_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RemoteId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_remote_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RemoteId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_mailbox_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MailboxId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_conversation_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ConversationId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_folder_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_FolderId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_allow_internet_images(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AllowInternetImages)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_allow_internet_images(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AllowInternetImages)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_change_number(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ChangeNumber)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_download_state(&self) -> Result<EmailMessageDownloadState> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DownloadState)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_download_state(&self, value: EmailMessageDownloadState) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DownloadState)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_estimated_download_size_in_bytes(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_EstimatedDownloadSizeInBytes)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_estimated_download_size_in_bytes(&self, value: u32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_EstimatedDownloadSizeInBytes)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_flag_state(&self) -> Result<EmailFlagState> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_FlagState)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_flag_state(&self, value: EmailFlagState) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_FlagState)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_has_partial_bodies(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_HasPartialBodies)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_importance(&self) -> Result<EmailImportance> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Importance)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_importance(&self, value: EmailImportance) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Importance)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_in_response_to_message_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_InResponseToMessageId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_irm_info(&self) -> Result<Option<EmailIrmInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_IrmInfo)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailIrmInfo::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_irm_info(&self, value: &EmailIrmInfo) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IrmInfo)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_draft_message(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsDraftMessage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_read(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsRead)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_read(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsRead)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_seen(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsSeen)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_seen(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsSeen)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_server_search_message(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsServerSearchMessage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_smart_sendable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsSmartSendable)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_message_class(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MessageClass)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_message_class(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MessageClass)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_normalized_subject(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_NormalizedSubject)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_original_code_page(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_OriginalCodePage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_original_code_page(&self, value: i32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_OriginalCodePage)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_preview(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Preview)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_preview(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Preview)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_last_response_kind(&self) -> Result<EmailMessageResponseKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_LastResponseKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_last_response_kind(&self, value: EmailMessageResponseKind) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_LastResponseKind)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sender(&self) -> Result<Option<EmailRecipient>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Sender)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailRecipient::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_sender(&self, value: &EmailRecipient) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Sender)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sent_time(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SentTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_sent_time(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SentTime)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_meeting_info(&self) -> Result<Option<EmailMeetingInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MeetingInfo)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMeetingInfo::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_meeting_info(&self, value: &EmailMeetingInfo) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MeetingInfo)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_body_stream(&self, type_: EmailMessageBodyKind) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetBodyStream)(self.get_abi() as *const _ as *mut _, type_, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_body_stream(&self, type_: EmailMessageBodyKind, stream: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetBodyStream)(self.get_abi() as *const _ as *mut _, type_, stream.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IEmailMessage3, 2716493660, 58776, 19753, 160, 24, 252, 123, 126, 236, 224, 161);
RT_INTERFACE!{interface IEmailMessage3(IEmailMessage3Vtbl): IInspectable [IID_IEmailMessage3] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_SmimeData(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_SmimeData(&self, value: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    fn get_SmimeKind(&self, out: *mut EmailMessageSmimeKind) -> HRESULT,
    fn put_SmimeKind(&self, value: EmailMessageSmimeKind) -> HRESULT
}}
impl IEmailMessage3 {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_smime_data(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SmimeData)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_smime_data(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SmimeData)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_smime_kind(&self) -> Result<EmailMessageSmimeKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SmimeKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_smime_kind(&self, value: EmailMessageSmimeKind) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SmimeKind)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IEmailMessage4, 830271873, 15999, 18949, 131, 148, 62, 16, 51, 109, 212, 53);
RT_INTERFACE!{interface IEmailMessage4(IEmailMessage4Vtbl): IInspectable [IID_IEmailMessage4] {
    fn get_ReplyTo(&self, out: *mut <foundation::collections::IVector<EmailRecipient> as RtType>::Abi) -> HRESULT,
    fn get_SentRepresenting(&self, out: *mut <EmailRecipient as RtType>::Abi) -> HRESULT,
    fn put_SentRepresenting(&self, value: <EmailRecipient as RtType>::Abi) -> HRESULT
}}
impl IEmailMessage4 {
    #[inline] pub fn get_reply_to(&self) -> Result<Option<foundation::collections::IVector<EmailRecipient>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ReplyTo)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sent_representing(&self) -> Result<Option<EmailRecipient>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SentRepresenting)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailRecipient::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_sent_representing(&self, value: &EmailRecipient) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SentRepresenting)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IEmailMessageBatch, 1616695439, 9689, 20251, 158, 81, 5, 20, 192, 20, 150, 83);
RT_INTERFACE!{interface IEmailMessageBatch(IEmailMessageBatchVtbl): IInspectable [IID_IEmailMessageBatch] {
    fn get_Messages(&self, out: *mut <foundation::collections::IVectorView<EmailMessage> as RtType>::Abi) -> HRESULT,
    fn get_Status(&self, out: *mut EmailBatchStatus) -> HRESULT
}}
impl IEmailMessageBatch {
    #[inline] pub fn get_messages(&self) -> Result<Option<foundation::collections::IVectorView<EmailMessage>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Messages)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<EmailBatchStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMessageBatch: IEmailMessageBatch}
RT_ENUM! { enum EmailMessageBodyKind: i32 {
    Html = 0, PlainText = 1,
}}
RT_ENUM! { enum EmailMessageDownloadState: i32 {
    PartiallyDownloaded = 0, Downloading = 1, Downloaded = 2, Failed = 3,
}}
DEFINE_IID!(IID_IEmailMessageReader, 793427615, 25107, 19077, 163, 176, 249, 45, 26, 131, 157, 25);
RT_INTERFACE!{interface IEmailMessageReader(IEmailMessageReaderVtbl): IInspectable [IID_IEmailMessageReader] {
    fn ReadBatchAsync(&self, out: *mut <foundation::IAsyncOperation<EmailMessageBatch> as RtType>::Abi) -> HRESULT
}}
impl IEmailMessageReader {
    #[inline] pub fn read_batch_async(&self) -> Result<foundation::IAsyncOperation<EmailMessageBatch>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReadBatchAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMessageReader: IEmailMessageReader}
RT_ENUM! { enum EmailMessageResponseKind: i32 {
    None = 0, Reply = 1, ReplyAll = 2, Forward = 3,
}}
RT_ENUM! { enum EmailMessageSmimeKind: i32 {
    None = 0, ClearSigned = 1, OpaqueSigned = 2, Encrypted = 3,
}}
RT_ENUM! { enum EmailQueryKind: i32 {
    All = 0, Important = 1, Flagged = 2, Unread = 3, Read = 4, Unseen = 5,
}}
DEFINE_IID!(IID_IEmailQueryOptions, 1162890139, 15999, 19794, 182, 221, 214, 253, 78, 31, 189, 154);
RT_INTERFACE!{interface IEmailQueryOptions(IEmailQueryOptionsVtbl): IInspectable [IID_IEmailQueryOptions] {
    fn get_TextSearch(&self, out: *mut <EmailQueryTextSearch as RtType>::Abi) -> HRESULT,
    fn get_SortDirection(&self, out: *mut EmailQuerySortDirection) -> HRESULT,
    fn put_SortDirection(&self, value: EmailQuerySortDirection) -> HRESULT,
    fn get_SortProperty(&self, out: *mut EmailQuerySortProperty) -> HRESULT,
    fn put_SortProperty(&self, value: EmailQuerySortProperty) -> HRESULT,
    fn get_Kind(&self, out: *mut EmailQueryKind) -> HRESULT,
    fn put_Kind(&self, value: EmailQueryKind) -> HRESULT,
    fn get_FolderIds(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT
}}
impl IEmailQueryOptions {
    #[inline] pub fn get_text_search(&self) -> Result<Option<EmailQueryTextSearch>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TextSearch)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailQueryTextSearch::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sort_direction(&self) -> Result<EmailQuerySortDirection> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SortDirection)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_sort_direction(&self, value: EmailQuerySortDirection) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SortDirection)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sort_property(&self) -> Result<EmailQuerySortProperty> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SortProperty)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_sort_property(&self, value: EmailQuerySortProperty) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SortProperty)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_kind(&self) -> Result<EmailQueryKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Kind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_kind(&self, value: EmailQueryKind) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Kind)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_folder_ids(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_FolderIds)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailQueryOptions: IEmailQueryOptions}
impl RtActivatable<IEmailQueryOptionsFactory> for EmailQueryOptions {}
impl RtActivatable<IActivationFactory> for EmailQueryOptions {}
impl EmailQueryOptions {
    #[inline] pub fn create_with_text(text: &HStringArg) -> Result<EmailQueryOptions> {
        <Self as RtActivatable<IEmailQueryOptionsFactory>>::get_activation_factory().create_with_text(text)
    }
    #[inline] pub fn create_with_text_and_fields(text: &HStringArg, fields: EmailQuerySearchFields) -> Result<EmailQueryOptions> {
        <Self as RtActivatable<IEmailQueryOptionsFactory>>::get_activation_factory().create_with_text_and_fields(text, fields)
    }
}
DEFINE_CLSID!(EmailQueryOptions(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,69,109,97,105,108,46,69,109,97,105,108,81,117,101,114,121,79,112,116,105,111,110,115,0]) [CLSID_EmailQueryOptions]);
DEFINE_IID!(IID_IEmailQueryOptionsFactory, 2297536952, 30891, 20200, 180, 227, 4, 109, 110, 47, 229, 226);
RT_INTERFACE!{static interface IEmailQueryOptionsFactory(IEmailQueryOptionsFactoryVtbl): IInspectable [IID_IEmailQueryOptionsFactory] {
    fn CreateWithText(&self, text: HSTRING, out: *mut <EmailQueryOptions as RtType>::Abi) -> HRESULT,
    fn CreateWithTextAndFields(&self, text: HSTRING, fields: EmailQuerySearchFields, out: *mut <EmailQueryOptions as RtType>::Abi) -> HRESULT
}}
impl IEmailQueryOptionsFactory {
    #[inline] pub fn create_with_text(&self, text: &HStringArg) -> Result<EmailQueryOptions> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWithText)(self.get_abi() as *const _ as *mut _, text.get(), &mut out);
        if hr == S_OK { Ok(EmailQueryOptions::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_text_and_fields(&self, text: &HStringArg, fields: EmailQuerySearchFields) -> Result<EmailQueryOptions> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWithTextAndFields)(self.get_abi() as *const _ as *mut _, text.get(), fields, &mut out);
        if hr == S_OK { Ok(EmailQueryOptions::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum EmailQuerySearchFields: u32 {
    None = 0, Subject = 1, Sender = 2, Preview = 4, Recipients = 8, All = 4294967295,
}}
RT_ENUM! { enum EmailQuerySearchScope: i32 {
    Local = 0, Server = 1,
}}
RT_ENUM! { enum EmailQuerySortDirection: i32 {
    Descending = 0, Ascending = 1,
}}
RT_ENUM! { enum EmailQuerySortProperty: i32 {
    Date = 0,
}}
DEFINE_IID!(IID_IEmailQueryTextSearch, 2678104712, 15453, 18085, 166, 226, 49, 214, 253, 23, 229, 64);
RT_INTERFACE!{interface IEmailQueryTextSearch(IEmailQueryTextSearchVtbl): IInspectable [IID_IEmailQueryTextSearch] {
    fn get_Fields(&self, out: *mut EmailQuerySearchFields) -> HRESULT,
    fn put_Fields(&self, value: EmailQuerySearchFields) -> HRESULT,
    fn get_SearchScope(&self, out: *mut EmailQuerySearchScope) -> HRESULT,
    fn put_SearchScope(&self, value: EmailQuerySearchScope) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Text(&self, value: HSTRING) -> HRESULT
}}
impl IEmailQueryTextSearch {
    #[inline] pub fn get_fields(&self) -> Result<EmailQuerySearchFields> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Fields)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_fields(&self, value: EmailQuerySearchFields) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Fields)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_search_scope(&self) -> Result<EmailQuerySearchScope> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SearchScope)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_search_scope(&self, value: EmailQuerySearchScope) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SearchScope)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Text)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_text(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Text)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailQueryTextSearch: IEmailQueryTextSearch}
DEFINE_IID!(IID_IEmailRecipient, 3404211635, 17528, 18452, 185, 0, 201, 2, 181, 225, 155, 83);
RT_INTERFACE!{interface IEmailRecipient(IEmailRecipientVtbl): IInspectable [IID_IEmailRecipient] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT,
    fn get_Address(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Address(&self, value: HSTRING) -> HRESULT
}}
impl IEmailRecipient {
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Name)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Name)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_address(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Address)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_address(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Address)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailRecipient: IEmailRecipient}
impl RtActivatable<IEmailRecipientFactory> for EmailRecipient {}
impl RtActivatable<IActivationFactory> for EmailRecipient {}
impl EmailRecipient {
    #[inline] pub fn create(address: &HStringArg) -> Result<EmailRecipient> {
        <Self as RtActivatable<IEmailRecipientFactory>>::get_activation_factory().create(address)
    }
    #[inline] pub fn create_with_name(address: &HStringArg, name: &HStringArg) -> Result<EmailRecipient> {
        <Self as RtActivatable<IEmailRecipientFactory>>::get_activation_factory().create_with_name(address, name)
    }
}
DEFINE_CLSID!(EmailRecipient(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,69,109,97,105,108,46,69,109,97,105,108,82,101,99,105,112,105,101,110,116,0]) [CLSID_EmailRecipient]);
DEFINE_IID!(IID_IEmailRecipientFactory, 1426110541, 51098, 20216, 185, 9, 114, 46, 24, 227, 147, 93);
RT_INTERFACE!{static interface IEmailRecipientFactory(IEmailRecipientFactoryVtbl): IInspectable [IID_IEmailRecipientFactory] {
    fn Create(&self, address: HSTRING, out: *mut <EmailRecipient as RtType>::Abi) -> HRESULT,
    fn CreateWithName(&self, address: HSTRING, name: HSTRING, out: *mut <EmailRecipient as RtType>::Abi) -> HRESULT
}}
impl IEmailRecipientFactory {
    #[inline] pub fn create(&self, address: &HStringArg) -> Result<EmailRecipient> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, address.get(), &mut out);
        if hr == S_OK { Ok(EmailRecipient::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_name(&self, address: &HStringArg, name: &HStringArg) -> Result<EmailRecipient> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWithName)(self.get_abi() as *const _ as *mut _, address.get(), name.get(), &mut out);
        if hr == S_OK { Ok(EmailRecipient::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IEmailRecipientResolutionResult, 2441296122, 36237, 17779, 128, 209, 7, 23, 42, 52, 185, 141);
RT_INTERFACE!{interface IEmailRecipientResolutionResult(IEmailRecipientResolutionResultVtbl): IInspectable [IID_IEmailRecipientResolutionResult] {
    fn get_Status(&self, out: *mut EmailRecipientResolutionStatus) -> HRESULT,
    #[cfg(feature="windows-security")] fn get_PublicKeys(&self, out: *mut <foundation::collections::IVectorView<super::super::security::cryptography::certificates::Certificate> as RtType>::Abi) -> HRESULT
}}
impl IEmailRecipientResolutionResult {
    #[inline] pub fn get_status(&self) -> Result<EmailRecipientResolutionStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn get_public_keys(&self) -> Result<Option<foundation::collections::IVectorView<super::super::security::cryptography::certificates::Certificate>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PublicKeys)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailRecipientResolutionResult: IEmailRecipientResolutionResult}
impl RtActivatable<IActivationFactory> for EmailRecipientResolutionResult {}
DEFINE_CLSID!(EmailRecipientResolutionResult(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,69,109,97,105,108,46,69,109,97,105,108,82,101,99,105,112,105,101,110,116,82,101,115,111,108,117,116,105,111,110,82,101,115,117,108,116,0]) [CLSID_EmailRecipientResolutionResult]);
DEFINE_IID!(IID_IEmailRecipientResolutionResult2, 1581386678, 52827, 19422, 185, 212, 225, 109, 160, 176, 159, 202);
RT_INTERFACE!{interface IEmailRecipientResolutionResult2(IEmailRecipientResolutionResult2Vtbl): IInspectable [IID_IEmailRecipientResolutionResult2] {
    fn put_Status(&self, value: EmailRecipientResolutionStatus) -> HRESULT,
    #[cfg(feature="windows-security")] fn SetPublicKeys(&self, value: <foundation::collections::IIterable<super::super::security::cryptography::certificates::Certificate> as RtType>::Abi) -> HRESULT
}}
impl IEmailRecipientResolutionResult2 {
    #[inline] pub fn set_status(&self, value: EmailRecipientResolutionStatus) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Status)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn set_public_keys(&self, value: &foundation::collections::IIterable<super::super::security::cryptography::certificates::Certificate>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetPublicKeys)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum EmailRecipientResolutionStatus: i32 {
    Success = 0, RecipientNotFound = 1, AmbiguousRecipient = 2, NoCertificate = 3, CertificateRequestLimitReached = 4, CannotResolveDistributionList = 5, ServerError = 6, UnknownFailure = 7,
}}
RT_ENUM! { enum EmailSpecialFolderKind: i32 {
    None = 0, Root = 1, Inbox = 2, Outbox = 3, Drafts = 4, DeletedItems = 5, Sent = 6,
}}
DEFINE_IID!(IID_IEmailStore, 4160954990, 37175, 20363, 164, 112, 39, 154, 195, 5, 142, 182);
RT_INTERFACE!{interface IEmailStore(IEmailStoreVtbl): IInspectable [IID_IEmailStore] {
    fn FindMailboxesAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<EmailMailbox>> as RtType>::Abi) -> HRESULT,
    fn GetConversationReader(&self, out: *mut <EmailConversationReader as RtType>::Abi) -> HRESULT,
    fn GetConversationReaderWithOptions(&self, options: <EmailQueryOptions as RtType>::Abi, out: *mut <EmailConversationReader as RtType>::Abi) -> HRESULT,
    fn GetMessageReader(&self, out: *mut <EmailMessageReader as RtType>::Abi) -> HRESULT,
    fn GetMessageReaderWithOptions(&self, options: <EmailQueryOptions as RtType>::Abi, out: *mut <EmailMessageReader as RtType>::Abi) -> HRESULT,
    fn GetMailboxAsync(&self, id: HSTRING, out: *mut <foundation::IAsyncOperation<EmailMailbox> as RtType>::Abi) -> HRESULT,
    fn GetConversationAsync(&self, id: HSTRING, out: *mut <foundation::IAsyncOperation<EmailConversation> as RtType>::Abi) -> HRESULT,
    fn GetFolderAsync(&self, id: HSTRING, out: *mut <foundation::IAsyncOperation<EmailFolder> as RtType>::Abi) -> HRESULT,
    fn GetMessageAsync(&self, id: HSTRING, out: *mut <foundation::IAsyncOperation<EmailMessage> as RtType>::Abi) -> HRESULT,
    fn CreateMailboxAsync(&self, accountName: HSTRING, accountAddress: HSTRING, out: *mut <foundation::IAsyncOperation<EmailMailbox> as RtType>::Abi) -> HRESULT,
    fn CreateMailboxInAccountAsync(&self, accountName: HSTRING, accountAddress: HSTRING, userDataAccountId: HSTRING, out: *mut <foundation::IAsyncOperation<EmailMailbox> as RtType>::Abi) -> HRESULT
}}
impl IEmailStore {
    #[inline] pub fn find_mailboxes_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<EmailMailbox>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindMailboxesAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_conversation_reader(&self) -> Result<Option<EmailConversationReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetConversationReader)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailConversationReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_conversation_reader_with_options(&self, options: &EmailQueryOptions) -> Result<Option<EmailConversationReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetConversationReaderWithOptions)(self.get_abi() as *const _ as *mut _, options.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailConversationReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_reader(&self) -> Result<Option<EmailMessageReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetMessageReader)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMessageReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_reader_with_options(&self, options: &EmailQueryOptions) -> Result<Option<EmailMessageReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetMessageReaderWithOptions)(self.get_abi() as *const _ as *mut _, options.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMessageReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_mailbox_async(&self, id: &HStringArg) -> Result<foundation::IAsyncOperation<EmailMailbox>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetMailboxAsync)(self.get_abi() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_conversation_async(&self, id: &HStringArg) -> Result<foundation::IAsyncOperation<EmailConversation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetConversationAsync)(self.get_abi() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_folder_async(&self, id: &HStringArg) -> Result<foundation::IAsyncOperation<EmailFolder>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetFolderAsync)(self.get_abi() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_async(&self, id: &HStringArg) -> Result<foundation::IAsyncOperation<EmailMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetMessageAsync)(self.get_abi() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_mailbox_async(&self, accountName: &HStringArg, accountAddress: &HStringArg) -> Result<foundation::IAsyncOperation<EmailMailbox>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateMailboxAsync)(self.get_abi() as *const _ as *mut _, accountName.get(), accountAddress.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_mailbox_in_account_async(&self, accountName: &HStringArg, accountAddress: &HStringArg, userDataAccountId: &HStringArg) -> Result<foundation::IAsyncOperation<EmailMailbox>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateMailboxInAccountAsync)(self.get_abi() as *const _ as *mut _, accountName.get(), accountAddress.get(), userDataAccountId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailStore: IEmailStore}
RT_ENUM! { enum EmailStoreAccessType: i32 {
    AppMailboxesReadWrite = 0, AllMailboxesLimitedReadWrite = 1,
}}
DEFINE_IID!(IID_IEmailStoreNotificationTriggerDetails, 3457635900, 18150, 17353, 150, 247, 250, 207, 125, 215, 16, 203);
RT_INTERFACE!{interface IEmailStoreNotificationTriggerDetails(IEmailStoreNotificationTriggerDetailsVtbl): IInspectable [IID_IEmailStoreNotificationTriggerDetails] {
    
}}
RT_CLASS!{class EmailStoreNotificationTriggerDetails: IEmailStoreNotificationTriggerDetails}
pub mod dataprovider { // Windows.ApplicationModel.Email.DataProvider
use crate::prelude::*;
DEFINE_IID!(IID_IEmailDataProviderConnection, 1000119751, 14258, 19440, 174, 48, 123, 100, 74, 28, 150, 225);
RT_INTERFACE!{interface IEmailDataProviderConnection(IEmailDataProviderConnectionVtbl): IInspectable [IID_IEmailDataProviderConnection] {
    fn add_MailboxSyncRequested(&self, handler: <foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxSyncManagerSyncRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MailboxSyncRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_DownloadMessageRequested(&self, handler: <foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxDownloadMessageRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DownloadMessageRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_DownloadAttachmentRequested(&self, handler: <foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxDownloadAttachmentRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DownloadAttachmentRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CreateFolderRequested(&self, handler: <foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxCreateFolderRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CreateFolderRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_DeleteFolderRequested(&self, handler: <foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxDeleteFolderRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DeleteFolderRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_EmptyFolderRequested(&self, handler: <foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxEmptyFolderRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EmptyFolderRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_MoveFolderRequested(&self, handler: <foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxMoveFolderRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MoveFolderRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_UpdateMeetingResponseRequested(&self, handler: <foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxUpdateMeetingResponseRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_UpdateMeetingResponseRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ForwardMeetingRequested(&self, handler: <foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxForwardMeetingRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ForwardMeetingRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ProposeNewTimeForMeetingRequested(&self, handler: <foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxProposeNewTimeForMeetingRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ProposeNewTimeForMeetingRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SetAutoReplySettingsRequested(&self, handler: <foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxSetAutoReplySettingsRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SetAutoReplySettingsRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_GetAutoReplySettingsRequested(&self, handler: <foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxGetAutoReplySettingsRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_GetAutoReplySettingsRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ResolveRecipientsRequested(&self, handler: <foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxResolveRecipientsRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ResolveRecipientsRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ValidateCertificatesRequested(&self, handler: <foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxValidateCertificatesRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ValidateCertificatesRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ServerSearchReadBatchRequested(&self, handler: <foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxServerSearchReadBatchRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ServerSearchReadBatchRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn Start(&self) -> HRESULT
}}
impl IEmailDataProviderConnection {
    #[inline] pub fn add_mailbox_sync_requested(&self, handler: &foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxSyncManagerSyncRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_MailboxSyncRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_mailbox_sync_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_MailboxSyncRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_download_message_requested(&self, handler: &foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxDownloadMessageRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_DownloadMessageRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_download_message_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_DownloadMessageRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_download_attachment_requested(&self, handler: &foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxDownloadAttachmentRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_DownloadAttachmentRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_download_attachment_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_DownloadAttachmentRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_create_folder_requested(&self, handler: &foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxCreateFolderRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_CreateFolderRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_create_folder_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_CreateFolderRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_delete_folder_requested(&self, handler: &foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxDeleteFolderRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_DeleteFolderRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_delete_folder_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_DeleteFolderRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_empty_folder_requested(&self, handler: &foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxEmptyFolderRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_EmptyFolderRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_empty_folder_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_EmptyFolderRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_move_folder_requested(&self, handler: &foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxMoveFolderRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_MoveFolderRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_move_folder_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_MoveFolderRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_update_meeting_response_requested(&self, handler: &foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxUpdateMeetingResponseRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_UpdateMeetingResponseRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_update_meeting_response_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_UpdateMeetingResponseRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_forward_meeting_requested(&self, handler: &foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxForwardMeetingRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_ForwardMeetingRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_forward_meeting_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_ForwardMeetingRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_propose_new_time_for_meeting_requested(&self, handler: &foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxProposeNewTimeForMeetingRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_ProposeNewTimeForMeetingRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_propose_new_time_for_meeting_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_ProposeNewTimeForMeetingRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_set_auto_reply_settings_requested(&self, handler: &foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxSetAutoReplySettingsRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_SetAutoReplySettingsRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_set_auto_reply_settings_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_SetAutoReplySettingsRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_get_auto_reply_settings_requested(&self, handler: &foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxGetAutoReplySettingsRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_GetAutoReplySettingsRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_get_auto_reply_settings_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_GetAutoReplySettingsRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_resolve_recipients_requested(&self, handler: &foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxResolveRecipientsRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_ResolveRecipientsRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_resolve_recipients_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_ResolveRecipientsRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_validate_certificates_requested(&self, handler: &foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxValidateCertificatesRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_ValidateCertificatesRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_validate_certificates_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_ValidateCertificatesRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_server_search_read_batch_requested(&self, handler: &foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxServerSearchReadBatchRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_ServerSearchReadBatchRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_server_search_read_batch_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_ServerSearchReadBatchRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Start)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailDataProviderConnection: IEmailDataProviderConnection}
DEFINE_IID!(IID_IEmailDataProviderTriggerDetails, 2403225168, 13342, 17907, 187, 160, 132, 160, 5, 225, 49, 154);
RT_INTERFACE!{interface IEmailDataProviderTriggerDetails(IEmailDataProviderTriggerDetailsVtbl): IInspectable [IID_IEmailDataProviderTriggerDetails] {
    fn get_Connection(&self, out: *mut <EmailDataProviderConnection as RtType>::Abi) -> HRESULT
}}
impl IEmailDataProviderTriggerDetails {
    #[inline] pub fn get_connection(&self) -> Result<Option<EmailDataProviderConnection>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Connection)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailDataProviderConnection::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailDataProviderTriggerDetails: IEmailDataProviderTriggerDetails}
DEFINE_IID!(IID_IEmailMailboxCreateFolderRequest, 407713653, 51489, 19513, 163, 9, 225, 108, 159, 34, 176, 75);
RT_INTERFACE!{interface IEmailMailboxCreateFolderRequest(IEmailMailboxCreateFolderRequestVtbl): IInspectable [IID_IEmailMailboxCreateFolderRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ParentFolderId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, folder: <super::EmailFolder as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, status: super::EmailMailboxCreateFolderStatus, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxCreateFolderRequest {
    #[inline] pub fn get_email_mailbox_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailMailboxId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_parent_folder_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ParentFolderId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Name)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self, folder: &super::EmailFolder) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, folder.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self, status: super::EmailMailboxCreateFolderStatus) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, status, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxCreateFolderRequest: IEmailMailboxCreateFolderRequest}
DEFINE_IID!(IID_IEmailMailboxCreateFolderRequestEventArgs, 65323052, 9244, 20137, 166, 143, 255, 32, 188, 90, 252, 133);
RT_INTERFACE!{interface IEmailMailboxCreateFolderRequestEventArgs(IEmailMailboxCreateFolderRequestEventArgsVtbl): IInspectable [IID_IEmailMailboxCreateFolderRequestEventArgs] {
    fn get_Request(&self, out: *mut <EmailMailboxCreateFolderRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxCreateFolderRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<EmailMailboxCreateFolderRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxCreateFolderRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxCreateFolderRequestEventArgs: IEmailMailboxCreateFolderRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxDeleteFolderRequest, 2489968778, 43313, 18297, 146, 61, 9, 163, 234, 41, 46, 41);
RT_INTERFACE!{interface IEmailMailboxDeleteFolderRequest(IEmailMailboxDeleteFolderRequestVtbl): IInspectable [IID_IEmailMailboxDeleteFolderRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EmailFolderId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, status: super::EmailMailboxDeleteFolderStatus, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxDeleteFolderRequest {
    #[inline] pub fn get_email_mailbox_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailMailboxId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_email_folder_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailFolderId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self, status: super::EmailMailboxDeleteFolderStatus) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, status, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxDeleteFolderRequest: IEmailMailboxDeleteFolderRequest}
DEFINE_IID!(IID_IEmailMailboxDeleteFolderRequestEventArgs, 3033738502, 9010, 18040, 131, 120, 40, 181, 121, 51, 104, 70);
RT_INTERFACE!{interface IEmailMailboxDeleteFolderRequestEventArgs(IEmailMailboxDeleteFolderRequestEventArgsVtbl): IInspectable [IID_IEmailMailboxDeleteFolderRequestEventArgs] {
    fn get_Request(&self, out: *mut <EmailMailboxDeleteFolderRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxDeleteFolderRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<EmailMailboxDeleteFolderRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxDeleteFolderRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxDeleteFolderRequestEventArgs: IEmailMailboxDeleteFolderRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxDownloadAttachmentRequest, 186497972, 29964, 18657, 188, 228, 141, 88, 150, 132, 255, 188);
RT_INTERFACE!{interface IEmailMailboxDownloadAttachmentRequest(IEmailMailboxDownloadAttachmentRequestVtbl): IInspectable [IID_IEmailMailboxDownloadAttachmentRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EmailMessageId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EmailAttachmentId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxDownloadAttachmentRequest {
    #[inline] pub fn get_email_mailbox_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailMailboxId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_email_message_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailMessageId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_email_attachment_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailAttachmentId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxDownloadAttachmentRequest: IEmailMailboxDownloadAttachmentRequest}
DEFINE_IID!(IID_IEmailMailboxDownloadAttachmentRequestEventArgs, 3437085805, 65448, 18551, 159, 157, 254, 215, 188, 175, 65, 4);
RT_INTERFACE!{interface IEmailMailboxDownloadAttachmentRequestEventArgs(IEmailMailboxDownloadAttachmentRequestEventArgsVtbl): IInspectable [IID_IEmailMailboxDownloadAttachmentRequestEventArgs] {
    fn get_Request(&self, out: *mut <EmailMailboxDownloadAttachmentRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxDownloadAttachmentRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<EmailMailboxDownloadAttachmentRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxDownloadAttachmentRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxDownloadAttachmentRequestEventArgs: IEmailMailboxDownloadAttachmentRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxDownloadMessageRequest, 1232814471, 23373, 19235, 129, 108, 243, 132, 43, 235, 117, 62);
RT_INTERFACE!{interface IEmailMailboxDownloadMessageRequest(IEmailMailboxDownloadMessageRequestVtbl): IInspectable [IID_IEmailMailboxDownloadMessageRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EmailMessageId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxDownloadMessageRequest {
    #[inline] pub fn get_email_mailbox_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailMailboxId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_email_message_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailMessageId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxDownloadMessageRequest: IEmailMailboxDownloadMessageRequest}
DEFINE_IID!(IID_IEmailMailboxDownloadMessageRequestEventArgs, 1191446957, 53408, 19035, 187, 42, 55, 98, 16, 57, 197, 62);
RT_INTERFACE!{interface IEmailMailboxDownloadMessageRequestEventArgs(IEmailMailboxDownloadMessageRequestEventArgsVtbl): IInspectable [IID_IEmailMailboxDownloadMessageRequestEventArgs] {
    fn get_Request(&self, out: *mut <EmailMailboxDownloadMessageRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxDownloadMessageRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<EmailMailboxDownloadMessageRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxDownloadMessageRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxDownloadMessageRequestEventArgs: IEmailMailboxDownloadMessageRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxEmptyFolderRequest, 4266329003, 63597, 18137, 180, 206, 188, 138, 109, 158, 146, 104);
RT_INTERFACE!{interface IEmailMailboxEmptyFolderRequest(IEmailMailboxEmptyFolderRequestVtbl): IInspectable [IID_IEmailMailboxEmptyFolderRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EmailFolderId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, status: super::EmailMailboxEmptyFolderStatus, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxEmptyFolderRequest {
    #[inline] pub fn get_email_mailbox_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailMailboxId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_email_folder_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailFolderId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self, status: super::EmailMailboxEmptyFolderStatus) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, status, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxEmptyFolderRequest: IEmailMailboxEmptyFolderRequest}
DEFINE_IID!(IID_IEmailMailboxEmptyFolderRequestEventArgs, 1904473220, 39002, 19136, 179, 63, 238, 14, 38, 39, 163, 192);
RT_INTERFACE!{interface IEmailMailboxEmptyFolderRequestEventArgs(IEmailMailboxEmptyFolderRequestEventArgsVtbl): IInspectable [IID_IEmailMailboxEmptyFolderRequestEventArgs] {
    fn get_Request(&self, out: *mut <EmailMailboxEmptyFolderRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxEmptyFolderRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<EmailMailboxEmptyFolderRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxEmptyFolderRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxEmptyFolderRequestEventArgs: IEmailMailboxEmptyFolderRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxForwardMeetingRequest, 1634560753, 28884, 18482, 184, 105, 184, 5, 66, 174, 155, 232);
RT_INTERFACE!{interface IEmailMailboxForwardMeetingRequest(IEmailMailboxForwardMeetingRequestVtbl): IInspectable [IID_IEmailMailboxForwardMeetingRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EmailMessageId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Recipients(&self, out: *mut <foundation::collections::IVectorView<super::EmailRecipient> as RtType>::Abi) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ForwardHeaderType(&self, out: *mut super::EmailMessageBodyKind) -> HRESULT,
    fn get_ForwardHeader(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Comment(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxForwardMeetingRequest {
    #[inline] pub fn get_email_mailbox_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailMailboxId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_email_message_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailMessageId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_recipients(&self) -> Result<Option<foundation::collections::IVectorView<super::EmailRecipient>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Recipients)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_subject(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Subject)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_forward_header_type(&self) -> Result<super::EmailMessageBodyKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ForwardHeaderType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_forward_header(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ForwardHeader)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_comment(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Comment)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxForwardMeetingRequest: IEmailMailboxForwardMeetingRequest}
DEFINE_IID!(IID_IEmailMailboxForwardMeetingRequestEventArgs, 735638330, 10612, 18265, 165, 165, 88, 244, 77, 60, 2, 117);
RT_INTERFACE!{interface IEmailMailboxForwardMeetingRequestEventArgs(IEmailMailboxForwardMeetingRequestEventArgsVtbl): IInspectable [IID_IEmailMailboxForwardMeetingRequestEventArgs] {
    fn get_Request(&self, out: *mut <EmailMailboxForwardMeetingRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxForwardMeetingRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<EmailMailboxForwardMeetingRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxForwardMeetingRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxForwardMeetingRequestEventArgs: IEmailMailboxForwardMeetingRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxGetAutoReplySettingsRequest, 2604140425, 7816, 19969, 132, 204, 19, 134, 173, 154, 44, 47);
RT_INTERFACE!{interface IEmailMailboxGetAutoReplySettingsRequest(IEmailMailboxGetAutoReplySettingsRequestVtbl): IInspectable [IID_IEmailMailboxGetAutoReplySettingsRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RequestedFormat(&self, out: *mut super::EmailMailboxAutoReplyMessageResponseKind) -> HRESULT,
    fn ReportCompletedAsync(&self, autoReplySettings: <super::EmailMailboxAutoReplySettings as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxGetAutoReplySettingsRequest {
    #[inline] pub fn get_email_mailbox_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailMailboxId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_requested_format(&self) -> Result<super::EmailMailboxAutoReplyMessageResponseKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_RequestedFormat)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self, autoReplySettings: &super::EmailMailboxAutoReplySettings) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, autoReplySettings.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxGetAutoReplySettingsRequest: IEmailMailboxGetAutoReplySettingsRequest}
DEFINE_IID!(IID_IEmailMailboxGetAutoReplySettingsRequestEventArgs, 3617543618, 64837, 16388, 138, 145, 155, 172, 243, 139, 112, 34);
RT_INTERFACE!{interface IEmailMailboxGetAutoReplySettingsRequestEventArgs(IEmailMailboxGetAutoReplySettingsRequestEventArgsVtbl): IInspectable [IID_IEmailMailboxGetAutoReplySettingsRequestEventArgs] {
    fn get_Request(&self, out: *mut <EmailMailboxGetAutoReplySettingsRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxGetAutoReplySettingsRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<EmailMailboxGetAutoReplySettingsRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxGetAutoReplySettingsRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxGetAutoReplySettingsRequestEventArgs: IEmailMailboxGetAutoReplySettingsRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxMoveFolderRequest, 280635478, 19093, 16488, 145, 204, 103, 204, 122, 207, 69, 79);
RT_INTERFACE!{interface IEmailMailboxMoveFolderRequest(IEmailMailboxMoveFolderRequestVtbl): IInspectable [IID_IEmailMailboxMoveFolderRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EmailFolderId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_NewParentFolderId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_NewFolderName(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxMoveFolderRequest {
    #[inline] pub fn get_email_mailbox_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailMailboxId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_email_folder_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailFolderId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_new_parent_folder_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_NewParentFolderId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_new_folder_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_NewFolderName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxMoveFolderRequest: IEmailMailboxMoveFolderRequest}
DEFINE_IID!(IID_IEmailMailboxMoveFolderRequestEventArgs, 945958944, 5306, 19592, 134, 152, 114, 57, 227, 200, 170, 167);
RT_INTERFACE!{interface IEmailMailboxMoveFolderRequestEventArgs(IEmailMailboxMoveFolderRequestEventArgsVtbl): IInspectable [IID_IEmailMailboxMoveFolderRequestEventArgs] {
    fn get_Request(&self, out: *mut <EmailMailboxMoveFolderRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxMoveFolderRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<EmailMailboxMoveFolderRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxMoveFolderRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxMoveFolderRequestEventArgs: IEmailMailboxMoveFolderRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxProposeNewTimeForMeetingRequest, 1525674322, 38809, 20383, 163, 153, 255, 7, 243, 238, 240, 78);
RT_INTERFACE!{interface IEmailMailboxProposeNewTimeForMeetingRequest(IEmailMailboxProposeNewTimeForMeetingRequestVtbl): IInspectable [IID_IEmailMailboxProposeNewTimeForMeetingRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EmailMessageId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_NewStartTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_NewDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Comment(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxProposeNewTimeForMeetingRequest {
    #[inline] pub fn get_email_mailbox_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailMailboxId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_email_message_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailMessageId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_new_start_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_NewStartTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_new_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_NewDuration)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_subject(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Subject)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_comment(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Comment)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxProposeNewTimeForMeetingRequest: IEmailMailboxProposeNewTimeForMeetingRequest}
DEFINE_IID!(IID_IEmailMailboxProposeNewTimeForMeetingRequestEventArgs, 4215802776, 13229, 19047, 130, 81, 15, 156, 36, 155, 106, 32);
RT_INTERFACE!{interface IEmailMailboxProposeNewTimeForMeetingRequestEventArgs(IEmailMailboxProposeNewTimeForMeetingRequestEventArgsVtbl): IInspectable [IID_IEmailMailboxProposeNewTimeForMeetingRequestEventArgs] {
    fn get_Request(&self, out: *mut <EmailMailboxProposeNewTimeForMeetingRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxProposeNewTimeForMeetingRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<EmailMailboxProposeNewTimeForMeetingRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxProposeNewTimeForMeetingRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxProposeNewTimeForMeetingRequestEventArgs: IEmailMailboxProposeNewTimeForMeetingRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxResolveRecipientsRequest, 4020555632, 31545, 19611, 129, 30, 65, 234, 244, 58, 51, 45);
RT_INTERFACE!{interface IEmailMailboxResolveRecipientsRequest(IEmailMailboxResolveRecipientsRequestVtbl): IInspectable [IID_IEmailMailboxResolveRecipientsRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Recipients(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT,
    fn ReportCompletedAsync(&self, resolutionResults: <foundation::collections::IIterable<super::EmailRecipientResolutionResult> as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxResolveRecipientsRequest {
    #[inline] pub fn get_email_mailbox_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailMailboxId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_recipients(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Recipients)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self, resolutionResults: &foundation::collections::IIterable<super::EmailRecipientResolutionResult>) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, resolutionResults.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxResolveRecipientsRequest: IEmailMailboxResolveRecipientsRequest}
DEFINE_IID!(IID_IEmailMailboxResolveRecipientsRequestEventArgs, 638557698, 45775, 16632, 140, 40, 227, 237, 67, 177, 232, 154);
RT_INTERFACE!{interface IEmailMailboxResolveRecipientsRequestEventArgs(IEmailMailboxResolveRecipientsRequestEventArgsVtbl): IInspectable [IID_IEmailMailboxResolveRecipientsRequestEventArgs] {
    fn get_Request(&self, out: *mut <EmailMailboxResolveRecipientsRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxResolveRecipientsRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<EmailMailboxResolveRecipientsRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxResolveRecipientsRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxResolveRecipientsRequestEventArgs: IEmailMailboxResolveRecipientsRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxServerSearchReadBatchRequest, 151972831, 23190, 16851, 138, 216, 52, 145, 47, 154, 166, 14);
RT_INTERFACE!{interface IEmailMailboxServerSearchReadBatchRequest(IEmailMailboxServerSearchReadBatchRequestVtbl): IInspectable [IID_IEmailMailboxServerSearchReadBatchRequest] {
    fn get_SessionId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EmailFolderId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Options(&self, out: *mut <super::EmailQueryOptions as RtType>::Abi) -> HRESULT,
    fn get_SuggestedBatchSize(&self, out: *mut u32) -> HRESULT,
    fn SaveMessageAsync(&self, message: <super::EmailMessage as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, batchStatus: super::EmailBatchStatus, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxServerSearchReadBatchRequest {
    #[inline] pub fn get_session_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SessionId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_email_mailbox_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailMailboxId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_email_folder_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailFolderId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_options(&self) -> Result<Option<super::EmailQueryOptions>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Options)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::EmailQueryOptions::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_suggested_batch_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SuggestedBatchSize)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn save_message_async(&self, message: &super::EmailMessage) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SaveMessageAsync)(self.get_abi() as *const _ as *mut _, message.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self, batchStatus: super::EmailBatchStatus) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, batchStatus, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxServerSearchReadBatchRequest: IEmailMailboxServerSearchReadBatchRequest}
DEFINE_IID!(IID_IEmailMailboxServerSearchReadBatchRequestEventArgs, 336599886, 60830, 17873, 173, 122, 204, 155, 127, 100, 58, 226);
RT_INTERFACE!{interface IEmailMailboxServerSearchReadBatchRequestEventArgs(IEmailMailboxServerSearchReadBatchRequestEventArgsVtbl): IInspectable [IID_IEmailMailboxServerSearchReadBatchRequestEventArgs] {
    fn get_Request(&self, out: *mut <EmailMailboxServerSearchReadBatchRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxServerSearchReadBatchRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<EmailMailboxServerSearchReadBatchRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxServerSearchReadBatchRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxServerSearchReadBatchRequestEventArgs: IEmailMailboxServerSearchReadBatchRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxSetAutoReplySettingsRequest, 1973691088, 43150, 20052, 141, 199, 194, 67, 24, 107, 119, 78);
RT_INTERFACE!{interface IEmailMailboxSetAutoReplySettingsRequest(IEmailMailboxSetAutoReplySettingsRequestVtbl): IInspectable [IID_IEmailMailboxSetAutoReplySettingsRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AutoReplySettings(&self, out: *mut <super::EmailMailboxAutoReplySettings as RtType>::Abi) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxSetAutoReplySettingsRequest {
    #[inline] pub fn get_email_mailbox_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailMailboxId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_reply_settings(&self) -> Result<Option<super::EmailMailboxAutoReplySettings>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AutoReplySettings)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::EmailMailboxAutoReplySettings::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxSetAutoReplySettingsRequest: IEmailMailboxSetAutoReplySettingsRequest}
DEFINE_IID!(IID_IEmailMailboxSetAutoReplySettingsRequestEventArgs, 165286317, 55242, 16519, 172, 134, 83, 250, 103, 247, 98, 70);
RT_INTERFACE!{interface IEmailMailboxSetAutoReplySettingsRequestEventArgs(IEmailMailboxSetAutoReplySettingsRequestEventArgsVtbl): IInspectable [IID_IEmailMailboxSetAutoReplySettingsRequestEventArgs] {
    fn get_Request(&self, out: *mut <EmailMailboxSetAutoReplySettingsRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxSetAutoReplySettingsRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<EmailMailboxSetAutoReplySettingsRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxSetAutoReplySettingsRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxSetAutoReplySettingsRequestEventArgs: IEmailMailboxSetAutoReplySettingsRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxSyncManagerSyncRequest, 1309731044, 32359, 16474, 182, 115, 220, 96, 201, 16, 144, 252);
RT_INTERFACE!{interface IEmailMailboxSyncManagerSyncRequest(IEmailMailboxSyncManagerSyncRequestVtbl): IInspectable [IID_IEmailMailboxSyncManagerSyncRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxSyncManagerSyncRequest {
    #[inline] pub fn get_email_mailbox_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailMailboxId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxSyncManagerSyncRequest: IEmailMailboxSyncManagerSyncRequest}
DEFINE_IID!(IID_IEmailMailboxSyncManagerSyncRequestEventArgs, 1134166810, 36812, 19173, 185, 181, 212, 52, 224, 166, 90, 168);
RT_INTERFACE!{interface IEmailMailboxSyncManagerSyncRequestEventArgs(IEmailMailboxSyncManagerSyncRequestEventArgsVtbl): IInspectable [IID_IEmailMailboxSyncManagerSyncRequestEventArgs] {
    fn get_Request(&self, out: *mut <EmailMailboxSyncManagerSyncRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxSyncManagerSyncRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<EmailMailboxSyncManagerSyncRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxSyncManagerSyncRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxSyncManagerSyncRequestEventArgs: IEmailMailboxSyncManagerSyncRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxUpdateMeetingResponseRequest, 1536797843, 45775, 18568, 186, 79, 48, 107, 107, 102, 223, 48);
RT_INTERFACE!{interface IEmailMailboxUpdateMeetingResponseRequest(IEmailMailboxUpdateMeetingResponseRequestVtbl): IInspectable [IID_IEmailMailboxUpdateMeetingResponseRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EmailMessageId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Response(&self, out: *mut super::EmailMeetingResponseType) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Comment(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SendUpdate(&self, out: *mut bool) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxUpdateMeetingResponseRequest {
    #[inline] pub fn get_email_mailbox_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailMailboxId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_email_message_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailMessageId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_response(&self) -> Result<super::EmailMeetingResponseType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Response)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_subject(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Subject)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_comment(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Comment)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_send_update(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SendUpdate)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxUpdateMeetingResponseRequest: IEmailMailboxUpdateMeetingResponseRequest}
DEFINE_IID!(IID_IEmailMailboxUpdateMeetingResponseRequestEventArgs, 1754847073, 22217, 20247, 190, 49, 102, 253, 169, 75, 161, 89);
RT_INTERFACE!{interface IEmailMailboxUpdateMeetingResponseRequestEventArgs(IEmailMailboxUpdateMeetingResponseRequestEventArgsVtbl): IInspectable [IID_IEmailMailboxUpdateMeetingResponseRequestEventArgs] {
    fn get_Request(&self, out: *mut <EmailMailboxUpdateMeetingResponseRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxUpdateMeetingResponseRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<EmailMailboxUpdateMeetingResponseRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxUpdateMeetingResponseRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxUpdateMeetingResponseRequestEventArgs: IEmailMailboxUpdateMeetingResponseRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxValidateCertificatesRequest, 2840410417, 57626, 20375, 184, 26, 24, 122, 112, 168, 244, 26);
RT_INTERFACE!{interface IEmailMailboxValidateCertificatesRequest(IEmailMailboxValidateCertificatesRequestVtbl): IInspectable [IID_IEmailMailboxValidateCertificatesRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-security")] fn get_Certificates(&self, out: *mut <foundation::collections::IVectorView<crate::windows::security::cryptography::certificates::Certificate> as RtType>::Abi) -> HRESULT,
    fn ReportCompletedAsync(&self, validationStatuses: <foundation::collections::IIterable<super::EmailCertificateValidationStatus> as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxValidateCertificatesRequest {
    #[inline] pub fn get_email_mailbox_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailMailboxId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn get_certificates(&self) -> Result<Option<foundation::collections::IVectorView<crate::windows::security::cryptography::certificates::Certificate>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Certificates)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self, validationStatuses: &foundation::collections::IIterable<super::EmailCertificateValidationStatus>) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, validationStatuses.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxValidateCertificatesRequest: IEmailMailboxValidateCertificatesRequest}
DEFINE_IID!(IID_IEmailMailboxValidateCertificatesRequestEventArgs, 629391127, 767, 18942, 167, 60, 3, 243, 117, 102, 198, 145);
RT_INTERFACE!{interface IEmailMailboxValidateCertificatesRequestEventArgs(IEmailMailboxValidateCertificatesRequestEventArgsVtbl): IInspectable [IID_IEmailMailboxValidateCertificatesRequestEventArgs] {
    fn get_Request(&self, out: *mut <EmailMailboxValidateCertificatesRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IEmailMailboxValidateCertificatesRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<EmailMailboxValidateCertificatesRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EmailMailboxValidateCertificatesRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmailMailboxValidateCertificatesRequestEventArgs: IEmailMailboxValidateCertificatesRequestEventArgs}
} // Windows.ApplicationModel.Email.DataProvider
} // Windows.ApplicationModel.Email
pub mod extendedexecution { // Windows.ApplicationModel.ExtendedExecution
use crate::prelude::*;
RT_ENUM! { enum ExtendedExecutionReason: i32 {
    Unspecified = 0, LocationTracking = 1, SavingData = 2,
}}
RT_ENUM! { enum ExtendedExecutionResult: i32 {
    Allowed = 0, Denied = 1,
}}
DEFINE_IID!(IID_IExtendedExecutionRevokedEventArgs, 3216809750, 25525, 19467, 170, 214, 130, 138, 245, 55, 62, 195);
RT_INTERFACE!{interface IExtendedExecutionRevokedEventArgs(IExtendedExecutionRevokedEventArgsVtbl): IInspectable [IID_IExtendedExecutionRevokedEventArgs] {
    fn get_Reason(&self, out: *mut ExtendedExecutionRevokedReason) -> HRESULT
}}
impl IExtendedExecutionRevokedEventArgs {
    #[inline] pub fn get_reason(&self) -> Result<ExtendedExecutionRevokedReason> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Reason)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ExtendedExecutionRevokedEventArgs: IExtendedExecutionRevokedEventArgs}
RT_ENUM! { enum ExtendedExecutionRevokedReason: i32 {
    Resumed = 0, SystemPolicy = 1,
}}
DEFINE_IID!(IID_IExtendedExecutionSession, 2945485357, 4491, 18673, 147, 8, 12, 79, 196, 30, 32, 15);
RT_INTERFACE!{interface IExtendedExecutionSession(IExtendedExecutionSessionVtbl): IInspectable [IID_IExtendedExecutionSession] {
    fn get_Reason(&self, out: *mut ExtendedExecutionReason) -> HRESULT,
    fn put_Reason(&self, value: ExtendedExecutionReason) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT,
    fn get_PercentProgress(&self, out: *mut u32) -> HRESULT,
    fn put_PercentProgress(&self, value: u32) -> HRESULT,
    fn add_Revoked(&self, handler: <foundation::TypedEventHandler<IInspectable, ExtendedExecutionRevokedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Revoked(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn RequestExtensionAsync(&self, out: *mut <foundation::IAsyncOperation<ExtendedExecutionResult> as RtType>::Abi) -> HRESULT
}}
impl IExtendedExecutionSession {
    #[inline] pub fn get_reason(&self) -> Result<ExtendedExecutionReason> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Reason)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_reason(&self, value: ExtendedExecutionReason) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Reason)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Description)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_description(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Description)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_percent_progress(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_PercentProgress)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_percent_progress(&self, value: u32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_PercentProgress)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_revoked(&self, handler: &foundation::TypedEventHandler<IInspectable, ExtendedExecutionRevokedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_Revoked)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_revoked(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_Revoked)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn request_extension_async(&self) -> Result<foundation::IAsyncOperation<ExtendedExecutionResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestExtensionAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ExtendedExecutionSession: IExtendedExecutionSession}
impl RtActivatable<IActivationFactory> for ExtendedExecutionSession {}
DEFINE_CLSID!(ExtendedExecutionSession(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,69,120,116,101,110,100,101,100,69,120,101,99,117,116,105,111,110,46,69,120,116,101,110,100,101,100,69,120,101,99,117,116,105,111,110,83,101,115,115,105,111,110,0]) [CLSID_ExtendedExecutionSession]);
pub mod foreground { // Windows.ApplicationModel.ExtendedExecution.Foreground
use crate::prelude::*;
RT_ENUM! { enum ExtendedExecutionForegroundReason: i32 {
    Unspecified = 0, SavingData = 1, BackgroundAudio = 2, Unconstrained = 3,
}}
RT_ENUM! { enum ExtendedExecutionForegroundResult: i32 {
    Allowed = 0, Denied = 1,
}}
DEFINE_IID!(IID_IExtendedExecutionForegroundRevokedEventArgs, 2960972096, 38231, 44708, 44, 153, 189, 213, 109, 155, 228, 97);
RT_INTERFACE!{interface IExtendedExecutionForegroundRevokedEventArgs(IExtendedExecutionForegroundRevokedEventArgsVtbl): IInspectable [IID_IExtendedExecutionForegroundRevokedEventArgs] {
    fn get_Reason(&self, out: *mut ExtendedExecutionForegroundRevokedReason) -> HRESULT
}}
impl IExtendedExecutionForegroundRevokedEventArgs {
    #[inline] pub fn get_reason(&self) -> Result<ExtendedExecutionForegroundRevokedReason> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Reason)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ExtendedExecutionForegroundRevokedEventArgs: IExtendedExecutionForegroundRevokedEventArgs}
RT_ENUM! { enum ExtendedExecutionForegroundRevokedReason: i32 {
    Resumed = 0, SystemPolicy = 1,
}}
DEFINE_IID!(IID_IExtendedExecutionForegroundSession, 4227088609, 40208, 16897, 176, 30, 200, 50, 117, 41, 111, 46);
RT_INTERFACE!{interface IExtendedExecutionForegroundSession(IExtendedExecutionForegroundSessionVtbl): IInspectable [IID_IExtendedExecutionForegroundSession] {
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT,
    fn add_Revoked(&self, handler: <foundation::TypedEventHandler<IInspectable, ExtendedExecutionForegroundRevokedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Revoked(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn RequestExtensionAsync(&self, out: *mut <foundation::IAsyncOperation<ExtendedExecutionForegroundResult> as RtType>::Abi) -> HRESULT,
    fn get_Reason(&self, out: *mut ExtendedExecutionForegroundReason) -> HRESULT,
    fn put_Reason(&self, value: ExtendedExecutionForegroundReason) -> HRESULT
}}
impl IExtendedExecutionForegroundSession {
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Description)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_description(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Description)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_revoked(&self, handler: &foundation::TypedEventHandler<IInspectable, ExtendedExecutionForegroundRevokedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_Revoked)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_revoked(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_Revoked)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn request_extension_async(&self) -> Result<foundation::IAsyncOperation<ExtendedExecutionForegroundResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestExtensionAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_reason(&self) -> Result<ExtendedExecutionForegroundReason> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Reason)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_reason(&self, value: ExtendedExecutionForegroundReason) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Reason)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ExtendedExecutionForegroundSession: IExtendedExecutionForegroundSession}
impl RtActivatable<IActivationFactory> for ExtendedExecutionForegroundSession {}
DEFINE_CLSID!(ExtendedExecutionForegroundSession(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,69,120,116,101,110,100,101,100,69,120,101,99,117,116,105,111,110,46,70,111,114,101,103,114,111,117,110,100,46,69,120,116,101,110,100,101,100,69,120,101,99,117,116,105,111,110,70,111,114,101,103,114,111,117,110,100,83,101,115,115,105,111,110,0]) [CLSID_ExtendedExecutionForegroundSession]);
} // Windows.ApplicationModel.ExtendedExecution.Foreground
} // Windows.ApplicationModel.ExtendedExecution
pub mod lockscreen { // Windows.ApplicationModel.LockScreen
use crate::prelude::*;
DEFINE_IID!(IID_ILockApplicationHost, 955134381, 55631, 20092, 129, 250, 79, 68, 54, 80, 98, 129);
RT_INTERFACE!{interface ILockApplicationHost(ILockApplicationHostVtbl): IInspectable [IID_ILockApplicationHost] {
    fn RequestUnlock(&self) -> HRESULT,
    fn add_Unlocking(&self, handler: <foundation::TypedEventHandler<LockApplicationHost, LockScreenUnlockingEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Unlocking(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ILockApplicationHost {
    #[inline] pub fn request_unlock(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().RequestUnlock)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_unlocking(&self, handler: &foundation::TypedEventHandler<LockApplicationHost, LockScreenUnlockingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_Unlocking)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_unlocking(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_Unlocking)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LockApplicationHost: ILockApplicationHost}
impl RtActivatable<ILockApplicationHostStatics> for LockApplicationHost {}
impl LockApplicationHost {
    #[inline] pub fn get_for_current_view() -> Result<Option<LockApplicationHost>> {
        <Self as RtActivatable<ILockApplicationHostStatics>>::get_activation_factory().get_for_current_view()
    }
}
DEFINE_CLSID!(LockApplicationHost(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,76,111,99,107,83,99,114,101,101,110,46,76,111,99,107,65,112,112,108,105,99,97,116,105,111,110,72,111,115,116,0]) [CLSID_LockApplicationHost]);
DEFINE_IID!(IID_ILockApplicationHostStatics, 4103056270, 9175, 20067, 150, 161, 102, 111, 245, 45, 59, 44);
RT_INTERFACE!{static interface ILockApplicationHostStatics(ILockApplicationHostStaticsVtbl): IInspectable [IID_ILockApplicationHostStatics] {
    fn GetForCurrentView(&self, out: *mut <LockApplicationHost as RtType>::Abi) -> HRESULT
}}
impl ILockApplicationHostStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<LockApplicationHost>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetForCurrentView)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(LockApplicationHost::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILockScreenBadge, 3914401241, 11263, 19888, 155, 79, 56, 36, 119, 139, 156, 154);
RT_INTERFACE!{interface ILockScreenBadge(ILockScreenBadgeVtbl): IInspectable [IID_ILockScreenBadge] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Logo(&self, out: *mut <super::super::storage::streams::IRandomAccessStream as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Glyph(&self, out: *mut <super::super::storage::streams::IRandomAccessStream as RtType>::Abi) -> HRESULT,
    fn get_Number(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_AutomationName(&self, out: *mut HSTRING) -> HRESULT,
    fn LaunchApp(&self) -> HRESULT
}}
impl ILockScreenBadge {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_logo(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStream>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Logo)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStream::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_glyph(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStream>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Glyph)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStream::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_number(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Number)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_automation_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AutomationName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn launch_app(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().LaunchApp)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LockScreenBadge: ILockScreenBadge}
DEFINE_IID!(IID_ILockScreenInfo, 4120553052, 38673, 19913, 166, 48, 149, 182, 203, 140, 218, 208);
RT_INTERFACE!{interface ILockScreenInfo(ILockScreenInfoVtbl): IInspectable [IID_ILockScreenInfo] {
    fn add_LockScreenImageChanged(&self, handler: <foundation::TypedEventHandler<LockScreenInfo, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LockScreenImageChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_LockScreenImage(&self, out: *mut <super::super::storage::streams::IRandomAccessStream as RtType>::Abi) -> HRESULT,
    fn add_BadgesChanged(&self, handler: <foundation::TypedEventHandler<LockScreenInfo, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BadgesChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Badges(&self, out: *mut <foundation::collections::IVectorView<LockScreenBadge> as RtType>::Abi) -> HRESULT,
    fn add_DetailTextChanged(&self, handler: <foundation::TypedEventHandler<LockScreenInfo, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DetailTextChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_DetailText(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT,
    fn add_AlarmIconChanged(&self, handler: <foundation::TypedEventHandler<LockScreenInfo, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AlarmIconChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_AlarmIcon(&self, out: *mut <super::super::storage::streams::IRandomAccessStream as RtType>::Abi) -> HRESULT
}}
impl ILockScreenInfo {
    #[inline] pub fn add_lock_screen_image_changed(&self, handler: &foundation::TypedEventHandler<LockScreenInfo, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_LockScreenImageChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_lock_screen_image_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_LockScreenImageChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_lock_screen_image(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStream>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LockScreenImage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStream::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_badges_changed(&self, handler: &foundation::TypedEventHandler<LockScreenInfo, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_BadgesChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_badges_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_BadgesChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_badges(&self) -> Result<Option<foundation::collections::IVectorView<LockScreenBadge>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Badges)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_detail_text_changed(&self, handler: &foundation::TypedEventHandler<LockScreenInfo, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_DetailTextChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_detail_text_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_DetailTextChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_detail_text(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DetailText)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_alarm_icon_changed(&self, handler: &foundation::TypedEventHandler<LockScreenInfo, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_AlarmIconChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_alarm_icon_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_AlarmIconChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_alarm_icon(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStream>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AlarmIcon)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStream::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LockScreenInfo: ILockScreenInfo}
DEFINE_IID!(IID_ILockScreenUnlockingDeferral, 2122128086, 20995, 17383, 155, 214, 124, 57, 71, 209, 227, 254);
RT_INTERFACE!{interface ILockScreenUnlockingDeferral(ILockScreenUnlockingDeferralVtbl): IInspectable [IID_ILockScreenUnlockingDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl ILockScreenUnlockingDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Complete)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LockScreenUnlockingDeferral: ILockScreenUnlockingDeferral}
DEFINE_IID!(IID_ILockScreenUnlockingEventArgs, 1155973127, 30203, 19131, 159, 139, 130, 71, 72, 144, 12, 113);
RT_INTERFACE!{interface ILockScreenUnlockingEventArgs(ILockScreenUnlockingEventArgsVtbl): IInspectable [IID_ILockScreenUnlockingEventArgs] {
    fn GetDeferral(&self, out: *mut <LockScreenUnlockingDeferral as RtType>::Abi) -> HRESULT,
    fn get_Deadline(&self, out: *mut foundation::DateTime) -> HRESULT
}}
impl ILockScreenUnlockingEventArgs {
    #[inline] pub fn get_deferral(&self) -> Result<Option<LockScreenUnlockingDeferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(LockScreenUnlockingDeferral::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deadline(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Deadline)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class LockScreenUnlockingEventArgs: ILockScreenUnlockingEventArgs}
} // Windows.ApplicationModel.LockScreen
pub mod payments { // Windows.ApplicationModel.Payments
use crate::prelude::*;
DEFINE_IID!(IID_IPaymentAddress, 1596089577, 28474, 16742, 160, 24, 10, 11, 6, 187, 50, 181);
RT_INTERFACE!{interface IPaymentAddress(IPaymentAddressVtbl): IInspectable [IID_IPaymentAddress] {
    fn get_Country(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Country(&self, value: HSTRING) -> HRESULT,
    fn get_AddressLines(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT,
    fn put_AddressLines(&self, value: <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT,
    fn get_Region(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Region(&self, value: HSTRING) -> HRESULT,
    fn get_City(&self, out: *mut HSTRING) -> HRESULT,
    fn put_City(&self, value: HSTRING) -> HRESULT,
    fn get_DependentLocality(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DependentLocality(&self, value: HSTRING) -> HRESULT,
    fn get_PostalCode(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PostalCode(&self, value: HSTRING) -> HRESULT,
    fn get_SortingCode(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SortingCode(&self, value: HSTRING) -> HRESULT,
    fn get_LanguageCode(&self, out: *mut HSTRING) -> HRESULT,
    fn put_LanguageCode(&self, value: HSTRING) -> HRESULT,
    fn get_Organization(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Organization(&self, value: HSTRING) -> HRESULT,
    fn get_Recipient(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Recipient(&self, value: HSTRING) -> HRESULT,
    fn get_PhoneNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PhoneNumber(&self, value: HSTRING) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::ValueSet as RtType>::Abi) -> HRESULT
}}
impl IPaymentAddress {
    #[inline] pub fn get_country(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Country)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_country(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Country)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_address_lines(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AddressLines)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_address_lines(&self, value: &foundation::collections::IVectorView<HString>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AddressLines)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_region(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Region)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_region(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Region)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_city(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_City)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_city(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_City)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_dependent_locality(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DependentLocality)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_dependent_locality(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DependentLocality)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_postal_code(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PostalCode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_postal_code(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_PostalCode)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sorting_code(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SortingCode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_sorting_code(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SortingCode)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_language_code(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LanguageCode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_language_code(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_LanguageCode)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_organization(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Organization)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_organization(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Organization)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_recipient(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Recipient)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_recipient(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Recipient)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_phone_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PhoneNumber)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_phone_number(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_PhoneNumber)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::ValueSet>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Properties)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::ValueSet::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PaymentAddress: IPaymentAddress}
impl RtActivatable<IActivationFactory> for PaymentAddress {}
DEFINE_CLSID!(PaymentAddress(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,97,121,109,101,110,116,115,46,80,97,121,109,101,110,116,65,100,100,114,101,115,115,0]) [CLSID_PaymentAddress]);
DEFINE_IID!(IID_IPaymentCanMakePaymentResult, 1989606997, 54739, 19773, 179, 69, 69, 89, 23, 89, 197, 16);
RT_INTERFACE!{interface IPaymentCanMakePaymentResult(IPaymentCanMakePaymentResultVtbl): IInspectable [IID_IPaymentCanMakePaymentResult] {
    fn get_Status(&self, out: *mut PaymentCanMakePaymentResultStatus) -> HRESULT
}}
impl IPaymentCanMakePaymentResult {
    #[inline] pub fn get_status(&self) -> Result<PaymentCanMakePaymentResultStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PaymentCanMakePaymentResult: IPaymentCanMakePaymentResult}
impl RtActivatable<IPaymentCanMakePaymentResultFactory> for PaymentCanMakePaymentResult {}
impl PaymentCanMakePaymentResult {
    #[inline] pub fn create(value: PaymentCanMakePaymentResultStatus) -> Result<PaymentCanMakePaymentResult> {
        <Self as RtActivatable<IPaymentCanMakePaymentResultFactory>>::get_activation_factory().create(value)
    }
}
DEFINE_CLSID!(PaymentCanMakePaymentResult(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,97,121,109,101,110,116,115,46,80,97,121,109,101,110,116,67,97,110,77,97,107,101,80,97,121,109,101,110,116,82,101,115,117,108,116,0]) [CLSID_PaymentCanMakePaymentResult]);
DEFINE_IID!(IID_IPaymentCanMakePaymentResultFactory, 3151800894, 32073, 20329, 170, 83, 42, 15, 129, 100, 183, 201);
RT_INTERFACE!{static interface IPaymentCanMakePaymentResultFactory(IPaymentCanMakePaymentResultFactoryVtbl): IInspectable [IID_IPaymentCanMakePaymentResultFactory] {
    fn Create(&self, value: PaymentCanMakePaymentResultStatus, out: *mut <PaymentCanMakePaymentResult as RtType>::Abi) -> HRESULT
}}
impl IPaymentCanMakePaymentResultFactory {
    #[inline] pub fn create(&self, value: PaymentCanMakePaymentResultStatus) -> Result<PaymentCanMakePaymentResult> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(PaymentCanMakePaymentResult::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum PaymentCanMakePaymentResultStatus: i32 {
    Unknown = 0, Yes = 1, No = 2, NotAllowed = 3, UserNotSignedIn = 4, SpecifiedPaymentMethodIdsNotSupported = 5, NoQualifyingCardOnFile = 6,
}}
DEFINE_IID!(IID_IPaymentCurrencyAmount, 3819170272, 46111, 18823, 189, 203, 7, 19, 49, 242, 218, 164);
RT_INTERFACE!{interface IPaymentCurrencyAmount(IPaymentCurrencyAmountVtbl): IInspectable [IID_IPaymentCurrencyAmount] {
    fn get_Currency(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Currency(&self, value: HSTRING) -> HRESULT,
    fn get_CurrencySystem(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CurrencySystem(&self, value: HSTRING) -> HRESULT,
    fn get_Value(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Value(&self, value: HSTRING) -> HRESULT
}}
impl IPaymentCurrencyAmount {
    #[inline] pub fn get_currency(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Currency)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_currency(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Currency)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_currency_system(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CurrencySystem)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_currency_system(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CurrencySystem)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Value)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_value(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Value)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PaymentCurrencyAmount: IPaymentCurrencyAmount}
impl RtActivatable<IPaymentCurrencyAmountFactory> for PaymentCurrencyAmount {}
impl PaymentCurrencyAmount {
    #[inline] pub fn create(value: &HStringArg, currency: &HStringArg) -> Result<PaymentCurrencyAmount> {
        <Self as RtActivatable<IPaymentCurrencyAmountFactory>>::get_activation_factory().create(value, currency)
    }
    #[inline] pub fn create_with_currency_system(value: &HStringArg, currency: &HStringArg, currencySystem: &HStringArg) -> Result<PaymentCurrencyAmount> {
        <Self as RtActivatable<IPaymentCurrencyAmountFactory>>::get_activation_factory().create_with_currency_system(value, currency, currencySystem)
    }
}
DEFINE_CLSID!(PaymentCurrencyAmount(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,97,121,109,101,110,116,115,46,80,97,121,109,101,110,116,67,117,114,114,101,110,99,121,65,109,111,117,110,116,0]) [CLSID_PaymentCurrencyAmount]);
DEFINE_IID!(IID_IPaymentCurrencyAmountFactory, 844616504, 5132, 17781, 133, 53, 247, 115, 23, 140, 9, 167);
RT_INTERFACE!{static interface IPaymentCurrencyAmountFactory(IPaymentCurrencyAmountFactoryVtbl): IInspectable [IID_IPaymentCurrencyAmountFactory] {
    fn Create(&self, value: HSTRING, currency: HSTRING, out: *mut <PaymentCurrencyAmount as RtType>::Abi) -> HRESULT,
    fn CreateWithCurrencySystem(&self, value: HSTRING, currency: HSTRING, currencySystem: HSTRING, out: *mut <PaymentCurrencyAmount as RtType>::Abi) -> HRESULT
}}
impl IPaymentCurrencyAmountFactory {
    #[inline] pub fn create(&self, value: &HStringArg, currency: &HStringArg) -> Result<PaymentCurrencyAmount> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, value.get(), currency.get(), &mut out);
        if hr == S_OK { Ok(PaymentCurrencyAmount::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_currency_system(&self, value: &HStringArg, currency: &HStringArg, currencySystem: &HStringArg) -> Result<PaymentCurrencyAmount> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWithCurrencySystem)(self.get_abi() as *const _ as *mut _, value.get(), currency.get(), currencySystem.get(), &mut out);
        if hr == S_OK { Ok(PaymentCurrencyAmount::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPaymentDetails, 1404775805, 57579, 16467, 142, 174, 206, 124, 72, 224, 41, 69);
RT_INTERFACE!{interface IPaymentDetails(IPaymentDetailsVtbl): IInspectable [IID_IPaymentDetails] {
    fn get_Total(&self, out: *mut <PaymentItem as RtType>::Abi) -> HRESULT,
    fn put_Total(&self, value: <PaymentItem as RtType>::Abi) -> HRESULT,
    fn get_DisplayItems(&self, out: *mut <foundation::collections::IVectorView<PaymentItem> as RtType>::Abi) -> HRESULT,
    fn put_DisplayItems(&self, value: <foundation::collections::IVectorView<PaymentItem> as RtType>::Abi) -> HRESULT,
    fn get_ShippingOptions(&self, out: *mut <foundation::collections::IVectorView<PaymentShippingOption> as RtType>::Abi) -> HRESULT,
    fn put_ShippingOptions(&self, value: <foundation::collections::IVectorView<PaymentShippingOption> as RtType>::Abi) -> HRESULT,
    fn get_Modifiers(&self, out: *mut <foundation::collections::IVectorView<PaymentDetailsModifier> as RtType>::Abi) -> HRESULT,
    fn put_Modifiers(&self, value: <foundation::collections::IVectorView<PaymentDetailsModifier> as RtType>::Abi) -> HRESULT
}}
impl IPaymentDetails {
    #[inline] pub fn get_total(&self) -> Result<Option<PaymentItem>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Total)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentItem::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_total(&self, value: &PaymentItem) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Total)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_display_items(&self) -> Result<Option<foundation::collections::IVectorView<PaymentItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayItems)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_items(&self, value: &foundation::collections::IVectorView<PaymentItem>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayItems)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_shipping_options(&self) -> Result<Option<foundation::collections::IVectorView<PaymentShippingOption>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ShippingOptions)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_shipping_options(&self, value: &foundation::collections::IVectorView<PaymentShippingOption>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ShippingOptions)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_modifiers(&self) -> Result<Option<foundation::collections::IVectorView<PaymentDetailsModifier>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Modifiers)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_modifiers(&self, value: &foundation::collections::IVectorView<PaymentDetailsModifier>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Modifiers)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PaymentDetails: IPaymentDetails}
impl RtActivatable<IPaymentDetailsFactory> for PaymentDetails {}
impl RtActivatable<IActivationFactory> for PaymentDetails {}
impl PaymentDetails {
    #[inline] pub fn create(total: &PaymentItem) -> Result<PaymentDetails> {
        <Self as RtActivatable<IPaymentDetailsFactory>>::get_activation_factory().create(total)
    }
    #[inline] pub fn create_with_display_items(total: &PaymentItem, displayItems: &foundation::collections::IIterable<PaymentItem>) -> Result<PaymentDetails> {
        <Self as RtActivatable<IPaymentDetailsFactory>>::get_activation_factory().create_with_display_items(total, displayItems)
    }
}
DEFINE_CLSID!(PaymentDetails(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,97,121,109,101,110,116,115,46,80,97,121,109,101,110,116,68,101,116,97,105,108,115,0]) [CLSID_PaymentDetails]);
DEFINE_IID!(IID_IPaymentDetailsFactory, 3488133102, 49386, 19617, 139, 199, 109, 230, 123, 31, 55, 99);
RT_INTERFACE!{static interface IPaymentDetailsFactory(IPaymentDetailsFactoryVtbl): IInspectable [IID_IPaymentDetailsFactory] {
    fn Create(&self, total: <PaymentItem as RtType>::Abi, out: *mut <PaymentDetails as RtType>::Abi) -> HRESULT,
    fn CreateWithDisplayItems(&self, total: <PaymentItem as RtType>::Abi, displayItems: <foundation::collections::IIterable<PaymentItem> as RtType>::Abi, out: *mut <PaymentDetails as RtType>::Abi) -> HRESULT
}}
impl IPaymentDetailsFactory {
    #[inline] pub fn create(&self, total: &PaymentItem) -> Result<PaymentDetails> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, total.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentDetails::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_display_items(&self, total: &PaymentItem, displayItems: &foundation::collections::IIterable<PaymentItem>) -> Result<PaymentDetails> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWithDisplayItems)(self.get_abi() as *const _ as *mut _, total.get_abi() as *const _ as *mut _, displayItems.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentDetails::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPaymentDetailsModifier, 3189538149, 17187, 16855, 179, 5, 223, 203, 118, 95, 105, 222);
RT_INTERFACE!{interface IPaymentDetailsModifier(IPaymentDetailsModifierVtbl): IInspectable [IID_IPaymentDetailsModifier] {
    fn get_JsonData(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SupportedMethodIds(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT,
    fn get_Total(&self, out: *mut <PaymentItem as RtType>::Abi) -> HRESULT,
    fn get_AdditionalDisplayItems(&self, out: *mut <foundation::collections::IVectorView<PaymentItem> as RtType>::Abi) -> HRESULT
}}
impl IPaymentDetailsModifier {
    #[inline] pub fn get_json_data(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_JsonData)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_method_ids(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SupportedMethodIds)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_total(&self) -> Result<Option<PaymentItem>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Total)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentItem::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_additional_display_items(&self) -> Result<Option<foundation::collections::IVectorView<PaymentItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AdditionalDisplayItems)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PaymentDetailsModifier: IPaymentDetailsModifier}
impl RtActivatable<IPaymentDetailsModifierFactory> for PaymentDetailsModifier {}
impl PaymentDetailsModifier {
    #[inline] pub fn create(supportedMethodIds: &foundation::collections::IIterable<HString>, total: &PaymentItem) -> Result<PaymentDetailsModifier> {
        <Self as RtActivatable<IPaymentDetailsModifierFactory>>::get_activation_factory().create(supportedMethodIds, total)
    }
    #[inline] pub fn create_with_additional_display_items(supportedMethodIds: &foundation::collections::IIterable<HString>, total: &PaymentItem, additionalDisplayItems: &foundation::collections::IIterable<PaymentItem>) -> Result<PaymentDetailsModifier> {
        <Self as RtActivatable<IPaymentDetailsModifierFactory>>::get_activation_factory().create_with_additional_display_items(supportedMethodIds, total, additionalDisplayItems)
    }
    #[inline] pub fn create_with_additional_display_items_and_json_data(supportedMethodIds: &foundation::collections::IIterable<HString>, total: &PaymentItem, additionalDisplayItems: &foundation::collections::IIterable<PaymentItem>, jsonData: &HStringArg) -> Result<PaymentDetailsModifier> {
        <Self as RtActivatable<IPaymentDetailsModifierFactory>>::get_activation_factory().create_with_additional_display_items_and_json_data(supportedMethodIds, total, additionalDisplayItems, jsonData)
    }
}
DEFINE_CLSID!(PaymentDetailsModifier(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,97,121,109,101,110,116,115,46,80,97,121,109,101,110,116,68,101,116,97,105,108,115,77,111,100,105,102,105,101,114,0]) [CLSID_PaymentDetailsModifier]);
DEFINE_IID!(IID_IPaymentDetailsModifierFactory, 2030064262, 21726, 17052, 158, 79, 93, 206, 110, 16, 235, 206);
RT_INTERFACE!{static interface IPaymentDetailsModifierFactory(IPaymentDetailsModifierFactoryVtbl): IInspectable [IID_IPaymentDetailsModifierFactory] {
    fn Create(&self, supportedMethodIds: <foundation::collections::IIterable<HString> as RtType>::Abi, total: <PaymentItem as RtType>::Abi, out: *mut <PaymentDetailsModifier as RtType>::Abi) -> HRESULT,
    fn CreateWithAdditionalDisplayItems(&self, supportedMethodIds: <foundation::collections::IIterable<HString> as RtType>::Abi, total: <PaymentItem as RtType>::Abi, additionalDisplayItems: <foundation::collections::IIterable<PaymentItem> as RtType>::Abi, out: *mut <PaymentDetailsModifier as RtType>::Abi) -> HRESULT,
    fn CreateWithAdditionalDisplayItemsAndJsonData(&self, supportedMethodIds: <foundation::collections::IIterable<HString> as RtType>::Abi, total: <PaymentItem as RtType>::Abi, additionalDisplayItems: <foundation::collections::IIterable<PaymentItem> as RtType>::Abi, jsonData: HSTRING, out: *mut <PaymentDetailsModifier as RtType>::Abi) -> HRESULT
}}
impl IPaymentDetailsModifierFactory {
    #[inline] pub fn create(&self, supportedMethodIds: &foundation::collections::IIterable<HString>, total: &PaymentItem) -> Result<PaymentDetailsModifier> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, supportedMethodIds.get_abi() as *const _ as *mut _, total.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentDetailsModifier::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_additional_display_items(&self, supportedMethodIds: &foundation::collections::IIterable<HString>, total: &PaymentItem, additionalDisplayItems: &foundation::collections::IIterable<PaymentItem>) -> Result<PaymentDetailsModifier> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWithAdditionalDisplayItems)(self.get_abi() as *const _ as *mut _, supportedMethodIds.get_abi() as *const _ as *mut _, total.get_abi() as *const _ as *mut _, additionalDisplayItems.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentDetailsModifier::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_additional_display_items_and_json_data(&self, supportedMethodIds: &foundation::collections::IIterable<HString>, total: &PaymentItem, additionalDisplayItems: &foundation::collections::IIterable<PaymentItem>, jsonData: &HStringArg) -> Result<PaymentDetailsModifier> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWithAdditionalDisplayItemsAndJsonData)(self.get_abi() as *const _ as *mut _, supportedMethodIds.get_abi() as *const _ as *mut _, total.get_abi() as *const _ as *mut _, additionalDisplayItems.get_abi() as *const _ as *mut _, jsonData.get(), &mut out);
        if hr == S_OK { Ok(PaymentDetailsModifier::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPaymentItem, 1750780043, 31154, 19318, 158, 3, 168, 118, 34, 61, 254, 114);
RT_INTERFACE!{interface IPaymentItem(IPaymentItemVtbl): IInspectable [IID_IPaymentItem] {
    fn get_Label(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Label(&self, value: HSTRING) -> HRESULT,
    fn get_Amount(&self, out: *mut <PaymentCurrencyAmount as RtType>::Abi) -> HRESULT,
    fn put_Amount(&self, value: <PaymentCurrencyAmount as RtType>::Abi) -> HRESULT,
    fn get_Pending(&self, out: *mut bool) -> HRESULT,
    fn put_Pending(&self, value: bool) -> HRESULT
}}
impl IPaymentItem {
    #[inline] pub fn get_label(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Label)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_label(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Label)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_amount(&self) -> Result<Option<PaymentCurrencyAmount>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Amount)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentCurrencyAmount::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_amount(&self, value: &PaymentCurrencyAmount) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Amount)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_pending(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Pending)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_pending(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Pending)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PaymentItem: IPaymentItem}
impl RtActivatable<IPaymentItemFactory> for PaymentItem {}
impl PaymentItem {
    #[inline] pub fn create(label: &HStringArg, amount: &PaymentCurrencyAmount) -> Result<PaymentItem> {
        <Self as RtActivatable<IPaymentItemFactory>>::get_activation_factory().create(label, amount)
    }
}
DEFINE_CLSID!(PaymentItem(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,97,121,109,101,110,116,115,46,80,97,121,109,101,110,116,73,116,101,109,0]) [CLSID_PaymentItem]);
DEFINE_IID!(IID_IPaymentItemFactory, 3333126872, 9475, 19741, 167, 120, 2, 178, 229, 146, 123, 44);
RT_INTERFACE!{static interface IPaymentItemFactory(IPaymentItemFactoryVtbl): IInspectable [IID_IPaymentItemFactory] {
    fn Create(&self, label: HSTRING, amount: <PaymentCurrencyAmount as RtType>::Abi, out: *mut <PaymentItem as RtType>::Abi) -> HRESULT
}}
impl IPaymentItemFactory {
    #[inline] pub fn create(&self, label: &HStringArg, amount: &PaymentCurrencyAmount) -> Result<PaymentItem> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, label.get(), amount.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentItem::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPaymentMediator, 4212058153, 60428, 17562, 131, 218, 122, 227, 7, 51, 101, 162);
RT_INTERFACE!{interface IPaymentMediator(IPaymentMediatorVtbl): IInspectable [IID_IPaymentMediator] {
    fn GetSupportedMethodIdsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<HString>> as RtType>::Abi) -> HRESULT,
    fn SubmitPaymentRequestAsync(&self, paymentRequest: <PaymentRequest as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PaymentRequestSubmitResult> as RtType>::Abi) -> HRESULT,
    fn SubmitPaymentRequestWithChangeHandlerAsync(&self, paymentRequest: <PaymentRequest as RtType>::Abi, changeHandler: <PaymentRequestChangedHandler as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PaymentRequestSubmitResult> as RtType>::Abi) -> HRESULT
}}
impl IPaymentMediator {
    #[inline] pub fn get_supported_method_ids_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetSupportedMethodIdsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn submit_payment_request_async(&self, paymentRequest: &PaymentRequest) -> Result<foundation::IAsyncOperation<PaymentRequestSubmitResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SubmitPaymentRequestAsync)(self.get_abi() as *const _ as *mut _, paymentRequest.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn submit_payment_request_with_change_handler_async(&self, paymentRequest: &PaymentRequest, changeHandler: &PaymentRequestChangedHandler) -> Result<foundation::IAsyncOperation<PaymentRequestSubmitResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SubmitPaymentRequestWithChangeHandlerAsync)(self.get_abi() as *const _ as *mut _, paymentRequest.get_abi() as *const _ as *mut _, changeHandler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PaymentMediator: IPaymentMediator}
impl RtActivatable<IActivationFactory> for PaymentMediator {}
DEFINE_CLSID!(PaymentMediator(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,97,121,109,101,110,116,115,46,80,97,121,109,101,110,116,77,101,100,105,97,116,111,114,0]) [CLSID_PaymentMediator]);
DEFINE_IID!(IID_IPaymentMediator2, 3471808753, 58375, 16680, 142, 115, 217, 61, 95, 130, 39, 134);
RT_INTERFACE!{interface IPaymentMediator2(IPaymentMediator2Vtbl): IInspectable [IID_IPaymentMediator2] {
    fn CanMakePaymentAsync(&self, paymentRequest: <PaymentRequest as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PaymentCanMakePaymentResult> as RtType>::Abi) -> HRESULT
}}
impl IPaymentMediator2 {
    #[inline] pub fn can_make_payment_async(&self, paymentRequest: &PaymentRequest) -> Result<foundation::IAsyncOperation<PaymentCanMakePaymentResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CanMakePaymentAsync)(self.get_abi() as *const _ as *mut _, paymentRequest.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPaymentMerchantInfo, 1665421392, 3732, 20182, 170, 203, 230, 1, 43, 211, 39, 167);
RT_INTERFACE!{interface IPaymentMerchantInfo(IPaymentMerchantInfoVtbl): IInspectable [IID_IPaymentMerchantInfo] {
    fn get_PackageFullName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Uri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT
}}
impl IPaymentMerchantInfo {
    #[inline] pub fn get_package_full_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PackageFullName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Uri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PaymentMerchantInfo: IPaymentMerchantInfo}
impl RtActivatable<IPaymentMerchantInfoFactory> for PaymentMerchantInfo {}
impl RtActivatable<IActivationFactory> for PaymentMerchantInfo {}
impl PaymentMerchantInfo {
    #[inline] pub fn create(uri: &foundation::Uri) -> Result<PaymentMerchantInfo> {
        <Self as RtActivatable<IPaymentMerchantInfoFactory>>::get_activation_factory().create(uri)
    }
}
DEFINE_CLSID!(PaymentMerchantInfo(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,97,121,109,101,110,116,115,46,80,97,121,109,101,110,116,77,101,114,99,104,97,110,116,73,110,102,111,0]) [CLSID_PaymentMerchantInfo]);
DEFINE_IID!(IID_IPaymentMerchantInfoFactory, 2659831507, 52407, 16743, 168, 236, 225, 10, 233, 109, 188, 209);
RT_INTERFACE!{static interface IPaymentMerchantInfoFactory(IPaymentMerchantInfoFactoryVtbl): IInspectable [IID_IPaymentMerchantInfoFactory] {
    fn Create(&self, uri: <foundation::Uri as RtType>::Abi, out: *mut <PaymentMerchantInfo as RtType>::Abi) -> HRESULT
}}
impl IPaymentMerchantInfoFactory {
    #[inline] pub fn create(&self, uri: &foundation::Uri) -> Result<PaymentMerchantInfo> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, uri.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentMerchantInfo::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPaymentMethodData, 3520318196, 56984, 16681, 177, 183, 195, 173, 134, 35, 123, 244);
RT_INTERFACE!{interface IPaymentMethodData(IPaymentMethodDataVtbl): IInspectable [IID_IPaymentMethodData] {
    fn get_SupportedMethodIds(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT,
    fn get_JsonData(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPaymentMethodData {
    #[inline] pub fn get_supported_method_ids(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SupportedMethodIds)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_json_data(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_JsonData)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PaymentMethodData: IPaymentMethodData}
impl RtActivatable<IPaymentMethodDataFactory> for PaymentMethodData {}
impl PaymentMethodData {
    #[inline] pub fn create(supportedMethodIds: &foundation::collections::IIterable<HString>) -> Result<PaymentMethodData> {
        <Self as RtActivatable<IPaymentMethodDataFactory>>::get_activation_factory().create(supportedMethodIds)
    }
    #[inline] pub fn create_with_json_data(supportedMethodIds: &foundation::collections::IIterable<HString>, jsonData: &HStringArg) -> Result<PaymentMethodData> {
        <Self as RtActivatable<IPaymentMethodDataFactory>>::get_activation_factory().create_with_json_data(supportedMethodIds, jsonData)
    }
}
DEFINE_CLSID!(PaymentMethodData(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,97,121,109,101,110,116,115,46,80,97,121,109,101,110,116,77,101,116,104,111,100,68,97,116,97,0]) [CLSID_PaymentMethodData]);
DEFINE_IID!(IID_IPaymentMethodDataFactory, 2329793151, 39850, 19074, 131, 66, 168, 33, 9, 146, 163, 107);
RT_INTERFACE!{static interface IPaymentMethodDataFactory(IPaymentMethodDataFactoryVtbl): IInspectable [IID_IPaymentMethodDataFactory] {
    fn Create(&self, supportedMethodIds: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <PaymentMethodData as RtType>::Abi) -> HRESULT,
    fn CreateWithJsonData(&self, supportedMethodIds: <foundation::collections::IIterable<HString> as RtType>::Abi, jsonData: HSTRING, out: *mut <PaymentMethodData as RtType>::Abi) -> HRESULT
}}
impl IPaymentMethodDataFactory {
    #[inline] pub fn create(&self, supportedMethodIds: &foundation::collections::IIterable<HString>) -> Result<PaymentMethodData> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, supportedMethodIds.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentMethodData::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_json_data(&self, supportedMethodIds: &foundation::collections::IIterable<HString>, jsonData: &HStringArg) -> Result<PaymentMethodData> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWithJsonData)(self.get_abi() as *const _ as *mut _, supportedMethodIds.get_abi() as *const _ as *mut _, jsonData.get(), &mut out);
        if hr == S_OK { Ok(PaymentMethodData::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum PaymentOptionPresence: i32 {
    None = 0, Optional = 1, Required = 2,
}}
DEFINE_IID!(IID_IPaymentOptions, 2862811220, 7979, 17253, 130, 81, 1, 181, 137, 21, 165, 188);
RT_INTERFACE!{interface IPaymentOptions(IPaymentOptionsVtbl): IInspectable [IID_IPaymentOptions] {
    fn get_RequestPayerEmail(&self, out: *mut PaymentOptionPresence) -> HRESULT,
    fn put_RequestPayerEmail(&self, value: PaymentOptionPresence) -> HRESULT,
    fn get_RequestPayerName(&self, out: *mut PaymentOptionPresence) -> HRESULT,
    fn put_RequestPayerName(&self, value: PaymentOptionPresence) -> HRESULT,
    fn get_RequestPayerPhoneNumber(&self, out: *mut PaymentOptionPresence) -> HRESULT,
    fn put_RequestPayerPhoneNumber(&self, value: PaymentOptionPresence) -> HRESULT,
    fn get_RequestShipping(&self, out: *mut bool) -> HRESULT,
    fn put_RequestShipping(&self, value: bool) -> HRESULT,
    fn get_ShippingType(&self, out: *mut PaymentShippingType) -> HRESULT,
    fn put_ShippingType(&self, value: PaymentShippingType) -> HRESULT
}}
impl IPaymentOptions {
    #[inline] pub fn get_request_payer_email(&self) -> Result<PaymentOptionPresence> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_RequestPayerEmail)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_request_payer_email(&self, value: PaymentOptionPresence) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RequestPayerEmail)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_request_payer_name(&self) -> Result<PaymentOptionPresence> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_RequestPayerName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_request_payer_name(&self, value: PaymentOptionPresence) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RequestPayerName)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_request_payer_phone_number(&self) -> Result<PaymentOptionPresence> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_RequestPayerPhoneNumber)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_request_payer_phone_number(&self, value: PaymentOptionPresence) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RequestPayerPhoneNumber)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_request_shipping(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_RequestShipping)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_request_shipping(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RequestShipping)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_shipping_type(&self) -> Result<PaymentShippingType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ShippingType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_shipping_type(&self, value: PaymentShippingType) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ShippingType)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PaymentOptions: IPaymentOptions}
impl RtActivatable<IActivationFactory> for PaymentOptions {}
DEFINE_CLSID!(PaymentOptions(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,97,121,109,101,110,116,115,46,80,97,121,109,101,110,116,79,112,116,105,111,110,115,0]) [CLSID_PaymentOptions]);
DEFINE_IID!(IID_IPaymentRequest, 3075031777, 60795, 18411, 188, 8, 120, 204, 93, 104, 150, 182);
RT_INTERFACE!{interface IPaymentRequest(IPaymentRequestVtbl): IInspectable [IID_IPaymentRequest] {
    fn get_MerchantInfo(&self, out: *mut <PaymentMerchantInfo as RtType>::Abi) -> HRESULT,
    fn get_Details(&self, out: *mut <PaymentDetails as RtType>::Abi) -> HRESULT,
    fn get_MethodData(&self, out: *mut <foundation::collections::IVectorView<PaymentMethodData> as RtType>::Abi) -> HRESULT,
    fn get_Options(&self, out: *mut <PaymentOptions as RtType>::Abi) -> HRESULT
}}
impl IPaymentRequest {
    #[inline] pub fn get_merchant_info(&self) -> Result<Option<PaymentMerchantInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MerchantInfo)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentMerchantInfo::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_details(&self) -> Result<Option<PaymentDetails>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Details)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentDetails::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_method_data(&self) -> Result<Option<foundation::collections::IVectorView<PaymentMethodData>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MethodData)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_options(&self) -> Result<Option<PaymentOptions>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Options)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentOptions::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PaymentRequest: IPaymentRequest}
impl RtActivatable<IPaymentRequestFactory> for PaymentRequest {}
impl RtActivatable<IPaymentRequestFactory2> for PaymentRequest {}
impl PaymentRequest {
    #[inline] pub fn create(details: &PaymentDetails, methodData: &foundation::collections::IIterable<PaymentMethodData>) -> Result<PaymentRequest> {
        <Self as RtActivatable<IPaymentRequestFactory>>::get_activation_factory().create(details, methodData)
    }
    #[inline] pub fn create_with_merchant_info(details: &PaymentDetails, methodData: &foundation::collections::IIterable<PaymentMethodData>, merchantInfo: &PaymentMerchantInfo) -> Result<PaymentRequest> {
        <Self as RtActivatable<IPaymentRequestFactory>>::get_activation_factory().create_with_merchant_info(details, methodData, merchantInfo)
    }
    #[inline] pub fn create_with_merchant_info_and_options(details: &PaymentDetails, methodData: &foundation::collections::IIterable<PaymentMethodData>, merchantInfo: &PaymentMerchantInfo, options: &PaymentOptions) -> Result<PaymentRequest> {
        <Self as RtActivatable<IPaymentRequestFactory>>::get_activation_factory().create_with_merchant_info_and_options(details, methodData, merchantInfo, options)
    }
    #[inline] pub fn create_with_merchant_info_options_and_id(details: &PaymentDetails, methodData: &foundation::collections::IIterable<PaymentMethodData>, merchantInfo: &PaymentMerchantInfo, options: &PaymentOptions, id: &HStringArg) -> Result<PaymentRequest> {
        <Self as RtActivatable<IPaymentRequestFactory2>>::get_activation_factory().create_with_merchant_info_options_and_id(details, methodData, merchantInfo, options, id)
    }
}
DEFINE_CLSID!(PaymentRequest(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,97,121,109,101,110,116,115,46,80,97,121,109,101,110,116,82,101,113,117,101,115,116,0]) [CLSID_PaymentRequest]);
DEFINE_IID!(IID_IPaymentRequest2, 3057438645, 22936, 18750, 160, 76, 103, 4, 138, 80, 241, 65);
RT_INTERFACE!{interface IPaymentRequest2(IPaymentRequest2Vtbl): IInspectable [IID_IPaymentRequest2] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPaymentRequest2 {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPaymentRequestChangedArgs, 3323223620, 52619, 19428, 181, 85, 39, 201, 145, 148, 192, 197);
RT_INTERFACE!{interface IPaymentRequestChangedArgs(IPaymentRequestChangedArgsVtbl): IInspectable [IID_IPaymentRequestChangedArgs] {
    fn get_ChangeKind(&self, out: *mut PaymentRequestChangeKind) -> HRESULT,
    fn get_ShippingAddress(&self, out: *mut <PaymentAddress as RtType>::Abi) -> HRESULT,
    fn get_SelectedShippingOption(&self, out: *mut <PaymentShippingOption as RtType>::Abi) -> HRESULT,
    fn Acknowledge(&self, changeResult: <PaymentRequestChangedResult as RtType>::Abi) -> HRESULT
}}
impl IPaymentRequestChangedArgs {
    #[inline] pub fn get_change_kind(&self) -> Result<PaymentRequestChangeKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ChangeKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_shipping_address(&self) -> Result<Option<PaymentAddress>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ShippingAddress)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentAddress::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_selected_shipping_option(&self) -> Result<Option<PaymentShippingOption>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SelectedShippingOption)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentShippingOption::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn acknowledge(&self, changeResult: &PaymentRequestChangedResult) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Acknowledge)(self.get_abi() as *const _ as *mut _, changeResult.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PaymentRequestChangedArgs: IPaymentRequestChangedArgs}
DEFINE_IID!(IID_PaymentRequestChangedHandler, 1350089185, 62360, 20268, 162, 126, 148, 211, 113, 207, 108, 125);
RT_DELEGATE!{delegate PaymentRequestChangedHandler(PaymentRequestChangedHandlerVtbl, PaymentRequestChangedHandlerImpl) [IID_PaymentRequestChangedHandler] {
    fn Invoke(&self, paymentRequest: <PaymentRequest as RtType>::Abi, args: <PaymentRequestChangedArgs as RtType>::Abi) -> HRESULT
}}
impl PaymentRequestChangedHandler {
    #[inline] pub fn invoke(&self, paymentRequest: &PaymentRequest, args: &PaymentRequestChangedArgs) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Invoke)(self.get_abi() as *const _ as *mut _, paymentRequest.get_abi() as *const _ as *mut _, args.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPaymentRequestChangedResult, 3748240988, 5828, 18349, 148, 1, 132, 64, 236, 7, 87, 219);
RT_INTERFACE!{interface IPaymentRequestChangedResult(IPaymentRequestChangedResultVtbl): IInspectable [IID_IPaymentRequestChangedResult] {
    fn get_ChangeAcceptedByMerchant(&self, out: *mut bool) -> HRESULT,
    fn put_ChangeAcceptedByMerchant(&self, value: bool) -> HRESULT,
    fn get_Message(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Message(&self, value: HSTRING) -> HRESULT,
    fn get_UpdatedPaymentDetails(&self, out: *mut <PaymentDetails as RtType>::Abi) -> HRESULT,
    fn put_UpdatedPaymentDetails(&self, value: <PaymentDetails as RtType>::Abi) -> HRESULT
}}
impl IPaymentRequestChangedResult {
    #[inline] pub fn get_change_accepted_by_merchant(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ChangeAcceptedByMerchant)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_change_accepted_by_merchant(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ChangeAcceptedByMerchant)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_message(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Message)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_message(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Message)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_updated_payment_details(&self) -> Result<Option<PaymentDetails>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_UpdatedPaymentDetails)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentDetails::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_updated_payment_details(&self, value: &PaymentDetails) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_UpdatedPaymentDetails)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PaymentRequestChangedResult: IPaymentRequestChangedResult}
impl RtActivatable<IPaymentRequestChangedResultFactory> for PaymentRequestChangedResult {}
impl PaymentRequestChangedResult {
    #[inline] pub fn create(changeAcceptedByMerchant: bool) -> Result<PaymentRequestChangedResult> {
        <Self as RtActivatable<IPaymentRequestChangedResultFactory>>::get_activation_factory().create(changeAcceptedByMerchant)
    }
    #[inline] pub fn create_with_payment_details(changeAcceptedByMerchant: bool, updatedPaymentDetails: &PaymentDetails) -> Result<PaymentRequestChangedResult> {
        <Self as RtActivatable<IPaymentRequestChangedResultFactory>>::get_activation_factory().create_with_payment_details(changeAcceptedByMerchant, updatedPaymentDetails)
    }
}
DEFINE_CLSID!(PaymentRequestChangedResult(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,97,121,109,101,110,116,115,46,80,97,121,109,101,110,116,82,101,113,117,101,115,116,67,104,97,110,103,101,100,82,101,115,117,108,116,0]) [CLSID_PaymentRequestChangedResult]);
DEFINE_IID!(IID_IPaymentRequestChangedResultFactory, 141823830, 7475, 17457, 129, 75, 103, 234, 36, 191, 33, 219);
RT_INTERFACE!{static interface IPaymentRequestChangedResultFactory(IPaymentRequestChangedResultFactoryVtbl): IInspectable [IID_IPaymentRequestChangedResultFactory] {
    fn Create(&self, changeAcceptedByMerchant: bool, out: *mut <PaymentRequestChangedResult as RtType>::Abi) -> HRESULT,
    fn CreateWithPaymentDetails(&self, changeAcceptedByMerchant: bool, updatedPaymentDetails: <PaymentDetails as RtType>::Abi, out: *mut <PaymentRequestChangedResult as RtType>::Abi) -> HRESULT
}}
impl IPaymentRequestChangedResultFactory {
    #[inline] pub fn create(&self, changeAcceptedByMerchant: bool) -> Result<PaymentRequestChangedResult> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, changeAcceptedByMerchant, &mut out);
        if hr == S_OK { Ok(PaymentRequestChangedResult::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_payment_details(&self, changeAcceptedByMerchant: bool, updatedPaymentDetails: &PaymentDetails) -> Result<PaymentRequestChangedResult> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWithPaymentDetails)(self.get_abi() as *const _ as *mut _, changeAcceptedByMerchant, updatedPaymentDetails.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentRequestChangedResult::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum PaymentRequestChangeKind: i32 {
    ShippingOption = 0, ShippingAddress = 1,
}}
RT_ENUM! { enum PaymentRequestCompletionStatus: i32 {
    Succeeded = 0, Failed = 1, Unknown = 2,
}}
DEFINE_IID!(IID_IPaymentRequestFactory, 1049262556, 27508, 17107, 177, 3, 240, 222, 53, 251, 24, 72);
RT_INTERFACE!{static interface IPaymentRequestFactory(IPaymentRequestFactoryVtbl): IInspectable [IID_IPaymentRequestFactory] {
    fn Create(&self, details: <PaymentDetails as RtType>::Abi, methodData: <foundation::collections::IIterable<PaymentMethodData> as RtType>::Abi, out: *mut <PaymentRequest as RtType>::Abi) -> HRESULT,
    fn CreateWithMerchantInfo(&self, details: <PaymentDetails as RtType>::Abi, methodData: <foundation::collections::IIterable<PaymentMethodData> as RtType>::Abi, merchantInfo: <PaymentMerchantInfo as RtType>::Abi, out: *mut <PaymentRequest as RtType>::Abi) -> HRESULT,
    fn CreateWithMerchantInfoAndOptions(&self, details: <PaymentDetails as RtType>::Abi, methodData: <foundation::collections::IIterable<PaymentMethodData> as RtType>::Abi, merchantInfo: <PaymentMerchantInfo as RtType>::Abi, options: <PaymentOptions as RtType>::Abi, out: *mut <PaymentRequest as RtType>::Abi) -> HRESULT
}}
impl IPaymentRequestFactory {
    #[inline] pub fn create(&self, details: &PaymentDetails, methodData: &foundation::collections::IIterable<PaymentMethodData>) -> Result<PaymentRequest> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, details.get_abi() as *const _ as *mut _, methodData.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentRequest::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_merchant_info(&self, details: &PaymentDetails, methodData: &foundation::collections::IIterable<PaymentMethodData>, merchantInfo: &PaymentMerchantInfo) -> Result<PaymentRequest> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWithMerchantInfo)(self.get_abi() as *const _ as *mut _, details.get_abi() as *const _ as *mut _, methodData.get_abi() as *const _ as *mut _, merchantInfo.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentRequest::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_merchant_info_and_options(&self, details: &PaymentDetails, methodData: &foundation::collections::IIterable<PaymentMethodData>, merchantInfo: &PaymentMerchantInfo, options: &PaymentOptions) -> Result<PaymentRequest> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWithMerchantInfoAndOptions)(self.get_abi() as *const _ as *mut _, details.get_abi() as *const _ as *mut _, methodData.get_abi() as *const _ as *mut _, merchantInfo.get_abi() as *const _ as *mut _, options.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentRequest::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPaymentRequestFactory2, 3872264997, 42246, 17266, 183, 239, 26, 3, 29, 86, 98, 209);
RT_INTERFACE!{static interface IPaymentRequestFactory2(IPaymentRequestFactory2Vtbl): IInspectable [IID_IPaymentRequestFactory2] {
    fn CreateWithMerchantInfoOptionsAndId(&self, details: <PaymentDetails as RtType>::Abi, methodData: <foundation::collections::IIterable<PaymentMethodData> as RtType>::Abi, merchantInfo: <PaymentMerchantInfo as RtType>::Abi, options: <PaymentOptions as RtType>::Abi, id: HSTRING, out: *mut <PaymentRequest as RtType>::Abi) -> HRESULT
}}
impl IPaymentRequestFactory2 {
    #[inline] pub fn create_with_merchant_info_options_and_id(&self, details: &PaymentDetails, methodData: &foundation::collections::IIterable<PaymentMethodData>, merchantInfo: &PaymentMerchantInfo, options: &PaymentOptions, id: &HStringArg) -> Result<PaymentRequest> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWithMerchantInfoOptionsAndId)(self.get_abi() as *const _ as *mut _, details.get_abi() as *const _ as *mut _, methodData.get_abi() as *const _ as *mut _, merchantInfo.get_abi() as *const _ as *mut _, options.get_abi() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(PaymentRequest::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum PaymentRequestStatus: i32 {
    Succeeded = 0, Failed = 1, Canceled = 2,
}}
DEFINE_IID!(IID_IPaymentRequestSubmitResult, 2073835794, 12530, 20112, 178, 73, 140, 231, 215, 143, 254, 86);
RT_INTERFACE!{interface IPaymentRequestSubmitResult(IPaymentRequestSubmitResultVtbl): IInspectable [IID_IPaymentRequestSubmitResult] {
    fn get_Status(&self, out: *mut PaymentRequestStatus) -> HRESULT,
    fn get_Response(&self, out: *mut <PaymentResponse as RtType>::Abi) -> HRESULT
}}
impl IPaymentRequestSubmitResult {
    #[inline] pub fn get_status(&self) -> Result<PaymentRequestStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_response(&self) -> Result<Option<PaymentResponse>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Response)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentResponse::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PaymentRequestSubmitResult: IPaymentRequestSubmitResult}
DEFINE_IID!(IID_IPaymentResponse, 3778581591, 35794, 18568, 159, 168, 151, 152, 85, 69, 16, 142);
RT_INTERFACE!{interface IPaymentResponse(IPaymentResponseVtbl): IInspectable [IID_IPaymentResponse] {
    fn get_PaymentToken(&self, out: *mut <PaymentToken as RtType>::Abi) -> HRESULT,
    fn get_ShippingOption(&self, out: *mut <PaymentShippingOption as RtType>::Abi) -> HRESULT,
    fn get_ShippingAddress(&self, out: *mut <PaymentAddress as RtType>::Abi) -> HRESULT,
    fn get_PayerEmail(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PayerName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PayerPhoneNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn CompleteAsync(&self, status: PaymentRequestCompletionStatus, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IPaymentResponse {
    #[inline] pub fn get_payment_token(&self) -> Result<Option<PaymentToken>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PaymentToken)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentToken::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_shipping_option(&self) -> Result<Option<PaymentShippingOption>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ShippingOption)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentShippingOption::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_shipping_address(&self) -> Result<Option<PaymentAddress>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ShippingAddress)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentAddress::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_payer_email(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PayerEmail)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_payer_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PayerName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_payer_phone_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PayerPhoneNumber)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn complete_async(&self, status: PaymentRequestCompletionStatus) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CompleteAsync)(self.get_abi() as *const _ as *mut _, status, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PaymentResponse: IPaymentResponse}
DEFINE_IID!(IID_IPaymentShippingOption, 322382554, 38739, 17780, 137, 102, 147, 20, 90, 118, 199, 249);
RT_INTERFACE!{interface IPaymentShippingOption(IPaymentShippingOptionVtbl): IInspectable [IID_IPaymentShippingOption] {
    fn get_Label(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Label(&self, value: HSTRING) -> HRESULT,
    fn get_Amount(&self, out: *mut <PaymentCurrencyAmount as RtType>::Abi) -> HRESULT,
    fn put_Amount(&self, value: <PaymentCurrencyAmount as RtType>::Abi) -> HRESULT,
    fn get_Tag(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Tag(&self, value: HSTRING) -> HRESULT,
    fn get_IsSelected(&self, out: *mut bool) -> HRESULT,
    fn put_IsSelected(&self, value: bool) -> HRESULT
}}
impl IPaymentShippingOption {
    #[inline] pub fn get_label(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Label)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_label(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Label)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_amount(&self) -> Result<Option<PaymentCurrencyAmount>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Amount)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentCurrencyAmount::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_amount(&self, value: &PaymentCurrencyAmount) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Amount)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_tag(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Tag)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_tag(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Tag)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_selected(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsSelected)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_selected(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsSelected)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PaymentShippingOption: IPaymentShippingOption}
impl RtActivatable<IPaymentShippingOptionFactory> for PaymentShippingOption {}
impl PaymentShippingOption {
    #[inline] pub fn create(label: &HStringArg, amount: &PaymentCurrencyAmount) -> Result<PaymentShippingOption> {
        <Self as RtActivatable<IPaymentShippingOptionFactory>>::get_activation_factory().create(label, amount)
    }
    #[inline] pub fn create_with_selected(label: &HStringArg, amount: &PaymentCurrencyAmount, selected: bool) -> Result<PaymentShippingOption> {
        <Self as RtActivatable<IPaymentShippingOptionFactory>>::get_activation_factory().create_with_selected(label, amount, selected)
    }
    #[inline] pub fn create_with_selected_and_tag(label: &HStringArg, amount: &PaymentCurrencyAmount, selected: bool, tag: &HStringArg) -> Result<PaymentShippingOption> {
        <Self as RtActivatable<IPaymentShippingOptionFactory>>::get_activation_factory().create_with_selected_and_tag(label, amount, selected, tag)
    }
}
DEFINE_CLSID!(PaymentShippingOption(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,97,121,109,101,110,116,115,46,80,97,121,109,101,110,116,83,104,105,112,112,105,110,103,79,112,116,105,111,110,0]) [CLSID_PaymentShippingOption]);
DEFINE_IID!(IID_IPaymentShippingOptionFactory, 1575352599, 45783, 17515, 157, 115, 97, 35, 251, 202, 59, 198);
RT_INTERFACE!{static interface IPaymentShippingOptionFactory(IPaymentShippingOptionFactoryVtbl): IInspectable [IID_IPaymentShippingOptionFactory] {
    fn Create(&self, label: HSTRING, amount: <PaymentCurrencyAmount as RtType>::Abi, out: *mut <PaymentShippingOption as RtType>::Abi) -> HRESULT,
    fn CreateWithSelected(&self, label: HSTRING, amount: <PaymentCurrencyAmount as RtType>::Abi, selected: bool, out: *mut <PaymentShippingOption as RtType>::Abi) -> HRESULT,
    fn CreateWithSelectedAndTag(&self, label: HSTRING, amount: <PaymentCurrencyAmount as RtType>::Abi, selected: bool, tag: HSTRING, out: *mut <PaymentShippingOption as RtType>::Abi) -> HRESULT
}}
impl IPaymentShippingOptionFactory {
    #[inline] pub fn create(&self, label: &HStringArg, amount: &PaymentCurrencyAmount) -> Result<PaymentShippingOption> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, label.get(), amount.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentShippingOption::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_selected(&self, label: &HStringArg, amount: &PaymentCurrencyAmount, selected: bool) -> Result<PaymentShippingOption> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWithSelected)(self.get_abi() as *const _ as *mut _, label.get(), amount.get_abi() as *const _ as *mut _, selected, &mut out);
        if hr == S_OK { Ok(PaymentShippingOption::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_selected_and_tag(&self, label: &HStringArg, amount: &PaymentCurrencyAmount, selected: bool, tag: &HStringArg) -> Result<PaymentShippingOption> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWithSelectedAndTag)(self.get_abi() as *const _ as *mut _, label.get(), amount.get_abi() as *const _ as *mut _, selected, tag.get(), &mut out);
        if hr == S_OK { Ok(PaymentShippingOption::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum PaymentShippingType: i32 {
    Shipping = 0, Delivery = 1, Pickup = 2,
}}
DEFINE_IID!(IID_IPaymentToken, 3150626835, 52432, 16882, 178, 161, 10, 46, 75, 93, 206, 37);
RT_INTERFACE!{interface IPaymentToken(IPaymentTokenVtbl): IInspectable [IID_IPaymentToken] {
    fn get_PaymentMethodId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_JsonDetails(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPaymentToken {
    #[inline] pub fn get_payment_method_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PaymentMethodId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_json_details(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_JsonDetails)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PaymentToken: IPaymentToken}
impl RtActivatable<IPaymentTokenFactory> for PaymentToken {}
impl PaymentToken {
    #[inline] pub fn create(paymentMethodId: &HStringArg) -> Result<PaymentToken> {
        <Self as RtActivatable<IPaymentTokenFactory>>::get_activation_factory().create(paymentMethodId)
    }
    #[inline] pub fn create_with_json_details(paymentMethodId: &HStringArg, jsonDetails: &HStringArg) -> Result<PaymentToken> {
        <Self as RtActivatable<IPaymentTokenFactory>>::get_activation_factory().create_with_json_details(paymentMethodId, jsonDetails)
    }
}
DEFINE_CLSID!(PaymentToken(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,97,121,109,101,110,116,115,46,80,97,121,109,101,110,116,84,111,107,101,110,0]) [CLSID_PaymentToken]);
DEFINE_IID!(IID_IPaymentTokenFactory, 2559367082, 18259, 18692, 131, 115, 221, 123, 8, 185, 149, 193);
RT_INTERFACE!{static interface IPaymentTokenFactory(IPaymentTokenFactoryVtbl): IInspectable [IID_IPaymentTokenFactory] {
    fn Create(&self, paymentMethodId: HSTRING, out: *mut <PaymentToken as RtType>::Abi) -> HRESULT,
    fn CreateWithJsonDetails(&self, paymentMethodId: HSTRING, jsonDetails: HSTRING, out: *mut <PaymentToken as RtType>::Abi) -> HRESULT
}}
impl IPaymentTokenFactory {
    #[inline] pub fn create(&self, paymentMethodId: &HStringArg) -> Result<PaymentToken> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Create)(self.get_abi() as *const _ as *mut _, paymentMethodId.get(), &mut out);
        if hr == S_OK { Ok(PaymentToken::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_json_details(&self, paymentMethodId: &HStringArg, jsonDetails: &HStringArg) -> Result<PaymentToken> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWithJsonDetails)(self.get_abi() as *const _ as *mut _, paymentMethodId.get(), jsonDetails.get(), &mut out);
        if hr == S_OK { Ok(PaymentToken::wrap_nonnull(out)) } else { err(hr) }
    }}
}
pub mod provider { // Windows.ApplicationModel.Payments.Provider
use crate::prelude::*;
DEFINE_IID!(IID_IPaymentAppCanMakePaymentTriggerDetails, 216138224, 35731, 20150, 140, 70, 46, 74, 108, 106, 38, 246);
RT_INTERFACE!{interface IPaymentAppCanMakePaymentTriggerDetails(IPaymentAppCanMakePaymentTriggerDetailsVtbl): IInspectable [IID_IPaymentAppCanMakePaymentTriggerDetails] {
    fn get_Request(&self, out: *mut <super::PaymentRequest as RtType>::Abi) -> HRESULT,
    fn ReportCanMakePaymentResult(&self, value: <super::PaymentCanMakePaymentResult as RtType>::Abi) -> HRESULT
}}
impl IPaymentAppCanMakePaymentTriggerDetails {
    #[inline] pub fn get_request(&self) -> Result<Option<super::PaymentRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::PaymentRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_can_make_payment_result(&self, value: &super::PaymentCanMakePaymentResult) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportCanMakePaymentResult)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PaymentAppCanMakePaymentTriggerDetails: IPaymentAppCanMakePaymentTriggerDetails}
DEFINE_IID!(IID_IPaymentAppManager, 239577683, 34081, 18793, 169, 87, 223, 37, 56, 163, 169, 143);
RT_INTERFACE!{interface IPaymentAppManager(IPaymentAppManagerVtbl): IInspectable [IID_IPaymentAppManager] {
    fn RegisterAsync(&self, supportedPaymentMethodIds: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn UnregisterAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IPaymentAppManager {
    #[inline] pub fn register_async(&self, supportedPaymentMethodIds: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RegisterAsync)(self.get_abi() as *const _ as *mut _, supportedPaymentMethodIds.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn unregister_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().UnregisterAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PaymentAppManager: IPaymentAppManager}
impl RtActivatable<IPaymentAppManagerStatics> for PaymentAppManager {}
impl PaymentAppManager {
    #[inline] pub fn get_current() -> Result<Option<PaymentAppManager>> {
        <Self as RtActivatable<IPaymentAppManagerStatics>>::get_activation_factory().get_current()
    }
}
DEFINE_CLSID!(PaymentAppManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,97,121,109,101,110,116,115,46,80,114,111,118,105,100,101,114,46,80,97,121,109,101,110,116,65,112,112,77,97,110,97,103,101,114,0]) [CLSID_PaymentAppManager]);
DEFINE_IID!(IID_IPaymentAppManagerStatics, 2738990120, 64649, 17414, 180, 217, 52, 231, 254, 121, 223, 182);
RT_INTERFACE!{static interface IPaymentAppManagerStatics(IPaymentAppManagerStaticsVtbl): IInspectable [IID_IPaymentAppManagerStatics] {
    fn get_Current(&self, out: *mut <PaymentAppManager as RtType>::Abi) -> HRESULT
}}
impl IPaymentAppManagerStatics {
    #[inline] pub fn get_current(&self) -> Result<Option<PaymentAppManager>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Current)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PaymentAppManager::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPaymentTransaction, 1649941920, 9893, 20123, 166, 235, 102, 96, 108, 240, 1, 211);
RT_INTERFACE!{interface IPaymentTransaction(IPaymentTransactionVtbl): IInspectable [IID_IPaymentTransaction] {
    fn get_PaymentRequest(&self, out: *mut <super::PaymentRequest as RtType>::Abi) -> HRESULT,
    fn get_PayerEmail(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PayerEmail(&self, value: HSTRING) -> HRESULT,
    fn get_PayerName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PayerName(&self, value: HSTRING) -> HRESULT,
    fn get_PayerPhoneNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PayerPhoneNumber(&self, value: HSTRING) -> HRESULT,
    fn UpdateShippingAddressAsync(&self, shippingAddress: <super::PaymentAddress as RtType>::Abi, out: *mut <foundation::IAsyncOperation<super::PaymentRequestChangedResult> as RtType>::Abi) -> HRESULT,
    fn UpdateSelectedShippingOptionAsync(&self, selectedShippingOption: <super::PaymentShippingOption as RtType>::Abi, out: *mut <foundation::IAsyncOperation<super::PaymentRequestChangedResult> as RtType>::Abi) -> HRESULT,
    fn AcceptAsync(&self, paymentToken: <super::PaymentToken as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PaymentTransactionAcceptResult> as RtType>::Abi) -> HRESULT,
    fn Reject(&self) -> HRESULT
}}
impl IPaymentTransaction {
    #[inline] pub fn get_payment_request(&self) -> Result<Option<super::PaymentRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PaymentRequest)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::PaymentRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_payer_email(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PayerEmail)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_payer_email(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_PayerEmail)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_payer_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PayerName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_payer_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_PayerName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_payer_phone_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PayerPhoneNumber)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_payer_phone_number(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_PayerPhoneNumber)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn update_shipping_address_async(&self, shippingAddress: &super::PaymentAddress) -> Result<foundation::IAsyncOperation<super::PaymentRequestChangedResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().UpdateShippingAddressAsync)(self.get_abi() as *const _ as *mut _, shippingAddress.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn update_selected_shipping_option_async(&self, selectedShippingOption: &super::PaymentShippingOption) -> Result<foundation::IAsyncOperation<super::PaymentRequestChangedResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().UpdateSelectedShippingOptionAsync)(self.get_abi() as *const _ as *mut _, selectedShippingOption.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn accept_async(&self, paymentToken: &super::PaymentToken) -> Result<foundation::IAsyncOperation<PaymentTransactionAcceptResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().AcceptAsync)(self.get_abi() as *const _ as *mut _, paymentToken.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn reject(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Reject)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PaymentTransaction: IPaymentTransaction}
impl RtActivatable<IPaymentTransactionStatics> for PaymentTransaction {}
impl PaymentTransaction {
    #[inline] pub fn from_id_async(id: &HStringArg) -> Result<foundation::IAsyncOperation<PaymentTransaction>> {
        <Self as RtActivatable<IPaymentTransactionStatics>>::get_activation_factory().from_id_async(id)
    }
}
DEFINE_CLSID!(PaymentTransaction(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,97,121,109,101,110,116,115,46,80,114,111,118,105,100,101,114,46,80,97,121,109,101,110,116,84,114,97,110,115,97,99,116,105,111,110,0]) [CLSID_PaymentTransaction]);
DEFINE_IID!(IID_IPaymentTransactionAcceptResult, 101593718, 54028, 18455, 149, 162, 223, 122, 233, 39, 59, 86);
RT_INTERFACE!{interface IPaymentTransactionAcceptResult(IPaymentTransactionAcceptResultVtbl): IInspectable [IID_IPaymentTransactionAcceptResult] {
    fn get_Status(&self, out: *mut super::PaymentRequestCompletionStatus) -> HRESULT
}}
impl IPaymentTransactionAcceptResult {
    #[inline] pub fn get_status(&self) -> Result<super::PaymentRequestCompletionStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PaymentTransactionAcceptResult: IPaymentTransactionAcceptResult}
DEFINE_IID!(IID_IPaymentTransactionStatics, 2372114256, 60938, 19957, 155, 30, 28, 15, 158, 197, 152, 129);
RT_INTERFACE!{static interface IPaymentTransactionStatics(IPaymentTransactionStaticsVtbl): IInspectable [IID_IPaymentTransactionStatics] {
    fn FromIdAsync(&self, id: HSTRING, out: *mut <foundation::IAsyncOperation<PaymentTransaction> as RtType>::Abi) -> HRESULT
}}
impl IPaymentTransactionStatics {
    #[inline] pub fn from_id_async(&self, id: &HStringArg) -> Result<foundation::IAsyncOperation<PaymentTransaction>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FromIdAsync)(self.get_abi() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
} // Windows.ApplicationModel.Payments.Provider
} // Windows.ApplicationModel.Payments
pub mod preview { // Windows.ApplicationModel.Preview
pub mod holographic { // Windows.ApplicationModel.Preview.Holographic
use crate::prelude::*;
RT_CLASS!{static class HolographicApplicationPreview}
impl RtActivatable<IHolographicApplicationPreviewStatics> for HolographicApplicationPreview {}
impl HolographicApplicationPreview {
    #[inline] pub fn is_current_view_presented_on_holographic_display() -> Result<bool> {
        <Self as RtActivatable<IHolographicApplicationPreviewStatics>>::get_activation_factory().is_current_view_presented_on_holographic_display()
    }
    #[inline] pub fn is_holographic_activation(activatedEventArgs: &super::super::activation::IActivatedEventArgs) -> Result<bool> {
        <Self as RtActivatable<IHolographicApplicationPreviewStatics>>::get_activation_factory().is_holographic_activation(activatedEventArgs)
    }
}
DEFINE_CLSID!(HolographicApplicationPreview(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,114,101,118,105,101,119,46,72,111,108,111,103,114,97,112,104,105,99,46,72,111,108,111,103,114,97,112,104,105,99,65,112,112,108,105,99,97,116,105,111,110,80,114,101,118,105,101,119,0]) [CLSID_HolographicApplicationPreview]);
DEFINE_IID!(IID_IHolographicApplicationPreviewStatics, 4261643921, 10810, 17833, 162, 8, 123, 237, 105, 25, 25, 243);
RT_INTERFACE!{static interface IHolographicApplicationPreviewStatics(IHolographicApplicationPreviewStaticsVtbl): IInspectable [IID_IHolographicApplicationPreviewStatics] {
    fn IsCurrentViewPresentedOnHolographicDisplay(&self, out: *mut bool) -> HRESULT,
    fn IsHolographicActivation(&self, activatedEventArgs: <super::super::activation::IActivatedEventArgs as RtType>::Abi, out: *mut bool) -> HRESULT
}}
impl IHolographicApplicationPreviewStatics {
    #[inline] pub fn is_current_view_presented_on_holographic_display(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().IsCurrentViewPresentedOnHolographicDisplay)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_holographic_activation(&self, activatedEventArgs: &super::super::activation::IActivatedEventArgs) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().IsHolographicActivation)(self.get_abi() as *const _ as *mut _, activatedEventArgs.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
} // Windows.ApplicationModel.Preview.Holographic
pub mod inkworkspace { // Windows.ApplicationModel.Preview.InkWorkspace
use crate::prelude::*;
DEFINE_IID!(IID_IInkWorkspaceHostedAppManager, 4262099344, 24153, 19383, 138, 99, 125, 33, 140, 217, 99, 0);
RT_INTERFACE!{interface IInkWorkspaceHostedAppManager(IInkWorkspaceHostedAppManagerVtbl): IInspectable [IID_IInkWorkspaceHostedAppManager] {
    #[cfg(feature="windows-graphics")] fn SetThumbnailAsync(&self, bitmap: <crate::windows::graphics::imaging::SoftwareBitmap as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IInkWorkspaceHostedAppManager {
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_thumbnail_async(&self, bitmap: &crate::windows::graphics::imaging::SoftwareBitmap) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SetThumbnailAsync)(self.get_abi() as *const _ as *mut _, bitmap.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InkWorkspaceHostedAppManager: IInkWorkspaceHostedAppManager}
impl RtActivatable<IInkWorkspaceHostedAppManagerStatics> for InkWorkspaceHostedAppManager {}
impl InkWorkspaceHostedAppManager {
    #[inline] pub fn get_for_current_app() -> Result<Option<InkWorkspaceHostedAppManager>> {
        <Self as RtActivatable<IInkWorkspaceHostedAppManagerStatics>>::get_activation_factory().get_for_current_app()
    }
}
DEFINE_CLSID!(InkWorkspaceHostedAppManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,114,101,118,105,101,119,46,73,110,107,87,111,114,107,115,112,97,99,101,46,73,110,107,87,111,114,107,115,112,97,99,101,72,111,115,116,101,100,65,112,112,77,97,110,97,103,101,114,0]) [CLSID_InkWorkspaceHostedAppManager]);
DEFINE_IID!(IID_IInkWorkspaceHostedAppManagerStatics, 3422391493, 41314, 19396, 132, 238, 232, 113, 109, 82, 51, 197);
RT_INTERFACE!{static interface IInkWorkspaceHostedAppManagerStatics(IInkWorkspaceHostedAppManagerStaticsVtbl): IInspectable [IID_IInkWorkspaceHostedAppManagerStatics] {
    fn GetForCurrentApp(&self, out: *mut <InkWorkspaceHostedAppManager as RtType>::Abi) -> HRESULT
}}
impl IInkWorkspaceHostedAppManagerStatics {
    #[inline] pub fn get_for_current_app(&self) -> Result<Option<InkWorkspaceHostedAppManager>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetForCurrentApp)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(InkWorkspaceHostedAppManager::wrap(out)) } else { err(hr) }
    }}
}
} // Windows.ApplicationModel.Preview.InkWorkspace
pub mod notes { // Windows.ApplicationModel.Preview.Notes
use crate::prelude::*;
DEFINE_IID!(IID_INotePlacementChangedPreviewEventArgs, 1226659767, 63360, 20095, 169, 57, 154, 76, 175, 150, 82, 20);
RT_INTERFACE!{interface INotePlacementChangedPreviewEventArgs(INotePlacementChangedPreviewEventArgsVtbl): IInspectable [IID_INotePlacementChangedPreviewEventArgs] {
    fn get_ViewId(&self, out: *mut i32) -> HRESULT
}}
impl INotePlacementChangedPreviewEventArgs {
    #[inline] pub fn get_view_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ViewId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class NotePlacementChangedPreviewEventArgs: INotePlacementChangedPreviewEventArgs}
DEFINE_IID!(IID_INotesWindowManagerPreview, 3693789758, 18512, 20243, 156, 199, 255, 72, 126, 253, 252, 222);
RT_INTERFACE!{interface INotesWindowManagerPreview(INotesWindowManagerPreviewVtbl): IInspectable [IID_INotesWindowManagerPreview] {
    fn get_IsScreenLocked(&self, out: *mut bool) -> HRESULT,
    fn ShowNote(&self, noteViewId: i32) -> HRESULT,
    fn ShowNoteRelativeTo(&self, noteViewId: i32, anchorNoteViewId: i32) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-storage")] fn ShowNoteWithPlacement(&self, noteViewId: i32, data: <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn HideNote(&self, noteViewId: i32) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn GetNotePlacement(&self, noteViewId: i32, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn TrySetNoteSize(&self, noteViewId: i32, size: foundation::Size, out: *mut bool) -> HRESULT,
    fn SetFocusToNextView(&self) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-storage")] fn SetNotesThumbnailAsync(&self, thumbnail: <crate::windows::storage::streams::IBuffer as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn add_SystemLockStateChanged(&self, handler: <foundation::TypedEventHandler<NotesWindowManagerPreview, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SystemLockStateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_NotePlacementChanged(&self, handler: <foundation::TypedEventHandler<NotesWindowManagerPreview, NotePlacementChangedPreviewEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NotePlacementChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_NoteVisibilityChanged(&self, handler: <foundation::TypedEventHandler<NotesWindowManagerPreview, NoteVisibilityChangedPreviewEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NoteVisibilityChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl INotesWindowManagerPreview {
    #[inline] pub fn get_is_screen_locked(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsScreenLocked)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn show_note(&self, noteViewId: i32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ShowNote)(self.get_abi() as *const _ as *mut _, noteViewId);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn show_note_relative_to(&self, noteViewId: i32, anchorNoteViewId: i32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ShowNoteRelativeTo)(self.get_abi() as *const _ as *mut _, noteViewId, anchorNoteViewId);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn show_note_with_placement(&self, noteViewId: i32, data: &crate::windows::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ShowNoteWithPlacement)(self.get_abi() as *const _ as *mut _, noteViewId, data.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn hide_note(&self, noteViewId: i32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().HideNote)(self.get_abi() as *const _ as *mut _, noteViewId);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_note_placement(&self, noteViewId: i32) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetNotePlacement)(self.get_abi() as *const _ as *mut _, noteViewId, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_set_note_size(&self, noteViewId: i32, size: foundation::Size) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().TrySetNoteSize)(self.get_abi() as *const _ as *mut _, noteViewId, size, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_focus_to_next_view(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetFocusToNextView)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_notes_thumbnail_async(&self, thumbnail: &crate::windows::storage::streams::IBuffer) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SetNotesThumbnailAsync)(self.get_abi() as *const _ as *mut _, thumbnail.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_system_lock_state_changed(&self, handler: &foundation::TypedEventHandler<NotesWindowManagerPreview, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_SystemLockStateChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_system_lock_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_SystemLockStateChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_note_placement_changed(&self, handler: &foundation::TypedEventHandler<NotesWindowManagerPreview, NotePlacementChangedPreviewEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_NotePlacementChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_note_placement_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_NotePlacementChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_note_visibility_changed(&self, handler: &foundation::TypedEventHandler<NotesWindowManagerPreview, NoteVisibilityChangedPreviewEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_NoteVisibilityChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_note_visibility_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_NoteVisibilityChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class NotesWindowManagerPreview: INotesWindowManagerPreview}
impl RtActivatable<INotesWindowManagerPreviewStatics> for NotesWindowManagerPreview {}
impl NotesWindowManagerPreview {
    #[inline] pub fn get_for_current_app() -> Result<Option<NotesWindowManagerPreview>> {
        <Self as RtActivatable<INotesWindowManagerPreviewStatics>>::get_activation_factory().get_for_current_app()
    }
}
DEFINE_CLSID!(NotesWindowManagerPreview(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,114,101,118,105,101,119,46,78,111,116,101,115,46,78,111,116,101,115,87,105,110,100,111,119,77,97,110,97,103,101,114,80,114,101,118,105,101,119,0]) [CLSID_NotesWindowManagerPreview]);
DEFINE_IID!(IID_INotesWindowManagerPreview2, 3992880714, 8020, 19209, 152, 35, 255, 71, 127, 111, 163, 188);
RT_INTERFACE!{interface INotesWindowManagerPreview2(INotesWindowManagerPreview2Vtbl): IInspectable [IID_INotesWindowManagerPreview2] {
    fn ShowNoteRelativeToWithOptions(&self, noteViewId: i32, anchorNoteViewId: i32, options: <NotesWindowManagerPreviewShowNoteOptions as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn ShowNoteWithPlacementWithOptions(&self, noteViewId: i32, data: <crate::windows::storage::streams::IBuffer as RtType>::Abi, options: <NotesWindowManagerPreviewShowNoteOptions as RtType>::Abi) -> HRESULT,
    fn SetFocusToPreviousView(&self) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn SetThumbnailImageForTaskSwitcherAsync(&self, bitmap: <crate::windows::graphics::imaging::SoftwareBitmap as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl INotesWindowManagerPreview2 {
    #[inline] pub fn show_note_relative_to_with_options(&self, noteViewId: i32, anchorNoteViewId: i32, options: &NotesWindowManagerPreviewShowNoteOptions) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ShowNoteRelativeToWithOptions)(self.get_abi() as *const _ as *mut _, noteViewId, anchorNoteViewId, options.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn show_note_with_placement_with_options(&self, noteViewId: i32, data: &crate::windows::storage::streams::IBuffer, options: &NotesWindowManagerPreviewShowNoteOptions) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ShowNoteWithPlacementWithOptions)(self.get_abi() as *const _ as *mut _, noteViewId, data.get_abi() as *const _ as *mut _, options.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_focus_to_previous_view(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetFocusToPreviousView)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_thumbnail_image_for_task_switcher_async(&self, bitmap: &crate::windows::graphics::imaging::SoftwareBitmap) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SetThumbnailImageForTaskSwitcherAsync)(self.get_abi() as *const _ as *mut _, bitmap.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_INotesWindowManagerPreviewShowNoteOptions, 2288716246, 42670, 16391, 165, 109, 28, 167, 12, 132, 192, 210);
RT_INTERFACE!{interface INotesWindowManagerPreviewShowNoteOptions(INotesWindowManagerPreviewShowNoteOptionsVtbl): IInspectable [IID_INotesWindowManagerPreviewShowNoteOptions] {
    fn get_ShowWithFocus(&self, out: *mut bool) -> HRESULT,
    fn put_ShowWithFocus(&self, value: bool) -> HRESULT
}}
impl INotesWindowManagerPreviewShowNoteOptions {
    #[inline] pub fn get_show_with_focus(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ShowWithFocus)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_show_with_focus(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ShowWithFocus)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class NotesWindowManagerPreviewShowNoteOptions: INotesWindowManagerPreviewShowNoteOptions}
impl RtActivatable<IActivationFactory> for NotesWindowManagerPreviewShowNoteOptions {}
DEFINE_CLSID!(NotesWindowManagerPreviewShowNoteOptions(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,80,114,101,118,105,101,119,46,78,111,116,101,115,46,78,111,116,101,115,87,105,110,100,111,119,77,97,110,97,103,101,114,80,114,101,118,105,101,119,83,104,111,119,78,111,116,101,79,112,116,105,111,110,115,0]) [CLSID_NotesWindowManagerPreviewShowNoteOptions]);
DEFINE_IID!(IID_INotesWindowManagerPreviewStatics, 1718144136, 2702, 16679, 163, 142, 153, 84, 69, 134, 138, 120);
RT_INTERFACE!{static interface INotesWindowManagerPreviewStatics(INotesWindowManagerPreviewStaticsVtbl): IInspectable [IID_INotesWindowManagerPreviewStatics] {
    fn GetForCurrentApp(&self, out: *mut <NotesWindowManagerPreview as RtType>::Abi) -> HRESULT
}}
impl INotesWindowManagerPreviewStatics {
    #[inline] pub fn get_for_current_app(&self) -> Result<Option<NotesWindowManagerPreview>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetForCurrentApp)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(NotesWindowManagerPreview::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_INoteVisibilityChangedPreviewEventArgs, 238314654, 14357, 20470, 131, 179, 161, 77, 23, 18, 14, 36);
RT_INTERFACE!{interface INoteVisibilityChangedPreviewEventArgs(INoteVisibilityChangedPreviewEventArgsVtbl): IInspectable [IID_INoteVisibilityChangedPreviewEventArgs] {
    fn get_ViewId(&self, out: *mut i32) -> HRESULT,
    fn get_IsVisible(&self, out: *mut bool) -> HRESULT
}}
impl INoteVisibilityChangedPreviewEventArgs {
    #[inline] pub fn get_view_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ViewId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_visible(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsVisible)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class NoteVisibilityChangedPreviewEventArgs: INoteVisibilityChangedPreviewEventArgs}
} // Windows.ApplicationModel.Preview.Notes
} // Windows.ApplicationModel.Preview
pub mod resources { // Windows.ApplicationModel.Resources
use crate::prelude::*;
DEFINE_IID!(IID_IResourceLoader, 139610376, 5871, 17837, 166, 2, 41, 54, 55, 215, 230, 26);
RT_INTERFACE!{interface IResourceLoader(IResourceLoaderVtbl): IInspectable [IID_IResourceLoader] {
    fn GetString(&self, resource: HSTRING, out: *mut HSTRING) -> HRESULT
}}
impl IResourceLoader {
    #[inline] pub fn get_string(&self, resource: &HStringArg) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetString)(self.get_abi() as *const _ as *mut _, resource.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ResourceLoader: IResourceLoader}
impl RtActivatable<IResourceLoaderFactory> for ResourceLoader {}
impl RtActivatable<IResourceLoaderStatics> for ResourceLoader {}
impl RtActivatable<IResourceLoaderStatics2> for ResourceLoader {}
impl RtActivatable<IActivationFactory> for ResourceLoader {}
impl ResourceLoader {
    #[inline] pub fn create_resource_loader_by_name(name: &HStringArg) -> Result<ResourceLoader> {
        <Self as RtActivatable<IResourceLoaderFactory>>::get_activation_factory().create_resource_loader_by_name(name)
    }
    #[inline] pub fn get_string_for_reference(uri: &foundation::Uri) -> Result<HString> {
        <Self as RtActivatable<IResourceLoaderStatics>>::get_activation_factory().get_string_for_reference(uri)
    }
    #[inline] pub fn get_for_current_view() -> Result<Option<ResourceLoader>> {
        <Self as RtActivatable<IResourceLoaderStatics2>>::get_activation_factory().get_for_current_view()
    }
    #[inline] pub fn get_for_current_view_with_name(name: &HStringArg) -> Result<Option<ResourceLoader>> {
        <Self as RtActivatable<IResourceLoaderStatics2>>::get_activation_factory().get_for_current_view_with_name(name)
    }
    #[inline] pub fn get_for_view_independent_use() -> Result<Option<ResourceLoader>> {
        <Self as RtActivatable<IResourceLoaderStatics2>>::get_activation_factory().get_for_view_independent_use()
    }
    #[inline] pub fn get_for_view_independent_use_with_name(name: &HStringArg) -> Result<Option<ResourceLoader>> {
        <Self as RtActivatable<IResourceLoaderStatics2>>::get_activation_factory().get_for_view_independent_use_with_name(name)
    }
}
DEFINE_CLSID!(ResourceLoader(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,82,101,115,111,117,114,99,101,115,46,82,101,115,111,117,114,99,101,76,111,97,100,101,114,0]) [CLSID_ResourceLoader]);
DEFINE_IID!(IID_IResourceLoader2, 283864774, 33080, 18625, 188, 101, 225, 241, 66, 7, 54, 124);
RT_INTERFACE!{interface IResourceLoader2(IResourceLoader2Vtbl): IInspectable [IID_IResourceLoader2] {
    fn GetStringForUri(&self, uri: <foundation::Uri as RtType>::Abi, out: *mut HSTRING) -> HRESULT
}}
impl IResourceLoader2 {
    #[inline] pub fn get_string_for_uri(&self, uri: &foundation::Uri) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetStringForUri)(self.get_abi() as *const _ as *mut _, uri.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IResourceLoaderFactory, 3275372035, 27100, 17029, 160, 119, 213, 192, 228, 124, 203, 232);
RT_INTERFACE!{static interface IResourceLoaderFactory(IResourceLoaderFactoryVtbl): IInspectable [IID_IResourceLoaderFactory] {
    fn CreateResourceLoaderByName(&self, name: HSTRING, out: *mut <ResourceLoader as RtType>::Abi) -> HRESULT
}}
impl IResourceLoaderFactory {
    #[inline] pub fn create_resource_loader_by_name(&self, name: &HStringArg) -> Result<ResourceLoader> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateResourceLoaderByName)(self.get_abi() as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(ResourceLoader::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IResourceLoaderStatics, 3212279009, 6600, 18882, 149, 60, 71, 233, 34, 123, 51, 78);
RT_INTERFACE!{static interface IResourceLoaderStatics(IResourceLoaderStaticsVtbl): IInspectable [IID_IResourceLoaderStatics] {
    fn GetStringForReference(&self, uri: <foundation::Uri as RtType>::Abi, out: *mut HSTRING) -> HRESULT
}}
impl IResourceLoaderStatics {
    #[inline] pub fn get_string_for_reference(&self, uri: &foundation::Uri) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetStringForReference)(self.get_abi() as *const _ as *mut _, uri.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IResourceLoaderStatics2, 213926209, 25702, 18825, 148, 148, 11, 130, 223, 197, 63, 31);
RT_INTERFACE!{static interface IResourceLoaderStatics2(IResourceLoaderStatics2Vtbl): IInspectable [IID_IResourceLoaderStatics2] {
    fn GetForCurrentView(&self, out: *mut <ResourceLoader as RtType>::Abi) -> HRESULT,
    fn GetForCurrentViewWithName(&self, name: HSTRING, out: *mut <ResourceLoader as RtType>::Abi) -> HRESULT,
    fn GetForViewIndependentUse(&self, out: *mut <ResourceLoader as RtType>::Abi) -> HRESULT,
    fn GetForViewIndependentUseWithName(&self, name: HSTRING, out: *mut <ResourceLoader as RtType>::Abi) -> HRESULT
}}
impl IResourceLoaderStatics2 {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<ResourceLoader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetForCurrentView)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ResourceLoader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_for_current_view_with_name(&self, name: &HStringArg) -> Result<Option<ResourceLoader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetForCurrentViewWithName)(self.get_abi() as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(ResourceLoader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_for_view_independent_use(&self) -> Result<Option<ResourceLoader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetForViewIndependentUse)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ResourceLoader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_for_view_independent_use_with_name(&self, name: &HStringArg) -> Result<Option<ResourceLoader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetForViewIndependentUseWithName)(self.get_abi() as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(ResourceLoader::wrap(out)) } else { err(hr) }
    }}
}
pub mod core { // Windows.ApplicationModel.Resources.Core
use crate::prelude::*;
DEFINE_IID!(IID_INamedResource, 479773209, 2835, 16960, 137, 165, 212, 149, 220, 24, 154, 0);
RT_INTERFACE!{interface INamedResource(INamedResourceVtbl): IInspectable [IID_INamedResource] {
    fn get_Uri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_Candidates(&self, out: *mut <foundation::collections::IVectorView<ResourceCandidate> as RtType>::Abi) -> HRESULT,
    fn Resolve(&self, out: *mut <ResourceCandidate as RtType>::Abi) -> HRESULT,
    fn ResolveForContext(&self, resourceContext: <ResourceContext as RtType>::Abi, out: *mut <ResourceCandidate as RtType>::Abi) -> HRESULT,
    fn ResolveAll(&self, out: *mut <foundation::collections::IVectorView<ResourceCandidate> as RtType>::Abi) -> HRESULT,
    fn ResolveAllForContext(&self, resourceContext: <ResourceContext as RtType>::Abi, out: *mut <foundation::collections::IVectorView<ResourceCandidate> as RtType>::Abi) -> HRESULT
}}
impl INamedResource {
    #[inline] pub fn get_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Uri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_candidates(&self) -> Result<Option<foundation::collections::IVectorView<ResourceCandidate>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Candidates)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn resolve(&self) -> Result<Option<ResourceCandidate>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Resolve)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ResourceCandidate::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn resolve_for_context(&self, resourceContext: &ResourceContext) -> Result<Option<ResourceCandidate>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ResolveForContext)(self.get_abi() as *const _ as *mut _, resourceContext.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ResourceCandidate::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn resolve_all(&self) -> Result<Option<foundation::collections::IVectorView<ResourceCandidate>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ResolveAll)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn resolve_all_for_context(&self, resourceContext: &ResourceContext) -> Result<Option<foundation::collections::IVectorView<ResourceCandidate>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ResolveAllForContext)(self.get_abi() as *const _ as *mut _, resourceContext.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class NamedResource: INamedResource}
DEFINE_IID!(IID_IResourceCandidate, 2941388761, 50227, 18276, 179, 253, 143, 166, 191, 188, 186, 220);
RT_INTERFACE!{interface IResourceCandidate(IResourceCandidateVtbl): IInspectable [IID_IResourceCandidate] {
    fn get_Qualifiers(&self, out: *mut <foundation::collections::IVectorView<ResourceQualifier> as RtType>::Abi) -> HRESULT,
    fn get_IsMatch(&self, out: *mut bool) -> HRESULT,
    fn get_IsMatchAsDefault(&self, out: *mut bool) -> HRESULT,
    fn get_IsDefault(&self, out: *mut bool) -> HRESULT,
    fn get_ValueAsString(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn GetValueAsFileAsync(&self, out: *mut <foundation::IAsyncOperation<crate::windows::storage::StorageFile> as RtType>::Abi) -> HRESULT,
    fn GetQualifierValue(&self, qualifierName: HSTRING, out: *mut HSTRING) -> HRESULT
}}
impl IResourceCandidate {
    #[inline] pub fn get_qualifiers(&self) -> Result<Option<foundation::collections::IVectorView<ResourceQualifier>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Qualifiers)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_match(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsMatch)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_match_as_default(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsMatchAsDefault)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_default(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsDefault)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_value_as_string(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ValueAsString)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_value_as_file_async(&self) -> Result<foundation::IAsyncOperation<crate::windows::storage::StorageFile>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetValueAsFileAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_qualifier_value(&self, qualifierName: &HStringArg) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetQualifierValue)(self.get_abi() as *const _ as *mut _, qualifierName.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ResourceCandidate: IResourceCandidate}
DEFINE_IID!(IID_IResourceCandidate2, 1776661608, 63228, 16403, 170, 162, 213, 63, 23, 87, 211, 181);
RT_INTERFACE!{interface IResourceCandidate2(IResourceCandidate2Vtbl): IInspectable [IID_IResourceCandidate2] {
    #[cfg(feature="windows-storage")] fn GetValueAsStreamAsync(&self, out: *mut <foundation::IAsyncOperation<crate::windows::storage::streams::IRandomAccessStream> as RtType>::Abi) -> HRESULT
}}
impl IResourceCandidate2 {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_value_as_stream_async(&self) -> Result<foundation::IAsyncOperation<crate::windows::storage::streams::IRandomAccessStream>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetValueAsStreamAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ResourceCandidateVectorView: foundation::collections::IVectorView<ResourceCandidate>}
DEFINE_IID!(IID_IResourceContext, 799158091, 28798, 19239, 173, 13, 208, 216, 205, 70, 143, 210);
RT_INTERFACE!{interface IResourceContext(IResourceContextVtbl): IInspectable [IID_IResourceContext] {
    fn get_QualifierValues(&self, out: *mut <foundation::collections::IObservableMap<HString, HString> as RtType>::Abi) -> HRESULT,
    fn Reset(&self) -> HRESULT,
    fn ResetQualifierValues(&self, qualifierNames: <foundation::collections::IIterable<HString> as RtType>::Abi) -> HRESULT,
    fn OverrideToMatch(&self, result: <foundation::collections::IIterable<ResourceQualifier> as RtType>::Abi) -> HRESULT,
    fn Clone(&self, out: *mut <ResourceContext as RtType>::Abi) -> HRESULT,
    fn get_Languages(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT,
    fn put_Languages(&self, languages: <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT
}}
impl IResourceContext {
    #[inline] pub fn get_qualifier_values(&self) -> Result<Option<foundation::collections::IObservableMap<HString, HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_QualifierValues)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IObservableMap::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn reset(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Reset)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn reset_qualifier_values(&self, qualifierNames: &foundation::collections::IIterable<HString>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ResetQualifierValues)(self.get_abi() as *const _ as *mut _, qualifierNames.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn override_to_match(&self, result: &foundation::collections::IIterable<ResourceQualifier>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().OverrideToMatch)(self.get_abi() as *const _ as *mut _, result.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn clone(&self) -> Result<Option<ResourceContext>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().Clone)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ResourceContext::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_languages(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Languages)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_languages(&self, languages: &foundation::collections::IVectorView<HString>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Languages)(self.get_abi() as *const _ as *mut _, languages.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ResourceContext: IResourceContext}
impl RtActivatable<IResourceContextStatics> for ResourceContext {}
impl RtActivatable<IResourceContextStatics2> for ResourceContext {}
impl RtActivatable<IResourceContextStatics3> for ResourceContext {}
impl RtActivatable<IActivationFactory> for ResourceContext {}
impl ResourceContext {
    #[inline] pub fn create_matching_context(result: &foundation::collections::IIterable<ResourceQualifier>) -> Result<Option<ResourceContext>> {
        <Self as RtActivatable<IResourceContextStatics>>::get_activation_factory().create_matching_context(result)
    }
    #[inline] pub fn get_for_current_view() -> Result<Option<ResourceContext>> {
        <Self as RtActivatable<IResourceContextStatics2>>::get_activation_factory().get_for_current_view()
    }
    #[inline] pub fn set_global_qualifier_value(key: &HStringArg, value: &HStringArg) -> Result<()> {
        <Self as RtActivatable<IResourceContextStatics2>>::get_activation_factory().set_global_qualifier_value(key, value)
    }
    #[inline] pub fn reset_global_qualifier_values() -> Result<()> {
        <Self as RtActivatable<IResourceContextStatics2>>::get_activation_factory().reset_global_qualifier_values()
    }
    #[inline] pub fn reset_global_qualifier_values_for_specified_qualifiers(qualifierNames: &foundation::collections::IIterable<HString>) -> Result<()> {
        <Self as RtActivatable<IResourceContextStatics2>>::get_activation_factory().reset_global_qualifier_values_for_specified_qualifiers(qualifierNames)
    }
    #[inline] pub fn get_for_view_independent_use() -> Result<Option<ResourceContext>> {
        <Self as RtActivatable<IResourceContextStatics2>>::get_activation_factory().get_for_view_independent_use()
    }
    #[inline] pub fn set_global_qualifier_value_with_persistence(key: &HStringArg, value: &HStringArg, persistence: ResourceQualifierPersistence) -> Result<()> {
        <Self as RtActivatable<IResourceContextStatics3>>::get_activation_factory().set_global_qualifier_value_with_persistence(key, value, persistence)
    }
}
DEFINE_CLSID!(ResourceContext(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,82,101,115,111,117,114,99,101,115,46,67,111,114,101,46,82,101,115,111,117,114,99,101,67,111,110,116,101,120,116,0]) [CLSID_ResourceContext]);
RT_CLASS!{class ResourceContextLanguagesVectorView: foundation::collections::IVectorView<HString>}
DEFINE_IID!(IID_IResourceContextStatics, 2562628972, 25400, 19249, 153, 223, 178, 180, 66, 241, 113, 73);
RT_INTERFACE!{static interface IResourceContextStatics(IResourceContextStaticsVtbl): IInspectable [IID_IResourceContextStatics] {
    fn CreateMatchingContext(&self, result: <foundation::collections::IIterable<ResourceQualifier> as RtType>::Abi, out: *mut <ResourceContext as RtType>::Abi) -> HRESULT
}}
impl IResourceContextStatics {
    #[inline] pub fn create_matching_context(&self, result: &foundation::collections::IIterable<ResourceQualifier>) -> Result<Option<ResourceContext>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateMatchingContext)(self.get_abi() as *const _ as *mut _, result.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ResourceContext::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IResourceContextStatics2, 1106727663, 4783, 16825, 171, 54, 177, 235, 75, 81, 36, 96);
RT_INTERFACE!{static interface IResourceContextStatics2(IResourceContextStatics2Vtbl): IInspectable [IID_IResourceContextStatics2] {
    fn GetForCurrentView(&self, out: *mut <ResourceContext as RtType>::Abi) -> HRESULT,
    fn SetGlobalQualifierValue(&self, key: HSTRING, value: HSTRING) -> HRESULT,
    fn ResetGlobalQualifierValues(&self) -> HRESULT,
    fn ResetGlobalQualifierValuesForSpecifiedQualifiers(&self, qualifierNames: <foundation::collections::IIterable<HString> as RtType>::Abi) -> HRESULT,
    fn GetForViewIndependentUse(&self, out: *mut <ResourceContext as RtType>::Abi) -> HRESULT
}}
impl IResourceContextStatics2 {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<ResourceContext>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetForCurrentView)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ResourceContext::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_global_qualifier_value(&self, key: &HStringArg, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetGlobalQualifierValue)(self.get_abi() as *const _ as *mut _, key.get(), value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn reset_global_qualifier_values(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ResetGlobalQualifierValues)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn reset_global_qualifier_values_for_specified_qualifiers(&self, qualifierNames: &foundation::collections::IIterable<HString>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ResetGlobalQualifierValuesForSpecifiedQualifiers)(self.get_abi() as *const _ as *mut _, qualifierNames.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_for_view_independent_use(&self) -> Result<Option<ResourceContext>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetForViewIndependentUse)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ResourceContext::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IResourceContextStatics3, 550455596, 44815, 17675, 157, 166, 16, 109, 208, 194, 154, 57);
RT_INTERFACE!{static interface IResourceContextStatics3(IResourceContextStatics3Vtbl): IInspectable [IID_IResourceContextStatics3] {
    fn SetGlobalQualifierValueWithPersistence(&self, key: HSTRING, value: HSTRING, persistence: ResourceQualifierPersistence) -> HRESULT
}}
impl IResourceContextStatics3 {
    #[inline] pub fn set_global_qualifier_value_with_persistence(&self, key: &HStringArg, value: &HStringArg, persistence: ResourceQualifierPersistence) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetGlobalQualifierValueWithPersistence)(self.get_abi() as *const _ as *mut _, key.get(), value.get(), persistence);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_STRUCT! { struct ResourceLayoutInfo {
    MajorVersion: u32, MinorVersion: u32, ResourceSubtreeCount: u32, NamedResourceCount: u32, Checksum: i32,
}}
DEFINE_IID!(IID_IResourceManager, 4148484475, 39304, 17659, 171, 214, 83, 120, 132, 76, 250, 139);
RT_INTERFACE!{interface IResourceManager(IResourceManagerVtbl): IInspectable [IID_IResourceManager] {
    fn get_MainResourceMap(&self, out: *mut <ResourceMap as RtType>::Abi) -> HRESULT,
    fn get_AllResourceMaps(&self, out: *mut <foundation::collections::IMapView<HString, ResourceMap> as RtType>::Abi) -> HRESULT,
    fn get_DefaultContext(&self, out: *mut <ResourceContext as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn LoadPriFiles(&self, files: <foundation::collections::IIterable<crate::windows::storage::IStorageFile> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn UnloadPriFiles(&self, files: <foundation::collections::IIterable<crate::windows::storage::IStorageFile> as RtType>::Abi) -> HRESULT
}}
impl IResourceManager {
    #[inline] pub fn get_main_resource_map(&self) -> Result<Option<ResourceMap>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_MainResourceMap)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ResourceMap::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_all_resource_maps(&self) -> Result<Option<foundation::collections::IMapView<HString, ResourceMap>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AllResourceMaps)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_context(&self) -> Result<Option<ResourceContext>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DefaultContext)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ResourceContext::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn load_pri_files(&self, files: &foundation::collections::IIterable<crate::windows::storage::IStorageFile>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().LoadPriFiles)(self.get_abi() as *const _ as *mut _, files.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn unload_pri_files(&self, files: &foundation::collections::IIterable<crate::windows::storage::IStorageFile>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().UnloadPriFiles)(self.get_abi() as *const _ as *mut _, files.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ResourceManager: IResourceManager}
impl RtActivatable<IResourceManagerStatics> for ResourceManager {}
impl ResourceManager {
    #[inline] pub fn get_current() -> Result<Option<ResourceManager>> {
        <Self as RtActivatable<IResourceManagerStatics>>::get_activation_factory().get_current()
    }
    #[inline] pub fn is_resource_reference(resourceReference: &HStringArg) -> Result<bool> {
        <Self as RtActivatable<IResourceManagerStatics>>::get_activation_factory().is_resource_reference(resourceReference)
    }
}
DEFINE_CLSID!(ResourceManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,82,101,115,111,117,114,99,101,115,46,67,111,114,101,46,82,101,115,111,117,114,99,101,77,97,110,97,103,101,114,0]) [CLSID_ResourceManager]);
DEFINE_IID!(IID_IResourceManager2, 2640772716, 42199, 19491, 158, 133, 103, 95, 48, 76, 37, 45);
RT_INTERFACE!{interface IResourceManager2(IResourceManager2Vtbl): IInspectable [IID_IResourceManager2] {
    fn GetAllNamedResourcesForPackage(&self, packageName: HSTRING, resourceLayoutInfo: ResourceLayoutInfo, out: *mut <foundation::collections::IVectorView<NamedResource> as RtType>::Abi) -> HRESULT,
    fn GetAllSubtreesForPackage(&self, packageName: HSTRING, resourceLayoutInfo: ResourceLayoutInfo, out: *mut <foundation::collections::IVectorView<ResourceMap> as RtType>::Abi) -> HRESULT
}}
impl IResourceManager2 {
    #[inline] pub fn get_all_named_resources_for_package(&self, packageName: &HStringArg, resourceLayoutInfo: ResourceLayoutInfo) -> Result<Option<foundation::collections::IVectorView<NamedResource>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetAllNamedResourcesForPackage)(self.get_abi() as *const _ as *mut _, packageName.get(), resourceLayoutInfo, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_all_subtrees_for_package(&self, packageName: &HStringArg, resourceLayoutInfo: ResourceLayoutInfo) -> Result<Option<foundation::collections::IVectorView<ResourceMap>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetAllSubtreesForPackage)(self.get_abi() as *const _ as *mut _, packageName.get(), resourceLayoutInfo, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IResourceManagerStatics, 482409980, 27118, 20035, 153, 1, 71, 241, 38, 135, 186, 247);
RT_INTERFACE!{static interface IResourceManagerStatics(IResourceManagerStaticsVtbl): IInspectable [IID_IResourceManagerStatics] {
    fn get_Current(&self, out: *mut <ResourceManager as RtType>::Abi) -> HRESULT,
    fn IsResourceReference(&self, resourceReference: HSTRING, out: *mut bool) -> HRESULT
}}
impl IResourceManagerStatics {
    #[inline] pub fn get_current(&self) -> Result<Option<ResourceManager>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Current)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ResourceManager::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_resource_reference(&self, resourceReference: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().IsResourceReference)(self.get_abi() as *const _ as *mut _, resourceReference.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IResourceMap, 1915242532, 56204, 17144, 176, 140, 83, 255, 53, 125, 173, 130);
RT_INTERFACE!{interface IResourceMap(IResourceMapVtbl): IInspectable [IID_IResourceMap] {
    fn get_Uri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn GetValue(&self, resource: HSTRING, out: *mut <ResourceCandidate as RtType>::Abi) -> HRESULT,
    fn GetValueForContext(&self, resource: HSTRING, context: <ResourceContext as RtType>::Abi, out: *mut <ResourceCandidate as RtType>::Abi) -> HRESULT,
    fn GetSubtree(&self, reference: HSTRING, out: *mut <ResourceMap as RtType>::Abi) -> HRESULT
}}
impl IResourceMap {
    #[inline] pub fn get_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Uri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self, resource: &HStringArg) -> Result<Option<ResourceCandidate>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetValue)(self.get_abi() as *const _ as *mut _, resource.get(), &mut out);
        if hr == S_OK { Ok(ResourceCandidate::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_value_for_context(&self, resource: &HStringArg, context: &ResourceContext) -> Result<Option<ResourceCandidate>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetValueForContext)(self.get_abi() as *const _ as *mut _, resource.get(), context.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ResourceCandidate::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_subtree(&self, reference: &HStringArg) -> Result<Option<ResourceMap>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetSubtree)(self.get_abi() as *const _ as *mut _, reference.get(), &mut out);
        if hr == S_OK { Ok(ResourceMap::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ResourceMap: IResourceMap}
RT_CLASS!{class ResourceMapIterator: foundation::collections::IIterator<foundation::collections::IKeyValuePair<HString, NamedResource>>}
RT_CLASS!{class ResourceMapMapView: foundation::collections::IMapView<HString, ResourceMap>}
RT_CLASS!{class ResourceMapMapViewIterator: foundation::collections::IIterator<foundation::collections::IKeyValuePair<HString, ResourceMap>>}
DEFINE_IID!(IID_IResourceQualifier, 2019403186, 19197, 17270, 168, 136, 197, 249, 166, 183, 160, 92);
RT_INTERFACE!{interface IResourceQualifier(IResourceQualifierVtbl): IInspectable [IID_IResourceQualifier] {
    fn get_QualifierName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_QualifierValue(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsDefault(&self, out: *mut bool) -> HRESULT,
    fn get_IsMatch(&self, out: *mut bool) -> HRESULT,
    fn get_Score(&self, out: *mut f64) -> HRESULT
}}
impl IResourceQualifier {
    #[inline] pub fn get_qualifier_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_QualifierName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_qualifier_value(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_QualifierValue)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_default(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsDefault)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_match(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsMatch)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_score(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Score)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ResourceQualifier: IResourceQualifier}
RT_CLASS!{class ResourceQualifierMapView: foundation::collections::IMapView<HString, HString>}
RT_CLASS!{class ResourceQualifierObservableMap: foundation::collections::IObservableMap<HString, HString>}
RT_ENUM! { enum ResourceQualifierPersistence: i32 {
    None = 0, LocalMachine = 1,
}}
RT_CLASS!{class ResourceQualifierVectorView: foundation::collections::IVectorView<ResourceQualifier>}
} // Windows.ApplicationModel.Resources.Core
pub mod management { // Windows.ApplicationModel.Resources.Management
use crate::prelude::*;
DEFINE_IID!(IID_IIndexedResourceCandidate, 241278707, 64236, 17428, 169, 215, 84, 172, 213, 149, 63, 41);
RT_INTERFACE!{interface IIndexedResourceCandidate(IIndexedResourceCandidateVtbl): IInspectable [IID_IIndexedResourceCandidate] {
    fn get_Type(&self, out: *mut IndexedResourceType) -> HRESULT,
    fn get_Uri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_Metadata(&self, out: *mut <foundation::collections::IMapView<HString, HString> as RtType>::Abi) -> HRESULT,
    fn get_Qualifiers(&self, out: *mut <foundation::collections::IVectorView<IndexedResourceQualifier> as RtType>::Abi) -> HRESULT,
    fn get_ValueAsString(&self, out: *mut HSTRING) -> HRESULT,
    fn GetQualifierValue(&self, qualifierName: HSTRING, out: *mut HSTRING) -> HRESULT
}}
impl IIndexedResourceCandidate {
    #[inline] pub fn get_type(&self) -> Result<IndexedResourceType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Type)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Uri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_metadata(&self) -> Result<Option<foundation::collections::IMapView<HString, HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Metadata)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_qualifiers(&self) -> Result<Option<foundation::collections::IVectorView<IndexedResourceQualifier>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Qualifiers)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_value_as_string(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ValueAsString)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_qualifier_value(&self, qualifierName: &HStringArg) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetQualifierValue)(self.get_abi() as *const _ as *mut _, qualifierName.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class IndexedResourceCandidate: IIndexedResourceCandidate}
DEFINE_IID!(IID_IIndexedResourceQualifier, 3672357787, 54020, 18815, 161, 104, 163, 64, 4, 44, 138, 219);
RT_INTERFACE!{interface IIndexedResourceQualifier(IIndexedResourceQualifierVtbl): IInspectable [IID_IIndexedResourceQualifier] {
    fn get_QualifierName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_QualifierValue(&self, out: *mut HSTRING) -> HRESULT
}}
impl IIndexedResourceQualifier {
    #[inline] pub fn get_qualifier_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_QualifierName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_qualifier_value(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_QualifierValue)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class IndexedResourceQualifier: IIndexedResourceQualifier}
RT_ENUM! { enum IndexedResourceType: i32 {
    String = 0, Path = 1, EmbeddedData = 2,
}}
DEFINE_IID!(IID_IResourceIndexer, 760019365, 58159, 19122, 135, 72, 150, 53, 10, 1, 109, 163);
RT_INTERFACE!{interface IResourceIndexer(IResourceIndexerVtbl): IInspectable [IID_IResourceIndexer] {
    fn IndexFilePath(&self, filePath: <foundation::Uri as RtType>::Abi, out: *mut <IndexedResourceCandidate as RtType>::Abi) -> HRESULT,
    fn IndexFileContentsAsync(&self, file: <foundation::Uri as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<IndexedResourceCandidate>> as RtType>::Abi) -> HRESULT
}}
impl IResourceIndexer {
    #[inline] pub fn index_file_path(&self, filePath: &foundation::Uri) -> Result<Option<IndexedResourceCandidate>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().IndexFilePath)(self.get_abi() as *const _ as *mut _, filePath.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IndexedResourceCandidate::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn index_file_contents_async(&self, file: &foundation::Uri) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<IndexedResourceCandidate>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().IndexFileContentsAsync)(self.get_abi() as *const _ as *mut _, file.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ResourceIndexer: IResourceIndexer}
impl RtActivatable<IResourceIndexerFactory> for ResourceIndexer {}
impl RtActivatable<IResourceIndexerFactory2> for ResourceIndexer {}
impl ResourceIndexer {
    #[inline] pub fn create_resource_indexer(projectRoot: &foundation::Uri) -> Result<ResourceIndexer> {
        <Self as RtActivatable<IResourceIndexerFactory>>::get_activation_factory().create_resource_indexer(projectRoot)
    }
    #[inline] pub fn create_resource_indexer_with_extension(projectRoot: &foundation::Uri, extensionDllPath: &foundation::Uri) -> Result<ResourceIndexer> {
        <Self as RtActivatable<IResourceIndexerFactory2>>::get_activation_factory().create_resource_indexer_with_extension(projectRoot, extensionDllPath)
    }
}
DEFINE_CLSID!(ResourceIndexer(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,82,101,115,111,117,114,99,101,115,46,77,97,110,97,103,101,109,101,110,116,46,82,101,115,111,117,114,99,101,73,110,100,101,120,101,114,0]) [CLSID_ResourceIndexer]);
DEFINE_IID!(IID_IResourceIndexerFactory, 3101572873, 12749, 19863, 189, 48, 141, 57, 247, 66, 188, 97);
RT_INTERFACE!{static interface IResourceIndexerFactory(IResourceIndexerFactoryVtbl): IInspectable [IID_IResourceIndexerFactory] {
    fn CreateResourceIndexer(&self, projectRoot: <foundation::Uri as RtType>::Abi, out: *mut <ResourceIndexer as RtType>::Abi) -> HRESULT
}}
impl IResourceIndexerFactory {
    #[inline] pub fn create_resource_indexer(&self, projectRoot: &foundation::Uri) -> Result<ResourceIndexer> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateResourceIndexer)(self.get_abi() as *const _ as *mut _, projectRoot.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ResourceIndexer::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IResourceIndexerFactory2, 1614868877, 54757, 19296, 146, 1, 205, 39, 156, 188, 254, 217);
RT_INTERFACE!{static interface IResourceIndexerFactory2(IResourceIndexerFactory2Vtbl): IInspectable [IID_IResourceIndexerFactory2] {
    fn CreateResourceIndexerWithExtension(&self, projectRoot: <foundation::Uri as RtType>::Abi, extensionDllPath: <foundation::Uri as RtType>::Abi, out: *mut <ResourceIndexer as RtType>::Abi) -> HRESULT
}}
impl IResourceIndexerFactory2 {
    #[inline] pub fn create_resource_indexer_with_extension(&self, projectRoot: &foundation::Uri, extensionDllPath: &foundation::Uri) -> Result<ResourceIndexer> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateResourceIndexerWithExtension)(self.get_abi() as *const _ as *mut _, projectRoot.get_abi() as *const _ as *mut _, extensionDllPath.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ResourceIndexer::wrap_nonnull(out)) } else { err(hr) }
    }}
}
} // Windows.ApplicationModel.Resources.Management
} // Windows.ApplicationModel.Resources
pub mod search { // Windows.ApplicationModel.Search
use crate::prelude::*;
DEFINE_IID!(IID_ILocalContentSuggestionSettings, 4004425826, 29757, 17774, 132, 163, 35, 240, 111, 45, 21, 215);
RT_INTERFACE!{interface ILocalContentSuggestionSettings(ILocalContentSuggestionSettingsVtbl): IInspectable [IID_ILocalContentSuggestionSettings] {
    fn put_Enabled(&self, value: bool) -> HRESULT,
    fn get_Enabled(&self, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Locations(&self, out: *mut <foundation::collections::IVector<super::super::storage::StorageFolder> as RtType>::Abi) -> HRESULT,
    fn put_AqsFilter(&self, value: HSTRING) -> HRESULT,
    fn get_AqsFilter(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PropertiesToMatch(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT
}}
impl ILocalContentSuggestionSettings {
    #[inline] pub fn set_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Enabled)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Enabled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_locations(&self) -> Result<Option<foundation::collections::IVector<super::super::storage::StorageFolder>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Locations)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_aqs_filter(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AqsFilter)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_aqs_filter(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AqsFilter)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties_to_match(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PropertiesToMatch)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LocalContentSuggestionSettings: ILocalContentSuggestionSettings}
impl RtActivatable<IActivationFactory> for LocalContentSuggestionSettings {}
DEFINE_CLSID!(LocalContentSuggestionSettings(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,83,101,97,114,99,104,46,76,111,99,97,108,67,111,110,116,101,110,116,83,117,103,103,101,115,116,105,111,110,83,101,116,116,105,110,103,115,0]) [CLSID_LocalContentSuggestionSettings]);
DEFINE_IID!(IID_ISearchPane, 4255968312, 14080, 19827, 145, 161, 47, 153, 134, 116, 35, 138);
RT_INTERFACE!{interface ISearchPane(ISearchPaneVtbl): IInspectable [IID_ISearchPane] {
    fn put_SearchHistoryEnabled(&self, value: bool) -> HRESULT,
    fn get_SearchHistoryEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_SearchHistoryContext(&self, value: HSTRING) -> HRESULT,
    fn get_SearchHistoryContext(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PlaceholderText(&self, value: HSTRING) -> HRESULT,
    fn get_PlaceholderText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_QueryText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Visible(&self, out: *mut bool) -> HRESULT,
    fn add_VisibilityChanged(&self, handler: <foundation::TypedEventHandler<SearchPane, SearchPaneVisibilityChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VisibilityChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_QueryChanged(&self, handler: <foundation::TypedEventHandler<SearchPane, SearchPaneQueryChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_QueryChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SuggestionsRequested(&self, handler: <foundation::TypedEventHandler<SearchPane, SearchPaneSuggestionsRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SuggestionsRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_QuerySubmitted(&self, handler: <foundation::TypedEventHandler<SearchPane, SearchPaneQuerySubmittedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_QuerySubmitted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ResultSuggestionChosen(&self, handler: <foundation::TypedEventHandler<SearchPane, SearchPaneResultSuggestionChosenEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ResultSuggestionChosen(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn SetLocalContentSuggestionSettings(&self, settings: <LocalContentSuggestionSettings as RtType>::Abi) -> HRESULT,
    fn ShowOverloadDefault(&self) -> HRESULT,
    fn ShowOverloadWithQuery(&self, query: HSTRING) -> HRESULT,
    fn put_ShowOnKeyboardInput(&self, value: bool) -> HRESULT,
    fn get_ShowOnKeyboardInput(&self, out: *mut bool) -> HRESULT,
    fn TrySetQueryText(&self, query: HSTRING, out: *mut bool) -> HRESULT
}}
impl ISearchPane {
    #[inline] pub fn set_search_history_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SearchHistoryEnabled)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_search_history_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SearchHistoryEnabled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_search_history_context(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SearchHistoryContext)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_search_history_context(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SearchHistoryContext)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_placeholder_text(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_PlaceholderText)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_placeholder_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PlaceholderText)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_query_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_QueryText)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_language(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Language)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_visible(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Visible)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_visibility_changed(&self, handler: &foundation::TypedEventHandler<SearchPane, SearchPaneVisibilityChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_VisibilityChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_visibility_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_VisibilityChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_query_changed(&self, handler: &foundation::TypedEventHandler<SearchPane, SearchPaneQueryChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_QueryChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_query_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_QueryChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_suggestions_requested(&self, handler: &foundation::TypedEventHandler<SearchPane, SearchPaneSuggestionsRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_SuggestionsRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_suggestions_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_SuggestionsRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_query_submitted(&self, handler: &foundation::TypedEventHandler<SearchPane, SearchPaneQuerySubmittedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_QuerySubmitted)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_query_submitted(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_QuerySubmitted)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_result_suggestion_chosen(&self, handler: &foundation::TypedEventHandler<SearchPane, SearchPaneResultSuggestionChosenEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_ResultSuggestionChosen)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_result_suggestion_chosen(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_ResultSuggestionChosen)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_local_content_suggestion_settings(&self, settings: &LocalContentSuggestionSettings) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetLocalContentSuggestionSettings)(self.get_abi() as *const _ as *mut _, settings.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn show_overload_default(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ShowOverloadDefault)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn show_overload_with_query(&self, query: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ShowOverloadWithQuery)(self.get_abi() as *const _ as *mut _, query.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_show_on_keyboard_input(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ShowOnKeyboardInput)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_show_on_keyboard_input(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ShowOnKeyboardInput)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_set_query_text(&self, query: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().TrySetQueryText)(self.get_abi() as *const _ as *mut _, query.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SearchPane: ISearchPane}
impl RtActivatable<ISearchPaneStatics> for SearchPane {}
impl RtActivatable<ISearchPaneStaticsWithHideThisApplication> for SearchPane {}
impl SearchPane {
    #[inline] pub fn get_for_current_view() -> Result<Option<SearchPane>> {
        <Self as RtActivatable<ISearchPaneStatics>>::get_activation_factory().get_for_current_view()
    }
    #[inline] pub fn hide_this_application() -> Result<()> {
        <Self as RtActivatable<ISearchPaneStaticsWithHideThisApplication>>::get_activation_factory().hide_this_application()
    }
}
DEFINE_CLSID!(SearchPane(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,83,101,97,114,99,104,46,83,101,97,114,99,104,80,97,110,101,0]) [CLSID_SearchPane]);
DEFINE_IID!(IID_ISearchPaneQueryChangedEventArgs, 1007046633, 9041, 16968, 165, 41, 113, 16, 244, 100, 167, 133);
RT_INTERFACE!{interface ISearchPaneQueryChangedEventArgs(ISearchPaneQueryChangedEventArgsVtbl): IInspectable [IID_ISearchPaneQueryChangedEventArgs] {
    fn get_QueryText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT,
    fn get_LinguisticDetails(&self, out: *mut <SearchPaneQueryLinguisticDetails as RtType>::Abi) -> HRESULT
}}
impl ISearchPaneQueryChangedEventArgs {
    #[inline] pub fn get_query_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_QueryText)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_language(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Language)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_linguistic_details(&self) -> Result<Option<SearchPaneQueryLinguisticDetails>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LinguisticDetails)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SearchPaneQueryLinguisticDetails::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SearchPaneQueryChangedEventArgs: ISearchPaneQueryChangedEventArgs}
DEFINE_IID!(IID_ISearchPaneQueryLinguisticDetails, 2197505550, 2368, 19309, 184, 208, 100, 43, 48, 152, 158, 21);
RT_INTERFACE!{interface ISearchPaneQueryLinguisticDetails(ISearchPaneQueryLinguisticDetailsVtbl): IInspectable [IID_ISearchPaneQueryLinguisticDetails] {
    fn get_QueryTextAlternatives(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT,
    fn get_QueryTextCompositionStart(&self, out: *mut u32) -> HRESULT,
    fn get_QueryTextCompositionLength(&self, out: *mut u32) -> HRESULT
}}
impl ISearchPaneQueryLinguisticDetails {
    #[inline] pub fn get_query_text_alternatives(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_QueryTextAlternatives)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_query_text_composition_start(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_QueryTextCompositionStart)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_query_text_composition_length(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_QueryTextCompositionLength)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SearchPaneQueryLinguisticDetails: ISearchPaneQueryLinguisticDetails}
DEFINE_IID!(IID_ISearchPaneQuerySubmittedEventArgs, 339453180, 59845, 18230, 145, 178, 232, 235, 156, 184, 131, 86);
RT_INTERFACE!{interface ISearchPaneQuerySubmittedEventArgs(ISearchPaneQuerySubmittedEventArgsVtbl): IInspectable [IID_ISearchPaneQuerySubmittedEventArgs] {
    fn get_QueryText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT
}}
impl ISearchPaneQuerySubmittedEventArgs {
    #[inline] pub fn get_query_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_QueryText)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_language(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Language)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SearchPaneQuerySubmittedEventArgs: ISearchPaneQuerySubmittedEventArgs}
DEFINE_IID!(IID_ISearchPaneQuerySubmittedEventArgsWithLinguisticDetails, 1175229157, 19506, 17720, 164, 212, 182, 180, 64, 13, 20, 15);
RT_INTERFACE!{interface ISearchPaneQuerySubmittedEventArgsWithLinguisticDetails(ISearchPaneQuerySubmittedEventArgsWithLinguisticDetailsVtbl): IInspectable [IID_ISearchPaneQuerySubmittedEventArgsWithLinguisticDetails] {
    fn get_LinguisticDetails(&self, out: *mut <SearchPaneQueryLinguisticDetails as RtType>::Abi) -> HRESULT
}}
impl ISearchPaneQuerySubmittedEventArgsWithLinguisticDetails {
    #[inline] pub fn get_linguistic_details(&self) -> Result<Option<SearchPaneQueryLinguisticDetails>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LinguisticDetails)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SearchPaneQueryLinguisticDetails::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISearchPaneResultSuggestionChosenEventArgs, 3358682304, 44754, 16864, 188, 224, 194, 108, 167, 79, 133, 236);
RT_INTERFACE!{interface ISearchPaneResultSuggestionChosenEventArgs(ISearchPaneResultSuggestionChosenEventArgsVtbl): IInspectable [IID_ISearchPaneResultSuggestionChosenEventArgs] {
    fn get_Tag(&self, out: *mut HSTRING) -> HRESULT
}}
impl ISearchPaneResultSuggestionChosenEventArgs {
    #[inline] pub fn get_tag(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Tag)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SearchPaneResultSuggestionChosenEventArgs: ISearchPaneResultSuggestionChosenEventArgs}
DEFINE_IID!(IID_ISearchPaneStatics, 2507320817, 36637, 18463, 161, 91, 198, 22, 85, 241, 106, 14);
RT_INTERFACE!{static interface ISearchPaneStatics(ISearchPaneStaticsVtbl): IInspectable [IID_ISearchPaneStatics] {
    fn GetForCurrentView(&self, out: *mut <SearchPane as RtType>::Abi) -> HRESULT
}}
impl ISearchPaneStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<SearchPane>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetForCurrentView)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SearchPane::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISearchPaneStaticsWithHideThisApplication, 7546928, 20721, 19715, 153, 172, 198, 100, 76, 142, 216, 181);
RT_INTERFACE!{static interface ISearchPaneStaticsWithHideThisApplication(ISearchPaneStaticsWithHideThisApplicationVtbl): IInspectable [IID_ISearchPaneStaticsWithHideThisApplication] {
    fn HideThisApplication(&self) -> HRESULT
}}
impl ISearchPaneStaticsWithHideThisApplication {
    #[inline] pub fn hide_this_application(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().HideThisApplication)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISearchPaneSuggestionsRequest, 2175863580, 58721, 16531, 155, 77, 42, 212, 130, 121, 74, 83);
RT_INTERFACE!{interface ISearchPaneSuggestionsRequest(ISearchPaneSuggestionsRequestVtbl): IInspectable [IID_ISearchPaneSuggestionsRequest] {
    fn get_IsCanceled(&self, out: *mut bool) -> HRESULT,
    fn get_SearchSuggestionCollection(&self, out: *mut <SearchSuggestionCollection as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <SearchPaneSuggestionsRequestDeferral as RtType>::Abi) -> HRESULT
}}
impl ISearchPaneSuggestionsRequest {
    #[inline] pub fn get_is_canceled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsCanceled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_search_suggestion_collection(&self) -> Result<Option<SearchSuggestionCollection>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SearchSuggestionCollection)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SearchSuggestionCollection::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<SearchPaneSuggestionsRequestDeferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SearchPaneSuggestionsRequestDeferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SearchPaneSuggestionsRequest: ISearchPaneSuggestionsRequest}
DEFINE_IID!(IID_ISearchPaneSuggestionsRequestDeferral, 2697988599, 34632, 20194, 173, 68, 175, 166, 190, 153, 124, 81);
RT_INTERFACE!{interface ISearchPaneSuggestionsRequestDeferral(ISearchPaneSuggestionsRequestDeferralVtbl): IInspectable [IID_ISearchPaneSuggestionsRequestDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl ISearchPaneSuggestionsRequestDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Complete)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SearchPaneSuggestionsRequestDeferral: ISearchPaneSuggestionsRequestDeferral}
DEFINE_IID!(IID_ISearchPaneSuggestionsRequestedEventArgs, 3365636655, 44118, 17504, 141, 47, 128, 2, 59, 236, 79, 197);
RT_INTERFACE!{interface ISearchPaneSuggestionsRequestedEventArgs(ISearchPaneSuggestionsRequestedEventArgsVtbl): IInspectable [IID_ISearchPaneSuggestionsRequestedEventArgs] {
    fn get_Request(&self, out: *mut <SearchPaneSuggestionsRequest as RtType>::Abi) -> HRESULT
}}
impl ISearchPaneSuggestionsRequestedEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<SearchPaneSuggestionsRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SearchPaneSuggestionsRequest::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SearchPaneSuggestionsRequestedEventArgs: ISearchPaneSuggestionsRequestedEventArgs}
DEFINE_IID!(IID_ISearchPaneVisibilityChangedEventArgs, 1011691590, 44107, 18930, 151, 214, 2, 14, 97, 130, 203, 156);
RT_INTERFACE!{interface ISearchPaneVisibilityChangedEventArgs(ISearchPaneVisibilityChangedEventArgsVtbl): IInspectable [IID_ISearchPaneVisibilityChangedEventArgs] {
    fn get_Visible(&self, out: *mut bool) -> HRESULT
}}
impl ISearchPaneVisibilityChangedEventArgs {
    #[inline] pub fn get_visible(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Visible)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SearchPaneVisibilityChangedEventArgs: ISearchPaneVisibilityChangedEventArgs}
DEFINE_IID!(IID_ISearchQueryLinguisticDetails, 1184964699, 27081, 18245, 183, 47, 168, 164, 252, 143, 36, 174);
RT_INTERFACE!{interface ISearchQueryLinguisticDetails(ISearchQueryLinguisticDetailsVtbl): IInspectable [IID_ISearchQueryLinguisticDetails] {
    fn get_QueryTextAlternatives(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT,
    fn get_QueryTextCompositionStart(&self, out: *mut u32) -> HRESULT,
    fn get_QueryTextCompositionLength(&self, out: *mut u32) -> HRESULT
}}
impl ISearchQueryLinguisticDetails {
    #[inline] pub fn get_query_text_alternatives(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_QueryTextAlternatives)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_query_text_composition_start(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_QueryTextCompositionStart)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_query_text_composition_length(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_QueryTextCompositionLength)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SearchQueryLinguisticDetails: ISearchQueryLinguisticDetails}
impl RtActivatable<ISearchQueryLinguisticDetailsFactory> for SearchQueryLinguisticDetails {}
impl SearchQueryLinguisticDetails {
    #[inline] pub fn create_instance(queryTextAlternatives: &foundation::collections::IIterable<HString>, queryTextCompositionStart: u32, queryTextCompositionLength: u32) -> Result<SearchQueryLinguisticDetails> {
        <Self as RtActivatable<ISearchQueryLinguisticDetailsFactory>>::get_activation_factory().create_instance(queryTextAlternatives, queryTextCompositionStart, queryTextCompositionLength)
    }
}
DEFINE_CLSID!(SearchQueryLinguisticDetails(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,83,101,97,114,99,104,46,83,101,97,114,99,104,81,117,101,114,121,76,105,110,103,117,105,115,116,105,99,68,101,116,97,105,108,115,0]) [CLSID_SearchQueryLinguisticDetails]);
DEFINE_IID!(IID_ISearchQueryLinguisticDetailsFactory, 3402023864, 15460, 19965, 173, 159, 71, 158, 77, 64, 101, 164);
RT_INTERFACE!{static interface ISearchQueryLinguisticDetailsFactory(ISearchQueryLinguisticDetailsFactoryVtbl): IInspectable [IID_ISearchQueryLinguisticDetailsFactory] {
    fn CreateInstance(&self, queryTextAlternatives: <foundation::collections::IIterable<HString> as RtType>::Abi, queryTextCompositionStart: u32, queryTextCompositionLength: u32, out: *mut <SearchQueryLinguisticDetails as RtType>::Abi) -> HRESULT
}}
impl ISearchQueryLinguisticDetailsFactory {
    #[inline] pub fn create_instance(&self, queryTextAlternatives: &foundation::collections::IIterable<HString>, queryTextCompositionStart: u32, queryTextCompositionLength: u32) -> Result<SearchQueryLinguisticDetails> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateInstance)(self.get_abi() as *const _ as *mut _, queryTextAlternatives.get_abi() as *const _ as *mut _, queryTextCompositionStart, queryTextCompositionLength, &mut out);
        if hr == S_OK { Ok(SearchQueryLinguisticDetails::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISearchSuggestionCollection, 842697291, 64490, 17478, 171, 188, 61, 167, 145, 95, 221, 58);
RT_INTERFACE!{interface ISearchSuggestionCollection(ISearchSuggestionCollectionVtbl): IInspectable [IID_ISearchSuggestionCollection] {
    fn get_Size(&self, out: *mut u32) -> HRESULT,
    fn AppendQuerySuggestion(&self, text: HSTRING) -> HRESULT,
    fn AppendQuerySuggestions(&self, suggestions: <foundation::collections::IIterable<HString> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-storage")] fn AppendResultSuggestion(&self, text: HSTRING, detailText: HSTRING, tag: HSTRING, image: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi, imageAlternateText: HSTRING) -> HRESULT,
    fn AppendSearchSeparator(&self, label: HSTRING) -> HRESULT
}}
impl ISearchSuggestionCollection {
    #[inline] pub fn get_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Size)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn append_query_suggestion(&self, text: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().AppendQuerySuggestion)(self.get_abi() as *const _ as *mut _, text.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn append_query_suggestions(&self, suggestions: &foundation::collections::IIterable<HString>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().AppendQuerySuggestions)(self.get_abi() as *const _ as *mut _, suggestions.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn append_result_suggestion(&self, text: &HStringArg, detailText: &HStringArg, tag: &HStringArg, image: &super::super::storage::streams::IRandomAccessStreamReference, imageAlternateText: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().AppendResultSuggestion)(self.get_abi() as *const _ as *mut _, text.get(), detailText.get(), tag.get(), image.get_abi() as *const _ as *mut _, imageAlternateText.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn append_search_separator(&self, label: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().AppendSearchSeparator)(self.get_abi() as *const _ as *mut _, label.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SearchSuggestionCollection: ISearchSuggestionCollection}
DEFINE_IID!(IID_ISearchSuggestionsRequest, 1313744551, 17637, 16441, 144, 153, 96, 0, 234, 209, 240, 198);
RT_INTERFACE!{interface ISearchSuggestionsRequest(ISearchSuggestionsRequestVtbl): IInspectable [IID_ISearchSuggestionsRequest] {
    fn get_IsCanceled(&self, out: *mut bool) -> HRESULT,
    fn get_SearchSuggestionCollection(&self, out: *mut <SearchSuggestionCollection as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <SearchSuggestionsRequestDeferral as RtType>::Abi) -> HRESULT
}}
impl ISearchSuggestionsRequest {
    #[inline] pub fn get_is_canceled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsCanceled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_search_suggestion_collection(&self) -> Result<Option<SearchSuggestionCollection>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SearchSuggestionCollection)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SearchSuggestionCollection::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<SearchSuggestionsRequestDeferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SearchSuggestionsRequestDeferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SearchSuggestionsRequest: ISearchSuggestionsRequest}
DEFINE_IID!(IID_ISearchSuggestionsRequestDeferral, 3071645865, 49253, 17773, 168, 69, 30, 204, 236, 93, 194, 139);
RT_INTERFACE!{interface ISearchSuggestionsRequestDeferral(ISearchSuggestionsRequestDeferralVtbl): IInspectable [IID_ISearchSuggestionsRequestDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl ISearchSuggestionsRequestDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Complete)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SearchSuggestionsRequestDeferral: ISearchSuggestionsRequestDeferral}
pub mod core { // Windows.ApplicationModel.Search.Core
use crate::prelude::*;
DEFINE_IID!(IID_IRequestingFocusOnKeyboardInputEventArgs, 2702794535, 45479, 16802, 135, 157, 106, 104, 104, 126, 89, 133);
RT_INTERFACE!{interface IRequestingFocusOnKeyboardInputEventArgs(IRequestingFocusOnKeyboardInputEventArgsVtbl): IInspectable [IID_IRequestingFocusOnKeyboardInputEventArgs] {
    
}}
RT_CLASS!{class RequestingFocusOnKeyboardInputEventArgs: IRequestingFocusOnKeyboardInputEventArgs}
DEFINE_IID!(IID_ISearchSuggestion, 1532318896, 5415, 17275, 149, 197, 141, 24, 210, 184, 175, 85);
RT_INTERFACE!{interface ISearchSuggestion(ISearchSuggestionVtbl): IInspectable [IID_ISearchSuggestion] {
    fn get_Kind(&self, out: *mut SearchSuggestionKind) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Tag(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DetailText(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Image(&self, out: *mut <crate::windows::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    fn get_ImageAlternateText(&self, out: *mut HSTRING) -> HRESULT
}}
impl ISearchSuggestion {
    #[inline] pub fn get_kind(&self) -> Result<SearchSuggestionKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Kind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Text)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_tag(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Tag)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_detail_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DetailText)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_image(&self) -> Result<Option<crate::windows::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Image)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_image_alternate_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ImageAlternateText)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SearchSuggestion: ISearchSuggestion}
RT_ENUM! { enum SearchSuggestionKind: i32 {
    Query = 0, Result = 1, Separator = 2,
}}
DEFINE_IID!(IID_ISearchSuggestionManager, 1057771681, 52125, 18811, 181, 0, 60, 4, 172, 149, 154, 210);
RT_INTERFACE!{interface ISearchSuggestionManager(ISearchSuggestionManagerVtbl): IInspectable [IID_ISearchSuggestionManager] {
    fn get_SearchHistoryEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_SearchHistoryEnabled(&self, value: bool) -> HRESULT,
    fn get_SearchHistoryContext(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SearchHistoryContext(&self, value: HSTRING) -> HRESULT,
    fn SetLocalContentSuggestionSettings(&self, settings: <super::LocalContentSuggestionSettings as RtType>::Abi) -> HRESULT,
    fn SetQuery(&self, queryText: HSTRING) -> HRESULT,
    fn SetQueryWithLanguage(&self, queryText: HSTRING, language: HSTRING) -> HRESULT,
    fn SetQueryWithSearchQueryLinguisticDetails(&self, queryText: HSTRING, language: HSTRING, linguisticDetails: <super::SearchQueryLinguisticDetails as RtType>::Abi) -> HRESULT,
    fn get_Suggestions(&self, out: *mut <foundation::collections::IObservableVector<SearchSuggestion> as RtType>::Abi) -> HRESULT,
    fn AddToHistory(&self, queryText: HSTRING) -> HRESULT,
    fn AddToHistoryWithLanguage(&self, queryText: HSTRING, language: HSTRING) -> HRESULT,
    fn ClearHistory(&self) -> HRESULT,
    fn add_SuggestionsRequested(&self, handler: <foundation::TypedEventHandler<SearchSuggestionManager, SearchSuggestionsRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SuggestionsRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_RequestingFocusOnKeyboardInput(&self, handler: <foundation::TypedEventHandler<SearchSuggestionManager, RequestingFocusOnKeyboardInputEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RequestingFocusOnKeyboardInput(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ISearchSuggestionManager {
    #[inline] pub fn get_search_history_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SearchHistoryEnabled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_search_history_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SearchHistoryEnabled)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_search_history_context(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SearchHistoryContext)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_search_history_context(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SearchHistoryContext)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_local_content_suggestion_settings(&self, settings: &super::LocalContentSuggestionSettings) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetLocalContentSuggestionSettings)(self.get_abi() as *const _ as *mut _, settings.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_query(&self, queryText: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetQuery)(self.get_abi() as *const _ as *mut _, queryText.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_query_with_language(&self, queryText: &HStringArg, language: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetQueryWithLanguage)(self.get_abi() as *const _ as *mut _, queryText.get(), language.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_query_with_search_query_linguistic_details(&self, queryText: &HStringArg, language: &HStringArg, linguisticDetails: &super::SearchQueryLinguisticDetails) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetQueryWithSearchQueryLinguisticDetails)(self.get_abi() as *const _ as *mut _, queryText.get(), language.get(), linguisticDetails.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_suggestions(&self) -> Result<Option<foundation::collections::IObservableVector<SearchSuggestion>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Suggestions)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IObservableVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_to_history(&self, queryText: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().AddToHistory)(self.get_abi() as *const _ as *mut _, queryText.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_to_history_with_language(&self, queryText: &HStringArg, language: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().AddToHistoryWithLanguage)(self.get_abi() as *const _ as *mut _, queryText.get(), language.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn clear_history(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ClearHistory)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_suggestions_requested(&self, handler: &foundation::TypedEventHandler<SearchSuggestionManager, SearchSuggestionsRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_SuggestionsRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_suggestions_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_SuggestionsRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_requesting_focus_on_keyboard_input(&self, handler: &foundation::TypedEventHandler<SearchSuggestionManager, RequestingFocusOnKeyboardInputEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_RequestingFocusOnKeyboardInput)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_requesting_focus_on_keyboard_input(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_RequestingFocusOnKeyboardInput)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SearchSuggestionManager: ISearchSuggestionManager}
impl RtActivatable<IActivationFactory> for SearchSuggestionManager {}
DEFINE_CLSID!(SearchSuggestionManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,83,101,97,114,99,104,46,67,111,114,101,46,83,101,97,114,99,104,83,117,103,103,101,115,116,105,111,110,77,97,110,97,103,101,114,0]) [CLSID_SearchSuggestionManager]);
DEFINE_IID!(IID_ISearchSuggestionsRequestedEventArgs, 1876236773, 40574, 19124, 139, 227, 199, 107, 27, 212, 52, 74);
RT_INTERFACE!{interface ISearchSuggestionsRequestedEventArgs(ISearchSuggestionsRequestedEventArgsVtbl): IInspectable [IID_ISearchSuggestionsRequestedEventArgs] {
    fn get_QueryText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT,
    fn get_LinguisticDetails(&self, out: *mut <super::SearchQueryLinguisticDetails as RtType>::Abi) -> HRESULT,
    fn get_Request(&self, out: *mut <super::SearchSuggestionsRequest as RtType>::Abi) -> HRESULT
}}
impl ISearchSuggestionsRequestedEventArgs {
    #[inline] pub fn get_query_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_QueryText)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_language(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Language)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_linguistic_details(&self) -> Result<Option<super::SearchQueryLinguisticDetails>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LinguisticDetails)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::SearchQueryLinguisticDetails::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_request(&self) -> Result<Option<super::SearchSuggestionsRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::SearchSuggestionsRequest::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SearchSuggestionsRequestedEventArgs: ISearchSuggestionsRequestedEventArgs}
} // Windows.ApplicationModel.Search.Core
} // Windows.ApplicationModel.Search
pub mod socialinfo { // Windows.ApplicationModel.SocialInfo
use crate::prelude::*;
DEFINE_IID!(IID_ISocialFeedChildItem, 191535194, 54685, 16574, 152, 12, 72, 138, 42, 179, 10, 131);
RT_INTERFACE!{interface ISocialFeedChildItem(ISocialFeedChildItemVtbl): IInspectable [IID_ISocialFeedChildItem] {
    fn get_Author(&self, out: *mut <SocialUserInfo as RtType>::Abi) -> HRESULT,
    fn get_PrimaryContent(&self, out: *mut <SocialFeedContent as RtType>::Abi) -> HRESULT,
    fn get_SecondaryContent(&self, out: *mut <SocialFeedContent as RtType>::Abi) -> HRESULT,
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn put_Timestamp(&self, value: foundation::DateTime) -> HRESULT,
    fn get_TargetUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_TargetUri(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_Thumbnails(&self, out: *mut <foundation::collections::IVector<SocialItemThumbnail> as RtType>::Abi) -> HRESULT,
    fn get_SharedItem(&self, out: *mut <SocialFeedSharedItem as RtType>::Abi) -> HRESULT,
    fn put_SharedItem(&self, value: <SocialFeedSharedItem as RtType>::Abi) -> HRESULT
}}
impl ISocialFeedChildItem {
    #[inline] pub fn get_author(&self) -> Result<Option<SocialUserInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Author)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SocialUserInfo::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_primary_content(&self) -> Result<Option<SocialFeedContent>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PrimaryContent)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SocialFeedContent::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_secondary_content(&self) -> Result<Option<SocialFeedContent>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SecondaryContent)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SocialFeedContent::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Timestamp)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_timestamp(&self, value: foundation::DateTime) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Timestamp)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_target_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TargetUri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_target_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_TargetUri)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_thumbnails(&self) -> Result<Option<foundation::collections::IVector<SocialItemThumbnail>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Thumbnails)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_shared_item(&self) -> Result<Option<SocialFeedSharedItem>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SharedItem)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SocialFeedSharedItem::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_shared_item(&self, value: &SocialFeedSharedItem) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SharedItem)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SocialFeedChildItem: ISocialFeedChildItem}
impl RtActivatable<IActivationFactory> for SocialFeedChildItem {}
DEFINE_CLSID!(SocialFeedChildItem(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,83,111,99,105,97,108,73,110,102,111,46,83,111,99,105,97,108,70,101,101,100,67,104,105,108,100,73,116,101,109,0]) [CLSID_SocialFeedChildItem]);
DEFINE_IID!(IID_ISocialFeedContent, 2721375273, 15929, 18765, 163, 124, 244, 98, 162, 73, 69, 20);
RT_INTERFACE!{interface ISocialFeedContent(ISocialFeedContentVtbl): IInspectable [IID_ISocialFeedContent] {
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    fn get_Message(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Message(&self, value: HSTRING) -> HRESULT,
    fn get_TargetUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_TargetUri(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT
}}
impl ISocialFeedContent {
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Title)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_title(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Title)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_message(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Message)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_message(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Message)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_target_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TargetUri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_target_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_TargetUri)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SocialFeedContent: ISocialFeedContent}
DEFINE_IID!(IID_ISocialFeedItem, 1326682795, 8050, 19763, 182, 149, 222, 62, 29, 182, 3, 23);
RT_INTERFACE!{interface ISocialFeedItem(ISocialFeedItemVtbl): IInspectable [IID_ISocialFeedItem] {
    fn get_Author(&self, out: *mut <SocialUserInfo as RtType>::Abi) -> HRESULT,
    fn get_PrimaryContent(&self, out: *mut <SocialFeedContent as RtType>::Abi) -> HRESULT,
    fn get_SecondaryContent(&self, out: *mut <SocialFeedContent as RtType>::Abi) -> HRESULT,
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn put_Timestamp(&self, value: foundation::DateTime) -> HRESULT,
    fn get_TargetUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_TargetUri(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_Thumbnails(&self, out: *mut <foundation::collections::IVector<SocialItemThumbnail> as RtType>::Abi) -> HRESULT,
    fn get_SharedItem(&self, out: *mut <SocialFeedSharedItem as RtType>::Abi) -> HRESULT,
    fn put_SharedItem(&self, value: <SocialFeedSharedItem as RtType>::Abi) -> HRESULT,
    fn get_BadgeStyle(&self, out: *mut SocialItemBadgeStyle) -> HRESULT,
    fn put_BadgeStyle(&self, value: SocialItemBadgeStyle) -> HRESULT,
    fn get_BadgeCountValue(&self, out: *mut i32) -> HRESULT,
    fn put_BadgeCountValue(&self, value: i32) -> HRESULT,
    fn get_RemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RemoteId(&self, value: HSTRING) -> HRESULT,
    fn get_ChildItem(&self, out: *mut <SocialFeedChildItem as RtType>::Abi) -> HRESULT,
    fn put_ChildItem(&self, value: <SocialFeedChildItem as RtType>::Abi) -> HRESULT,
    fn get_Style(&self, out: *mut SocialFeedItemStyle) -> HRESULT,
    fn put_Style(&self, value: SocialFeedItemStyle) -> HRESULT
}}
impl ISocialFeedItem {
    #[inline] pub fn get_author(&self) -> Result<Option<SocialUserInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Author)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SocialUserInfo::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_primary_content(&self) -> Result<Option<SocialFeedContent>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PrimaryContent)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SocialFeedContent::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_secondary_content(&self) -> Result<Option<SocialFeedContent>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SecondaryContent)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SocialFeedContent::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Timestamp)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_timestamp(&self, value: foundation::DateTime) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Timestamp)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_target_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TargetUri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_target_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_TargetUri)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_thumbnails(&self) -> Result<Option<foundation::collections::IVector<SocialItemThumbnail>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Thumbnails)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_shared_item(&self) -> Result<Option<SocialFeedSharedItem>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SharedItem)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SocialFeedSharedItem::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_shared_item(&self, value: &SocialFeedSharedItem) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SharedItem)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_badge_style(&self) -> Result<SocialItemBadgeStyle> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_BadgeStyle)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_badge_style(&self, value: SocialItemBadgeStyle) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_BadgeStyle)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_badge_count_value(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_BadgeCountValue)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_badge_count_value(&self, value: i32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_BadgeCountValue)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_remote_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RemoteId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_remote_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RemoteId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_child_item(&self) -> Result<Option<SocialFeedChildItem>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ChildItem)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SocialFeedChildItem::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_child_item(&self, value: &SocialFeedChildItem) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ChildItem)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_style(&self) -> Result<SocialFeedItemStyle> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Style)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_style(&self, value: SocialFeedItemStyle) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Style)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SocialFeedItem: ISocialFeedItem}
impl RtActivatable<IActivationFactory> for SocialFeedItem {}
DEFINE_CLSID!(SocialFeedItem(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,83,111,99,105,97,108,73,110,102,111,46,83,111,99,105,97,108,70,101,101,100,73,116,101,109,0]) [CLSID_SocialFeedItem]);
RT_ENUM! { enum SocialFeedItemStyle: i32 {
    Default = 0, Photo = 1,
}}
RT_ENUM! { enum SocialFeedKind: i32 {
    HomeFeed = 0, ContactFeed = 1, Dashboard = 2,
}}
DEFINE_IID!(IID_ISocialFeedSharedItem, 2080087616, 42666, 17831, 159, 246, 84, 196, 33, 5, 221, 31);
RT_INTERFACE!{interface ISocialFeedSharedItem(ISocialFeedSharedItemVtbl): IInspectable [IID_ISocialFeedSharedItem] {
    fn get_OriginalSource(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_OriginalSource(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_Content(&self, out: *mut <SocialFeedContent as RtType>::Abi) -> HRESULT,
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn put_Timestamp(&self, value: foundation::DateTime) -> HRESULT,
    fn get_TargetUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_TargetUri(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_Thumbnail(&self, value: <SocialItemThumbnail as RtType>::Abi) -> HRESULT,
    fn get_Thumbnail(&self, out: *mut <SocialItemThumbnail as RtType>::Abi) -> HRESULT
}}
impl ISocialFeedSharedItem {
    #[inline] pub fn get_original_source(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_OriginalSource)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_original_source(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_OriginalSource)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_content(&self) -> Result<Option<SocialFeedContent>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Content)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SocialFeedContent::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Timestamp)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_timestamp(&self, value: foundation::DateTime) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Timestamp)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_target_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TargetUri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_target_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_TargetUri)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_thumbnail(&self, value: &SocialItemThumbnail) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Thumbnail)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_thumbnail(&self) -> Result<Option<SocialItemThumbnail>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Thumbnail)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SocialItemThumbnail::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SocialFeedSharedItem: ISocialFeedSharedItem}
impl RtActivatable<IActivationFactory> for SocialFeedSharedItem {}
DEFINE_CLSID!(SocialFeedSharedItem(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,83,111,99,105,97,108,73,110,102,111,46,83,111,99,105,97,108,70,101,101,100,83,104,97,114,101,100,73,116,101,109,0]) [CLSID_SocialFeedSharedItem]);
RT_ENUM! { enum SocialFeedUpdateMode: i32 {
    Append = 0, Replace = 1,
}}
RT_ENUM! { enum SocialItemBadgeStyle: i32 {
    Hidden = 0, Visible = 1, VisibleWithCount = 2,
}}
DEFINE_IID!(IID_ISocialItemThumbnail, 1556054810, 16136, 18815, 145, 127, 87, 224, 157, 132, 177, 65);
RT_INTERFACE!{interface ISocialItemThumbnail(ISocialItemThumbnailVtbl): IInspectable [IID_ISocialItemThumbnail] {
    fn get_TargetUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_TargetUri(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_ImageUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_ImageUri(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_BitmapSize(&self, out: *mut super::super::graphics::imaging::BitmapSize) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-graphics")] fn put_BitmapSize(&self, value: super::super::graphics::imaging::BitmapSize) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SetImageAsync(&self, image: <super::super::storage::streams::IInputStream as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl ISocialItemThumbnail {
    #[inline] pub fn get_target_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TargetUri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_target_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_TargetUri)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_image_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ImageUri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_image_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ImageUri)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_bitmap_size(&self) -> Result<super::super::graphics::imaging::BitmapSize> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_BitmapSize)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_bitmap_size(&self, value: super::super::graphics::imaging::BitmapSize) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_BitmapSize)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_image_async(&self, image: &super::super::storage::streams::IInputStream) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SetImageAsync)(self.get_abi() as *const _ as *mut _, image.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SocialItemThumbnail: ISocialItemThumbnail}
impl RtActivatable<IActivationFactory> for SocialItemThumbnail {}
DEFINE_CLSID!(SocialItemThumbnail(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,83,111,99,105,97,108,73,110,102,111,46,83,111,99,105,97,108,73,116,101,109,84,104,117,109,98,110,97,105,108,0]) [CLSID_SocialItemThumbnail]);
DEFINE_IID!(IID_ISocialUserInfo, 2656967633, 37072, 19997, 149, 84, 132, 77, 70, 96, 127, 97);
RT_INTERFACE!{interface ISocialUserInfo(ISocialUserInfoVtbl): IInspectable [IID_ISocialUserInfo] {
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_UserName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_UserName(&self, value: HSTRING) -> HRESULT,
    fn get_RemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RemoteId(&self, value: HSTRING) -> HRESULT,
    fn get_TargetUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_TargetUri(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT
}}
impl ISocialUserInfo {
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_user_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_UserName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_user_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_UserName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_remote_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RemoteId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_remote_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RemoteId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_target_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TargetUri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_target_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_TargetUri)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SocialUserInfo: ISocialUserInfo}
pub mod provider { // Windows.ApplicationModel.SocialInfo.Provider
use crate::prelude::*;
DEFINE_IID!(IID_ISocialDashboardItemUpdater, 1021222345, 18432, 18125, 134, 155, 25, 115, 236, 104, 91, 222);
RT_INTERFACE!{interface ISocialDashboardItemUpdater(ISocialDashboardItemUpdaterVtbl): IInspectable [IID_ISocialDashboardItemUpdater] {
    fn get_OwnerRemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Content(&self, out: *mut <super::SocialFeedContent as RtType>::Abi) -> HRESULT,
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn put_Timestamp(&self, value: foundation::DateTime) -> HRESULT,
    fn put_Thumbnail(&self, value: <super::SocialItemThumbnail as RtType>::Abi) -> HRESULT,
    fn get_Thumbnail(&self, out: *mut <super::SocialItemThumbnail as RtType>::Abi) -> HRESULT,
    fn CommitAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn get_TargetUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_TargetUri(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT
}}
impl ISocialDashboardItemUpdater {
    #[inline] pub fn get_owner_remote_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_OwnerRemoteId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_content(&self) -> Result<Option<super::SocialFeedContent>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Content)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::SocialFeedContent::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Timestamp)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_timestamp(&self, value: foundation::DateTime) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Timestamp)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_thumbnail(&self, value: &super::SocialItemThumbnail) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Thumbnail)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_thumbnail(&self) -> Result<Option<super::SocialItemThumbnail>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Thumbnail)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::SocialItemThumbnail::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn commit_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CommitAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_target_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TargetUri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_target_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_TargetUri)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SocialDashboardItemUpdater: ISocialDashboardItemUpdater}
DEFINE_IID!(IID_ISocialFeedUpdater, 2047609511, 60809, 19413, 168, 217, 21, 244, 217, 134, 28, 16);
RT_INTERFACE!{interface ISocialFeedUpdater(ISocialFeedUpdaterVtbl): IInspectable [IID_ISocialFeedUpdater] {
    fn get_OwnerRemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Kind(&self, out: *mut super::SocialFeedKind) -> HRESULT,
    fn get_Items(&self, out: *mut <foundation::collections::IVector<super::SocialFeedItem> as RtType>::Abi) -> HRESULT,
    fn CommitAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl ISocialFeedUpdater {
    #[inline] pub fn get_owner_remote_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_OwnerRemoteId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_kind(&self) -> Result<super::SocialFeedKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Kind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_items(&self) -> Result<Option<foundation::collections::IVector<super::SocialFeedItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Items)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn commit_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CommitAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SocialFeedUpdater: ISocialFeedUpdater}
RT_CLASS!{static class SocialInfoProviderManager}
impl RtActivatable<ISocialInfoProviderManagerStatics> for SocialInfoProviderManager {}
impl SocialInfoProviderManager {
    #[inline] pub fn create_social_feed_updater_async(kind: super::SocialFeedKind, mode: super::SocialFeedUpdateMode, ownerRemoteId: &HStringArg) -> Result<foundation::IAsyncOperation<SocialFeedUpdater>> {
        <Self as RtActivatable<ISocialInfoProviderManagerStatics>>::get_activation_factory().create_social_feed_updater_async(kind, mode, ownerRemoteId)
    }
    #[inline] pub fn create_dashboard_item_updater_async(ownerRemoteId: &HStringArg) -> Result<foundation::IAsyncOperation<SocialDashboardItemUpdater>> {
        <Self as RtActivatable<ISocialInfoProviderManagerStatics>>::get_activation_factory().create_dashboard_item_updater_async(ownerRemoteId)
    }
    #[inline] pub fn update_badge_count_value(itemRemoteId: &HStringArg, newCount: i32) -> Result<()> {
        <Self as RtActivatable<ISocialInfoProviderManagerStatics>>::get_activation_factory().update_badge_count_value(itemRemoteId, newCount)
    }
    #[inline] pub fn report_new_content_available(contactRemoteId: &HStringArg, kind: super::SocialFeedKind) -> Result<()> {
        <Self as RtActivatable<ISocialInfoProviderManagerStatics>>::get_activation_factory().report_new_content_available(contactRemoteId, kind)
    }
    #[inline] pub fn provision_async() -> Result<foundation::IAsyncOperation<bool>> {
        <Self as RtActivatable<ISocialInfoProviderManagerStatics>>::get_activation_factory().provision_async()
    }
    #[inline] pub fn deprovision_async() -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<ISocialInfoProviderManagerStatics>>::get_activation_factory().deprovision_async()
    }
}
DEFINE_CLSID!(SocialInfoProviderManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,83,111,99,105,97,108,73,110,102,111,46,80,114,111,118,105,100,101,114,46,83,111,99,105,97,108,73,110,102,111,80,114,111,118,105,100,101,114,77,97,110,97,103,101,114,0]) [CLSID_SocialInfoProviderManager]);
DEFINE_IID!(IID_ISocialInfoProviderManagerStatics, 461956395, 30599, 18646, 170, 18, 216, 232, 244, 122, 184, 90);
RT_INTERFACE!{static interface ISocialInfoProviderManagerStatics(ISocialInfoProviderManagerStaticsVtbl): IInspectable [IID_ISocialInfoProviderManagerStatics] {
    fn CreateSocialFeedUpdaterAsync(&self, kind: super::SocialFeedKind, mode: super::SocialFeedUpdateMode, ownerRemoteId: HSTRING, out: *mut <foundation::IAsyncOperation<SocialFeedUpdater> as RtType>::Abi) -> HRESULT,
    fn CreateDashboardItemUpdaterAsync(&self, ownerRemoteId: HSTRING, out: *mut <foundation::IAsyncOperation<SocialDashboardItemUpdater> as RtType>::Abi) -> HRESULT,
    fn UpdateBadgeCountValue(&self, itemRemoteId: HSTRING, newCount: i32) -> HRESULT,
    fn ReportNewContentAvailable(&self, contactRemoteId: HSTRING, kind: super::SocialFeedKind) -> HRESULT,
    fn ProvisionAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn DeprovisionAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl ISocialInfoProviderManagerStatics {
    #[inline] pub fn create_social_feed_updater_async(&self, kind: super::SocialFeedKind, mode: super::SocialFeedUpdateMode, ownerRemoteId: &HStringArg) -> Result<foundation::IAsyncOperation<SocialFeedUpdater>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateSocialFeedUpdaterAsync)(self.get_abi() as *const _ as *mut _, kind, mode, ownerRemoteId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_dashboard_item_updater_async(&self, ownerRemoteId: &HStringArg) -> Result<foundation::IAsyncOperation<SocialDashboardItemUpdater>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateDashboardItemUpdaterAsync)(self.get_abi() as *const _ as *mut _, ownerRemoteId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn update_badge_count_value(&self, itemRemoteId: &HStringArg, newCount: i32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().UpdateBadgeCountValue)(self.get_abi() as *const _ as *mut _, itemRemoteId.get(), newCount);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn report_new_content_available(&self, contactRemoteId: &HStringArg, kind: super::SocialFeedKind) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportNewContentAvailable)(self.get_abi() as *const _ as *mut _, contactRemoteId.get(), kind);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn provision_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ProvisionAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn deprovision_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeprovisionAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
} // Windows.ApplicationModel.SocialInfo.Provider
} // Windows.ApplicationModel.SocialInfo
pub mod store { // Windows.ApplicationModel.Store
use crate::prelude::*;
DEFINE_IID!(IID_ICurrentApp, 3576545381, 55871, 18053, 153, 94, 155, 72, 46, 181, 230, 3);
RT_INTERFACE!{static interface ICurrentApp(ICurrentAppVtbl): IInspectable [IID_ICurrentApp] {
    fn get_LicenseInformation(&self, out: *mut <LicenseInformation as RtType>::Abi) -> HRESULT,
    fn get_LinkUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_AppId(&self, out: *mut Guid) -> HRESULT,
    fn RequestAppPurchaseAsync(&self, includeReceipt: bool, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn RequestProductPurchaseAsync(&self, productId: HSTRING, includeReceipt: bool, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn LoadListingInformationAsync(&self, out: *mut <foundation::IAsyncOperation<ListingInformation> as RtType>::Abi) -> HRESULT,
    fn GetAppReceiptAsync(&self, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn GetProductReceiptAsync(&self, productId: HSTRING, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT
}}
impl ICurrentApp {
    #[inline] pub fn get_license_information(&self) -> Result<Option<LicenseInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LicenseInformation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(LicenseInformation::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_link_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LinkUri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_app_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AppId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn request_app_purchase_async(&self, includeReceipt: bool) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestAppPurchaseAsync)(self.get_abi() as *const _ as *mut _, includeReceipt, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_product_purchase_async(&self, productId: &HStringArg, includeReceipt: bool) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestProductPurchaseAsync)(self.get_abi() as *const _ as *mut _, productId.get(), includeReceipt, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn load_listing_information_async(&self) -> Result<foundation::IAsyncOperation<ListingInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().LoadListingInformationAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_app_receipt_async(&self) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetAppReceiptAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_product_receipt_async(&self, productId: &HStringArg) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetProductReceiptAsync)(self.get_abi() as *const _ as *mut _, productId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class CurrentApp}
impl RtActivatable<ICurrentApp> for CurrentApp {}
impl RtActivatable<ICurrentApp2Statics> for CurrentApp {}
impl RtActivatable<ICurrentAppStaticsWithFiltering> for CurrentApp {}
impl RtActivatable<ICurrentAppWithCampaignId> for CurrentApp {}
impl RtActivatable<ICurrentAppWithConsumables> for CurrentApp {}
impl CurrentApp {
    #[inline] pub fn get_license_information() -> Result<Option<LicenseInformation>> {
        <Self as RtActivatable<ICurrentApp>>::get_activation_factory().get_license_information()
    }
    #[inline] pub fn get_link_uri() -> Result<Option<foundation::Uri>> {
        <Self as RtActivatable<ICurrentApp>>::get_activation_factory().get_link_uri()
    }
    #[inline] pub fn get_app_id() -> Result<Guid> {
        <Self as RtActivatable<ICurrentApp>>::get_activation_factory().get_app_id()
    }
    #[inline] pub fn request_app_purchase_async(includeReceipt: bool) -> Result<foundation::IAsyncOperation<HString>> {
        <Self as RtActivatable<ICurrentApp>>::get_activation_factory().request_app_purchase_async(includeReceipt)
    }
    #[inline] pub fn request_product_purchase_async(productId: &HStringArg, includeReceipt: bool) -> Result<foundation::IAsyncOperation<HString>> {
        <Self as RtActivatable<ICurrentApp>>::get_activation_factory().request_product_purchase_async(productId, includeReceipt)
    }
    #[inline] pub fn load_listing_information_async() -> Result<foundation::IAsyncOperation<ListingInformation>> {
        <Self as RtActivatable<ICurrentApp>>::get_activation_factory().load_listing_information_async()
    }
    #[inline] pub fn get_app_receipt_async() -> Result<foundation::IAsyncOperation<HString>> {
        <Self as RtActivatable<ICurrentApp>>::get_activation_factory().get_app_receipt_async()
    }
    #[inline] pub fn get_product_receipt_async(productId: &HStringArg) -> Result<foundation::IAsyncOperation<HString>> {
        <Self as RtActivatable<ICurrentApp>>::get_activation_factory().get_product_receipt_async(productId)
    }
    #[inline] pub fn get_customer_purchase_id_async(serviceTicket: &HStringArg, publisherUserId: &HStringArg) -> Result<foundation::IAsyncOperation<HString>> {
        <Self as RtActivatable<ICurrentApp2Statics>>::get_activation_factory().get_customer_purchase_id_async(serviceTicket, publisherUserId)
    }
    #[inline] pub fn get_customer_collections_id_async(serviceTicket: &HStringArg, publisherUserId: &HStringArg) -> Result<foundation::IAsyncOperation<HString>> {
        <Self as RtActivatable<ICurrentApp2Statics>>::get_activation_factory().get_customer_collections_id_async(serviceTicket, publisherUserId)
    }
    #[inline] pub fn load_listing_information_by_product_ids_async(productIds: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<ListingInformation>> {
        <Self as RtActivatable<ICurrentAppStaticsWithFiltering>>::get_activation_factory().load_listing_information_by_product_ids_async(productIds)
    }
    #[inline] pub fn load_listing_information_by_keywords_async(keywords: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<ListingInformation>> {
        <Self as RtActivatable<ICurrentAppStaticsWithFiltering>>::get_activation_factory().load_listing_information_by_keywords_async(keywords)
    }
    #[inline] pub fn report_product_fulfillment(productId: &HStringArg) -> Result<()> {
        <Self as RtActivatable<ICurrentAppStaticsWithFiltering>>::get_activation_factory().report_product_fulfillment(productId)
    }
    #[inline] pub fn get_app_purchase_campaign_id_async() -> Result<foundation::IAsyncOperation<HString>> {
        <Self as RtActivatable<ICurrentAppWithCampaignId>>::get_activation_factory().get_app_purchase_campaign_id_async()
    }
    #[inline] pub fn report_consumable_fulfillment_async(productId: &HStringArg, transactionId: Guid) -> Result<foundation::IAsyncOperation<FulfillmentResult>> {
        <Self as RtActivatable<ICurrentAppWithConsumables>>::get_activation_factory().report_consumable_fulfillment_async(productId, transactionId)
    }
    #[inline] pub fn request_product_purchase_with_results_async(productId: &HStringArg) -> Result<foundation::IAsyncOperation<PurchaseResults>> {
        <Self as RtActivatable<ICurrentAppWithConsumables>>::get_activation_factory().request_product_purchase_with_results_async(productId)
    }
    #[inline] pub fn request_product_purchase_with_display_properties_async(productId: &HStringArg, offerId: &HStringArg, displayProperties: &ProductPurchaseDisplayProperties) -> Result<foundation::IAsyncOperation<PurchaseResults>> {
        <Self as RtActivatable<ICurrentAppWithConsumables>>::get_activation_factory().request_product_purchase_with_display_properties_async(productId, offerId, displayProperties)
    }
    #[inline] pub fn get_unfulfilled_consumables_async() -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<UnfulfilledConsumable>>> {
        <Self as RtActivatable<ICurrentAppWithConsumables>>::get_activation_factory().get_unfulfilled_consumables_async()
    }
}
DEFINE_CLSID!(CurrentApp(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,83,116,111,114,101,46,67,117,114,114,101,110,116,65,112,112,0]) [CLSID_CurrentApp]);
DEFINE_IID!(IID_ICurrentApp2Statics, 3746459181, 12657, 19155, 134, 20, 44, 97, 36, 67, 115, 203);
RT_INTERFACE!{static interface ICurrentApp2Statics(ICurrentApp2StaticsVtbl): IInspectable [IID_ICurrentApp2Statics] {
    fn GetCustomerPurchaseIdAsync(&self, serviceTicket: HSTRING, publisherUserId: HSTRING, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn GetCustomerCollectionsIdAsync(&self, serviceTicket: HSTRING, publisherUserId: HSTRING, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT
}}
impl ICurrentApp2Statics {
    #[inline] pub fn get_customer_purchase_id_async(&self, serviceTicket: &HStringArg, publisherUserId: &HStringArg) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetCustomerPurchaseIdAsync)(self.get_abi() as *const _ as *mut _, serviceTicket.get(), publisherUserId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_customer_collections_id_async(&self, serviceTicket: &HStringArg, publisherUserId: &HStringArg) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetCustomerCollectionsIdAsync)(self.get_abi() as *const _ as *mut _, serviceTicket.get(), publisherUserId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICurrentAppSimulator, 4051672497, 29901, 18311, 151, 135, 25, 134, 110, 154, 85, 89);
RT_INTERFACE!{static interface ICurrentAppSimulator(ICurrentAppSimulatorVtbl): IInspectable [IID_ICurrentAppSimulator] {
    fn get_LicenseInformation(&self, out: *mut <LicenseInformation as RtType>::Abi) -> HRESULT,
    fn get_LinkUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_AppId(&self, out: *mut Guid) -> HRESULT,
    fn RequestAppPurchaseAsync(&self, includeReceipt: bool, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn RequestProductPurchaseAsync(&self, productId: HSTRING, includeReceipt: bool, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn LoadListingInformationAsync(&self, out: *mut <foundation::IAsyncOperation<ListingInformation> as RtType>::Abi) -> HRESULT,
    fn GetAppReceiptAsync(&self, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn GetProductReceiptAsync(&self, productId: HSTRING, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn ReloadSimulatorAsync(&self, simulatorSettingsFile: <super::super::storage::StorageFile as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl ICurrentAppSimulator {
    #[inline] pub fn get_license_information(&self) -> Result<Option<LicenseInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LicenseInformation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(LicenseInformation::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_link_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LinkUri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_app_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AppId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn request_app_purchase_async(&self, includeReceipt: bool) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestAppPurchaseAsync)(self.get_abi() as *const _ as *mut _, includeReceipt, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_product_purchase_async(&self, productId: &HStringArg, includeReceipt: bool) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestProductPurchaseAsync)(self.get_abi() as *const _ as *mut _, productId.get(), includeReceipt, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn load_listing_information_async(&self) -> Result<foundation::IAsyncOperation<ListingInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().LoadListingInformationAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_app_receipt_async(&self) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetAppReceiptAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_product_receipt_async(&self, productId: &HStringArg) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetProductReceiptAsync)(self.get_abi() as *const _ as *mut _, productId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn reload_simulator_async(&self, simulatorSettingsFile: &super::super::storage::StorageFile) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReloadSimulatorAsync)(self.get_abi() as *const _ as *mut _, simulatorSettingsFile.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class CurrentAppSimulator}
impl RtActivatable<ICurrentAppSimulator> for CurrentAppSimulator {}
impl RtActivatable<ICurrentAppSimulatorStaticsWithFiltering> for CurrentAppSimulator {}
impl RtActivatable<ICurrentAppSimulatorWithCampaignId> for CurrentAppSimulator {}
impl RtActivatable<ICurrentAppSimulatorWithConsumables> for CurrentAppSimulator {}
impl CurrentAppSimulator {
    #[inline] pub fn get_license_information() -> Result<Option<LicenseInformation>> {
        <Self as RtActivatable<ICurrentAppSimulator>>::get_activation_factory().get_license_information()
    }
    #[inline] pub fn get_link_uri() -> Result<Option<foundation::Uri>> {
        <Self as RtActivatable<ICurrentAppSimulator>>::get_activation_factory().get_link_uri()
    }
    #[inline] pub fn get_app_id() -> Result<Guid> {
        <Self as RtActivatable<ICurrentAppSimulator>>::get_activation_factory().get_app_id()
    }
    #[inline] pub fn request_app_purchase_async(includeReceipt: bool) -> Result<foundation::IAsyncOperation<HString>> {
        <Self as RtActivatable<ICurrentAppSimulator>>::get_activation_factory().request_app_purchase_async(includeReceipt)
    }
    #[inline] pub fn request_product_purchase_async(productId: &HStringArg, includeReceipt: bool) -> Result<foundation::IAsyncOperation<HString>> {
        <Self as RtActivatable<ICurrentAppSimulator>>::get_activation_factory().request_product_purchase_async(productId, includeReceipt)
    }
    #[inline] pub fn load_listing_information_async() -> Result<foundation::IAsyncOperation<ListingInformation>> {
        <Self as RtActivatable<ICurrentAppSimulator>>::get_activation_factory().load_listing_information_async()
    }
    #[inline] pub fn get_app_receipt_async() -> Result<foundation::IAsyncOperation<HString>> {
        <Self as RtActivatable<ICurrentAppSimulator>>::get_activation_factory().get_app_receipt_async()
    }
    #[inline] pub fn get_product_receipt_async(productId: &HStringArg) -> Result<foundation::IAsyncOperation<HString>> {
        <Self as RtActivatable<ICurrentAppSimulator>>::get_activation_factory().get_product_receipt_async(productId)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn reload_simulator_async(simulatorSettingsFile: &super::super::storage::StorageFile) -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<ICurrentAppSimulator>>::get_activation_factory().reload_simulator_async(simulatorSettingsFile)
    }
    #[inline] pub fn load_listing_information_by_product_ids_async(productIds: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<ListingInformation>> {
        <Self as RtActivatable<ICurrentAppSimulatorStaticsWithFiltering>>::get_activation_factory().load_listing_information_by_product_ids_async(productIds)
    }
    #[inline] pub fn load_listing_information_by_keywords_async(keywords: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<ListingInformation>> {
        <Self as RtActivatable<ICurrentAppSimulatorStaticsWithFiltering>>::get_activation_factory().load_listing_information_by_keywords_async(keywords)
    }
    #[inline] pub fn get_app_purchase_campaign_id_async() -> Result<foundation::IAsyncOperation<HString>> {
        <Self as RtActivatable<ICurrentAppSimulatorWithCampaignId>>::get_activation_factory().get_app_purchase_campaign_id_async()
    }
    #[inline] pub fn report_consumable_fulfillment_async(productId: &HStringArg, transactionId: Guid) -> Result<foundation::IAsyncOperation<FulfillmentResult>> {
        <Self as RtActivatable<ICurrentAppSimulatorWithConsumables>>::get_activation_factory().report_consumable_fulfillment_async(productId, transactionId)
    }
    #[inline] pub fn request_product_purchase_with_results_async(productId: &HStringArg) -> Result<foundation::IAsyncOperation<PurchaseResults>> {
        <Self as RtActivatable<ICurrentAppSimulatorWithConsumables>>::get_activation_factory().request_product_purchase_with_results_async(productId)
    }
    #[inline] pub fn request_product_purchase_with_display_properties_async(productId: &HStringArg, offerId: &HStringArg, displayProperties: &ProductPurchaseDisplayProperties) -> Result<foundation::IAsyncOperation<PurchaseResults>> {
        <Self as RtActivatable<ICurrentAppSimulatorWithConsumables>>::get_activation_factory().request_product_purchase_with_display_properties_async(productId, offerId, displayProperties)
    }
    #[inline] pub fn get_unfulfilled_consumables_async() -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<UnfulfilledConsumable>>> {
        <Self as RtActivatable<ICurrentAppSimulatorWithConsumables>>::get_activation_factory().get_unfulfilled_consumables_async()
    }
}
DEFINE_CLSID!(CurrentAppSimulator(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,83,116,111,114,101,46,67,117,114,114,101,110,116,65,112,112,83,105,109,117,108,97,116,111,114,0]) [CLSID_CurrentAppSimulator]);
DEFINE_IID!(IID_ICurrentAppSimulatorStaticsWithFiltering, 1635676386, 63599, 19284, 150, 102, 221, 226, 133, 9, 44, 104);
RT_INTERFACE!{static interface ICurrentAppSimulatorStaticsWithFiltering(ICurrentAppSimulatorStaticsWithFilteringVtbl): IInspectable [IID_ICurrentAppSimulatorStaticsWithFiltering] {
    fn LoadListingInformationByProductIdsAsync(&self, productIds: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<ListingInformation> as RtType>::Abi) -> HRESULT,
    fn LoadListingInformationByKeywordsAsync(&self, keywords: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<ListingInformation> as RtType>::Abi) -> HRESULT
}}
impl ICurrentAppSimulatorStaticsWithFiltering {
    #[inline] pub fn load_listing_information_by_product_ids_async(&self, productIds: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<ListingInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().LoadListingInformationByProductIdsAsync)(self.get_abi() as *const _ as *mut _, productIds.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn load_listing_information_by_keywords_async(&self, keywords: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<ListingInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().LoadListingInformationByKeywordsAsync)(self.get_abi() as *const _ as *mut _, keywords.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICurrentAppSimulatorWithCampaignId, 2221378115, 57088, 18034, 164, 63, 178, 91, 20, 65, 207, 207);
RT_INTERFACE!{static interface ICurrentAppSimulatorWithCampaignId(ICurrentAppSimulatorWithCampaignIdVtbl): IInspectable [IID_ICurrentAppSimulatorWithCampaignId] {
    fn GetAppPurchaseCampaignIdAsync(&self, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT
}}
impl ICurrentAppSimulatorWithCampaignId {
    #[inline] pub fn get_app_purchase_campaign_id_async(&self) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetAppPurchaseCampaignIdAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICurrentAppSimulatorWithConsumables, 1313992875, 8423, 17426, 155, 133, 89, 187, 120, 56, 134, 103);
RT_INTERFACE!{static interface ICurrentAppSimulatorWithConsumables(ICurrentAppSimulatorWithConsumablesVtbl): IInspectable [IID_ICurrentAppSimulatorWithConsumables] {
    fn ReportConsumableFulfillmentAsync(&self, productId: HSTRING, transactionId: Guid, out: *mut <foundation::IAsyncOperation<FulfillmentResult> as RtType>::Abi) -> HRESULT,
    fn RequestProductPurchaseWithResultsAsync(&self, productId: HSTRING, out: *mut <foundation::IAsyncOperation<PurchaseResults> as RtType>::Abi) -> HRESULT,
    fn RequestProductPurchaseWithDisplayPropertiesAsync(&self, productId: HSTRING, offerId: HSTRING, displayProperties: <ProductPurchaseDisplayProperties as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PurchaseResults> as RtType>::Abi) -> HRESULT,
    fn GetUnfulfilledConsumablesAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<UnfulfilledConsumable>> as RtType>::Abi) -> HRESULT
}}
impl ICurrentAppSimulatorWithConsumables {
    #[inline] pub fn report_consumable_fulfillment_async(&self, productId: &HStringArg, transactionId: Guid) -> Result<foundation::IAsyncOperation<FulfillmentResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportConsumableFulfillmentAsync)(self.get_abi() as *const _ as *mut _, productId.get(), transactionId, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_product_purchase_with_results_async(&self, productId: &HStringArg) -> Result<foundation::IAsyncOperation<PurchaseResults>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestProductPurchaseWithResultsAsync)(self.get_abi() as *const _ as *mut _, productId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_product_purchase_with_display_properties_async(&self, productId: &HStringArg, offerId: &HStringArg, displayProperties: &ProductPurchaseDisplayProperties) -> Result<foundation::IAsyncOperation<PurchaseResults>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestProductPurchaseWithDisplayPropertiesAsync)(self.get_abi() as *const _ as *mut _, productId.get(), offerId.get(), displayProperties.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_unfulfilled_consumables_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<UnfulfilledConsumable>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetUnfulfilledConsumablesAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICurrentAppStaticsWithFiltering, 3547161922, 36997, 17294, 151, 186, 162, 92, 151, 107, 226, 253);
RT_INTERFACE!{static interface ICurrentAppStaticsWithFiltering(ICurrentAppStaticsWithFilteringVtbl): IInspectable [IID_ICurrentAppStaticsWithFiltering] {
    fn LoadListingInformationByProductIdsAsync(&self, productIds: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<ListingInformation> as RtType>::Abi) -> HRESULT,
    fn LoadListingInformationByKeywordsAsync(&self, keywords: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<ListingInformation> as RtType>::Abi) -> HRESULT,
    fn ReportProductFulfillment(&self, productId: HSTRING) -> HRESULT
}}
impl ICurrentAppStaticsWithFiltering {
    #[inline] pub fn load_listing_information_by_product_ids_async(&self, productIds: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<ListingInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().LoadListingInformationByProductIdsAsync)(self.get_abi() as *const _ as *mut _, productIds.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn load_listing_information_by_keywords_async(&self, keywords: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<ListingInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().LoadListingInformationByKeywordsAsync)(self.get_abi() as *const _ as *mut _, keywords.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_product_fulfillment(&self, productId: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportProductFulfillment)(self.get_abi() as *const _ as *mut _, productId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICurrentAppWithCampaignId, 825183440, 14017, 17574, 179, 43, 67, 45, 96, 142, 77, 214);
RT_INTERFACE!{static interface ICurrentAppWithCampaignId(ICurrentAppWithCampaignIdVtbl): IInspectable [IID_ICurrentAppWithCampaignId] {
    fn GetAppPurchaseCampaignIdAsync(&self, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT
}}
impl ICurrentAppWithCampaignId {
    #[inline] pub fn get_app_purchase_campaign_id_async(&self) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetAppPurchaseCampaignIdAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICurrentAppWithConsumables, 2219704433, 40527, 20345, 153, 90, 95, 145, 23, 46, 108, 239);
RT_INTERFACE!{static interface ICurrentAppWithConsumables(ICurrentAppWithConsumablesVtbl): IInspectable [IID_ICurrentAppWithConsumables] {
    fn ReportConsumableFulfillmentAsync(&self, productId: HSTRING, transactionId: Guid, out: *mut <foundation::IAsyncOperation<FulfillmentResult> as RtType>::Abi) -> HRESULT,
    fn RequestProductPurchaseWithResultsAsync(&self, productId: HSTRING, out: *mut <foundation::IAsyncOperation<PurchaseResults> as RtType>::Abi) -> HRESULT,
    fn RequestProductPurchaseWithDisplayPropertiesAsync(&self, productId: HSTRING, offerId: HSTRING, displayProperties: <ProductPurchaseDisplayProperties as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PurchaseResults> as RtType>::Abi) -> HRESULT,
    fn GetUnfulfilledConsumablesAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<UnfulfilledConsumable>> as RtType>::Abi) -> HRESULT
}}
impl ICurrentAppWithConsumables {
    #[inline] pub fn report_consumable_fulfillment_async(&self, productId: &HStringArg, transactionId: Guid) -> Result<foundation::IAsyncOperation<FulfillmentResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportConsumableFulfillmentAsync)(self.get_abi() as *const _ as *mut _, productId.get(), transactionId, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_product_purchase_with_results_async(&self, productId: &HStringArg) -> Result<foundation::IAsyncOperation<PurchaseResults>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestProductPurchaseWithResultsAsync)(self.get_abi() as *const _ as *mut _, productId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_product_purchase_with_display_properties_async(&self, productId: &HStringArg, offerId: &HStringArg, displayProperties: &ProductPurchaseDisplayProperties) -> Result<foundation::IAsyncOperation<PurchaseResults>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestProductPurchaseWithDisplayPropertiesAsync)(self.get_abi() as *const _ as *mut _, productId.get(), offerId.get(), displayProperties.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_unfulfilled_consumables_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<UnfulfilledConsumable>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetUnfulfilledConsumablesAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum FulfillmentResult: i32 {
    Succeeded = 0, NothingToFulfill = 1, PurchasePending = 2, PurchaseReverted = 3, ServerError = 4,
}}
DEFINE_IID!(IID_LicenseChangedEventHandler, 3567583829, 4969, 19510, 131, 47, 111, 45, 136, 227, 101, 155);
RT_DELEGATE!{delegate LicenseChangedEventHandler(LicenseChangedEventHandlerVtbl, LicenseChangedEventHandlerImpl) [IID_LicenseChangedEventHandler] {
    fn Invoke(&self) -> HRESULT
}}
impl LicenseChangedEventHandler {
    #[inline] pub fn invoke(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Invoke)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILicenseInformation, 2394414128, 61808, 20181, 142, 33, 21, 22, 218, 63, 211, 103);
RT_INTERFACE!{interface ILicenseInformation(ILicenseInformationVtbl): IInspectable [IID_ILicenseInformation] {
    fn get_ProductLicenses(&self, out: *mut <foundation::collections::IMapView<HString, ProductLicense> as RtType>::Abi) -> HRESULT,
    fn get_IsActive(&self, out: *mut bool) -> HRESULT,
    fn get_IsTrial(&self, out: *mut bool) -> HRESULT,
    fn get_ExpirationDate(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn add_LicenseChanged(&self, handler: <LicenseChangedEventHandler as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LicenseChanged(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ILicenseInformation {
    #[inline] pub fn get_product_licenses(&self) -> Result<Option<foundation::collections::IMapView<HString, ProductLicense>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ProductLicenses)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_active(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsActive)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_trial(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsTrial)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_expiration_date(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ExpirationDate)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_license_changed(&self, handler: &LicenseChangedEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_LicenseChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_license_changed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_LicenseChanged)(self.get_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LicenseInformation: ILicenseInformation}
DEFINE_IID!(IID_IListingInformation, 1485523647, 48244, 17283, 183, 140, 153, 96, 99, 35, 222, 206);
RT_INTERFACE!{interface IListingInformation(IListingInformationVtbl): IInspectable [IID_IListingInformation] {
    fn get_CurrentMarket(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ProductListings(&self, out: *mut <foundation::collections::IMapView<HString, ProductListing> as RtType>::Abi) -> HRESULT,
    fn get_FormattedPrice(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AgeRating(&self, out: *mut u32) -> HRESULT
}}
impl IListingInformation {
    #[inline] pub fn get_current_market(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CurrentMarket)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Description)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_product_listings(&self) -> Result<Option<foundation::collections::IMapView<HString, ProductListing>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ProductListings)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_formatted_price(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_FormattedPrice)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Name)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_age_rating(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AgeRating)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ListingInformation: IListingInformation}
DEFINE_IID!(IID_IListingInformation2, 3237817373, 45838, 17284, 132, 234, 114, 254, 250, 130, 34, 62);
RT_INTERFACE!{interface IListingInformation2(IListingInformation2Vtbl): IInspectable [IID_IListingInformation2] {
    fn get_FormattedBasePrice(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SaleEndDate(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_IsOnSale(&self, out: *mut bool) -> HRESULT,
    fn get_CurrencyCode(&self, out: *mut HSTRING) -> HRESULT
}}
impl IListingInformation2 {
    #[inline] pub fn get_formatted_base_price(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_FormattedBasePrice)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sale_end_date(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SaleEndDate)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_on_sale(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsOnSale)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_currency_code(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CurrencyCode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IProductLicense, 909314247, 11215, 19470, 143, 47, 232, 8, 170, 168, 249, 157);
RT_INTERFACE!{interface IProductLicense(IProductLicenseVtbl): IInspectable [IID_IProductLicense] {
    fn get_ProductId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsActive(&self, out: *mut bool) -> HRESULT,
    fn get_ExpirationDate(&self, out: *mut foundation::DateTime) -> HRESULT
}}
impl IProductLicense {
    #[inline] pub fn get_product_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ProductId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_active(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsActive)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_expiration_date(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ExpirationDate)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ProductLicense: IProductLicense}
DEFINE_IID!(IID_IProductLicenseWithFulfillment, 4233321610, 63079, 16627, 186, 60, 4, 90, 99, 171, 179, 172);
RT_INTERFACE!{interface IProductLicenseWithFulfillment(IProductLicenseWithFulfillmentVtbl): IInspectable [IID_IProductLicenseWithFulfillment] {
    fn get_IsConsumable(&self, out: *mut bool) -> HRESULT
}}
impl IProductLicenseWithFulfillment {
    #[inline] pub fn get_is_consumable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsConsumable)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IProductListing, 1168627373, 51024, 19868, 148, 124, 176, 13, 203, 249, 233, 194);
RT_INTERFACE!{interface IProductListing(IProductListingVtbl): IInspectable [IID_IProductListing] {
    fn get_ProductId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FormattedPrice(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT
}}
impl IProductListing {
    #[inline] pub fn get_product_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ProductId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_formatted_price(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_FormattedPrice)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Name)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ProductListing: IProductListing}
DEFINE_IID!(IID_IProductListing2, 4171114767, 29694, 18765, 169, 57, 8, 169, 178, 73, 90, 190);
RT_INTERFACE!{interface IProductListing2(IProductListing2Vtbl): IInspectable [IID_IProductListing2] {
    fn get_FormattedBasePrice(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SaleEndDate(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_IsOnSale(&self, out: *mut bool) -> HRESULT,
    fn get_CurrencyCode(&self, out: *mut HSTRING) -> HRESULT
}}
impl IProductListing2 {
    #[inline] pub fn get_formatted_base_price(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_FormattedBasePrice)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sale_end_date(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SaleEndDate)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_on_sale(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsOnSale)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_currency_code(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CurrencyCode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IProductListingWithConsumables, 3953039248, 36715, 18463, 147, 167, 92, 58, 99, 6, 129, 73);
RT_INTERFACE!{interface IProductListingWithConsumables(IProductListingWithConsumablesVtbl): IInspectable [IID_IProductListingWithConsumables] {
    fn get_ProductType(&self, out: *mut ProductType) -> HRESULT
}}
impl IProductListingWithConsumables {
    #[inline] pub fn get_product_type(&self) -> Result<ProductType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ProductType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IProductListingWithMetadata, 307078503, 9208, 16958, 149, 50, 24, 153, 67, 196, 10, 206);
RT_INTERFACE!{interface IProductListingWithMetadata(IProductListingWithMetadataVtbl): IInspectable [IID_IProductListingWithMetadata] {
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Keywords(&self, out: *mut <foundation::collections::IIterable<HString> as RtType>::Abi) -> HRESULT,
    fn get_ProductType(&self, out: *mut ProductType) -> HRESULT,
    fn get_Tag(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ImageUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT
}}
impl IProductListingWithMetadata {
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Description)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_keywords(&self) -> Result<Option<foundation::collections::IIterable<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Keywords)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IIterable::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_product_type(&self) -> Result<ProductType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ProductType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tag(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Tag)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_image_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ImageUri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IProductPurchaseDisplayProperties, 3607852064, 48274, 16411, 168, 9, 201, 178, 229, 219, 189, 175);
RT_INTERFACE!{interface IProductPurchaseDisplayProperties(IProductPurchaseDisplayPropertiesVtbl): IInspectable [IID_IProductPurchaseDisplayProperties] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT,
    fn get_Image(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_Image(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT
}}
impl IProductPurchaseDisplayProperties {
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Name)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Name)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Description)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_description(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Description)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_image(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Image)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_image(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Image)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ProductPurchaseDisplayProperties: IProductPurchaseDisplayProperties}
impl RtActivatable<IProductPurchaseDisplayPropertiesFactory> for ProductPurchaseDisplayProperties {}
impl RtActivatable<IActivationFactory> for ProductPurchaseDisplayProperties {}
impl ProductPurchaseDisplayProperties {
    #[inline] pub fn create_product_purchase_display_properties(name: &HStringArg) -> Result<ProductPurchaseDisplayProperties> {
        <Self as RtActivatable<IProductPurchaseDisplayPropertiesFactory>>::get_activation_factory().create_product_purchase_display_properties(name)
    }
}
DEFINE_CLSID!(ProductPurchaseDisplayProperties(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,83,116,111,114,101,46,80,114,111,100,117,99,116,80,117,114,99,104,97,115,101,68,105,115,112,108,97,121,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_ProductPurchaseDisplayProperties]);
DEFINE_IID!(IID_IProductPurchaseDisplayPropertiesFactory, 1867062772, 13014, 19264, 180, 116, 184, 48, 56, 164, 217, 207);
RT_INTERFACE!{static interface IProductPurchaseDisplayPropertiesFactory(IProductPurchaseDisplayPropertiesFactoryVtbl): IInspectable [IID_IProductPurchaseDisplayPropertiesFactory] {
    fn CreateProductPurchaseDisplayProperties(&self, name: HSTRING, out: *mut <ProductPurchaseDisplayProperties as RtType>::Abi) -> HRESULT
}}
impl IProductPurchaseDisplayPropertiesFactory {
    #[inline] pub fn create_product_purchase_display_properties(&self, name: &HStringArg) -> Result<ProductPurchaseDisplayProperties> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateProductPurchaseDisplayProperties)(self.get_abi() as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(ProductPurchaseDisplayProperties::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ProductPurchaseStatus: i32 {
    Succeeded = 0, AlreadyPurchased = 1, NotFulfilled = 2, NotPurchased = 3,
}}
RT_ENUM! { enum ProductType: i32 {
    Unknown = 0, Durable = 1, Consumable = 2,
}}
DEFINE_IID!(IID_IPurchaseResults, 3981489022, 34390, 20325, 184, 200, 172, 126, 12, 177, 161, 194);
RT_INTERFACE!{interface IPurchaseResults(IPurchaseResultsVtbl): IInspectable [IID_IPurchaseResults] {
    fn get_Status(&self, out: *mut ProductPurchaseStatus) -> HRESULT,
    fn get_TransactionId(&self, out: *mut Guid) -> HRESULT,
    fn get_ReceiptXml(&self, out: *mut HSTRING) -> HRESULT,
    fn get_OfferId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPurchaseResults {
    #[inline] pub fn get_status(&self) -> Result<ProductPurchaseStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_transaction_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_TransactionId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_receipt_xml(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ReceiptXml)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_offer_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_OfferId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PurchaseResults: IPurchaseResults}
DEFINE_IID!(IID_IUnfulfilledConsumable, 771226555, 7389, 19640, 160, 20, 123, 156, 248, 152, 105, 39);
RT_INTERFACE!{interface IUnfulfilledConsumable(IUnfulfilledConsumableVtbl): IInspectable [IID_IUnfulfilledConsumable] {
    fn get_ProductId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TransactionId(&self, out: *mut Guid) -> HRESULT,
    fn get_OfferId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IUnfulfilledConsumable {
    #[inline] pub fn get_product_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ProductId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_transaction_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_TransactionId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_offer_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_OfferId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UnfulfilledConsumable: IUnfulfilledConsumable}
pub mod licensemanagement { // Windows.ApplicationModel.Store.LicenseManagement
use crate::prelude::*;
RT_CLASS!{static class LicenseManager}
impl RtActivatable<ILicenseManagerStatics> for LicenseManager {}
impl RtActivatable<ILicenseManagerStatics2> for LicenseManager {}
impl LicenseManager {
    #[cfg(feature="windows-storage")] #[inline] pub fn add_license_async(license: &crate::windows::storage::streams::IBuffer) -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<ILicenseManagerStatics>>::get_activation_factory().add_license_async(license)
    }
    #[inline] pub fn get_satisfaction_infos_async(contentIds: &foundation::collections::IIterable<HString>, keyIds: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<LicenseSatisfactionResult>> {
        <Self as RtActivatable<ILicenseManagerStatics>>::get_activation_factory().get_satisfaction_infos_async(contentIds, keyIds)
    }
    #[inline] pub fn refresh_licenses_async(refreshOption: LicenseRefreshOption) -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<ILicenseManagerStatics2>>::get_activation_factory().refresh_licenses_async(refreshOption)
    }
}
DEFINE_CLSID!(LicenseManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,83,116,111,114,101,46,76,105,99,101,110,115,101,77,97,110,97,103,101,109,101,110,116,46,76,105,99,101,110,115,101,77,97,110,97,103,101,114,0]) [CLSID_LicenseManager]);
DEFINE_IID!(IID_ILicenseManagerStatics, 3047963360, 55879, 20256, 154, 35, 9, 24, 44, 148, 118, 255);
RT_INTERFACE!{static interface ILicenseManagerStatics(ILicenseManagerStaticsVtbl): IInspectable [IID_ILicenseManagerStatics] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn AddLicenseAsync(&self, license: <crate::windows::storage::streams::IBuffer as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn GetSatisfactionInfosAsync(&self, contentIds: <foundation::collections::IIterable<HString> as RtType>::Abi, keyIds: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<LicenseSatisfactionResult> as RtType>::Abi) -> HRESULT
}}
impl ILicenseManagerStatics {
    #[cfg(feature="windows-storage")] #[inline] pub fn add_license_async(&self, license: &crate::windows::storage::streams::IBuffer) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().AddLicenseAsync)(self.get_abi() as *const _ as *mut _, license.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_satisfaction_infos_async(&self, contentIds: &foundation::collections::IIterable<HString>, keyIds: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<LicenseSatisfactionResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetSatisfactionInfosAsync)(self.get_abi() as *const _ as *mut _, contentIds.get_abi() as *const _ as *mut _, keyIds.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILicenseManagerStatics2, 2871968891, 8057, 17536, 184, 126, 44, 73, 158, 96, 27, 163);
RT_INTERFACE!{static interface ILicenseManagerStatics2(ILicenseManagerStatics2Vtbl): IInspectable [IID_ILicenseManagerStatics2] {
    fn RefreshLicensesAsync(&self, refreshOption: LicenseRefreshOption, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl ILicenseManagerStatics2 {
    #[inline] pub fn refresh_licenses_async(&self, refreshOption: LicenseRefreshOption) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RefreshLicensesAsync)(self.get_abi() as *const _ as *mut _, refreshOption, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum LicenseRefreshOption: i32 {
    RunningLicenses = 0, AllLicenses = 1,
}}
DEFINE_IID!(IID_ILicenseSatisfactionInfo, 1019981967, 56113, 18645, 131, 132, 250, 23, 200, 20, 116, 226);
RT_INTERFACE!{interface ILicenseSatisfactionInfo(ILicenseSatisfactionInfoVtbl): IInspectable [IID_ILicenseSatisfactionInfo] {
    fn get_SatisfiedByDevice(&self, out: *mut bool) -> HRESULT,
    fn get_SatisfiedByOpenLicense(&self, out: *mut bool) -> HRESULT,
    fn get_SatisfiedByTrial(&self, out: *mut bool) -> HRESULT,
    fn get_SatisfiedByPass(&self, out: *mut bool) -> HRESULT,
    fn get_SatisfiedByInstallMedia(&self, out: *mut bool) -> HRESULT,
    fn get_SatisfiedBySignedInUser(&self, out: *mut bool) -> HRESULT,
    fn get_IsSatisfied(&self, out: *mut bool) -> HRESULT
}}
impl ILicenseSatisfactionInfo {
    #[inline] pub fn get_satisfied_by_device(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SatisfiedByDevice)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_satisfied_by_open_license(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SatisfiedByOpenLicense)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_satisfied_by_trial(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SatisfiedByTrial)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_satisfied_by_pass(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SatisfiedByPass)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_satisfied_by_install_media(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SatisfiedByInstallMedia)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_satisfied_by_signed_in_user(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SatisfiedBySignedInUser)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_satisfied(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsSatisfied)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class LicenseSatisfactionInfo: ILicenseSatisfactionInfo}
DEFINE_IID!(IID_ILicenseSatisfactionResult, 1013403507, 15495, 20193, 130, 1, 244, 40, 53, 155, 211, 175);
RT_INTERFACE!{interface ILicenseSatisfactionResult(ILicenseSatisfactionResultVtbl): IInspectable [IID_ILicenseSatisfactionResult] {
    fn get_LicenseSatisfactionInfos(&self, out: *mut <foundation::collections::IMapView<HString, LicenseSatisfactionInfo> as RtType>::Abi) -> HRESULT,
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl ILicenseSatisfactionResult {
    #[inline] pub fn get_license_satisfaction_infos(&self) -> Result<Option<foundation::collections::IMapView<HString, LicenseSatisfactionInfo>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LicenseSatisfactionInfos)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ExtendedError)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class LicenseSatisfactionResult: ILicenseSatisfactionResult}
} // Windows.ApplicationModel.Store.LicenseManagement
pub mod preview { // Windows.ApplicationModel.Store.Preview
use crate::prelude::*;
RT_ENUM! { enum DeliveryOptimizationDownloadMode: i32 {
    Simple = 0, HttpOnly = 1, Lan = 2, Group = 3, Internet = 4, Bypass = 5,
}}
RT_ENUM! { enum DeliveryOptimizationDownloadModeSource: i32 {
    Default = 0, Policy = 1,
}}
DEFINE_IID!(IID_IDeliveryOptimizationSettings, 403766688, 59475, 22110, 184, 116, 122, 138, 123, 154, 14, 15);
RT_INTERFACE!{interface IDeliveryOptimizationSettings(IDeliveryOptimizationSettingsVtbl): IInspectable [IID_IDeliveryOptimizationSettings] {
    fn get_DownloadMode(&self, out: *mut DeliveryOptimizationDownloadMode) -> HRESULT,
    fn get_DownloadModeSource(&self, out: *mut DeliveryOptimizationDownloadModeSource) -> HRESULT
}}
impl IDeliveryOptimizationSettings {
    #[inline] pub fn get_download_mode(&self) -> Result<DeliveryOptimizationDownloadMode> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DownloadMode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_download_mode_source(&self) -> Result<DeliveryOptimizationDownloadModeSource> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DownloadModeSource)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DeliveryOptimizationSettings: IDeliveryOptimizationSettings}
impl RtActivatable<IDeliveryOptimizationSettingsStatics> for DeliveryOptimizationSettings {}
impl DeliveryOptimizationSettings {
    #[inline] pub fn get_current_settings() -> Result<Option<DeliveryOptimizationSettings>> {
        <Self as RtActivatable<IDeliveryOptimizationSettingsStatics>>::get_activation_factory().get_current_settings()
    }
}
DEFINE_CLSID!(DeliveryOptimizationSettings(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,83,116,111,114,101,46,80,114,101,118,105,101,119,46,68,101,108,105,118,101,114,121,79,112,116,105,109,105,122,97,116,105,111,110,83,101,116,116,105,110,103,115,0]) [CLSID_DeliveryOptimizationSettings]);
DEFINE_IID!(IID_IDeliveryOptimizationSettingsStatics, 1551989935, 44757, 22937, 180, 201, 140, 96, 137, 139, 196, 243);
RT_INTERFACE!{static interface IDeliveryOptimizationSettingsStatics(IDeliveryOptimizationSettingsStaticsVtbl): IInspectable [IID_IDeliveryOptimizationSettingsStatics] {
    fn GetCurrentSettings(&self, out: *mut <DeliveryOptimizationSettings as RtType>::Abi) -> HRESULT
}}
impl IDeliveryOptimizationSettingsStatics {
    #[inline] pub fn get_current_settings(&self) -> Result<Option<DeliveryOptimizationSettings>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetCurrentSettings)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DeliveryOptimizationSettings::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class StoreConfiguration}
impl RtActivatable<IStoreConfigurationStatics> for StoreConfiguration {}
impl RtActivatable<IStoreConfigurationStatics2> for StoreConfiguration {}
impl RtActivatable<IStoreConfigurationStatics3> for StoreConfiguration {}
impl RtActivatable<IStoreConfigurationStatics4> for StoreConfiguration {}
impl RtActivatable<IStoreConfigurationStatics5> for StoreConfiguration {}
impl StoreConfiguration {
    #[inline] pub fn set_system_configuration(catalogHardwareManufacturerId: &HStringArg, catalogStoreContentModifierId: &HStringArg, systemConfigurationExpiration: foundation::DateTime, catalogHardwareDescriptor: &HStringArg) -> Result<()> {
        <Self as RtActivatable<IStoreConfigurationStatics>>::get_activation_factory().set_system_configuration(catalogHardwareManufacturerId, catalogStoreContentModifierId, systemConfigurationExpiration, catalogHardwareDescriptor)
    }
    #[inline] pub fn set_mobile_operator_configuration(mobileOperatorId: &HStringArg, appDownloadLimitInMegabytes: u32, updateDownloadLimitInMegabytes: u32) -> Result<()> {
        <Self as RtActivatable<IStoreConfigurationStatics>>::get_activation_factory().set_mobile_operator_configuration(mobileOperatorId, appDownloadLimitInMegabytes, updateDownloadLimitInMegabytes)
    }
    #[inline] pub fn set_store_web_account_id(webAccountId: &HStringArg) -> Result<()> {
        <Self as RtActivatable<IStoreConfigurationStatics>>::get_activation_factory().set_store_web_account_id(webAccountId)
    }
    #[inline] pub fn is_store_web_account_id(webAccountId: &HStringArg) -> Result<bool> {
        <Self as RtActivatable<IStoreConfigurationStatics>>::get_activation_factory().is_store_web_account_id(webAccountId)
    }
    #[inline] pub fn get_hardware_manufacturer_info() -> Result<Option<StoreHardwareManufacturerInfo>> {
        <Self as RtActivatable<IStoreConfigurationStatics>>::get_activation_factory().get_hardware_manufacturer_info()
    }
    #[inline] pub fn filter_unsupported_system_features_async(systemFeatures: &foundation::collections::IIterable<StoreSystemFeature>) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<StoreSystemFeature>>> {
        <Self as RtActivatable<IStoreConfigurationStatics>>::get_activation_factory().filter_unsupported_system_features_async(systemFeatures)
    }
    #[inline] pub fn get_purchase_prompting_policy() -> Result<Option<foundation::IReference<u32>>> {
        <Self as RtActivatable<IStoreConfigurationStatics2>>::get_activation_factory().get_purchase_prompting_policy()
    }
    #[inline] pub fn set_purchase_prompting_policy(value: &foundation::IReference<u32>) -> Result<()> {
        <Self as RtActivatable<IStoreConfigurationStatics2>>::get_activation_factory().set_purchase_prompting_policy(value)
    }
    #[inline] pub fn has_store_web_account() -> Result<bool> {
        <Self as RtActivatable<IStoreConfigurationStatics3>>::get_activation_factory().has_store_web_account()
    }
    #[cfg(feature="windows-system")] #[inline] pub fn has_store_web_account_for_user(user: &crate::windows::system::User) -> Result<bool> {
        <Self as RtActivatable<IStoreConfigurationStatics3>>::get_activation_factory().has_store_web_account_for_user(user)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn get_store_log_data_async(options: StoreLogOptions) -> Result<foundation::IAsyncOperation<crate::windows::storage::streams::IRandomAccessStreamReference>> {
        <Self as RtActivatable<IStoreConfigurationStatics3>>::get_activation_factory().get_store_log_data_async(options)
    }
    #[cfg(feature="windows-system")] #[inline] pub fn set_store_web_account_id_for_user(user: &crate::windows::system::User, webAccountId: &HStringArg) -> Result<()> {
        <Self as RtActivatable<IStoreConfigurationStatics3>>::get_activation_factory().set_store_web_account_id_for_user(user, webAccountId)
    }
    #[cfg(feature="windows-system")] #[inline] pub fn is_store_web_account_id_for_user(user: &crate::windows::system::User, webAccountId: &HStringArg) -> Result<bool> {
        <Self as RtActivatable<IStoreConfigurationStatics3>>::get_activation_factory().is_store_web_account_id_for_user(user, webAccountId)
    }
    #[cfg(feature="windows-system")] #[inline] pub fn get_purchase_prompting_policy_for_user(user: &crate::windows::system::User) -> Result<Option<foundation::IReference<u32>>> {
        <Self as RtActivatable<IStoreConfigurationStatics3>>::get_activation_factory().get_purchase_prompting_policy_for_user(user)
    }
    #[cfg(feature="windows-system")] #[inline] pub fn set_purchase_prompting_policy_for_user(user: &crate::windows::system::User, value: &foundation::IReference<u32>) -> Result<()> {
        <Self as RtActivatable<IStoreConfigurationStatics3>>::get_activation_factory().set_purchase_prompting_policy_for_user(user, value)
    }
    #[inline] pub fn get_store_web_account_id() -> Result<HString> {
        <Self as RtActivatable<IStoreConfigurationStatics4>>::get_activation_factory().get_store_web_account_id()
    }
    #[cfg(feature="windows-system")] #[inline] pub fn get_store_web_account_id_for_user(user: &crate::windows::system::User) -> Result<HString> {
        <Self as RtActivatable<IStoreConfigurationStatics4>>::get_activation_factory().get_store_web_account_id_for_user(user)
    }
    #[inline] pub fn set_enterprise_store_web_account_id(webAccountId: &HStringArg) -> Result<()> {
        <Self as RtActivatable<IStoreConfigurationStatics4>>::get_activation_factory().set_enterprise_store_web_account_id(webAccountId)
    }
    #[cfg(feature="windows-system")] #[inline] pub fn set_enterprise_store_web_account_id_for_user(user: &crate::windows::system::User, webAccountId: &HStringArg) -> Result<()> {
        <Self as RtActivatable<IStoreConfigurationStatics4>>::get_activation_factory().set_enterprise_store_web_account_id_for_user(user, webAccountId)
    }
    #[inline] pub fn get_enterprise_store_web_account_id() -> Result<HString> {
        <Self as RtActivatable<IStoreConfigurationStatics4>>::get_activation_factory().get_enterprise_store_web_account_id()
    }
    #[cfg(feature="windows-system")] #[inline] pub fn get_enterprise_store_web_account_id_for_user(user: &crate::windows::system::User) -> Result<HString> {
        <Self as RtActivatable<IStoreConfigurationStatics4>>::get_activation_factory().get_enterprise_store_web_account_id_for_user(user)
    }
    #[inline] pub fn should_restrict_to_enterprise_store_only() -> Result<bool> {
        <Self as RtActivatable<IStoreConfigurationStatics4>>::get_activation_factory().should_restrict_to_enterprise_store_only()
    }
    #[cfg(feature="windows-system")] #[inline] pub fn should_restrict_to_enterprise_store_only_for_user(user: &crate::windows::system::User) -> Result<bool> {
        <Self as RtActivatable<IStoreConfigurationStatics4>>::get_activation_factory().should_restrict_to_enterprise_store_only_for_user(user)
    }
    #[inline] pub fn is_pin_to_desktop_supported() -> Result<bool> {
        <Self as RtActivatable<IStoreConfigurationStatics5>>::get_activation_factory().is_pin_to_desktop_supported()
    }
    #[inline] pub fn is_pin_to_taskbar_supported() -> Result<bool> {
        <Self as RtActivatable<IStoreConfigurationStatics5>>::get_activation_factory().is_pin_to_taskbar_supported()
    }
    #[inline] pub fn is_pin_to_start_supported() -> Result<bool> {
        <Self as RtActivatable<IStoreConfigurationStatics5>>::get_activation_factory().is_pin_to_start_supported()
    }
    #[inline] pub fn pin_to_desktop(appPackageFamilyName: &HStringArg) -> Result<()> {
        <Self as RtActivatable<IStoreConfigurationStatics5>>::get_activation_factory().pin_to_desktop(appPackageFamilyName)
    }
    #[cfg(feature="windows-system")] #[inline] pub fn pin_to_desktop_for_user(user: &crate::windows::system::User, appPackageFamilyName: &HStringArg) -> Result<()> {
        <Self as RtActivatable<IStoreConfigurationStatics5>>::get_activation_factory().pin_to_desktop_for_user(user, appPackageFamilyName)
    }
}
DEFINE_CLSID!(StoreConfiguration(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,83,116,111,114,101,46,80,114,101,118,105,101,119,46,83,116,111,114,101,67,111,110,102,105,103,117,114,97,116,105,111,110,0]) [CLSID_StoreConfiguration]);
DEFINE_IID!(IID_IStoreConfigurationStatics, 1922006976, 34344, 17132, 132, 162, 7, 120, 14, 180, 77, 139);
RT_INTERFACE!{static interface IStoreConfigurationStatics(IStoreConfigurationStaticsVtbl): IInspectable [IID_IStoreConfigurationStatics] {
    fn SetSystemConfiguration(&self, catalogHardwareManufacturerId: HSTRING, catalogStoreContentModifierId: HSTRING, systemConfigurationExpiration: foundation::DateTime, catalogHardwareDescriptor: HSTRING) -> HRESULT,
    fn SetMobileOperatorConfiguration(&self, mobileOperatorId: HSTRING, appDownloadLimitInMegabytes: u32, updateDownloadLimitInMegabytes: u32) -> HRESULT,
    fn SetStoreWebAccountId(&self, webAccountId: HSTRING) -> HRESULT,
    fn IsStoreWebAccountId(&self, webAccountId: HSTRING, out: *mut bool) -> HRESULT,
    fn get_HardwareManufacturerInfo(&self, out: *mut <StoreHardwareManufacturerInfo as RtType>::Abi) -> HRESULT,
    fn FilterUnsupportedSystemFeaturesAsync(&self, systemFeatures: <foundation::collections::IIterable<StoreSystemFeature> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<StoreSystemFeature>> as RtType>::Abi) -> HRESULT
}}
impl IStoreConfigurationStatics {
    #[inline] pub fn set_system_configuration(&self, catalogHardwareManufacturerId: &HStringArg, catalogStoreContentModifierId: &HStringArg, systemConfigurationExpiration: foundation::DateTime, catalogHardwareDescriptor: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetSystemConfiguration)(self.get_abi() as *const _ as *mut _, catalogHardwareManufacturerId.get(), catalogStoreContentModifierId.get(), systemConfigurationExpiration, catalogHardwareDescriptor.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_mobile_operator_configuration(&self, mobileOperatorId: &HStringArg, appDownloadLimitInMegabytes: u32, updateDownloadLimitInMegabytes: u32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetMobileOperatorConfiguration)(self.get_abi() as *const _ as *mut _, mobileOperatorId.get(), appDownloadLimitInMegabytes, updateDownloadLimitInMegabytes);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_store_web_account_id(&self, webAccountId: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetStoreWebAccountId)(self.get_abi() as *const _ as *mut _, webAccountId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn is_store_web_account_id(&self, webAccountId: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().IsStoreWebAccountId)(self.get_abi() as *const _ as *mut _, webAccountId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_hardware_manufacturer_info(&self) -> Result<Option<StoreHardwareManufacturerInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_HardwareManufacturerInfo)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(StoreHardwareManufacturerInfo::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn filter_unsupported_system_features_async(&self, systemFeatures: &foundation::collections::IIterable<StoreSystemFeature>) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<StoreSystemFeature>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FilterUnsupportedSystemFeaturesAsync)(self.get_abi() as *const _ as *mut _, systemFeatures.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IStoreConfigurationStatics2, 1702643093, 51383, 20457, 159, 76, 77, 113, 2, 125, 52, 126);
RT_INTERFACE!{static interface IStoreConfigurationStatics2(IStoreConfigurationStatics2Vtbl): IInspectable [IID_IStoreConfigurationStatics2] {
    fn get_PurchasePromptingPolicy(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn put_PurchasePromptingPolicy(&self, value: <foundation::IReference<u32> as RtType>::Abi) -> HRESULT
}}
impl IStoreConfigurationStatics2 {
    #[inline] pub fn get_purchase_prompting_policy(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PurchasePromptingPolicy)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_purchase_prompting_policy(&self, value: &foundation::IReference<u32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_PurchasePromptingPolicy)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IStoreConfigurationStatics3, 1833301372, 61764, 19637, 157, 63, 78, 176, 94, 48, 182, 211);
RT_INTERFACE!{static interface IStoreConfigurationStatics3(IStoreConfigurationStatics3Vtbl): IInspectable [IID_IStoreConfigurationStatics3] {
    fn HasStoreWebAccount(&self, out: *mut bool) -> HRESULT,
    #[cfg(feature="windows-system")] fn HasStoreWebAccountForUser(&self, user: <crate::windows::system::User as RtType>::Abi, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn GetStoreLogDataAsync(&self, options: StoreLogOptions, out: *mut <foundation::IAsyncOperation<crate::windows::storage::streams::IRandomAccessStreamReference> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-system")] fn SetStoreWebAccountIdForUser(&self, user: <crate::windows::system::User as RtType>::Abi, webAccountId: HSTRING) -> HRESULT,
    #[cfg(feature="windows-system")] fn IsStoreWebAccountIdForUser(&self, user: <crate::windows::system::User as RtType>::Abi, webAccountId: HSTRING, out: *mut bool) -> HRESULT,
    #[cfg(feature="windows-system")] fn GetPurchasePromptingPolicyForUser(&self, user: <crate::windows::system::User as RtType>::Abi, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-system")] fn SetPurchasePromptingPolicyForUser(&self, user: <crate::windows::system::User as RtType>::Abi, value: <foundation::IReference<u32> as RtType>::Abi) -> HRESULT
}}
impl IStoreConfigurationStatics3 {
    #[inline] pub fn has_store_web_account(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().HasStoreWebAccount)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn has_store_web_account_for_user(&self, user: &crate::windows::system::User) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().HasStoreWebAccountForUser)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_store_log_data_async(&self, options: StoreLogOptions) -> Result<foundation::IAsyncOperation<crate::windows::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetStoreLogDataAsync)(self.get_abi() as *const _ as *mut _, options, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn set_store_web_account_id_for_user(&self, user: &crate::windows::system::User, webAccountId: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetStoreWebAccountIdForUser)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, webAccountId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn is_store_web_account_id_for_user(&self, user: &crate::windows::system::User, webAccountId: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().IsStoreWebAccountIdForUser)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, webAccountId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_purchase_prompting_policy_for_user(&self, user: &crate::windows::system::User) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetPurchasePromptingPolicyForUser)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn set_purchase_prompting_policy_for_user(&self, user: &crate::windows::system::User, value: &foundation::IReference<u32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetPurchasePromptingPolicyForUser)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IStoreConfigurationStatics4, 553604818, 20195, 19696, 155, 18, 85, 44, 3, 49, 15, 117);
RT_INTERFACE!{static interface IStoreConfigurationStatics4(IStoreConfigurationStatics4Vtbl): IInspectable [IID_IStoreConfigurationStatics4] {
    fn GetStoreWebAccountId(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(feature="windows-system")] fn GetStoreWebAccountIdForUser(&self, user: <crate::windows::system::User as RtType>::Abi, out: *mut HSTRING) -> HRESULT,
    fn SetEnterpriseStoreWebAccountId(&self, webAccountId: HSTRING) -> HRESULT,
    #[cfg(feature="windows-system")] fn SetEnterpriseStoreWebAccountIdForUser(&self, user: <crate::windows::system::User as RtType>::Abi, webAccountId: HSTRING) -> HRESULT,
    fn GetEnterpriseStoreWebAccountId(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(feature="windows-system")] fn GetEnterpriseStoreWebAccountIdForUser(&self, user: <crate::windows::system::User as RtType>::Abi, out: *mut HSTRING) -> HRESULT,
    fn ShouldRestrictToEnterpriseStoreOnly(&self, out: *mut bool) -> HRESULT,
    #[cfg(feature="windows-system")] fn ShouldRestrictToEnterpriseStoreOnlyForUser(&self, user: <crate::windows::system::User as RtType>::Abi, out: *mut bool) -> HRESULT
}}
impl IStoreConfigurationStatics4 {
    #[inline] pub fn get_store_web_account_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetStoreWebAccountId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_store_web_account_id_for_user(&self, user: &crate::windows::system::User) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetStoreWebAccountIdForUser)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_enterprise_store_web_account_id(&self, webAccountId: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetEnterpriseStoreWebAccountId)(self.get_abi() as *const _ as *mut _, webAccountId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn set_enterprise_store_web_account_id_for_user(&self, user: &crate::windows::system::User, webAccountId: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetEnterpriseStoreWebAccountIdForUser)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, webAccountId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_enterprise_store_web_account_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetEnterpriseStoreWebAccountId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_enterprise_store_web_account_id_for_user(&self, user: &crate::windows::system::User) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetEnterpriseStoreWebAccountIdForUser)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn should_restrict_to_enterprise_store_only(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().ShouldRestrictToEnterpriseStoreOnly)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn should_restrict_to_enterprise_store_only_for_user(&self, user: &crate::windows::system::User) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().ShouldRestrictToEnterpriseStoreOnlyForUser)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IStoreConfigurationStatics5, 4150342033, 36777, 18907, 130, 43, 1, 96, 231, 228, 229, 197);
RT_INTERFACE!{static interface IStoreConfigurationStatics5(IStoreConfigurationStatics5Vtbl): IInspectable [IID_IStoreConfigurationStatics5] {
    fn IsPinToDesktopSupported(&self, out: *mut bool) -> HRESULT,
    fn IsPinToTaskbarSupported(&self, out: *mut bool) -> HRESULT,
    fn IsPinToStartSupported(&self, out: *mut bool) -> HRESULT,
    fn PinToDesktop(&self, appPackageFamilyName: HSTRING) -> HRESULT,
    #[cfg(feature="windows-system")] fn PinToDesktopForUser(&self, user: <crate::windows::system::User as RtType>::Abi, appPackageFamilyName: HSTRING) -> HRESULT
}}
impl IStoreConfigurationStatics5 {
    #[inline] pub fn is_pin_to_desktop_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().IsPinToDesktopSupported)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_pin_to_taskbar_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().IsPinToTaskbarSupported)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_pin_to_start_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().IsPinToStartSupported)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn pin_to_desktop(&self, appPackageFamilyName: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().PinToDesktop)(self.get_abi() as *const _ as *mut _, appPackageFamilyName.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn pin_to_desktop_for_user(&self, user: &crate::windows::system::User, appPackageFamilyName: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().PinToDesktopForUser)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, appPackageFamilyName.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IStoreHardwareManufacturerInfo, 4069710856, 50772, 17324, 162, 31, 52, 128, 28, 157, 51, 136);
RT_INTERFACE!{interface IStoreHardwareManufacturerInfo(IStoreHardwareManufacturerInfoVtbl): IInspectable [IID_IStoreHardwareManufacturerInfo] {
    fn get_HardwareManufacturerId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_StoreContentModifierId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ModelName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ManufacturerName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IStoreHardwareManufacturerInfo {
    #[inline] pub fn get_hardware_manufacturer_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_HardwareManufacturerId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_store_content_modifier_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_StoreContentModifierId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_model_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ModelName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_manufacturer_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ManufacturerName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class StoreHardwareManufacturerInfo: IStoreHardwareManufacturerInfo}
RT_ENUM! { enum StoreLogOptions: u32 {
    None = 0, TryElevate = 1,
}}
DEFINE_IID!(IID_IStorePreview, 2316661313, 33806, 18857, 188, 1, 93, 91, 1, 251, 200, 233);
RT_INTERFACE!{static interface IStorePreview(IStorePreviewVtbl): IInspectable [IID_IStorePreview] {
    fn RequestProductPurchaseByProductIdAndSkuIdAsync(&self, productId: HSTRING, skuId: HSTRING, out: *mut <foundation::IAsyncOperation<StorePreviewPurchaseResults> as RtType>::Abi) -> HRESULT,
    fn LoadAddOnProductInfosAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<StorePreviewProductInfo>> as RtType>::Abi) -> HRESULT
}}
impl IStorePreview {
    #[inline] pub fn request_product_purchase_by_product_id_and_sku_id_async(&self, productId: &HStringArg, skuId: &HStringArg) -> Result<foundation::IAsyncOperation<StorePreviewPurchaseResults>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestProductPurchaseByProductIdAndSkuIdAsync)(self.get_abi() as *const _ as *mut _, productId.get(), skuId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn load_add_on_product_infos_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<StorePreviewProductInfo>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().LoadAddOnProductInfosAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class StorePreview}
impl RtActivatable<IStorePreview> for StorePreview {}
impl StorePreview {
    #[inline] pub fn request_product_purchase_by_product_id_and_sku_id_async(productId: &HStringArg, skuId: &HStringArg) -> Result<foundation::IAsyncOperation<StorePreviewPurchaseResults>> {
        <Self as RtActivatable<IStorePreview>>::get_activation_factory().request_product_purchase_by_product_id_and_sku_id_async(productId, skuId)
    }
    #[inline] pub fn load_add_on_product_infos_async() -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<StorePreviewProductInfo>>> {
        <Self as RtActivatable<IStorePreview>>::get_activation_factory().load_add_on_product_infos_async()
    }
}
DEFINE_CLSID!(StorePreview(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,83,116,111,114,101,46,80,114,101,118,105,101,119,46,83,116,111,114,101,80,114,101,118,105,101,119,0]) [CLSID_StorePreview]);
DEFINE_IID!(IID_IStorePreviewProductInfo, 423091123, 27649, 19613, 133, 205, 91, 171, 170, 194, 179, 81);
RT_INTERFACE!{interface IStorePreviewProductInfo(IStorePreviewProductInfoVtbl): IInspectable [IID_IStorePreviewProductInfo] {
    fn get_ProductId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ProductType(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SkuInfoList(&self, out: *mut <foundation::collections::IVectorView<StorePreviewSkuInfo> as RtType>::Abi) -> HRESULT
}}
impl IStorePreviewProductInfo {
    #[inline] pub fn get_product_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ProductId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_product_type(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ProductType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Title)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Description)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sku_info_list(&self) -> Result<Option<foundation::collections::IVectorView<StorePreviewSkuInfo>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SkuInfoList)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class StorePreviewProductInfo: IStorePreviewProductInfo}
RT_ENUM! { enum StorePreviewProductPurchaseStatus: i32 {
    Succeeded = 0, AlreadyPurchased = 1, NotFulfilled = 2, NotPurchased = 3,
}}
DEFINE_IID!(IID_IStorePreviewPurchaseResults, 2967121617, 54981, 20051, 160, 67, 251, 160, 216, 230, 18, 49);
RT_INTERFACE!{interface IStorePreviewPurchaseResults(IStorePreviewPurchaseResultsVtbl): IInspectable [IID_IStorePreviewPurchaseResults] {
    fn get_ProductPurchaseStatus(&self, out: *mut StorePreviewProductPurchaseStatus) -> HRESULT
}}
impl IStorePreviewPurchaseResults {
    #[inline] pub fn get_product_purchase_status(&self) -> Result<StorePreviewProductPurchaseStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ProductPurchaseStatus)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class StorePreviewPurchaseResults: IStorePreviewPurchaseResults}
DEFINE_IID!(IID_IStorePreviewSkuInfo, 2180871906, 2854, 18649, 152, 206, 39, 70, 28, 102, 157, 108);
RT_INTERFACE!{interface IStorePreviewSkuInfo(IStorePreviewSkuInfoVtbl): IInspectable [IID_IStorePreviewSkuInfo] {
    fn get_ProductId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SkuId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SkuType(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CustomDeveloperData(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CurrencyCode(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FormattedListPrice(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ExtendedData(&self, out: *mut HSTRING) -> HRESULT
}}
impl IStorePreviewSkuInfo {
    #[inline] pub fn get_product_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ProductId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sku_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SkuId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sku_type(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SkuType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Title)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Description)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_custom_developer_data(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CustomDeveloperData)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_currency_code(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CurrencyCode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_formatted_list_price(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_FormattedListPrice)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_data(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ExtendedData)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class StorePreviewSkuInfo: IStorePreviewSkuInfo}
RT_ENUM! { enum StoreSystemFeature: i32 {
    ArchitectureX86 = 0, ArchitectureX64 = 1, ArchitectureArm = 2, DirectX9 = 3, DirectX10 = 4, DirectX11 = 5, D3D12HardwareFL11 = 6, D3D12HardwareFL12 = 7, Memory300MB = 8, Memory750MB = 9, Memory1GB = 10, Memory2GB = 11, CameraFront = 12, CameraRear = 13, Gyroscope = 14, Hover = 15, Magnetometer = 16, Nfc = 17, Resolution720P = 18, ResolutionWvga = 19, ResolutionWvgaOr720P = 20, ResolutionWxga = 21, ResolutionWvgaOrWxga = 22, ResolutionWxgaOr720P = 23, Memory4GB = 24, Memory6GB = 25, Memory8GB = 26, Memory12GB = 27, Memory16GB = 28, Memory20GB = 29, VideoMemory2GB = 30, VideoMemory4GB = 31, VideoMemory6GB = 32, VideoMemory1GB = 33, ArchitectureArm64 = 34,
}}
DEFINE_IID!(IID_IWebAuthenticationCoreManagerHelper, 111478053, 59157, 16675, 146, 118, 157, 111, 134, 91, 165, 95);
RT_INTERFACE!{static interface IWebAuthenticationCoreManagerHelper(IWebAuthenticationCoreManagerHelperVtbl): IInspectable [IID_IWebAuthenticationCoreManagerHelper] {
    #[cfg(all(feature="windows-security",feature="windows-ui-xaml"))] fn RequestTokenWithUIElementHostingAsync(&self, request: <crate::windows::security::authentication::web::core::WebTokenRequest as RtType>::Abi, uiElement: <crate::windows::ui::xaml::UIElement as RtType>::Abi, out: *mut <foundation::IAsyncOperation<crate::windows::security::authentication::web::core::WebTokenRequestResult> as RtType>::Abi) -> HRESULT,
    #[cfg(all(feature="windows-security",feature="windows-ui-xaml"))] fn RequestTokenWithUIElementHostingAndWebAccountAsync(&self, request: <crate::windows::security::authentication::web::core::WebTokenRequest as RtType>::Abi, webAccount: <crate::windows::security::credentials::WebAccount as RtType>::Abi, uiElement: <crate::windows::ui::xaml::UIElement as RtType>::Abi, out: *mut <foundation::IAsyncOperation<crate::windows::security::authentication::web::core::WebTokenRequestResult> as RtType>::Abi) -> HRESULT
}}
impl IWebAuthenticationCoreManagerHelper {
    #[cfg(all(feature="windows-security",feature="windows-ui-xaml"))] #[inline] pub fn request_token_with_uielement_hosting_async(&self, request: &crate::windows::security::authentication::web::core::WebTokenRequest, uiElement: &crate::windows::ui::xaml::UIElement) -> Result<foundation::IAsyncOperation<crate::windows::security::authentication::web::core::WebTokenRequestResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestTokenWithUIElementHostingAsync)(self.get_abi() as *const _ as *mut _, request.get_abi() as *const _ as *mut _, uiElement.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(all(feature="windows-security",feature="windows-ui-xaml"))] #[inline] pub fn request_token_with_uielement_hosting_and_web_account_async(&self, request: &crate::windows::security::authentication::web::core::WebTokenRequest, webAccount: &crate::windows::security::credentials::WebAccount, uiElement: &crate::windows::ui::xaml::UIElement) -> Result<foundation::IAsyncOperation<crate::windows::security::authentication::web::core::WebTokenRequestResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestTokenWithUIElementHostingAndWebAccountAsync)(self.get_abi() as *const _ as *mut _, request.get_abi() as *const _ as *mut _, webAccount.get_abi() as *const _ as *mut _, uiElement.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class WebAuthenticationCoreManagerHelper}
impl RtActivatable<IWebAuthenticationCoreManagerHelper> for WebAuthenticationCoreManagerHelper {}
impl WebAuthenticationCoreManagerHelper {
    #[cfg(all(feature="windows-security",feature="windows-ui-xaml"))] #[inline] pub fn request_token_with_uielement_hosting_async(request: &crate::windows::security::authentication::web::core::WebTokenRequest, uiElement: &crate::windows::ui::xaml::UIElement) -> Result<foundation::IAsyncOperation<crate::windows::security::authentication::web::core::WebTokenRequestResult>> {
        <Self as RtActivatable<IWebAuthenticationCoreManagerHelper>>::get_activation_factory().request_token_with_uielement_hosting_async(request, uiElement)
    }
    #[cfg(all(feature="windows-security",feature="windows-ui-xaml"))] #[inline] pub fn request_token_with_uielement_hosting_and_web_account_async(request: &crate::windows::security::authentication::web::core::WebTokenRequest, webAccount: &crate::windows::security::credentials::WebAccount, uiElement: &crate::windows::ui::xaml::UIElement) -> Result<foundation::IAsyncOperation<crate::windows::security::authentication::web::core::WebTokenRequestResult>> {
        <Self as RtActivatable<IWebAuthenticationCoreManagerHelper>>::get_activation_factory().request_token_with_uielement_hosting_and_web_account_async(request, webAccount, uiElement)
    }
}
DEFINE_CLSID!(WebAuthenticationCoreManagerHelper(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,83,116,111,114,101,46,80,114,101,118,105,101,119,46,87,101,98,65,117,116,104,101,110,116,105,99,97,116,105,111,110,67,111,114,101,77,97,110,97,103,101,114,72,101,108,112,101,114,0]) [CLSID_WebAuthenticationCoreManagerHelper]);
pub mod installcontrol { // Windows.ApplicationModel.Store.Preview.InstallControl
use crate::prelude::*;
RT_ENUM! { enum AppInstallationToastNotificationMode: i32 {
    Default = 0, Toast = 1, ToastWithoutPopup = 2, NoToast = 3,
}}
DEFINE_IID!(IID_IAppInstallItem, 1238622123, 5770, 19647, 169, 58, 158, 68, 140, 130, 115, 125);
RT_INTERFACE!{interface IAppInstallItem(IAppInstallItemVtbl): IInspectable [IID_IAppInstallItem] {
    fn get_ProductId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_InstallType(&self, out: *mut AppInstallType) -> HRESULT,
    fn get_IsUserInitiated(&self, out: *mut bool) -> HRESULT,
    fn GetCurrentStatus(&self, out: *mut <AppInstallStatus as RtType>::Abi) -> HRESULT,
    fn Cancel(&self) -> HRESULT,
    fn Pause(&self) -> HRESULT,
    fn Restart(&self) -> HRESULT,
    fn add_Completed(&self, handler: <foundation::TypedEventHandler<AppInstallItem, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Completed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_StatusChanged(&self, handler: <foundation::TypedEventHandler<AppInstallItem, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAppInstallItem {
    #[inline] pub fn get_product_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ProductId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_package_family_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PackageFamilyName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_install_type(&self) -> Result<AppInstallType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_InstallType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_user_initiated(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsUserInitiated)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_current_status(&self) -> Result<Option<AppInstallStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetCurrentStatus)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppInstallStatus::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn cancel(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Cancel)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn pause(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Pause)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn restart(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Restart)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_completed(&self, handler: &foundation::TypedEventHandler<AppInstallItem, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_Completed)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_Completed)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_status_changed(&self, handler: &foundation::TypedEventHandler<AppInstallItem, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_StatusChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_StatusChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppInstallItem: IAppInstallItem}
DEFINE_IID!(IID_IAppInstallItem2, 3549899512, 16576, 20439, 170, 108, 10, 161, 60, 166, 24, 140);
RT_INTERFACE!{interface IAppInstallItem2(IAppInstallItem2Vtbl): IInspectable [IID_IAppInstallItem2] {
    fn CancelWithTelemetry(&self, correlationVector: HSTRING) -> HRESULT,
    fn PauseWithTelemetry(&self, correlationVector: HSTRING) -> HRESULT,
    fn RestartWithTelemetry(&self, correlationVector: HSTRING) -> HRESULT
}}
impl IAppInstallItem2 {
    #[inline] pub fn cancel_with_telemetry(&self, correlationVector: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().CancelWithTelemetry)(self.get_abi() as *const _ as *mut _, correlationVector.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn pause_with_telemetry(&self, correlationVector: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().PauseWithTelemetry)(self.get_abi() as *const _ as *mut _, correlationVector.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn restart_with_telemetry(&self, correlationVector: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().RestartWithTelemetry)(self.get_abi() as *const _ as *mut _, correlationVector.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppInstallItem3, 1866320280, 56647, 17212, 146, 52, 86, 1, 114, 214, 122, 69);
RT_INTERFACE!{interface IAppInstallItem3(IAppInstallItem3Vtbl): IInspectable [IID_IAppInstallItem3] {
    fn get_Children(&self, out: *mut <foundation::collections::IVectorView<AppInstallItem> as RtType>::Abi) -> HRESULT,
    fn get_ItemOperationsMightAffectOtherItems(&self, out: *mut bool) -> HRESULT
}}
impl IAppInstallItem3 {
    #[inline] pub fn get_children(&self) -> Result<Option<foundation::collections::IVectorView<AppInstallItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Children)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_item_operations_might_affect_other_items(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ItemOperationsMightAffectOtherItems)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppInstallItem4, 3268529682, 29183, 20424, 181, 64, 69, 61, 75, 55, 225, 209);
RT_INTERFACE!{interface IAppInstallItem4(IAppInstallItem4Vtbl): IInspectable [IID_IAppInstallItem4] {
    fn get_LaunchAfterInstall(&self, out: *mut bool) -> HRESULT,
    fn put_LaunchAfterInstall(&self, value: bool) -> HRESULT
}}
impl IAppInstallItem4 {
    #[inline] pub fn get_launch_after_install(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_LaunchAfterInstall)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_launch_after_install(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_LaunchAfterInstall)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppInstallItem5, 1427171276, 16502, 18955, 148, 114, 194, 29, 157, 56, 14, 85);
RT_INTERFACE!{interface IAppInstallItem5(IAppInstallItem5Vtbl): IInspectable [IID_IAppInstallItem5] {
    fn get_PinToDesktopAfterInstall(&self, out: *mut bool) -> HRESULT,
    fn put_PinToDesktopAfterInstall(&self, value: bool) -> HRESULT,
    fn get_PinToStartAfterInstall(&self, out: *mut bool) -> HRESULT,
    fn put_PinToStartAfterInstall(&self, value: bool) -> HRESULT,
    fn get_PinToTaskbarAfterInstall(&self, out: *mut bool) -> HRESULT,
    fn put_PinToTaskbarAfterInstall(&self, value: bool) -> HRESULT,
    fn get_CompletedInstallToastNotificationMode(&self, out: *mut AppInstallationToastNotificationMode) -> HRESULT,
    fn put_CompletedInstallToastNotificationMode(&self, value: AppInstallationToastNotificationMode) -> HRESULT,
    fn get_InstallInProgressToastNotificationMode(&self, out: *mut AppInstallationToastNotificationMode) -> HRESULT,
    fn put_InstallInProgressToastNotificationMode(&self, value: AppInstallationToastNotificationMode) -> HRESULT
}}
impl IAppInstallItem5 {
    #[inline] pub fn get_pin_to_desktop_after_install(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_PinToDesktopAfterInstall)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_pin_to_desktop_after_install(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_PinToDesktopAfterInstall)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_pin_to_start_after_install(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_PinToStartAfterInstall)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_pin_to_start_after_install(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_PinToStartAfterInstall)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_pin_to_taskbar_after_install(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_PinToTaskbarAfterInstall)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_pin_to_taskbar_after_install(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_PinToTaskbarAfterInstall)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_completed_install_toast_notification_mode(&self) -> Result<AppInstallationToastNotificationMode> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CompletedInstallToastNotificationMode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_completed_install_toast_notification_mode(&self, value: AppInstallationToastNotificationMode) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CompletedInstallToastNotificationMode)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_install_in_progress_toast_notification_mode(&self) -> Result<AppInstallationToastNotificationMode> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_InstallInProgressToastNotificationMode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_install_in_progress_toast_notification_mode(&self, value: AppInstallationToastNotificationMode) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_InstallInProgressToastNotificationMode)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppInstallManager, 2471747952, 33857, 19269, 189, 114, 124, 47, 169, 37, 190, 238);
RT_INTERFACE!{interface IAppInstallManager(IAppInstallManagerVtbl): IInspectable [IID_IAppInstallManager] {
    fn get_AppInstallItems(&self, out: *mut <foundation::collections::IVectorView<AppInstallItem> as RtType>::Abi) -> HRESULT,
    fn Cancel(&self, productId: HSTRING) -> HRESULT,
    fn Pause(&self, productId: HSTRING) -> HRESULT,
    fn Restart(&self, productId: HSTRING) -> HRESULT,
    fn add_ItemCompleted(&self, handler: <foundation::TypedEventHandler<AppInstallManager, AppInstallManagerItemEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ItemCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ItemStatusChanged(&self, handler: <foundation::TypedEventHandler<AppInstallManager, AppInstallManagerItemEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ItemStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_AutoUpdateSetting(&self, out: *mut AutoUpdateSetting) -> HRESULT,
    fn put_AutoUpdateSetting(&self, value: AutoUpdateSetting) -> HRESULT,
    fn get_AcquisitionIdentity(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AcquisitionIdentity(&self, value: HSTRING) -> HRESULT,
    fn GetIsApplicableAsync(&self, productId: HSTRING, skuId: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn StartAppInstallAsync(&self, productId: HSTRING, skuId: HSTRING, repair: bool, forceUseOfNonRemovableStorage: bool, out: *mut <foundation::IAsyncOperation<AppInstallItem> as RtType>::Abi) -> HRESULT,
    fn UpdateAppByPackageFamilyNameAsync(&self, packageFamilyName: HSTRING, out: *mut <foundation::IAsyncOperation<AppInstallItem> as RtType>::Abi) -> HRESULT,
    fn SearchForUpdatesAsync(&self, productId: HSTRING, skuId: HSTRING, out: *mut <foundation::IAsyncOperation<AppInstallItem> as RtType>::Abi) -> HRESULT,
    fn SearchForAllUpdatesAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<AppInstallItem>> as RtType>::Abi) -> HRESULT,
    fn IsStoreBlockedByPolicyAsync(&self, storeClientName: HSTRING, storeClientPublisher: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn GetIsAppAllowedToInstallAsync(&self, productId: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl IAppInstallManager {
    #[inline] pub fn get_app_install_items(&self) -> Result<Option<foundation::collections::IVectorView<AppInstallItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppInstallItems)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn cancel(&self, productId: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Cancel)(self.get_abi() as *const _ as *mut _, productId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn pause(&self, productId: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Pause)(self.get_abi() as *const _ as *mut _, productId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn restart(&self, productId: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Restart)(self.get_abi() as *const _ as *mut _, productId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_item_completed(&self, handler: &foundation::TypedEventHandler<AppInstallManager, AppInstallManagerItemEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_ItemCompleted)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_item_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_ItemCompleted)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_item_status_changed(&self, handler: &foundation::TypedEventHandler<AppInstallManager, AppInstallManagerItemEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_ItemStatusChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_item_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_ItemStatusChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_update_setting(&self) -> Result<AutoUpdateSetting> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AutoUpdateSetting)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto_update_setting(&self, value: AutoUpdateSetting) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AutoUpdateSetting)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_acquisition_identity(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AcquisitionIdentity)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_acquisition_identity(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AcquisitionIdentity)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_applicable_async(&self, productId: &HStringArg, skuId: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetIsApplicableAsync)(self.get_abi() as *const _ as *mut _, productId.get(), skuId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn start_app_install_async(&self, productId: &HStringArg, skuId: &HStringArg, repair: bool, forceUseOfNonRemovableStorage: bool) -> Result<foundation::IAsyncOperation<AppInstallItem>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().StartAppInstallAsync)(self.get_abi() as *const _ as *mut _, productId.get(), skuId.get(), repair, forceUseOfNonRemovableStorage, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn update_app_by_package_family_name_async(&self, packageFamilyName: &HStringArg) -> Result<foundation::IAsyncOperation<AppInstallItem>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().UpdateAppByPackageFamilyNameAsync)(self.get_abi() as *const _ as *mut _, packageFamilyName.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn search_for_updates_async(&self, productId: &HStringArg, skuId: &HStringArg) -> Result<foundation::IAsyncOperation<AppInstallItem>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SearchForUpdatesAsync)(self.get_abi() as *const _ as *mut _, productId.get(), skuId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn search_for_all_updates_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<AppInstallItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SearchForAllUpdatesAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_store_blocked_by_policy_async(&self, storeClientName: &HStringArg, storeClientPublisher: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().IsStoreBlockedByPolicyAsync)(self.get_abi() as *const _ as *mut _, storeClientName.get(), storeClientPublisher.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_app_allowed_to_install_async(&self, productId: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetIsAppAllowedToInstallAsync)(self.get_abi() as *const _ as *mut _, productId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppInstallManager: IAppInstallManager}
impl RtActivatable<IActivationFactory> for AppInstallManager {}
DEFINE_CLSID!(AppInstallManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,83,116,111,114,101,46,80,114,101,118,105,101,119,46,73,110,115,116,97,108,108,67,111,110,116,114,111,108,46,65,112,112,73,110,115,116,97,108,108,77,97,110,97,103,101,114,0]) [CLSID_AppInstallManager]);
DEFINE_IID!(IID_IAppInstallManager2, 378763345, 60727, 18445, 131, 20, 82, 226, 124, 3, 240, 74);
RT_INTERFACE!{interface IAppInstallManager2(IAppInstallManager2Vtbl): IInspectable [IID_IAppInstallManager2] {
    fn StartAppInstallWithTelemetryAsync(&self, productId: HSTRING, skuId: HSTRING, repair: bool, forceUseOfNonRemovableStorage: bool, catalogId: HSTRING, bundleId: HSTRING, correlationVector: HSTRING, out: *mut <foundation::IAsyncOperation<AppInstallItem> as RtType>::Abi) -> HRESULT,
    fn UpdateAppByPackageFamilyNameWithTelemetryAsync(&self, packageFamilyName: HSTRING, correlationVector: HSTRING, out: *mut <foundation::IAsyncOperation<AppInstallItem> as RtType>::Abi) -> HRESULT,
    fn SearchForUpdatesWithTelemetryAsync(&self, productId: HSTRING, skuId: HSTRING, catalogId: HSTRING, correlationVector: HSTRING, out: *mut <foundation::IAsyncOperation<AppInstallItem> as RtType>::Abi) -> HRESULT,
    fn SearchForAllUpdatesWithTelemetryAsync(&self, correlationVector: HSTRING, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<AppInstallItem>> as RtType>::Abi) -> HRESULT,
    fn GetIsAppAllowedToInstallWithTelemetryAsync(&self, productId: HSTRING, skuId: HSTRING, catalogId: HSTRING, correlationVector: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn CancelWithTelemetry(&self, productId: HSTRING, correlationVector: HSTRING) -> HRESULT,
    fn PauseWithTelemetry(&self, productId: HSTRING, correlationVector: HSTRING) -> HRESULT,
    fn RestartWithTelemetry(&self, productId: HSTRING, correlationVector: HSTRING) -> HRESULT
}}
impl IAppInstallManager2 {
    #[inline] pub fn start_app_install_with_telemetry_async(&self, productId: &HStringArg, skuId: &HStringArg, repair: bool, forceUseOfNonRemovableStorage: bool, catalogId: &HStringArg, bundleId: &HStringArg, correlationVector: &HStringArg) -> Result<foundation::IAsyncOperation<AppInstallItem>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().StartAppInstallWithTelemetryAsync)(self.get_abi() as *const _ as *mut _, productId.get(), skuId.get(), repair, forceUseOfNonRemovableStorage, catalogId.get(), bundleId.get(), correlationVector.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn update_app_by_package_family_name_with_telemetry_async(&self, packageFamilyName: &HStringArg, correlationVector: &HStringArg) -> Result<foundation::IAsyncOperation<AppInstallItem>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().UpdateAppByPackageFamilyNameWithTelemetryAsync)(self.get_abi() as *const _ as *mut _, packageFamilyName.get(), correlationVector.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn search_for_updates_with_telemetry_async(&self, productId: &HStringArg, skuId: &HStringArg, catalogId: &HStringArg, correlationVector: &HStringArg) -> Result<foundation::IAsyncOperation<AppInstallItem>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SearchForUpdatesWithTelemetryAsync)(self.get_abi() as *const _ as *mut _, productId.get(), skuId.get(), catalogId.get(), correlationVector.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn search_for_all_updates_with_telemetry_async(&self, correlationVector: &HStringArg) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<AppInstallItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SearchForAllUpdatesWithTelemetryAsync)(self.get_abi() as *const _ as *mut _, correlationVector.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_app_allowed_to_install_with_telemetry_async(&self, productId: &HStringArg, skuId: &HStringArg, catalogId: &HStringArg, correlationVector: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetIsAppAllowedToInstallWithTelemetryAsync)(self.get_abi() as *const _ as *mut _, productId.get(), skuId.get(), catalogId.get(), correlationVector.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn cancel_with_telemetry(&self, productId: &HStringArg, correlationVector: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().CancelWithTelemetry)(self.get_abi() as *const _ as *mut _, productId.get(), correlationVector.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn pause_with_telemetry(&self, productId: &HStringArg, correlationVector: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().PauseWithTelemetry)(self.get_abi() as *const _ as *mut _, productId.get(), correlationVector.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn restart_with_telemetry(&self, productId: &HStringArg, correlationVector: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().RestartWithTelemetry)(self.get_abi() as *const _ as *mut _, productId.get(), correlationVector.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppInstallManager3, 2511489815, 59754, 19726, 132, 225, 200, 203, 65, 122, 1, 120);
RT_INTERFACE!{interface IAppInstallManager3(IAppInstallManager3Vtbl): IInspectable [IID_IAppInstallManager3] {
    #[cfg(not(feature="windows-management"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-management")] fn StartProductInstallAsync(&self, productId: HSTRING, catalogId: HSTRING, flightId: HSTRING, clientId: HSTRING, repair: bool, forceUseOfNonRemovableStorage: bool, correlationVector: HSTRING, targetVolume: <crate::windows::management::deployment::PackageVolume as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<AppInstallItem>> as RtType>::Abi) -> HRESULT,
    #[cfg(not(all(feature="windows-management",feature="windows-system")))] fn __Dummy1(&self) -> (),
    #[cfg(all(feature="windows-management",feature="windows-system"))] fn StartProductInstallForUserAsync(&self, user: <crate::windows::system::User as RtType>::Abi, productId: HSTRING, catalogId: HSTRING, flightId: HSTRING, clientId: HSTRING, repair: bool, forceUseOfNonRemovableStorage: bool, correlationVector: HSTRING, targetVolume: <crate::windows::management::deployment::PackageVolume as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<AppInstallItem>> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-system")] fn UpdateAppByPackageFamilyNameForUserAsync(&self, user: <crate::windows::system::User as RtType>::Abi, packageFamilyName: HSTRING, correlationVector: HSTRING, out: *mut <foundation::IAsyncOperation<AppInstallItem> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-system")] fn SearchForUpdatesForUserAsync(&self, user: <crate::windows::system::User as RtType>::Abi, productId: HSTRING, skuId: HSTRING, catalogId: HSTRING, correlationVector: HSTRING, out: *mut <foundation::IAsyncOperation<AppInstallItem> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-system")] fn SearchForAllUpdatesForUserAsync(&self, user: <crate::windows::system::User as RtType>::Abi, correlationVector: HSTRING, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<AppInstallItem>> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-system")] fn GetIsAppAllowedToInstallForUserAsync(&self, user: <crate::windows::system::User as RtType>::Abi, productId: HSTRING, skuId: HSTRING, catalogId: HSTRING, correlationVector: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-system")] fn GetIsApplicableForUserAsync(&self, user: <crate::windows::system::User as RtType>::Abi, productId: HSTRING, skuId: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn MoveToFrontOfDownloadQueue(&self, productId: HSTRING, correlationVector: HSTRING) -> HRESULT
}}
impl IAppInstallManager3 {
    #[cfg(feature="windows-management")] #[inline] pub fn start_product_install_async(&self, productId: &HStringArg, catalogId: &HStringArg, flightId: &HStringArg, clientId: &HStringArg, repair: bool, forceUseOfNonRemovableStorage: bool, correlationVector: &HStringArg, targetVolume: &crate::windows::management::deployment::PackageVolume) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<AppInstallItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().StartProductInstallAsync)(self.get_abi() as *const _ as *mut _, productId.get(), catalogId.get(), flightId.get(), clientId.get(), repair, forceUseOfNonRemovableStorage, correlationVector.get(), targetVolume.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(all(feature="windows-management",feature="windows-system"))] #[inline] pub fn start_product_install_for_user_async(&self, user: &crate::windows::system::User, productId: &HStringArg, catalogId: &HStringArg, flightId: &HStringArg, clientId: &HStringArg, repair: bool, forceUseOfNonRemovableStorage: bool, correlationVector: &HStringArg, targetVolume: &crate::windows::management::deployment::PackageVolume) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<AppInstallItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().StartProductInstallForUserAsync)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, productId.get(), catalogId.get(), flightId.get(), clientId.get(), repair, forceUseOfNonRemovableStorage, correlationVector.get(), targetVolume.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn update_app_by_package_family_name_for_user_async(&self, user: &crate::windows::system::User, packageFamilyName: &HStringArg, correlationVector: &HStringArg) -> Result<foundation::IAsyncOperation<AppInstallItem>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().UpdateAppByPackageFamilyNameForUserAsync)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, packageFamilyName.get(), correlationVector.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn search_for_updates_for_user_async(&self, user: &crate::windows::system::User, productId: &HStringArg, skuId: &HStringArg, catalogId: &HStringArg, correlationVector: &HStringArg) -> Result<foundation::IAsyncOperation<AppInstallItem>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SearchForUpdatesForUserAsync)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, productId.get(), skuId.get(), catalogId.get(), correlationVector.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn search_for_all_updates_for_user_async(&self, user: &crate::windows::system::User, correlationVector: &HStringArg) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<AppInstallItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SearchForAllUpdatesForUserAsync)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, correlationVector.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_is_app_allowed_to_install_for_user_async(&self, user: &crate::windows::system::User, productId: &HStringArg, skuId: &HStringArg, catalogId: &HStringArg, correlationVector: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetIsAppAllowedToInstallForUserAsync)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, productId.get(), skuId.get(), catalogId.get(), correlationVector.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_is_applicable_for_user_async(&self, user: &crate::windows::system::User, productId: &HStringArg, skuId: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetIsApplicableForUserAsync)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, productId.get(), skuId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn move_to_front_of_download_queue(&self, productId: &HStringArg, correlationVector: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().MoveToFrontOfDownloadQueue)(self.get_abi() as *const _ as *mut _, productId.get(), correlationVector.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppInstallManager4, 638200342, 23198, 20157, 185, 68, 242, 186, 117, 195, 17, 89);
RT_INTERFACE!{interface IAppInstallManager4(IAppInstallManager4Vtbl): IInspectable [IID_IAppInstallManager4] {
    fn GetFreeUserEntitlementAsync(&self, storeId: HSTRING, campaignId: HSTRING, correlationVector: HSTRING, out: *mut <foundation::IAsyncOperation<GetEntitlementResult> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-system")] fn GetFreeUserEntitlementForUserAsync(&self, user: <crate::windows::system::User as RtType>::Abi, storeId: HSTRING, campaignId: HSTRING, correlationVector: HSTRING, out: *mut <foundation::IAsyncOperation<GetEntitlementResult> as RtType>::Abi) -> HRESULT,
    fn GetFreeDeviceEntitlementAsync(&self, storeId: HSTRING, campaignId: HSTRING, correlationVector: HSTRING, out: *mut <foundation::IAsyncOperation<GetEntitlementResult> as RtType>::Abi) -> HRESULT
}}
impl IAppInstallManager4 {
    #[inline] pub fn get_free_user_entitlement_async(&self, storeId: &HStringArg, campaignId: &HStringArg, correlationVector: &HStringArg) -> Result<foundation::IAsyncOperation<GetEntitlementResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetFreeUserEntitlementAsync)(self.get_abi() as *const _ as *mut _, storeId.get(), campaignId.get(), correlationVector.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_free_user_entitlement_for_user_async(&self, user: &crate::windows::system::User, storeId: &HStringArg, campaignId: &HStringArg, correlationVector: &HStringArg) -> Result<foundation::IAsyncOperation<GetEntitlementResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetFreeUserEntitlementForUserAsync)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, storeId.get(), campaignId.get(), correlationVector.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_free_device_entitlement_async(&self, storeId: &HStringArg, campaignId: &HStringArg, correlationVector: &HStringArg) -> Result<foundation::IAsyncOperation<GetEntitlementResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetFreeDeviceEntitlementAsync)(self.get_abi() as *const _ as *mut _, storeId.get(), campaignId.get(), correlationVector.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppInstallManager5, 1020771916, 7145, 20351, 182, 117, 170, 29, 100, 165, 41, 178);
RT_INTERFACE!{interface IAppInstallManager5(IAppInstallManager5Vtbl): IInspectable [IID_IAppInstallManager5] {
    fn get_AppInstallItemsWithGroupSupport(&self, out: *mut <foundation::collections::IVectorView<AppInstallItem> as RtType>::Abi) -> HRESULT
}}
impl IAppInstallManager5 {
    #[inline] pub fn get_app_install_items_with_group_support(&self) -> Result<Option<foundation::collections::IVectorView<AppInstallItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppInstallItemsWithGroupSupport)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppInstallManager6, 3387413512, 62074, 17521, 178, 244, 231, 110, 252, 190, 188, 202);
RT_INTERFACE!{interface IAppInstallManager6(IAppInstallManager6Vtbl): IInspectable [IID_IAppInstallManager6] {
    fn SearchForAllUpdatesWithUpdateOptionsAsync(&self, correlationVector: HSTRING, clientId: HSTRING, updateOptions: <AppUpdateOptions as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<AppInstallItem>> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-system")] fn SearchForAllUpdatesWithUpdateOptionsForUserAsync(&self, user: <crate::windows::system::User as RtType>::Abi, correlationVector: HSTRING, clientId: HSTRING, updateOptions: <AppUpdateOptions as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<AppInstallItem>> as RtType>::Abi) -> HRESULT,
    fn SearchForUpdatesWithUpdateOptionsAsync(&self, productId: HSTRING, skuId: HSTRING, correlationVector: HSTRING, clientId: HSTRING, updateOptions: <AppUpdateOptions as RtType>::Abi, out: *mut <foundation::IAsyncOperation<AppInstallItem> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-system")] fn SearchForUpdatesWithUpdateOptionsForUserAsync(&self, user: <crate::windows::system::User as RtType>::Abi, productId: HSTRING, skuId: HSTRING, correlationVector: HSTRING, clientId: HSTRING, updateOptions: <AppUpdateOptions as RtType>::Abi, out: *mut <foundation::IAsyncOperation<AppInstallItem> as RtType>::Abi) -> HRESULT,
    fn StartProductInstallWithOptionsAsync(&self, productId: HSTRING, flightId: HSTRING, clientId: HSTRING, correlationVector: HSTRING, installOptions: <AppInstallOptions as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<AppInstallItem>> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-system")] fn StartProductInstallWithOptionsForUserAsync(&self, user: <crate::windows::system::User as RtType>::Abi, productId: HSTRING, flightId: HSTRING, clientId: HSTRING, correlationVector: HSTRING, installOptions: <AppInstallOptions as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<AppInstallItem>> as RtType>::Abi) -> HRESULT,
    fn GetIsPackageIdentityAllowedToInstallAsync(&self, correlationVector: HSTRING, packageIdentityName: HSTRING, publisherCertificateName: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-system")] fn GetIsPackageIdentityAllowedToInstallForUserAsync(&self, user: <crate::windows::system::User as RtType>::Abi, correlationVector: HSTRING, packageIdentityName: HSTRING, publisherCertificateName: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl IAppInstallManager6 {
    #[inline] pub fn search_for_all_updates_with_update_options_async(&self, correlationVector: &HStringArg, clientId: &HStringArg, updateOptions: &AppUpdateOptions) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<AppInstallItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SearchForAllUpdatesWithUpdateOptionsAsync)(self.get_abi() as *const _ as *mut _, correlationVector.get(), clientId.get(), updateOptions.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn search_for_all_updates_with_update_options_for_user_async(&self, user: &crate::windows::system::User, correlationVector: &HStringArg, clientId: &HStringArg, updateOptions: &AppUpdateOptions) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<AppInstallItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SearchForAllUpdatesWithUpdateOptionsForUserAsync)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, correlationVector.get(), clientId.get(), updateOptions.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn search_for_updates_with_update_options_async(&self, productId: &HStringArg, skuId: &HStringArg, correlationVector: &HStringArg, clientId: &HStringArg, updateOptions: &AppUpdateOptions) -> Result<foundation::IAsyncOperation<AppInstallItem>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SearchForUpdatesWithUpdateOptionsAsync)(self.get_abi() as *const _ as *mut _, productId.get(), skuId.get(), correlationVector.get(), clientId.get(), updateOptions.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn search_for_updates_with_update_options_for_user_async(&self, user: &crate::windows::system::User, productId: &HStringArg, skuId: &HStringArg, correlationVector: &HStringArg, clientId: &HStringArg, updateOptions: &AppUpdateOptions) -> Result<foundation::IAsyncOperation<AppInstallItem>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SearchForUpdatesWithUpdateOptionsForUserAsync)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, productId.get(), skuId.get(), correlationVector.get(), clientId.get(), updateOptions.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn start_product_install_with_options_async(&self, productId: &HStringArg, flightId: &HStringArg, clientId: &HStringArg, correlationVector: &HStringArg, installOptions: &AppInstallOptions) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<AppInstallItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().StartProductInstallWithOptionsAsync)(self.get_abi() as *const _ as *mut _, productId.get(), flightId.get(), clientId.get(), correlationVector.get(), installOptions.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn start_product_install_with_options_for_user_async(&self, user: &crate::windows::system::User, productId: &HStringArg, flightId: &HStringArg, clientId: &HStringArg, correlationVector: &HStringArg, installOptions: &AppInstallOptions) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<AppInstallItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().StartProductInstallWithOptionsForUserAsync)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, productId.get(), flightId.get(), clientId.get(), correlationVector.get(), installOptions.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_package_identity_allowed_to_install_async(&self, correlationVector: &HStringArg, packageIdentityName: &HStringArg, publisherCertificateName: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetIsPackageIdentityAllowedToInstallAsync)(self.get_abi() as *const _ as *mut _, correlationVector.get(), packageIdentityName.get(), publisherCertificateName.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_is_package_identity_allowed_to_install_for_user_async(&self, user: &crate::windows::system::User, correlationVector: &HStringArg, packageIdentityName: &HStringArg, publisherCertificateName: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetIsPackageIdentityAllowedToInstallForUserAsync)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, correlationVector.get(), packageIdentityName.get(), publisherCertificateName.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppInstallManager7, 2783869744, 54756, 18851, 152, 83, 61, 176, 50, 3, 50, 29);
RT_INTERFACE!{interface IAppInstallManager7(IAppInstallManager7Vtbl): IInspectable [IID_IAppInstallManager7] {
    fn get_CanInstallForAllUsers(&self, out: *mut bool) -> HRESULT
}}
impl IAppInstallManager7 {
    #[inline] pub fn get_can_install_for_all_users(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanInstallForAllUsers)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppInstallManagerItemEventArgs, 3159381827, 18036, 19921, 149, 126, 194, 86, 130, 8, 106, 20);
RT_INTERFACE!{interface IAppInstallManagerItemEventArgs(IAppInstallManagerItemEventArgsVtbl): IInspectable [IID_IAppInstallManagerItemEventArgs] {
    fn get_Item(&self, out: *mut <AppInstallItem as RtType>::Abi) -> HRESULT
}}
impl IAppInstallManagerItemEventArgs {
    #[inline] pub fn get_item(&self) -> Result<Option<AppInstallItem>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Item)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppInstallItem::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppInstallManagerItemEventArgs: IAppInstallManagerItemEventArgs}
DEFINE_IID!(IID_IAppInstallOptions, 3380642560, 7352, 20150, 140, 159, 106, 48, 198, 74, 91, 81);
RT_INTERFACE!{interface IAppInstallOptions(IAppInstallOptionsVtbl): IInspectable [IID_IAppInstallOptions] {
    fn get_CatalogId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CatalogId(&self, value: HSTRING) -> HRESULT,
    fn get_ForceUseOfNonRemovableStorage(&self, out: *mut bool) -> HRESULT,
    fn put_ForceUseOfNonRemovableStorage(&self, value: bool) -> HRESULT,
    fn get_AllowForcedAppRestart(&self, out: *mut bool) -> HRESULT,
    fn put_AllowForcedAppRestart(&self, value: bool) -> HRESULT,
    fn get_Repair(&self, out: *mut bool) -> HRESULT,
    fn put_Repair(&self, value: bool) -> HRESULT,
    #[cfg(not(feature="windows-management"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-management")] fn get_TargetVolume(&self, out: *mut <crate::windows::management::deployment::PackageVolume as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-management"))] fn __Dummy9(&self) -> (),
    #[cfg(feature="windows-management")] fn put_TargetVolume(&self, value: <crate::windows::management::deployment::PackageVolume as RtType>::Abi) -> HRESULT,
    fn get_LaunchAfterInstall(&self, out: *mut bool) -> HRESULT,
    fn put_LaunchAfterInstall(&self, value: bool) -> HRESULT
}}
impl IAppInstallOptions {
    #[inline] pub fn get_catalog_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CatalogId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_catalog_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CatalogId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_force_use_of_non_removable_storage(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ForceUseOfNonRemovableStorage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_force_use_of_non_removable_storage(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ForceUseOfNonRemovableStorage)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_allow_forced_app_restart(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AllowForcedAppRestart)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_allow_forced_app_restart(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AllowForcedAppRestart)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_repair(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Repair)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_repair(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Repair)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-management")] #[inline] pub fn get_target_volume(&self) -> Result<Option<crate::windows::management::deployment::PackageVolume>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TargetVolume)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::management::deployment::PackageVolume::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-management")] #[inline] pub fn set_target_volume(&self, value: &crate::windows::management::deployment::PackageVolume) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_TargetVolume)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_launch_after_install(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_LaunchAfterInstall)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_launch_after_install(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_LaunchAfterInstall)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppInstallOptions: IAppInstallOptions}
impl RtActivatable<IActivationFactory> for AppInstallOptions {}
DEFINE_CLSID!(AppInstallOptions(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,83,116,111,114,101,46,80,114,101,118,105,101,119,46,73,110,115,116,97,108,108,67,111,110,116,114,111,108,46,65,112,112,73,110,115,116,97,108,108,79,112,116,105,111,110,115,0]) [CLSID_AppInstallOptions]);
DEFINE_IID!(IID_IAppInstallOptions2, 2315567319, 51531, 16990, 149, 180, 191, 39, 250, 234, 238, 137);
RT_INTERFACE!{interface IAppInstallOptions2(IAppInstallOptions2Vtbl): IInspectable [IID_IAppInstallOptions2] {
    fn get_PinToDesktopAfterInstall(&self, out: *mut bool) -> HRESULT,
    fn put_PinToDesktopAfterInstall(&self, value: bool) -> HRESULT,
    fn get_PinToStartAfterInstall(&self, out: *mut bool) -> HRESULT,
    fn put_PinToStartAfterInstall(&self, value: bool) -> HRESULT,
    fn get_PinToTaskbarAfterInstall(&self, out: *mut bool) -> HRESULT,
    fn put_PinToTaskbarAfterInstall(&self, value: bool) -> HRESULT,
    fn get_CompletedInstallToastNotificationMode(&self, out: *mut AppInstallationToastNotificationMode) -> HRESULT,
    fn put_CompletedInstallToastNotificationMode(&self, value: AppInstallationToastNotificationMode) -> HRESULT,
    fn get_InstallInProgressToastNotificationMode(&self, out: *mut AppInstallationToastNotificationMode) -> HRESULT,
    fn put_InstallInProgressToastNotificationMode(&self, value: AppInstallationToastNotificationMode) -> HRESULT,
    fn get_InstallForAllUsers(&self, out: *mut bool) -> HRESULT,
    fn put_InstallForAllUsers(&self, value: bool) -> HRESULT,
    fn get_StageButDoNotInstall(&self, out: *mut bool) -> HRESULT,
    fn put_StageButDoNotInstall(&self, value: bool) -> HRESULT,
    fn get_CampaignId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CampaignId(&self, value: HSTRING) -> HRESULT,
    fn get_ExtendedCampaignId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ExtendedCampaignId(&self, value: HSTRING) -> HRESULT
}}
impl IAppInstallOptions2 {
    #[inline] pub fn get_pin_to_desktop_after_install(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_PinToDesktopAfterInstall)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_pin_to_desktop_after_install(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_PinToDesktopAfterInstall)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_pin_to_start_after_install(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_PinToStartAfterInstall)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_pin_to_start_after_install(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_PinToStartAfterInstall)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_pin_to_taskbar_after_install(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_PinToTaskbarAfterInstall)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_pin_to_taskbar_after_install(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_PinToTaskbarAfterInstall)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_completed_install_toast_notification_mode(&self) -> Result<AppInstallationToastNotificationMode> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CompletedInstallToastNotificationMode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_completed_install_toast_notification_mode(&self, value: AppInstallationToastNotificationMode) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CompletedInstallToastNotificationMode)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_install_in_progress_toast_notification_mode(&self) -> Result<AppInstallationToastNotificationMode> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_InstallInProgressToastNotificationMode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_install_in_progress_toast_notification_mode(&self, value: AppInstallationToastNotificationMode) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_InstallInProgressToastNotificationMode)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_install_for_all_users(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_InstallForAllUsers)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_install_for_all_users(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_InstallForAllUsers)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_stage_but_do_not_install(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_StageButDoNotInstall)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_stage_but_do_not_install(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_StageButDoNotInstall)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_campaign_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CampaignId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_campaign_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CampaignId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_campaign_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ExtendedCampaignId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_extended_campaign_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ExtendedCampaignId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum AppInstallState: i32 {
    Pending = 0, Starting = 1, AcquiringLicense = 2, Downloading = 3, RestoringData = 4, Installing = 5, Completed = 6, Canceled = 7, Paused = 8, Error = 9, PausedLowBattery = 10, PausedWiFiRecommended = 11, PausedWiFiRequired = 12, ReadyToDownload = 13,
}}
DEFINE_IID!(IID_IAppInstallStatus, 2473446650, 9296, 16678, 136, 177, 97, 39, 166, 68, 221, 92);
RT_INTERFACE!{interface IAppInstallStatus(IAppInstallStatusVtbl): IInspectable [IID_IAppInstallStatus] {
    fn get_InstallState(&self, out: *mut AppInstallState) -> HRESULT,
    fn get_DownloadSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn get_BytesDownloaded(&self, out: *mut u64) -> HRESULT,
    fn get_PercentComplete(&self, out: *mut f64) -> HRESULT,
    fn get_ErrorCode(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl IAppInstallStatus {
    #[inline] pub fn get_install_state(&self) -> Result<AppInstallState> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_InstallState)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_download_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DownloadSizeInBytes)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bytes_downloaded(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_BytesDownloaded)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_percent_complete(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_PercentComplete)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error_code(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ErrorCode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppInstallStatus: IAppInstallStatus}
DEFINE_IID!(IID_IAppInstallStatus2, 2531754378, 24210, 19113, 142, 220, 88, 254, 212, 184, 126, 0);
RT_INTERFACE!{interface IAppInstallStatus2(IAppInstallStatus2Vtbl): IInspectable [IID_IAppInstallStatus2] {
    #[cfg(not(feature="windows-system"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut <crate::windows::system::User as RtType>::Abi) -> HRESULT,
    fn get_ReadyForLaunch(&self, out: *mut bool) -> HRESULT
}}
impl IAppInstallStatus2 {
    #[cfg(feature="windows-system")] #[inline] pub fn get_user(&self) -> Result<Option<crate::windows::system::User>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_User)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::system::User::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_ready_for_launch(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ReadyForLaunch)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppInstallStatus3, 3414690902, 33659, 19276, 158, 187, 109, 68, 160, 169, 99, 7);
RT_INTERFACE!{interface IAppInstallStatus3(IAppInstallStatus3Vtbl): IInspectable [IID_IAppInstallStatus3] {
    fn get_IsStaged(&self, out: *mut bool) -> HRESULT
}}
impl IAppInstallStatus3 {
    #[inline] pub fn get_is_staged(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsStaged)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum AppInstallType: i32 {
    Install = 0, Update = 1, Repair = 2,
}}
DEFINE_IID!(IID_IAppUpdateOptions, 653307951, 49907, 19178, 175, 140, 99, 8, 221, 157, 184, 95);
RT_INTERFACE!{interface IAppUpdateOptions(IAppUpdateOptionsVtbl): IInspectable [IID_IAppUpdateOptions] {
    fn get_CatalogId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CatalogId(&self, value: HSTRING) -> HRESULT,
    fn get_AllowForcedAppRestart(&self, out: *mut bool) -> HRESULT,
    fn put_AllowForcedAppRestart(&self, value: bool) -> HRESULT
}}
impl IAppUpdateOptions {
    #[inline] pub fn get_catalog_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CatalogId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_catalog_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CatalogId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_allow_forced_app_restart(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AllowForcedAppRestart)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_allow_forced_app_restart(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AllowForcedAppRestart)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppUpdateOptions: IAppUpdateOptions}
impl RtActivatable<IActivationFactory> for AppUpdateOptions {}
DEFINE_CLSID!(AppUpdateOptions(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,83,116,111,114,101,46,80,114,101,118,105,101,119,46,73,110,115,116,97,108,108,67,111,110,116,114,111,108,46,65,112,112,85,112,100,97,116,101,79,112,116,105,111,110,115,0]) [CLSID_AppUpdateOptions]);
DEFINE_IID!(IID_IAppUpdateOptions2, 4100222472, 60710, 19449, 150, 121, 72, 246, 40, 229, 61, 248);
RT_INTERFACE!{interface IAppUpdateOptions2(IAppUpdateOptions2Vtbl): IInspectable [IID_IAppUpdateOptions2] {
    fn get_AutomaticallyDownloadAndInstallUpdateIfFound(&self, out: *mut bool) -> HRESULT,
    fn put_AutomaticallyDownloadAndInstallUpdateIfFound(&self, value: bool) -> HRESULT
}}
impl IAppUpdateOptions2 {
    #[inline] pub fn get_automatically_download_and_install_update_if_found(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AutomaticallyDownloadAndInstallUpdateIfFound)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_automatically_download_and_install_update_if_found(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AutomaticallyDownloadAndInstallUpdateIfFound)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum AutoUpdateSetting: i32 {
    Disabled = 0, Enabled = 1, DisabledByPolicy = 2, EnabledByPolicy = 3,
}}
DEFINE_IID!(IID_IGetEntitlementResult, 1962705983, 6814, 17929, 142, 77, 129, 144, 134, 208, 138, 61);
RT_INTERFACE!{interface IGetEntitlementResult(IGetEntitlementResultVtbl): IInspectable [IID_IGetEntitlementResult] {
    fn get_Status(&self, out: *mut GetEntitlementStatus) -> HRESULT
}}
impl IGetEntitlementResult {
    #[inline] pub fn get_status(&self) -> Result<GetEntitlementStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GetEntitlementResult: IGetEntitlementResult}
RT_ENUM! { enum GetEntitlementStatus: i32 {
    Succeeded = 0, NoStoreAccount = 1, NetworkError = 2, ServerError = 3,
}}
} // Windows.ApplicationModel.Store.Preview.InstallControl
} // Windows.ApplicationModel.Store.Preview
} // Windows.ApplicationModel.Store
pub mod useractivities { // Windows.ApplicationModel.UserActivities
use crate::prelude::*;
DEFINE_IID!(IID_IUserActivity, 4228923038, 11435, 19766, 174, 162, 180, 187, 85, 108, 239, 15);
RT_INTERFACE!{interface IUserActivity(IUserActivityVtbl): IInspectable [IID_IUserActivity] {
    fn get_State(&self, out: *mut UserActivityState) -> HRESULT,
    fn get_ActivityId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VisualElements(&self, out: *mut <UserActivityVisualElements as RtType>::Abi) -> HRESULT,
    fn get_ContentUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_ContentUri(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_ContentType(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ContentType(&self, value: HSTRING) -> HRESULT,
    fn get_FallbackUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_FallbackUri(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_ActivationUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_ActivationUri(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_ContentInfo(&self, out: *mut <IUserActivityContentInfo as RtType>::Abi) -> HRESULT,
    fn put_ContentInfo(&self, value: <IUserActivityContentInfo as RtType>::Abi) -> HRESULT,
    fn SaveAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn CreateSession(&self, out: *mut <UserActivitySession as RtType>::Abi) -> HRESULT
}}
impl IUserActivity {
    #[inline] pub fn get_state(&self) -> Result<UserActivityState> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_State)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_activity_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ActivityId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_visual_elements(&self) -> Result<Option<UserActivityVisualElements>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_VisualElements)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserActivityVisualElements::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_content_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContentUri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_content_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ContentUri)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_content_type(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContentType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_content_type(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ContentType)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_fallback_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_FallbackUri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_fallback_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_FallbackUri)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_activation_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ActivationUri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_activation_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ActivationUri)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_content_info(&self) -> Result<Option<IUserActivityContentInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ContentInfo)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IUserActivityContentInfo::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_content_info(&self, value: &IUserActivityContentInfo) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ContentInfo)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn save_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SaveAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_session(&self) -> Result<Option<UserActivitySession>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateSession)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserActivitySession::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserActivity: IUserActivity}
impl RtActivatable<IUserActivityFactory> for UserActivity {}
impl RtActivatable<IUserActivityStatics> for UserActivity {}
impl UserActivity {
    #[inline] pub fn create_with_activity_id(activityId: &HStringArg) -> Result<UserActivity> {
        <Self as RtActivatable<IUserActivityFactory>>::get_activation_factory().create_with_activity_id(activityId)
    }
    #[inline] pub fn try_parse_from_json(json: &HStringArg) -> Result<Option<UserActivity>> {
        <Self as RtActivatable<IUserActivityStatics>>::get_activation_factory().try_parse_from_json(json)
    }
    #[inline] pub fn try_parse_from_json_array(json: &HStringArg) -> Result<Option<foundation::collections::IVector<UserActivity>>> {
        <Self as RtActivatable<IUserActivityStatics>>::get_activation_factory().try_parse_from_json_array(json)
    }
    #[inline] pub fn to_json_array(activities: &foundation::collections::IIterable<UserActivity>) -> Result<HString> {
        <Self as RtActivatable<IUserActivityStatics>>::get_activation_factory().to_json_array(activities)
    }
}
DEFINE_CLSID!(UserActivity(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,85,115,101,114,65,99,116,105,118,105,116,105,101,115,46,85,115,101,114,65,99,116,105,118,105,116,121,0]) [CLSID_UserActivity]);
DEFINE_IID!(IID_IUserActivity2, 2646871138, 2244, 18348, 170, 156, 43, 178, 34, 28, 85, 253);
RT_INTERFACE!{interface IUserActivity2(IUserActivity2Vtbl): IInspectable [IID_IUserActivity2] {
    fn ToJson(&self, out: *mut HSTRING) -> HRESULT
}}
impl IUserActivity2 {
    #[inline] pub fn to_json(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ToJson)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUserActivity3, 3882448708, 57762, 20807, 142, 6, 85, 241, 238, 239, 39, 28);
RT_INTERFACE!{interface IUserActivity3(IUserActivity3Vtbl): IInspectable [IID_IUserActivity3] {
    fn get_IsRoamable(&self, out: *mut bool) -> HRESULT,
    fn put_IsRoamable(&self, value: bool) -> HRESULT
}}
impl IUserActivity3 {
    #[inline] pub fn get_is_roamable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsRoamable)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_roamable(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsRoamable)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUserActivityAttribution, 883280053, 34525, 19180, 164, 145, 106, 79, 174, 165, 210, 46);
RT_INTERFACE!{interface IUserActivityAttribution(IUserActivityAttributionVtbl): IInspectable [IID_IUserActivityAttribution] {
    fn get_IconUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_IconUri(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_AlternateText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AlternateText(&self, value: HSTRING) -> HRESULT,
    fn get_AddImageQuery(&self, out: *mut bool) -> HRESULT,
    fn put_AddImageQuery(&self, value: bool) -> HRESULT
}}
impl IUserActivityAttribution {
    #[inline] pub fn get_icon_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_IconUri)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_icon_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IconUri)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_alternate_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AlternateText)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_alternate_text(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AlternateText)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_add_image_query(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AddImageQuery)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_add_image_query(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AddImageQuery)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UserActivityAttribution: IUserActivityAttribution}
impl RtActivatable<IUserActivityAttributionFactory> for UserActivityAttribution {}
impl RtActivatable<IActivationFactory> for UserActivityAttribution {}
impl UserActivityAttribution {
    #[inline] pub fn create_with_uri(iconUri: &foundation::Uri) -> Result<UserActivityAttribution> {
        <Self as RtActivatable<IUserActivityAttributionFactory>>::get_activation_factory().create_with_uri(iconUri)
    }
}
DEFINE_CLSID!(UserActivityAttribution(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,85,115,101,114,65,99,116,105,118,105,116,105,101,115,46,85,115,101,114,65,99,116,105,118,105,116,121,65,116,116,114,105,98,117,116,105,111,110,0]) [CLSID_UserActivityAttribution]);
DEFINE_IID!(IID_IUserActivityAttributionFactory, 3861631570, 50534, 20290, 153, 116, 145, 108, 77, 118, 55, 126);
RT_INTERFACE!{static interface IUserActivityAttributionFactory(IUserActivityAttributionFactoryVtbl): IInspectable [IID_IUserActivityAttributionFactory] {
    fn CreateWithUri(&self, iconUri: <foundation::Uri as RtType>::Abi, out: *mut <UserActivityAttribution as RtType>::Abi) -> HRESULT
}}
impl IUserActivityAttributionFactory {
    #[inline] pub fn create_with_uri(&self, iconUri: &foundation::Uri) -> Result<UserActivityAttribution> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWithUri)(self.get_abi() as *const _ as *mut _, iconUri.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserActivityAttribution::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUserActivityChannel, 3133208760, 41188, 18491, 185, 72, 156, 186, 189, 6, 7, 12);
RT_INTERFACE!{interface IUserActivityChannel(IUserActivityChannelVtbl): IInspectable [IID_IUserActivityChannel] {
    fn GetOrCreateUserActivityAsync(&self, activityId: HSTRING, out: *mut <foundation::IAsyncOperation<UserActivity> as RtType>::Abi) -> HRESULT,
    fn DeleteActivityAsync(&self, activityId: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn DeleteAllActivitiesAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IUserActivityChannel {
    #[inline] pub fn get_or_create_user_activity_async(&self, activityId: &HStringArg) -> Result<foundation::IAsyncOperation<UserActivity>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetOrCreateUserActivityAsync)(self.get_abi() as *const _ as *mut _, activityId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_activity_async(&self, activityId: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteActivityAsync)(self.get_abi() as *const _ as *mut _, activityId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_all_activities_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteAllActivitiesAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserActivityChannel: IUserActivityChannel}
impl RtActivatable<IUserActivityChannelStatics> for UserActivityChannel {}
impl RtActivatable<IUserActivityChannelStatics2> for UserActivityChannel {}
impl UserActivityChannel {
    #[inline] pub fn get_default() -> Result<Option<UserActivityChannel>> {
        <Self as RtActivatable<IUserActivityChannelStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn disable_auto_session_creation() -> Result<()> {
        <Self as RtActivatable<IUserActivityChannelStatics2>>::get_activation_factory().disable_auto_session_creation()
    }
    #[cfg(feature="windows-security")] #[inline] pub fn try_get_for_web_account(account: &super::super::security::credentials::WebAccount) -> Result<Option<UserActivityChannel>> {
        <Self as RtActivatable<IUserActivityChannelStatics2>>::get_activation_factory().try_get_for_web_account(account)
    }
}
DEFINE_CLSID!(UserActivityChannel(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,85,115,101,114,65,99,116,105,118,105,116,105,101,115,46,85,115,101,114,65,99,116,105,118,105,116,121,67,104,97,110,110,101,108,0]) [CLSID_UserActivityChannel]);
DEFINE_IID!(IID_IUserActivityChannel2, 379118427, 60286, 20128, 191, 23, 164, 89, 232, 190, 112, 108);
RT_INTERFACE!{interface IUserActivityChannel2(IUserActivityChannel2Vtbl): IInspectable [IID_IUserActivityChannel2] {
    fn GetRecentUserActivitiesAsync(&self, maxUniqueActivities: i32, out: *mut <foundation::IAsyncOperation<foundation::collections::IVector<UserActivitySessionHistoryItem>> as RtType>::Abi) -> HRESULT,
    fn GetSessionHistoryItemsForUserActivityAsync(&self, activityId: HSTRING, startTime: foundation::DateTime, out: *mut <foundation::IAsyncOperation<foundation::collections::IVector<UserActivitySessionHistoryItem>> as RtType>::Abi) -> HRESULT
}}
impl IUserActivityChannel2 {
    #[inline] pub fn get_recent_user_activities_async(&self, maxUniqueActivities: i32) -> Result<foundation::IAsyncOperation<foundation::collections::IVector<UserActivitySessionHistoryItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetRecentUserActivitiesAsync)(self.get_abi() as *const _ as *mut _, maxUniqueActivities, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_session_history_items_for_user_activity_async(&self, activityId: &HStringArg, startTime: foundation::DateTime) -> Result<foundation::IAsyncOperation<foundation::collections::IVector<UserActivitySessionHistoryItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetSessionHistoryItemsForUserActivityAsync)(self.get_abi() as *const _ as *mut _, activityId.get(), startTime, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUserActivityChannelStatics, 3368027563, 6541, 19840, 171, 178, 201, 119, 94, 196, 167, 41);
RT_INTERFACE!{static interface IUserActivityChannelStatics(IUserActivityChannelStaticsVtbl): IInspectable [IID_IUserActivityChannelStatics] {
    fn GetDefault(&self, out: *mut <UserActivityChannel as RtType>::Abi) -> HRESULT
}}
impl IUserActivityChannelStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<UserActivityChannel>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDefault)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserActivityChannel::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUserActivityChannelStatics2, 2391268912, 43599, 17956, 154, 208, 212, 15, 59, 160, 49, 124);
RT_INTERFACE!{static interface IUserActivityChannelStatics2(IUserActivityChannelStatics2Vtbl): IInspectable [IID_IUserActivityChannelStatics2] {
    fn DisableAutoSessionCreation(&self) -> HRESULT,
    #[cfg(feature="windows-security")] fn TryGetForWebAccount(&self, account: <super::super::security::credentials::WebAccount as RtType>::Abi, out: *mut <UserActivityChannel as RtType>::Abi) -> HRESULT
}}
impl IUserActivityChannelStatics2 {
    #[inline] pub fn disable_auto_session_creation(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().DisableAutoSessionCreation)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn try_get_for_web_account(&self, account: &super::super::security::credentials::WebAccount) -> Result<Option<UserActivityChannel>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryGetForWebAccount)(self.get_abi() as *const _ as *mut _, account.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserActivityChannel::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUserActivityContentInfo, 3013207469, 4991, 16541, 130, 45, 225, 175, 39, 206, 8, 220);
RT_INTERFACE!{interface IUserActivityContentInfo(IUserActivityContentInfoVtbl): IInspectable [IID_IUserActivityContentInfo] {
    fn ToJson(&self, out: *mut HSTRING) -> HRESULT
}}
impl IUserActivityContentInfo {
    #[inline] pub fn to_json(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ToJson)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserActivityContentInfo: IUserActivityContentInfo}
impl RtActivatable<IUserActivityContentInfoStatics> for UserActivityContentInfo {}
impl UserActivityContentInfo {
    #[inline] pub fn from_json(value: &HStringArg) -> Result<Option<UserActivityContentInfo>> {
        <Self as RtActivatable<IUserActivityContentInfoStatics>>::get_activation_factory().from_json(value)
    }
}
DEFINE_CLSID!(UserActivityContentInfo(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,85,115,101,114,65,99,116,105,118,105,116,105,101,115,46,85,115,101,114,65,99,116,105,118,105,116,121,67,111,110,116,101,110,116,73,110,102,111,0]) [CLSID_UserActivityContentInfo]);
DEFINE_IID!(IID_IUserActivityContentInfoStatics, 2575876939, 902, 19401, 150, 138, 130, 0, 176, 4, 20, 79);
RT_INTERFACE!{static interface IUserActivityContentInfoStatics(IUserActivityContentInfoStaticsVtbl): IInspectable [IID_IUserActivityContentInfoStatics] {
    fn FromJson(&self, value: HSTRING, out: *mut <UserActivityContentInfo as RtType>::Abi) -> HRESULT
}}
impl IUserActivityContentInfoStatics {
    #[inline] pub fn from_json(&self, value: &HStringArg) -> Result<Option<UserActivityContentInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FromJson)(self.get_abi() as *const _ as *mut _, value.get(), &mut out);
        if hr == S_OK { Ok(UserActivityContentInfo::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUserActivityFactory, 2084067160, 13853, 19047, 138, 59, 52, 202, 41, 120, 249, 163);
RT_INTERFACE!{static interface IUserActivityFactory(IUserActivityFactoryVtbl): IInspectable [IID_IUserActivityFactory] {
    fn CreateWithActivityId(&self, activityId: HSTRING, out: *mut <UserActivity as RtType>::Abi) -> HRESULT
}}
impl IUserActivityFactory {
    #[inline] pub fn create_with_activity_id(&self, activityId: &HStringArg) -> Result<UserActivity> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWithActivityId)(self.get_abi() as *const _ as *mut _, activityId.get(), &mut out);
        if hr == S_OK { Ok(UserActivity::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUserActivityRequest, 2700043093, 53045, 20464, 136, 51, 80, 203, 75, 114, 224, 109);
RT_INTERFACE!{interface IUserActivityRequest(IUserActivityRequestVtbl): IInspectable [IID_IUserActivityRequest] {
    fn SetUserActivity(&self, activity: <UserActivity as RtType>::Abi) -> HRESULT
}}
impl IUserActivityRequest {
    #[inline] pub fn set_user_activity(&self, activity: &UserActivity) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().SetUserActivity)(self.get_abi() as *const _ as *mut _, activity.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UserActivityRequest: IUserActivityRequest}
DEFINE_IID!(IID_IUserActivityRequestedEventArgs, 2764864076, 33321, 19709, 163, 188, 198, 29, 49, 133, 117, 164);
RT_INTERFACE!{interface IUserActivityRequestedEventArgs(IUserActivityRequestedEventArgsVtbl): IInspectable [IID_IUserActivityRequestedEventArgs] {
    fn get_Request(&self, out: *mut <UserActivityRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IUserActivityRequestedEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<UserActivityRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserActivityRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserActivityRequestedEventArgs: IUserActivityRequestedEventArgs}
DEFINE_IID!(IID_IUserActivityRequestManager, 204521038, 36925, 18646, 130, 212, 64, 67, 237, 87, 121, 27);
RT_INTERFACE!{interface IUserActivityRequestManager(IUserActivityRequestManagerVtbl): IInspectable [IID_IUserActivityRequestManager] {
    fn add_UserActivityRequested(&self, handler: <foundation::TypedEventHandler<UserActivityRequestManager, UserActivityRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_UserActivityRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IUserActivityRequestManager {
    #[inline] pub fn add_user_activity_requested(&self, handler: &foundation::TypedEventHandler<UserActivityRequestManager, UserActivityRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_UserActivityRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_user_activity_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_UserActivityRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UserActivityRequestManager: IUserActivityRequestManager}
impl RtActivatable<IUserActivityRequestManagerStatics> for UserActivityRequestManager {}
impl UserActivityRequestManager {
    #[inline] pub fn get_for_current_view() -> Result<Option<UserActivityRequestManager>> {
        <Self as RtActivatable<IUserActivityRequestManagerStatics>>::get_activation_factory().get_for_current_view()
    }
}
DEFINE_CLSID!(UserActivityRequestManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,85,115,101,114,65,99,116,105,118,105,116,105,101,115,46,85,115,101,114,65,99,116,105,118,105,116,121,82,101,113,117,101,115,116,77,97,110,97,103,101,114,0]) [CLSID_UserActivityRequestManager]);
DEFINE_IID!(IID_IUserActivityRequestManagerStatics, 3224972785, 8778, 17196, 129, 229, 12, 118, 180, 196, 206, 250);
RT_INTERFACE!{static interface IUserActivityRequestManagerStatics(IUserActivityRequestManagerStaticsVtbl): IInspectable [IID_IUserActivityRequestManagerStatics] {
    fn GetForCurrentView(&self, out: *mut <UserActivityRequestManager as RtType>::Abi) -> HRESULT
}}
impl IUserActivityRequestManagerStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<UserActivityRequestManager>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetForCurrentView)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserActivityRequestManager::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUserActivitySession, 2923646328, 9466, 17571, 173, 72, 110, 218, 97, 170, 25, 36);
RT_INTERFACE!{interface IUserActivitySession(IUserActivitySessionVtbl): IInspectable [IID_IUserActivitySession] {
    fn get_ActivityId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IUserActivitySession {
    #[inline] pub fn get_activity_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ActivityId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserActivitySession: IUserActivitySession}
DEFINE_IID!(IID_IUserActivitySessionHistoryItem, 3906313171, 15965, 18941, 152, 215, 109, 169, 117, 33, 226, 85);
RT_INTERFACE!{interface IUserActivitySessionHistoryItem(IUserActivitySessionHistoryItemVtbl): IInspectable [IID_IUserActivitySessionHistoryItem] {
    fn get_UserActivity(&self, out: *mut <UserActivity as RtType>::Abi) -> HRESULT,
    fn get_StartTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_EndTime(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT
}}
impl IUserActivitySessionHistoryItem {
    #[inline] pub fn get_user_activity(&self) -> Result<Option<UserActivity>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_UserActivity)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserActivity::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_start_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_StartTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_end_time(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EndTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserActivitySessionHistoryItem: IUserActivitySessionHistoryItem}
RT_ENUM! { enum UserActivityState: i32 {
    New = 0, Published = 1,
}}
DEFINE_IID!(IID_IUserActivityStatics, 2358235955, 3593, 18422, 154, 199, 149, 207, 92, 57, 54, 123);
RT_INTERFACE!{static interface IUserActivityStatics(IUserActivityStaticsVtbl): IInspectable [IID_IUserActivityStatics] {
    fn TryParseFromJson(&self, json: HSTRING, out: *mut <UserActivity as RtType>::Abi) -> HRESULT,
    fn TryParseFromJsonArray(&self, json: HSTRING, out: *mut <foundation::collections::IVector<UserActivity> as RtType>::Abi) -> HRESULT,
    fn ToJsonArray(&self, activities: <foundation::collections::IIterable<UserActivity> as RtType>::Abi, out: *mut HSTRING) -> HRESULT
}}
impl IUserActivityStatics {
    #[inline] pub fn try_parse_from_json(&self, json: &HStringArg) -> Result<Option<UserActivity>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryParseFromJson)(self.get_abi() as *const _ as *mut _, json.get(), &mut out);
        if hr == S_OK { Ok(UserActivity::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_parse_from_json_array(&self, json: &HStringArg) -> Result<Option<foundation::collections::IVector<UserActivity>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryParseFromJsonArray)(self.get_abi() as *const _ as *mut _, json.get(), &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn to_json_array(&self, activities: &foundation::collections::IIterable<UserActivity>) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ToJsonArray)(self.get_abi() as *const _ as *mut _, activities.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUserActivityVisualElements, 2490725651, 9775, 18927, 187, 191, 155, 117, 210, 232, 82, 80);
RT_INTERFACE!{interface IUserActivityVisualElements(IUserActivityVisualElementsVtbl): IInspectable [IID_IUserActivityVisualElements] {
    fn get_DisplayText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayText(&self, value: HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_BackgroundColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_BackgroundColor(&self, value: super::super::ui::Color) -> HRESULT,
    fn get_Attribution(&self, out: *mut <UserActivityAttribution as RtType>::Abi) -> HRESULT,
    fn put_Attribution(&self, value: <UserActivityAttribution as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_Content(&self, value: <super::super::ui::shell::IAdaptiveCard as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_Content(&self, out: *mut <super::super::ui::shell::IAdaptiveCard as RtType>::Abi) -> HRESULT
}}
impl IUserActivityVisualElements {
    #[inline] pub fn get_display_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayText)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_text(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayText)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Description)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_description(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Description)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_background_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_BackgroundColor)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_background_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_BackgroundColor)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_attribution(&self) -> Result<Option<UserActivityAttribution>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Attribution)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserActivityAttribution::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_attribution(&self, value: &UserActivityAttribution) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Attribution)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_content(&self, value: &super::super::ui::shell::IAdaptiveCard) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Content)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_content(&self) -> Result<Option<super::super::ui::shell::IAdaptiveCard>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Content)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::ui::shell::IAdaptiveCard::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserActivityVisualElements: IUserActivityVisualElements}
DEFINE_IID!(IID_IUserActivityVisualElements2, 3400433607, 16111, 17241, 130, 92, 157, 81, 185, 34, 13, 227);
RT_INTERFACE!{interface IUserActivityVisualElements2(IUserActivityVisualElements2Vtbl): IInspectable [IID_IUserActivityVisualElements2] {
    fn get_AttributionDisplayText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AttributionDisplayText(&self, value: HSTRING) -> HRESULT
}}
impl IUserActivityVisualElements2 {
    #[inline] pub fn get_attribution_display_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AttributionDisplayText)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_attribution_display_text(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AttributionDisplayText)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
pub mod core { // Windows.ApplicationModel.UserActivities.Core
use crate::prelude::*;
RT_CLASS!{static class CoreUserActivityManager}
impl RtActivatable<ICoreUserActivityManagerStatics> for CoreUserActivityManager {}
impl CoreUserActivityManager {
    #[inline] pub fn create_user_activity_session_in_background(activity: &super::UserActivity) -> Result<Option<super::UserActivitySession>> {
        <Self as RtActivatable<ICoreUserActivityManagerStatics>>::get_activation_factory().create_user_activity_session_in_background(activity)
    }
    #[inline] pub fn delete_user_activity_sessions_in_time_range_async(channel: &super::UserActivityChannel, startTime: foundation::DateTime, endTime: foundation::DateTime) -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<ICoreUserActivityManagerStatics>>::get_activation_factory().delete_user_activity_sessions_in_time_range_async(channel, startTime, endTime)
    }
}
DEFINE_CLSID!(CoreUserActivityManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,85,115,101,114,65,99,116,105,118,105,116,105,101,115,46,67,111,114,101,46,67,111,114,101,85,115,101,114,65,99,116,105,118,105,116,121,77,97,110,97,103,101,114,0]) [CLSID_CoreUserActivityManager]);
DEFINE_IID!(IID_ICoreUserActivityManagerStatics, 3392854786, 42174, 19789, 191, 168, 103, 149, 244, 38, 78, 251);
RT_INTERFACE!{static interface ICoreUserActivityManagerStatics(ICoreUserActivityManagerStaticsVtbl): IInspectable [IID_ICoreUserActivityManagerStatics] {
    fn CreateUserActivitySessionInBackground(&self, activity: <super::UserActivity as RtType>::Abi, out: *mut <super::UserActivitySession as RtType>::Abi) -> HRESULT,
    fn DeleteUserActivitySessionsInTimeRangeAsync(&self, channel: <super::UserActivityChannel as RtType>::Abi, startTime: foundation::DateTime, endTime: foundation::DateTime, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl ICoreUserActivityManagerStatics {
    #[inline] pub fn create_user_activity_session_in_background(&self, activity: &super::UserActivity) -> Result<Option<super::UserActivitySession>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateUserActivitySessionInBackground)(self.get_abi() as *const _ as *mut _, activity.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::UserActivitySession::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_user_activity_sessions_in_time_range_async(&self, channel: &super::UserActivityChannel, startTime: foundation::DateTime, endTime: foundation::DateTime) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteUserActivitySessionsInTimeRangeAsync)(self.get_abi() as *const _ as *mut _, channel.get_abi() as *const _ as *mut _, startTime, endTime, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
} // Windows.ApplicationModel.UserActivities.Core
} // Windows.ApplicationModel.UserActivities
pub mod userdataaccounts { // Windows.ApplicationModel.UserDataAccounts
use crate::prelude::*;
DEFINE_IID!(IID_IUserDataAccount, 3116643966, 45896, 18704, 190, 148, 74, 212, 187, 166, 222, 167);
RT_INTERFACE!{interface IUserDataAccount(IUserDataAccountVtbl): IInspectable [IID_IUserDataAccount] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_UserDisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_UserDisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_OtherAppReadAccess(&self, out: *mut UserDataAccountOtherAppReadAccess) -> HRESULT,
    fn put_OtherAppReadAccess(&self, value: UserDataAccountOtherAppReadAccess) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Icon(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    fn get_DeviceAccountTypeId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn SaveAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn DeleteAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn FindAppointmentCalendarsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<super::appointments::AppointmentCalendar>> as RtType>::Abi) -> HRESULT,
    fn FindEmailMailboxesAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<super::email::EmailMailbox>> as RtType>::Abi) -> HRESULT,
    fn FindContactListsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<super::contacts::ContactList>> as RtType>::Abi) -> HRESULT,
    fn FindContactAnnotationListsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<super::contacts::ContactAnnotationList>> as RtType>::Abi) -> HRESULT
}}
impl IUserDataAccount {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_user_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_UserDisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_user_display_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_UserDisplayName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_other_app_read_access(&self) -> Result<UserDataAccountOtherAppReadAccess> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_OtherAppReadAccess)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_other_app_read_access(&self, value: UserDataAccountOtherAppReadAccess) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_OtherAppReadAccess)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_icon(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Icon)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_account_type_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DeviceAccountTypeId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_package_family_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PackageFamilyName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn save_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SaveAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_appointment_calendars_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<super::appointments::AppointmentCalendar>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindAppointmentCalendarsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_email_mailboxes_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<super::email::EmailMailbox>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindEmailMailboxesAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_contact_lists_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<super::contacts::ContactList>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindContactListsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_contact_annotation_lists_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<super::contacts::ContactAnnotationList>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindContactAnnotationListsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataAccount: IUserDataAccount}
DEFINE_IID!(IID_IUserDataAccount2, 126671007, 56962, 16459, 129, 149, 200, 163, 172, 25, 143, 96);
RT_INTERFACE!{interface IUserDataAccount2(IUserDataAccount2Vtbl): IInspectable [IID_IUserDataAccount2] {
    fn get_EnterpriseId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsProtectedUnderLock(&self, out: *mut bool) -> HRESULT
}}
impl IUserDataAccount2 {
    #[inline] pub fn get_enterprise_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EnterpriseId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_protected_under_lock(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsProtectedUnderLock)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUserDataAccount3, 22231109, 27715, 17030, 157, 105, 62, 23, 9, 161, 242, 102);
RT_INTERFACE!{interface IUserDataAccount3(IUserDataAccount3Vtbl): IInspectable [IID_IUserDataAccount3] {
    fn get_ExplictReadAccessPackageFamilyNames(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT
}}
impl IUserDataAccount3 {
    #[inline] pub fn get_explict_read_access_package_family_names(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ExplictReadAccessPackageFamilyNames)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUserDataAccount4, 3291566608, 60133, 20234, 168, 178, 28, 202, 17, 94, 0, 143);
RT_INTERFACE!{interface IUserDataAccount4(IUserDataAccount4Vtbl): IInspectable [IID_IUserDataAccount4] {
    fn get_CanShowCreateContactGroup(&self, out: *mut bool) -> HRESULT,
    fn put_CanShowCreateContactGroup(&self, value: bool) -> HRESULT,
    fn get_ProviderProperties(&self, out: *mut <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT,
    fn FindUserDataTaskListsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<super::userdatatasks::UserDataTaskList>> as RtType>::Abi) -> HRESULT,
    fn FindContactGroupsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<super::contacts::ContactGroup>> as RtType>::Abi) -> HRESULT,
    fn TryShowCreateContactGroupAsync(&self, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn put_IsProtectedUnderLock(&self, value: bool) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_Icon(&self, value: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT
}}
impl IUserDataAccount4 {
    #[inline] pub fn get_can_show_create_contact_group(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CanShowCreateContactGroup)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_can_show_create_contact_group(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CanShowCreateContactGroup)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_provider_properties(&self) -> Result<Option<foundation::collections::IPropertySet>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ProviderProperties)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IPropertySet::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_user_data_task_lists_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<super::userdatatasks::UserDataTaskList>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindUserDataTaskListsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_contact_groups_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<super::contacts::ContactGroup>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindContactGroupsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_show_create_contact_group_async(&self) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryShowCreateContactGroupAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_is_protected_under_lock(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsProtectedUnderLock)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_icon(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Icon)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum UserDataAccountContentKinds: u32 {
    Email = 1, Contact = 2, Appointment = 4,
}}
RT_CLASS!{static class UserDataAccountManager}
impl RtActivatable<IUserDataAccountManagerStatics> for UserDataAccountManager {}
impl RtActivatable<IUserDataAccountManagerStatics2> for UserDataAccountManager {}
impl UserDataAccountManager {
    #[inline] pub fn request_store_async(storeAccessType: UserDataAccountStoreAccessType) -> Result<foundation::IAsyncOperation<UserDataAccountStore>> {
        <Self as RtActivatable<IUserDataAccountManagerStatics>>::get_activation_factory().request_store_async(storeAccessType)
    }
    #[inline] pub fn show_add_account_async(contentKinds: UserDataAccountContentKinds) -> Result<foundation::IAsyncOperation<HString>> {
        <Self as RtActivatable<IUserDataAccountManagerStatics>>::get_activation_factory().show_add_account_async(contentKinds)
    }
    #[inline] pub fn show_account_settings_async(id: &HStringArg) -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<IUserDataAccountManagerStatics>>::get_activation_factory().show_account_settings_async(id)
    }
    #[inline] pub fn show_account_error_resolver_async(id: &HStringArg) -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<IUserDataAccountManagerStatics>>::get_activation_factory().show_account_error_resolver_async(id)
    }
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(user: &super::super::system::User) -> Result<Option<UserDataAccountManagerForUser>> {
        <Self as RtActivatable<IUserDataAccountManagerStatics2>>::get_activation_factory().get_for_user(user)
    }
}
DEFINE_CLSID!(UserDataAccountManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,85,115,101,114,68,97,116,97,65,99,99,111,117,110,116,115,46,85,115,101,114,68,97,116,97,65,99,99,111,117,110,116,77,97,110,97,103,101,114,0]) [CLSID_UserDataAccountManager]);
DEFINE_IID!(IID_IUserDataAccountManagerForUser, 1453779163, 56207, 16811, 166, 95, 140, 89, 113, 170, 201, 130);
RT_INTERFACE!{interface IUserDataAccountManagerForUser(IUserDataAccountManagerForUserVtbl): IInspectable [IID_IUserDataAccountManagerForUser] {
    fn RequestStoreAsync(&self, storeAccessType: UserDataAccountStoreAccessType, out: *mut <foundation::IAsyncOperation<UserDataAccountStore> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut <super::super::system::User as RtType>::Abi) -> HRESULT
}}
impl IUserDataAccountManagerForUser {
    #[inline] pub fn request_store_async(&self, storeAccessType: UserDataAccountStoreAccessType) -> Result<foundation::IAsyncOperation<UserDataAccountStore>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestStoreAsync)(self.get_abi() as *const _ as *mut _, storeAccessType, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_user(&self) -> Result<Option<super::super::system::User>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_User)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::system::User::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataAccountManagerForUser: IUserDataAccountManagerForUser}
DEFINE_IID!(IID_IUserDataAccountManagerStatics, 228297194, 6440, 18976, 134, 213, 60, 115, 127, 125, 195, 176);
RT_INTERFACE!{static interface IUserDataAccountManagerStatics(IUserDataAccountManagerStaticsVtbl): IInspectable [IID_IUserDataAccountManagerStatics] {
    fn RequestStoreAsync(&self, storeAccessType: UserDataAccountStoreAccessType, out: *mut <foundation::IAsyncOperation<UserDataAccountStore> as RtType>::Abi) -> HRESULT,
    fn ShowAddAccountAsync(&self, contentKinds: UserDataAccountContentKinds, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn ShowAccountSettingsAsync(&self, id: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ShowAccountErrorResolverAsync(&self, id: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IUserDataAccountManagerStatics {
    #[inline] pub fn request_store_async(&self, storeAccessType: UserDataAccountStoreAccessType) -> Result<foundation::IAsyncOperation<UserDataAccountStore>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestStoreAsync)(self.get_abi() as *const _ as *mut _, storeAccessType, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_add_account_async(&self, contentKinds: UserDataAccountContentKinds) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowAddAccountAsync)(self.get_abi() as *const _ as *mut _, contentKinds, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_account_settings_async(&self, id: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowAccountSettingsAsync)(self.get_abi() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_account_error_resolver_async(&self, id: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowAccountErrorResolverAsync)(self.get_abi() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUserDataAccountManagerStatics2, 1782443400, 12651, 17246, 181, 52, 247, 212, 180, 183, 219, 166);
RT_INTERFACE!{static interface IUserDataAccountManagerStatics2(IUserDataAccountManagerStatics2Vtbl): IInspectable [IID_IUserDataAccountManagerStatics2] {
    #[cfg(feature="windows-system")] fn GetForUser(&self, user: <super::super::system::User as RtType>::Abi, out: *mut <UserDataAccountManagerForUser as RtType>::Abi) -> HRESULT
}}
impl IUserDataAccountManagerStatics2 {
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(&self, user: &super::super::system::User) -> Result<Option<UserDataAccountManagerForUser>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetForUser)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserDataAccountManagerForUser::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum UserDataAccountOtherAppReadAccess: i32 {
    SystemOnly = 0, Full = 1, None = 2,
}}
DEFINE_IID!(IID_IUserDataAccountStore, 544452781, 32010, 20086, 191, 69, 35, 104, 249, 120, 165, 154);
RT_INTERFACE!{interface IUserDataAccountStore(IUserDataAccountStoreVtbl): IInspectable [IID_IUserDataAccountStore] {
    fn FindAccountsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<UserDataAccount>> as RtType>::Abi) -> HRESULT,
    fn GetAccountAsync(&self, id: HSTRING, out: *mut <foundation::IAsyncOperation<UserDataAccount> as RtType>::Abi) -> HRESULT,
    fn CreateAccountAsync(&self, userDisplayName: HSTRING, out: *mut <foundation::IAsyncOperation<UserDataAccount> as RtType>::Abi) -> HRESULT
}}
impl IUserDataAccountStore {
    #[inline] pub fn find_accounts_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<UserDataAccount>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindAccountsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_account_async(&self, id: &HStringArg) -> Result<foundation::IAsyncOperation<UserDataAccount>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetAccountAsync)(self.get_abi() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_account_async(&self, userDisplayName: &HStringArg) -> Result<foundation::IAsyncOperation<UserDataAccount>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateAccountAsync)(self.get_abi() as *const _ as *mut _, userDisplayName.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataAccountStore: IUserDataAccountStore}
DEFINE_IID!(IID_IUserDataAccountStore2, 2984292087, 38240, 17969, 138, 240, 6, 29, 48, 22, 20, 105);
RT_INTERFACE!{interface IUserDataAccountStore2(IUserDataAccountStore2Vtbl): IInspectable [IID_IUserDataAccountStore2] {
    fn CreateAccountWithPackageRelativeAppIdAsync(&self, userDisplayName: HSTRING, packageRelativeAppId: HSTRING, out: *mut <foundation::IAsyncOperation<UserDataAccount> as RtType>::Abi) -> HRESULT,
    fn add_StoreChanged(&self, handler: <foundation::TypedEventHandler<UserDataAccountStore, UserDataAccountStoreChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StoreChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IUserDataAccountStore2 {
    #[inline] pub fn create_account_with_package_relative_app_id_async(&self, userDisplayName: &HStringArg, packageRelativeAppId: &HStringArg) -> Result<foundation::IAsyncOperation<UserDataAccount>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateAccountWithPackageRelativeAppIdAsync)(self.get_abi() as *const _ as *mut _, userDisplayName.get(), packageRelativeAppId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_store_changed(&self, handler: &foundation::TypedEventHandler<UserDataAccountStore, UserDataAccountStoreChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_StoreChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_store_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_StoreChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUserDataAccountStore3, 2168635540, 62409, 18315, 177, 23, 101, 133, 190, 187, 103, 137);
RT_INTERFACE!{interface IUserDataAccountStore3(IUserDataAccountStore3Vtbl): IInspectable [IID_IUserDataAccountStore3] {
    fn CreateAccountWithPackageRelativeAppIdAndEnterpriseIdAsync(&self, userDisplayName: HSTRING, packageRelativeAppId: HSTRING, enterpriseId: HSTRING, out: *mut <foundation::IAsyncOperation<UserDataAccount> as RtType>::Abi) -> HRESULT
}}
impl IUserDataAccountStore3 {
    #[inline] pub fn create_account_with_package_relative_app_id_and_enterprise_id_async(&self, userDisplayName: &HStringArg, packageRelativeAppId: &HStringArg, enterpriseId: &HStringArg) -> Result<foundation::IAsyncOperation<UserDataAccount>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateAccountWithPackageRelativeAppIdAndEnterpriseIdAsync)(self.get_abi() as *const _ as *mut _, userDisplayName.get(), packageRelativeAppId.get(), enterpriseId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum UserDataAccountStoreAccessType: i32 {
    AllAccountsReadOnly = 0, AppAccountsReadWrite = 1,
}}
DEFINE_IID!(IID_IUserDataAccountStoreChangedEventArgs, 2229527269, 34848, 17682, 177, 246, 46, 3, 91, 225, 7, 44);
RT_INTERFACE!{interface IUserDataAccountStoreChangedEventArgs(IUserDataAccountStoreChangedEventArgsVtbl): IInspectable [IID_IUserDataAccountStoreChangedEventArgs] {
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IUserDataAccountStoreChangedEventArgs {
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataAccountStoreChangedEventArgs: IUserDataAccountStoreChangedEventArgs}
pub mod provider { // Windows.ApplicationModel.UserDataAccounts.Provider
use crate::prelude::*;
DEFINE_IID!(IID_IUserDataAccountPartnerAccountInfo, 1595932727, 63215, 20163, 134, 48, 1, 44, 89, 193, 20, 159);
RT_INTERFACE!{interface IUserDataAccountPartnerAccountInfo(IUserDataAccountPartnerAccountInfoVtbl): IInspectable [IID_IUserDataAccountPartnerAccountInfo] {
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Priority(&self, out: *mut u32) -> HRESULT,
    fn get_AccountKind(&self, out: *mut UserDataAccountProviderPartnerAccountKind) -> HRESULT
}}
impl IUserDataAccountPartnerAccountInfo {
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_priority(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Priority)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_account_kind(&self) -> Result<UserDataAccountProviderPartnerAccountKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AccountKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataAccountPartnerAccountInfo: IUserDataAccountPartnerAccountInfo}
DEFINE_IID!(IID_IUserDataAccountProviderAddAccountOperation, 3116836144, 16260, 19293, 142, 170, 69, 233, 122, 168, 66, 237);
RT_INTERFACE!{interface IUserDataAccountProviderAddAccountOperation(IUserDataAccountProviderAddAccountOperationVtbl): IInspectable [IID_IUserDataAccountProviderAddAccountOperation] {
    fn get_ContentKinds(&self, out: *mut super::UserDataAccountContentKinds) -> HRESULT,
    fn get_PartnerAccountInfos(&self, out: *mut <foundation::collections::IVectorView<UserDataAccountPartnerAccountInfo> as RtType>::Abi) -> HRESULT,
    fn ReportCompleted(&self, userDataAccountId: HSTRING) -> HRESULT
}}
impl IUserDataAccountProviderAddAccountOperation {
    #[inline] pub fn get_content_kinds(&self) -> Result<super::UserDataAccountContentKinds> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ContentKinds)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_partner_account_infos(&self) -> Result<Option<foundation::collections::IVectorView<UserDataAccountPartnerAccountInfo>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PartnerAccountInfos)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed(&self, userDataAccountId: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportCompleted)(self.get_abi() as *const _ as *mut _, userDataAccountId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataAccountProviderAddAccountOperation: IUserDataAccountProviderAddAccountOperation}
DEFINE_IID!(IID_IUserDataAccountProviderOperation, 2718608739, 34956, 19042, 163, 221, 52, 208, 122, 128, 43, 43);
RT_INTERFACE!{interface IUserDataAccountProviderOperation(IUserDataAccountProviderOperationVtbl): IInspectable [IID_IUserDataAccountProviderOperation] {
    fn get_Kind(&self, out: *mut UserDataAccountProviderOperationKind) -> HRESULT
}}
impl IUserDataAccountProviderOperation {
    #[inline] pub fn get_kind(&self) -> Result<UserDataAccountProviderOperationKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Kind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum UserDataAccountProviderOperationKind: i32 {
    AddAccount = 0, Settings = 1, ResolveErrors = 2,
}}
RT_ENUM! { enum UserDataAccountProviderPartnerAccountKind: i32 {
    Exchange = 0, PopOrImap = 1,
}}
DEFINE_IID!(IID_IUserDataAccountProviderResolveErrorsOperation, 1647696917, 49099, 16865, 153, 87, 151, 89, 162, 136, 70, 204);
RT_INTERFACE!{interface IUserDataAccountProviderResolveErrorsOperation(IUserDataAccountProviderResolveErrorsOperationVtbl): IInspectable [IID_IUserDataAccountProviderResolveErrorsOperation] {
    fn get_UserDataAccountId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompleted(&self) -> HRESULT
}}
impl IUserDataAccountProviderResolveErrorsOperation {
    #[inline] pub fn get_user_data_account_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_UserDataAccountId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportCompleted)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataAccountProviderResolveErrorsOperation: IUserDataAccountProviderResolveErrorsOperation}
DEFINE_IID!(IID_IUserDataAccountProviderSettingsOperation, 2449690039, 34376, 20272, 172, 250, 48, 2, 101, 140, 168, 13);
RT_INTERFACE!{interface IUserDataAccountProviderSettingsOperation(IUserDataAccountProviderSettingsOperationVtbl): IInspectable [IID_IUserDataAccountProviderSettingsOperation] {
    fn get_UserDataAccountId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompleted(&self) -> HRESULT
}}
impl IUserDataAccountProviderSettingsOperation {
    #[inline] pub fn get_user_data_account_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_UserDataAccountId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().ReportCompleted)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataAccountProviderSettingsOperation: IUserDataAccountProviderSettingsOperation}
} // Windows.ApplicationModel.UserDataAccounts.Provider
pub mod systemaccess { // Windows.ApplicationModel.UserDataAccounts.SystemAccess
use crate::prelude::*;
RT_ENUM! { enum DeviceAccountAuthenticationType: i32 {
    Basic = 0, OAuth = 1, SingleSignOn = 2,
}}
DEFINE_IID!(IID_IDeviceAccountConfiguration, 2902533027, 64476, 19739, 190, 67, 90, 39, 234, 74, 27, 99);
RT_INTERFACE!{interface IDeviceAccountConfiguration(IDeviceAccountConfigurationVtbl): IInspectable [IID_IDeviceAccountConfiguration] {
    fn get_AccountName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AccountName(&self, value: HSTRING) -> HRESULT,
    fn get_DeviceAccountTypeId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DeviceAccountTypeId(&self, value: HSTRING) -> HRESULT,
    fn get_ServerType(&self, out: *mut DeviceAccountServerType) -> HRESULT,
    fn put_ServerType(&self, value: DeviceAccountServerType) -> HRESULT,
    fn get_EmailAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn put_EmailAddress(&self, value: HSTRING) -> HRESULT,
    fn get_Domain(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Domain(&self, value: HSTRING) -> HRESULT,
    fn get_EmailSyncEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_EmailSyncEnabled(&self, value: bool) -> HRESULT,
    fn get_ContactsSyncEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_ContactsSyncEnabled(&self, value: bool) -> HRESULT,
    fn get_CalendarSyncEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_CalendarSyncEnabled(&self, value: bool) -> HRESULT,
    fn get_IncomingServerAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn put_IncomingServerAddress(&self, value: HSTRING) -> HRESULT,
    fn get_IncomingServerPort(&self, out: *mut i32) -> HRESULT,
    fn put_IncomingServerPort(&self, value: i32) -> HRESULT,
    fn get_IncomingServerRequiresSsl(&self, out: *mut bool) -> HRESULT,
    fn put_IncomingServerRequiresSsl(&self, value: bool) -> HRESULT,
    fn get_IncomingServerUsername(&self, out: *mut HSTRING) -> HRESULT,
    fn put_IncomingServerUsername(&self, value: HSTRING) -> HRESULT,
    fn get_OutgoingServerAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn put_OutgoingServerAddress(&self, value: HSTRING) -> HRESULT,
    fn get_OutgoingServerPort(&self, out: *mut i32) -> HRESULT,
    fn put_OutgoingServerPort(&self, value: i32) -> HRESULT,
    fn get_OutgoingServerRequiresSsl(&self, out: *mut bool) -> HRESULT,
    fn put_OutgoingServerRequiresSsl(&self, value: bool) -> HRESULT,
    fn get_OutgoingServerUsername(&self, out: *mut HSTRING) -> HRESULT,
    fn put_OutgoingServerUsername(&self, value: HSTRING) -> HRESULT
}}
impl IDeviceAccountConfiguration {
    #[inline] pub fn get_account_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AccountName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_account_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AccountName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_device_account_type_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DeviceAccountTypeId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_device_account_type_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DeviceAccountTypeId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_server_type(&self) -> Result<DeviceAccountServerType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ServerType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_server_type(&self, value: DeviceAccountServerType) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ServerType)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_email_address(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_EmailAddress)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_email_address(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_EmailAddress)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_domain(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Domain)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_domain(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Domain)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_email_sync_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_EmailSyncEnabled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_email_sync_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_EmailSyncEnabled)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_contacts_sync_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ContactsSyncEnabled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_contacts_sync_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ContactsSyncEnabled)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_calendar_sync_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CalendarSyncEnabled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_calendar_sync_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CalendarSyncEnabled)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_incoming_server_address(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_IncomingServerAddress)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_incoming_server_address(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IncomingServerAddress)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_incoming_server_port(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IncomingServerPort)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_incoming_server_port(&self, value: i32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IncomingServerPort)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_incoming_server_requires_ssl(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IncomingServerRequiresSsl)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_incoming_server_requires_ssl(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IncomingServerRequiresSsl)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_incoming_server_username(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_IncomingServerUsername)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_incoming_server_username(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IncomingServerUsername)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_outgoing_server_address(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_OutgoingServerAddress)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_outgoing_server_address(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_OutgoingServerAddress)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_outgoing_server_port(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_OutgoingServerPort)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_outgoing_server_port(&self, value: i32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_OutgoingServerPort)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_outgoing_server_requires_ssl(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_OutgoingServerRequiresSsl)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_outgoing_server_requires_ssl(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_OutgoingServerRequiresSsl)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_outgoing_server_username(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_OutgoingServerUsername)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_outgoing_server_username(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_OutgoingServerUsername)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceAccountConfiguration: IDeviceAccountConfiguration}
impl RtActivatable<IActivationFactory> for DeviceAccountConfiguration {}
DEFINE_CLSID!(DeviceAccountConfiguration(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,85,115,101,114,68,97,116,97,65,99,99,111,117,110,116,115,46,83,121,115,116,101,109,65,99,99,101,115,115,46,68,101,118,105,99,101,65,99,99,111,117,110,116,67,111,110,102,105,103,117,114,97,116,105,111,110,0]) [CLSID_DeviceAccountConfiguration]);
DEFINE_IID!(IID_IDeviceAccountConfiguration2, 4071810470, 29325, 19018, 137, 69, 43, 248, 88, 1, 54, 222);
RT_INTERFACE!{interface IDeviceAccountConfiguration2(IDeviceAccountConfiguration2Vtbl): IInspectable [IID_IDeviceAccountConfiguration2] {
    #[cfg(not(feature="windows-security"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-security")] fn get_IncomingServerCredential(&self, out: *mut <crate::windows::security::credentials::PasswordCredential as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-security")] fn put_IncomingServerCredential(&self, value: <crate::windows::security::credentials::PasswordCredential as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-security")] fn get_OutgoingServerCredential(&self, out: *mut <crate::windows::security::credentials::PasswordCredential as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-security")] fn put_OutgoingServerCredential(&self, value: <crate::windows::security::credentials::PasswordCredential as RtType>::Abi) -> HRESULT,
    fn get_OAuthRefreshToken(&self, out: *mut HSTRING) -> HRESULT,
    fn put_OAuthRefreshToken(&self, value: HSTRING) -> HRESULT,
    fn get_IsExternallyManaged(&self, out: *mut bool) -> HRESULT,
    fn put_IsExternallyManaged(&self, value: bool) -> HRESULT,
    fn get_AccountIconId(&self, out: *mut DeviceAccountIconId) -> HRESULT,
    fn put_AccountIconId(&self, value: DeviceAccountIconId) -> HRESULT,
    fn get_AuthenticationType(&self, out: *mut DeviceAccountAuthenticationType) -> HRESULT,
    fn put_AuthenticationType(&self, value: DeviceAccountAuthenticationType) -> HRESULT,
    fn get_IsSsoAuthenticationSupported(&self, out: *mut bool) -> HRESULT,
    fn get_SsoAccountId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SsoAccountId(&self, value: HSTRING) -> HRESULT,
    fn get_AlwaysDownloadFullMessage(&self, out: *mut bool) -> HRESULT,
    fn put_AlwaysDownloadFullMessage(&self, value: bool) -> HRESULT,
    fn get_DoesPolicyAllowMailSync(&self, out: *mut bool) -> HRESULT,
    fn get_SyncScheduleKind(&self, out: *mut DeviceAccountSyncScheduleKind) -> HRESULT,
    fn put_SyncScheduleKind(&self, value: DeviceAccountSyncScheduleKind) -> HRESULT,
    fn get_MailAgeFilter(&self, out: *mut DeviceAccountMailAgeFilter) -> HRESULT,
    fn put_MailAgeFilter(&self, value: DeviceAccountMailAgeFilter) -> HRESULT,
    fn get_IsClientAuthenticationCertificateRequired(&self, out: *mut bool) -> HRESULT,
    fn put_IsClientAuthenticationCertificateRequired(&self, value: bool) -> HRESULT,
    fn get_AutoSelectAuthenticationCertificate(&self, out: *mut bool) -> HRESULT,
    fn put_AutoSelectAuthenticationCertificate(&self, value: bool) -> HRESULT,
    fn get_AuthenticationCertificateId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AuthenticationCertificateId(&self, value: HSTRING) -> HRESULT,
    fn get_CardDavSyncScheduleKind(&self, out: *mut DeviceAccountSyncScheduleKind) -> HRESULT,
    fn put_CardDavSyncScheduleKind(&self, value: DeviceAccountSyncScheduleKind) -> HRESULT,
    fn get_CalDavSyncScheduleKind(&self, out: *mut DeviceAccountSyncScheduleKind) -> HRESULT,
    fn put_CalDavSyncScheduleKind(&self, value: DeviceAccountSyncScheduleKind) -> HRESULT,
    fn get_CardDavServerUrl(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_CardDavServerUrl(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_CardDavRequiresSsl(&self, out: *mut bool) -> HRESULT,
    fn put_CardDavRequiresSsl(&self, value: bool) -> HRESULT,
    fn get_CalDavServerUrl(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_CalDavServerUrl(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_CalDavRequiresSsl(&self, out: *mut bool) -> HRESULT,
    fn put_CalDavRequiresSsl(&self, value: bool) -> HRESULT,
    fn get_WasModifiedByUser(&self, out: *mut bool) -> HRESULT,
    fn put_WasModifiedByUser(&self, value: bool) -> HRESULT,
    fn get_WasIncomingServerCertificateHashConfirmed(&self, out: *mut bool) -> HRESULT,
    fn put_WasIncomingServerCertificateHashConfirmed(&self, value: bool) -> HRESULT,
    fn get_IncomingServerCertificateHash(&self, out: *mut HSTRING) -> HRESULT,
    fn put_IncomingServerCertificateHash(&self, value: HSTRING) -> HRESULT,
    fn get_IsOutgoingServerAuthenticationRequired(&self, out: *mut bool) -> HRESULT,
    fn put_IsOutgoingServerAuthenticationRequired(&self, value: bool) -> HRESULT,
    fn get_IsOutgoingServerAuthenticationEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsOutgoingServerAuthenticationEnabled(&self, value: bool) -> HRESULT,
    fn get_WasOutgoingServerCertificateHashConfirmed(&self, out: *mut bool) -> HRESULT,
    fn put_WasOutgoingServerCertificateHashConfirmed(&self, value: bool) -> HRESULT,
    fn get_OutgoingServerCertificateHash(&self, out: *mut HSTRING) -> HRESULT,
    fn put_OutgoingServerCertificateHash(&self, value: HSTRING) -> HRESULT,
    fn get_IsSyncScheduleManagedBySystem(&self, out: *mut bool) -> HRESULT,
    fn put_IsSyncScheduleManagedBySystem(&self, value: bool) -> HRESULT
}}
impl IDeviceAccountConfiguration2 {
    #[cfg(feature="windows-security")] #[inline] pub fn get_incoming_server_credential(&self) -> Result<Option<crate::windows::security::credentials::PasswordCredential>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_IncomingServerCredential)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::security::credentials::PasswordCredential::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn set_incoming_server_credential(&self, value: &crate::windows::security::credentials::PasswordCredential) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IncomingServerCredential)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn get_outgoing_server_credential(&self) -> Result<Option<crate::windows::security::credentials::PasswordCredential>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_OutgoingServerCredential)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::security::credentials::PasswordCredential::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn set_outgoing_server_credential(&self, value: &crate::windows::security::credentials::PasswordCredential) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_OutgoingServerCredential)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_oauth_refresh_token(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_OAuthRefreshToken)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_oauth_refresh_token(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_OAuthRefreshToken)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_externally_managed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsExternallyManaged)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_externally_managed(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsExternallyManaged)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_account_icon_id(&self) -> Result<DeviceAccountIconId> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AccountIconId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_account_icon_id(&self, value: DeviceAccountIconId) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AccountIconId)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_authentication_type(&self) -> Result<DeviceAccountAuthenticationType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AuthenticationType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_authentication_type(&self, value: DeviceAccountAuthenticationType) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AuthenticationType)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_sso_authentication_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsSsoAuthenticationSupported)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sso_account_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SsoAccountId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_sso_account_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SsoAccountId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_always_download_full_message(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AlwaysDownloadFullMessage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_always_download_full_message(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AlwaysDownloadFullMessage)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_does_policy_allow_mail_sync(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DoesPolicyAllowMailSync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sync_schedule_kind(&self) -> Result<DeviceAccountSyncScheduleKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SyncScheduleKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_sync_schedule_kind(&self, value: DeviceAccountSyncScheduleKind) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SyncScheduleKind)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_mail_age_filter(&self) -> Result<DeviceAccountMailAgeFilter> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MailAgeFilter)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_mail_age_filter(&self, value: DeviceAccountMailAgeFilter) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_MailAgeFilter)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_client_authentication_certificate_required(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsClientAuthenticationCertificateRequired)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_client_authentication_certificate_required(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsClientAuthenticationCertificateRequired)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_select_authentication_certificate(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AutoSelectAuthenticationCertificate)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto_select_authentication_certificate(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AutoSelectAuthenticationCertificate)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_authentication_certificate_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AuthenticationCertificateId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_authentication_certificate_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AuthenticationCertificateId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_card_dav_sync_schedule_kind(&self) -> Result<DeviceAccountSyncScheduleKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CardDavSyncScheduleKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_card_dav_sync_schedule_kind(&self, value: DeviceAccountSyncScheduleKind) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CardDavSyncScheduleKind)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cal_dav_sync_schedule_kind(&self) -> Result<DeviceAccountSyncScheduleKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CalDavSyncScheduleKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_cal_dav_sync_schedule_kind(&self, value: DeviceAccountSyncScheduleKind) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CalDavSyncScheduleKind)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_card_dav_server_url(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CardDavServerUrl)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_card_dav_server_url(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CardDavServerUrl)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_card_dav_requires_ssl(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CardDavRequiresSsl)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_card_dav_requires_ssl(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CardDavRequiresSsl)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cal_dav_server_url(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CalDavServerUrl)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_cal_dav_server_url(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CalDavServerUrl)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cal_dav_requires_ssl(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_CalDavRequiresSsl)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_cal_dav_requires_ssl(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CalDavRequiresSsl)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_was_modified_by_user(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_WasModifiedByUser)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_was_modified_by_user(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_WasModifiedByUser)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_was_incoming_server_certificate_hash_confirmed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_WasIncomingServerCertificateHashConfirmed)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_was_incoming_server_certificate_hash_confirmed(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_WasIncomingServerCertificateHashConfirmed)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_incoming_server_certificate_hash(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_IncomingServerCertificateHash)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_incoming_server_certificate_hash(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IncomingServerCertificateHash)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_outgoing_server_authentication_required(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsOutgoingServerAuthenticationRequired)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_outgoing_server_authentication_required(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsOutgoingServerAuthenticationRequired)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_outgoing_server_authentication_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsOutgoingServerAuthenticationEnabled)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_outgoing_server_authentication_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsOutgoingServerAuthenticationEnabled)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_was_outgoing_server_certificate_hash_confirmed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_WasOutgoingServerCertificateHashConfirmed)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_was_outgoing_server_certificate_hash_confirmed(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_WasOutgoingServerCertificateHashConfirmed)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_outgoing_server_certificate_hash(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_OutgoingServerCertificateHash)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_outgoing_server_certificate_hash(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_OutgoingServerCertificateHash)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_sync_schedule_managed_by_system(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsSyncScheduleManagedBySystem)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_sync_schedule_managed_by_system(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsSyncScheduleManagedBySystem)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum DeviceAccountIconId: i32 {
    Exchange = 0, Msa = 1, Outlook = 2, Generic = 3,
}}
RT_ENUM! { enum DeviceAccountMailAgeFilter: i32 {
    All = 0, Last1Day = 1, Last3Days = 2, Last7Days = 3, Last14Days = 4, Last30Days = 5, Last90Days = 6,
}}
RT_ENUM! { enum DeviceAccountServerType: i32 {
    Exchange = 0, Pop = 1, Imap = 2,
}}
RT_ENUM! { enum DeviceAccountSyncScheduleKind: i32 {
    Manual = 0, Every15Minutes = 1, Every30Minutes = 2, Every60Minutes = 3, Every2Hours = 4, Daily = 5, AsItemsArrive = 6,
}}
RT_CLASS!{static class UserDataAccountSystemAccessManager}
impl RtActivatable<IUserDataAccountSystemAccessManagerStatics> for UserDataAccountSystemAccessManager {}
impl RtActivatable<IUserDataAccountSystemAccessManagerStatics2> for UserDataAccountSystemAccessManager {}
impl UserDataAccountSystemAccessManager {
    #[inline] pub fn add_and_show_device_accounts_async(accounts: &foundation::collections::IIterable<DeviceAccountConfiguration>) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<HString>>> {
        <Self as RtActivatable<IUserDataAccountSystemAccessManagerStatics>>::get_activation_factory().add_and_show_device_accounts_async(accounts)
    }
    #[inline] pub fn suppress_local_account_with_account_async(userDataAccountId: &HStringArg) -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<IUserDataAccountSystemAccessManagerStatics2>>::get_activation_factory().suppress_local_account_with_account_async(userDataAccountId)
    }
    #[inline] pub fn create_device_account_async(account: &DeviceAccountConfiguration) -> Result<foundation::IAsyncOperation<HString>> {
        <Self as RtActivatable<IUserDataAccountSystemAccessManagerStatics2>>::get_activation_factory().create_device_account_async(account)
    }
    #[inline] pub fn delete_device_account_async(accountId: &HStringArg) -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<IUserDataAccountSystemAccessManagerStatics2>>::get_activation_factory().delete_device_account_async(accountId)
    }
    #[inline] pub fn get_device_account_configuration_async(accountId: &HStringArg) -> Result<foundation::IAsyncOperation<DeviceAccountConfiguration>> {
        <Self as RtActivatable<IUserDataAccountSystemAccessManagerStatics2>>::get_activation_factory().get_device_account_configuration_async(accountId)
    }
}
DEFINE_CLSID!(UserDataAccountSystemAccessManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,85,115,101,114,68,97,116,97,65,99,99,111,117,110,116,115,46,83,121,115,116,101,109,65,99,99,101,115,115,46,85,115,101,114,68,97,116,97,65,99,99,111,117,110,116,83,121,115,116,101,109,65,99,99,101,115,115,77,97,110,97,103,101,114,0]) [CLSID_UserDataAccountSystemAccessManager]);
DEFINE_IID!(IID_IUserDataAccountSystemAccessManagerStatics, 2641039801, 52197, 17909, 130, 43, 194, 103, 184, 29, 189, 182);
RT_INTERFACE!{static interface IUserDataAccountSystemAccessManagerStatics(IUserDataAccountSystemAccessManagerStaticsVtbl): IInspectable [IID_IUserDataAccountSystemAccessManagerStatics] {
    fn AddAndShowDeviceAccountsAsync(&self, accounts: <foundation::collections::IIterable<DeviceAccountConfiguration> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<HString>> as RtType>::Abi) -> HRESULT
}}
impl IUserDataAccountSystemAccessManagerStatics {
    #[inline] pub fn add_and_show_device_accounts_async(&self, accounts: &foundation::collections::IIterable<DeviceAccountConfiguration>) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().AddAndShowDeviceAccountsAsync)(self.get_abi() as *const _ as *mut _, accounts.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUserDataAccountSystemAccessManagerStatics2, 2487190861, 19278, 17311, 131, 211, 151, 155, 39, 192, 90, 199);
RT_INTERFACE!{static interface IUserDataAccountSystemAccessManagerStatics2(IUserDataAccountSystemAccessManagerStatics2Vtbl): IInspectable [IID_IUserDataAccountSystemAccessManagerStatics2] {
    fn SuppressLocalAccountWithAccountAsync(&self, userDataAccountId: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn CreateDeviceAccountAsync(&self, account: <DeviceAccountConfiguration as RtType>::Abi, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn DeleteDeviceAccountAsync(&self, accountId: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn GetDeviceAccountConfigurationAsync(&self, accountId: HSTRING, out: *mut <foundation::IAsyncOperation<DeviceAccountConfiguration> as RtType>::Abi) -> HRESULT
}}
impl IUserDataAccountSystemAccessManagerStatics2 {
    #[inline] pub fn suppress_local_account_with_account_async(&self, userDataAccountId: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SuppressLocalAccountWithAccountAsync)(self.get_abi() as *const _ as *mut _, userDataAccountId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_device_account_async(&self, account: &DeviceAccountConfiguration) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateDeviceAccountAsync)(self.get_abi() as *const _ as *mut _, account.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_device_account_async(&self, accountId: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteDeviceAccountAsync)(self.get_abi() as *const _ as *mut _, accountId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_account_configuration_async(&self, accountId: &HStringArg) -> Result<foundation::IAsyncOperation<DeviceAccountConfiguration>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeviceAccountConfigurationAsync)(self.get_abi() as *const _ as *mut _, accountId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
} // Windows.ApplicationModel.UserDataAccounts.SystemAccess
} // Windows.ApplicationModel.UserDataAccounts
pub mod userdatatasks { // Windows.ApplicationModel.UserDataTasks
use crate::prelude::*;
DEFINE_IID!(IID_IUserDataTask, 2087028177, 57556, 20377, 174, 226, 188, 45, 93, 218, 223, 76);
RT_INTERFACE!{interface IUserDataTask(IUserDataTaskVtbl): IInspectable [IID_IUserDataTask] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ListId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RemoteId(&self, value: HSTRING) -> HRESULT,
    fn get_CompletedDate(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn put_CompletedDate(&self, value: <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_Details(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Details(&self, value: HSTRING) -> HRESULT,
    fn get_DetailsKind(&self, out: *mut UserDataTaskDetailsKind) -> HRESULT,
    fn put_DetailsKind(&self, value: UserDataTaskDetailsKind) -> HRESULT,
    fn get_DueDate(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn put_DueDate(&self, value: <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_Kind(&self, out: *mut UserDataTaskKind) -> HRESULT,
    fn get_Priority(&self, out: *mut UserDataTaskPriority) -> HRESULT,
    fn put_Priority(&self, value: UserDataTaskPriority) -> HRESULT,
    fn get_RecurrenceProperties(&self, out: *mut <UserDataTaskRecurrenceProperties as RtType>::Abi) -> HRESULT,
    fn put_RecurrenceProperties(&self, value: <UserDataTaskRecurrenceProperties as RtType>::Abi) -> HRESULT,
    fn get_RegenerationProperties(&self, out: *mut <UserDataTaskRegenerationProperties as RtType>::Abi) -> HRESULT,
    fn put_RegenerationProperties(&self, value: <UserDataTaskRegenerationProperties as RtType>::Abi) -> HRESULT,
    fn get_Reminder(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn put_Reminder(&self, value: <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_Sensitivity(&self, out: *mut UserDataTaskSensitivity) -> HRESULT,
    fn put_Sensitivity(&self, value: UserDataTaskSensitivity) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Subject(&self, value: HSTRING) -> HRESULT,
    fn get_StartDate(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn put_StartDate(&self, value: <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT
}}
impl IUserDataTask {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_list_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ListId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_remote_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RemoteId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_remote_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RemoteId)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_completed_date(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CompletedDate)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_completed_date(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_CompletedDate)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_details(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Details)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_details(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Details)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_details_kind(&self) -> Result<UserDataTaskDetailsKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DetailsKind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_details_kind(&self, value: UserDataTaskDetailsKind) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DetailsKind)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_due_date(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DueDate)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_due_date(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DueDate)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_kind(&self) -> Result<UserDataTaskKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Kind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_priority(&self) -> Result<UserDataTaskPriority> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Priority)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_priority(&self, value: UserDataTaskPriority) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Priority)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_recurrence_properties(&self) -> Result<Option<UserDataTaskRecurrenceProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RecurrenceProperties)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserDataTaskRecurrenceProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_recurrence_properties(&self, value: &UserDataTaskRecurrenceProperties) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RecurrenceProperties)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_regeneration_properties(&self) -> Result<Option<UserDataTaskRegenerationProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RegenerationProperties)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserDataTaskRegenerationProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_regeneration_properties(&self, value: &UserDataTaskRegenerationProperties) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RegenerationProperties)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_reminder(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Reminder)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_reminder(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Reminder)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sensitivity(&self) -> Result<UserDataTaskSensitivity> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Sensitivity)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_sensitivity(&self, value: UserDataTaskSensitivity) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Sensitivity)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_subject(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Subject)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_subject(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Subject)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_start_date(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_StartDate)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_start_date(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_StartDate)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTask: IUserDataTask}
impl RtActivatable<IActivationFactory> for UserDataTask {}
DEFINE_CLSID!(UserDataTask(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,85,115,101,114,68,97,116,97,84,97,115,107,115,46,85,115,101,114,68,97,116,97,84,97,115,107,0]) [CLSID_UserDataTask]);
DEFINE_IID!(IID_IUserDataTaskBatch, 942515710, 8373, 17180, 143, 66, 165, 210, 146, 236, 147, 12);
RT_INTERFACE!{interface IUserDataTaskBatch(IUserDataTaskBatchVtbl): IInspectable [IID_IUserDataTaskBatch] {
    fn get_Tasks(&self, out: *mut <foundation::collections::IVectorView<UserDataTask> as RtType>::Abi) -> HRESULT
}}
impl IUserDataTaskBatch {
    #[inline] pub fn get_tasks(&self) -> Result<Option<foundation::collections::IVectorView<UserDataTask>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Tasks)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTaskBatch: IUserDataTaskBatch}
RT_ENUM! { enum UserDataTaskDaysOfWeek: u32 {
    None = 0, Sunday = 1, Monday = 2, Tuesday = 4, Wednesday = 8, Thursday = 16, Friday = 32, Saturday = 64,
}}
RT_ENUM! { enum UserDataTaskDetailsKind: i32 {
    PlainText = 0, Html = 1,
}}
RT_ENUM! { enum UserDataTaskKind: i32 {
    Single = 0, Recurring = 1, Regenerating = 2,
}}
DEFINE_IID!(IID_IUserDataTaskList, 1229008441, 31773, 19953, 190, 211, 49, 75, 124, 191, 94, 78);
RT_INTERFACE!{interface IUserDataTaskList(IUserDataTaskListVtbl): IInspectable [IID_IUserDataTaskList] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_UserDataAccountId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_SourceDisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_OtherAppReadAccess(&self, out: *mut UserDataTaskListOtherAppReadAccess) -> HRESULT,
    fn put_OtherAppReadAccess(&self, value: UserDataTaskListOtherAppReadAccess) -> HRESULT,
    fn get_OtherAppWriteAccess(&self, out: *mut UserDataTaskListOtherAppWriteAccess) -> HRESULT,
    fn put_OtherAppWriteAccess(&self, value: UserDataTaskListOtherAppWriteAccess) -> HRESULT,
    fn get_LimitedWriteOperations(&self, out: *mut <UserDataTaskListLimitedWriteOperations as RtType>::Abi) -> HRESULT,
    fn get_SyncManager(&self, out: *mut <UserDataTaskListSyncManager as RtType>::Abi) -> HRESULT,
    fn RegisterSyncManagerAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn GetTaskReader(&self, out: *mut <UserDataTaskReader as RtType>::Abi) -> HRESULT,
    fn GetTaskReaderWithOptions(&self, options: <UserDataTaskQueryOptions as RtType>::Abi, out: *mut <UserDataTaskReader as RtType>::Abi) -> HRESULT,
    fn GetTaskAsync(&self, userDataTask: HSTRING, out: *mut <foundation::IAsyncOperation<UserDataTask> as RtType>::Abi) -> HRESULT,
    fn SaveTaskAsync(&self, userDataTask: <UserDataTask as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn DeleteTaskAsync(&self, userDataTaskId: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn DeleteAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn SaveAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IUserDataTaskList {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_user_data_account_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_UserDataAccountId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_source_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SourceDisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_other_app_read_access(&self) -> Result<UserDataTaskListOtherAppReadAccess> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_OtherAppReadAccess)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_other_app_read_access(&self, value: UserDataTaskListOtherAppReadAccess) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_OtherAppReadAccess)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_other_app_write_access(&self) -> Result<UserDataTaskListOtherAppWriteAccess> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_OtherAppWriteAccess)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_other_app_write_access(&self, value: UserDataTaskListOtherAppWriteAccess) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_OtherAppWriteAccess)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_limited_write_operations(&self) -> Result<Option<UserDataTaskListLimitedWriteOperations>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LimitedWriteOperations)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserDataTaskListLimitedWriteOperations::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sync_manager(&self) -> Result<Option<UserDataTaskListSyncManager>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SyncManager)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserDataTaskListSyncManager::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn register_sync_manager_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RegisterSyncManagerAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_task_reader(&self) -> Result<Option<UserDataTaskReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetTaskReader)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserDataTaskReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_task_reader_with_options(&self, options: &UserDataTaskQueryOptions) -> Result<Option<UserDataTaskReader>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetTaskReaderWithOptions)(self.get_abi() as *const _ as *mut _, options.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserDataTaskReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_task_async(&self, userDataTask: &HStringArg) -> Result<foundation::IAsyncOperation<UserDataTask>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetTaskAsync)(self.get_abi() as *const _ as *mut _, userDataTask.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn save_task_async(&self, userDataTask: &UserDataTask) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SaveTaskAsync)(self.get_abi() as *const _ as *mut _, userDataTask.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_task_async(&self, userDataTaskId: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteTaskAsync)(self.get_abi() as *const _ as *mut _, userDataTaskId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn save_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SaveAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTaskList: IUserDataTaskList}
DEFINE_IID!(IID_IUserDataTaskListLimitedWriteOperations, 2057463794, 24696, 16771, 145, 158, 79, 41, 241, 156, 250, 233);
RT_INTERFACE!{interface IUserDataTaskListLimitedWriteOperations(IUserDataTaskListLimitedWriteOperationsVtbl): IInspectable [IID_IUserDataTaskListLimitedWriteOperations] {
    fn TryCompleteTaskAsync(&self, userDataTaskId: HSTRING, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn TryCreateOrUpdateTaskAsync(&self, userDataTask: <UserDataTask as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryDeleteTaskAsync(&self, userDataTaskId: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TrySkipOccurrenceAsync(&self, userDataTaskId: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl IUserDataTaskListLimitedWriteOperations {
    #[inline] pub fn try_complete_task_async(&self, userDataTaskId: &HStringArg) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryCompleteTaskAsync)(self.get_abi() as *const _ as *mut _, userDataTaskId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_create_or_update_task_async(&self, userDataTask: &UserDataTask) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryCreateOrUpdateTaskAsync)(self.get_abi() as *const _ as *mut _, userDataTask.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_delete_task_async(&self, userDataTaskId: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TryDeleteTaskAsync)(self.get_abi() as *const _ as *mut _, userDataTaskId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_skip_occurrence_async(&self, userDataTaskId: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().TrySkipOccurrenceAsync)(self.get_abi() as *const _ as *mut _, userDataTaskId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTaskListLimitedWriteOperations: IUserDataTaskListLimitedWriteOperations}
RT_ENUM! { enum UserDataTaskListOtherAppReadAccess: i32 {
    Full = 0, SystemOnly = 1, None = 2,
}}
RT_ENUM! { enum UserDataTaskListOtherAppWriteAccess: i32 {
    Limited = 0, None = 1,
}}
DEFINE_IID!(IID_IUserDataTaskListSyncManager, 2388204181, 7631, 18079, 147, 236, 186, 72, 187, 85, 60, 107);
RT_INTERFACE!{interface IUserDataTaskListSyncManager(IUserDataTaskListSyncManagerVtbl): IInspectable [IID_IUserDataTaskListSyncManager] {
    fn get_LastAttemptedSyncTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn put_LastAttemptedSyncTime(&self, value: foundation::DateTime) -> HRESULT,
    fn get_LastSuccessfulSyncTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn put_LastSuccessfulSyncTime(&self, value: foundation::DateTime) -> HRESULT,
    fn get_Status(&self, out: *mut UserDataTaskListSyncStatus) -> HRESULT,
    fn put_Status(&self, value: UserDataTaskListSyncStatus) -> HRESULT,
    fn SyncAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn add_SyncStatusChanged(&self, handler: <foundation::TypedEventHandler<UserDataTaskListSyncManager, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SyncStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IUserDataTaskListSyncManager {
    #[inline] pub fn get_last_attempted_sync_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_LastAttemptedSyncTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_last_attempted_sync_time(&self, value: foundation::DateTime) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_LastAttemptedSyncTime)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_last_successful_sync_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_LastSuccessfulSyncTime)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_last_successful_sync_time(&self, value: foundation::DateTime) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_LastSuccessfulSyncTime)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<UserDataTaskListSyncStatus> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Status)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_status(&self, value: UserDataTaskListSyncStatus) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Status)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn sync_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SyncAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_sync_status_changed(&self, handler: &foundation::TypedEventHandler<UserDataTaskListSyncManager, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_SyncStatusChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_sync_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_SyncStatusChanged)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTaskListSyncManager: IUserDataTaskListSyncManager}
RT_ENUM! { enum UserDataTaskListSyncStatus: i32 {
    Idle = 0, Syncing = 1, UpToDate = 2, AuthenticationError = 3, PolicyError = 4, UnknownError = 5,
}}
DEFINE_IID!(IID_IUserDataTaskManager, 2219952404, 58891, 18601, 146, 17, 127, 184, 165, 108, 184, 76);
RT_INTERFACE!{interface IUserDataTaskManager(IUserDataTaskManagerVtbl): IInspectable [IID_IUserDataTaskManager] {
    fn RequestStoreAsync(&self, accessType: UserDataTaskStoreAccessType, out: *mut <foundation::IAsyncOperation<UserDataTaskStore> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut <super::super::system::User as RtType>::Abi) -> HRESULT
}}
impl IUserDataTaskManager {
    #[inline] pub fn request_store_async(&self, accessType: UserDataTaskStoreAccessType) -> Result<foundation::IAsyncOperation<UserDataTaskStore>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestStoreAsync)(self.get_abi() as *const _ as *mut _, accessType, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_user(&self) -> Result<Option<super::super::system::User>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_User)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::system::User::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTaskManager: IUserDataTaskManager}
impl RtActivatable<IUserDataTaskManagerStatics> for UserDataTaskManager {}
impl UserDataTaskManager {
    #[inline] pub fn get_default() -> Result<Option<UserDataTaskManager>> {
        <Self as RtActivatable<IUserDataTaskManagerStatics>>::get_activation_factory().get_default()
    }
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(user: &super::super::system::User) -> Result<Option<UserDataTaskManager>> {
        <Self as RtActivatable<IUserDataTaskManagerStatics>>::get_activation_factory().get_for_user(user)
    }
}
DEFINE_CLSID!(UserDataTaskManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,85,115,101,114,68,97,116,97,84,97,115,107,115,46,85,115,101,114,68,97,116,97,84,97,115,107,77,97,110,97,103,101,114,0]) [CLSID_UserDataTaskManager]);
DEFINE_IID!(IID_IUserDataTaskManagerStatics, 3008707064, 50434, 18428, 168, 30, 16, 8, 131, 113, 157, 85);
RT_INTERFACE!{static interface IUserDataTaskManagerStatics(IUserDataTaskManagerStaticsVtbl): IInspectable [IID_IUserDataTaskManagerStatics] {
    fn GetDefault(&self, out: *mut <UserDataTaskManager as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-system")] fn GetForUser(&self, user: <super::super::system::User as RtType>::Abi, out: *mut <UserDataTaskManager as RtType>::Abi) -> HRESULT
}}
impl IUserDataTaskManagerStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<UserDataTaskManager>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDefault)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserDataTaskManager::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(&self, user: &super::super::system::User) -> Result<Option<UserDataTaskManager>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetForUser)(self.get_abi() as *const _ as *mut _, user.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserDataTaskManager::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum UserDataTaskPriority: i32 {
    Normal = 0, Low = -1, High = 1,
}}
RT_ENUM! { enum UserDataTaskQueryKind: i32 {
    All = 0, Incomplete = 1, Complete = 2,
}}
DEFINE_IID!(IID_IUserDataTaskQueryOptions, 2510235629, 37018, 19760, 140, 27, 51, 29, 143, 230, 103, 226);
RT_INTERFACE!{interface IUserDataTaskQueryOptions(IUserDataTaskQueryOptionsVtbl): IInspectable [IID_IUserDataTaskQueryOptions] {
    fn get_SortProperty(&self, out: *mut UserDataTaskQuerySortProperty) -> HRESULT,
    fn put_SortProperty(&self, value: UserDataTaskQuerySortProperty) -> HRESULT,
    fn get_Kind(&self, out: *mut UserDataTaskQueryKind) -> HRESULT,
    fn put_Kind(&self, value: UserDataTaskQueryKind) -> HRESULT
}}
impl IUserDataTaskQueryOptions {
    #[inline] pub fn get_sort_property(&self) -> Result<UserDataTaskQuerySortProperty> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SortProperty)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_sort_property(&self, value: UserDataTaskQuerySortProperty) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SortProperty)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_kind(&self) -> Result<UserDataTaskQueryKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Kind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_kind(&self, value: UserDataTaskQueryKind) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Kind)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTaskQueryOptions: IUserDataTaskQueryOptions}
impl RtActivatable<IActivationFactory> for UserDataTaskQueryOptions {}
DEFINE_CLSID!(UserDataTaskQueryOptions(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,85,115,101,114,68,97,116,97,84,97,115,107,115,46,85,115,101,114,68,97,116,97,84,97,115,107,81,117,101,114,121,79,112,116,105,111,110,115,0]) [CLSID_UserDataTaskQueryOptions]);
RT_ENUM! { enum UserDataTaskQuerySortProperty: i32 {
    DueDate = 0,
}}
DEFINE_IID!(IID_IUserDataTaskReader, 65439921, 19663, 17664, 136, 59, 231, 98, 144, 207, 237, 99);
RT_INTERFACE!{interface IUserDataTaskReader(IUserDataTaskReaderVtbl): IInspectable [IID_IUserDataTaskReader] {
    fn ReadBatchAsync(&self, out: *mut <foundation::IAsyncOperation<UserDataTaskBatch> as RtType>::Abi) -> HRESULT
}}
impl IUserDataTaskReader {
    #[inline] pub fn read_batch_async(&self) -> Result<foundation::IAsyncOperation<UserDataTaskBatch>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReadBatchAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTaskReader: IUserDataTaskReader}
DEFINE_IID!(IID_IUserDataTaskRecurrenceProperties, 1944027312, 10182, 16590, 177, 73, 156, 212, 20, 133, 166, 158);
RT_INTERFACE!{interface IUserDataTaskRecurrenceProperties(IUserDataTaskRecurrencePropertiesVtbl): IInspectable [IID_IUserDataTaskRecurrenceProperties] {
    fn get_Unit(&self, out: *mut UserDataTaskRecurrenceUnit) -> HRESULT,
    fn put_Unit(&self, value: UserDataTaskRecurrenceUnit) -> HRESULT,
    fn get_Occurrences(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_Occurrences(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_Until(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn put_Until(&self, value: <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_Interval(&self, out: *mut i32) -> HRESULT,
    fn put_Interval(&self, value: i32) -> HRESULT,
    fn get_DaysOfWeek(&self, out: *mut <foundation::IReference<UserDataTaskDaysOfWeek> as RtType>::Abi) -> HRESULT,
    fn put_DaysOfWeek(&self, value: <foundation::IReference<UserDataTaskDaysOfWeek> as RtType>::Abi) -> HRESULT,
    fn get_WeekOfMonth(&self, out: *mut <foundation::IReference<UserDataTaskWeekOfMonth> as RtType>::Abi) -> HRESULT,
    fn put_WeekOfMonth(&self, value: <foundation::IReference<UserDataTaskWeekOfMonth> as RtType>::Abi) -> HRESULT,
    fn get_Month(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_Month(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_Day(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_Day(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT
}}
impl IUserDataTaskRecurrenceProperties {
    #[inline] pub fn get_unit(&self) -> Result<UserDataTaskRecurrenceUnit> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Unit)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_unit(&self, value: UserDataTaskRecurrenceUnit) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Unit)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_occurrences(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Occurrences)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_occurrences(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Occurrences)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_until(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Until)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_until(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Until)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_interval(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Interval)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_interval(&self, value: i32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Interval)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_days_of_week(&self) -> Result<Option<foundation::IReference<UserDataTaskDaysOfWeek>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DaysOfWeek)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_days_of_week(&self, value: &foundation::IReference<UserDataTaskDaysOfWeek>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DaysOfWeek)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_week_of_month(&self) -> Result<Option<foundation::IReference<UserDataTaskWeekOfMonth>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_WeekOfMonth)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_week_of_month(&self, value: &foundation::IReference<UserDataTaskWeekOfMonth>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_WeekOfMonth)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_month(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Month)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_month(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Month)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_day(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Day)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_day(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Day)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTaskRecurrenceProperties: IUserDataTaskRecurrenceProperties}
impl RtActivatable<IActivationFactory> for UserDataTaskRecurrenceProperties {}
DEFINE_CLSID!(UserDataTaskRecurrenceProperties(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,85,115,101,114,68,97,116,97,84,97,115,107,115,46,85,115,101,114,68,97,116,97,84,97,115,107,82,101,99,117,114,114,101,110,99,101,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_UserDataTaskRecurrenceProperties]);
RT_ENUM! { enum UserDataTaskRecurrenceUnit: i32 {
    Daily = 0, Weekly = 1, Monthly = 2, MonthlyOnDay = 3, Yearly = 4, YearlyOnDay = 5,
}}
DEFINE_IID!(IID_IUserDataTaskRegenerationProperties, 2460680199, 2318, 18180, 187, 92, 132, 252, 11, 13, 156, 49);
RT_INTERFACE!{interface IUserDataTaskRegenerationProperties(IUserDataTaskRegenerationPropertiesVtbl): IInspectable [IID_IUserDataTaskRegenerationProperties] {
    fn get_Unit(&self, out: *mut UserDataTaskRegenerationUnit) -> HRESULT,
    fn put_Unit(&self, value: UserDataTaskRegenerationUnit) -> HRESULT,
    fn get_Occurrences(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_Occurrences(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_Until(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn put_Until(&self, value: <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_Interval(&self, out: *mut i32) -> HRESULT,
    fn put_Interval(&self, value: i32) -> HRESULT
}}
impl IUserDataTaskRegenerationProperties {
    #[inline] pub fn get_unit(&self) -> Result<UserDataTaskRegenerationUnit> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Unit)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_unit(&self, value: UserDataTaskRegenerationUnit) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Unit)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_occurrences(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Occurrences)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_occurrences(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Occurrences)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_until(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Until)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_until(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Until)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_interval(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Interval)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_interval(&self, value: i32) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Interval)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTaskRegenerationProperties: IUserDataTaskRegenerationProperties}
impl RtActivatable<IActivationFactory> for UserDataTaskRegenerationProperties {}
DEFINE_CLSID!(UserDataTaskRegenerationProperties(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,85,115,101,114,68,97,116,97,84,97,115,107,115,46,85,115,101,114,68,97,116,97,84,97,115,107,82,101,103,101,110,101,114,97,116,105,111,110,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_UserDataTaskRegenerationProperties]);
RT_ENUM! { enum UserDataTaskRegenerationUnit: i32 {
    Daily = 0, Weekly = 1, Monthly = 2, Yearly = 4,
}}
RT_ENUM! { enum UserDataTaskSensitivity: i32 {
    Public = 0, Private = 1,
}}
DEFINE_IID!(IID_IUserDataTaskStore, 4033518768, 61915, 17850, 138, 98, 8, 96, 4, 192, 33, 61);
RT_INTERFACE!{interface IUserDataTaskStore(IUserDataTaskStoreVtbl): IInspectable [IID_IUserDataTaskStore] {
    fn CreateListAsync(&self, name: HSTRING, out: *mut <foundation::IAsyncOperation<UserDataTaskList> as RtType>::Abi) -> HRESULT,
    fn CreateListInAccountAsync(&self, name: HSTRING, userDataAccountId: HSTRING, out: *mut <foundation::IAsyncOperation<UserDataTaskList> as RtType>::Abi) -> HRESULT,
    fn FindListsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<UserDataTaskList>> as RtType>::Abi) -> HRESULT,
    fn GetListAsync(&self, taskListId: HSTRING, out: *mut <foundation::IAsyncOperation<UserDataTaskList> as RtType>::Abi) -> HRESULT
}}
impl IUserDataTaskStore {
    #[inline] pub fn create_list_async(&self, name: &HStringArg) -> Result<foundation::IAsyncOperation<UserDataTaskList>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateListAsync)(self.get_abi() as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_list_in_account_async(&self, name: &HStringArg, userDataAccountId: &HStringArg) -> Result<foundation::IAsyncOperation<UserDataTaskList>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateListInAccountAsync)(self.get_abi() as *const _ as *mut _, name.get(), userDataAccountId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_lists_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<UserDataTaskList>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FindListsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_list_async(&self, taskListId: &HStringArg) -> Result<foundation::IAsyncOperation<UserDataTaskList>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetListAsync)(self.get_abi() as *const _ as *mut _, taskListId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTaskStore: IUserDataTaskStore}
RT_ENUM! { enum UserDataTaskStoreAccessType: i32 {
    AppTasksReadWrite = 0, AllTasksLimitedReadWrite = 1,
}}
RT_ENUM! { enum UserDataTaskWeekOfMonth: i32 {
    First = 0, Second = 1, Third = 2, Fourth = 3, Last = 4,
}}
pub mod dataprovider { // Windows.ApplicationModel.UserDataTasks.DataProvider
use crate::prelude::*;
DEFINE_IID!(IID_IUserDataTaskDataProviderConnection, 2683542813, 42055, 17035, 175, 233, 229, 64, 43, 222, 176, 65);
RT_INTERFACE!{interface IUserDataTaskDataProviderConnection(IUserDataTaskDataProviderConnectionVtbl): IInspectable [IID_IUserDataTaskDataProviderConnection] {
    fn add_CreateOrUpdateTaskRequested(&self, handler: <foundation::TypedEventHandler<UserDataTaskDataProviderConnection, UserDataTaskListCreateOrUpdateTaskRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CreateOrUpdateTaskRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SyncRequested(&self, handler: <foundation::TypedEventHandler<UserDataTaskDataProviderConnection, UserDataTaskListSyncManagerSyncRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SyncRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SkipOccurrenceRequested(&self, handler: <foundation::TypedEventHandler<UserDataTaskDataProviderConnection, UserDataTaskListSkipOccurrenceRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SkipOccurrenceRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CompleteTaskRequested(&self, handler: <foundation::TypedEventHandler<UserDataTaskDataProviderConnection, UserDataTaskListCompleteTaskRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CompleteTaskRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_DeleteTaskRequested(&self, handler: <foundation::TypedEventHandler<UserDataTaskDataProviderConnection, UserDataTaskListDeleteTaskRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DeleteTaskRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn Start(&self) -> HRESULT
}}
impl IUserDataTaskDataProviderConnection {
    #[inline] pub fn add_create_or_update_task_requested(&self, handler: &foundation::TypedEventHandler<UserDataTaskDataProviderConnection, UserDataTaskListCreateOrUpdateTaskRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_CreateOrUpdateTaskRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_create_or_update_task_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_CreateOrUpdateTaskRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_sync_requested(&self, handler: &foundation::TypedEventHandler<UserDataTaskDataProviderConnection, UserDataTaskListSyncManagerSyncRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_SyncRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_sync_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_SyncRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_skip_occurrence_requested(&self, handler: &foundation::TypedEventHandler<UserDataTaskDataProviderConnection, UserDataTaskListSkipOccurrenceRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_SkipOccurrenceRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_skip_occurrence_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_SkipOccurrenceRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_complete_task_requested(&self, handler: &foundation::TypedEventHandler<UserDataTaskDataProviderConnection, UserDataTaskListCompleteTaskRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_CompleteTaskRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_complete_task_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_CompleteTaskRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_delete_task_requested(&self, handler: &foundation::TypedEventHandler<UserDataTaskDataProviderConnection, UserDataTaskListDeleteTaskRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_DeleteTaskRequested)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_delete_task_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_DeleteTaskRequested)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().Start)(self.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTaskDataProviderConnection: IUserDataTaskDataProviderConnection}
DEFINE_IID!(IID_IUserDataTaskDataProviderTriggerDetails, 2921804290, 45513, 17726, 175, 197, 179, 10, 243, 189, 33, 125);
RT_INTERFACE!{interface IUserDataTaskDataProviderTriggerDetails(IUserDataTaskDataProviderTriggerDetailsVtbl): IInspectable [IID_IUserDataTaskDataProviderTriggerDetails] {
    fn get_Connection(&self, out: *mut <UserDataTaskDataProviderConnection as RtType>::Abi) -> HRESULT
}}
impl IUserDataTaskDataProviderTriggerDetails {
    #[inline] pub fn get_connection(&self) -> Result<Option<UserDataTaskDataProviderConnection>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Connection)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserDataTaskDataProviderConnection::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTaskDataProviderTriggerDetails: IUserDataTaskDataProviderTriggerDetails}
DEFINE_IID!(IID_IUserDataTaskListCompleteTaskRequest, 4133360803, 6722, 18906, 133, 82, 40, 115, 229, 44, 85, 235);
RT_INTERFACE!{interface IUserDataTaskListCompleteTaskRequest(IUserDataTaskListCompleteTaskRequestVtbl): IInspectable [IID_IUserDataTaskListCompleteTaskRequest] {
    fn get_TaskListId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TaskId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, completedTaskId: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IUserDataTaskListCompleteTaskRequest {
    #[inline] pub fn get_task_list_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TaskListId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_task_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TaskId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self, completedTaskId: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, completedTaskId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTaskListCompleteTaskRequest: IUserDataTaskListCompleteTaskRequest}
DEFINE_IID!(IID_IUserDataTaskListCompleteTaskRequestEventArgs, 3615242557, 19698, 18605, 135, 253, 150, 63, 14, 170, 122, 149);
RT_INTERFACE!{interface IUserDataTaskListCompleteTaskRequestEventArgs(IUserDataTaskListCompleteTaskRequestEventArgsVtbl): IInspectable [IID_IUserDataTaskListCompleteTaskRequestEventArgs] {
    fn get_Request(&self, out: *mut <UserDataTaskListCompleteTaskRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IUserDataTaskListCompleteTaskRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<UserDataTaskListCompleteTaskRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserDataTaskListCompleteTaskRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTaskListCompleteTaskRequestEventArgs: IUserDataTaskListCompleteTaskRequestEventArgs}
DEFINE_IID!(IID_IUserDataTaskListCreateOrUpdateTaskRequest, 557020972, 21954, 17152, 130, 121, 4, 50, 110, 7, 204, 228);
RT_INTERFACE!{interface IUserDataTaskListCreateOrUpdateTaskRequest(IUserDataTaskListCreateOrUpdateTaskRequestVtbl): IInspectable [IID_IUserDataTaskListCreateOrUpdateTaskRequest] {
    fn get_TaskListId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Task(&self, out: *mut <super::UserDataTask as RtType>::Abi) -> HRESULT,
    fn ReportCompletedAsync(&self, createdOrUpdatedUserDataTask: <super::UserDataTask as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IUserDataTaskListCreateOrUpdateTaskRequest {
    #[inline] pub fn get_task_list_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TaskListId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_task(&self) -> Result<Option<super::UserDataTask>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Task)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::UserDataTask::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self, createdOrUpdatedUserDataTask: &super::UserDataTask) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, createdOrUpdatedUserDataTask.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTaskListCreateOrUpdateTaskRequest: IUserDataTaskListCreateOrUpdateTaskRequest}
DEFINE_IID!(IID_IUserDataTaskListCreateOrUpdateTaskRequestEventArgs, 314923602, 58232, 16795, 174, 56, 165, 233, 230, 4, 71, 110);
RT_INTERFACE!{interface IUserDataTaskListCreateOrUpdateTaskRequestEventArgs(IUserDataTaskListCreateOrUpdateTaskRequestEventArgsVtbl): IInspectable [IID_IUserDataTaskListCreateOrUpdateTaskRequestEventArgs] {
    fn get_Request(&self, out: *mut <UserDataTaskListCreateOrUpdateTaskRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IUserDataTaskListCreateOrUpdateTaskRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<UserDataTaskListCreateOrUpdateTaskRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserDataTaskListCreateOrUpdateTaskRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTaskListCreateOrUpdateTaskRequestEventArgs: IUserDataTaskListCreateOrUpdateTaskRequestEventArgs}
DEFINE_IID!(IID_IUserDataTaskListDeleteTaskRequest, 1267088488, 30295, 20285, 176, 116, 212, 126, 200, 223, 7, 231);
RT_INTERFACE!{interface IUserDataTaskListDeleteTaskRequest(IUserDataTaskListDeleteTaskRequestVtbl): IInspectable [IID_IUserDataTaskListDeleteTaskRequest] {
    fn get_TaskListId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TaskId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IUserDataTaskListDeleteTaskRequest {
    #[inline] pub fn get_task_list_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TaskListId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_task_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TaskId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTaskListDeleteTaskRequest: IUserDataTaskListDeleteTaskRequest}
DEFINE_IID!(IID_IUserDataTaskListDeleteTaskRequestEventArgs, 1617156825, 62818, 16709, 142, 254, 213, 0, 120, 201, 43, 127);
RT_INTERFACE!{interface IUserDataTaskListDeleteTaskRequestEventArgs(IUserDataTaskListDeleteTaskRequestEventArgsVtbl): IInspectable [IID_IUserDataTaskListDeleteTaskRequestEventArgs] {
    fn get_Request(&self, out: *mut <UserDataTaskListDeleteTaskRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IUserDataTaskListDeleteTaskRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<UserDataTaskListDeleteTaskRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserDataTaskListDeleteTaskRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTaskListDeleteTaskRequestEventArgs: IUserDataTaskListDeleteTaskRequestEventArgs}
DEFINE_IID!(IID_IUserDataTaskListSkipOccurrenceRequest, 2877809485, 7379, 17180, 159, 88, 8, 154, 164, 51, 141, 133);
RT_INTERFACE!{interface IUserDataTaskListSkipOccurrenceRequest(IUserDataTaskListSkipOccurrenceRequestVtbl): IInspectable [IID_IUserDataTaskListSkipOccurrenceRequest] {
    fn get_TaskListId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TaskId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IUserDataTaskListSkipOccurrenceRequest {
    #[inline] pub fn get_task_list_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TaskListId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_task_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TaskId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTaskListSkipOccurrenceRequest: IUserDataTaskListSkipOccurrenceRequest}
DEFINE_IID!(IID_IUserDataTaskListSkipOccurrenceRequestEventArgs, 2050724426, 52271, 20091, 170, 205, 165, 185, 210, 156, 250, 78);
RT_INTERFACE!{interface IUserDataTaskListSkipOccurrenceRequestEventArgs(IUserDataTaskListSkipOccurrenceRequestEventArgsVtbl): IInspectable [IID_IUserDataTaskListSkipOccurrenceRequestEventArgs] {
    fn get_Request(&self, out: *mut <UserDataTaskListSkipOccurrenceRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IUserDataTaskListSkipOccurrenceRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<UserDataTaskListSkipOccurrenceRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserDataTaskListSkipOccurrenceRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTaskListSkipOccurrenceRequestEventArgs: IUserDataTaskListSkipOccurrenceRequestEventArgs}
DEFINE_IID!(IID_IUserDataTaskListSyncManagerSyncRequest, 1084700679, 30096, 16713, 174, 25, 178, 17, 67, 26, 159, 72);
RT_INTERFACE!{interface IUserDataTaskListSyncManagerSyncRequest(IUserDataTaskListSyncManagerSyncRequestVtbl): IInspectable [IID_IUserDataTaskListSyncManagerSyncRequest] {
    fn get_TaskListId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IUserDataTaskListSyncManagerSyncRequest {
    #[inline] pub fn get_task_list_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TaskListId)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportCompletedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailedAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTaskListSyncManagerSyncRequest: IUserDataTaskListSyncManagerSyncRequest}
DEFINE_IID!(IID_IUserDataTaskListSyncManagerSyncRequestEventArgs, 2393709586, 30350, 17341, 131, 133, 92, 220, 53, 31, 253, 234);
RT_INTERFACE!{interface IUserDataTaskListSyncManagerSyncRequestEventArgs(IUserDataTaskListSyncManagerSyncRequestEventArgsVtbl): IInspectable [IID_IUserDataTaskListSyncManagerSyncRequestEventArgs] {
    fn get_Request(&self, out: *mut <UserDataTaskListSyncManagerSyncRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IUserDataTaskListSyncManagerSyncRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<UserDataTaskListSyncManagerSyncRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Request)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UserDataTaskListSyncManagerSyncRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetDeferral)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UserDataTaskListSyncManagerSyncRequestEventArgs: IUserDataTaskListSyncManagerSyncRequestEventArgs}
} // Windows.ApplicationModel.UserDataTasks.DataProvider
} // Windows.ApplicationModel.UserDataTasks
pub mod voicecommands { // Windows.ApplicationModel.VoiceCommands
use crate::prelude::*;
DEFINE_IID!(IID_IVoiceCommand, 2473546355, 60546, 17062, 165, 92, 210, 215, 158, 198, 249, 32);
RT_INTERFACE!{interface IVoiceCommand(IVoiceCommandVtbl): IInspectable [IID_IVoiceCommand] {
    fn get_CommandName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, foundation::collections::IVectorView<HString>> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-media")] fn get_SpeechRecognitionResult(&self, out: *mut <super::super::media::speechrecognition::SpeechRecognitionResult as RtType>::Abi) -> HRESULT
}}
impl IVoiceCommand {
    #[inline] pub fn get_command_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_CommandName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, foundation::collections::IVectorView<HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Properties)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-media")] #[inline] pub fn get_speech_recognition_result(&self) -> Result<Option<super::super::media::speechrecognition::SpeechRecognitionResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SpeechRecognitionResult)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::media::speechrecognition::SpeechRecognitionResult::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VoiceCommand: IVoiceCommand}
DEFINE_IID!(IID_IVoiceCommandCompletedEventArgs, 3361630045, 65090, 17196, 153, 7, 9, 223, 159, 207, 100, 232);
RT_INTERFACE!{interface IVoiceCommandCompletedEventArgs(IVoiceCommandCompletedEventArgsVtbl): IInspectable [IID_IVoiceCommandCompletedEventArgs] {
    fn get_Reason(&self, out: *mut VoiceCommandCompletionReason) -> HRESULT
}}
impl IVoiceCommandCompletedEventArgs {
    #[inline] pub fn get_reason(&self) -> Result<VoiceCommandCompletionReason> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Reason)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class VoiceCommandCompletedEventArgs: IVoiceCommandCompletedEventArgs}
RT_ENUM! { enum VoiceCommandCompletionReason: i32 {
    Unknown = 0, CommunicationFailed = 1, ResourceLimitsExceeded = 2, Canceled = 3, TimeoutExceeded = 4, AppLaunched = 5, Completed = 6,
}}
DEFINE_IID!(IID_IVoiceCommandConfirmationResult, 2686605630, 33313, 17702, 176, 131, 132, 9, 114, 38, 34, 71);
RT_INTERFACE!{interface IVoiceCommandConfirmationResult(IVoiceCommandConfirmationResultVtbl): IInspectable [IID_IVoiceCommandConfirmationResult] {
    fn get_Confirmed(&self, out: *mut bool) -> HRESULT
}}
impl IVoiceCommandConfirmationResult {
    #[inline] pub fn get_confirmed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Confirmed)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class VoiceCommandConfirmationResult: IVoiceCommandConfirmationResult}
DEFINE_IID!(IID_IVoiceCommandContentTile, 1055910384, 47303, 19574, 160, 222, 22, 7, 137, 94, 227, 39);
RT_INTERFACE!{interface IVoiceCommandContentTile(IVoiceCommandContentTileVtbl): IInspectable [IID_IVoiceCommandContentTile] {
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    fn get_TextLine1(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TextLine1(&self, value: HSTRING) -> HRESULT,
    fn get_TextLine2(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TextLine2(&self, value: HSTRING) -> HRESULT,
    fn get_TextLine3(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TextLine3(&self, value: HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Image(&self, out: *mut <super::super::storage::IStorageFile as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy9(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Image(&self, value: <super::super::storage::IStorageFile as RtType>::Abi) -> HRESULT,
    fn get_AppContext(&self, out: *mut <IInspectable as RtType>::Abi) -> HRESULT,
    fn put_AppContext(&self, value: <IInspectable as RtType>::Abi) -> HRESULT,
    fn get_AppLaunchArgument(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AppLaunchArgument(&self, value: HSTRING) -> HRESULT,
    fn get_ContentTileType(&self, out: *mut VoiceCommandContentTileType) -> HRESULT,
    fn put_ContentTileType(&self, value: VoiceCommandContentTileType) -> HRESULT
}}
impl IVoiceCommandContentTile {
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Title)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_title(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Title)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_text_line1(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TextLine1)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_text_line1(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_TextLine1)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_text_line2(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TextLine2)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_text_line2(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_TextLine2)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_text_line3(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TextLine3)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_text_line3(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_TextLine3)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_image(&self) -> Result<Option<super::super::storage::IStorageFile>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Image)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::IStorageFile::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_image(&self, value: &super::super::storage::IStorageFile) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Image)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_app_context(&self) -> Result<Option<IInspectable>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppContext)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IInspectable::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_app_context(&self, value: &IInspectable) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AppContext)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_app_launch_argument(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppLaunchArgument)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_app_launch_argument(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AppLaunchArgument)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_content_tile_type(&self) -> Result<VoiceCommandContentTileType> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_ContentTileType)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_content_tile_type(&self, value: VoiceCommandContentTileType) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ContentTileType)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class VoiceCommandContentTile: IVoiceCommandContentTile}
impl RtActivatable<IActivationFactory> for VoiceCommandContentTile {}
DEFINE_CLSID!(VoiceCommandContentTile(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,86,111,105,99,101,67,111,109,109,97,110,100,115,46,86,111,105,99,101,67,111,109,109,97,110,100,67,111,110,116,101,110,116,84,105,108,101,0]) [CLSID_VoiceCommandContentTile]);
RT_ENUM! { enum VoiceCommandContentTileType: i32 {
    TitleOnly = 0, TitleWithText = 1, TitleWith68x68Icon = 2, TitleWith68x68IconAndText = 3, TitleWith68x92Icon = 4, TitleWith68x92IconAndText = 5, TitleWith280x140Icon = 6, TitleWith280x140IconAndText = 7,
}}
DEFINE_IID!(IID_IVoiceCommandDefinition, 2037557968, 2420, 18809, 152, 75, 203, 137, 89, 205, 97, 174);
RT_INTERFACE!{interface IVoiceCommandDefinition(IVoiceCommandDefinitionVtbl): IInspectable [IID_IVoiceCommandDefinition] {
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn SetPhraseListAsync(&self, phraseListName: HSTRING, phraseList: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IVoiceCommandDefinition {
    #[inline] pub fn get_language(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Language)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Name)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_phrase_list_async(&self, phraseListName: &HStringArg, phraseList: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().SetPhraseListAsync)(self.get_abi() as *const _ as *mut _, phraseListName.get(), phraseList.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VoiceCommandDefinition: IVoiceCommandDefinition}
RT_CLASS!{static class VoiceCommandDefinitionManager}
impl RtActivatable<IVoiceCommandDefinitionManagerStatics> for VoiceCommandDefinitionManager {}
impl VoiceCommandDefinitionManager {
    #[cfg(feature="windows-storage")] #[inline] pub fn install_command_definitions_from_storage_file_async(file: &super::super::storage::StorageFile) -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<IVoiceCommandDefinitionManagerStatics>>::get_activation_factory().install_command_definitions_from_storage_file_async(file)
    }
    #[inline] pub fn get_installed_command_definitions() -> Result<Option<foundation::collections::IMapView<HString, VoiceCommandDefinition>>> {
        <Self as RtActivatable<IVoiceCommandDefinitionManagerStatics>>::get_activation_factory().get_installed_command_definitions()
    }
}
DEFINE_CLSID!(VoiceCommandDefinitionManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,86,111,105,99,101,67,111,109,109,97,110,100,115,46,86,111,105,99,101,67,111,109,109,97,110,100,68,101,102,105,110,105,116,105,111,110,77,97,110,97,103,101,114,0]) [CLSID_VoiceCommandDefinitionManager]);
DEFINE_IID!(IID_IVoiceCommandDefinitionManagerStatics, 2414323358, 1662, 20246, 161, 140, 91, 23, 233, 73, 153, 64);
RT_INTERFACE!{static interface IVoiceCommandDefinitionManagerStatics(IVoiceCommandDefinitionManagerStaticsVtbl): IInspectable [IID_IVoiceCommandDefinitionManagerStatics] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn InstallCommandDefinitionsFromStorageFileAsync(&self, file: <super::super::storage::StorageFile as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn get_InstalledCommandDefinitions(&self, out: *mut <foundation::collections::IMapView<HString, VoiceCommandDefinition> as RtType>::Abi) -> HRESULT
}}
impl IVoiceCommandDefinitionManagerStatics {
    #[cfg(feature="windows-storage")] #[inline] pub fn install_command_definitions_from_storage_file_async(&self, file: &super::super::storage::StorageFile) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().InstallCommandDefinitionsFromStorageFileAsync)(self.get_abi() as *const _ as *mut _, file.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_installed_command_definitions(&self) -> Result<Option<foundation::collections::IMapView<HString, VoiceCommandDefinition>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_InstalledCommandDefinitions)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVoiceCommandDisambiguationResult, 3972435198, 51628, 17887, 168, 234, 254, 234, 8, 239, 156, 94);
RT_INTERFACE!{interface IVoiceCommandDisambiguationResult(IVoiceCommandDisambiguationResultVtbl): IInspectable [IID_IVoiceCommandDisambiguationResult] {
    fn get_SelectedItem(&self, out: *mut <VoiceCommandContentTile as RtType>::Abi) -> HRESULT
}}
impl IVoiceCommandDisambiguationResult {
    #[inline] pub fn get_selected_item(&self) -> Result<Option<VoiceCommandContentTile>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SelectedItem)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VoiceCommandContentTile::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VoiceCommandDisambiguationResult: IVoiceCommandDisambiguationResult}
DEFINE_IID!(IID_IVoiceCommandResponse, 42251022, 35387, 19652, 166, 161, 202, 213, 190, 39, 22, 181);
RT_INTERFACE!{interface IVoiceCommandResponse(IVoiceCommandResponseVtbl): IInspectable [IID_IVoiceCommandResponse] {
    fn get_Message(&self, out: *mut <VoiceCommandUserMessage as RtType>::Abi) -> HRESULT,
    fn put_Message(&self, value: <VoiceCommandUserMessage as RtType>::Abi) -> HRESULT,
    fn get_RepeatMessage(&self, out: *mut <VoiceCommandUserMessage as RtType>::Abi) -> HRESULT,
    fn put_RepeatMessage(&self, value: <VoiceCommandUserMessage as RtType>::Abi) -> HRESULT,
    fn get_AppLaunchArgument(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AppLaunchArgument(&self, value: HSTRING) -> HRESULT,
    fn get_VoiceCommandContentTiles(&self, out: *mut <foundation::collections::IVector<VoiceCommandContentTile> as RtType>::Abi) -> HRESULT
}}
impl IVoiceCommandResponse {
    #[inline] pub fn get_message(&self) -> Result<Option<VoiceCommandUserMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Message)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VoiceCommandUserMessage::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_message(&self, value: &VoiceCommandUserMessage) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Message)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_repeat_message(&self) -> Result<Option<VoiceCommandUserMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RepeatMessage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VoiceCommandUserMessage::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_repeat_message(&self, value: &VoiceCommandUserMessage) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RepeatMessage)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_app_launch_argument(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_AppLaunchArgument)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_app_launch_argument(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AppLaunchArgument)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_voice_command_content_tiles(&self) -> Result<Option<foundation::collections::IVector<VoiceCommandContentTile>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_VoiceCommandContentTiles)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VoiceCommandResponse: IVoiceCommandResponse}
impl RtActivatable<IVoiceCommandResponseStatics> for VoiceCommandResponse {}
impl VoiceCommandResponse {
    #[inline] pub fn get_max_supported_voice_command_content_tiles() -> Result<u32> {
        <Self as RtActivatable<IVoiceCommandResponseStatics>>::get_activation_factory().get_max_supported_voice_command_content_tiles()
    }
    #[inline] pub fn create_response(userMessage: &VoiceCommandUserMessage) -> Result<Option<VoiceCommandResponse>> {
        <Self as RtActivatable<IVoiceCommandResponseStatics>>::get_activation_factory().create_response(userMessage)
    }
    #[inline] pub fn create_response_with_tiles(message: &VoiceCommandUserMessage, contentTiles: &foundation::collections::IIterable<VoiceCommandContentTile>) -> Result<Option<VoiceCommandResponse>> {
        <Self as RtActivatable<IVoiceCommandResponseStatics>>::get_activation_factory().create_response_with_tiles(message, contentTiles)
    }
    #[inline] pub fn create_response_for_prompt(message: &VoiceCommandUserMessage, repeatMessage: &VoiceCommandUserMessage) -> Result<Option<VoiceCommandResponse>> {
        <Self as RtActivatable<IVoiceCommandResponseStatics>>::get_activation_factory().create_response_for_prompt(message, repeatMessage)
    }
    #[inline] pub fn create_response_for_prompt_with_tiles(message: &VoiceCommandUserMessage, repeatMessage: &VoiceCommandUserMessage, contentTiles: &foundation::collections::IIterable<VoiceCommandContentTile>) -> Result<Option<VoiceCommandResponse>> {
        <Self as RtActivatable<IVoiceCommandResponseStatics>>::get_activation_factory().create_response_for_prompt_with_tiles(message, repeatMessage, contentTiles)
    }
}
DEFINE_CLSID!(VoiceCommandResponse(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,86,111,105,99,101,67,111,109,109,97,110,100,115,46,86,111,105,99,101,67,111,109,109,97,110,100,82,101,115,112,111,110,115,101,0]) [CLSID_VoiceCommandResponse]);
DEFINE_IID!(IID_IVoiceCommandResponseStatics, 691206163, 3387, 18930, 150, 221, 98, 80, 25, 189, 59, 93);
RT_INTERFACE!{static interface IVoiceCommandResponseStatics(IVoiceCommandResponseStaticsVtbl): IInspectable [IID_IVoiceCommandResponseStatics] {
    fn get_MaxSupportedVoiceCommandContentTiles(&self, out: *mut u32) -> HRESULT,
    fn CreateResponse(&self, userMessage: <VoiceCommandUserMessage as RtType>::Abi, out: *mut <VoiceCommandResponse as RtType>::Abi) -> HRESULT,
    fn CreateResponseWithTiles(&self, message: <VoiceCommandUserMessage as RtType>::Abi, contentTiles: <foundation::collections::IIterable<VoiceCommandContentTile> as RtType>::Abi, out: *mut <VoiceCommandResponse as RtType>::Abi) -> HRESULT,
    fn CreateResponseForPrompt(&self, message: <VoiceCommandUserMessage as RtType>::Abi, repeatMessage: <VoiceCommandUserMessage as RtType>::Abi, out: *mut <VoiceCommandResponse as RtType>::Abi) -> HRESULT,
    fn CreateResponseForPromptWithTiles(&self, message: <VoiceCommandUserMessage as RtType>::Abi, repeatMessage: <VoiceCommandUserMessage as RtType>::Abi, contentTiles: <foundation::collections::IIterable<VoiceCommandContentTile> as RtType>::Abi, out: *mut <VoiceCommandResponse as RtType>::Abi) -> HRESULT
}}
impl IVoiceCommandResponseStatics {
    #[inline] pub fn get_max_supported_voice_command_content_tiles(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_MaxSupportedVoiceCommandContentTiles)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn create_response(&self, userMessage: &VoiceCommandUserMessage) -> Result<Option<VoiceCommandResponse>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateResponse)(self.get_abi() as *const _ as *mut _, userMessage.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VoiceCommandResponse::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_response_with_tiles(&self, message: &VoiceCommandUserMessage, contentTiles: &foundation::collections::IIterable<VoiceCommandContentTile>) -> Result<Option<VoiceCommandResponse>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateResponseWithTiles)(self.get_abi() as *const _ as *mut _, message.get_abi() as *const _ as *mut _, contentTiles.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VoiceCommandResponse::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_response_for_prompt(&self, message: &VoiceCommandUserMessage, repeatMessage: &VoiceCommandUserMessage) -> Result<Option<VoiceCommandResponse>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateResponseForPrompt)(self.get_abi() as *const _ as *mut _, message.get_abi() as *const _ as *mut _, repeatMessage.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VoiceCommandResponse::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_response_for_prompt_with_tiles(&self, message: &VoiceCommandUserMessage, repeatMessage: &VoiceCommandUserMessage, contentTiles: &foundation::collections::IIterable<VoiceCommandContentTile>) -> Result<Option<VoiceCommandResponse>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateResponseForPromptWithTiles)(self.get_abi() as *const _ as *mut _, message.get_abi() as *const _ as *mut _, repeatMessage.get_abi() as *const _ as *mut _, contentTiles.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VoiceCommandResponse::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVoiceCommandServiceConnection, 3633626015, 8666, 17572, 152, 162, 251, 19, 25, 32, 169, 204);
RT_INTERFACE!{interface IVoiceCommandServiceConnection(IVoiceCommandServiceConnectionVtbl): IInspectable [IID_IVoiceCommandServiceConnection] {
    fn GetVoiceCommandAsync(&self, out: *mut <foundation::IAsyncOperation<VoiceCommand> as RtType>::Abi) -> HRESULT,
    fn RequestConfirmationAsync(&self, response: <VoiceCommandResponse as RtType>::Abi, out: *mut <foundation::IAsyncOperation<VoiceCommandConfirmationResult> as RtType>::Abi) -> HRESULT,
    fn RequestDisambiguationAsync(&self, response: <VoiceCommandResponse as RtType>::Abi, out: *mut <foundation::IAsyncOperation<VoiceCommandDisambiguationResult> as RtType>::Abi) -> HRESULT,
    fn ReportProgressAsync(&self, response: <VoiceCommandResponse as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportSuccessAsync(&self, response: <VoiceCommandResponse as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailureAsync(&self, response: <VoiceCommandResponse as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn RequestAppLaunchAsync(&self, response: <VoiceCommandResponse as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-globalization"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-globalization")] fn get_Language(&self, out: *mut <super::super::globalization::Language as RtType>::Abi) -> HRESULT,
    fn add_VoiceCommandCompleted(&self, handler: <foundation::TypedEventHandler<VoiceCommandServiceConnection, VoiceCommandCompletedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VoiceCommandCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IVoiceCommandServiceConnection {
    #[inline] pub fn get_voice_command_async(&self) -> Result<foundation::IAsyncOperation<VoiceCommand>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetVoiceCommandAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_confirmation_async(&self, response: &VoiceCommandResponse) -> Result<foundation::IAsyncOperation<VoiceCommandConfirmationResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestConfirmationAsync)(self.get_abi() as *const _ as *mut _, response.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_disambiguation_async(&self, response: &VoiceCommandResponse) -> Result<foundation::IAsyncOperation<VoiceCommandDisambiguationResult>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestDisambiguationAsync)(self.get_abi() as *const _ as *mut _, response.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_progress_async(&self, response: &VoiceCommandResponse) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportProgressAsync)(self.get_abi() as *const _ as *mut _, response.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_success_async(&self, response: &VoiceCommandResponse) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportSuccessAsync)(self.get_abi() as *const _ as *mut _, response.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failure_async(&self, response: &VoiceCommandResponse) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ReportFailureAsync)(self.get_abi() as *const _ as *mut _, response.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_app_launch_async(&self, response: &VoiceCommandResponse) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestAppLaunchAsync)(self.get_abi() as *const _ as *mut _, response.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_language(&self) -> Result<Option<super::super::globalization::Language>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Language)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::globalization::Language::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_voice_command_completed(&self, handler: &foundation::TypedEventHandler<VoiceCommandServiceConnection, VoiceCommandCompletedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_VoiceCommandCompleted)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_voice_command_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_VoiceCommandCompleted)(self.get_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class VoiceCommandServiceConnection: IVoiceCommandServiceConnection}
impl RtActivatable<IVoiceCommandServiceConnectionStatics> for VoiceCommandServiceConnection {}
impl VoiceCommandServiceConnection {
    #[inline] pub fn from_app_service_trigger_details(triggerDetails: &super::appservice::AppServiceTriggerDetails) -> Result<Option<VoiceCommandServiceConnection>> {
        <Self as RtActivatable<IVoiceCommandServiceConnectionStatics>>::get_activation_factory().from_app_service_trigger_details(triggerDetails)
    }
}
DEFINE_CLSID!(VoiceCommandServiceConnection(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,86,111,105,99,101,67,111,109,109,97,110,100,115,46,86,111,105,99,101,67,111,109,109,97,110,100,83,101,114,118,105,99,101,67,111,110,110,101,99,116,105,111,110,0]) [CLSID_VoiceCommandServiceConnection]);
DEFINE_IID!(IID_IVoiceCommandServiceConnectionStatics, 923713531, 11572, 17119, 135, 112, 7, 77, 15, 51, 70, 151);
RT_INTERFACE!{static interface IVoiceCommandServiceConnectionStatics(IVoiceCommandServiceConnectionStaticsVtbl): IInspectable [IID_IVoiceCommandServiceConnectionStatics] {
    fn FromAppServiceTriggerDetails(&self, triggerDetails: <super::appservice::AppServiceTriggerDetails as RtType>::Abi, out: *mut <VoiceCommandServiceConnection as RtType>::Abi) -> HRESULT
}}
impl IVoiceCommandServiceConnectionStatics {
    #[inline] pub fn from_app_service_trigger_details(&self, triggerDetails: &super::appservice::AppServiceTriggerDetails) -> Result<Option<VoiceCommandServiceConnection>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().FromAppServiceTriggerDetails)(self.get_abi() as *const _ as *mut _, triggerDetails.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VoiceCommandServiceConnection::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVoiceCommandUserMessage, 1733211072, 17654, 20231, 185, 121, 76, 114, 63, 192, 133, 151);
RT_INTERFACE!{interface IVoiceCommandUserMessage(IVoiceCommandUserMessageVtbl): IInspectable [IID_IVoiceCommandUserMessage] {
    fn get_DisplayMessage(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayMessage(&self, value: HSTRING) -> HRESULT,
    fn get_SpokenMessage(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SpokenMessage(&self, value: HSTRING) -> HRESULT
}}
impl IVoiceCommandUserMessage {
    #[inline] pub fn get_display_message(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayMessage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_message(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayMessage)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_spoken_message(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_SpokenMessage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_spoken_message(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SpokenMessage)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class VoiceCommandUserMessage: IVoiceCommandUserMessage}
impl RtActivatable<IActivationFactory> for VoiceCommandUserMessage {}
DEFINE_CLSID!(VoiceCommandUserMessage(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,86,111,105,99,101,67,111,109,109,97,110,100,115,46,86,111,105,99,101,67,111,109,109,97,110,100,85,115,101,114,77,101,115,115,97,103,101,0]) [CLSID_VoiceCommandUserMessage]);
} // Windows.ApplicationModel.VoiceCommands
pub mod wallet { // Windows.ApplicationModel.Wallet
use crate::prelude::*;
RT_ENUM! { enum WalletActionKind: i32 {
    OpenItem = 0, Transaction = 1, MoreTransactions = 2, Message = 3, Verb = 4,
}}
DEFINE_IID!(IID_IWalletBarcode, 1334147881, 56960, 20132, 161, 205, 129, 205, 8, 77, 172, 39);
RT_INTERFACE!{interface IWalletBarcode(IWalletBarcodeVtbl): IInspectable [IID_IWalletBarcode] {
    fn get_Symbology(&self, out: *mut WalletBarcodeSymbology) -> HRESULT,
    fn get_Value(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetImageAsync(&self, out: *mut <foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamReference> as RtType>::Abi) -> HRESULT
}}
impl IWalletBarcode {
    #[inline] pub fn get_symbology(&self) -> Result<WalletBarcodeSymbology> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Symbology)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Value)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_image_async(&self) -> Result<foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetImageAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WalletBarcode: IWalletBarcode}
impl RtActivatable<IWalletBarcodeFactory> for WalletBarcode {}
impl WalletBarcode {
    #[inline] pub fn create_wallet_barcode(symbology: WalletBarcodeSymbology, value: &HStringArg) -> Result<WalletBarcode> {
        <Self as RtActivatable<IWalletBarcodeFactory>>::get_activation_factory().create_wallet_barcode(symbology, value)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn create_custom_wallet_barcode(streamToBarcodeImage: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<WalletBarcode> {
        <Self as RtActivatable<IWalletBarcodeFactory>>::get_activation_factory().create_custom_wallet_barcode(streamToBarcodeImage)
    }
}
DEFINE_CLSID!(WalletBarcode(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,87,97,108,108,101,116,46,87,97,108,108,101,116,66,97,114,99,111,100,101,0]) [CLSID_WalletBarcode]);
DEFINE_IID!(IID_IWalletBarcodeFactory, 806449505, 60828, 18078, 187, 253, 48, 108, 149, 234, 113, 8);
RT_INTERFACE!{static interface IWalletBarcodeFactory(IWalletBarcodeFactoryVtbl): IInspectable [IID_IWalletBarcodeFactory] {
    fn CreateWalletBarcode(&self, symbology: WalletBarcodeSymbology, value: HSTRING, out: *mut <WalletBarcode as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn CreateCustomWalletBarcode(&self, streamToBarcodeImage: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi, out: *mut <WalletBarcode as RtType>::Abi) -> HRESULT
}}
impl IWalletBarcodeFactory {
    #[inline] pub fn create_wallet_barcode(&self, symbology: WalletBarcodeSymbology, value: &HStringArg) -> Result<WalletBarcode> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWalletBarcode)(self.get_abi() as *const _ as *mut _, symbology, value.get(), &mut out);
        if hr == S_OK { Ok(WalletBarcode::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn create_custom_wallet_barcode(&self, streamToBarcodeImage: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<WalletBarcode> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateCustomWalletBarcode)(self.get_abi() as *const _ as *mut _, streamToBarcodeImage.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(WalletBarcode::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum WalletBarcodeSymbology: i32 {
    Invalid = 0, Upca = 1, Upce = 2, Ean13 = 3, Ean8 = 4, Itf = 5, Code39 = 6, Code128 = 7, Qr = 8, Pdf417 = 9, Aztec = 10, Custom = 100000,
}}
RT_ENUM! { enum WalletDetailViewPosition: i32 {
    Hidden = 0, HeaderField1 = 1, HeaderField2 = 2, PrimaryField1 = 3, PrimaryField2 = 4, SecondaryField1 = 5, SecondaryField2 = 6, SecondaryField3 = 7, SecondaryField4 = 8, SecondaryField5 = 9, CenterField1 = 10, FooterField1 = 11, FooterField2 = 12, FooterField3 = 13, FooterField4 = 14,
}}
DEFINE_IID!(IID_IWalletItem, 548752360, 4493, 20164, 153, 108, 185, 99, 231, 189, 62, 116);
RT_INTERFACE!{interface IWalletItem(IWalletItemVtbl): IInspectable [IID_IWalletItem] {
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsAcknowledged(&self, out: *mut bool) -> HRESULT,
    fn put_IsAcknowledged(&self, value: bool) -> HRESULT,
    fn get_IssuerDisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_IssuerDisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_LastUpdated(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn put_LastUpdated(&self, value: <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_Kind(&self, out: *mut WalletItemKind) -> HRESULT,
    fn get_Barcode(&self, out: *mut <WalletBarcode as RtType>::Abi) -> HRESULT,
    fn put_Barcode(&self, value: <WalletBarcode as RtType>::Abi) -> HRESULT,
    fn get_ExpirationDate(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn put_ExpirationDate(&self, value: <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy14(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Logo159x159(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy15(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Logo159x159(&self, value: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy16(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Logo336x336(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy17(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Logo336x336(&self, value: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy18(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Logo99x99(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy19(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Logo99x99(&self, value: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    fn get_DisplayMessage(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayMessage(&self, value: HSTRING) -> HRESULT,
    fn get_IsDisplayMessageLaunchable(&self, out: *mut bool) -> HRESULT,
    fn put_IsDisplayMessageLaunchable(&self, value: bool) -> HRESULT,
    fn get_LogoText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_LogoText(&self, value: HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy26(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_HeaderColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy27(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_HeaderColor(&self, value: super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy28(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_BodyColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy29(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_BodyColor(&self, value: super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy30(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_HeaderFontColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy31(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_HeaderFontColor(&self, value: super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy32(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_BodyFontColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy33(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_BodyFontColor(&self, value: super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy34(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_HeaderBackgroundImage(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy35(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_HeaderBackgroundImage(&self, value: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy36(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_BodyBackgroundImage(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy37(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_BodyBackgroundImage(&self, value: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy38(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_LogoImage(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy39(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_LogoImage(&self, value: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy40(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_PromotionalImage(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy41(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_PromotionalImage(&self, value: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    fn get_RelevantDate(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn put_RelevantDate(&self, value: <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_RelevantDateDisplayMessage(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RelevantDateDisplayMessage(&self, value: HSTRING) -> HRESULT,
    fn get_TransactionHistory(&self, out: *mut <foundation::collections::IMap<HString, WalletTransaction> as RtType>::Abi) -> HRESULT,
    fn get_RelevantLocations(&self, out: *mut <foundation::collections::IMap<HString, WalletRelevantLocation> as RtType>::Abi) -> HRESULT,
    fn get_IsMoreTransactionHistoryLaunchable(&self, out: *mut bool) -> HRESULT,
    fn put_IsMoreTransactionHistoryLaunchable(&self, value: bool) -> HRESULT,
    fn get_DisplayProperties(&self, out: *mut <foundation::collections::IMap<HString, WalletItemCustomProperty> as RtType>::Abi) -> HRESULT,
    fn get_Verbs(&self, out: *mut <foundation::collections::IMap<HString, WalletVerb> as RtType>::Abi) -> HRESULT
}}
impl IWalletItem {
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Id)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_acknowledged(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsAcknowledged)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_acknowledged(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsAcknowledged)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_issuer_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_IssuerDisplayName)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_issuer_display_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IssuerDisplayName)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_last_updated(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LastUpdated)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_last_updated(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_LastUpdated)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_kind(&self) -> Result<WalletItemKind> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Kind)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_barcode(&self) -> Result<Option<WalletBarcode>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Barcode)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(WalletBarcode::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_barcode(&self, value: &WalletBarcode) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Barcode)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_expiration_date(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_ExpirationDate)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_expiration_date(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_ExpirationDate)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_logo_159x159(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Logo159x159)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_logo_159x159(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Logo159x159)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_logo_336x336(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Logo336x336)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_logo_336x336(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Logo336x336)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_logo_99x99(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Logo99x99)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_logo_99x99(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Logo99x99)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_display_message(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayMessage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_message(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayMessage)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_display_message_launchable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsDisplayMessageLaunchable)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_display_message_launchable(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsDisplayMessageLaunchable)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_logo_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LogoText)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_logo_text(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_LogoText)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_header_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_HeaderColor)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_header_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_HeaderColor)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_body_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_BodyColor)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_body_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_BodyColor)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_header_font_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_HeaderFontColor)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_header_font_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_HeaderFontColor)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_body_font_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_BodyFontColor)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_body_font_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_BodyFontColor)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_header_background_image(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_HeaderBackgroundImage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_header_background_image(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_HeaderBackgroundImage)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_body_background_image(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_BodyBackgroundImage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_body_background_image(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_BodyBackgroundImage)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_logo_image(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_LogoImage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_logo_image(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_LogoImage)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_promotional_image(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_PromotionalImage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_promotional_image(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_PromotionalImage)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_relevant_date(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RelevantDate)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_relevant_date(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RelevantDate)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_relevant_date_display_message(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RelevantDateDisplayMessage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_relevant_date_display_message(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_RelevantDateDisplayMessage)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_transaction_history(&self) -> Result<Option<foundation::collections::IMap<HString, WalletTransaction>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TransactionHistory)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMap::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_relevant_locations(&self) -> Result<Option<foundation::collections::IMap<HString, WalletRelevantLocation>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_RelevantLocations)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMap::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_more_transaction_history_launchable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsMoreTransactionHistoryLaunchable)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_more_transaction_history_launchable(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsMoreTransactionHistoryLaunchable)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_display_properties(&self) -> Result<Option<foundation::collections::IMap<HString, WalletItemCustomProperty>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayProperties)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMap::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_verbs(&self) -> Result<Option<foundation::collections::IMap<HString, WalletVerb>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Verbs)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMap::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WalletItem: IWalletItem}
impl RtActivatable<IWalletItemFactory> for WalletItem {}
impl WalletItem {
    #[inline] pub fn create_wallet_item(kind: WalletItemKind, displayName: &HStringArg) -> Result<WalletItem> {
        <Self as RtActivatable<IWalletItemFactory>>::get_activation_factory().create_wallet_item(kind, displayName)
    }
}
DEFINE_CLSID!(WalletItem(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,87,97,108,108,101,116,46,87,97,108,108,101,116,73,116,101,109,0]) [CLSID_WalletItem]);
DEFINE_IID!(IID_IWalletItemCustomProperty, 3108716787, 64000, 16637, 152, 220, 157, 228, 102, 151, 241, 231);
RT_INTERFACE!{interface IWalletItemCustomProperty(IWalletItemCustomPropertyVtbl): IInspectable [IID_IWalletItemCustomProperty] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT,
    fn get_Value(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Value(&self, value: HSTRING) -> HRESULT,
    fn get_AutoDetectLinks(&self, out: *mut bool) -> HRESULT,
    fn put_AutoDetectLinks(&self, value: bool) -> HRESULT,
    fn get_DetailViewPosition(&self, out: *mut WalletDetailViewPosition) -> HRESULT,
    fn put_DetailViewPosition(&self, value: WalletDetailViewPosition) -> HRESULT,
    fn get_SummaryViewPosition(&self, out: *mut WalletSummaryViewPosition) -> HRESULT,
    fn put_SummaryViewPosition(&self, value: WalletSummaryViewPosition) -> HRESULT
}}
impl IWalletItemCustomProperty {
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Name)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Name)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Value)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_value(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Value)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_detect_links(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_AutoDetectLinks)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto_detect_links(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_AutoDetectLinks)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_detail_view_position(&self) -> Result<WalletDetailViewPosition> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_DetailViewPosition)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_detail_view_position(&self, value: WalletDetailViewPosition) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DetailViewPosition)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_summary_view_position(&self) -> Result<WalletSummaryViewPosition> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_SummaryViewPosition)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_summary_view_position(&self, value: WalletSummaryViewPosition) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_SummaryViewPosition)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class WalletItemCustomProperty: IWalletItemCustomProperty}
impl RtActivatable<IWalletItemCustomPropertyFactory> for WalletItemCustomProperty {}
impl WalletItemCustomProperty {
    #[inline] pub fn create_wallet_item_custom_property(name: &HStringArg, value: &HStringArg) -> Result<WalletItemCustomProperty> {
        <Self as RtActivatable<IWalletItemCustomPropertyFactory>>::get_activation_factory().create_wallet_item_custom_property(name, value)
    }
}
DEFINE_CLSID!(WalletItemCustomProperty(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,87,97,108,108,101,116,46,87,97,108,108,101,116,73,116,101,109,67,117,115,116,111,109,80,114,111,112,101,114,116,121,0]) [CLSID_WalletItemCustomProperty]);
DEFINE_IID!(IID_IWalletItemCustomPropertyFactory, 3489950276, 24993, 16810, 178, 89, 165, 97, 10, 181, 213, 117);
RT_INTERFACE!{static interface IWalletItemCustomPropertyFactory(IWalletItemCustomPropertyFactoryVtbl): IInspectable [IID_IWalletItemCustomPropertyFactory] {
    fn CreateWalletItemCustomProperty(&self, name: HSTRING, value: HSTRING, out: *mut <WalletItemCustomProperty as RtType>::Abi) -> HRESULT
}}
impl IWalletItemCustomPropertyFactory {
    #[inline] pub fn create_wallet_item_custom_property(&self, name: &HStringArg, value: &HStringArg) -> Result<WalletItemCustomProperty> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWalletItemCustomProperty)(self.get_abi() as *const _ as *mut _, name.get(), value.get(), &mut out);
        if hr == S_OK { Ok(WalletItemCustomProperty::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IWalletItemFactory, 1407349872, 20235, 19006, 153, 229, 11, 187, 30, 171, 56, 212);
RT_INTERFACE!{static interface IWalletItemFactory(IWalletItemFactoryVtbl): IInspectable [IID_IWalletItemFactory] {
    fn CreateWalletItem(&self, kind: WalletItemKind, displayName: HSTRING, out: *mut <WalletItem as RtType>::Abi) -> HRESULT
}}
impl IWalletItemFactory {
    #[inline] pub fn create_wallet_item(&self, kind: WalletItemKind, displayName: &HStringArg) -> Result<WalletItem> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWalletItem)(self.get_abi() as *const _ as *mut _, kind, displayName.get(), &mut out);
        if hr == S_OK { Ok(WalletItem::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum WalletItemKind: i32 {
    Invalid = 0, Deal = 1, General = 2, PaymentInstrument = 3, Ticket = 4, BoardingPass = 5, MembershipCard = 6,
}}
DEFINE_IID!(IID_IWalletItemStore, 1902135371, 27977, 18680, 145, 169, 64, 161, 208, 241, 62, 244);
RT_INTERFACE!{interface IWalletItemStore(IWalletItemStoreVtbl): IInspectable [IID_IWalletItemStore] {
    fn AddAsync(&self, id: HSTRING, item: <WalletItem as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ClearAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn GetWalletItemAsync(&self, id: HSTRING, out: *mut <foundation::IAsyncOperation<WalletItem> as RtType>::Abi) -> HRESULT,
    fn GetItemsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<WalletItem>> as RtType>::Abi) -> HRESULT,
    fn GetItemsWithKindAsync(&self, kind: WalletItemKind, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<WalletItem>> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn ImportItemAsync(&self, stream: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi, out: *mut <foundation::IAsyncOperation<WalletItem> as RtType>::Abi) -> HRESULT,
    fn DeleteAsync(&self, id: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ShowAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ShowItemAsync(&self, id: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn UpdateAsync(&self, item: <WalletItem as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IWalletItemStore {
    #[inline] pub fn add_async(&self, id: &HStringArg, item: &WalletItem) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().AddAsync)(self.get_abi() as *const _ as *mut _, id.get(), item.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn clear_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ClearAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_wallet_item_async(&self, id: &HStringArg) -> Result<foundation::IAsyncOperation<WalletItem>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetWalletItemAsync)(self.get_abi() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_items_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<WalletItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetItemsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_items_with_kind_async(&self, kind: WalletItemKind) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<WalletItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetItemsWithKindAsync)(self.get_abi() as *const _ as *mut _, kind, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn import_item_async(&self, stream: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<foundation::IAsyncOperation<WalletItem>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ImportItemAsync)(self.get_abi() as *const _ as *mut _, stream.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_async(&self, id: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteAsync)(self.get_abi() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_item_async(&self, id: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ShowItemAsync)(self.get_abi() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn update_async(&self, item: &WalletItem) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().UpdateAsync)(self.get_abi() as *const _ as *mut _, item.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WalletItemStore: IWalletItemStore}
DEFINE_IID!(IID_IWalletItemStore2, 1709605616, 28681, 18965, 189, 84, 79, 255, 55, 155, 255, 226);
RT_INTERFACE!{interface IWalletItemStore2(IWalletItemStore2Vtbl): IInspectable [IID_IWalletItemStore2] {
    fn add_ItemsChanged(&self, handler: <foundation::TypedEventHandler<WalletItemStore, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ItemsChanged(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl IWalletItemStore2 {
    #[inline] pub fn add_items_changed(&self, handler: &foundation::TypedEventHandler<WalletItemStore, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_ItemsChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_items_changed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_ItemsChanged)(self.get_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{static class WalletManager}
impl RtActivatable<IWalletManagerStatics> for WalletManager {}
impl WalletManager {
    #[inline] pub fn request_store_async() -> Result<foundation::IAsyncOperation<WalletItemStore>> {
        <Self as RtActivatable<IWalletManagerStatics>>::get_activation_factory().request_store_async()
    }
}
DEFINE_CLSID!(WalletManager(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,87,97,108,108,101,116,46,87,97,108,108,101,116,77,97,110,97,103,101,114,0]) [CLSID_WalletManager]);
DEFINE_IID!(IID_IWalletManagerStatics, 1360123576, 51620, 19556, 180, 221, 225, 229, 72, 0, 28, 13);
RT_INTERFACE!{static interface IWalletManagerStatics(IWalletManagerStaticsVtbl): IInspectable [IID_IWalletManagerStatics] {
    fn RequestStoreAsync(&self, out: *mut <foundation::IAsyncOperation<WalletItemStore> as RtType>::Abi) -> HRESULT
}}
impl IWalletManagerStatics {
    #[inline] pub fn request_store_async(&self) -> Result<foundation::IAsyncOperation<WalletItemStore>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestStoreAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IWalletRelevantLocation, 2681763882, 58361, 19937, 186, 179, 187, 25, 46, 70, 179, 243);
RT_INTERFACE!{interface IWalletRelevantLocation(IWalletRelevantLocationVtbl): IInspectable [IID_IWalletRelevantLocation] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_Position(&self, out: *mut super::super::devices::geolocation::BasicGeoposition) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-devices")] fn put_Position(&self, value: super::super::devices::geolocation::BasicGeoposition) -> HRESULT,
    fn get_DisplayMessage(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayMessage(&self, value: HSTRING) -> HRESULT
}}
impl IWalletRelevantLocation {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_position(&self) -> Result<super::super::devices::geolocation::BasicGeoposition> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_Position)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn set_position(&self, value: super::super::devices::geolocation::BasicGeoposition) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Position)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_display_message(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayMessage)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_message(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayMessage)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class WalletRelevantLocation: IWalletRelevantLocation}
impl RtActivatable<IActivationFactory> for WalletRelevantLocation {}
DEFINE_CLSID!(WalletRelevantLocation(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,87,97,108,108,101,116,46,87,97,108,108,101,116,82,101,108,101,118,97,110,116,76,111,99,97,116,105,111,110,0]) [CLSID_WalletRelevantLocation]);
RT_ENUM! { enum WalletSummaryViewPosition: i32 {
    Hidden = 0, Field1 = 1, Field2 = 2,
}}
DEFINE_IID!(IID_IWalletTransaction, 1088547136, 9734, 17689, 129, 203, 191, 241, 198, 13, 31, 121);
RT_INTERFACE!{interface IWalletTransaction(IWalletTransactionVtbl): IInspectable [IID_IWalletTransaction] {
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT,
    fn get_DisplayAmount(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayAmount(&self, value: HSTRING) -> HRESULT,
    fn get_IgnoreTimeOfDay(&self, out: *mut bool) -> HRESULT,
    fn put_IgnoreTimeOfDay(&self, value: bool) -> HRESULT,
    fn get_DisplayLocation(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayLocation(&self, value: HSTRING) -> HRESULT,
    fn get_TransactionDate(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn put_TransactionDate(&self, value: <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_IsLaunchable(&self, out: *mut bool) -> HRESULT,
    fn put_IsLaunchable(&self, value: bool) -> HRESULT
}}
impl IWalletTransaction {
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Description)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_description(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Description)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_display_amount(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayAmount)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_amount(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayAmount)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_ignore_time_of_day(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IgnoreTimeOfDay)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_ignore_time_of_day(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IgnoreTimeOfDay)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_display_location(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_DisplayLocation)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_location(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_DisplayLocation)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_transaction_date(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_TransactionDate)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_transaction_date(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_TransactionDate)(self.get_abi() as *const _ as *mut _, value.get_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_launchable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().get_IsLaunchable)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_launchable(&self, value: bool) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_IsLaunchable)(self.get_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class WalletTransaction: IWalletTransaction}
impl RtActivatable<IActivationFactory> for WalletTransaction {}
DEFINE_CLSID!(WalletTransaction(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,87,97,108,108,101,116,46,87,97,108,108,101,116,84,114,97,110,115,97,99,116,105,111,110,0]) [CLSID_WalletTransaction]);
DEFINE_IID!(IID_IWalletVerb, 397944534, 58305, 19572, 138, 148, 33, 122, 173, 188, 72, 132);
RT_INTERFACE!{interface IWalletVerb(IWalletVerbVtbl): IInspectable [IID_IWalletVerb] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT
}}
impl IWalletVerb {
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().get_Name)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().put_Name)(self.get_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class WalletVerb: IWalletVerb}
impl RtActivatable<IWalletVerbFactory> for WalletVerb {}
impl WalletVerb {
    #[inline] pub fn create_wallet_verb(name: &HStringArg) -> Result<WalletVerb> {
        <Self as RtActivatable<IWalletVerbFactory>>::get_activation_factory().create_wallet_verb(name)
    }
}
DEFINE_CLSID!(WalletVerb(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,87,97,108,108,101,116,46,87,97,108,108,101,116,86,101,114,98,0]) [CLSID_WalletVerb]);
DEFINE_IID!(IID_IWalletVerbFactory, 1979787121, 48728, 19806, 131, 237, 88, 177, 102, 156, 122, 217);
RT_INTERFACE!{static interface IWalletVerbFactory(IWalletVerbFactoryVtbl): IInspectable [IID_IWalletVerbFactory] {
    fn CreateWalletVerb(&self, name: HSTRING, out: *mut <WalletVerb as RtType>::Abi) -> HRESULT
}}
impl IWalletVerbFactory {
    #[inline] pub fn create_wallet_verb(&self, name: &HStringArg) -> Result<WalletVerb> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().CreateWalletVerb)(self.get_abi() as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(WalletVerb::wrap_nonnull(out)) } else { err(hr) }
    }}
}
pub mod system { // Windows.ApplicationModel.Wallet.System
use crate::prelude::*;
RT_ENUM! { enum WalletItemAppAssociation: i32 {
    None = 0, AppInstalled = 1, AppNotInstalled = 2,
}}
DEFINE_IID!(IID_IWalletItemSystemStore, 1378757631, 38562, 18967, 141, 25, 254, 29, 159, 131, 117, 97);
RT_INTERFACE!{interface IWalletItemSystemStore(IWalletItemSystemStoreVtbl): IInspectable [IID_IWalletItemSystemStore] {
    fn GetItemsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<super::WalletItem>> as RtType>::Abi) -> HRESULT,
    fn DeleteAsync(&self, item: <super::WalletItem as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn ImportItemAsync(&self, stream: <crate::windows::storage::streams::IRandomAccessStreamReference as RtType>::Abi, out: *mut <foundation::IAsyncOperation<super::WalletItem> as RtType>::Abi) -> HRESULT,
    fn GetAppStatusForItem(&self, item: <super::WalletItem as RtType>::Abi, out: *mut WalletItemAppAssociation) -> HRESULT,
    fn LaunchAppForItemAsync(&self, item: <super::WalletItem as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl IWalletItemSystemStore {
    #[inline] pub fn get_items_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<super::WalletItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().GetItemsAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_async(&self, item: &super::WalletItem) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().DeleteAsync)(self.get_abi() as *const _ as *mut _, item.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn import_item_async(&self, stream: &crate::windows::storage::streams::IRandomAccessStreamReference) -> Result<foundation::IAsyncOperation<super::WalletItem>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().ImportItemAsync)(self.get_abi() as *const _ as *mut _, stream.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_app_status_for_item(&self, item: &super::WalletItem) -> Result<WalletItemAppAssociation> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().GetAppStatusForItem)(self.get_abi() as *const _ as *mut _, item.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn launch_app_for_item_async(&self, item: &super::WalletItem) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().LaunchAppForItemAsync)(self.get_abi() as *const _ as *mut _, item.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WalletItemSystemStore: IWalletItemSystemStore}
DEFINE_IID!(IID_IWalletItemSystemStore2, 4186782286, 48640, 20445, 151, 52, 108, 17, 60, 26, 193, 203);
RT_INTERFACE!{interface IWalletItemSystemStore2(IWalletItemSystemStore2Vtbl): IInspectable [IID_IWalletItemSystemStore2] {
    fn add_ItemsChanged(&self, handler: <foundation::TypedEventHandler<WalletItemSystemStore, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ItemsChanged(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl IWalletItemSystemStore2 {
    #[inline] pub fn add_items_changed(&self, handler: &foundation::TypedEventHandler<WalletItemSystemStore, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = (self.get_vtbl().add_ItemsChanged)(self.get_abi() as *const _ as *mut _, handler.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_items_changed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = (self.get_vtbl().remove_ItemsChanged)(self.get_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{static class WalletManagerSystem}
impl RtActivatable<IWalletManagerSystemStatics> for WalletManagerSystem {}
impl WalletManagerSystem {
    #[inline] pub fn request_store_async() -> Result<foundation::IAsyncOperation<WalletItemSystemStore>> {
        <Self as RtActivatable<IWalletManagerSystemStatics>>::get_activation_factory().request_store_async()
    }
}
DEFINE_CLSID!(WalletManagerSystem(&[87,105,110,100,111,119,115,46,65,112,112,108,105,99,97,116,105,111,110,77,111,100,101,108,46,87,97,108,108,101,116,46,83,121,115,116,101,109,46,87,97,108,108,101,116,77,97,110,97,103,101,114,83,121,115,116,101,109,0]) [CLSID_WalletManagerSystem]);
DEFINE_IID!(IID_IWalletManagerSystemStatics, 3202935689, 9780, 19354, 139, 35, 238, 137, 3, 201, 31, 224);
RT_INTERFACE!{static interface IWalletManagerSystemStatics(IWalletManagerSystemStaticsVtbl): IInspectable [IID_IWalletManagerSystemStatics] {
    fn RequestStoreAsync(&self, out: *mut <foundation::IAsyncOperation<WalletItemSystemStore> as RtType>::Abi) -> HRESULT
}}
impl IWalletManagerSystemStatics {
    #[inline] pub fn request_store_async(&self) -> Result<foundation::IAsyncOperation<WalletItemSystemStore>> { unsafe { 
        let mut out = null_mut();
        let hr = (self.get_vtbl().RequestStoreAsync)(self.get_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
} // Windows.ApplicationModel.Wallet.System
} // Windows.ApplicationModel.Wallet
