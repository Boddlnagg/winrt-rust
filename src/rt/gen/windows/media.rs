use crate::prelude::*;
DEFINE_IID!(IID_IAudioBuffer, 890722343, 29259, 19562, 177, 48, 246, 83, 127, 154, 224, 208);
RT_INTERFACE!{interface IAudioBuffer(IAudioBufferVtbl, IAudioBuffer_Abi): IInspectable(IInspectableVtbl) [IID_IAudioBuffer] {
    fn get_Capacity(&self, out: *mut u32) -> HRESULT,
    fn get_Length(&self, out: *mut u32) -> HRESULT,
    fn put_Length(&self, value: u32) -> HRESULT
}}
impl IAudioBuffer {
    #[inline] pub fn get_capacity(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Capacity)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_length(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Length)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_length(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Length)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioBuffer: IAudioBuffer}
RT_ENUM! { enum AudioBufferAccessMode: i32 {
    Read = 0, ReadWrite = 1, Write = 2,
}}
DEFINE_IID!(IID_IAudioFrame, 3815424772, 43698, 17015, 158, 208, 67, 206, 223, 142, 41, 198);
RT_INTERFACE!{interface IAudioFrame(IAudioFrameVtbl, IAudioFrame_Abi): IInspectable(IInspectableVtbl) [IID_IAudioFrame] {
    fn LockBuffer(&self, mode: AudioBufferAccessMode, out: *mut <AudioBuffer as RtType>::Abi) -> HRESULT
}}
impl IAudioFrame {
    #[inline] pub fn lock_buffer(&self, mode: AudioBufferAccessMode) -> Result<Option<AudioBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).LockBuffer)(self.0.as_abi() as *const _ as *mut _, mode, &mut out);
        if hr == S_OK { Ok(AudioBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioFrame: IAudioFrame}
impl RtActivatable<IAudioFrameFactory> for AudioFrame {}
impl AudioFrame {
    #[inline] pub fn create(capacity: u32) -> Result<AudioFrame> {
        <Self as RtActivatable<IAudioFrameFactory>>::get_activation_factory().create(capacity)
    }
}
DEFINE_CLSID!(AudioFrame(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,65,117,100,105,111,70,114,97,109,101,0]) [CLSID_AudioFrame]);
DEFINE_IID!(IID_IAudioFrameFactory, 2443774686, 9250, 16550, 185, 173, 48, 208, 36, 4, 49, 125);
RT_INTERFACE!{static interface IAudioFrameFactory(IAudioFrameFactoryVtbl, IAudioFrameFactory_Abi): IInspectable(IInspectableVtbl) [IID_IAudioFrameFactory] {
    fn Create(&self, capacity: u32, out: *mut <AudioFrame as RtType>::Abi) -> HRESULT
}}
impl IAudioFrameFactory {
    #[inline] pub fn create(&self, capacity: u32) -> Result<AudioFrame> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, capacity, &mut out);
        if hr == S_OK { Ok(AudioFrame::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum AudioProcessing: i32 {
    Default = 0, Raw = 1,
}}
DEFINE_IID!(IID_IAutoRepeatModeChangeRequestedEventArgs, 3927146234, 55378, 17294, 136, 43, 201, 144, 16, 154, 120, 244);
RT_INTERFACE!{interface IAutoRepeatModeChangeRequestedEventArgs(IAutoRepeatModeChangeRequestedEventArgsVtbl, IAutoRepeatModeChangeRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAutoRepeatModeChangeRequestedEventArgs] {
    fn get_RequestedAutoRepeatMode(&self, out: *mut MediaPlaybackAutoRepeatMode) -> HRESULT
}}
impl IAutoRepeatModeChangeRequestedEventArgs {
    #[inline] pub fn get_requested_auto_repeat_mode(&self) -> Result<MediaPlaybackAutoRepeatMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RequestedAutoRepeatMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AutoRepeatModeChangeRequestedEventArgs: IAutoRepeatModeChangeRequestedEventArgs}
DEFINE_IID!(IID_IImageDisplayProperties, 3440101359, 21735, 16671, 153, 51, 240, 233, 139, 10, 150, 210);
RT_INTERFACE!{interface IImageDisplayProperties(IImageDisplayPropertiesVtbl, IImageDisplayProperties_Abi): IInspectable(IInspectableVtbl) [IID_IImageDisplayProperties] {
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    fn get_Subtitle(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Subtitle(&self, value: HSTRING) -> HRESULT
}}
impl IImageDisplayProperties {
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Title)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_title(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Title)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_subtitle(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Subtitle)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_subtitle(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Subtitle)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ImageDisplayProperties: IImageDisplayProperties}
DEFINE_IID!(IID_IMediaControl, 2565995489, 31373, 17099, 182, 254, 143, 230, 152, 38, 79, 19);
RT_INTERFACE!{static interface IMediaControl(IMediaControlVtbl, IMediaControl_Abi): IInspectable(IInspectableVtbl) [IID_IMediaControl] {
    fn add_SoundLevelChanged(&self, handler: <foundation::EventHandler<IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SoundLevelChanged(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PlayPressed(&self, handler: <foundation::EventHandler<IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PlayPressed(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PausePressed(&self, handler: <foundation::EventHandler<IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PausePressed(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_StopPressed(&self, handler: <foundation::EventHandler<IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StopPressed(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PlayPauseTogglePressed(&self, handler: <foundation::EventHandler<IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PlayPauseTogglePressed(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_RecordPressed(&self, handler: <foundation::EventHandler<IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RecordPressed(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_NextTrackPressed(&self, handler: <foundation::EventHandler<IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NextTrackPressed(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PreviousTrackPressed(&self, handler: <foundation::EventHandler<IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PreviousTrackPressed(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_FastForwardPressed(&self, handler: <foundation::EventHandler<IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FastForwardPressed(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_RewindPressed(&self, handler: <foundation::EventHandler<IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RewindPressed(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ChannelUpPressed(&self, handler: <foundation::EventHandler<IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ChannelUpPressed(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ChannelDownPressed(&self, handler: <foundation::EventHandler<IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ChannelDownPressed(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn get_SoundLevel(&self, out: *mut SoundLevel) -> HRESULT,
    fn put_TrackName(&self, value: HSTRING) -> HRESULT,
    fn get_TrackName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ArtistName(&self, value: HSTRING) -> HRESULT,
    fn get_ArtistName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_IsPlaying(&self, value: bool) -> HRESULT,
    fn get_IsPlaying(&self, out: *mut bool) -> HRESULT,
    fn put_AlbumArt(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_AlbumArt(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT
}}
impl IMediaControl {
    #[inline] pub fn add_sound_level_changed(&self, handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SoundLevelChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_sound_level_changed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SoundLevelChanged)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_play_pressed(&self, handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PlayPressed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_play_pressed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PlayPressed)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pause_pressed(&self, handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PausePressed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pause_pressed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PausePressed)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stop_pressed(&self, handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StopPressed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stop_pressed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StopPressed)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_play_pause_toggle_pressed(&self, handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PlayPauseTogglePressed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_play_pause_toggle_pressed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PlayPauseTogglePressed)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_record_pressed(&self, handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_RecordPressed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_record_pressed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_RecordPressed)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_next_track_pressed(&self, handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_NextTrackPressed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_next_track_pressed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_NextTrackPressed)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_previous_track_pressed(&self, handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PreviousTrackPressed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_previous_track_pressed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PreviousTrackPressed)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_fast_forward_pressed(&self, handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_FastForwardPressed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_fast_forward_pressed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_FastForwardPressed)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_rewind_pressed(&self, handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_RewindPressed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_rewind_pressed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_RewindPressed)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_channel_up_pressed(&self, handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ChannelUpPressed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_channel_up_pressed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ChannelUpPressed)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_channel_down_pressed(&self, handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ChannelDownPressed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_channel_down_pressed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ChannelDownPressed)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sound_level(&self) -> Result<SoundLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SoundLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_track_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_TrackName)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_track_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TrackName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_artist_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ArtistName)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_artist_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ArtistName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_is_playing(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsPlaying)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_playing(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPlaying)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_album_art(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AlbumArt)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_album_art(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AlbumArt)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class MediaControl}
impl RtActivatable<IMediaControl> for MediaControl {}
impl MediaControl {
    #[inline] pub fn add_sound_level_changed(handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().add_sound_level_changed(handler)
    }
    #[inline] pub fn remove_sound_level_changed(cookie: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().remove_sound_level_changed(cookie)
    }
    #[inline] pub fn add_play_pressed(handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().add_play_pressed(handler)
    }
    #[inline] pub fn remove_play_pressed(cookie: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().remove_play_pressed(cookie)
    }
    #[inline] pub fn add_pause_pressed(handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().add_pause_pressed(handler)
    }
    #[inline] pub fn remove_pause_pressed(cookie: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().remove_pause_pressed(cookie)
    }
    #[inline] pub fn add_stop_pressed(handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().add_stop_pressed(handler)
    }
    #[inline] pub fn remove_stop_pressed(cookie: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().remove_stop_pressed(cookie)
    }
    #[inline] pub fn add_play_pause_toggle_pressed(handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().add_play_pause_toggle_pressed(handler)
    }
    #[inline] pub fn remove_play_pause_toggle_pressed(cookie: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().remove_play_pause_toggle_pressed(cookie)
    }
    #[inline] pub fn add_record_pressed(handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().add_record_pressed(handler)
    }
    #[inline] pub fn remove_record_pressed(cookie: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().remove_record_pressed(cookie)
    }
    #[inline] pub fn add_next_track_pressed(handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().add_next_track_pressed(handler)
    }
    #[inline] pub fn remove_next_track_pressed(cookie: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().remove_next_track_pressed(cookie)
    }
    #[inline] pub fn add_previous_track_pressed(handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().add_previous_track_pressed(handler)
    }
    #[inline] pub fn remove_previous_track_pressed(cookie: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().remove_previous_track_pressed(cookie)
    }
    #[inline] pub fn add_fast_forward_pressed(handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().add_fast_forward_pressed(handler)
    }
    #[inline] pub fn remove_fast_forward_pressed(cookie: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().remove_fast_forward_pressed(cookie)
    }
    #[inline] pub fn add_rewind_pressed(handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().add_rewind_pressed(handler)
    }
    #[inline] pub fn remove_rewind_pressed(cookie: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().remove_rewind_pressed(cookie)
    }
    #[inline] pub fn add_channel_up_pressed(handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().add_channel_up_pressed(handler)
    }
    #[inline] pub fn remove_channel_up_pressed(cookie: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().remove_channel_up_pressed(cookie)
    }
    #[inline] pub fn add_channel_down_pressed(handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().add_channel_down_pressed(handler)
    }
    #[inline] pub fn remove_channel_down_pressed(cookie: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().remove_channel_down_pressed(cookie)
    }
    #[inline] pub fn get_sound_level() -> Result<SoundLevel> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().get_sound_level()
    }
    #[inline] pub fn set_track_name(value: &HStringArg) -> Result<()> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().set_track_name(value)
    }
    #[inline] pub fn get_track_name() -> Result<HString> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().get_track_name()
    }
    #[inline] pub fn set_artist_name(value: &HStringArg) -> Result<()> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().set_artist_name(value)
    }
    #[inline] pub fn get_artist_name() -> Result<HString> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().get_artist_name()
    }
    #[inline] pub fn set_is_playing(value: bool) -> Result<()> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().set_is_playing(value)
    }
    #[inline] pub fn get_is_playing() -> Result<bool> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().get_is_playing()
    }
    #[inline] pub fn set_album_art(value: &foundation::Uri) -> Result<()> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().set_album_art(value)
    }
    #[inline] pub fn get_album_art() -> Result<Option<foundation::Uri>> {
        <Self as RtActivatable<IMediaControl>>::get_activation_factory().get_album_art()
    }
}
DEFINE_CLSID!(MediaControl(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,77,101,100,105,97,67,111,110,116,114,111,108,0]) [CLSID_MediaControl]);
DEFINE_IID!(IID_IMediaExtension, 126963992, 17887, 17451, 138, 63, 247, 130, 106, 99, 112, 171);
RT_INTERFACE!{interface IMediaExtension(IMediaExtensionVtbl, IMediaExtension_Abi): IInspectable(IInspectableVtbl) [IID_IMediaExtension] {
    fn SetProperties(&self, configuration: <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT
}}
impl IMediaExtension {
    #[inline] pub fn set_properties(&self, configuration: &foundation::collections::IPropertySet) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetProperties)(self.0.as_abi() as *const _ as *mut _, get_abi(configuration) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaExtensionManager, 1243998965, 9261, 19963, 151, 244, 105, 183, 196, 37, 118, 255);
RT_INTERFACE!{interface IMediaExtensionManager(IMediaExtensionManagerVtbl, IMediaExtensionManager_Abi): IInspectable(IInspectableVtbl) [IID_IMediaExtensionManager] {
    fn RegisterSchemeHandler(&self, activatableClassId: HSTRING, scheme: HSTRING) -> HRESULT,
    fn RegisterSchemeHandlerWithSettings(&self, activatableClassId: HSTRING, scheme: HSTRING, configuration: <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT,
    fn RegisterByteStreamHandler(&self, activatableClassId: HSTRING, fileExtension: HSTRING, mimeType: HSTRING) -> HRESULT,
    fn RegisterByteStreamHandlerWithSettings(&self, activatableClassId: HSTRING, fileExtension: HSTRING, mimeType: HSTRING, configuration: <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT,
    fn RegisterAudioDecoder(&self, activatableClassId: HSTRING, inputSubtype: Guid, outputSubtype: Guid) -> HRESULT,
    fn RegisterAudioDecoderWithSettings(&self, activatableClassId: HSTRING, inputSubtype: Guid, outputSubtype: Guid, configuration: <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT,
    fn RegisterAudioEncoder(&self, activatableClassId: HSTRING, inputSubtype: Guid, outputSubtype: Guid) -> HRESULT,
    fn RegisterAudioEncoderWithSettings(&self, activatableClassId: HSTRING, inputSubtype: Guid, outputSubtype: Guid, configuration: <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT,
    fn RegisterVideoDecoder(&self, activatableClassId: HSTRING, inputSubtype: Guid, outputSubtype: Guid) -> HRESULT,
    fn RegisterVideoDecoderWithSettings(&self, activatableClassId: HSTRING, inputSubtype: Guid, outputSubtype: Guid, configuration: <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT,
    fn RegisterVideoEncoder(&self, activatableClassId: HSTRING, inputSubtype: Guid, outputSubtype: Guid) -> HRESULT,
    fn RegisterVideoEncoderWithSettings(&self, activatableClassId: HSTRING, inputSubtype: Guid, outputSubtype: Guid, configuration: <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT
}}
impl IMediaExtensionManager {
    #[inline] pub fn register_scheme_handler(&self, activatableClassId: &HStringArg, scheme: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RegisterSchemeHandler)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get(), scheme.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn register_scheme_handler_with_settings(&self, activatableClassId: &HStringArg, scheme: &HStringArg, configuration: &foundation::collections::IPropertySet) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RegisterSchemeHandlerWithSettings)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get(), scheme.get(), get_abi(configuration) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn register_byte_stream_handler(&self, activatableClassId: &HStringArg, fileExtension: &HStringArg, mimeType: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RegisterByteStreamHandler)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get(), fileExtension.get(), mimeType.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn register_byte_stream_handler_with_settings(&self, activatableClassId: &HStringArg, fileExtension: &HStringArg, mimeType: &HStringArg, configuration: &foundation::collections::IPropertySet) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RegisterByteStreamHandlerWithSettings)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get(), fileExtension.get(), mimeType.get(), get_abi(configuration) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn register_audio_decoder(&self, activatableClassId: &HStringArg, inputSubtype: Guid, outputSubtype: Guid) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RegisterAudioDecoder)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get(), inputSubtype, outputSubtype);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn register_audio_decoder_with_settings(&self, activatableClassId: &HStringArg, inputSubtype: Guid, outputSubtype: Guid, configuration: &foundation::collections::IPropertySet) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RegisterAudioDecoderWithSettings)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get(), inputSubtype, outputSubtype, get_abi(configuration) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn register_audio_encoder(&self, activatableClassId: &HStringArg, inputSubtype: Guid, outputSubtype: Guid) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RegisterAudioEncoder)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get(), inputSubtype, outputSubtype);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn register_audio_encoder_with_settings(&self, activatableClassId: &HStringArg, inputSubtype: Guid, outputSubtype: Guid, configuration: &foundation::collections::IPropertySet) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RegisterAudioEncoderWithSettings)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get(), inputSubtype, outputSubtype, get_abi(configuration) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn register_video_decoder(&self, activatableClassId: &HStringArg, inputSubtype: Guid, outputSubtype: Guid) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RegisterVideoDecoder)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get(), inputSubtype, outputSubtype);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn register_video_decoder_with_settings(&self, activatableClassId: &HStringArg, inputSubtype: Guid, outputSubtype: Guid, configuration: &foundation::collections::IPropertySet) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RegisterVideoDecoderWithSettings)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get(), inputSubtype, outputSubtype, get_abi(configuration) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn register_video_encoder(&self, activatableClassId: &HStringArg, inputSubtype: Guid, outputSubtype: Guid) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RegisterVideoEncoder)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get(), inputSubtype, outputSubtype);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn register_video_encoder_with_settings(&self, activatableClassId: &HStringArg, inputSubtype: Guid, outputSubtype: Guid, configuration: &foundation::collections::IPropertySet) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RegisterVideoEncoderWithSettings)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get(), inputSubtype, outputSubtype, get_abi(configuration) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaExtensionManager: IMediaExtensionManager}
impl RtActivatable<IActivationFactory> for MediaExtensionManager {}
DEFINE_CLSID!(MediaExtensionManager(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,77,101,100,105,97,69,120,116,101,110,115,105,111,110,77,97,110,97,103,101,114,0]) [CLSID_MediaExtensionManager]);
DEFINE_IID!(IID_IMediaExtensionManager2, 1540276039, 16451, 20461, 172, 175, 84, 236, 41, 223, 177, 247);
RT_INTERFACE!{interface IMediaExtensionManager2(IMediaExtensionManager2Vtbl, IMediaExtensionManager2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaExtensionManager2] {
    #[cfg(feature="windows-applicationmodel")] fn RegisterMediaExtensionForAppService(&self, extension: <IMediaExtension as RtType>::Abi, connection: <super::applicationmodel::appservice::AppServiceConnection as RtType>::Abi) -> HRESULT
}}
impl IMediaExtensionManager2 {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub fn register_media_extension_for_app_service(&self, extension: &IMediaExtension, connection: &super::applicationmodel::appservice::AppServiceConnection) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RegisterMediaExtensionForAppService)(self.0.as_abi() as *const _ as *mut _, get_abi(extension) as *const _ as *mut _, get_abi(connection) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaFrame, 3216322444, 22851, 18392, 142, 16, 5, 48, 138, 165, 251, 208);
RT_INTERFACE!{interface IMediaFrame(IMediaFrameVtbl, IMediaFrame_Abi): IInspectable(IInspectableVtbl) [IID_IMediaFrame] {
    fn get_Type(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsReadOnly(&self, out: *mut bool) -> HRESULT,
    fn put_RelativeTime(&self, value: <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_RelativeTime(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn put_SystemRelativeTime(&self, value: <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_SystemRelativeTime(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn put_Duration(&self, value: <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_Duration(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn put_IsDiscontinuous(&self, value: bool) -> HRESULT,
    fn get_IsDiscontinuous(&self, out: *mut bool) -> HRESULT,
    fn get_ExtendedProperties(&self, out: *mut <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT
}}
impl IMediaFrame {
    #[inline] pub fn get_type(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Type)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_read_only(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsReadOnly)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_relative_time(&self, value: &foundation::IReference<foundation::TimeSpan>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_RelativeTime)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_relative_time(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_RelativeTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_system_relative_time(&self, value: &foundation::IReference<foundation::TimeSpan>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SystemRelativeTime)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_system_relative_time(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SystemRelativeTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_duration(&self, value: &foundation::IReference<foundation::TimeSpan>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Duration)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_is_discontinuous(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsDiscontinuous)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_discontinuous(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDiscontinuous)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_properties(&self) -> Result<Option<foundation::collections::IPropertySet>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IPropertySet::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaMarker, 402906872, 56485, 19311, 156, 32, 227, 211, 192, 100, 54, 37);
RT_INTERFACE!{interface IMediaMarker(IMediaMarkerVtbl, IMediaMarker_Abi): IInspectable(IInspectableVtbl) [IID_IMediaMarker] {
    fn get_Time(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_MediaMarkerType(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMediaMarker {
    #[inline] pub fn get_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Time)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_media_marker_type(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaMarkerType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Text)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaMarkers, 2951393673, 63709, 18030, 170, 16, 146, 11, 82, 53, 63, 223);
RT_INTERFACE!{interface IMediaMarkers(IMediaMarkersVtbl, IMediaMarkers_Abi): IInspectable(IInspectableVtbl) [IID_IMediaMarkers] {
    fn get_Markers(&self, out: *mut <foundation::collections::IVectorView<IMediaMarker> as RtType>::Abi) -> HRESULT
}}
impl IMediaMarkers {
    #[inline] pub fn get_markers(&self) -> Result<Option<foundation::collections::IVectorView<IMediaMarker>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Markers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class MediaMarkerTypes}
impl RtActivatable<IMediaMarkerTypesStatics> for MediaMarkerTypes {}
impl MediaMarkerTypes {
    #[inline] pub fn get_bookmark() -> Result<HString> {
        <Self as RtActivatable<IMediaMarkerTypesStatics>>::get_activation_factory().get_bookmark()
    }
}
DEFINE_CLSID!(MediaMarkerTypes(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,77,101,100,105,97,77,97,114,107,101,114,84,121,112,101,115,0]) [CLSID_MediaMarkerTypes]);
DEFINE_IID!(IID_IMediaMarkerTypesStatics, 3139010624, 18479, 18243, 136, 50, 69, 133, 56, 33, 236, 224);
RT_INTERFACE!{static interface IMediaMarkerTypesStatics(IMediaMarkerTypesStaticsVtbl, IMediaMarkerTypesStatics_Abi): IInspectable(IInspectableVtbl) [IID_IMediaMarkerTypesStatics] {
    fn get_Bookmark(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMediaMarkerTypesStatics {
    #[inline] pub fn get_bookmark(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Bookmark)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum MediaPlaybackAutoRepeatMode: i32 {
    None = 0, Track = 1, List = 2,
}}
RT_ENUM! { enum MediaPlaybackStatus: i32 {
    Closed = 0, Changing = 1, Stopped = 2, Playing = 3, Paused = 4,
}}
RT_ENUM! { enum MediaPlaybackType: i32 {
    Unknown = 0, Music = 1, Video = 2, Image = 3,
}}
DEFINE_IID!(IID_IMediaProcessingTriggerDetails, 3951387820, 41809, 20302, 180, 240, 155, 242, 64, 137, 147, 219);
RT_INTERFACE!{interface IMediaProcessingTriggerDetails(IMediaProcessingTriggerDetailsVtbl, IMediaProcessingTriggerDetails_Abi): IInspectable(IInspectableVtbl) [IID_IMediaProcessingTriggerDetails] {
    fn get_Arguments(&self, out: *mut <foundation::collections::ValueSet as RtType>::Abi) -> HRESULT
}}
impl IMediaProcessingTriggerDetails {
    #[inline] pub fn get_arguments(&self) -> Result<Option<foundation::collections::ValueSet>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Arguments)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::ValueSet::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaProcessingTriggerDetails: IMediaProcessingTriggerDetails}
DEFINE_IID!(IID_IMediaTimelineController, 2396217843, 2936, 17248, 191, 113, 12, 132, 25, 153, 234, 27);
RT_INTERFACE!{interface IMediaTimelineController(IMediaTimelineControllerVtbl, IMediaTimelineController_Abi): IInspectable(IInspectableVtbl) [IID_IMediaTimelineController] {
    fn Start(&self) -> HRESULT,
    fn Resume(&self) -> HRESULT,
    fn Pause(&self) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_Position(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_ClockRate(&self, out: *mut f64) -> HRESULT,
    fn put_ClockRate(&self, value: f64) -> HRESULT,
    fn get_State(&self, out: *mut MediaTimelineControllerState) -> HRESULT,
    fn add_PositionChanged(&self, positionChangedEventHandler: <foundation::TypedEventHandler<MediaTimelineController, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PositionChanged(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_StateChanged(&self, stateChangedEventHandler: <foundation::TypedEventHandler<MediaTimelineController, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StateChanged(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl IMediaTimelineController {
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn resume(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Resume)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn pause(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Pause)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_position(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Position)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_clock_rate(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ClockRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_clock_rate(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ClockRate)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_state(&self) -> Result<MediaTimelineControllerState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_position_changed(&self, positionChangedEventHandler: &foundation::TypedEventHandler<MediaTimelineController, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PositionChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(positionChangedEventHandler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_position_changed(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PositionChanged)(self.0.as_abi() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_state_changed(&self, stateChangedEventHandler: &foundation::TypedEventHandler<MediaTimelineController, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(stateChangedEventHandler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_state_changed(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StateChanged)(self.0.as_abi() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaTimelineController: IMediaTimelineController}
impl RtActivatable<IActivationFactory> for MediaTimelineController {}
DEFINE_CLSID!(MediaTimelineController(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,77,101,100,105,97,84,105,109,101,108,105,110,101,67,111,110,116,114,111,108,108,101,114,0]) [CLSID_MediaTimelineController]);
DEFINE_IID!(IID_IMediaTimelineController2, 4017416760, 40562, 19961, 131, 85, 110, 144, 200, 27, 186, 221);
RT_INTERFACE!{interface IMediaTimelineController2(IMediaTimelineController2Vtbl, IMediaTimelineController2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaTimelineController2] {
    fn get_Duration(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn put_Duration(&self, value: <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_IsLoopingEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsLoopingEnabled(&self, value: bool) -> HRESULT,
    fn add_Failed(&self, eventHandler: <foundation::TypedEventHandler<MediaTimelineController, MediaTimelineControllerFailedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Failed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Ended(&self, eventHandler: <foundation::TypedEventHandler<MediaTimelineController, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Ended(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IMediaTimelineController2 {
    #[inline] pub fn get_duration(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_duration(&self, value: &foundation::IReference<foundation::TimeSpan>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Duration)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_looping_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsLoopingEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_looping_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsLoopingEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_failed(&self, eventHandler: &foundation::TypedEventHandler<MediaTimelineController, MediaTimelineControllerFailedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Failed)(self.0.as_abi() as *const _ as *mut _, get_abi(eventHandler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_failed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Failed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_ended(&self, eventHandler: &foundation::TypedEventHandler<MediaTimelineController, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Ended)(self.0.as_abi() as *const _ as *mut _, get_abi(eventHandler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_ended(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Ended)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaTimelineControllerFailedEventArgs, 2283927581, 15991, 17403, 190, 38, 79, 200, 122, 4, 72, 52);
RT_INTERFACE!{interface IMediaTimelineControllerFailedEventArgs(IMediaTimelineControllerFailedEventArgsVtbl, IMediaTimelineControllerFailedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaTimelineControllerFailedEventArgs] {
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl IMediaTimelineControllerFailedEventArgs {
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaTimelineControllerFailedEventArgs: IMediaTimelineControllerFailedEventArgs}
RT_ENUM! { enum MediaTimelineControllerState: i32 {
    Paused = 0, Running = 1, Stalled = 2, Error = 3,
}}
RT_STRUCT! { struct MediaTimeRange {
    Start: foundation::TimeSpan, End: foundation::TimeSpan,
}}
DEFINE_IID!(IID_IMusicDisplayProperties, 1807682649, 53408, 19750, 146, 160, 249, 120, 225, 209, 142, 123);
RT_INTERFACE!{interface IMusicDisplayProperties(IMusicDisplayPropertiesVtbl, IMusicDisplayProperties_Abi): IInspectable(IInspectableVtbl) [IID_IMusicDisplayProperties] {
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    fn get_AlbumArtist(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AlbumArtist(&self, value: HSTRING) -> HRESULT,
    fn get_Artist(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Artist(&self, value: HSTRING) -> HRESULT
}}
impl IMusicDisplayProperties {
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Title)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_title(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Title)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_album_artist(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AlbumArtist)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_album_artist(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AlbumArtist)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_artist(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Artist)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_artist(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Artist)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MusicDisplayProperties: IMusicDisplayProperties}
DEFINE_IID!(IID_IMusicDisplayProperties2, 3572834, 38867, 17593, 176, 15, 0, 138, 252, 239, 175, 24);
RT_INTERFACE!{interface IMusicDisplayProperties2(IMusicDisplayProperties2Vtbl, IMusicDisplayProperties2_Abi): IInspectable(IInspectableVtbl) [IID_IMusicDisplayProperties2] {
    fn get_AlbumTitle(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AlbumTitle(&self, value: HSTRING) -> HRESULT,
    fn get_TrackNumber(&self, out: *mut u32) -> HRESULT,
    fn put_TrackNumber(&self, value: u32) -> HRESULT,
    fn get_Genres(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT
}}
impl IMusicDisplayProperties2 {
    #[inline] pub fn get_album_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AlbumTitle)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_album_title(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AlbumTitle)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_track_number(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TrackNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_track_number(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_TrackNumber)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_genres(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Genres)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMusicDisplayProperties3, 1303714497, 1665, 20108, 148, 1, 184, 21, 157, 158, 239, 199);
RT_INTERFACE!{interface IMusicDisplayProperties3(IMusicDisplayProperties3Vtbl, IMusicDisplayProperties3_Abi): IInspectable(IInspectableVtbl) [IID_IMusicDisplayProperties3] {
    fn get_AlbumTrackCount(&self, out: *mut u32) -> HRESULT,
    fn put_AlbumTrackCount(&self, value: u32) -> HRESULT
}}
impl IMusicDisplayProperties3 {
    #[inline] pub fn get_album_track_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AlbumTrackCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_album_track_count(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AlbumTrackCount)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPlaybackPositionChangeRequestedEventArgs, 3024699272, 60200, 18785, 156, 20, 51, 94, 68, 243, 225, 37);
RT_INTERFACE!{interface IPlaybackPositionChangeRequestedEventArgs(IPlaybackPositionChangeRequestedEventArgsVtbl, IPlaybackPositionChangeRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPlaybackPositionChangeRequestedEventArgs] {
    fn get_RequestedPlaybackPosition(&self, out: *mut foundation::TimeSpan) -> HRESULT
}}
impl IPlaybackPositionChangeRequestedEventArgs {
    #[inline] pub fn get_requested_playback_position(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RequestedPlaybackPosition)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PlaybackPositionChangeRequestedEventArgs: IPlaybackPositionChangeRequestedEventArgs}
DEFINE_IID!(IID_IPlaybackRateChangeRequestedEventArgs, 753058847, 15574, 20343, 155, 167, 235, 39, 194, 106, 33, 64);
RT_INTERFACE!{interface IPlaybackRateChangeRequestedEventArgs(IPlaybackRateChangeRequestedEventArgsVtbl, IPlaybackRateChangeRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPlaybackRateChangeRequestedEventArgs] {
    fn get_RequestedPlaybackRate(&self, out: *mut f64) -> HRESULT
}}
impl IPlaybackRateChangeRequestedEventArgs {
    #[inline] pub fn get_requested_playback_rate(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RequestedPlaybackRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PlaybackRateChangeRequestedEventArgs: IPlaybackRateChangeRequestedEventArgs}
DEFINE_IID!(IID_IShuffleEnabledChangeRequestedEventArgs, 1236636670, 20432, 18022, 163, 20, 192, 224, 25, 64, 211, 2);
RT_INTERFACE!{interface IShuffleEnabledChangeRequestedEventArgs(IShuffleEnabledChangeRequestedEventArgsVtbl, IShuffleEnabledChangeRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IShuffleEnabledChangeRequestedEventArgs] {
    fn get_RequestedShuffleEnabled(&self, out: *mut bool) -> HRESULT
}}
impl IShuffleEnabledChangeRequestedEventArgs {
    #[inline] pub fn get_requested_shuffle_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RequestedShuffleEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ShuffleEnabledChangeRequestedEventArgs: IShuffleEnabledChangeRequestedEventArgs}
RT_ENUM! { enum SoundLevel: i32 {
    Muted = 0, Low = 1, Full = 2,
}}
DEFINE_IID!(IID_ISystemMediaTransportControls, 2583314420, 5954, 17062, 144, 46, 8, 125, 65, 249, 101, 236);
RT_INTERFACE!{interface ISystemMediaTransportControls(ISystemMediaTransportControlsVtbl, ISystemMediaTransportControls_Abi): IInspectable(IInspectableVtbl) [IID_ISystemMediaTransportControls] {
    fn get_PlaybackStatus(&self, out: *mut MediaPlaybackStatus) -> HRESULT,
    fn put_PlaybackStatus(&self, value: MediaPlaybackStatus) -> HRESULT,
    fn get_DisplayUpdater(&self, out: *mut <SystemMediaTransportControlsDisplayUpdater as RtType>::Abi) -> HRESULT,
    fn get_SoundLevel(&self, out: *mut SoundLevel) -> HRESULT,
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsEnabled(&self, value: bool) -> HRESULT,
    fn get_IsPlayEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsPlayEnabled(&self, value: bool) -> HRESULT,
    fn get_IsStopEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsStopEnabled(&self, value: bool) -> HRESULT,
    fn get_IsPauseEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsPauseEnabled(&self, value: bool) -> HRESULT,
    fn get_IsRecordEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsRecordEnabled(&self, value: bool) -> HRESULT,
    fn get_IsFastForwardEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsFastForwardEnabled(&self, value: bool) -> HRESULT,
    fn get_IsRewindEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsRewindEnabled(&self, value: bool) -> HRESULT,
    fn get_IsPreviousEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsPreviousEnabled(&self, value: bool) -> HRESULT,
    fn get_IsNextEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsNextEnabled(&self, value: bool) -> HRESULT,
    fn get_IsChannelUpEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsChannelUpEnabled(&self, value: bool) -> HRESULT,
    fn get_IsChannelDownEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsChannelDownEnabled(&self, value: bool) -> HRESULT,
    fn add_ButtonPressed(&self, handler: <foundation::TypedEventHandler<SystemMediaTransportControls, SystemMediaTransportControlsButtonPressedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ButtonPressed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PropertyChanged(&self, handler: <foundation::TypedEventHandler<SystemMediaTransportControls, SystemMediaTransportControlsPropertyChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PropertyChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ISystemMediaTransportControls {
    #[inline] pub fn get_playback_status(&self) -> Result<MediaPlaybackStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_playback_status(&self, value: MediaPlaybackStatus) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PlaybackStatus)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_display_updater(&self) -> Result<Option<SystemMediaTransportControlsDisplayUpdater>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DisplayUpdater)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SystemMediaTransportControlsDisplayUpdater::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sound_level(&self) -> Result<SoundLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SoundLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_play_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPlayEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_play_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsPlayEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_stop_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStopEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_stop_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsStopEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_pause_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPauseEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_pause_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsPauseEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_record_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsRecordEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_record_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsRecordEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_fast_forward_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsFastForwardEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_fast_forward_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsFastForwardEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_rewind_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsRewindEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_rewind_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsRewindEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_previous_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPreviousEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_previous_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsPreviousEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_next_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsNextEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_next_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsNextEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_channel_up_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsChannelUpEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_channel_up_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsChannelUpEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_channel_down_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsChannelDownEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_channel_down_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsChannelDownEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_button_pressed(&self, handler: &foundation::TypedEventHandler<SystemMediaTransportControls, SystemMediaTransportControlsButtonPressedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ButtonPressed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_button_pressed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ButtonPressed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_property_changed(&self, handler: &foundation::TypedEventHandler<SystemMediaTransportControls, SystemMediaTransportControlsPropertyChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PropertyChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_property_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PropertyChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SystemMediaTransportControls: ISystemMediaTransportControls}
impl RtActivatable<ISystemMediaTransportControlsStatics> for SystemMediaTransportControls {}
impl SystemMediaTransportControls {
    #[inline] pub fn get_for_current_view() -> Result<Option<SystemMediaTransportControls>> {
        <Self as RtActivatable<ISystemMediaTransportControlsStatics>>::get_activation_factory().get_for_current_view()
    }
}
DEFINE_CLSID!(SystemMediaTransportControls(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,83,121,115,116,101,109,77,101,100,105,97,84,114,97,110,115,112,111,114,116,67,111,110,116,114,111,108,115,0]) [CLSID_SystemMediaTransportControls]);
DEFINE_IID!(IID_ISystemMediaTransportControls2, 3935884022, 32572, 19186, 165, 134, 114, 136, 152, 8, 239, 177);
RT_INTERFACE!{interface ISystemMediaTransportControls2(ISystemMediaTransportControls2Vtbl, ISystemMediaTransportControls2_Abi): IInspectable(IInspectableVtbl) [IID_ISystemMediaTransportControls2] {
    fn get_AutoRepeatMode(&self, out: *mut MediaPlaybackAutoRepeatMode) -> HRESULT,
    fn put_AutoRepeatMode(&self, value: MediaPlaybackAutoRepeatMode) -> HRESULT,
    fn get_ShuffleEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_ShuffleEnabled(&self, value: bool) -> HRESULT,
    fn get_PlaybackRate(&self, out: *mut f64) -> HRESULT,
    fn put_PlaybackRate(&self, value: f64) -> HRESULT,
    fn UpdateTimelineProperties(&self, timelineProperties: <SystemMediaTransportControlsTimelineProperties as RtType>::Abi) -> HRESULT,
    fn add_PlaybackPositionChangeRequested(&self, handler: <foundation::TypedEventHandler<SystemMediaTransportControls, PlaybackPositionChangeRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PlaybackPositionChangeRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PlaybackRateChangeRequested(&self, handler: <foundation::TypedEventHandler<SystemMediaTransportControls, PlaybackRateChangeRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PlaybackRateChangeRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ShuffleEnabledChangeRequested(&self, handler: <foundation::TypedEventHandler<SystemMediaTransportControls, ShuffleEnabledChangeRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ShuffleEnabledChangeRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_AutoRepeatModeChangeRequested(&self, handler: <foundation::TypedEventHandler<SystemMediaTransportControls, AutoRepeatModeChangeRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AutoRepeatModeChangeRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ISystemMediaTransportControls2 {
    #[inline] pub fn get_auto_repeat_mode(&self) -> Result<MediaPlaybackAutoRepeatMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutoRepeatMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto_repeat_mode(&self, value: MediaPlaybackAutoRepeatMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AutoRepeatMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_shuffle_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ShuffleEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_shuffle_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ShuffleEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_playback_rate(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_playback_rate(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PlaybackRate)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn update_timeline_properties(&self, timelineProperties: &SystemMediaTransportControlsTimelineProperties) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).UpdateTimelineProperties)(self.0.as_abi() as *const _ as *mut _, get_abi(timelineProperties) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_playback_position_change_requested(&self, handler: &foundation::TypedEventHandler<SystemMediaTransportControls, PlaybackPositionChangeRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PlaybackPositionChangeRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_playback_position_change_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PlaybackPositionChangeRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_playback_rate_change_requested(&self, handler: &foundation::TypedEventHandler<SystemMediaTransportControls, PlaybackRateChangeRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PlaybackRateChangeRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_playback_rate_change_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PlaybackRateChangeRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_shuffle_enabled_change_requested(&self, handler: &foundation::TypedEventHandler<SystemMediaTransportControls, ShuffleEnabledChangeRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ShuffleEnabledChangeRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_shuffle_enabled_change_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ShuffleEnabledChangeRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_auto_repeat_mode_change_requested(&self, handler: &foundation::TypedEventHandler<SystemMediaTransportControls, AutoRepeatModeChangeRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AutoRepeatModeChangeRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_auto_repeat_mode_change_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AutoRepeatModeChangeRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum SystemMediaTransportControlsButton: i32 {
    Play = 0, Pause = 1, Stop = 2, Record = 3, FastForward = 4, Rewind = 5, Next = 6, Previous = 7, ChannelUp = 8, ChannelDown = 9,
}}
DEFINE_IID!(IID_ISystemMediaTransportControlsButtonPressedEventArgs, 3086250262, 42351, 19912, 158, 17, 146, 3, 31, 74, 135, 194);
RT_INTERFACE!{interface ISystemMediaTransportControlsButtonPressedEventArgs(ISystemMediaTransportControlsButtonPressedEventArgsVtbl, ISystemMediaTransportControlsButtonPressedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ISystemMediaTransportControlsButtonPressedEventArgs] {
    fn get_Button(&self, out: *mut SystemMediaTransportControlsButton) -> HRESULT
}}
impl ISystemMediaTransportControlsButtonPressedEventArgs {
    #[inline] pub fn get_button(&self) -> Result<SystemMediaTransportControlsButton> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Button)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SystemMediaTransportControlsButtonPressedEventArgs: ISystemMediaTransportControlsButtonPressedEventArgs}
DEFINE_IID!(IID_ISystemMediaTransportControlsDisplayUpdater, 2327561534, 64085, 20175, 173, 142, 201, 132, 229, 221, 21, 80);
RT_INTERFACE!{interface ISystemMediaTransportControlsDisplayUpdater(ISystemMediaTransportControlsDisplayUpdaterVtbl, ISystemMediaTransportControlsDisplayUpdater_Abi): IInspectable(IInspectableVtbl) [IID_ISystemMediaTransportControlsDisplayUpdater] {
    fn get_Type(&self, out: *mut MediaPlaybackType) -> HRESULT,
    fn put_Type(&self, value: MediaPlaybackType) -> HRESULT,
    fn get_AppMediaId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AppMediaId(&self, value: HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Thumbnail(&self, out: *mut <super::storage::streams::RandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Thumbnail(&self, value: <super::storage::streams::RandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    fn get_MusicProperties(&self, out: *mut <MusicDisplayProperties as RtType>::Abi) -> HRESULT,
    fn get_VideoProperties(&self, out: *mut <VideoDisplayProperties as RtType>::Abi) -> HRESULT,
    fn get_ImageProperties(&self, out: *mut <ImageDisplayProperties as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy9(&self) -> (),
    #[cfg(feature="windows-storage")] fn CopyFromFileAsync(&self, type_: MediaPlaybackType, source: <super::storage::StorageFile as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn ClearAll(&self) -> HRESULT,
    fn Update(&self) -> HRESULT
}}
impl ISystemMediaTransportControlsDisplayUpdater {
    #[inline] pub fn get_type(&self) -> Result<MediaPlaybackType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Type)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_type(&self, value: MediaPlaybackType) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Type)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_app_media_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AppMediaId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_app_media_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AppMediaId)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_thumbnail(&self) -> Result<Option<super::storage::streams::RandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Thumbnail)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::storage::streams::RandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_thumbnail(&self, value: &super::storage::streams::RandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Thumbnail)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_music_properties(&self) -> Result<Option<MusicDisplayProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MusicProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MusicDisplayProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_properties(&self) -> Result<Option<VideoDisplayProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoDisplayProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_image_properties(&self) -> Result<Option<ImageDisplayProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ImageProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ImageDisplayProperties::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn copy_from_file_async(&self, type_: MediaPlaybackType, source: &super::storage::StorageFile) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CopyFromFileAsync)(self.0.as_abi() as *const _ as *mut _, type_, get_abi(source) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn clear_all(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ClearAll)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn update(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Update)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SystemMediaTransportControlsDisplayUpdater: ISystemMediaTransportControlsDisplayUpdater}
RT_ENUM! { enum SystemMediaTransportControlsProperty: i32 {
    SoundLevel = 0,
}}
DEFINE_IID!(IID_ISystemMediaTransportControlsPropertyChangedEventArgs, 3502901558, 13211, 19635, 142, 235, 115, 118, 7, 245, 110, 8);
RT_INTERFACE!{interface ISystemMediaTransportControlsPropertyChangedEventArgs(ISystemMediaTransportControlsPropertyChangedEventArgsVtbl, ISystemMediaTransportControlsPropertyChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ISystemMediaTransportControlsPropertyChangedEventArgs] {
    fn get_Property(&self, out: *mut SystemMediaTransportControlsProperty) -> HRESULT
}}
impl ISystemMediaTransportControlsPropertyChangedEventArgs {
    #[inline] pub fn get_property(&self) -> Result<SystemMediaTransportControlsProperty> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Property)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SystemMediaTransportControlsPropertyChangedEventArgs: ISystemMediaTransportControlsPropertyChangedEventArgs}
DEFINE_IID!(IID_ISystemMediaTransportControlsStatics, 1136277514, 60580, 18482, 145, 171, 212, 21, 250, 228, 132, 198);
RT_INTERFACE!{static interface ISystemMediaTransportControlsStatics(ISystemMediaTransportControlsStaticsVtbl, ISystemMediaTransportControlsStatics_Abi): IInspectable(IInspectableVtbl) [IID_ISystemMediaTransportControlsStatics] {
    fn GetForCurrentView(&self, out: *mut <SystemMediaTransportControls as RtType>::Abi) -> HRESULT
}}
impl ISystemMediaTransportControlsStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<SystemMediaTransportControls>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetForCurrentView)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SystemMediaTransportControls::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISystemMediaTransportControlsTimelineProperties, 1361391978, 50082, 18267, 133, 7, 147, 83, 77, 200, 143, 21);
RT_INTERFACE!{interface ISystemMediaTransportControlsTimelineProperties(ISystemMediaTransportControlsTimelinePropertiesVtbl, ISystemMediaTransportControlsTimelineProperties_Abi): IInspectable(IInspectableVtbl) [IID_ISystemMediaTransportControlsTimelineProperties] {
    fn get_StartTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_StartTime(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_EndTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_EndTime(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_MinSeekTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_MinSeekTime(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_MaxSeekTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_MaxSeekTime(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_Position(&self, value: foundation::TimeSpan) -> HRESULT
}}
impl ISystemMediaTransportControlsTimelineProperties {
    #[inline] pub fn get_start_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StartTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_start_time(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_StartTime)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_end_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_EndTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_end_time(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_EndTime)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_min_seek_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinSeekTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_min_seek_time(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MinSeekTime)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_seek_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxSeekTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_max_seek_time(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MaxSeekTime)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_position(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Position)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SystemMediaTransportControlsTimelineProperties: ISystemMediaTransportControlsTimelineProperties}
impl RtActivatable<IActivationFactory> for SystemMediaTransportControlsTimelineProperties {}
DEFINE_CLSID!(SystemMediaTransportControlsTimelineProperties(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,83,121,115,116,101,109,77,101,100,105,97,84,114,97,110,115,112,111,114,116,67,111,110,116,114,111,108,115,84,105,109,101,108,105,110,101,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_SystemMediaTransportControlsTimelineProperties]);
DEFINE_IID!(IID_IVideoDisplayProperties, 1443495345, 23853, 18546, 129, 112, 69, 222, 229, 188, 47, 92);
RT_INTERFACE!{interface IVideoDisplayProperties(IVideoDisplayPropertiesVtbl, IVideoDisplayProperties_Abi): IInspectable(IInspectableVtbl) [IID_IVideoDisplayProperties] {
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    fn get_Subtitle(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Subtitle(&self, value: HSTRING) -> HRESULT
}}
impl IVideoDisplayProperties {
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Title)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_title(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Title)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_subtitle(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Subtitle)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_subtitle(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Subtitle)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class VideoDisplayProperties: IVideoDisplayProperties}
DEFINE_IID!(IID_IVideoDisplayProperties2, 3021005262, 43858, 16811, 164, 134, 204, 16, 250, 177, 82, 249);
RT_INTERFACE!{interface IVideoDisplayProperties2(IVideoDisplayProperties2Vtbl, IVideoDisplayProperties2_Abi): IInspectable(IInspectableVtbl) [IID_IVideoDisplayProperties2] {
    fn get_Genres(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT
}}
impl IVideoDisplayProperties2 {
    #[inline] pub fn get_genres(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Genres)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class VideoEffects}
impl RtActivatable<IVideoEffectsStatics> for VideoEffects {}
impl VideoEffects {
    #[inline] pub fn get_video_stabilization() -> Result<HString> {
        <Self as RtActivatable<IVideoEffectsStatics>>::get_activation_factory().get_video_stabilization()
    }
}
DEFINE_CLSID!(VideoEffects(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,86,105,100,101,111,69,102,102,101,99,116,115,0]) [CLSID_VideoEffects]);
DEFINE_IID!(IID_IVideoEffectsStatics, 533571048, 47857, 17697, 152, 12, 59, 206, 187, 68, 207, 56);
RT_INTERFACE!{static interface IVideoEffectsStatics(IVideoEffectsStaticsVtbl, IVideoEffectsStatics_Abi): IInspectable(IInspectableVtbl) [IID_IVideoEffectsStatics] {
    fn get_VideoStabilization(&self, out: *mut HSTRING) -> HRESULT
}}
impl IVideoEffectsStatics {
    #[inline] pub fn get_video_stabilization(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoStabilization)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVideoFrame, 213935653, 37116, 19602, 189, 149, 125, 237, 33, 129, 157, 28);
RT_INTERFACE!{interface IVideoFrame(IVideoFrameVtbl, IVideoFrame_Abi): IInspectable(IInspectableVtbl) [IID_IVideoFrame] {
    #[cfg(feature="windows-graphics")] fn get_SoftwareBitmap(&self, out: *mut <super::graphics::imaging::SoftwareBitmap as RtType>::Abi) -> HRESULT,
    fn CopyToAsync(&self, frame: <VideoFrame as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn get_Direct3DSurface(&self, out: *mut <super::graphics::directx::direct3d11::IDirect3DSurface as RtType>::Abi) -> HRESULT
}}
impl IVideoFrame {
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_software_bitmap(&self) -> Result<Option<super::graphics::imaging::SoftwareBitmap>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SoftwareBitmap)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::graphics::imaging::SoftwareBitmap::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn copy_to_async(&self, frame: &VideoFrame) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CopyToAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(frame) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_direct3d_surface(&self) -> Result<Option<super::graphics::directx::direct3d11::IDirect3DSurface>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Direct3DSurface)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::graphics::directx::direct3d11::IDirect3DSurface::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VideoFrame: IVideoFrame}
impl RtActivatable<IVideoFrameFactory> for VideoFrame {}
impl RtActivatable<IVideoFrameStatics> for VideoFrame {}
impl VideoFrame {
    #[cfg(feature="windows-graphics")] #[inline] pub fn create(format: super::graphics::imaging::BitmapPixelFormat, width: i32, height: i32) -> Result<VideoFrame> {
        <Self as RtActivatable<IVideoFrameFactory>>::get_activation_factory().create(format, width, height)
    }
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_with_alpha(format: super::graphics::imaging::BitmapPixelFormat, width: i32, height: i32, alpha: super::graphics::imaging::BitmapAlphaMode) -> Result<VideoFrame> {
        <Self as RtActivatable<IVideoFrameFactory>>::get_activation_factory().create_with_alpha(format, width, height, alpha)
    }
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_as_direct3d11_surface_backed(format: super::graphics::directx::DirectXPixelFormat, width: i32, height: i32) -> Result<Option<VideoFrame>> {
        <Self as RtActivatable<IVideoFrameStatics>>::get_activation_factory().create_as_direct3d11_surface_backed(format, width, height)
    }
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_as_direct3d11_surface_backed_with_device(format: super::graphics::directx::DirectXPixelFormat, width: i32, height: i32, device: &super::graphics::directx::direct3d11::IDirect3DDevice) -> Result<Option<VideoFrame>> {
        <Self as RtActivatable<IVideoFrameStatics>>::get_activation_factory().create_as_direct3d11_surface_backed_with_device(format, width, height, device)
    }
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_with_software_bitmap(bitmap: &super::graphics::imaging::SoftwareBitmap) -> Result<Option<VideoFrame>> {
        <Self as RtActivatable<IVideoFrameStatics>>::get_activation_factory().create_with_software_bitmap(bitmap)
    }
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_with_direct3d11_surface(surface: &super::graphics::directx::direct3d11::IDirect3DSurface) -> Result<Option<VideoFrame>> {
        <Self as RtActivatable<IVideoFrameStatics>>::get_activation_factory().create_with_direct3d11_surface(surface)
    }
}
DEFINE_CLSID!(VideoFrame(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,86,105,100,101,111,70,114,97,109,101,0]) [CLSID_VideoFrame]);
DEFINE_IID!(IID_IVideoFrame2, 943162381, 13164, 17254, 141, 70, 6, 7, 152, 115, 108, 93);
RT_INTERFACE!{interface IVideoFrame2(IVideoFrame2Vtbl, IVideoFrame2_Abi): IInspectable(IInspectableVtbl) [IID_IVideoFrame2] {
    #[cfg(feature="windows-graphics")] fn CopyToWithBoundsAsync(&self, frame: <VideoFrame as RtType>::Abi, sourceBounds: <foundation::IReference<super::graphics::imaging::BitmapBounds> as RtType>::Abi, destinationBounds: <foundation::IReference<super::graphics::imaging::BitmapBounds> as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IVideoFrame2 {
    #[cfg(feature="windows-graphics")] #[inline] pub fn copy_to_with_bounds_async(&self, frame: &VideoFrame, sourceBounds: &foundation::IReference<super::graphics::imaging::BitmapBounds>, destinationBounds: &foundation::IReference<super::graphics::imaging::BitmapBounds>) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CopyToWithBoundsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(frame) as *const _ as *mut _, get_abi(sourceBounds) as *const _ as *mut _, get_abi(destinationBounds) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVideoFrameFactory, 21720425, 8744, 19602, 146, 255, 80, 195, 128, 211, 231, 118);
RT_INTERFACE!{static interface IVideoFrameFactory(IVideoFrameFactoryVtbl, IVideoFrameFactory_Abi): IInspectable(IInspectableVtbl) [IID_IVideoFrameFactory] {
    #[cfg(feature="windows-graphics")] fn Create(&self, format: super::graphics::imaging::BitmapPixelFormat, width: i32, height: i32, out: *mut <VideoFrame as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn CreateWithAlpha(&self, format: super::graphics::imaging::BitmapPixelFormat, width: i32, height: i32, alpha: super::graphics::imaging::BitmapAlphaMode, out: *mut <VideoFrame as RtType>::Abi) -> HRESULT
}}
impl IVideoFrameFactory {
    #[cfg(feature="windows-graphics")] #[inline] pub fn create(&self, format: super::graphics::imaging::BitmapPixelFormat, width: i32, height: i32) -> Result<VideoFrame> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, format, width, height, &mut out);
        if hr == S_OK { Ok(VideoFrame::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_with_alpha(&self, format: super::graphics::imaging::BitmapPixelFormat, width: i32, height: i32, alpha: super::graphics::imaging::BitmapAlphaMode) -> Result<VideoFrame> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithAlpha)(self.0.as_abi() as *const _ as *mut _, format, width, height, alpha, &mut out);
        if hr == S_OK { Ok(VideoFrame::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVideoFrameStatics, 2871678319, 24849, 19251, 142, 195, 43, 32, 154, 2, 225, 122);
RT_INTERFACE!{static interface IVideoFrameStatics(IVideoFrameStaticsVtbl, IVideoFrameStatics_Abi): IInspectable(IInspectableVtbl) [IID_IVideoFrameStatics] {
    #[cfg(feature="windows-graphics")] fn CreateAsDirect3D11SurfaceBacked(&self, format: super::graphics::directx::DirectXPixelFormat, width: i32, height: i32, out: *mut <VideoFrame as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn CreateAsDirect3D11SurfaceBackedWithDevice(&self, format: super::graphics::directx::DirectXPixelFormat, width: i32, height: i32, device: <super::graphics::directx::direct3d11::IDirect3DDevice as RtType>::Abi, out: *mut <VideoFrame as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn CreateWithSoftwareBitmap(&self, bitmap: <super::graphics::imaging::SoftwareBitmap as RtType>::Abi, out: *mut <VideoFrame as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn CreateWithDirect3D11Surface(&self, surface: <super::graphics::directx::direct3d11::IDirect3DSurface as RtType>::Abi, out: *mut <VideoFrame as RtType>::Abi) -> HRESULT
}}
impl IVideoFrameStatics {
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_as_direct3d11_surface_backed(&self, format: super::graphics::directx::DirectXPixelFormat, width: i32, height: i32) -> Result<Option<VideoFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateAsDirect3D11SurfaceBacked)(self.0.as_abi() as *const _ as *mut _, format, width, height, &mut out);
        if hr == S_OK { Ok(VideoFrame::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_as_direct3d11_surface_backed_with_device(&self, format: super::graphics::directx::DirectXPixelFormat, width: i32, height: i32, device: &super::graphics::directx::direct3d11::IDirect3DDevice) -> Result<Option<VideoFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateAsDirect3D11SurfaceBackedWithDevice)(self.0.as_abi() as *const _ as *mut _, format, width, height, get_abi(device) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoFrame::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_with_software_bitmap(&self, bitmap: &super::graphics::imaging::SoftwareBitmap) -> Result<Option<VideoFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithSoftwareBitmap)(self.0.as_abi() as *const _ as *mut _, get_abi(bitmap) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoFrame::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_with_direct3d11_surface(&self, surface: &super::graphics::directx::direct3d11::IDirect3DSurface) -> Result<Option<VideoFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithDirect3D11Surface)(self.0.as_abi() as *const _ as *mut _, get_abi(surface) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoFrame::wrap(out)) } else { err(hr) }
    }}
}
pub mod appbroadcasting { // Windows.Media.AppBroadcasting
use crate::prelude::*;
DEFINE_IID!(IID_IAppBroadcastingMonitor, 16341608, 35079, 18592, 184, 239, 36, 210, 8, 19, 117, 66);
RT_INTERFACE!{interface IAppBroadcastingMonitor(IAppBroadcastingMonitorVtbl, IAppBroadcastingMonitor_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastingMonitor] {
    fn get_IsCurrentAppBroadcasting(&self, out: *mut bool) -> HRESULT,
    fn add_IsCurrentAppBroadcastingChanged(&self, handler: <foundation::TypedEventHandler<AppBroadcastingMonitor, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_IsCurrentAppBroadcastingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAppBroadcastingMonitor {
    #[inline] pub fn get_is_current_app_broadcasting(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCurrentAppBroadcasting)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_is_current_app_broadcasting_changed(&self, handler: &foundation::TypedEventHandler<AppBroadcastingMonitor, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_IsCurrentAppBroadcastingChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_is_current_app_broadcasting_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_IsCurrentAppBroadcastingChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastingMonitor: IAppBroadcastingMonitor}
impl RtActivatable<IActivationFactory> for AppBroadcastingMonitor {}
DEFINE_CLSID!(AppBroadcastingMonitor(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,65,112,112,66,114,111,97,100,99,97,115,116,105,110,103,46,65,112,112,66,114,111,97,100,99,97,115,116,105,110,103,77,111,110,105,116,111,114,0]) [CLSID_AppBroadcastingMonitor]);
DEFINE_IID!(IID_IAppBroadcastingStatus, 304473311, 929, 17144, 139, 128, 201, 34, 140, 217, 207, 46);
RT_INTERFACE!{interface IAppBroadcastingStatus(IAppBroadcastingStatusVtbl, IAppBroadcastingStatus_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastingStatus] {
    fn get_CanStartBroadcast(&self, out: *mut bool) -> HRESULT,
    fn get_Details(&self, out: *mut <AppBroadcastingStatusDetails as RtType>::Abi) -> HRESULT
}}
impl IAppBroadcastingStatus {
    #[inline] pub fn get_can_start_broadcast(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanStartBroadcast)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_details(&self) -> Result<Option<AppBroadcastingStatusDetails>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Details)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastingStatusDetails::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastingStatus: IAppBroadcastingStatus}
DEFINE_IID!(IID_IAppBroadcastingStatusDetails, 110996900, 46451, 20028, 142, 25, 27, 175, 172, 208, 151, 19);
RT_INTERFACE!{interface IAppBroadcastingStatusDetails(IAppBroadcastingStatusDetailsVtbl, IAppBroadcastingStatusDetails_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastingStatusDetails] {
    fn get_IsAnyAppBroadcasting(&self, out: *mut bool) -> HRESULT,
    fn get_IsCaptureResourceUnavailable(&self, out: *mut bool) -> HRESULT,
    fn get_IsGameStreamInProgress(&self, out: *mut bool) -> HRESULT,
    fn get_IsGpuConstrained(&self, out: *mut bool) -> HRESULT,
    fn get_IsAppInactive(&self, out: *mut bool) -> HRESULT,
    fn get_IsBlockedForApp(&self, out: *mut bool) -> HRESULT,
    fn get_IsDisabledByUser(&self, out: *mut bool) -> HRESULT,
    fn get_IsDisabledBySystem(&self, out: *mut bool) -> HRESULT
}}
impl IAppBroadcastingStatusDetails {
    #[inline] pub fn get_is_any_app_broadcasting(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsAnyAppBroadcasting)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_capture_resource_unavailable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCaptureResourceUnavailable)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_game_stream_in_progress(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsGameStreamInProgress)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_gpu_constrained(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsGpuConstrained)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_app_inactive(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsAppInactive)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_blocked_for_app(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsBlockedForApp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_disabled_by_user(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDisabledByUser)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_disabled_by_system(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDisabledBySystem)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastingStatusDetails: IAppBroadcastingStatusDetails}
DEFINE_IID!(IID_IAppBroadcastingUI, 3849297807, 61081, 19914, 163, 195, 112, 175, 61, 180, 79, 95);
RT_INTERFACE!{interface IAppBroadcastingUI(IAppBroadcastingUIVtbl, IAppBroadcastingUI_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastingUI] {
    fn GetStatus(&self, out: *mut <AppBroadcastingStatus as RtType>::Abi) -> HRESULT,
    fn ShowBroadcastUI(&self) -> HRESULT
}}
impl IAppBroadcastingUI {
    #[inline] pub fn get_status(&self) -> Result<Option<AppBroadcastingStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastingStatus::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_broadcast_ui(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ShowBroadcastUI)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastingUI: IAppBroadcastingUI}
impl RtActivatable<IAppBroadcastingUIStatics> for AppBroadcastingUI {}
impl AppBroadcastingUI {
    #[inline] pub fn get_default() -> Result<Option<AppBroadcastingUI>> {
        <Self as RtActivatable<IAppBroadcastingUIStatics>>::get_activation_factory().get_default()
    }
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(user: &super::super::system::User) -> Result<Option<AppBroadcastingUI>> {
        <Self as RtActivatable<IAppBroadcastingUIStatics>>::get_activation_factory().get_for_user(user)
    }
}
DEFINE_CLSID!(AppBroadcastingUI(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,65,112,112,66,114,111,97,100,99,97,115,116,105,110,103,46,65,112,112,66,114,111,97,100,99,97,115,116,105,110,103,85,73,0]) [CLSID_AppBroadcastingUI]);
DEFINE_IID!(IID_IAppBroadcastingUIStatics, 1437116317, 9163, 17785, 156, 52, 136, 111, 224, 44, 4, 90);
RT_INTERFACE!{static interface IAppBroadcastingUIStatics(IAppBroadcastingUIStaticsVtbl, IAppBroadcastingUIStatics_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastingUIStatics] {
    fn GetDefault(&self, out: *mut <AppBroadcastingUI as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-system")] fn GetForUser(&self, user: <super::super::system::User as RtType>::Abi, out: *mut <AppBroadcastingUI as RtType>::Abi) -> HRESULT
}}
impl IAppBroadcastingUIStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<AppBroadcastingUI>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastingUI::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(&self, user: &super::super::system::User) -> Result<Option<AppBroadcastingUI>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetForUser)(self.0.as_abi() as *const _ as *mut _, get_abi(user) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastingUI::wrap(out)) } else { err(hr) }
    }}
}
} // Windows.Media.AppBroadcasting
pub mod apprecording { // Windows.Media.AppRecording
use crate::prelude::*;
DEFINE_IID!(IID_IAppRecordingManager, 3890372726, 41028, 18658, 165, 18, 48, 148, 213, 116, 199, 204);
RT_INTERFACE!{interface IAppRecordingManager(IAppRecordingManagerVtbl, IAppRecordingManager_Abi): IInspectable(IInspectableVtbl) [IID_IAppRecordingManager] {
    fn GetStatus(&self, out: *mut <AppRecordingStatus as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn StartRecordingToFileAsync(&self, file: <super::super::storage::StorageFile as RtType>::Abi, out: *mut <foundation::IAsyncOperation<AppRecordingResult> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn RecordTimeSpanToFileAsync(&self, startTime: foundation::DateTime, duration: foundation::TimeSpan, file: <super::super::storage::StorageFile as RtType>::Abi, out: *mut <foundation::IAsyncOperation<AppRecordingResult> as RtType>::Abi) -> HRESULT,
    fn get_SupportedScreenshotMediaEncodingSubtypes(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SaveScreenshotToFilesAsync(&self, folder: <super::super::storage::StorageFolder as RtType>::Abi, filenamePrefix: HSTRING, option: AppRecordingSaveScreenshotOption, requestedFormats: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<AppRecordingSaveScreenshotResult> as RtType>::Abi) -> HRESULT
}}
impl IAppRecordingManager {
    #[inline] pub fn get_status(&self) -> Result<Option<AppRecordingStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppRecordingStatus::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn start_recording_to_file_async(&self, file: &super::super::storage::StorageFile) -> Result<foundation::IAsyncOperation<AppRecordingResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StartRecordingToFileAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(file) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn record_time_span_to_file_async(&self, startTime: foundation::DateTime, duration: foundation::TimeSpan, file: &super::super::storage::StorageFile) -> Result<foundation::IAsyncOperation<AppRecordingResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RecordTimeSpanToFileAsync)(self.0.as_abi() as *const _ as *mut _, startTime, duration, get_abi(file) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_screenshot_media_encoding_subtypes(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedScreenshotMediaEncodingSubtypes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn save_screenshot_to_files_async(&self, folder: &super::super::storage::StorageFolder, filenamePrefix: &HStringArg, option: AppRecordingSaveScreenshotOption, requestedFormats: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<AppRecordingSaveScreenshotResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SaveScreenshotToFilesAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(folder) as *const _ as *mut _, filenamePrefix.get(), option, get_abi(requestedFormats) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppRecordingManager: IAppRecordingManager}
impl RtActivatable<IAppRecordingManagerStatics> for AppRecordingManager {}
impl AppRecordingManager {
    #[inline] pub fn get_default() -> Result<Option<AppRecordingManager>> {
        <Self as RtActivatable<IAppRecordingManagerStatics>>::get_activation_factory().get_default()
    }
}
DEFINE_CLSID!(AppRecordingManager(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,65,112,112,82,101,99,111,114,100,105,110,103,46,65,112,112,82,101,99,111,114,100,105,110,103,77,97,110,97,103,101,114,0]) [CLSID_AppRecordingManager]);
DEFINE_IID!(IID_IAppRecordingManagerStatics, 1357318647, 14542, 19411, 157, 178, 231, 43, 190, 157, 225, 29);
RT_INTERFACE!{static interface IAppRecordingManagerStatics(IAppRecordingManagerStaticsVtbl, IAppRecordingManagerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IAppRecordingManagerStatics] {
    fn GetDefault(&self, out: *mut <AppRecordingManager as RtType>::Abi) -> HRESULT
}}
impl IAppRecordingManagerStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<AppRecordingManager>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppRecordingManager::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppRecordingResult, 982517860, 50797, 18169, 178, 217, 91, 194, 218, 208, 112, 215);
RT_INTERFACE!{interface IAppRecordingResult(IAppRecordingResultVtbl, IAppRecordingResult_Abi): IInspectable(IInspectableVtbl) [IID_IAppRecordingResult] {
    fn get_Succeeded(&self, out: *mut bool) -> HRESULT,
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT,
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_IsFileTruncated(&self, out: *mut bool) -> HRESULT
}}
impl IAppRecordingResult {
    #[inline] pub fn get_succeeded(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Succeeded)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_file_truncated(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsFileTruncated)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppRecordingResult: IAppRecordingResult}
DEFINE_IID!(IID_IAppRecordingSavedScreenshotInfo, 2607033610, 6298, 19712, 191, 37, 225, 187, 18, 73, 213, 148);
RT_INTERFACE!{interface IAppRecordingSavedScreenshotInfo(IAppRecordingSavedScreenshotInfoVtbl, IAppRecordingSavedScreenshotInfo_Abi): IInspectable(IInspectableVtbl) [IID_IAppRecordingSavedScreenshotInfo] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_File(&self, out: *mut <super::super::storage::StorageFile as RtType>::Abi) -> HRESULT,
    fn get_MediaEncodingSubtype(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAppRecordingSavedScreenshotInfo {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_file(&self) -> Result<Option<super::super::storage::StorageFile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_File)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::StorageFile::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_media_encoding_subtype(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaEncodingSubtype)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppRecordingSavedScreenshotInfo: IAppRecordingSavedScreenshotInfo}
RT_ENUM! { enum AppRecordingSaveScreenshotOption: i32 {
    None = 0, HdrContentVisible = 1,
}}
DEFINE_IID!(IID_IAppRecordingSaveScreenshotResult, 2623245578, 2747, 17495, 170, 238, 36, 249, 193, 46, 199, 120);
RT_INTERFACE!{interface IAppRecordingSaveScreenshotResult(IAppRecordingSaveScreenshotResultVtbl, IAppRecordingSaveScreenshotResult_Abi): IInspectable(IInspectableVtbl) [IID_IAppRecordingSaveScreenshotResult] {
    fn get_Succeeded(&self, out: *mut bool) -> HRESULT,
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT,
    fn get_SavedScreenshotInfos(&self, out: *mut <foundation::collections::IVectorView<AppRecordingSavedScreenshotInfo> as RtType>::Abi) -> HRESULT
}}
impl IAppRecordingSaveScreenshotResult {
    #[inline] pub fn get_succeeded(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Succeeded)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_saved_screenshot_infos(&self) -> Result<Option<foundation::collections::IVectorView<AppRecordingSavedScreenshotInfo>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SavedScreenshotInfos)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppRecordingSaveScreenshotResult: IAppRecordingSaveScreenshotResult}
DEFINE_IID!(IID_IAppRecordingStatus, 487376940, 48152, 19338, 166, 239, 18, 126, 250, 179, 181, 217);
RT_INTERFACE!{interface IAppRecordingStatus(IAppRecordingStatusVtbl, IAppRecordingStatus_Abi): IInspectable(IInspectableVtbl) [IID_IAppRecordingStatus] {
    fn get_CanRecord(&self, out: *mut bool) -> HRESULT,
    fn get_CanRecordTimeSpan(&self, out: *mut bool) -> HRESULT,
    fn get_HistoricalBufferDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Details(&self, out: *mut <AppRecordingStatusDetails as RtType>::Abi) -> HRESULT
}}
impl IAppRecordingStatus {
    #[inline] pub fn get_can_record(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanRecord)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_record_time_span(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanRecordTimeSpan)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_historical_buffer_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HistoricalBufferDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_details(&self) -> Result<Option<AppRecordingStatusDetails>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Details)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppRecordingStatusDetails::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppRecordingStatus: IAppRecordingStatus}
DEFINE_IID!(IID_IAppRecordingStatusDetails, 3040389552, 5357, 17426, 172, 69, 109, 103, 44, 156, 153, 73);
RT_INTERFACE!{interface IAppRecordingStatusDetails(IAppRecordingStatusDetailsVtbl, IAppRecordingStatusDetails_Abi): IInspectable(IInspectableVtbl) [IID_IAppRecordingStatusDetails] {
    fn get_IsAnyAppBroadcasting(&self, out: *mut bool) -> HRESULT,
    fn get_IsCaptureResourceUnavailable(&self, out: *mut bool) -> HRESULT,
    fn get_IsGameStreamInProgress(&self, out: *mut bool) -> HRESULT,
    fn get_IsTimeSpanRecordingDisabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsGpuConstrained(&self, out: *mut bool) -> HRESULT,
    fn get_IsAppInactive(&self, out: *mut bool) -> HRESULT,
    fn get_IsBlockedForApp(&self, out: *mut bool) -> HRESULT,
    fn get_IsDisabledByUser(&self, out: *mut bool) -> HRESULT,
    fn get_IsDisabledBySystem(&self, out: *mut bool) -> HRESULT
}}
impl IAppRecordingStatusDetails {
    #[inline] pub fn get_is_any_app_broadcasting(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsAnyAppBroadcasting)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_capture_resource_unavailable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCaptureResourceUnavailable)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_game_stream_in_progress(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsGameStreamInProgress)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_time_span_recording_disabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsTimeSpanRecordingDisabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_gpu_constrained(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsGpuConstrained)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_app_inactive(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsAppInactive)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_blocked_for_app(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsBlockedForApp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_disabled_by_user(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDisabledByUser)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_disabled_by_system(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDisabledBySystem)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppRecordingStatusDetails: IAppRecordingStatusDetails}
} // Windows.Media.AppRecording
pub mod audio { // Windows.Media.Audio
use crate::prelude::*;
DEFINE_IID!(IID_IAudioDeviceInputNode, 2954587105, 28494, 18914, 172, 1, 85, 157, 98, 190, 179, 169);
RT_INTERFACE!{interface IAudioDeviceInputNode(IAudioDeviceInputNodeVtbl, IAudioDeviceInputNode_Abi): IInspectable(IInspectableVtbl) [IID_IAudioDeviceInputNode] {
    #[cfg(feature="windows-devices")] fn get_Device(&self, out: *mut <super::super::devices::enumeration::DeviceInformation as RtType>::Abi) -> HRESULT
}}
impl IAudioDeviceInputNode {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_device(&self) -> Result<Option<super::super::devices::enumeration::DeviceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Device)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::enumeration::DeviceInformation::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioDeviceInputNode: IAudioDeviceInputNode}
RT_ENUM! { enum AudioDeviceNodeCreationStatus: i32 {
    Success = 0, DeviceNotAvailable = 1, FormatNotSupported = 2, UnknownFailure = 3, AccessDenied = 4,
}}
DEFINE_IID!(IID_IAudioDeviceOutputNode, 909040639, 65308, 17460, 158, 15, 189, 46, 245, 34, 172, 130);
RT_INTERFACE!{interface IAudioDeviceOutputNode(IAudioDeviceOutputNodeVtbl, IAudioDeviceOutputNode_Abi): IInspectable(IInspectableVtbl) [IID_IAudioDeviceOutputNode] {
    #[cfg(feature="windows-devices")] fn get_Device(&self, out: *mut <super::super::devices::enumeration::DeviceInformation as RtType>::Abi) -> HRESULT
}}
impl IAudioDeviceOutputNode {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_device(&self) -> Result<Option<super::super::devices::enumeration::DeviceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Device)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::enumeration::DeviceInformation::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioDeviceOutputNode: IAudioDeviceOutputNode}
DEFINE_IID!(IID_IAudioFileInputNode, 2421909448, 28517, 19668, 136, 144, 70, 148, 132, 60, 39, 109);
RT_INTERFACE!{interface IAudioFileInputNode(IAudioFileInputNodeVtbl, IAudioFileInputNode_Abi): IInspectable(IInspectableVtbl) [IID_IAudioFileInputNode] {
    fn put_PlaybackSpeedFactor(&self, value: f64) -> HRESULT,
    fn get_PlaybackSpeedFactor(&self, out: *mut f64) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn Seek(&self, position: foundation::TimeSpan) -> HRESULT,
    fn get_StartTime(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn put_StartTime(&self, value: <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_EndTime(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn put_EndTime(&self, value: <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_LoopCount(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_LoopCount(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy11(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_SourceFile(&self, out: *mut <super::super::storage::StorageFile as RtType>::Abi) -> HRESULT,
    fn add_FileCompleted(&self, handler: <foundation::TypedEventHandler<AudioFileInputNode, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FileCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAudioFileInputNode {
    #[inline] pub fn set_playback_speed_factor(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PlaybackSpeedFactor)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_playback_speed_factor(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackSpeedFactor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn seek(&self, position: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Seek)(self.0.as_abi() as *const _ as *mut _, position);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_start_time(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_StartTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_start_time(&self, value: &foundation::IReference<foundation::TimeSpan>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_StartTime)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_end_time(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EndTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_end_time(&self, value: &foundation::IReference<foundation::TimeSpan>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_EndTime)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_loop_count(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_LoopCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_loop_count(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_LoopCount)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_source_file(&self) -> Result<Option<super::super::storage::StorageFile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SourceFile)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::StorageFile::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_file_completed(&self, handler: &foundation::TypedEventHandler<AudioFileInputNode, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_FileCompleted)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_file_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_FileCompleted)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioFileInputNode: IAudioFileInputNode}
RT_ENUM! { enum AudioFileNodeCreationStatus: i32 {
    Success = 0, FileNotFound = 1, InvalidFileType = 2, FormatNotSupported = 3, UnknownFailure = 4,
}}
DEFINE_IID!(IID_IAudioFileOutputNode, 1356863872, 20838, 16531, 128, 248, 173, 160, 0, 137, 233, 207);
RT_INTERFACE!{interface IAudioFileOutputNode(IAudioFileOutputNodeVtbl, IAudioFileOutputNode_Abi): IInspectable(IInspectableVtbl) [IID_IAudioFileOutputNode] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_File(&self, out: *mut <super::super::storage::IStorageFile as RtType>::Abi) -> HRESULT,
    fn get_FileEncodingProfile(&self, out: *mut <super::mediaproperties::MediaEncodingProfile as RtType>::Abi) -> HRESULT,
    fn FinalizeAsync(&self, out: *mut <foundation::IAsyncOperation<super::transcoding::TranscodeFailureReason> as RtType>::Abi) -> HRESULT
}}
impl IAudioFileOutputNode {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_file(&self) -> Result<Option<super::super::storage::IStorageFile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_File)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::IStorageFile::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_file_encoding_profile(&self) -> Result<Option<super::mediaproperties::MediaEncodingProfile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FileEncodingProfile)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::mediaproperties::MediaEncodingProfile::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn finalize_async(&self) -> Result<foundation::IAsyncOperation<super::transcoding::TranscodeFailureReason>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FinalizeAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioFileOutputNode: IAudioFileOutputNode}
DEFINE_IID!(IID_IAudioFrameCompletedEventArgs, 3699147422, 520, 17668, 165, 168, 240, 242, 104, 146, 10, 101);
RT_INTERFACE!{interface IAudioFrameCompletedEventArgs(IAudioFrameCompletedEventArgsVtbl, IAudioFrameCompletedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAudioFrameCompletedEventArgs] {
    fn get_Frame(&self, out: *mut <super::AudioFrame as RtType>::Abi) -> HRESULT
}}
impl IAudioFrameCompletedEventArgs {
    #[inline] pub fn get_frame(&self) -> Result<Option<super::AudioFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Frame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::AudioFrame::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioFrameCompletedEventArgs: IAudioFrameCompletedEventArgs}
DEFINE_IID!(IID_IAudioFrameInputNode, 28468935, 64918, 20469, 163, 197, 210, 122, 155, 244, 66, 55);
RT_INTERFACE!{interface IAudioFrameInputNode(IAudioFrameInputNodeVtbl, IAudioFrameInputNode_Abi): IInspectable(IInspectableVtbl) [IID_IAudioFrameInputNode] {
    fn put_PlaybackSpeedFactor(&self, value: f64) -> HRESULT,
    fn get_PlaybackSpeedFactor(&self, out: *mut f64) -> HRESULT,
    fn AddFrame(&self, frame: <super::AudioFrame as RtType>::Abi) -> HRESULT,
    fn DiscardQueuedFrames(&self) -> HRESULT,
    fn get_QueuedSampleCount(&self, out: *mut u64) -> HRESULT,
    fn add_AudioFrameCompleted(&self, handler: <foundation::TypedEventHandler<AudioFrameInputNode, AudioFrameCompletedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AudioFrameCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_QuantumStarted(&self, handler: <foundation::TypedEventHandler<AudioFrameInputNode, FrameInputNodeQuantumStartedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_QuantumStarted(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAudioFrameInputNode {
    #[inline] pub fn set_playback_speed_factor(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PlaybackSpeedFactor)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_playback_speed_factor(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackSpeedFactor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_frame(&self, frame: &super::AudioFrame) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AddFrame)(self.0.as_abi() as *const _ as *mut _, get_abi(frame) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn discard_queued_frames(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).DiscardQueuedFrames)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_queued_sample_count(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_QueuedSampleCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_audio_frame_completed(&self, handler: &foundation::TypedEventHandler<AudioFrameInputNode, AudioFrameCompletedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AudioFrameCompleted)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_audio_frame_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AudioFrameCompleted)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_quantum_started(&self, handler: &foundation::TypedEventHandler<AudioFrameInputNode, FrameInputNodeQuantumStartedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_QuantumStarted)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_quantum_started(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_QuantumStarted)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioFrameInputNode: IAudioFrameInputNode}
DEFINE_IID!(IID_IAudioFrameOutputNode, 3091674907, 12953, 17909, 136, 179, 201, 209, 42, 63, 28, 200);
RT_INTERFACE!{interface IAudioFrameOutputNode(IAudioFrameOutputNodeVtbl, IAudioFrameOutputNode_Abi): IInspectable(IInspectableVtbl) [IID_IAudioFrameOutputNode] {
    fn GetFrame(&self, out: *mut <super::AudioFrame as RtType>::Abi) -> HRESULT
}}
impl IAudioFrameOutputNode {
    #[inline] pub fn get_frame(&self) -> Result<Option<super::AudioFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::AudioFrame::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioFrameOutputNode: IAudioFrameOutputNode}
DEFINE_IID!(IID_IAudioGraph, 450129645, 58508, 19988, 150, 96, 44, 79, 131, 233, 205, 216);
RT_INTERFACE!{interface IAudioGraph(IAudioGraphVtbl, IAudioGraph_Abi): IInspectable(IInspectableVtbl) [IID_IAudioGraph] {
    fn CreateFrameInputNode(&self, out: *mut <AudioFrameInputNode as RtType>::Abi) -> HRESULT,
    fn CreateFrameInputNodeWithFormat(&self, encodingProperties: <super::mediaproperties::AudioEncodingProperties as RtType>::Abi, out: *mut <AudioFrameInputNode as RtType>::Abi) -> HRESULT,
    fn CreateDeviceInputNodeAsync(&self, category: super::capture::MediaCategory, out: *mut <foundation::IAsyncOperation<CreateAudioDeviceInputNodeResult> as RtType>::Abi) -> HRESULT,
    fn CreateDeviceInputNodeWithFormatAsync(&self, category: super::capture::MediaCategory, encodingProperties: <super::mediaproperties::AudioEncodingProperties as RtType>::Abi, out: *mut <foundation::IAsyncOperation<CreateAudioDeviceInputNodeResult> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-devices")] fn CreateDeviceInputNodeWithFormatOnDeviceAsync(&self, category: super::capture::MediaCategory, encodingProperties: <super::mediaproperties::AudioEncodingProperties as RtType>::Abi, device: <super::super::devices::enumeration::DeviceInformation as RtType>::Abi, out: *mut <foundation::IAsyncOperation<CreateAudioDeviceInputNodeResult> as RtType>::Abi) -> HRESULT,
    fn CreateFrameOutputNode(&self, out: *mut <AudioFrameOutputNode as RtType>::Abi) -> HRESULT,
    fn CreateFrameOutputNodeWithFormat(&self, encodingProperties: <super::mediaproperties::AudioEncodingProperties as RtType>::Abi, out: *mut <AudioFrameOutputNode as RtType>::Abi) -> HRESULT,
    fn CreateDeviceOutputNodeAsync(&self, out: *mut <foundation::IAsyncOperation<CreateAudioDeviceOutputNodeResult> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-storage")] fn CreateFileInputNodeAsync(&self, file: <super::super::storage::IStorageFile as RtType>::Abi, out: *mut <foundation::IAsyncOperation<CreateAudioFileInputNodeResult> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy9(&self) -> (),
    #[cfg(feature="windows-storage")] fn CreateFileOutputNodeAsync(&self, file: <super::super::storage::IStorageFile as RtType>::Abi, out: *mut <foundation::IAsyncOperation<CreateAudioFileOutputNodeResult> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy10(&self) -> (),
    #[cfg(feature="windows-storage")] fn CreateFileOutputNodeWithFileProfileAsync(&self, file: <super::super::storage::IStorageFile as RtType>::Abi, fileEncodingProfile: <super::mediaproperties::MediaEncodingProfile as RtType>::Abi, out: *mut <foundation::IAsyncOperation<CreateAudioFileOutputNodeResult> as RtType>::Abi) -> HRESULT,
    fn CreateSubmixNode(&self, out: *mut <AudioSubmixNode as RtType>::Abi) -> HRESULT,
    fn CreateSubmixNodeWithFormat(&self, encodingProperties: <super::mediaproperties::AudioEncodingProperties as RtType>::Abi, out: *mut <AudioSubmixNode as RtType>::Abi) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn ResetAllNodes(&self) -> HRESULT,
    fn add_QuantumStarted(&self, handler: <foundation::TypedEventHandler<AudioGraph, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_QuantumStarted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_QuantumProcessed(&self, handler: <foundation::TypedEventHandler<AudioGraph, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_QuantumProcessed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_UnrecoverableErrorOccurred(&self, handler: <foundation::TypedEventHandler<AudioGraph, AudioGraphUnrecoverableErrorOccurredEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_UnrecoverableErrorOccurred(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_CompletedQuantumCount(&self, out: *mut u64) -> HRESULT,
    fn get_EncodingProperties(&self, out: *mut <super::mediaproperties::AudioEncodingProperties as RtType>::Abi) -> HRESULT,
    fn get_LatencyInSamples(&self, out: *mut i32) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy25(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_PrimaryRenderDevice(&self, out: *mut <super::super::devices::enumeration::DeviceInformation as RtType>::Abi) -> HRESULT,
    fn get_RenderDeviceAudioProcessing(&self, out: *mut super::AudioProcessing) -> HRESULT,
    fn get_SamplesPerQuantum(&self, out: *mut i32) -> HRESULT
}}
impl IAudioGraph {
    #[inline] pub fn create_frame_input_node(&self) -> Result<Option<AudioFrameInputNode>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFrameInputNode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioFrameInputNode::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_frame_input_node_with_format(&self, encodingProperties: &super::mediaproperties::AudioEncodingProperties) -> Result<Option<AudioFrameInputNode>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFrameInputNodeWithFormat)(self.0.as_abi() as *const _ as *mut _, get_abi(encodingProperties) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioFrameInputNode::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_device_input_node_async(&self, category: super::capture::MediaCategory) -> Result<foundation::IAsyncOperation<CreateAudioDeviceInputNodeResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateDeviceInputNodeAsync)(self.0.as_abi() as *const _ as *mut _, category, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_device_input_node_with_format_async(&self, category: super::capture::MediaCategory, encodingProperties: &super::mediaproperties::AudioEncodingProperties) -> Result<foundation::IAsyncOperation<CreateAudioDeviceInputNodeResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateDeviceInputNodeWithFormatAsync)(self.0.as_abi() as *const _ as *mut _, category, get_abi(encodingProperties) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn create_device_input_node_with_format_on_device_async(&self, category: super::capture::MediaCategory, encodingProperties: &super::mediaproperties::AudioEncodingProperties, device: &super::super::devices::enumeration::DeviceInformation) -> Result<foundation::IAsyncOperation<CreateAudioDeviceInputNodeResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateDeviceInputNodeWithFormatOnDeviceAsync)(self.0.as_abi() as *const _ as *mut _, category, get_abi(encodingProperties) as *const _ as *mut _, get_abi(device) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_frame_output_node(&self) -> Result<Option<AudioFrameOutputNode>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFrameOutputNode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioFrameOutputNode::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_frame_output_node_with_format(&self, encodingProperties: &super::mediaproperties::AudioEncodingProperties) -> Result<Option<AudioFrameOutputNode>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFrameOutputNodeWithFormat)(self.0.as_abi() as *const _ as *mut _, get_abi(encodingProperties) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioFrameOutputNode::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_device_output_node_async(&self) -> Result<foundation::IAsyncOperation<CreateAudioDeviceOutputNodeResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateDeviceOutputNodeAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn create_file_input_node_async(&self, file: &super::super::storage::IStorageFile) -> Result<foundation::IAsyncOperation<CreateAudioFileInputNodeResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFileInputNodeAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(file) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn create_file_output_node_async(&self, file: &super::super::storage::IStorageFile) -> Result<foundation::IAsyncOperation<CreateAudioFileOutputNodeResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFileOutputNodeAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(file) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn create_file_output_node_with_file_profile_async(&self, file: &super::super::storage::IStorageFile, fileEncodingProfile: &super::mediaproperties::MediaEncodingProfile) -> Result<foundation::IAsyncOperation<CreateAudioFileOutputNodeResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFileOutputNodeWithFileProfileAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(file) as *const _ as *mut _, get_abi(fileEncodingProfile) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_submix_node(&self) -> Result<Option<AudioSubmixNode>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateSubmixNode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioSubmixNode::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_submix_node_with_format(&self, encodingProperties: &super::mediaproperties::AudioEncodingProperties) -> Result<Option<AudioSubmixNode>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateSubmixNodeWithFormat)(self.0.as_abi() as *const _ as *mut _, get_abi(encodingProperties) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioSubmixNode::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Stop)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn reset_all_nodes(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ResetAllNodes)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_quantum_started(&self, handler: &foundation::TypedEventHandler<AudioGraph, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_QuantumStarted)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_quantum_started(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_QuantumStarted)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_quantum_processed(&self, handler: &foundation::TypedEventHandler<AudioGraph, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_QuantumProcessed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_quantum_processed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_QuantumProcessed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_unrecoverable_error_occurred(&self, handler: &foundation::TypedEventHandler<AudioGraph, AudioGraphUnrecoverableErrorOccurredEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_UnrecoverableErrorOccurred)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_unrecoverable_error_occurred(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_UnrecoverableErrorOccurred)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_completed_quantum_count(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CompletedQuantumCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_encoding_properties(&self) -> Result<Option<super::mediaproperties::AudioEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EncodingProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::mediaproperties::AudioEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_latency_in_samples(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LatencyInSamples)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_primary_render_device(&self) -> Result<Option<super::super::devices::enumeration::DeviceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PrimaryRenderDevice)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::enumeration::DeviceInformation::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_render_device_audio_processing(&self) -> Result<super::AudioProcessing> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RenderDeviceAudioProcessing)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_samples_per_quantum(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SamplesPerQuantum)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioGraph: IAudioGraph}
impl RtActivatable<IAudioGraphStatics> for AudioGraph {}
impl AudioGraph {
    #[inline] pub fn create_async(settings: &AudioGraphSettings) -> Result<foundation::IAsyncOperation<CreateAudioGraphResult>> {
        <Self as RtActivatable<IAudioGraphStatics>>::get_activation_factory().create_async(settings)
    }
}
DEFINE_CLSID!(AudioGraph(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,65,117,100,105,111,46,65,117,100,105,111,71,114,97,112,104,0]) [CLSID_AudioGraph]);
DEFINE_IID!(IID_IAudioGraph2, 1313618901, 20417, 17910, 169, 71, 60, 211, 143, 79, 216, 57);
RT_INTERFACE!{interface IAudioGraph2(IAudioGraph2Vtbl, IAudioGraph2_Abi): IInspectable(IInspectableVtbl) [IID_IAudioGraph2] {
    fn CreateFrameInputNodeWithFormatAndEmitter(&self, encodingProperties: <super::mediaproperties::AudioEncodingProperties as RtType>::Abi, emitter: <AudioNodeEmitter as RtType>::Abi, out: *mut <AudioFrameInputNode as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-devices")] fn CreateDeviceInputNodeWithFormatAndEmitterOnDeviceAsync(&self, category: super::capture::MediaCategory, encodingProperties: <super::mediaproperties::AudioEncodingProperties as RtType>::Abi, device: <super::super::devices::enumeration::DeviceInformation as RtType>::Abi, emitter: <AudioNodeEmitter as RtType>::Abi, out: *mut <foundation::IAsyncOperation<CreateAudioDeviceInputNodeResult> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn CreateFileInputNodeWithEmitterAsync(&self, file: <super::super::storage::IStorageFile as RtType>::Abi, emitter: <AudioNodeEmitter as RtType>::Abi, out: *mut <foundation::IAsyncOperation<CreateAudioFileInputNodeResult> as RtType>::Abi) -> HRESULT,
    fn CreateSubmixNodeWithFormatAndEmitter(&self, encodingProperties: <super::mediaproperties::AudioEncodingProperties as RtType>::Abi, emitter: <AudioNodeEmitter as RtType>::Abi, out: *mut <AudioSubmixNode as RtType>::Abi) -> HRESULT,
    fn CreateBatchUpdater(&self, out: *mut <AudioGraphBatchUpdater as RtType>::Abi) -> HRESULT
}}
impl IAudioGraph2 {
    #[inline] pub fn create_frame_input_node_with_format_and_emitter(&self, encodingProperties: &super::mediaproperties::AudioEncodingProperties, emitter: &AudioNodeEmitter) -> Result<Option<AudioFrameInputNode>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFrameInputNodeWithFormatAndEmitter)(self.0.as_abi() as *const _ as *mut _, get_abi(encodingProperties) as *const _ as *mut _, get_abi(emitter) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioFrameInputNode::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn create_device_input_node_with_format_and_emitter_on_device_async(&self, category: super::capture::MediaCategory, encodingProperties: &super::mediaproperties::AudioEncodingProperties, device: &super::super::devices::enumeration::DeviceInformation, emitter: &AudioNodeEmitter) -> Result<foundation::IAsyncOperation<CreateAudioDeviceInputNodeResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateDeviceInputNodeWithFormatAndEmitterOnDeviceAsync)(self.0.as_abi() as *const _ as *mut _, category, get_abi(encodingProperties) as *const _ as *mut _, get_abi(device) as *const _ as *mut _, get_abi(emitter) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn create_file_input_node_with_emitter_async(&self, file: &super::super::storage::IStorageFile, emitter: &AudioNodeEmitter) -> Result<foundation::IAsyncOperation<CreateAudioFileInputNodeResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFileInputNodeWithEmitterAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(file) as *const _ as *mut _, get_abi(emitter) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_submix_node_with_format_and_emitter(&self, encodingProperties: &super::mediaproperties::AudioEncodingProperties, emitter: &AudioNodeEmitter) -> Result<Option<AudioSubmixNode>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateSubmixNodeWithFormatAndEmitter)(self.0.as_abi() as *const _ as *mut _, get_abi(encodingProperties) as *const _ as *mut _, get_abi(emitter) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioSubmixNode::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_batch_updater(&self) -> Result<Option<AudioGraphBatchUpdater>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateBatchUpdater)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioGraphBatchUpdater::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAudioGraph3, 3721209262, 4485, 17063, 131, 29, 106, 155, 15, 200, 104, 32);
RT_INTERFACE!{interface IAudioGraph3(IAudioGraph3Vtbl, IAudioGraph3_Abi): IInspectable(IInspectableVtbl) [IID_IAudioGraph3] {
    fn CreateMediaSourceAudioInputNodeAsync(&self, mediaSource: <super::core::MediaSource as RtType>::Abi, out: *mut <foundation::IAsyncOperation<CreateMediaSourceAudioInputNodeResult> as RtType>::Abi) -> HRESULT,
    fn CreateMediaSourceAudioInputNodeWithEmitterAsync(&self, mediaSource: <super::core::MediaSource as RtType>::Abi, emitter: <AudioNodeEmitter as RtType>::Abi, out: *mut <foundation::IAsyncOperation<CreateMediaSourceAudioInputNodeResult> as RtType>::Abi) -> HRESULT
}}
impl IAudioGraph3 {
    #[inline] pub fn create_media_source_audio_input_node_async(&self, mediaSource: &super::core::MediaSource) -> Result<foundation::IAsyncOperation<CreateMediaSourceAudioInputNodeResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateMediaSourceAudioInputNodeAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(mediaSource) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_media_source_audio_input_node_with_emitter_async(&self, mediaSource: &super::core::MediaSource, emitter: &AudioNodeEmitter) -> Result<foundation::IAsyncOperation<CreateMediaSourceAudioInputNodeResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateMediaSourceAudioInputNodeWithEmitterAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(mediaSource) as *const _ as *mut _, get_abi(emitter) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioGraphBatchUpdater: foundation::IClosable}
DEFINE_IID!(IID_IAudioGraphConnection, 1982886125, 53326, 20396, 178, 51, 96, 11, 66, 237, 212, 105);
RT_INTERFACE!{interface IAudioGraphConnection(IAudioGraphConnectionVtbl, IAudioGraphConnection_Abi): IInspectable(IInspectableVtbl) [IID_IAudioGraphConnection] {
    fn get_Destination(&self, out: *mut <IAudioNode as RtType>::Abi) -> HRESULT,
    fn put_Gain(&self, value: f64) -> HRESULT,
    fn get_Gain(&self, out: *mut f64) -> HRESULT
}}
impl IAudioGraphConnection {
    #[inline] pub fn get_destination(&self) -> Result<Option<IAudioNode>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Destination)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IAudioNode::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_gain(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Gain)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_gain(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Gain)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioGraphConnection: IAudioGraphConnection}
RT_ENUM! { enum AudioGraphCreationStatus: i32 {
    Success = 0, DeviceNotAvailable = 1, FormatNotSupported = 2, UnknownFailure = 3,
}}
DEFINE_IID!(IID_IAudioGraphSettings, 492397695, 59134, 17960, 132, 248, 157, 139, 219, 162, 87, 133);
RT_INTERFACE!{interface IAudioGraphSettings(IAudioGraphSettingsVtbl, IAudioGraphSettings_Abi): IInspectable(IInspectableVtbl) [IID_IAudioGraphSettings] {
    fn get_EncodingProperties(&self, out: *mut <super::mediaproperties::AudioEncodingProperties as RtType>::Abi) -> HRESULT,
    fn put_EncodingProperties(&self, value: <super::mediaproperties::AudioEncodingProperties as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_PrimaryRenderDevice(&self, out: *mut <super::super::devices::enumeration::DeviceInformation as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-devices")] fn put_PrimaryRenderDevice(&self, value: <super::super::devices::enumeration::DeviceInformation as RtType>::Abi) -> HRESULT,
    fn get_QuantumSizeSelectionMode(&self, out: *mut QuantumSizeSelectionMode) -> HRESULT,
    fn put_QuantumSizeSelectionMode(&self, value: QuantumSizeSelectionMode) -> HRESULT,
    fn get_DesiredSamplesPerQuantum(&self, out: *mut i32) -> HRESULT,
    fn put_DesiredSamplesPerQuantum(&self, value: i32) -> HRESULT,
    fn get_AudioRenderCategory(&self, out: *mut super::render::AudioRenderCategory) -> HRESULT,
    fn put_AudioRenderCategory(&self, value: super::render::AudioRenderCategory) -> HRESULT,
    fn get_DesiredRenderDeviceAudioProcessing(&self, out: *mut super::AudioProcessing) -> HRESULT,
    fn put_DesiredRenderDeviceAudioProcessing(&self, value: super::AudioProcessing) -> HRESULT
}}
impl IAudioGraphSettings {
    #[inline] pub fn get_encoding_properties(&self) -> Result<Option<super::mediaproperties::AudioEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EncodingProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::mediaproperties::AudioEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_encoding_properties(&self, value: &super::mediaproperties::AudioEncodingProperties) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_EncodingProperties)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_primary_render_device(&self) -> Result<Option<super::super::devices::enumeration::DeviceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PrimaryRenderDevice)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::enumeration::DeviceInformation::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn set_primary_render_device(&self, value: &super::super::devices::enumeration::DeviceInformation) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PrimaryRenderDevice)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_quantum_size_selection_mode(&self) -> Result<QuantumSizeSelectionMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_QuantumSizeSelectionMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_quantum_size_selection_mode(&self, value: QuantumSizeSelectionMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_QuantumSizeSelectionMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_desired_samples_per_quantum(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DesiredSamplesPerQuantum)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_samples_per_quantum(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DesiredSamplesPerQuantum)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_render_category(&self) -> Result<super::render::AudioRenderCategory> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioRenderCategory)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_audio_render_category(&self, value: super::render::AudioRenderCategory) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AudioRenderCategory)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_desired_render_device_audio_processing(&self) -> Result<super::AudioProcessing> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DesiredRenderDeviceAudioProcessing)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_render_device_audio_processing(&self, value: super::AudioProcessing) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DesiredRenderDeviceAudioProcessing)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioGraphSettings: IAudioGraphSettings}
impl RtActivatable<IAudioGraphSettingsFactory> for AudioGraphSettings {}
impl AudioGraphSettings {
    #[inline] pub fn create(audioRenderCategory: super::render::AudioRenderCategory) -> Result<AudioGraphSettings> {
        <Self as RtActivatable<IAudioGraphSettingsFactory>>::get_activation_factory().create(audioRenderCategory)
    }
}
DEFINE_CLSID!(AudioGraphSettings(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,65,117,100,105,111,46,65,117,100,105,111,71,114,97,112,104,83,101,116,116,105,110,103,115,0]) [CLSID_AudioGraphSettings]);
DEFINE_IID!(IID_IAudioGraphSettings2, 1922144135, 19883, 18147, 180, 201, 216, 225, 162, 99, 96, 98);
RT_INTERFACE!{interface IAudioGraphSettings2(IAudioGraphSettings2Vtbl, IAudioGraphSettings2_Abi): IInspectable(IInspectableVtbl) [IID_IAudioGraphSettings2] {
    fn put_MaxPlaybackSpeedFactor(&self, value: f64) -> HRESULT,
    fn get_MaxPlaybackSpeedFactor(&self, out: *mut f64) -> HRESULT
}}
impl IAudioGraphSettings2 {
    #[inline] pub fn set_max_playback_speed_factor(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MaxPlaybackSpeedFactor)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_playback_speed_factor(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxPlaybackSpeedFactor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAudioGraphSettingsFactory, 2782469318, 49899, 19041, 162, 20, 29, 102, 215, 95, 131, 218);
RT_INTERFACE!{static interface IAudioGraphSettingsFactory(IAudioGraphSettingsFactoryVtbl, IAudioGraphSettingsFactory_Abi): IInspectable(IInspectableVtbl) [IID_IAudioGraphSettingsFactory] {
    fn Create(&self, audioRenderCategory: super::render::AudioRenderCategory, out: *mut <AudioGraphSettings as RtType>::Abi) -> HRESULT
}}
impl IAudioGraphSettingsFactory {
    #[inline] pub fn create(&self, audioRenderCategory: super::render::AudioRenderCategory) -> Result<AudioGraphSettings> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, audioRenderCategory, &mut out);
        if hr == S_OK { Ok(AudioGraphSettings::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAudioGraphStatics, 1995190578, 57689, 19127, 168, 42, 23, 190, 180, 179, 30, 148);
RT_INTERFACE!{static interface IAudioGraphStatics(IAudioGraphStaticsVtbl, IAudioGraphStatics_Abi): IInspectable(IInspectableVtbl) [IID_IAudioGraphStatics] {
    fn CreateAsync(&self, settings: <AudioGraphSettings as RtType>::Abi, out: *mut <foundation::IAsyncOperation<CreateAudioGraphResult> as RtType>::Abi) -> HRESULT
}}
impl IAudioGraphStatics {
    #[inline] pub fn create_async(&self, settings: &AudioGraphSettings) -> Result<foundation::IAsyncOperation<CreateAudioGraphResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(settings) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum AudioGraphUnrecoverableError: i32 {
    None = 0, AudioDeviceLost = 1, AudioSessionDisconnected = 2, UnknownFailure = 3,
}}
DEFINE_IID!(IID_IAudioGraphUnrecoverableErrorOccurredEventArgs, 3285830624, 16374, 20403, 178, 98, 80, 212, 53, 197, 84, 35);
RT_INTERFACE!{interface IAudioGraphUnrecoverableErrorOccurredEventArgs(IAudioGraphUnrecoverableErrorOccurredEventArgsVtbl, IAudioGraphUnrecoverableErrorOccurredEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAudioGraphUnrecoverableErrorOccurredEventArgs] {
    fn get_Error(&self, out: *mut AudioGraphUnrecoverableError) -> HRESULT
}}
impl IAudioGraphUnrecoverableErrorOccurredEventArgs {
    #[inline] pub fn get_error(&self) -> Result<AudioGraphUnrecoverableError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Error)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioGraphUnrecoverableErrorOccurredEventArgs: IAudioGraphUnrecoverableErrorOccurredEventArgs}
DEFINE_IID!(IID_IAudioInputNode, 3511156828, 33832, 18308, 183, 253, 169, 157, 70, 140, 93, 32);
RT_INTERFACE!{interface IAudioInputNode(IAudioInputNodeVtbl, IAudioInputNode_Abi): IInspectable(IInspectableVtbl) [IID_IAudioInputNode] {
    fn get_OutgoingConnections(&self, out: *mut <foundation::collections::IVectorView<AudioGraphConnection> as RtType>::Abi) -> HRESULT,
    fn AddOutgoingConnection(&self, destination: <IAudioNode as RtType>::Abi) -> HRESULT,
    fn AddOutgoingConnectionWithGain(&self, destination: <IAudioNode as RtType>::Abi, gain: f64) -> HRESULT,
    fn RemoveOutgoingConnection(&self, destination: <IAudioNode as RtType>::Abi) -> HRESULT
}}
impl IAudioInputNode {
    #[inline] pub fn get_outgoing_connections(&self) -> Result<Option<foundation::collections::IVectorView<AudioGraphConnection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_OutgoingConnections)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_outgoing_connection(&self, destination: &IAudioNode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AddOutgoingConnection)(self.0.as_abi() as *const _ as *mut _, get_abi(destination) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_outgoing_connection_with_gain(&self, destination: &IAudioNode, gain: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AddOutgoingConnectionWithGain)(self.0.as_abi() as *const _ as *mut _, get_abi(destination) as *const _ as *mut _, gain);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove_outgoing_connection(&self, destination: &IAudioNode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RemoveOutgoingConnection)(self.0.as_abi() as *const _ as *mut _, get_abi(destination) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAudioInputNode2, 2421249719, 51816, 19565, 168, 188, 227, 238, 23, 254, 63, 210);
RT_INTERFACE!{interface IAudioInputNode2(IAudioInputNode2Vtbl, IAudioInputNode2_Abi): IInspectable(IInspectableVtbl) [IID_IAudioInputNode2] {
    fn get_Emitter(&self, out: *mut <AudioNodeEmitter as RtType>::Abi) -> HRESULT
}}
impl IAudioInputNode2 {
    #[inline] pub fn get_emitter(&self) -> Result<Option<AudioNodeEmitter>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Emitter)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioNodeEmitter::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAudioNode, 356031871, 56280, 18457, 191, 3, 102, 142, 147, 87, 205, 109);
RT_INTERFACE!{interface IAudioNode(IAudioNodeVtbl, IAudioNode_Abi): IInspectable(IInspectableVtbl) [IID_IAudioNode] {
    fn get_EffectDefinitions(&self, out: *mut <foundation::collections::IVector<super::effects::IAudioEffectDefinition> as RtType>::Abi) -> HRESULT,
    fn put_OutgoingGain(&self, value: f64) -> HRESULT,
    fn get_OutgoingGain(&self, out: *mut f64) -> HRESULT,
    fn get_EncodingProperties(&self, out: *mut <super::mediaproperties::AudioEncodingProperties as RtType>::Abi) -> HRESULT,
    fn get_ConsumeInput(&self, out: *mut bool) -> HRESULT,
    fn put_ConsumeInput(&self, value: bool) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn Reset(&self) -> HRESULT,
    fn DisableEffectsByDefinition(&self, definition: <super::effects::IAudioEffectDefinition as RtType>::Abi) -> HRESULT,
    fn EnableEffectsByDefinition(&self, definition: <super::effects::IAudioEffectDefinition as RtType>::Abi) -> HRESULT
}}
impl IAudioNode {
    #[inline] pub fn get_effect_definitions(&self) -> Result<Option<foundation::collections::IVector<super::effects::IAudioEffectDefinition>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EffectDefinitions)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_outgoing_gain(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_OutgoingGain)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_outgoing_gain(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OutgoingGain)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_encoding_properties(&self) -> Result<Option<super::mediaproperties::AudioEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EncodingProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::mediaproperties::AudioEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_consume_input(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConsumeInput)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_consume_input(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ConsumeInput)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Stop)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn reset(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Reset)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn disable_effects_by_definition(&self, definition: &super::effects::IAudioEffectDefinition) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).DisableEffectsByDefinition)(self.0.as_abi() as *const _ as *mut _, get_abi(definition) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn enable_effects_by_definition(&self, definition: &super::effects::IAudioEffectDefinition) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).EnableEffectsByDefinition)(self.0.as_abi() as *const _ as *mut _, get_abi(definition) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAudioNodeEmitter, 913741597, 34826, 18360, 173, 247, 19, 35, 169, 217, 101, 190);
RT_INTERFACE!{interface IAudioNodeEmitter(IAudioNodeEmitterVtbl, IAudioNodeEmitter_Abi): IInspectable(IInspectableVtbl) [IID_IAudioNodeEmitter] {
    fn get_Position(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn put_Position(&self, value: foundation::numerics::Vector3) -> HRESULT,
    fn get_Direction(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn put_Direction(&self, value: foundation::numerics::Vector3) -> HRESULT,
    fn get_Shape(&self, out: *mut <AudioNodeEmitterShape as RtType>::Abi) -> HRESULT,
    fn get_DecayModel(&self, out: *mut <AudioNodeEmitterDecayModel as RtType>::Abi) -> HRESULT,
    fn get_Gain(&self, out: *mut f64) -> HRESULT,
    fn put_Gain(&self, value: f64) -> HRESULT,
    fn get_DistanceScale(&self, out: *mut f64) -> HRESULT,
    fn put_DistanceScale(&self, value: f64) -> HRESULT,
    fn get_DopplerScale(&self, out: *mut f64) -> HRESULT,
    fn put_DopplerScale(&self, value: f64) -> HRESULT,
    fn get_DopplerVelocity(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn put_DopplerVelocity(&self, value: foundation::numerics::Vector3) -> HRESULT,
    fn get_IsDopplerDisabled(&self, out: *mut bool) -> HRESULT
}}
impl IAudioNodeEmitter {
    #[inline] pub fn get_position(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_position(&self, value: foundation::numerics::Vector3) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Position)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_direction(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Direction)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_direction(&self, value: foundation::numerics::Vector3) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Direction)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_shape(&self) -> Result<Option<AudioNodeEmitterShape>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Shape)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioNodeEmitterShape::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_decay_model(&self) -> Result<Option<AudioNodeEmitterDecayModel>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DecayModel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioNodeEmitterDecayModel::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_gain(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Gain)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_gain(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Gain)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_distance_scale(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DistanceScale)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_distance_scale(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DistanceScale)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_doppler_scale(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DopplerScale)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_doppler_scale(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DopplerScale)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_doppler_velocity(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DopplerVelocity)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_doppler_velocity(&self, value: foundation::numerics::Vector3) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DopplerVelocity)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_doppler_disabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDopplerDisabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioNodeEmitter: IAudioNodeEmitter}
impl RtActivatable<IAudioNodeEmitterFactory> for AudioNodeEmitter {}
impl RtActivatable<IActivationFactory> for AudioNodeEmitter {}
impl AudioNodeEmitter {
    #[inline] pub fn create_audio_node_emitter(shape: &AudioNodeEmitterShape, decayModel: &AudioNodeEmitterDecayModel, settings: AudioNodeEmitterSettings) -> Result<AudioNodeEmitter> {
        <Self as RtActivatable<IAudioNodeEmitterFactory>>::get_activation_factory().create_audio_node_emitter(shape, decayModel, settings)
    }
}
DEFINE_CLSID!(AudioNodeEmitter(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,65,117,100,105,111,46,65,117,100,105,111,78,111,100,101,69,109,105,116,116,101,114,0]) [CLSID_AudioNodeEmitter]);
DEFINE_IID!(IID_IAudioNodeEmitter2, 1253502667, 60457, 18424, 129, 140, 182, 182, 96, 165, 174, 177);
RT_INTERFACE!{interface IAudioNodeEmitter2(IAudioNodeEmitter2Vtbl, IAudioNodeEmitter2_Abi): IInspectable(IInspectableVtbl) [IID_IAudioNodeEmitter2] {
    fn get_SpatialAudioModel(&self, out: *mut SpatialAudioModel) -> HRESULT,
    fn put_SpatialAudioModel(&self, value: SpatialAudioModel) -> HRESULT
}}
impl IAudioNodeEmitter2 {
    #[inline] pub fn get_spatial_audio_model(&self) -> Result<SpatialAudioModel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SpatialAudioModel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_spatial_audio_model(&self, value: SpatialAudioModel) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SpatialAudioModel)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAudioNodeEmitterConeProperties, 3919260910, 714, 17269, 147, 38, 12, 106, 228, 188, 223, 181);
RT_INTERFACE!{interface IAudioNodeEmitterConeProperties(IAudioNodeEmitterConePropertiesVtbl, IAudioNodeEmitterConeProperties_Abi): IInspectable(IInspectableVtbl) [IID_IAudioNodeEmitterConeProperties] {
    fn get_InnerAngle(&self, out: *mut f64) -> HRESULT,
    fn get_OuterAngle(&self, out: *mut f64) -> HRESULT,
    fn get_OuterAngleGain(&self, out: *mut f64) -> HRESULT
}}
impl IAudioNodeEmitterConeProperties {
    #[inline] pub fn get_inner_angle(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InnerAngle)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_outer_angle(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OuterAngle)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_outer_angle_gain(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OuterAngleGain)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioNodeEmitterConeProperties: IAudioNodeEmitterConeProperties}
RT_ENUM! { enum AudioNodeEmitterDecayKind: i32 {
    Natural = 0, Custom = 1,
}}
DEFINE_IID!(IID_IAudioNodeEmitterDecayModel, 488463095, 3411, 20393, 189, 132, 213, 129, 106, 134, 243, 255);
RT_INTERFACE!{interface IAudioNodeEmitterDecayModel(IAudioNodeEmitterDecayModelVtbl, IAudioNodeEmitterDecayModel_Abi): IInspectable(IInspectableVtbl) [IID_IAudioNodeEmitterDecayModel] {
    fn get_Kind(&self, out: *mut AudioNodeEmitterDecayKind) -> HRESULT,
    fn get_MinGain(&self, out: *mut f64) -> HRESULT,
    fn get_MaxGain(&self, out: *mut f64) -> HRESULT,
    fn get_NaturalProperties(&self, out: *mut <AudioNodeEmitterNaturalDecayModelProperties as RtType>::Abi) -> HRESULT
}}
impl IAudioNodeEmitterDecayModel {
    #[inline] pub fn get_kind(&self) -> Result<AudioNodeEmitterDecayKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Kind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_gain(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinGain)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_gain(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxGain)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_natural_properties(&self) -> Result<Option<AudioNodeEmitterNaturalDecayModelProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_NaturalProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioNodeEmitterNaturalDecayModelProperties::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioNodeEmitterDecayModel: IAudioNodeEmitterDecayModel}
impl RtActivatable<IAudioNodeEmitterDecayModelStatics> for AudioNodeEmitterDecayModel {}
impl AudioNodeEmitterDecayModel {
    #[inline] pub fn create_natural(minGain: f64, maxGain: f64, unityGainDistance: f64, cutoffDistance: f64) -> Result<Option<AudioNodeEmitterDecayModel>> {
        <Self as RtActivatable<IAudioNodeEmitterDecayModelStatics>>::get_activation_factory().create_natural(minGain, maxGain, unityGainDistance, cutoffDistance)
    }
    #[inline] pub fn create_custom(minGain: f64, maxGain: f64) -> Result<Option<AudioNodeEmitterDecayModel>> {
        <Self as RtActivatable<IAudioNodeEmitterDecayModelStatics>>::get_activation_factory().create_custom(minGain, maxGain)
    }
}
DEFINE_CLSID!(AudioNodeEmitterDecayModel(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,65,117,100,105,111,46,65,117,100,105,111,78,111,100,101,69,109,105,116,116,101,114,68,101,99,97,121,77,111,100,101,108,0]) [CLSID_AudioNodeEmitterDecayModel]);
DEFINE_IID!(IID_IAudioNodeEmitterDecayModelStatics, 3346562216, 61816, 17967, 188, 129, 141, 213, 203, 229, 218, 232);
RT_INTERFACE!{static interface IAudioNodeEmitterDecayModelStatics(IAudioNodeEmitterDecayModelStaticsVtbl, IAudioNodeEmitterDecayModelStatics_Abi): IInspectable(IInspectableVtbl) [IID_IAudioNodeEmitterDecayModelStatics] {
    fn CreateNatural(&self, minGain: f64, maxGain: f64, unityGainDistance: f64, cutoffDistance: f64, out: *mut <AudioNodeEmitterDecayModel as RtType>::Abi) -> HRESULT,
    fn CreateCustom(&self, minGain: f64, maxGain: f64, out: *mut <AudioNodeEmitterDecayModel as RtType>::Abi) -> HRESULT
}}
impl IAudioNodeEmitterDecayModelStatics {
    #[inline] pub fn create_natural(&self, minGain: f64, maxGain: f64, unityGainDistance: f64, cutoffDistance: f64) -> Result<Option<AudioNodeEmitterDecayModel>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateNatural)(self.0.as_abi() as *const _ as *mut _, minGain, maxGain, unityGainDistance, cutoffDistance, &mut out);
        if hr == S_OK { Ok(AudioNodeEmitterDecayModel::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_custom(&self, minGain: f64, maxGain: f64) -> Result<Option<AudioNodeEmitterDecayModel>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateCustom)(self.0.as_abi() as *const _ as *mut _, minGain, maxGain, &mut out);
        if hr == S_OK { Ok(AudioNodeEmitterDecayModel::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAudioNodeEmitterFactory, 4257761434, 27350, 19684, 183, 247, 169, 147, 112, 223, 126, 233);
RT_INTERFACE!{static interface IAudioNodeEmitterFactory(IAudioNodeEmitterFactoryVtbl, IAudioNodeEmitterFactory_Abi): IInspectable(IInspectableVtbl) [IID_IAudioNodeEmitterFactory] {
    fn CreateAudioNodeEmitter(&self, shape: <AudioNodeEmitterShape as RtType>::Abi, decayModel: <AudioNodeEmitterDecayModel as RtType>::Abi, settings: AudioNodeEmitterSettings, out: *mut <AudioNodeEmitter as RtType>::Abi) -> HRESULT
}}
impl IAudioNodeEmitterFactory {
    #[inline] pub fn create_audio_node_emitter(&self, shape: &AudioNodeEmitterShape, decayModel: &AudioNodeEmitterDecayModel, settings: AudioNodeEmitterSettings) -> Result<AudioNodeEmitter> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateAudioNodeEmitter)(self.0.as_abi() as *const _ as *mut _, get_abi(shape) as *const _ as *mut _, get_abi(decayModel) as *const _ as *mut _, settings, &mut out);
        if hr == S_OK { Ok(AudioNodeEmitter::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAudioNodeEmitterNaturalDecayModelProperties, 1217612751, 53036, 20220, 147, 49, 117, 189, 34, 223, 31, 12);
RT_INTERFACE!{interface IAudioNodeEmitterNaturalDecayModelProperties(IAudioNodeEmitterNaturalDecayModelPropertiesVtbl, IAudioNodeEmitterNaturalDecayModelProperties_Abi): IInspectable(IInspectableVtbl) [IID_IAudioNodeEmitterNaturalDecayModelProperties] {
    fn get_UnityGainDistance(&self, out: *mut f64) -> HRESULT,
    fn get_CutoffDistance(&self, out: *mut f64) -> HRESULT
}}
impl IAudioNodeEmitterNaturalDecayModelProperties {
    #[inline] pub fn get_unity_gain_distance(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UnityGainDistance)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cutoff_distance(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CutoffDistance)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioNodeEmitterNaturalDecayModelProperties: IAudioNodeEmitterNaturalDecayModelProperties}
RT_ENUM! { enum AudioNodeEmitterSettings: u32 {
    None = 0, DisableDoppler = 1,
}}
DEFINE_IID!(IID_IAudioNodeEmitterShape, 3926069701, 59197, 17596, 133, 156, 69, 85, 59, 188, 72, 40);
RT_INTERFACE!{interface IAudioNodeEmitterShape(IAudioNodeEmitterShapeVtbl, IAudioNodeEmitterShape_Abi): IInspectable(IInspectableVtbl) [IID_IAudioNodeEmitterShape] {
    fn get_Kind(&self, out: *mut AudioNodeEmitterShapeKind) -> HRESULT,
    fn get_ConeProperties(&self, out: *mut <AudioNodeEmitterConeProperties as RtType>::Abi) -> HRESULT
}}
impl IAudioNodeEmitterShape {
    #[inline] pub fn get_kind(&self) -> Result<AudioNodeEmitterShapeKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Kind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cone_properties(&self) -> Result<Option<AudioNodeEmitterConeProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConeProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioNodeEmitterConeProperties::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioNodeEmitterShape: IAudioNodeEmitterShape}
impl RtActivatable<IAudioNodeEmitterShapeStatics> for AudioNodeEmitterShape {}
impl AudioNodeEmitterShape {
    #[inline] pub fn create_cone(innerAngle: f64, outerAngle: f64, outerAngleGain: f64) -> Result<Option<AudioNodeEmitterShape>> {
        <Self as RtActivatable<IAudioNodeEmitterShapeStatics>>::get_activation_factory().create_cone(innerAngle, outerAngle, outerAngleGain)
    }
    #[inline] pub fn create_omnidirectional() -> Result<Option<AudioNodeEmitterShape>> {
        <Self as RtActivatable<IAudioNodeEmitterShapeStatics>>::get_activation_factory().create_omnidirectional()
    }
}
DEFINE_CLSID!(AudioNodeEmitterShape(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,65,117,100,105,111,46,65,117,100,105,111,78,111,100,101,69,109,105,116,116,101,114,83,104,97,112,101,0]) [CLSID_AudioNodeEmitterShape]);
RT_ENUM! { enum AudioNodeEmitterShapeKind: i32 {
    Omnidirectional = 0, Cone = 1,
}}
DEFINE_IID!(IID_IAudioNodeEmitterShapeStatics, 1471883121, 65445, 19334, 167, 121, 226, 100, 174, 185, 20, 95);
RT_INTERFACE!{static interface IAudioNodeEmitterShapeStatics(IAudioNodeEmitterShapeStaticsVtbl, IAudioNodeEmitterShapeStatics_Abi): IInspectable(IInspectableVtbl) [IID_IAudioNodeEmitterShapeStatics] {
    fn CreateCone(&self, innerAngle: f64, outerAngle: f64, outerAngleGain: f64, out: *mut <AudioNodeEmitterShape as RtType>::Abi) -> HRESULT,
    fn CreateOmnidirectional(&self, out: *mut <AudioNodeEmitterShape as RtType>::Abi) -> HRESULT
}}
impl IAudioNodeEmitterShapeStatics {
    #[inline] pub fn create_cone(&self, innerAngle: f64, outerAngle: f64, outerAngleGain: f64) -> Result<Option<AudioNodeEmitterShape>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateCone)(self.0.as_abi() as *const _ as *mut _, innerAngle, outerAngle, outerAngleGain, &mut out);
        if hr == S_OK { Ok(AudioNodeEmitterShape::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_omnidirectional(&self) -> Result<Option<AudioNodeEmitterShape>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateOmnidirectional)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioNodeEmitterShape::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAudioNodeListener, 3648138774, 3082, 16858, 183, 85, 108, 119, 131, 95, 177, 235);
RT_INTERFACE!{interface IAudioNodeListener(IAudioNodeListenerVtbl, IAudioNodeListener_Abi): IInspectable(IInspectableVtbl) [IID_IAudioNodeListener] {
    fn get_Position(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn put_Position(&self, value: foundation::numerics::Vector3) -> HRESULT,
    fn get_Orientation(&self, out: *mut foundation::numerics::Quaternion) -> HRESULT,
    fn put_Orientation(&self, value: foundation::numerics::Quaternion) -> HRESULT,
    fn get_SpeedOfSound(&self, out: *mut f64) -> HRESULT,
    fn put_SpeedOfSound(&self, value: f64) -> HRESULT,
    fn get_DopplerVelocity(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn put_DopplerVelocity(&self, value: foundation::numerics::Vector3) -> HRESULT
}}
impl IAudioNodeListener {
    #[inline] pub fn get_position(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_position(&self, value: foundation::numerics::Vector3) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Position)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_orientation(&self) -> Result<foundation::numerics::Quaternion> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Orientation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_orientation(&self, value: foundation::numerics::Quaternion) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Orientation)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_speed_of_sound(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SpeedOfSound)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_speed_of_sound(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SpeedOfSound)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_doppler_velocity(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DopplerVelocity)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_doppler_velocity(&self, value: foundation::numerics::Vector3) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DopplerVelocity)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioNodeListener: IAudioNodeListener}
impl RtActivatable<IActivationFactory> for AudioNodeListener {}
DEFINE_CLSID!(AudioNodeListener(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,65,117,100,105,111,46,65,117,100,105,111,78,111,100,101,76,105,115,116,101,110,101,114,0]) [CLSID_AudioNodeListener]);
DEFINE_IID!(IID_IAudioNodeWithListener, 235901052, 31231, 17732, 158, 235, 1, 37, 123, 21, 16, 90);
RT_INTERFACE!{interface IAudioNodeWithListener(IAudioNodeWithListenerVtbl, IAudioNodeWithListener_Abi): IInspectable(IInspectableVtbl) [IID_IAudioNodeWithListener] {
    fn put_Listener(&self, value: <AudioNodeListener as RtType>::Abi) -> HRESULT,
    fn get_Listener(&self, out: *mut <AudioNodeListener as RtType>::Abi) -> HRESULT
}}
impl IAudioNodeWithListener {
    #[inline] pub fn set_listener(&self, value: &AudioNodeListener) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Listener)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_listener(&self) -> Result<Option<AudioNodeListener>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Listener)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioNodeListener::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAudioStateMonitor, 487838006, 409, 19676, 184, 78, 231, 44, 43, 88, 30, 206);
RT_INTERFACE!{interface IAudioStateMonitor(IAudioStateMonitorVtbl, IAudioStateMonitor_Abi): IInspectable(IInspectableVtbl) [IID_IAudioStateMonitor] {
    fn add_SoundLevelChanged(&self, handler: <foundation::TypedEventHandler<AudioStateMonitor, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SoundLevelChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_SoundLevel(&self, out: *mut super::SoundLevel) -> HRESULT
}}
impl IAudioStateMonitor {
    #[inline] pub fn add_sound_level_changed(&self, handler: &foundation::TypedEventHandler<AudioStateMonitor, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SoundLevelChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_sound_level_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SoundLevelChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sound_level(&self) -> Result<super::SoundLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SoundLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioStateMonitor: IAudioStateMonitor}
impl RtActivatable<IAudioStateMonitorStatics> for AudioStateMonitor {}
impl AudioStateMonitor {
    #[inline] pub fn create_for_render_monitoring() -> Result<Option<AudioStateMonitor>> {
        <Self as RtActivatable<IAudioStateMonitorStatics>>::get_activation_factory().create_for_render_monitoring()
    }
    #[inline] pub fn create_for_render_monitoring_with_category(category: super::render::AudioRenderCategory) -> Result<Option<AudioStateMonitor>> {
        <Self as RtActivatable<IAudioStateMonitorStatics>>::get_activation_factory().create_for_render_monitoring_with_category(category)
    }
    #[inline] pub fn create_for_render_monitoring_with_category_and_device_role(category: super::render::AudioRenderCategory, role: super::devices::AudioDeviceRole) -> Result<Option<AudioStateMonitor>> {
        <Self as RtActivatable<IAudioStateMonitorStatics>>::get_activation_factory().create_for_render_monitoring_with_category_and_device_role(category, role)
    }
    #[inline] pub fn create_for_render_monitoring_with_category_and_device_id(category: super::render::AudioRenderCategory, deviceId: &HStringArg) -> Result<Option<AudioStateMonitor>> {
        <Self as RtActivatable<IAudioStateMonitorStatics>>::get_activation_factory().create_for_render_monitoring_with_category_and_device_id(category, deviceId)
    }
    #[inline] pub fn create_for_capture_monitoring() -> Result<Option<AudioStateMonitor>> {
        <Self as RtActivatable<IAudioStateMonitorStatics>>::get_activation_factory().create_for_capture_monitoring()
    }
    #[inline] pub fn create_for_capture_monitoring_with_category(category: super::capture::MediaCategory) -> Result<Option<AudioStateMonitor>> {
        <Self as RtActivatable<IAudioStateMonitorStatics>>::get_activation_factory().create_for_capture_monitoring_with_category(category)
    }
    #[inline] pub fn create_for_capture_monitoring_with_category_and_device_role(category: super::capture::MediaCategory, role: super::devices::AudioDeviceRole) -> Result<Option<AudioStateMonitor>> {
        <Self as RtActivatable<IAudioStateMonitorStatics>>::get_activation_factory().create_for_capture_monitoring_with_category_and_device_role(category, role)
    }
    #[inline] pub fn create_for_capture_monitoring_with_category_and_device_id(category: super::capture::MediaCategory, deviceId: &HStringArg) -> Result<Option<AudioStateMonitor>> {
        <Self as RtActivatable<IAudioStateMonitorStatics>>::get_activation_factory().create_for_capture_monitoring_with_category_and_device_id(category, deviceId)
    }
}
DEFINE_CLSID!(AudioStateMonitor(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,65,117,100,105,111,46,65,117,100,105,111,83,116,97,116,101,77,111,110,105,116,111,114,0]) [CLSID_AudioStateMonitor]);
DEFINE_IID!(IID_IAudioStateMonitorStatics, 1668606540, 6971, 16385, 148, 217, 221, 34, 83, 48, 250, 64);
RT_INTERFACE!{static interface IAudioStateMonitorStatics(IAudioStateMonitorStaticsVtbl, IAudioStateMonitorStatics_Abi): IInspectable(IInspectableVtbl) [IID_IAudioStateMonitorStatics] {
    fn CreateForRenderMonitoring(&self, out: *mut <AudioStateMonitor as RtType>::Abi) -> HRESULT,
    fn CreateForRenderMonitoringWithCategory(&self, category: super::render::AudioRenderCategory, out: *mut <AudioStateMonitor as RtType>::Abi) -> HRESULT,
    fn CreateForRenderMonitoringWithCategoryAndDeviceRole(&self, category: super::render::AudioRenderCategory, role: super::devices::AudioDeviceRole, out: *mut <AudioStateMonitor as RtType>::Abi) -> HRESULT,
    fn CreateForRenderMonitoringWithCategoryAndDeviceId(&self, category: super::render::AudioRenderCategory, deviceId: HSTRING, out: *mut <AudioStateMonitor as RtType>::Abi) -> HRESULT,
    fn CreateForCaptureMonitoring(&self, out: *mut <AudioStateMonitor as RtType>::Abi) -> HRESULT,
    fn CreateForCaptureMonitoringWithCategory(&self, category: super::capture::MediaCategory, out: *mut <AudioStateMonitor as RtType>::Abi) -> HRESULT,
    fn CreateForCaptureMonitoringWithCategoryAndDeviceRole(&self, category: super::capture::MediaCategory, role: super::devices::AudioDeviceRole, out: *mut <AudioStateMonitor as RtType>::Abi) -> HRESULT,
    fn CreateForCaptureMonitoringWithCategoryAndDeviceId(&self, category: super::capture::MediaCategory, deviceId: HSTRING, out: *mut <AudioStateMonitor as RtType>::Abi) -> HRESULT
}}
impl IAudioStateMonitorStatics {
    #[inline] pub fn create_for_render_monitoring(&self) -> Result<Option<AudioStateMonitor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateForRenderMonitoring)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioStateMonitor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_for_render_monitoring_with_category(&self, category: super::render::AudioRenderCategory) -> Result<Option<AudioStateMonitor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateForRenderMonitoringWithCategory)(self.0.as_abi() as *const _ as *mut _, category, &mut out);
        if hr == S_OK { Ok(AudioStateMonitor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_for_render_monitoring_with_category_and_device_role(&self, category: super::render::AudioRenderCategory, role: super::devices::AudioDeviceRole) -> Result<Option<AudioStateMonitor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateForRenderMonitoringWithCategoryAndDeviceRole)(self.0.as_abi() as *const _ as *mut _, category, role, &mut out);
        if hr == S_OK { Ok(AudioStateMonitor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_for_render_monitoring_with_category_and_device_id(&self, category: super::render::AudioRenderCategory, deviceId: &HStringArg) -> Result<Option<AudioStateMonitor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateForRenderMonitoringWithCategoryAndDeviceId)(self.0.as_abi() as *const _ as *mut _, category, deviceId.get(), &mut out);
        if hr == S_OK { Ok(AudioStateMonitor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_for_capture_monitoring(&self) -> Result<Option<AudioStateMonitor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateForCaptureMonitoring)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioStateMonitor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_for_capture_monitoring_with_category(&self, category: super::capture::MediaCategory) -> Result<Option<AudioStateMonitor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateForCaptureMonitoringWithCategory)(self.0.as_abi() as *const _ as *mut _, category, &mut out);
        if hr == S_OK { Ok(AudioStateMonitor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_for_capture_monitoring_with_category_and_device_role(&self, category: super::capture::MediaCategory, role: super::devices::AudioDeviceRole) -> Result<Option<AudioStateMonitor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateForCaptureMonitoringWithCategoryAndDeviceRole)(self.0.as_abi() as *const _ as *mut _, category, role, &mut out);
        if hr == S_OK { Ok(AudioStateMonitor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_for_capture_monitoring_with_category_and_device_id(&self, category: super::capture::MediaCategory, deviceId: &HStringArg) -> Result<Option<AudioStateMonitor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateForCaptureMonitoringWithCategoryAndDeviceId)(self.0.as_abi() as *const _ as *mut _, category, deviceId.get(), &mut out);
        if hr == S_OK { Ok(AudioStateMonitor::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioSubmixNode: IAudioInputNode}
DEFINE_IID!(IID_ICreateAudioDeviceInputNodeResult, 384747432, 7335, 16623, 145, 164, 211, 70, 224, 170, 27, 186);
RT_INTERFACE!{interface ICreateAudioDeviceInputNodeResult(ICreateAudioDeviceInputNodeResultVtbl, ICreateAudioDeviceInputNodeResult_Abi): IInspectable(IInspectableVtbl) [IID_ICreateAudioDeviceInputNodeResult] {
    fn get_Status(&self, out: *mut AudioDeviceNodeCreationStatus) -> HRESULT,
    fn get_DeviceInputNode(&self, out: *mut <AudioDeviceInputNode as RtType>::Abi) -> HRESULT
}}
impl ICreateAudioDeviceInputNodeResult {
    #[inline] pub fn get_status(&self) -> Result<AudioDeviceNodeCreationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_device_input_node(&self) -> Result<Option<AudioDeviceInputNode>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceInputNode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioDeviceInputNode::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CreateAudioDeviceInputNodeResult: ICreateAudioDeviceInputNodeResult}
DEFINE_IID!(IID_ICreateAudioDeviceInputNodeResult2, 2451335630, 16181, 16839, 150, 34, 121, 246, 8, 186, 237, 194);
RT_INTERFACE!{interface ICreateAudioDeviceInputNodeResult2(ICreateAudioDeviceInputNodeResult2Vtbl, ICreateAudioDeviceInputNodeResult2_Abi): IInspectable(IInspectableVtbl) [IID_ICreateAudioDeviceInputNodeResult2] {
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl ICreateAudioDeviceInputNodeResult2 {
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICreateAudioDeviceOutputNodeResult, 4151799079, 7578, 18423, 156, 212, 40, 89, 204, 27, 123, 255);
RT_INTERFACE!{interface ICreateAudioDeviceOutputNodeResult(ICreateAudioDeviceOutputNodeResultVtbl, ICreateAudioDeviceOutputNodeResult_Abi): IInspectable(IInspectableVtbl) [IID_ICreateAudioDeviceOutputNodeResult] {
    fn get_Status(&self, out: *mut AudioDeviceNodeCreationStatus) -> HRESULT,
    fn get_DeviceOutputNode(&self, out: *mut <AudioDeviceOutputNode as RtType>::Abi) -> HRESULT
}}
impl ICreateAudioDeviceOutputNodeResult {
    #[inline] pub fn get_status(&self) -> Result<AudioDeviceNodeCreationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_device_output_node(&self) -> Result<Option<AudioDeviceOutputNode>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceOutputNode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioDeviceOutputNode::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CreateAudioDeviceOutputNodeResult: ICreateAudioDeviceOutputNodeResult}
DEFINE_IID!(IID_ICreateAudioDeviceOutputNodeResult2, 1214523039, 48590, 19121, 189, 56, 251, 174, 147, 174, 218, 202);
RT_INTERFACE!{interface ICreateAudioDeviceOutputNodeResult2(ICreateAudioDeviceOutputNodeResult2Vtbl, ICreateAudioDeviceOutputNodeResult2_Abi): IInspectable(IInspectableVtbl) [IID_ICreateAudioDeviceOutputNodeResult2] {
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl ICreateAudioDeviceOutputNodeResult2 {
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICreateAudioFileInputNodeResult, 3464746524, 58007, 19536, 156, 231, 28, 122, 105, 214, 189, 9);
RT_INTERFACE!{interface ICreateAudioFileInputNodeResult(ICreateAudioFileInputNodeResultVtbl, ICreateAudioFileInputNodeResult_Abi): IInspectable(IInspectableVtbl) [IID_ICreateAudioFileInputNodeResult] {
    fn get_Status(&self, out: *mut AudioFileNodeCreationStatus) -> HRESULT,
    fn get_FileInputNode(&self, out: *mut <AudioFileInputNode as RtType>::Abi) -> HRESULT
}}
impl ICreateAudioFileInputNodeResult {
    #[inline] pub fn get_status(&self) -> Result<AudioFileNodeCreationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_file_input_node(&self) -> Result<Option<AudioFileInputNode>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FileInputNode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioFileInputNode::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CreateAudioFileInputNodeResult: ICreateAudioFileInputNodeResult}
DEFINE_IID!(IID_ICreateAudioFileInputNodeResult2, 4178059296, 15744, 20448, 129, 193, 118, 143, 234, 124, 167, 224);
RT_INTERFACE!{interface ICreateAudioFileInputNodeResult2(ICreateAudioFileInputNodeResult2Vtbl, ICreateAudioFileInputNodeResult2_Abi): IInspectable(IInspectableVtbl) [IID_ICreateAudioFileInputNodeResult2] {
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl ICreateAudioFileInputNodeResult2 {
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICreateAudioFileOutputNodeResult, 1205254779, 59657, 17727, 134, 110, 85, 64, 205, 167, 52, 255);
RT_INTERFACE!{interface ICreateAudioFileOutputNodeResult(ICreateAudioFileOutputNodeResultVtbl, ICreateAudioFileOutputNodeResult_Abi): IInspectable(IInspectableVtbl) [IID_ICreateAudioFileOutputNodeResult] {
    fn get_Status(&self, out: *mut AudioFileNodeCreationStatus) -> HRESULT,
    fn get_FileOutputNode(&self, out: *mut <AudioFileOutputNode as RtType>::Abi) -> HRESULT
}}
impl ICreateAudioFileOutputNodeResult {
    #[inline] pub fn get_status(&self) -> Result<AudioFileNodeCreationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_file_output_node(&self) -> Result<Option<AudioFileOutputNode>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FileOutputNode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioFileOutputNode::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CreateAudioFileOutputNodeResult: ICreateAudioFileOutputNodeResult}
DEFINE_IID!(IID_ICreateAudioFileOutputNodeResult2, 2667689229, 13080, 18355, 166, 10, 27, 73, 43, 231, 252, 13);
RT_INTERFACE!{interface ICreateAudioFileOutputNodeResult2(ICreateAudioFileOutputNodeResult2Vtbl, ICreateAudioFileOutputNodeResult2_Abi): IInspectable(IInspectableVtbl) [IID_ICreateAudioFileOutputNodeResult2] {
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl ICreateAudioFileOutputNodeResult2 {
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICreateAudioGraphResult, 1414786942, 31710, 19318, 187, 93, 72, 247, 156, 252, 140, 11);
RT_INTERFACE!{interface ICreateAudioGraphResult(ICreateAudioGraphResultVtbl, ICreateAudioGraphResult_Abi): IInspectable(IInspectableVtbl) [IID_ICreateAudioGraphResult] {
    fn get_Status(&self, out: *mut AudioGraphCreationStatus) -> HRESULT,
    fn get_Graph(&self, out: *mut <AudioGraph as RtType>::Abi) -> HRESULT
}}
impl ICreateAudioGraphResult {
    #[inline] pub fn get_status(&self) -> Result<AudioGraphCreationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_graph(&self) -> Result<Option<AudioGraph>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Graph)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioGraph::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CreateAudioGraphResult: ICreateAudioGraphResult}
DEFINE_IID!(IID_ICreateAudioGraphResult2, 1836289532, 35014, 20427, 165, 52, 133, 206, 221, 64, 80, 161);
RT_INTERFACE!{interface ICreateAudioGraphResult2(ICreateAudioGraphResult2Vtbl, ICreateAudioGraphResult2_Abi): IInspectable(IInspectableVtbl) [IID_ICreateAudioGraphResult2] {
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl ICreateAudioGraphResult2 {
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICreateMediaSourceAudioInputNodeResult, 1185306787, 21440, 19801, 158, 81, 204, 29, 16, 68, 164, 196);
RT_INTERFACE!{interface ICreateMediaSourceAudioInputNodeResult(ICreateMediaSourceAudioInputNodeResultVtbl, ICreateMediaSourceAudioInputNodeResult_Abi): IInspectable(IInspectableVtbl) [IID_ICreateMediaSourceAudioInputNodeResult] {
    fn get_Status(&self, out: *mut MediaSourceAudioInputNodeCreationStatus) -> HRESULT,
    fn get_Node(&self, out: *mut <MediaSourceAudioInputNode as RtType>::Abi) -> HRESULT
}}
impl ICreateMediaSourceAudioInputNodeResult {
    #[inline] pub fn get_status(&self) -> Result<MediaSourceAudioInputNodeCreationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_node(&self) -> Result<Option<MediaSourceAudioInputNode>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Node)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaSourceAudioInputNode::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CreateMediaSourceAudioInputNodeResult: ICreateMediaSourceAudioInputNodeResult}
DEFINE_IID!(IID_ICreateMediaSourceAudioInputNodeResult2, 1666272488, 27162, 18915, 151, 236, 40, 253, 91, 225, 20, 229);
RT_INTERFACE!{interface ICreateMediaSourceAudioInputNodeResult2(ICreateMediaSourceAudioInputNodeResult2Vtbl, ICreateMediaSourceAudioInputNodeResult2_Abi): IInspectable(IInspectableVtbl) [IID_ICreateMediaSourceAudioInputNodeResult2] {
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl ICreateMediaSourceAudioInputNodeResult2 {
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IEchoEffectDefinition, 239943594, 14008, 19601, 185, 218, 17, 244, 74, 138, 102, 16);
RT_INTERFACE!{interface IEchoEffectDefinition(IEchoEffectDefinitionVtbl, IEchoEffectDefinition_Abi): IInspectable(IInspectableVtbl) [IID_IEchoEffectDefinition] {
    fn put_WetDryMix(&self, value: f64) -> HRESULT,
    fn get_WetDryMix(&self, out: *mut f64) -> HRESULT,
    fn put_Feedback(&self, value: f64) -> HRESULT,
    fn get_Feedback(&self, out: *mut f64) -> HRESULT,
    fn put_Delay(&self, value: f64) -> HRESULT,
    fn get_Delay(&self, out: *mut f64) -> HRESULT
}}
impl IEchoEffectDefinition {
    #[inline] pub fn set_wet_dry_mix(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_WetDryMix)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_wet_dry_mix(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_WetDryMix)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_feedback(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Feedback)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_feedback(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Feedback)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_delay(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Delay)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_delay(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Delay)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class EchoEffectDefinition: IEchoEffectDefinition}
impl RtActivatable<IEchoEffectDefinitionFactory> for EchoEffectDefinition {}
impl EchoEffectDefinition {
    #[inline] pub fn create(audioGraph: &AudioGraph) -> Result<EchoEffectDefinition> {
        <Self as RtActivatable<IEchoEffectDefinitionFactory>>::get_activation_factory().create(audioGraph)
    }
}
DEFINE_CLSID!(EchoEffectDefinition(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,65,117,100,105,111,46,69,99,104,111,69,102,102,101,99,116,68,101,102,105,110,105,116,105,111,110,0]) [CLSID_EchoEffectDefinition]);
DEFINE_IID!(IID_IEchoEffectDefinitionFactory, 223224407, 43762, 20102, 165, 76, 251, 121, 219, 143, 108, 18);
RT_INTERFACE!{static interface IEchoEffectDefinitionFactory(IEchoEffectDefinitionFactoryVtbl, IEchoEffectDefinitionFactory_Abi): IInspectable(IInspectableVtbl) [IID_IEchoEffectDefinitionFactory] {
    fn Create(&self, audioGraph: <AudioGraph as RtType>::Abi, out: *mut <EchoEffectDefinition as RtType>::Abi) -> HRESULT
}}
impl IEchoEffectDefinitionFactory {
    #[inline] pub fn create(&self, audioGraph: &AudioGraph) -> Result<EchoEffectDefinition> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(audioGraph) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EchoEffectDefinition::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IEqualizerBand, 3221903978, 9773, 19333, 155, 183, 67, 40, 11, 98, 237, 12);
RT_INTERFACE!{interface IEqualizerBand(IEqualizerBandVtbl, IEqualizerBand_Abi): IInspectable(IInspectableVtbl) [IID_IEqualizerBand] {
    fn get_Bandwidth(&self, out: *mut f64) -> HRESULT,
    fn put_Bandwidth(&self, value: f64) -> HRESULT,
    fn get_FrequencyCenter(&self, out: *mut f64) -> HRESULT,
    fn put_FrequencyCenter(&self, value: f64) -> HRESULT,
    fn get_Gain(&self, out: *mut f64) -> HRESULT,
    fn put_Gain(&self, value: f64) -> HRESULT
}}
impl IEqualizerBand {
    #[inline] pub fn get_bandwidth(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Bandwidth)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_bandwidth(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Bandwidth)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_frequency_center(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrequencyCenter)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_frequency_center(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_FrequencyCenter)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_gain(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Gain)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_gain(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Gain)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class EqualizerBand: IEqualizerBand}
DEFINE_IID!(IID_IEqualizerEffectDefinition, 37711647, 33790, 17562, 168, 34, 198, 150, 68, 45, 22, 176);
RT_INTERFACE!{interface IEqualizerEffectDefinition(IEqualizerEffectDefinitionVtbl, IEqualizerEffectDefinition_Abi): IInspectable(IInspectableVtbl) [IID_IEqualizerEffectDefinition] {
    fn get_Bands(&self, out: *mut <foundation::collections::IVectorView<EqualizerBand> as RtType>::Abi) -> HRESULT
}}
impl IEqualizerEffectDefinition {
    #[inline] pub fn get_bands(&self) -> Result<Option<foundation::collections::IVectorView<EqualizerBand>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Bands)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EqualizerEffectDefinition: IEqualizerEffectDefinition}
impl RtActivatable<IEqualizerEffectDefinitionFactory> for EqualizerEffectDefinition {}
impl EqualizerEffectDefinition {
    #[inline] pub fn create(audioGraph: &AudioGraph) -> Result<EqualizerEffectDefinition> {
        <Self as RtActivatable<IEqualizerEffectDefinitionFactory>>::get_activation_factory().create(audioGraph)
    }
}
DEFINE_CLSID!(EqualizerEffectDefinition(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,65,117,100,105,111,46,69,113,117,97,108,105,122,101,114,69,102,102,101,99,116,68,101,102,105,110,105,116,105,111,110,0]) [CLSID_EqualizerEffectDefinition]);
DEFINE_IID!(IID_IEqualizerEffectDefinitionFactory, 3532091332, 54288, 20149, 158, 105, 201, 170, 18, 119, 234, 240);
RT_INTERFACE!{static interface IEqualizerEffectDefinitionFactory(IEqualizerEffectDefinitionFactoryVtbl, IEqualizerEffectDefinitionFactory_Abi): IInspectable(IInspectableVtbl) [IID_IEqualizerEffectDefinitionFactory] {
    fn Create(&self, audioGraph: <AudioGraph as RtType>::Abi, out: *mut <EqualizerEffectDefinition as RtType>::Abi) -> HRESULT
}}
impl IEqualizerEffectDefinitionFactory {
    #[inline] pub fn create(&self, audioGraph: &AudioGraph) -> Result<EqualizerEffectDefinition> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(audioGraph) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EqualizerEffectDefinition::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IFrameInputNodeQuantumStartedEventArgs, 1033622680, 41734, 20230, 189, 159, 233, 239, 200, 34, 99, 4);
RT_INTERFACE!{interface IFrameInputNodeQuantumStartedEventArgs(IFrameInputNodeQuantumStartedEventArgsVtbl, IFrameInputNodeQuantumStartedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IFrameInputNodeQuantumStartedEventArgs] {
    fn get_RequiredSamples(&self, out: *mut i32) -> HRESULT
}}
impl IFrameInputNodeQuantumStartedEventArgs {
    #[inline] pub fn get_required_samples(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RequiredSamples)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class FrameInputNodeQuantumStartedEventArgs: IFrameInputNodeQuantumStartedEventArgs}
DEFINE_IID!(IID_ILimiterEffectDefinition, 1802853657, 9731, 18362, 189, 235, 57, 5, 94, 52, 134, 220);
RT_INTERFACE!{interface ILimiterEffectDefinition(ILimiterEffectDefinitionVtbl, ILimiterEffectDefinition_Abi): IInspectable(IInspectableVtbl) [IID_ILimiterEffectDefinition] {
    fn put_Release(&self, value: u32) -> HRESULT,
    fn get_Release(&self, out: *mut u32) -> HRESULT,
    fn put_Loudness(&self, value: u32) -> HRESULT,
    fn get_Loudness(&self, out: *mut u32) -> HRESULT
}}
impl ILimiterEffectDefinition {
    #[inline] pub fn set_release(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Release)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_release(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Release)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_loudness(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Loudness)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_loudness(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Loudness)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class LimiterEffectDefinition: ILimiterEffectDefinition}
impl RtActivatable<ILimiterEffectDefinitionFactory> for LimiterEffectDefinition {}
impl LimiterEffectDefinition {
    #[inline] pub fn create(audioGraph: &AudioGraph) -> Result<LimiterEffectDefinition> {
        <Self as RtActivatable<ILimiterEffectDefinitionFactory>>::get_activation_factory().create(audioGraph)
    }
}
DEFINE_CLSID!(LimiterEffectDefinition(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,65,117,100,105,111,46,76,105,109,105,116,101,114,69,102,102,101,99,116,68,101,102,105,110,105,116,105,111,110,0]) [CLSID_LimiterEffectDefinition]);
DEFINE_IID!(IID_ILimiterEffectDefinitionFactory, 3971671793, 25087, 17903, 184, 245, 72, 101, 154, 87, 199, 45);
RT_INTERFACE!{static interface ILimiterEffectDefinitionFactory(ILimiterEffectDefinitionFactoryVtbl, ILimiterEffectDefinitionFactory_Abi): IInspectable(IInspectableVtbl) [IID_ILimiterEffectDefinitionFactory] {
    fn Create(&self, audioGraph: <AudioGraph as RtType>::Abi, out: *mut <LimiterEffectDefinition as RtType>::Abi) -> HRESULT
}}
impl ILimiterEffectDefinitionFactory {
    #[inline] pub fn create(&self, audioGraph: &AudioGraph) -> Result<LimiterEffectDefinition> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(audioGraph) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(LimiterEffectDefinition::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaSourceAudioInputNode, 2581108795, 43146, 16449, 142, 79, 221, 186, 192, 201, 31, 211);
RT_INTERFACE!{interface IMediaSourceAudioInputNode(IMediaSourceAudioInputNodeVtbl, IMediaSourceAudioInputNode_Abi): IInspectable(IInspectableVtbl) [IID_IMediaSourceAudioInputNode] {
    fn put_PlaybackSpeedFactor(&self, value: f64) -> HRESULT,
    fn get_PlaybackSpeedFactor(&self, out: *mut f64) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn Seek(&self, position: foundation::TimeSpan) -> HRESULT,
    fn get_StartTime(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn put_StartTime(&self, value: <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_EndTime(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn put_EndTime(&self, value: <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_LoopCount(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_LoopCount(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_MediaSource(&self, out: *mut <super::core::MediaSource as RtType>::Abi) -> HRESULT,
    fn add_MediaSourceCompleted(&self, handler: <foundation::TypedEventHandler<MediaSourceAudioInputNode, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MediaSourceCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IMediaSourceAudioInputNode {
    #[inline] pub fn set_playback_speed_factor(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PlaybackSpeedFactor)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_playback_speed_factor(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackSpeedFactor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn seek(&self, position: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Seek)(self.0.as_abi() as *const _ as *mut _, position);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_start_time(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_StartTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_start_time(&self, value: &foundation::IReference<foundation::TimeSpan>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_StartTime)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_end_time(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EndTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_end_time(&self, value: &foundation::IReference<foundation::TimeSpan>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_EndTime)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_loop_count(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_LoopCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_loop_count(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_LoopCount)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_media_source(&self) -> Result<Option<super::core::MediaSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::core::MediaSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_media_source_completed(&self, handler: &foundation::TypedEventHandler<MediaSourceAudioInputNode, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_MediaSourceCompleted)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_media_source_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_MediaSourceCompleted)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaSourceAudioInputNode: IMediaSourceAudioInputNode}
RT_ENUM! { enum MediaSourceAudioInputNodeCreationStatus: i32 {
    Success = 0, FormatNotSupported = 1, NetworkError = 2, UnknownFailure = 3,
}}
RT_ENUM! { enum MixedRealitySpatialAudioFormatPolicy: i32 {
    UseMixedRealityDefaultSpatialAudioFormat = 0, UseDeviceConfigurationDefaultSpatialAudioFormat = 1,
}}
RT_ENUM! { enum QuantumSizeSelectionMode: i32 {
    SystemDefault = 0, LowestLatency = 1, ClosestToDesired = 2,
}}
DEFINE_IID!(IID_IReverbEffectDefinition, 1174841993, 62819, 19722, 143, 110, 240, 205, 223, 243, 93, 132);
RT_INTERFACE!{interface IReverbEffectDefinition(IReverbEffectDefinitionVtbl, IReverbEffectDefinition_Abi): IInspectable(IInspectableVtbl) [IID_IReverbEffectDefinition] {
    fn put_WetDryMix(&self, value: f64) -> HRESULT,
    fn get_WetDryMix(&self, out: *mut f64) -> HRESULT,
    fn put_ReflectionsDelay(&self, value: u32) -> HRESULT,
    fn get_ReflectionsDelay(&self, out: *mut u32) -> HRESULT,
    fn put_ReverbDelay(&self, value: u8) -> HRESULT,
    fn get_ReverbDelay(&self, out: *mut u8) -> HRESULT,
    fn put_RearDelay(&self, value: u8) -> HRESULT,
    fn get_RearDelay(&self, out: *mut u8) -> HRESULT,
    fn put_PositionLeft(&self, value: u8) -> HRESULT,
    fn get_PositionLeft(&self, out: *mut u8) -> HRESULT,
    fn put_PositionRight(&self, value: u8) -> HRESULT,
    fn get_PositionRight(&self, out: *mut u8) -> HRESULT,
    fn put_PositionMatrixLeft(&self, value: u8) -> HRESULT,
    fn get_PositionMatrixLeft(&self, out: *mut u8) -> HRESULT,
    fn put_PositionMatrixRight(&self, value: u8) -> HRESULT,
    fn get_PositionMatrixRight(&self, out: *mut u8) -> HRESULT,
    fn put_EarlyDiffusion(&self, value: u8) -> HRESULT,
    fn get_EarlyDiffusion(&self, out: *mut u8) -> HRESULT,
    fn put_LateDiffusion(&self, value: u8) -> HRESULT,
    fn get_LateDiffusion(&self, out: *mut u8) -> HRESULT,
    fn put_LowEQGain(&self, value: u8) -> HRESULT,
    fn get_LowEQGain(&self, out: *mut u8) -> HRESULT,
    fn put_LowEQCutoff(&self, value: u8) -> HRESULT,
    fn get_LowEQCutoff(&self, out: *mut u8) -> HRESULT,
    fn put_HighEQGain(&self, value: u8) -> HRESULT,
    fn get_HighEQGain(&self, out: *mut u8) -> HRESULT,
    fn put_HighEQCutoff(&self, value: u8) -> HRESULT,
    fn get_HighEQCutoff(&self, out: *mut u8) -> HRESULT,
    fn put_RoomFilterFreq(&self, value: f64) -> HRESULT,
    fn get_RoomFilterFreq(&self, out: *mut f64) -> HRESULT,
    fn put_RoomFilterMain(&self, value: f64) -> HRESULT,
    fn get_RoomFilterMain(&self, out: *mut f64) -> HRESULT,
    fn put_RoomFilterHF(&self, value: f64) -> HRESULT,
    fn get_RoomFilterHF(&self, out: *mut f64) -> HRESULT,
    fn put_ReflectionsGain(&self, value: f64) -> HRESULT,
    fn get_ReflectionsGain(&self, out: *mut f64) -> HRESULT,
    fn put_ReverbGain(&self, value: f64) -> HRESULT,
    fn get_ReverbGain(&self, out: *mut f64) -> HRESULT,
    fn put_DecayTime(&self, value: f64) -> HRESULT,
    fn get_DecayTime(&self, out: *mut f64) -> HRESULT,
    fn put_Density(&self, value: f64) -> HRESULT,
    fn get_Density(&self, out: *mut f64) -> HRESULT,
    fn put_RoomSize(&self, value: f64) -> HRESULT,
    fn get_RoomSize(&self, out: *mut f64) -> HRESULT,
    fn put_DisableLateField(&self, value: bool) -> HRESULT,
    fn get_DisableLateField(&self, out: *mut bool) -> HRESULT
}}
impl IReverbEffectDefinition {
    #[inline] pub fn set_wet_dry_mix(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_WetDryMix)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_wet_dry_mix(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_WetDryMix)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_reflections_delay(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReflectionsDelay)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_reflections_delay(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReflectionsDelay)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_reverb_delay(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReverbDelay)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_reverb_delay(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReverbDelay)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_rear_delay(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_RearDelay)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_rear_delay(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RearDelay)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_position_left(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PositionLeft)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_position_left(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PositionLeft)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_position_right(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PositionRight)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_position_right(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PositionRight)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_position_matrix_left(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PositionMatrixLeft)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_position_matrix_left(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PositionMatrixLeft)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_position_matrix_right(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PositionMatrixRight)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_position_matrix_right(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PositionMatrixRight)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_early_diffusion(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_EarlyDiffusion)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_early_diffusion(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_EarlyDiffusion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_late_diffusion(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_LateDiffusion)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_late_diffusion(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LateDiffusion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_low_eq_gain(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_LowEQGain)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_low_eq_gain(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LowEQGain)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_low_eq_cutoff(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_LowEQCutoff)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_low_eq_cutoff(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LowEQCutoff)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_high_eq_gain(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_HighEQGain)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_high_eq_gain(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HighEQGain)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_high_eq_cutoff(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_HighEQCutoff)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_high_eq_cutoff(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HighEQCutoff)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_room_filter_freq(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_RoomFilterFreq)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_room_filter_freq(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RoomFilterFreq)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_room_filter_main(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_RoomFilterMain)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_room_filter_main(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RoomFilterMain)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_room_filter_hf(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_RoomFilterHF)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_room_filter_hf(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RoomFilterHF)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_reflections_gain(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReflectionsGain)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_reflections_gain(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReflectionsGain)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_reverb_gain(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReverbGain)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_reverb_gain(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReverbGain)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_decay_time(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DecayTime)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_decay_time(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DecayTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_density(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Density)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_density(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Density)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_room_size(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_RoomSize)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_room_size(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RoomSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_disable_late_field(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DisableLateField)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_disable_late_field(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DisableLateField)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ReverbEffectDefinition: IReverbEffectDefinition}
impl RtActivatable<IReverbEffectDefinitionFactory> for ReverbEffectDefinition {}
impl ReverbEffectDefinition {
    #[inline] pub fn create(audioGraph: &AudioGraph) -> Result<ReverbEffectDefinition> {
        <Self as RtActivatable<IReverbEffectDefinitionFactory>>::get_activation_factory().create(audioGraph)
    }
}
DEFINE_CLSID!(ReverbEffectDefinition(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,65,117,100,105,111,46,82,101,118,101,114,98,69,102,102,101,99,116,68,101,102,105,110,105,116,105,111,110,0]) [CLSID_ReverbEffectDefinition]);
DEFINE_IID!(IID_IReverbEffectDefinitionFactory, 2815806462, 4107, 20464, 157, 166, 220, 78, 5, 167, 89, 240);
RT_INTERFACE!{static interface IReverbEffectDefinitionFactory(IReverbEffectDefinitionFactoryVtbl, IReverbEffectDefinitionFactory_Abi): IInspectable(IInspectableVtbl) [IID_IReverbEffectDefinitionFactory] {
    fn Create(&self, audioGraph: <AudioGraph as RtType>::Abi, out: *mut <ReverbEffectDefinition as RtType>::Abi) -> HRESULT
}}
impl IReverbEffectDefinitionFactory {
    #[inline] pub fn create(&self, audioGraph: &AudioGraph) -> Result<ReverbEffectDefinition> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(audioGraph) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ReverbEffectDefinition::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISetDefaultSpatialAudioFormatResult, 472556817, 5120, 24176, 158, 169, 174, 21, 18, 65, 232, 234);
RT_INTERFACE!{interface ISetDefaultSpatialAudioFormatResult(ISetDefaultSpatialAudioFormatResultVtbl, ISetDefaultSpatialAudioFormatResult_Abi): IInspectable(IInspectableVtbl) [IID_ISetDefaultSpatialAudioFormatResult] {
    fn get_Status(&self, out: *mut SetDefaultSpatialAudioFormatStatus) -> HRESULT
}}
impl ISetDefaultSpatialAudioFormatResult {
    #[inline] pub fn get_status(&self) -> Result<SetDefaultSpatialAudioFormatStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SetDefaultSpatialAudioFormatResult: ISetDefaultSpatialAudioFormatResult}
RT_ENUM! { enum SetDefaultSpatialAudioFormatStatus: i32 {
    Succeeded = 0, AccessDenied = 1, LicenseExpired = 2, LicenseNotValidForAudioEndpoint = 3, NotSupportedOnAudioEndpoint = 4, UnknownError = 5,
}}
DEFINE_IID!(IID_ISpatialAudioDeviceConfiguration, 4001562676, 25039, 22345, 157, 164, 16, 240, 254, 2, 129, 153);
RT_INTERFACE!{interface ISpatialAudioDeviceConfiguration(ISpatialAudioDeviceConfigurationVtbl, ISpatialAudioDeviceConfiguration_Abi): IInspectable(IInspectableVtbl) [IID_ISpatialAudioDeviceConfiguration] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsSpatialAudioSupported(&self, out: *mut bool) -> HRESULT,
    fn IsSpatialAudioFormatSupported(&self, subtype: HSTRING, out: *mut bool) -> HRESULT,
    fn get_ActiveSpatialAudioFormat(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DefaultSpatialAudioFormat(&self, out: *mut HSTRING) -> HRESULT,
    fn SetDefaultSpatialAudioFormatAsync(&self, subtype: HSTRING, out: *mut <foundation::IAsyncOperation<SetDefaultSpatialAudioFormatResult> as RtType>::Abi) -> HRESULT,
    fn add_ConfigurationChanged(&self, handler: <foundation::TypedEventHandler<SpatialAudioDeviceConfiguration, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ConfigurationChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ISpatialAudioDeviceConfiguration {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_spatial_audio_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsSpatialAudioSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_spatial_audio_format_supported(&self, subtype: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsSpatialAudioFormatSupported)(self.0.as_abi() as *const _ as *mut _, subtype.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_active_spatial_audio_format(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ActiveSpatialAudioFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_spatial_audio_format(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DefaultSpatialAudioFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_default_spatial_audio_format_async(&self, subtype: &HStringArg) -> Result<foundation::IAsyncOperation<SetDefaultSpatialAudioFormatResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetDefaultSpatialAudioFormatAsync)(self.0.as_abi() as *const _ as *mut _, subtype.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_configuration_changed(&self, handler: &foundation::TypedEventHandler<SpatialAudioDeviceConfiguration, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ConfigurationChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_configuration_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ConfigurationChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialAudioDeviceConfiguration: ISpatialAudioDeviceConfiguration}
impl RtActivatable<ISpatialAudioDeviceConfigurationStatics> for SpatialAudioDeviceConfiguration {}
impl SpatialAudioDeviceConfiguration {
    #[inline] pub fn get_for_device_id(deviceId: &HStringArg) -> Result<Option<SpatialAudioDeviceConfiguration>> {
        <Self as RtActivatable<ISpatialAudioDeviceConfigurationStatics>>::get_activation_factory().get_for_device_id(deviceId)
    }
}
DEFINE_CLSID!(SpatialAudioDeviceConfiguration(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,65,117,100,105,111,46,83,112,97,116,105,97,108,65,117,100,105,111,68,101,118,105,99,101,67,111,110,102,105,103,117,114,97,116,105,111,110,0]) [CLSID_SpatialAudioDeviceConfiguration]);
DEFINE_IID!(IID_ISpatialAudioDeviceConfigurationStatics, 1052999547, 37741, 19972, 151, 40, 40, 39, 217, 247, 88, 196);
RT_INTERFACE!{static interface ISpatialAudioDeviceConfigurationStatics(ISpatialAudioDeviceConfigurationStaticsVtbl, ISpatialAudioDeviceConfigurationStatics_Abi): IInspectable(IInspectableVtbl) [IID_ISpatialAudioDeviceConfigurationStatics] {
    fn GetForDeviceId(&self, deviceId: HSTRING, out: *mut <SpatialAudioDeviceConfiguration as RtType>::Abi) -> HRESULT
}}
impl ISpatialAudioDeviceConfigurationStatics {
    #[inline] pub fn get_for_device_id(&self, deviceId: &HStringArg) -> Result<Option<SpatialAudioDeviceConfiguration>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetForDeviceId)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(SpatialAudioDeviceConfiguration::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpatialAudioFormatConfiguration, 853477800, 20720, 21397, 153, 35, 125, 68, 202, 113, 237, 109);
RT_INTERFACE!{interface ISpatialAudioFormatConfiguration(ISpatialAudioFormatConfigurationVtbl, ISpatialAudioFormatConfiguration_Abi): IInspectable(IInspectableVtbl) [IID_ISpatialAudioFormatConfiguration] {
    fn ReportLicenseChangedAsync(&self, subtype: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportConfigurationChangedAsync(&self, subtype: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn get_MixedRealityExclusiveModePolicy(&self, out: *mut MixedRealitySpatialAudioFormatPolicy) -> HRESULT,
    fn put_MixedRealityExclusiveModePolicy(&self, value: MixedRealitySpatialAudioFormatPolicy) -> HRESULT
}}
impl ISpatialAudioFormatConfiguration {
    #[inline] pub fn report_license_changed_async(&self, subtype: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportLicenseChangedAsync)(self.0.as_abi() as *const _ as *mut _, subtype.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_configuration_changed_async(&self, subtype: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportConfigurationChangedAsync)(self.0.as_abi() as *const _ as *mut _, subtype.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_mixed_reality_exclusive_mode_policy(&self) -> Result<MixedRealitySpatialAudioFormatPolicy> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MixedRealityExclusiveModePolicy)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_mixed_reality_exclusive_mode_policy(&self, value: MixedRealitySpatialAudioFormatPolicy) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MixedRealityExclusiveModePolicy)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialAudioFormatConfiguration: ISpatialAudioFormatConfiguration}
impl RtActivatable<ISpatialAudioFormatConfigurationStatics> for SpatialAudioFormatConfiguration {}
impl SpatialAudioFormatConfiguration {
    #[inline] pub fn get_default() -> Result<Option<SpatialAudioFormatConfiguration>> {
        <Self as RtActivatable<ISpatialAudioFormatConfigurationStatics>>::get_activation_factory().get_default()
    }
}
DEFINE_CLSID!(SpatialAudioFormatConfiguration(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,65,117,100,105,111,46,83,112,97,116,105,97,108,65,117,100,105,111,70,111,114,109,97,116,67,111,110,102,105,103,117,114,97,116,105,111,110,0]) [CLSID_SpatialAudioFormatConfiguration]);
DEFINE_IID!(IID_ISpatialAudioFormatConfigurationStatics, 727707505, 26569, 20063, 163, 91, 65, 104, 7, 17, 248, 199);
RT_INTERFACE!{static interface ISpatialAudioFormatConfigurationStatics(ISpatialAudioFormatConfigurationStaticsVtbl, ISpatialAudioFormatConfigurationStatics_Abi): IInspectable(IInspectableVtbl) [IID_ISpatialAudioFormatConfigurationStatics] {
    fn GetDefault(&self, out: *mut <SpatialAudioFormatConfiguration as RtType>::Abi) -> HRESULT
}}
impl ISpatialAudioFormatConfigurationStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<SpatialAudioFormatConfiguration>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SpatialAudioFormatConfiguration::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class SpatialAudioFormatSubtype}
impl RtActivatable<ISpatialAudioFormatSubtypeStatics> for SpatialAudioFormatSubtype {}
impl SpatialAudioFormatSubtype {
    #[inline] pub fn get_windows_sonic() -> Result<HString> {
        <Self as RtActivatable<ISpatialAudioFormatSubtypeStatics>>::get_activation_factory().get_windows_sonic()
    }
    #[inline] pub fn get_dolby_atmos_for_headphones() -> Result<HString> {
        <Self as RtActivatable<ISpatialAudioFormatSubtypeStatics>>::get_activation_factory().get_dolby_atmos_for_headphones()
    }
    #[inline] pub fn get_dolby_atmos_for_home_theater() -> Result<HString> {
        <Self as RtActivatable<ISpatialAudioFormatSubtypeStatics>>::get_activation_factory().get_dolby_atmos_for_home_theater()
    }
    #[inline] pub fn get_dolby_atmos_for_speakers() -> Result<HString> {
        <Self as RtActivatable<ISpatialAudioFormatSubtypeStatics>>::get_activation_factory().get_dolby_atmos_for_speakers()
    }
    #[inline] pub fn get_dts_headphone_x() -> Result<HString> {
        <Self as RtActivatable<ISpatialAudioFormatSubtypeStatics>>::get_activation_factory().get_dts_headphone_x()
    }
    #[inline] pub fn get_dtsx_ultra() -> Result<HString> {
        <Self as RtActivatable<ISpatialAudioFormatSubtypeStatics>>::get_activation_factory().get_dtsx_ultra()
    }
}
DEFINE_CLSID!(SpatialAudioFormatSubtype(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,65,117,100,105,111,46,83,112,97,116,105,97,108,65,117,100,105,111,70,111,114,109,97,116,83,117,98,116,121,112,101,0]) [CLSID_SpatialAudioFormatSubtype]);
DEFINE_IID!(IID_ISpatialAudioFormatSubtypeStatics, 3017706055, 33774, 16998, 169, 69, 190, 223, 80, 122, 254, 237);
RT_INTERFACE!{static interface ISpatialAudioFormatSubtypeStatics(ISpatialAudioFormatSubtypeStaticsVtbl, ISpatialAudioFormatSubtypeStatics_Abi): IInspectable(IInspectableVtbl) [IID_ISpatialAudioFormatSubtypeStatics] {
    fn get_WindowsSonic(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DolbyAtmosForHeadphones(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DolbyAtmosForHomeTheater(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DolbyAtmosForSpeakers(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DTSHeadphoneX(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DTSXUltra(&self, out: *mut HSTRING) -> HRESULT
}}
impl ISpatialAudioFormatSubtypeStatics {
    #[inline] pub fn get_windows_sonic(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_WindowsSonic)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_dolby_atmos_for_headphones(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DolbyAtmosForHeadphones)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_dolby_atmos_for_home_theater(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DolbyAtmosForHomeTheater)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_dolby_atmos_for_speakers(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DolbyAtmosForSpeakers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_dts_headphone_x(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DTSHeadphoneX)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_dtsx_ultra(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DTSXUltra)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SpatialAudioModel: i32 {
    ObjectBased = 0, FoldDown = 1,
}}
} // Windows.Media.Audio
pub mod capture { // Windows.Media.Capture
use crate::prelude::*;
DEFINE_IID!(IID_IAdvancedCapturedPhoto, 4034032267, 45714, 17553, 157, 65, 153, 128, 122, 85, 11, 191);
RT_INTERFACE!{interface IAdvancedCapturedPhoto(IAdvancedCapturedPhotoVtbl, IAdvancedCapturedPhoto_Abi): IInspectable(IInspectableVtbl) [IID_IAdvancedCapturedPhoto] {
    fn get_Frame(&self, out: *mut <CapturedFrame as RtType>::Abi) -> HRESULT,
    fn get_Mode(&self, out: *mut super::devices::AdvancedPhotoMode) -> HRESULT,
    fn get_Context(&self, out: *mut <IInspectable as RtType>::Abi) -> HRESULT
}}
impl IAdvancedCapturedPhoto {
    #[inline] pub fn get_frame(&self) -> Result<Option<CapturedFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Frame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CapturedFrame::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_mode(&self) -> Result<super::devices::AdvancedPhotoMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_context(&self) -> Result<Option<IInspectable>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Context)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IInspectable::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AdvancedCapturedPhoto: IAdvancedCapturedPhoto}
DEFINE_IID!(IID_IAdvancedCapturedPhoto2, 416247000, 53246, 17112, 129, 4, 1, 123, 179, 24, 244, 161);
RT_INTERFACE!{interface IAdvancedCapturedPhoto2(IAdvancedCapturedPhoto2Vtbl, IAdvancedCapturedPhoto2_Abi): IInspectable(IInspectableVtbl) [IID_IAdvancedCapturedPhoto2] {
    fn get_FrameBoundsRelativeToReferencePhoto(&self, out: *mut <foundation::IReference<foundation::Rect> as RtType>::Abi) -> HRESULT
}}
impl IAdvancedCapturedPhoto2 {
    #[inline] pub fn get_frame_bounds_relative_to_reference_photo(&self) -> Result<Option<foundation::IReference<foundation::Rect>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameBoundsRelativeToReferencePhoto)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAdvancedPhotoCapture, 2214570746, 26215, 17628, 151, 60, 166, 188, 229, 150, 170, 15);
RT_INTERFACE!{interface IAdvancedPhotoCapture(IAdvancedPhotoCaptureVtbl, IAdvancedPhotoCapture_Abi): IInspectable(IInspectableVtbl) [IID_IAdvancedPhotoCapture] {
    fn CaptureAsync(&self, out: *mut <foundation::IAsyncOperation<AdvancedCapturedPhoto> as RtType>::Abi) -> HRESULT,
    fn CaptureWithContextAsync(&self, context: <IInspectable as RtType>::Abi, out: *mut <foundation::IAsyncOperation<AdvancedCapturedPhoto> as RtType>::Abi) -> HRESULT,
    fn add_OptionalReferencePhotoCaptured(&self, handler: <foundation::TypedEventHandler<AdvancedPhotoCapture, OptionalReferencePhotoCapturedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_OptionalReferencePhotoCaptured(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_AllPhotosCaptured(&self, handler: <foundation::TypedEventHandler<AdvancedPhotoCapture, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AllPhotosCaptured(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn FinishAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IAdvancedPhotoCapture {
    #[inline] pub fn capture_async(&self) -> Result<foundation::IAsyncOperation<AdvancedCapturedPhoto>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CaptureAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn capture_with_context_async(&self, context: &IInspectable) -> Result<foundation::IAsyncOperation<AdvancedCapturedPhoto>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CaptureWithContextAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(context) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_optional_reference_photo_captured(&self, handler: &foundation::TypedEventHandler<AdvancedPhotoCapture, OptionalReferencePhotoCapturedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_OptionalReferencePhotoCaptured)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_optional_reference_photo_captured(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_OptionalReferencePhotoCaptured)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_all_photos_captured(&self, handler: &foundation::TypedEventHandler<AdvancedPhotoCapture, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AllPhotosCaptured)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_all_photos_captured(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AllPhotosCaptured)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn finish_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FinishAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AdvancedPhotoCapture: IAdvancedPhotoCapture}
DEFINE_IID!(IID_IAppBroadcastBackgroundService, 3134318378, 64148, 18169, 149, 252, 215, 21, 17, 205, 167, 11);
RT_INTERFACE!{interface IAppBroadcastBackgroundService(IAppBroadcastBackgroundServiceVtbl, IAppBroadcastBackgroundService_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastBackgroundService] {
    fn put_PlugInState(&self, value: AppBroadcastPlugInState) -> HRESULT,
    fn get_PlugInState(&self, out: *mut AppBroadcastPlugInState) -> HRESULT,
    fn put_SignInInfo(&self, value: <AppBroadcastBackgroundServiceSignInInfo as RtType>::Abi) -> HRESULT,
    fn get_SignInInfo(&self, out: *mut <AppBroadcastBackgroundServiceSignInInfo as RtType>::Abi) -> HRESULT,
    fn put_StreamInfo(&self, value: <AppBroadcastBackgroundServiceStreamInfo as RtType>::Abi) -> HRESULT,
    fn get_StreamInfo(&self, out: *mut <AppBroadcastBackgroundServiceStreamInfo as RtType>::Abi) -> HRESULT,
    fn get_AppId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_BroadcastTitle(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ViewerCount(&self, value: u32) -> HRESULT,
    fn get_ViewerCount(&self, out: *mut u32) -> HRESULT,
    fn TerminateBroadcast(&self, reason: AppBroadcastTerminationReason, providerSpecificReason: u32) -> HRESULT,
    fn add_HeartbeatRequested(&self, handler: <foundation::TypedEventHandler<AppBroadcastBackgroundService, AppBroadcastHeartbeatRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_HeartbeatRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_TitleId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAppBroadcastBackgroundService {
    #[inline] pub fn set_plug_in_state(&self, value: AppBroadcastPlugInState) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PlugInState)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_plug_in_state(&self) -> Result<AppBroadcastPlugInState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlugInState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_sign_in_info(&self, value: &AppBroadcastBackgroundServiceSignInInfo) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SignInInfo)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sign_in_info(&self) -> Result<Option<AppBroadcastBackgroundServiceSignInInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SignInInfo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastBackgroundServiceSignInInfo::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_stream_info(&self, value: &AppBroadcastBackgroundServiceStreamInfo) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_StreamInfo)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_stream_info(&self) -> Result<Option<AppBroadcastBackgroundServiceStreamInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_StreamInfo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastBackgroundServiceStreamInfo::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_app_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AppId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_broadcast_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BroadcastTitle)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_viewer_count(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ViewerCount)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_viewer_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ViewerCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn terminate_broadcast(&self, reason: AppBroadcastTerminationReason, providerSpecificReason: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).TerminateBroadcast)(self.0.as_abi() as *const _ as *mut _, reason, providerSpecificReason);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_heartbeat_requested(&self, handler: &foundation::TypedEventHandler<AppBroadcastBackgroundService, AppBroadcastHeartbeatRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_HeartbeatRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_heartbeat_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_HeartbeatRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_title_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TitleId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastBackgroundService: IAppBroadcastBackgroundService}
DEFINE_IID!(IID_IAppBroadcastBackgroundService2, 4237085631, 21833, 19335, 149, 159, 35, 202, 64, 31, 212, 115);
RT_INTERFACE!{interface IAppBroadcastBackgroundService2(IAppBroadcastBackgroundService2Vtbl, IAppBroadcastBackgroundService2_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastBackgroundService2] {
    fn put_BroadcastTitle(&self, value: HSTRING) -> HRESULT,
    fn get_BroadcastLanguage(&self, out: *mut HSTRING) -> HRESULT,
    fn put_BroadcastLanguage(&self, value: HSTRING) -> HRESULT,
    fn get_BroadcastChannel(&self, out: *mut HSTRING) -> HRESULT,
    fn put_BroadcastChannel(&self, value: HSTRING) -> HRESULT,
    fn add_BroadcastTitleChanged(&self, handler: <foundation::TypedEventHandler<AppBroadcastBackgroundService, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BroadcastTitleChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_BroadcastLanguageChanged(&self, handler: <foundation::TypedEventHandler<AppBroadcastBackgroundService, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BroadcastLanguageChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_BroadcastChannelChanged(&self, handler: <foundation::TypedEventHandler<AppBroadcastBackgroundService, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BroadcastChannelChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAppBroadcastBackgroundService2 {
    #[inline] pub fn set_broadcast_title(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BroadcastTitle)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_broadcast_language(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BroadcastLanguage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_broadcast_language(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BroadcastLanguage)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_broadcast_channel(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BroadcastChannel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_broadcast_channel(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BroadcastChannel)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_broadcast_title_changed(&self, handler: &foundation::TypedEventHandler<AppBroadcastBackgroundService, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_BroadcastTitleChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_broadcast_title_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_BroadcastTitleChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_broadcast_language_changed(&self, handler: &foundation::TypedEventHandler<AppBroadcastBackgroundService, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_BroadcastLanguageChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_broadcast_language_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_BroadcastLanguageChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_broadcast_channel_changed(&self, handler: &foundation::TypedEventHandler<AppBroadcastBackgroundService, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_BroadcastChannelChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_broadcast_channel_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_BroadcastChannelChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppBroadcastBackgroundServiceSignInInfo, 1584616053, 35016, 20170, 137, 186, 72, 37, 152, 93, 184, 128);
RT_INTERFACE!{interface IAppBroadcastBackgroundServiceSignInInfo(IAppBroadcastBackgroundServiceSignInInfoVtbl, IAppBroadcastBackgroundServiceSignInInfo_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastBackgroundServiceSignInInfo] {
    fn get_SignInState(&self, out: *mut AppBroadcastSignInState) -> HRESULT,
    fn put_OAuthRequestUri(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_OAuthRequestUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_OAuthCallbackUri(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_OAuthCallbackUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-security")] fn get_AuthenticationResult(&self, out: *mut <super::super::security::authentication::web::WebAuthenticationResult as RtType>::Abi) -> HRESULT,
    fn put_UserName(&self, value: HSTRING) -> HRESULT,
    fn get_UserName(&self, out: *mut HSTRING) -> HRESULT,
    fn add_SignInStateChanged(&self, handler: <foundation::TypedEventHandler<AppBroadcastBackgroundServiceSignInInfo, AppBroadcastSignInStateChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SignInStateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAppBroadcastBackgroundServiceSignInInfo {
    #[inline] pub fn get_sign_in_state(&self) -> Result<AppBroadcastSignInState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SignInState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_oauth_request_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_OAuthRequestUri)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_oauth_request_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_OAuthRequestUri)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_oauth_callback_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_OAuthCallbackUri)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_oauth_callback_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_OAuthCallbackUri)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn get_authentication_result(&self) -> Result<Option<super::super::security::authentication::web::WebAuthenticationResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AuthenticationResult)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::security::authentication::web::WebAuthenticationResult::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_user_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_UserName)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_user_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_UserName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_sign_in_state_changed(&self, handler: &foundation::TypedEventHandler<AppBroadcastBackgroundServiceSignInInfo, AppBroadcastSignInStateChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SignInStateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_sign_in_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SignInStateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastBackgroundServiceSignInInfo: IAppBroadcastBackgroundServiceSignInInfo}
DEFINE_IID!(IID_IAppBroadcastBackgroundServiceSignInInfo2, 2432968796, 25295, 19004, 167, 238, 174, 181, 7, 64, 70, 69);
RT_INTERFACE!{interface IAppBroadcastBackgroundServiceSignInInfo2(IAppBroadcastBackgroundServiceSignInInfo2Vtbl, IAppBroadcastBackgroundServiceSignInInfo2_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastBackgroundServiceSignInInfo2] {
    fn add_UserNameChanged(&self, handler: <foundation::TypedEventHandler<AppBroadcastBackgroundServiceSignInInfo, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_UserNameChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAppBroadcastBackgroundServiceSignInInfo2 {
    #[inline] pub fn add_user_name_changed(&self, handler: &foundation::TypedEventHandler<AppBroadcastBackgroundServiceSignInInfo, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_UserNameChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_user_name_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_UserNameChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppBroadcastBackgroundServiceStreamInfo, 836502204, 39178, 18692, 170, 150, 254, 54, 67, 129, 241, 54);
RT_INTERFACE!{interface IAppBroadcastBackgroundServiceStreamInfo(IAppBroadcastBackgroundServiceStreamInfoVtbl, IAppBroadcastBackgroundServiceStreamInfo_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastBackgroundServiceStreamInfo] {
    fn get_StreamState(&self, out: *mut AppBroadcastStreamState) -> HRESULT,
    fn put_DesiredVideoEncodingBitrate(&self, value: u64) -> HRESULT,
    fn get_DesiredVideoEncodingBitrate(&self, out: *mut u64) -> HRESULT,
    fn put_BandwidthTestBitrate(&self, value: u64) -> HRESULT,
    fn get_BandwidthTestBitrate(&self, out: *mut u64) -> HRESULT,
    fn put_AudioCodec(&self, value: HSTRING) -> HRESULT,
    fn get_AudioCodec(&self, out: *mut HSTRING) -> HRESULT,
    fn get_BroadcastStreamReader(&self, out: *mut <AppBroadcastStreamReader as RtType>::Abi) -> HRESULT,
    fn add_StreamStateChanged(&self, handler: <foundation::TypedEventHandler<AppBroadcastBackgroundServiceStreamInfo, AppBroadcastStreamStateChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StreamStateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_VideoEncodingResolutionChanged(&self, handler: <foundation::TypedEventHandler<AppBroadcastBackgroundServiceStreamInfo, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VideoEncodingResolutionChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_VideoEncodingBitrateChanged(&self, handler: <foundation::TypedEventHandler<AppBroadcastBackgroundServiceStreamInfo, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VideoEncodingBitrateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAppBroadcastBackgroundServiceStreamInfo {
    #[inline] pub fn get_stream_state(&self) -> Result<AppBroadcastStreamState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StreamState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_video_encoding_bitrate(&self, value: u64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DesiredVideoEncodingBitrate)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_desired_video_encoding_bitrate(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DesiredVideoEncodingBitrate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_bandwidth_test_bitrate(&self, value: u64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BandwidthTestBitrate)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_bandwidth_test_bitrate(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BandwidthTestBitrate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_audio_codec(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AudioCodec)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_codec(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioCodec)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_broadcast_stream_reader(&self) -> Result<Option<AppBroadcastStreamReader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BroadcastStreamReader)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastStreamReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_stream_state_changed(&self, handler: &foundation::TypedEventHandler<AppBroadcastBackgroundServiceStreamInfo, AppBroadcastStreamStateChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StreamStateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stream_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StreamStateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_video_encoding_resolution_changed(&self, handler: &foundation::TypedEventHandler<AppBroadcastBackgroundServiceStreamInfo, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_VideoEncodingResolutionChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_video_encoding_resolution_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_VideoEncodingResolutionChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_video_encoding_bitrate_changed(&self, handler: &foundation::TypedEventHandler<AppBroadcastBackgroundServiceStreamInfo, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_VideoEncodingBitrateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_video_encoding_bitrate_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_VideoEncodingBitrateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastBackgroundServiceStreamInfo: IAppBroadcastBackgroundServiceStreamInfo}
DEFINE_IID!(IID_IAppBroadcastBackgroundServiceStreamInfo2, 3172900717, 38108, 20430, 149, 65, 169, 241, 41, 89, 99, 52);
RT_INTERFACE!{interface IAppBroadcastBackgroundServiceStreamInfo2(IAppBroadcastBackgroundServiceStreamInfo2Vtbl, IAppBroadcastBackgroundServiceStreamInfo2_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastBackgroundServiceStreamInfo2] {
    fn ReportProblemWithStream(&self) -> HRESULT
}}
impl IAppBroadcastBackgroundServiceStreamInfo2 {
    #[inline] pub fn report_problem_with_stream(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ReportProblemWithStream)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum AppBroadcastCameraCaptureState: i32 {
    Stopped = 0, Started = 1, Failed = 2,
}}
DEFINE_IID!(IID_IAppBroadcastCameraCaptureStateChangedEventArgs, 506678480, 47234, 19336, 134, 146, 5, 153, 154, 206, 183, 15);
RT_INTERFACE!{interface IAppBroadcastCameraCaptureStateChangedEventArgs(IAppBroadcastCameraCaptureStateChangedEventArgsVtbl, IAppBroadcastCameraCaptureStateChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastCameraCaptureStateChangedEventArgs] {
    fn get_State(&self, out: *mut AppBroadcastCameraCaptureState) -> HRESULT,
    fn get_ErrorCode(&self, out: *mut u32) -> HRESULT
}}
impl IAppBroadcastCameraCaptureStateChangedEventArgs {
    #[inline] pub fn get_state(&self) -> Result<AppBroadcastCameraCaptureState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error_code(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ErrorCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastCameraCaptureStateChangedEventArgs: IAppBroadcastCameraCaptureStateChangedEventArgs}
RT_ENUM! { enum AppBroadcastCameraOverlayLocation: i32 {
    TopLeft = 0, TopCenter = 1, TopRight = 2, MiddleLeft = 3, MiddleCenter = 4, MiddleRight = 5, BottomLeft = 6, BottomCenter = 7, BottomRight = 8,
}}
RT_ENUM! { enum AppBroadcastCameraOverlaySize: i32 {
    Small = 0, Medium = 1, Large = 2,
}}
RT_ENUM! { enum AppBroadcastCaptureTargetType: i32 {
    AppView = 0, EntireDisplay = 1,
}}
RT_ENUM! { enum AppBroadcastExitBroadcastModeReason: i32 {
    NormalExit = 0, UserCanceled = 1, AuthorizationFail = 2, ForegroundAppActivated = 3,
}}
DEFINE_IID!(IID_IAppBroadcastGlobalSettings, 2999658405, 28924, 19991, 128, 189, 107, 160, 253, 63, 243, 160);
RT_INTERFACE!{interface IAppBroadcastGlobalSettings(IAppBroadcastGlobalSettingsVtbl, IAppBroadcastGlobalSettings_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastGlobalSettings] {
    fn get_IsBroadcastEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsDisabledByPolicy(&self, out: *mut bool) -> HRESULT,
    fn get_IsGpuConstrained(&self, out: *mut bool) -> HRESULT,
    fn get_HasHardwareEncoder(&self, out: *mut bool) -> HRESULT,
    fn put_IsAudioCaptureEnabled(&self, value: bool) -> HRESULT,
    fn get_IsAudioCaptureEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsMicrophoneCaptureEnabledByDefault(&self, value: bool) -> HRESULT,
    fn get_IsMicrophoneCaptureEnabledByDefault(&self, out: *mut bool) -> HRESULT,
    fn put_IsEchoCancellationEnabled(&self, value: bool) -> HRESULT,
    fn get_IsEchoCancellationEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_SystemAudioGain(&self, value: f64) -> HRESULT,
    fn get_SystemAudioGain(&self, out: *mut f64) -> HRESULT,
    fn put_MicrophoneGain(&self, value: f64) -> HRESULT,
    fn get_MicrophoneGain(&self, out: *mut f64) -> HRESULT,
    fn put_IsCameraCaptureEnabledByDefault(&self, value: bool) -> HRESULT,
    fn get_IsCameraCaptureEnabledByDefault(&self, out: *mut bool) -> HRESULT,
    fn put_SelectedCameraId(&self, value: HSTRING) -> HRESULT,
    fn get_SelectedCameraId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CameraOverlayLocation(&self, value: AppBroadcastCameraOverlayLocation) -> HRESULT,
    fn get_CameraOverlayLocation(&self, out: *mut AppBroadcastCameraOverlayLocation) -> HRESULT,
    fn put_CameraOverlaySize(&self, value: AppBroadcastCameraOverlaySize) -> HRESULT,
    fn get_CameraOverlaySize(&self, out: *mut AppBroadcastCameraOverlaySize) -> HRESULT,
    fn put_IsCursorImageCaptureEnabled(&self, value: bool) -> HRESULT,
    fn get_IsCursorImageCaptureEnabled(&self, out: *mut bool) -> HRESULT
}}
impl IAppBroadcastGlobalSettings {
    #[inline] pub fn get_is_broadcast_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsBroadcastEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_disabled_by_policy(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDisabledByPolicy)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_gpu_constrained(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsGpuConstrained)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_has_hardware_encoder(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HasHardwareEncoder)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_audio_capture_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsAudioCaptureEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_audio_capture_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsAudioCaptureEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_microphone_capture_enabled_by_default(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsMicrophoneCaptureEnabledByDefault)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_microphone_capture_enabled_by_default(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsMicrophoneCaptureEnabledByDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_echo_cancellation_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsEchoCancellationEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_echo_cancellation_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsEchoCancellationEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_system_audio_gain(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SystemAudioGain)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_system_audio_gain(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SystemAudioGain)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_microphone_gain(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MicrophoneGain)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_microphone_gain(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MicrophoneGain)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_camera_capture_enabled_by_default(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsCameraCaptureEnabledByDefault)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_camera_capture_enabled_by_default(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCameraCaptureEnabledByDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_selected_camera_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SelectedCameraId)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_selected_camera_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SelectedCameraId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_camera_overlay_location(&self, value: AppBroadcastCameraOverlayLocation) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CameraOverlayLocation)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_camera_overlay_location(&self) -> Result<AppBroadcastCameraOverlayLocation> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CameraOverlayLocation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_camera_overlay_size(&self, value: AppBroadcastCameraOverlaySize) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CameraOverlaySize)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_camera_overlay_size(&self) -> Result<AppBroadcastCameraOverlaySize> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CameraOverlaySize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_cursor_image_capture_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsCursorImageCaptureEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_cursor_image_capture_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCursorImageCaptureEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastGlobalSettings: IAppBroadcastGlobalSettings}
DEFINE_IID!(IID_IAppBroadcastHeartbeatRequestedEventArgs, 3466936963, 61009, 19903, 148, 114, 121, 169, 237, 78, 33, 101);
RT_INTERFACE!{interface IAppBroadcastHeartbeatRequestedEventArgs(IAppBroadcastHeartbeatRequestedEventArgsVtbl, IAppBroadcastHeartbeatRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastHeartbeatRequestedEventArgs] {
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn get_Handled(&self, out: *mut bool) -> HRESULT
}}
impl IAppBroadcastHeartbeatRequestedEventArgs {
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Handled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Handled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastHeartbeatRequestedEventArgs: IAppBroadcastHeartbeatRequestedEventArgs}
RT_CLASS!{static class AppBroadcastManager}
impl RtActivatable<IAppBroadcastManagerStatics> for AppBroadcastManager {}
impl AppBroadcastManager {
    #[inline] pub fn get_global_settings() -> Result<Option<AppBroadcastGlobalSettings>> {
        <Self as RtActivatable<IAppBroadcastManagerStatics>>::get_activation_factory().get_global_settings()
    }
    #[inline] pub fn apply_global_settings(value: &AppBroadcastGlobalSettings) -> Result<()> {
        <Self as RtActivatable<IAppBroadcastManagerStatics>>::get_activation_factory().apply_global_settings(value)
    }
    #[inline] pub fn get_provider_settings() -> Result<Option<AppBroadcastProviderSettings>> {
        <Self as RtActivatable<IAppBroadcastManagerStatics>>::get_activation_factory().get_provider_settings()
    }
    #[inline] pub fn apply_provider_settings(value: &AppBroadcastProviderSettings) -> Result<()> {
        <Self as RtActivatable<IAppBroadcastManagerStatics>>::get_activation_factory().apply_provider_settings(value)
    }
}
DEFINE_CLSID!(AppBroadcastManager(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,97,112,116,117,114,101,46,65,112,112,66,114,111,97,100,99,97,115,116,77,97,110,97,103,101,114,0]) [CLSID_AppBroadcastManager]);
DEFINE_IID!(IID_IAppBroadcastManagerStatics, 911081867, 7758, 16671, 171, 62, 146, 149, 152, 68, 193, 86);
RT_INTERFACE!{static interface IAppBroadcastManagerStatics(IAppBroadcastManagerStaticsVtbl, IAppBroadcastManagerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastManagerStatics] {
    fn GetGlobalSettings(&self, out: *mut <AppBroadcastGlobalSettings as RtType>::Abi) -> HRESULT,
    fn ApplyGlobalSettings(&self, value: <AppBroadcastGlobalSettings as RtType>::Abi) -> HRESULT,
    fn GetProviderSettings(&self, out: *mut <AppBroadcastProviderSettings as RtType>::Abi) -> HRESULT,
    fn ApplyProviderSettings(&self, value: <AppBroadcastProviderSettings as RtType>::Abi) -> HRESULT
}}
impl IAppBroadcastManagerStatics {
    #[inline] pub fn get_global_settings(&self) -> Result<Option<AppBroadcastGlobalSettings>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetGlobalSettings)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastGlobalSettings::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn apply_global_settings(&self, value: &AppBroadcastGlobalSettings) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ApplyGlobalSettings)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_provider_settings(&self) -> Result<Option<AppBroadcastProviderSettings>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetProviderSettings)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastProviderSettings::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn apply_provider_settings(&self, value: &AppBroadcastProviderSettings) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ApplyProviderSettings)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum AppBroadcastMicrophoneCaptureState: i32 {
    Stopped = 0, Started = 1, Failed = 2,
}}
DEFINE_IID!(IID_IAppBroadcastMicrophoneCaptureStateChangedEventArgs, 2825573865, 37952, 18696, 157, 9, 101, 183, 227, 21, 215, 149);
RT_INTERFACE!{interface IAppBroadcastMicrophoneCaptureStateChangedEventArgs(IAppBroadcastMicrophoneCaptureStateChangedEventArgsVtbl, IAppBroadcastMicrophoneCaptureStateChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastMicrophoneCaptureStateChangedEventArgs] {
    fn get_State(&self, out: *mut AppBroadcastMicrophoneCaptureState) -> HRESULT,
    fn get_ErrorCode(&self, out: *mut u32) -> HRESULT
}}
impl IAppBroadcastMicrophoneCaptureStateChangedEventArgs {
    #[inline] pub fn get_state(&self) -> Result<AppBroadcastMicrophoneCaptureState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error_code(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ErrorCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastMicrophoneCaptureStateChangedEventArgs: IAppBroadcastMicrophoneCaptureStateChangedEventArgs}
DEFINE_IID!(IID_IAppBroadcastPlugIn, 1376525926, 25875, 17780, 172, 84, 35, 183, 151, 41, 97, 91);
RT_INTERFACE!{interface IAppBroadcastPlugIn(IAppBroadcastPlugInVtbl, IAppBroadcastPlugIn_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastPlugIn] {
    fn get_AppId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ProviderSettings(&self, out: *mut <AppBroadcastProviderSettings as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Logo(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAppBroadcastPlugIn {
    #[inline] pub fn get_app_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AppId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_provider_settings(&self) -> Result<Option<AppBroadcastProviderSettings>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProviderSettings)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastProviderSettings::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_logo(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Logo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DisplayName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastPlugIn: IAppBroadcastPlugIn}
DEFINE_IID!(IID_IAppBroadcastPlugInManager, 3847281017, 10145, 18855, 187, 244, 215, 169, 233, 208, 118, 104);
RT_INTERFACE!{interface IAppBroadcastPlugInManager(IAppBroadcastPlugInManagerVtbl, IAppBroadcastPlugInManager_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastPlugInManager] {
    fn get_IsBroadcastProviderAvailable(&self, out: *mut bool) -> HRESULT,
    fn get_PlugInList(&self, out: *mut <foundation::collections::IVectorView<AppBroadcastPlugIn> as RtType>::Abi) -> HRESULT,
    fn get_DefaultPlugIn(&self, out: *mut <AppBroadcastPlugIn as RtType>::Abi) -> HRESULT,
    fn put_DefaultPlugIn(&self, value: <AppBroadcastPlugIn as RtType>::Abi) -> HRESULT
}}
impl IAppBroadcastPlugInManager {
    #[inline] pub fn get_is_broadcast_provider_available(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsBroadcastProviderAvailable)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_plug_in_list(&self) -> Result<Option<foundation::collections::IVectorView<AppBroadcastPlugIn>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlugInList)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_plug_in(&self) -> Result<Option<AppBroadcastPlugIn>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DefaultPlugIn)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastPlugIn::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_default_plug_in(&self, value: &AppBroadcastPlugIn) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DefaultPlugIn)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastPlugInManager: IAppBroadcastPlugInManager}
impl RtActivatable<IAppBroadcastPlugInManagerStatics> for AppBroadcastPlugInManager {}
impl AppBroadcastPlugInManager {
    #[inline] pub fn get_default() -> Result<Option<AppBroadcastPlugInManager>> {
        <Self as RtActivatable<IAppBroadcastPlugInManagerStatics>>::get_activation_factory().get_default()
    }
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(user: &super::super::system::User) -> Result<Option<AppBroadcastPlugInManager>> {
        <Self as RtActivatable<IAppBroadcastPlugInManagerStatics>>::get_activation_factory().get_for_user(user)
    }
}
DEFINE_CLSID!(AppBroadcastPlugInManager(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,97,112,116,117,114,101,46,65,112,112,66,114,111,97,100,99,97,115,116,80,108,117,103,73,110,77,97,110,97,103,101,114,0]) [CLSID_AppBroadcastPlugInManager]);
DEFINE_IID!(IID_IAppBroadcastPlugInManagerStatics, 4066663456, 23670, 19676, 147, 100, 130, 254, 158, 182, 83, 77);
RT_INTERFACE!{static interface IAppBroadcastPlugInManagerStatics(IAppBroadcastPlugInManagerStaticsVtbl, IAppBroadcastPlugInManagerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastPlugInManagerStatics] {
    fn GetDefault(&self, out: *mut <AppBroadcastPlugInManager as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-system")] fn GetForUser(&self, user: <super::super::system::User as RtType>::Abi, out: *mut <AppBroadcastPlugInManager as RtType>::Abi) -> HRESULT
}}
impl IAppBroadcastPlugInManagerStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<AppBroadcastPlugInManager>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastPlugInManager::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(&self, user: &super::super::system::User) -> Result<Option<AppBroadcastPlugInManager>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetForUser)(self.0.as_abi() as *const _ as *mut _, get_abi(user) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastPlugInManager::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum AppBroadcastPlugInState: i32 {
    Unknown = 0, Initialized = 1, MicrosoftSignInRequired = 2, OAuthSignInRequired = 3, ProviderSignInRequired = 4, InBandwidthTest = 5, ReadyToBroadcast = 6,
}}
DEFINE_IID!(IID_IAppBroadcastPlugInStateChangedEventArgs, 1216467186, 43973, 20422, 132, 176, 137, 55, 11, 180, 114, 18);
RT_INTERFACE!{interface IAppBroadcastPlugInStateChangedEventArgs(IAppBroadcastPlugInStateChangedEventArgsVtbl, IAppBroadcastPlugInStateChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastPlugInStateChangedEventArgs] {
    fn get_PlugInState(&self, out: *mut AppBroadcastPlugInState) -> HRESULT
}}
impl IAppBroadcastPlugInStateChangedEventArgs {
    #[inline] pub fn get_plug_in_state(&self) -> Result<AppBroadcastPlugInState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlugInState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastPlugInStateChangedEventArgs: IAppBroadcastPlugInStateChangedEventArgs}
DEFINE_IID!(IID_IAppBroadcastPreview, 347475802, 28234, 19328, 161, 79, 103, 238, 119, 209, 83, 231);
RT_INTERFACE!{interface IAppBroadcastPreview(IAppBroadcastPreviewVtbl, IAppBroadcastPreview_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastPreview] {
    fn StopPreview(&self) -> HRESULT,
    fn get_PreviewState(&self, out: *mut AppBroadcastPreviewState) -> HRESULT,
    fn get_ErrorCode(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn add_PreviewStateChanged(&self, value: <foundation::TypedEventHandler<AppBroadcastPreview, AppBroadcastPreviewStateChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PreviewStateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_PreviewStreamReader(&self, out: *mut <AppBroadcastPreviewStreamReader as RtType>::Abi) -> HRESULT
}}
impl IAppBroadcastPreview {
    #[inline] pub fn stop_preview(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).StopPreview)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_preview_state(&self) -> Result<AppBroadcastPreviewState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PreviewState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error_code(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ErrorCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_preview_state_changed(&self, value: &foundation::TypedEventHandler<AppBroadcastPreview, AppBroadcastPreviewStateChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PreviewStateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_preview_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PreviewStateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_preview_stream_reader(&self) -> Result<Option<AppBroadcastPreviewStreamReader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PreviewStreamReader)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastPreviewStreamReader::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastPreview: IAppBroadcastPreview}
RT_ENUM! { enum AppBroadcastPreviewState: i32 {
    Started = 0, Stopped = 1, Failed = 2,
}}
DEFINE_IID!(IID_IAppBroadcastPreviewStateChangedEventArgs, 1515713246, 36330, 20102, 144, 173, 3, 252, 38, 185, 101, 60);
RT_INTERFACE!{interface IAppBroadcastPreviewStateChangedEventArgs(IAppBroadcastPreviewStateChangedEventArgsVtbl, IAppBroadcastPreviewStateChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastPreviewStateChangedEventArgs] {
    fn get_PreviewState(&self, out: *mut AppBroadcastPreviewState) -> HRESULT,
    fn get_ErrorCode(&self, out: *mut u32) -> HRESULT
}}
impl IAppBroadcastPreviewStateChangedEventArgs {
    #[inline] pub fn get_preview_state(&self) -> Result<AppBroadcastPreviewState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PreviewState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error_code(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ErrorCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastPreviewStateChangedEventArgs: IAppBroadcastPreviewStateChangedEventArgs}
DEFINE_IID!(IID_IAppBroadcastPreviewStreamReader, 2451737936, 56127, 16552, 140, 212, 244, 227, 113, 221, 171, 55);
RT_INTERFACE!{interface IAppBroadcastPreviewStreamReader(IAppBroadcastPreviewStreamReaderVtbl, IAppBroadcastPreviewStreamReader_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastPreviewStreamReader] {
    fn get_VideoWidth(&self, out: *mut u32) -> HRESULT,
    fn get_VideoHeight(&self, out: *mut u32) -> HRESULT,
    fn get_VideoStride(&self, out: *mut u32) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_VideoBitmapPixelFormat(&self, out: *mut super::super::graphics::imaging::BitmapPixelFormat) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_VideoBitmapAlphaMode(&self, out: *mut super::super::graphics::imaging::BitmapAlphaMode) -> HRESULT,
    fn TryGetNextVideoFrame(&self, out: *mut <AppBroadcastPreviewStreamVideoFrame as RtType>::Abi) -> HRESULT,
    fn add_VideoFrameArrived(&self, value: <foundation::TypedEventHandler<AppBroadcastPreviewStreamReader, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VideoFrameArrived(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAppBroadcastPreviewStreamReader {
    #[inline] pub fn get_video_width(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoWidth)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_video_height(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoHeight)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_video_stride(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoStride)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_video_bitmap_pixel_format(&self) -> Result<super::super::graphics::imaging::BitmapPixelFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoBitmapPixelFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_video_bitmap_alpha_mode(&self) -> Result<super::super::graphics::imaging::BitmapAlphaMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoBitmapAlphaMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_get_next_video_frame(&self) -> Result<Option<AppBroadcastPreviewStreamVideoFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryGetNextVideoFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastPreviewStreamVideoFrame::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_video_frame_arrived(&self, value: &foundation::TypedEventHandler<AppBroadcastPreviewStreamReader, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_VideoFrameArrived)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_video_frame_arrived(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_VideoFrameArrived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastPreviewStreamReader: IAppBroadcastPreviewStreamReader}
DEFINE_IID!(IID_IAppBroadcastPreviewStreamVideoFrame, 17809057, 38142, 17561, 184, 192, 141, 36, 66, 121, 251, 18);
RT_INTERFACE!{interface IAppBroadcastPreviewStreamVideoFrame(IAppBroadcastPreviewStreamVideoFrameVtbl, IAppBroadcastPreviewStreamVideoFrame_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastPreviewStreamVideoFrame] {
    fn get_VideoHeader(&self, out: *mut <AppBroadcastPreviewStreamVideoHeader as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_VideoBuffer(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IAppBroadcastPreviewStreamVideoFrame {
    #[inline] pub fn get_video_header(&self) -> Result<Option<AppBroadcastPreviewStreamVideoHeader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoHeader)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastPreviewStreamVideoHeader::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_video_buffer(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoBuffer)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastPreviewStreamVideoFrame: IAppBroadcastPreviewStreamVideoFrame}
DEFINE_IID!(IID_IAppBroadcastPreviewStreamVideoHeader, 2347720979, 55940, 17561, 167, 171, 135, 17, 140, 180, 161, 87);
RT_INTERFACE!{interface IAppBroadcastPreviewStreamVideoHeader(IAppBroadcastPreviewStreamVideoHeaderVtbl, IAppBroadcastPreviewStreamVideoHeader_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastPreviewStreamVideoHeader] {
    fn get_AbsoluteTimestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_RelativeTimestamp(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_FrameId(&self, out: *mut u64) -> HRESULT
}}
impl IAppBroadcastPreviewStreamVideoHeader {
    #[inline] pub fn get_absolute_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AbsoluteTimestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_relative_timestamp(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RelativeTimestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_frame_id(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastPreviewStreamVideoHeader: IAppBroadcastPreviewStreamVideoHeader}
DEFINE_IID!(IID_IAppBroadcastProviderSettings, 3272335202, 39240, 17807, 173, 80, 170, 6, 236, 3, 218, 8);
RT_INTERFACE!{interface IAppBroadcastProviderSettings(IAppBroadcastProviderSettingsVtbl, IAppBroadcastProviderSettings_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastProviderSettings] {
    fn put_DefaultBroadcastTitle(&self, value: HSTRING) -> HRESULT,
    fn get_DefaultBroadcastTitle(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AudioEncodingBitrate(&self, value: u32) -> HRESULT,
    fn get_AudioEncodingBitrate(&self, out: *mut u32) -> HRESULT,
    fn put_CustomVideoEncodingBitrate(&self, value: u32) -> HRESULT,
    fn get_CustomVideoEncodingBitrate(&self, out: *mut u32) -> HRESULT,
    fn put_CustomVideoEncodingHeight(&self, value: u32) -> HRESULT,
    fn get_CustomVideoEncodingHeight(&self, out: *mut u32) -> HRESULT,
    fn put_CustomVideoEncodingWidth(&self, value: u32) -> HRESULT,
    fn get_CustomVideoEncodingWidth(&self, out: *mut u32) -> HRESULT,
    fn put_VideoEncodingBitrateMode(&self, value: AppBroadcastVideoEncodingBitrateMode) -> HRESULT,
    fn get_VideoEncodingBitrateMode(&self, out: *mut AppBroadcastVideoEncodingBitrateMode) -> HRESULT,
    fn put_VideoEncodingResolutionMode(&self, value: AppBroadcastVideoEncodingResolutionMode) -> HRESULT,
    fn get_VideoEncodingResolutionMode(&self, out: *mut AppBroadcastVideoEncodingResolutionMode) -> HRESULT
}}
impl IAppBroadcastProviderSettings {
    #[inline] pub fn set_default_broadcast_title(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DefaultBroadcastTitle)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_default_broadcast_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DefaultBroadcastTitle)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_audio_encoding_bitrate(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AudioEncodingBitrate)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_encoding_bitrate(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioEncodingBitrate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_custom_video_encoding_bitrate(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CustomVideoEncodingBitrate)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_custom_video_encoding_bitrate(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CustomVideoEncodingBitrate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_custom_video_encoding_height(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CustomVideoEncodingHeight)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_custom_video_encoding_height(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CustomVideoEncodingHeight)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_custom_video_encoding_width(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CustomVideoEncodingWidth)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_custom_video_encoding_width(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CustomVideoEncodingWidth)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_video_encoding_bitrate_mode(&self, value: AppBroadcastVideoEncodingBitrateMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_VideoEncodingBitrateMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_video_encoding_bitrate_mode(&self) -> Result<AppBroadcastVideoEncodingBitrateMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoEncodingBitrateMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_video_encoding_resolution_mode(&self, value: AppBroadcastVideoEncodingResolutionMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_VideoEncodingResolutionMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_video_encoding_resolution_mode(&self) -> Result<AppBroadcastVideoEncodingResolutionMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoEncodingResolutionMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastProviderSettings: IAppBroadcastProviderSettings}
DEFINE_IID!(IID_IAppBroadcastServices, 2254484694, 38555, 20028, 172, 58, 139, 4, 46, 228, 238, 99);
RT_INTERFACE!{interface IAppBroadcastServices(IAppBroadcastServicesVtbl, IAppBroadcastServices_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastServices] {
    fn get_CaptureTargetType(&self, out: *mut AppBroadcastCaptureTargetType) -> HRESULT,
    fn put_CaptureTargetType(&self, value: AppBroadcastCaptureTargetType) -> HRESULT,
    fn get_BroadcastTitle(&self, out: *mut HSTRING) -> HRESULT,
    fn put_BroadcastTitle(&self, value: HSTRING) -> HRESULT,
    fn get_BroadcastLanguage(&self, out: *mut HSTRING) -> HRESULT,
    fn put_BroadcastLanguage(&self, value: HSTRING) -> HRESULT,
    fn get_UserName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CanCapture(&self, out: *mut bool) -> HRESULT,
    fn EnterBroadcastModeAsync(&self, plugIn: <AppBroadcastPlugIn as RtType>::Abi, out: *mut <foundation::IAsyncOperation<u32> as RtType>::Abi) -> HRESULT,
    fn ExitBroadcastMode(&self, reason: AppBroadcastExitBroadcastModeReason) -> HRESULT,
    fn StartBroadcast(&self) -> HRESULT,
    fn PauseBroadcast(&self) -> HRESULT,
    fn ResumeBroadcast(&self) -> HRESULT,
    fn StartPreview(&self, desiredSize: foundation::Size, out: *mut <AppBroadcastPreview as RtType>::Abi) -> HRESULT,
    fn get_State(&self, out: *mut <AppBroadcastState as RtType>::Abi) -> HRESULT
}}
impl IAppBroadcastServices {
    #[inline] pub fn get_capture_target_type(&self) -> Result<AppBroadcastCaptureTargetType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CaptureTargetType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_capture_target_type(&self, value: AppBroadcastCaptureTargetType) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CaptureTargetType)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_broadcast_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BroadcastTitle)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_broadcast_title(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BroadcastTitle)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_broadcast_language(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BroadcastLanguage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_broadcast_language(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BroadcastLanguage)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_user_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_UserName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_can_capture(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanCapture)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn enter_broadcast_mode_async(&self, plugIn: &AppBroadcastPlugIn) -> Result<foundation::IAsyncOperation<u32>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).EnterBroadcastModeAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(plugIn) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn exit_broadcast_mode(&self, reason: AppBroadcastExitBroadcastModeReason) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ExitBroadcastMode)(self.0.as_abi() as *const _ as *mut _, reason);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_broadcast(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).StartBroadcast)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn pause_broadcast(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).PauseBroadcast)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn resume_broadcast(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ResumeBroadcast)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_preview(&self, desiredSize: foundation::Size) -> Result<Option<AppBroadcastPreview>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StartPreview)(self.0.as_abi() as *const _ as *mut _, desiredSize, &mut out);
        if hr == S_OK { Ok(AppBroadcastPreview::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_state(&self) -> Result<Option<AppBroadcastState>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastState::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastServices: IAppBroadcastServices}
RT_ENUM! { enum AppBroadcastSignInResult: i32 {
    Success = 0, AuthenticationFailed = 1, Unauthorized = 2, ServiceUnavailable = 3, Unknown = 4,
}}
RT_ENUM! { enum AppBroadcastSignInState: i32 {
    NotSignedIn = 0, MicrosoftSignInInProgress = 1, MicrosoftSignInComplete = 2, OAuthSignInInProgress = 3, OAuthSignInComplete = 4,
}}
DEFINE_IID!(IID_IAppBroadcastSignInStateChangedEventArgs, 45519524, 22809, 19102, 141, 94, 201, 187, 13, 211, 55, 122);
RT_INTERFACE!{interface IAppBroadcastSignInStateChangedEventArgs(IAppBroadcastSignInStateChangedEventArgsVtbl, IAppBroadcastSignInStateChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastSignInStateChangedEventArgs] {
    fn get_SignInState(&self, out: *mut AppBroadcastSignInState) -> HRESULT,
    fn get_Result(&self, out: *mut AppBroadcastSignInResult) -> HRESULT
}}
impl IAppBroadcastSignInStateChangedEventArgs {
    #[inline] pub fn get_sign_in_state(&self) -> Result<AppBroadcastSignInState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SignInState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_result(&self) -> Result<AppBroadcastSignInResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Result)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastSignInStateChangedEventArgs: IAppBroadcastSignInStateChangedEventArgs}
DEFINE_IID!(IID_IAppBroadcastState, 3993503085, 32921, 19933, 146, 46, 197, 109, 172, 88, 171, 251);
RT_INTERFACE!{interface IAppBroadcastState(IAppBroadcastStateVtbl, IAppBroadcastState_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastState] {
    fn get_IsCaptureTargetRunning(&self, out: *mut bool) -> HRESULT,
    fn get_ViewerCount(&self, out: *mut u32) -> HRESULT,
    fn get_ShouldCaptureMicrophone(&self, out: *mut bool) -> HRESULT,
    fn put_ShouldCaptureMicrophone(&self, value: bool) -> HRESULT,
    fn RestartMicrophoneCapture(&self) -> HRESULT,
    fn get_ShouldCaptureCamera(&self, out: *mut bool) -> HRESULT,
    fn put_ShouldCaptureCamera(&self, value: bool) -> HRESULT,
    fn RestartCameraCapture(&self) -> HRESULT,
    fn get_EncodedVideoSize(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_MicrophoneCaptureState(&self, out: *mut AppBroadcastMicrophoneCaptureState) -> HRESULT,
    fn get_MicrophoneCaptureError(&self, out: *mut u32) -> HRESULT,
    fn get_CameraCaptureState(&self, out: *mut AppBroadcastCameraCaptureState) -> HRESULT,
    fn get_CameraCaptureError(&self, out: *mut u32) -> HRESULT,
    fn get_StreamState(&self, out: *mut AppBroadcastStreamState) -> HRESULT,
    fn get_PlugInState(&self, out: *mut AppBroadcastPlugInState) -> HRESULT,
    fn get_OAuthRequestUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_OAuthCallbackUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy17(&self) -> (),
    #[cfg(feature="windows-security")] fn get_AuthenticationResult(&self, out: *mut <super::super::security::authentication::web::WebAuthenticationResult as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy18(&self) -> (),
    #[cfg(feature="windows-security")] fn put_AuthenticationResult(&self, value: <super::super::security::authentication::web::WebAuthenticationResult as RtType>::Abi) -> HRESULT,
    fn put_SignInState(&self, value: AppBroadcastSignInState) -> HRESULT,
    fn get_SignInState(&self, out: *mut AppBroadcastSignInState) -> HRESULT,
    fn get_TerminationReason(&self, out: *mut AppBroadcastTerminationReason) -> HRESULT,
    fn get_TerminationReasonPlugInSpecific(&self, out: *mut u32) -> HRESULT,
    fn add_ViewerCountChanged(&self, value: <foundation::TypedEventHandler<AppBroadcastState, AppBroadcastViewerCountChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ViewerCountChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_MicrophoneCaptureStateChanged(&self, value: <foundation::TypedEventHandler<AppBroadcastState, AppBroadcastMicrophoneCaptureStateChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MicrophoneCaptureStateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CameraCaptureStateChanged(&self, value: <foundation::TypedEventHandler<AppBroadcastState, AppBroadcastCameraCaptureStateChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CameraCaptureStateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PlugInStateChanged(&self, handler: <foundation::TypedEventHandler<AppBroadcastState, AppBroadcastPlugInStateChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PlugInStateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_StreamStateChanged(&self, handler: <foundation::TypedEventHandler<AppBroadcastState, AppBroadcastStreamStateChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StreamStateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CaptureTargetClosed(&self, value: <foundation::TypedEventHandler<AppBroadcastState, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CaptureTargetClosed(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAppBroadcastState {
    #[inline] pub fn get_is_capture_target_running(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCaptureTargetRunning)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_viewer_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ViewerCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_should_capture_microphone(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ShouldCaptureMicrophone)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_should_capture_microphone(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ShouldCaptureMicrophone)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn restart_microphone_capture(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RestartMicrophoneCapture)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_should_capture_camera(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ShouldCaptureCamera)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_should_capture_camera(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ShouldCaptureCamera)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn restart_camera_capture(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RestartCameraCapture)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_encoded_video_size(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_EncodedVideoSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_microphone_capture_state(&self) -> Result<AppBroadcastMicrophoneCaptureState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MicrophoneCaptureState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_microphone_capture_error(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MicrophoneCaptureError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_camera_capture_state(&self) -> Result<AppBroadcastCameraCaptureState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CameraCaptureState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_camera_capture_error(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CameraCaptureError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_stream_state(&self) -> Result<AppBroadcastStreamState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StreamState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_plug_in_state(&self) -> Result<AppBroadcastPlugInState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlugInState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_oauth_request_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_OAuthRequestUri)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_oauth_callback_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_OAuthCallbackUri)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn get_authentication_result(&self) -> Result<Option<super::super::security::authentication::web::WebAuthenticationResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AuthenticationResult)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::security::authentication::web::WebAuthenticationResult::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn set_authentication_result(&self, value: &super::super::security::authentication::web::WebAuthenticationResult) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AuthenticationResult)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_sign_in_state(&self, value: AppBroadcastSignInState) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SignInState)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sign_in_state(&self) -> Result<AppBroadcastSignInState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SignInState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_termination_reason(&self) -> Result<AppBroadcastTerminationReason> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TerminationReason)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_termination_reason_plug_in_specific(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TerminationReasonPlugInSpecific)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_viewer_count_changed(&self, value: &foundation::TypedEventHandler<AppBroadcastState, AppBroadcastViewerCountChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ViewerCountChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_viewer_count_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ViewerCountChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_microphone_capture_state_changed(&self, value: &foundation::TypedEventHandler<AppBroadcastState, AppBroadcastMicrophoneCaptureStateChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_MicrophoneCaptureStateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_microphone_capture_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_MicrophoneCaptureStateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_camera_capture_state_changed(&self, value: &foundation::TypedEventHandler<AppBroadcastState, AppBroadcastCameraCaptureStateChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_CameraCaptureStateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_camera_capture_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_CameraCaptureStateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_plug_in_state_changed(&self, handler: &foundation::TypedEventHandler<AppBroadcastState, AppBroadcastPlugInStateChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PlugInStateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_plug_in_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PlugInStateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stream_state_changed(&self, handler: &foundation::TypedEventHandler<AppBroadcastState, AppBroadcastStreamStateChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StreamStateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stream_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StreamStateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_capture_target_closed(&self, value: &foundation::TypedEventHandler<AppBroadcastState, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_CaptureTargetClosed)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_capture_target_closed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_CaptureTargetClosed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastState: IAppBroadcastState}
DEFINE_IID!(IID_IAppBroadcastStreamAudioFrame, 4020980424, 8634, 17727, 139, 183, 94, 147, 138, 46, 154, 116);
RT_INTERFACE!{interface IAppBroadcastStreamAudioFrame(IAppBroadcastStreamAudioFrameVtbl, IAppBroadcastStreamAudioFrame_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastStreamAudioFrame] {
    fn get_AudioHeader(&self, out: *mut <AppBroadcastStreamAudioHeader as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_AudioBuffer(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IAppBroadcastStreamAudioFrame {
    #[inline] pub fn get_audio_header(&self) -> Result<Option<AppBroadcastStreamAudioHeader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioHeader)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastStreamAudioHeader::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_audio_buffer(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioBuffer)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastStreamAudioFrame: IAppBroadcastStreamAudioFrame}
DEFINE_IID!(IID_IAppBroadcastStreamAudioHeader, 3206653296, 27512, 16918, 159, 7, 90, 255, 82, 86, 241, 183);
RT_INTERFACE!{interface IAppBroadcastStreamAudioHeader(IAppBroadcastStreamAudioHeaderVtbl, IAppBroadcastStreamAudioHeader_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastStreamAudioHeader] {
    fn get_AbsoluteTimestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_RelativeTimestamp(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_HasDiscontinuity(&self, out: *mut bool) -> HRESULT,
    fn get_FrameId(&self, out: *mut u64) -> HRESULT
}}
impl IAppBroadcastStreamAudioHeader {
    #[inline] pub fn get_absolute_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AbsoluteTimestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_relative_timestamp(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RelativeTimestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_has_discontinuity(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HasDiscontinuity)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_frame_id(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastStreamAudioHeader: IAppBroadcastStreamAudioHeader}
DEFINE_IID!(IID_IAppBroadcastStreamReader, 3006840057, 13156, 17504, 181, 241, 60, 194, 121, 106, 138, 162);
RT_INTERFACE!{interface IAppBroadcastStreamReader(IAppBroadcastStreamReaderVtbl, IAppBroadcastStreamReader_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastStreamReader] {
    fn get_AudioChannels(&self, out: *mut u32) -> HRESULT,
    fn get_AudioSampleRate(&self, out: *mut u32) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_AudioAacSequence(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_AudioBitrate(&self, out: *mut u32) -> HRESULT,
    fn TryGetNextAudioFrame(&self, out: *mut <AppBroadcastStreamAudioFrame as RtType>::Abi) -> HRESULT,
    fn get_VideoWidth(&self, out: *mut u32) -> HRESULT,
    fn get_VideoHeight(&self, out: *mut u32) -> HRESULT,
    fn get_VideoBitrate(&self, out: *mut u32) -> HRESULT,
    fn TryGetNextVideoFrame(&self, out: *mut <AppBroadcastStreamVideoFrame as RtType>::Abi) -> HRESULT,
    fn add_AudioFrameArrived(&self, value: <foundation::TypedEventHandler<AppBroadcastStreamReader, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AudioFrameArrived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_VideoFrameArrived(&self, value: <foundation::TypedEventHandler<AppBroadcastStreamReader, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VideoFrameArrived(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAppBroadcastStreamReader {
    #[inline] pub fn get_audio_channels(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioChannels)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_sample_rate(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioSampleRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_audio_aac_sequence(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioAacSequence)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_bitrate(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioBitrate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_get_next_audio_frame(&self) -> Result<Option<AppBroadcastStreamAudioFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryGetNextAudioFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastStreamAudioFrame::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_width(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoWidth)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_video_height(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoHeight)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_video_bitrate(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoBitrate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_get_next_video_frame(&self) -> Result<Option<AppBroadcastStreamVideoFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryGetNextVideoFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastStreamVideoFrame::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_audio_frame_arrived(&self, value: &foundation::TypedEventHandler<AppBroadcastStreamReader, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AudioFrameArrived)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_audio_frame_arrived(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AudioFrameArrived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_video_frame_arrived(&self, value: &foundation::TypedEventHandler<AppBroadcastStreamReader, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_VideoFrameArrived)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_video_frame_arrived(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_VideoFrameArrived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastStreamReader: IAppBroadcastStreamReader}
RT_ENUM! { enum AppBroadcastStreamState: i32 {
    Initializing = 0, StreamReady = 1, Started = 2, Paused = 3, Terminated = 4,
}}
DEFINE_IID!(IID_IAppBroadcastStreamStateChangedEventArgs, 1359521587, 53256, 19081, 147, 190, 88, 174, 217, 97, 55, 78);
RT_INTERFACE!{interface IAppBroadcastStreamStateChangedEventArgs(IAppBroadcastStreamStateChangedEventArgsVtbl, IAppBroadcastStreamStateChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastStreamStateChangedEventArgs] {
    fn get_StreamState(&self, out: *mut AppBroadcastStreamState) -> HRESULT
}}
impl IAppBroadcastStreamStateChangedEventArgs {
    #[inline] pub fn get_stream_state(&self) -> Result<AppBroadcastStreamState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StreamState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastStreamStateChangedEventArgs: IAppBroadcastStreamStateChangedEventArgs}
DEFINE_IID!(IID_IAppBroadcastStreamVideoFrame, 261607211, 51684, 20104, 129, 148, 216, 20, 203, 213, 133, 216);
RT_INTERFACE!{interface IAppBroadcastStreamVideoFrame(IAppBroadcastStreamVideoFrameVtbl, IAppBroadcastStreamVideoFrame_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastStreamVideoFrame] {
    fn get_VideoHeader(&self, out: *mut <AppBroadcastStreamVideoHeader as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_VideoBuffer(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IAppBroadcastStreamVideoFrame {
    #[inline] pub fn get_video_header(&self) -> Result<Option<AppBroadcastStreamVideoHeader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoHeader)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastStreamVideoHeader::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_video_buffer(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoBuffer)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastStreamVideoFrame: IAppBroadcastStreamVideoFrame}
DEFINE_IID!(IID_IAppBroadcastStreamVideoHeader, 194952910, 32306, 17197, 140, 162, 54, 191, 16, 185, 244, 98);
RT_INTERFACE!{interface IAppBroadcastStreamVideoHeader(IAppBroadcastStreamVideoHeaderVtbl, IAppBroadcastStreamVideoHeader_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastStreamVideoHeader] {
    fn get_AbsoluteTimestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_RelativeTimestamp(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_IsKeyFrame(&self, out: *mut bool) -> HRESULT,
    fn get_HasDiscontinuity(&self, out: *mut bool) -> HRESULT,
    fn get_FrameId(&self, out: *mut u64) -> HRESULT
}}
impl IAppBroadcastStreamVideoHeader {
    #[inline] pub fn get_absolute_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AbsoluteTimestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_relative_timestamp(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RelativeTimestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_key_frame(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsKeyFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_has_discontinuity(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HasDiscontinuity)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_frame_id(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastStreamVideoHeader: IAppBroadcastStreamVideoHeader}
RT_ENUM! { enum AppBroadcastTerminationReason: i32 {
    NormalTermination = 0, LostConnectionToService = 1, NoNetworkConnectivity = 2, ServiceAbort = 3, ServiceError = 4, ServiceUnavailable = 5, InternalError = 6, UnsupportedFormat = 7, BackgroundTaskTerminated = 8, BackgroundTaskUnresponsive = 9,
}}
DEFINE_IID!(IID_IAppBroadcastTriggerDetails, 3739986741, 60510, 19855, 177, 192, 93, 166, 232, 199, 86, 56);
RT_INTERFACE!{interface IAppBroadcastTriggerDetails(IAppBroadcastTriggerDetailsVtbl, IAppBroadcastTriggerDetails_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastTriggerDetails] {
    fn get_BackgroundService(&self, out: *mut <AppBroadcastBackgroundService as RtType>::Abi) -> HRESULT
}}
impl IAppBroadcastTriggerDetails {
    #[inline] pub fn get_background_service(&self) -> Result<Option<AppBroadcastBackgroundService>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BackgroundService)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastBackgroundService::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastTriggerDetails: IAppBroadcastTriggerDetails}
RT_ENUM! { enum AppBroadcastVideoEncodingBitrateMode: i32 {
    Custom = 0, Auto = 1,
}}
RT_ENUM! { enum AppBroadcastVideoEncodingResolutionMode: i32 {
    Custom = 0, Auto = 1,
}}
DEFINE_IID!(IID_IAppBroadcastViewerCountChangedEventArgs, 3873511461, 21505, 19166, 139, 210, 193, 78, 206, 230, 128, 125);
RT_INTERFACE!{interface IAppBroadcastViewerCountChangedEventArgs(IAppBroadcastViewerCountChangedEventArgsVtbl, IAppBroadcastViewerCountChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAppBroadcastViewerCountChangedEventArgs] {
    fn get_ViewerCount(&self, out: *mut u32) -> HRESULT
}}
impl IAppBroadcastViewerCountChangedEventArgs {
    #[inline] pub fn get_viewer_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ViewerCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppBroadcastViewerCountChangedEventArgs: IAppBroadcastViewerCountChangedEventArgs}
DEFINE_IID!(IID_IAppCapture, 2538198099, 41626, 17901, 143, 41, 34, 208, 153, 66, 207, 247);
RT_INTERFACE!{interface IAppCapture(IAppCaptureVtbl, IAppCapture_Abi): IInspectable(IInspectableVtbl) [IID_IAppCapture] {
    fn get_IsCapturingAudio(&self, out: *mut bool) -> HRESULT,
    fn get_IsCapturingVideo(&self, out: *mut bool) -> HRESULT,
    fn add_CapturingChanged(&self, handler: <foundation::TypedEventHandler<AppCapture, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CapturingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAppCapture {
    #[inline] pub fn get_is_capturing_audio(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCapturingAudio)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_capturing_video(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCapturingVideo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_capturing_changed(&self, handler: &foundation::TypedEventHandler<AppCapture, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_CapturingChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_capturing_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_CapturingChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppCapture: IAppCapture}
impl RtActivatable<IAppCaptureStatics> for AppCapture {}
impl RtActivatable<IAppCaptureStatics2> for AppCapture {}
impl AppCapture {
    #[inline] pub fn get_for_current_view() -> Result<Option<AppCapture>> {
        <Self as RtActivatable<IAppCaptureStatics>>::get_activation_factory().get_for_current_view()
    }
    #[inline] pub fn set_allowed_async(allowed: bool) -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<IAppCaptureStatics2>>::get_activation_factory().set_allowed_async(allowed)
    }
}
DEFINE_CLSID!(AppCapture(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,97,112,116,117,114,101,46,65,112,112,67,97,112,116,117,114,101,0]) [CLSID_AppCapture]);
DEFINE_IID!(IID_IAppCaptureAlternateShortcutKeys, 434692335, 9068, 16633, 179, 143, 155, 125, 214, 93, 28, 204);
RT_INTERFACE!{interface IAppCaptureAlternateShortcutKeys(IAppCaptureAlternateShortcutKeysVtbl, IAppCaptureAlternateShortcutKeys_Abi): IInspectable(IInspectableVtbl) [IID_IAppCaptureAlternateShortcutKeys] {
    #[cfg(feature="windows-system")] fn put_ToggleGameBarKey(&self, value: super::super::system::VirtualKey) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_ToggleGameBarKey(&self, out: *mut super::super::system::VirtualKey) -> HRESULT,
    #[cfg(feature="windows-system")] fn put_ToggleGameBarKeyModifiers(&self, value: super::super::system::VirtualKeyModifiers) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_ToggleGameBarKeyModifiers(&self, out: *mut super::super::system::VirtualKeyModifiers) -> HRESULT,
    #[cfg(feature="windows-system")] fn put_SaveHistoricalVideoKey(&self, value: super::super::system::VirtualKey) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_SaveHistoricalVideoKey(&self, out: *mut super::super::system::VirtualKey) -> HRESULT,
    #[cfg(feature="windows-system")] fn put_SaveHistoricalVideoKeyModifiers(&self, value: super::super::system::VirtualKeyModifiers) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_SaveHistoricalVideoKeyModifiers(&self, out: *mut super::super::system::VirtualKeyModifiers) -> HRESULT,
    #[cfg(feature="windows-system")] fn put_ToggleRecordingKey(&self, value: super::super::system::VirtualKey) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_ToggleRecordingKey(&self, out: *mut super::super::system::VirtualKey) -> HRESULT,
    #[cfg(feature="windows-system")] fn put_ToggleRecordingKeyModifiers(&self, value: super::super::system::VirtualKeyModifiers) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_ToggleRecordingKeyModifiers(&self, out: *mut super::super::system::VirtualKeyModifiers) -> HRESULT,
    #[cfg(feature="windows-system")] fn put_TakeScreenshotKey(&self, value: super::super::system::VirtualKey) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_TakeScreenshotKey(&self, out: *mut super::super::system::VirtualKey) -> HRESULT,
    #[cfg(feature="windows-system")] fn put_TakeScreenshotKeyModifiers(&self, value: super::super::system::VirtualKeyModifiers) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_TakeScreenshotKeyModifiers(&self, out: *mut super::super::system::VirtualKeyModifiers) -> HRESULT,
    #[cfg(feature="windows-system")] fn put_ToggleRecordingIndicatorKey(&self, value: super::super::system::VirtualKey) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_ToggleRecordingIndicatorKey(&self, out: *mut super::super::system::VirtualKey) -> HRESULT,
    #[cfg(feature="windows-system")] fn put_ToggleRecordingIndicatorKeyModifiers(&self, value: super::super::system::VirtualKeyModifiers) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_ToggleRecordingIndicatorKeyModifiers(&self, out: *mut super::super::system::VirtualKeyModifiers) -> HRESULT
}}
impl IAppCaptureAlternateShortcutKeys {
    #[cfg(feature="windows-system")] #[inline] pub fn set_toggle_game_bar_key(&self, value: super::super::system::VirtualKey) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ToggleGameBarKey)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_toggle_game_bar_key(&self) -> Result<super::super::system::VirtualKey> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ToggleGameBarKey)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn set_toggle_game_bar_key_modifiers(&self, value: super::super::system::VirtualKeyModifiers) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ToggleGameBarKeyModifiers)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_toggle_game_bar_key_modifiers(&self) -> Result<super::super::system::VirtualKeyModifiers> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ToggleGameBarKeyModifiers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn set_save_historical_video_key(&self, value: super::super::system::VirtualKey) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SaveHistoricalVideoKey)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_save_historical_video_key(&self) -> Result<super::super::system::VirtualKey> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SaveHistoricalVideoKey)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn set_save_historical_video_key_modifiers(&self, value: super::super::system::VirtualKeyModifiers) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SaveHistoricalVideoKeyModifiers)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_save_historical_video_key_modifiers(&self) -> Result<super::super::system::VirtualKeyModifiers> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SaveHistoricalVideoKeyModifiers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn set_toggle_recording_key(&self, value: super::super::system::VirtualKey) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ToggleRecordingKey)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_toggle_recording_key(&self) -> Result<super::super::system::VirtualKey> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ToggleRecordingKey)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn set_toggle_recording_key_modifiers(&self, value: super::super::system::VirtualKeyModifiers) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ToggleRecordingKeyModifiers)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_toggle_recording_key_modifiers(&self) -> Result<super::super::system::VirtualKeyModifiers> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ToggleRecordingKeyModifiers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn set_take_screenshot_key(&self, value: super::super::system::VirtualKey) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_TakeScreenshotKey)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_take_screenshot_key(&self) -> Result<super::super::system::VirtualKey> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TakeScreenshotKey)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn set_take_screenshot_key_modifiers(&self, value: super::super::system::VirtualKeyModifiers) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_TakeScreenshotKeyModifiers)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_take_screenshot_key_modifiers(&self) -> Result<super::super::system::VirtualKeyModifiers> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TakeScreenshotKeyModifiers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn set_toggle_recording_indicator_key(&self, value: super::super::system::VirtualKey) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ToggleRecordingIndicatorKey)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_toggle_recording_indicator_key(&self) -> Result<super::super::system::VirtualKey> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ToggleRecordingIndicatorKey)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn set_toggle_recording_indicator_key_modifiers(&self, value: super::super::system::VirtualKeyModifiers) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ToggleRecordingIndicatorKeyModifiers)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_toggle_recording_indicator_key_modifiers(&self) -> Result<super::super::system::VirtualKeyModifiers> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ToggleRecordingIndicatorKeyModifiers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppCaptureAlternateShortcutKeys: IAppCaptureAlternateShortcutKeys}
DEFINE_IID!(IID_IAppCaptureAlternateShortcutKeys2, 3278278800, 56599, 18416, 149, 229, 206, 66, 40, 108, 243, 56);
RT_INTERFACE!{interface IAppCaptureAlternateShortcutKeys2(IAppCaptureAlternateShortcutKeys2Vtbl, IAppCaptureAlternateShortcutKeys2_Abi): IInspectable(IInspectableVtbl) [IID_IAppCaptureAlternateShortcutKeys2] {
    #[cfg(feature="windows-system")] fn put_ToggleMicrophoneCaptureKey(&self, value: super::super::system::VirtualKey) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_ToggleMicrophoneCaptureKey(&self, out: *mut super::super::system::VirtualKey) -> HRESULT,
    #[cfg(feature="windows-system")] fn put_ToggleMicrophoneCaptureKeyModifiers(&self, value: super::super::system::VirtualKeyModifiers) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_ToggleMicrophoneCaptureKeyModifiers(&self, out: *mut super::super::system::VirtualKeyModifiers) -> HRESULT
}}
impl IAppCaptureAlternateShortcutKeys2 {
    #[cfg(feature="windows-system")] #[inline] pub fn set_toggle_microphone_capture_key(&self, value: super::super::system::VirtualKey) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ToggleMicrophoneCaptureKey)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_toggle_microphone_capture_key(&self) -> Result<super::super::system::VirtualKey> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ToggleMicrophoneCaptureKey)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn set_toggle_microphone_capture_key_modifiers(&self, value: super::super::system::VirtualKeyModifiers) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ToggleMicrophoneCaptureKeyModifiers)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_toggle_microphone_capture_key_modifiers(&self) -> Result<super::super::system::VirtualKeyModifiers> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ToggleMicrophoneCaptureKeyModifiers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppCaptureAlternateShortcutKeys3, 2072069260, 16782, 18076, 164, 154, 69, 181, 151, 200, 38, 182);
RT_INTERFACE!{interface IAppCaptureAlternateShortcutKeys3(IAppCaptureAlternateShortcutKeys3Vtbl, IAppCaptureAlternateShortcutKeys3_Abi): IInspectable(IInspectableVtbl) [IID_IAppCaptureAlternateShortcutKeys3] {
    #[cfg(feature="windows-system")] fn put_ToggleCameraCaptureKey(&self, value: super::super::system::VirtualKey) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_ToggleCameraCaptureKey(&self, out: *mut super::super::system::VirtualKey) -> HRESULT,
    #[cfg(feature="windows-system")] fn put_ToggleCameraCaptureKeyModifiers(&self, value: super::super::system::VirtualKeyModifiers) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_ToggleCameraCaptureKeyModifiers(&self, out: *mut super::super::system::VirtualKeyModifiers) -> HRESULT,
    #[cfg(feature="windows-system")] fn put_ToggleBroadcastKey(&self, value: super::super::system::VirtualKey) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_ToggleBroadcastKey(&self, out: *mut super::super::system::VirtualKey) -> HRESULT,
    #[cfg(feature="windows-system")] fn put_ToggleBroadcastKeyModifiers(&self, value: super::super::system::VirtualKeyModifiers) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_ToggleBroadcastKeyModifiers(&self, out: *mut super::super::system::VirtualKeyModifiers) -> HRESULT
}}
impl IAppCaptureAlternateShortcutKeys3 {
    #[cfg(feature="windows-system")] #[inline] pub fn set_toggle_camera_capture_key(&self, value: super::super::system::VirtualKey) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ToggleCameraCaptureKey)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_toggle_camera_capture_key(&self) -> Result<super::super::system::VirtualKey> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ToggleCameraCaptureKey)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn set_toggle_camera_capture_key_modifiers(&self, value: super::super::system::VirtualKeyModifiers) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ToggleCameraCaptureKeyModifiers)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_toggle_camera_capture_key_modifiers(&self) -> Result<super::super::system::VirtualKeyModifiers> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ToggleCameraCaptureKeyModifiers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn set_toggle_broadcast_key(&self, value: super::super::system::VirtualKey) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ToggleBroadcastKey)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_toggle_broadcast_key(&self) -> Result<super::super::system::VirtualKey> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ToggleBroadcastKey)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn set_toggle_broadcast_key_modifiers(&self, value: super::super::system::VirtualKeyModifiers) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ToggleBroadcastKeyModifiers)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_toggle_broadcast_key_modifiers(&self) -> Result<super::super::system::VirtualKeyModifiers> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ToggleBroadcastKeyModifiers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppCaptureDurationGeneratedEventArgs, 3254081083, 65441, 17609, 151, 95, 39, 251, 235, 85, 59, 53);
RT_INTERFACE!{interface IAppCaptureDurationGeneratedEventArgs(IAppCaptureDurationGeneratedEventArgsVtbl, IAppCaptureDurationGeneratedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAppCaptureDurationGeneratedEventArgs] {
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT
}}
impl IAppCaptureDurationGeneratedEventArgs {
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppCaptureDurationGeneratedEventArgs: IAppCaptureDurationGeneratedEventArgs}
DEFINE_IID!(IID_IAppCaptureFileGeneratedEventArgs, 1099561972, 18014, 17855, 144, 127, 22, 91, 63, 178, 55, 88);
RT_INTERFACE!{interface IAppCaptureFileGeneratedEventArgs(IAppCaptureFileGeneratedEventArgsVtbl, IAppCaptureFileGeneratedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAppCaptureFileGeneratedEventArgs] {
    #[cfg(feature="windows-storage")] fn get_File(&self, out: *mut <super::super::storage::StorageFile as RtType>::Abi) -> HRESULT
}}
impl IAppCaptureFileGeneratedEventArgs {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_file(&self) -> Result<Option<super::super::storage::StorageFile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_File)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::StorageFile::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppCaptureFileGeneratedEventArgs: IAppCaptureFileGeneratedEventArgs}
RT_ENUM! { enum AppCaptureHistoricalBufferLengthUnit: i32 {
    Megabytes = 0, Seconds = 1,
}}
RT_CLASS!{static class AppCaptureManager}
impl RtActivatable<IAppCaptureManagerStatics> for AppCaptureManager {}
impl AppCaptureManager {
    #[inline] pub fn get_current_settings() -> Result<Option<AppCaptureSettings>> {
        <Self as RtActivatable<IAppCaptureManagerStatics>>::get_activation_factory().get_current_settings()
    }
    #[inline] pub fn apply_settings(appCaptureSettings: &AppCaptureSettings) -> Result<()> {
        <Self as RtActivatable<IAppCaptureManagerStatics>>::get_activation_factory().apply_settings(appCaptureSettings)
    }
}
DEFINE_CLSID!(AppCaptureManager(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,97,112,116,117,114,101,46,65,112,112,67,97,112,116,117,114,101,77,97,110,97,103,101,114,0]) [CLSID_AppCaptureManager]);
DEFINE_IID!(IID_IAppCaptureManagerStatics, 2107522727, 25218, 18229, 141, 78, 170, 69, 249, 15, 103, 35);
RT_INTERFACE!{static interface IAppCaptureManagerStatics(IAppCaptureManagerStaticsVtbl, IAppCaptureManagerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IAppCaptureManagerStatics] {
    fn GetCurrentSettings(&self, out: *mut <AppCaptureSettings as RtType>::Abi) -> HRESULT,
    fn ApplySettings(&self, appCaptureSettings: <AppCaptureSettings as RtType>::Abi) -> HRESULT
}}
impl IAppCaptureManagerStatics {
    #[inline] pub fn get_current_settings(&self) -> Result<Option<AppCaptureSettings>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCurrentSettings)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppCaptureSettings::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn apply_settings(&self, appCaptureSettings: &AppCaptureSettings) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ApplySettings)(self.0.as_abi() as *const _ as *mut _, get_abi(appCaptureSettings) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum AppCaptureMetadataPriority: i32 {
    Informational = 0, Important = 1,
}}
DEFINE_IID!(IID_IAppCaptureMetadataWriter, 3771615351, 39599, 18100, 173, 49, 106, 96, 180, 65, 199, 128);
RT_INTERFACE!{interface IAppCaptureMetadataWriter(IAppCaptureMetadataWriterVtbl, IAppCaptureMetadataWriter_Abi): IInspectable(IInspectableVtbl) [IID_IAppCaptureMetadataWriter] {
    fn AddStringEvent(&self, name: HSTRING, value: HSTRING, priority: AppCaptureMetadataPriority) -> HRESULT,
    fn AddInt32Event(&self, name: HSTRING, value: i32, priority: AppCaptureMetadataPriority) -> HRESULT,
    fn AddDoubleEvent(&self, name: HSTRING, value: f64, priority: AppCaptureMetadataPriority) -> HRESULT,
    fn StartStringState(&self, name: HSTRING, value: HSTRING, priority: AppCaptureMetadataPriority) -> HRESULT,
    fn StartInt32State(&self, name: HSTRING, value: i32, priority: AppCaptureMetadataPriority) -> HRESULT,
    fn StartDoubleState(&self, name: HSTRING, value: f64, priority: AppCaptureMetadataPriority) -> HRESULT,
    fn StopState(&self, name: HSTRING) -> HRESULT,
    fn StopAllStates(&self) -> HRESULT,
    fn get_RemainingStorageBytesAvailable(&self, out: *mut u64) -> HRESULT,
    fn add_MetadataPurged(&self, handler: <foundation::TypedEventHandler<AppCaptureMetadataWriter, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MetadataPurged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAppCaptureMetadataWriter {
    #[inline] pub fn add_string_event(&self, name: &HStringArg, value: &HStringArg, priority: AppCaptureMetadataPriority) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AddStringEvent)(self.0.as_abi() as *const _ as *mut _, name.get(), value.get(), priority);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_int32_event(&self, name: &HStringArg, value: i32, priority: AppCaptureMetadataPriority) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AddInt32Event)(self.0.as_abi() as *const _ as *mut _, name.get(), value, priority);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_double_event(&self, name: &HStringArg, value: f64, priority: AppCaptureMetadataPriority) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AddDoubleEvent)(self.0.as_abi() as *const _ as *mut _, name.get(), value, priority);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_string_state(&self, name: &HStringArg, value: &HStringArg, priority: AppCaptureMetadataPriority) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).StartStringState)(self.0.as_abi() as *const _ as *mut _, name.get(), value.get(), priority);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_int32_state(&self, name: &HStringArg, value: i32, priority: AppCaptureMetadataPriority) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).StartInt32State)(self.0.as_abi() as *const _ as *mut _, name.get(), value, priority);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_double_state(&self, name: &HStringArg, value: f64, priority: AppCaptureMetadataPriority) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).StartDoubleState)(self.0.as_abi() as *const _ as *mut _, name.get(), value, priority);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop_state(&self, name: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).StopState)(self.0.as_abi() as *const _ as *mut _, name.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop_all_states(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).StopAllStates)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_remaining_storage_bytes_available(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RemainingStorageBytesAvailable)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_metadata_purged(&self, handler: &foundation::TypedEventHandler<AppCaptureMetadataWriter, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_MetadataPurged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_metadata_purged(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_MetadataPurged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppCaptureMetadataWriter: IAppCaptureMetadataWriter}
impl RtActivatable<IActivationFactory> for AppCaptureMetadataWriter {}
DEFINE_CLSID!(AppCaptureMetadataWriter(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,97,112,116,117,114,101,46,65,112,112,67,97,112,116,117,114,101,77,101,116,97,100,97,116,97,87,114,105,116,101,114,0]) [CLSID_AppCaptureMetadataWriter]);
RT_ENUM! { enum AppCaptureMicrophoneCaptureState: i32 {
    Stopped = 0, Started = 1, Failed = 2,
}}
DEFINE_IID!(IID_IAppCaptureMicrophoneCaptureStateChangedEventArgs, 843916446, 17852, 19509, 188, 53, 228, 105, 252, 122, 105, 224);
RT_INTERFACE!{interface IAppCaptureMicrophoneCaptureStateChangedEventArgs(IAppCaptureMicrophoneCaptureStateChangedEventArgsVtbl, IAppCaptureMicrophoneCaptureStateChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAppCaptureMicrophoneCaptureStateChangedEventArgs] {
    fn get_State(&self, out: *mut AppCaptureMicrophoneCaptureState) -> HRESULT,
    fn get_ErrorCode(&self, out: *mut u32) -> HRESULT
}}
impl IAppCaptureMicrophoneCaptureStateChangedEventArgs {
    #[inline] pub fn get_state(&self) -> Result<AppCaptureMicrophoneCaptureState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error_code(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ErrorCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppCaptureMicrophoneCaptureStateChangedEventArgs: IAppCaptureMicrophoneCaptureStateChangedEventArgs}
RT_ENUM! { enum AppCaptureRecordingState: i32 {
    InProgress = 0, Completed = 1, Failed = 2,
}}
DEFINE_IID!(IID_IAppCaptureRecordingStateChangedEventArgs, 620529426, 58117, 18701, 180, 21, 107, 28, 144, 73, 115, 107);
RT_INTERFACE!{interface IAppCaptureRecordingStateChangedEventArgs(IAppCaptureRecordingStateChangedEventArgsVtbl, IAppCaptureRecordingStateChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAppCaptureRecordingStateChangedEventArgs] {
    fn get_State(&self, out: *mut AppCaptureRecordingState) -> HRESULT,
    fn get_ErrorCode(&self, out: *mut u32) -> HRESULT
}}
impl IAppCaptureRecordingStateChangedEventArgs {
    #[inline] pub fn get_state(&self) -> Result<AppCaptureRecordingState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error_code(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ErrorCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppCaptureRecordingStateChangedEventArgs: IAppCaptureRecordingStateChangedEventArgs}
DEFINE_IID!(IID_IAppCaptureRecordOperation, 3328188585, 5432, 18780, 155, 187, 43, 168, 112, 236, 88, 97);
RT_INTERFACE!{interface IAppCaptureRecordOperation(IAppCaptureRecordOperationVtbl, IAppCaptureRecordOperation_Abi): IInspectable(IInspectableVtbl) [IID_IAppCaptureRecordOperation] {
    fn StopRecording(&self) -> HRESULT,
    fn get_State(&self, out: *mut AppCaptureRecordingState) -> HRESULT,
    fn get_ErrorCode(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_Duration(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_File(&self, out: *mut <super::super::storage::StorageFile as RtType>::Abi) -> HRESULT,
    fn get_IsFileTruncated(&self, out: *mut <foundation::IReference<bool> as RtType>::Abi) -> HRESULT,
    fn add_StateChanged(&self, value: <foundation::TypedEventHandler<AppCaptureRecordOperation, AppCaptureRecordingStateChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_DurationGenerated(&self, value: <foundation::TypedEventHandler<AppCaptureRecordOperation, AppCaptureDurationGeneratedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DurationGenerated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_FileGenerated(&self, value: <foundation::TypedEventHandler<AppCaptureRecordOperation, AppCaptureFileGeneratedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FileGenerated(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAppCaptureRecordOperation {
    #[inline] pub fn stop_recording(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).StopRecording)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_state(&self) -> Result<AppCaptureRecordingState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error_code(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ErrorCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_file(&self) -> Result<Option<super::super::storage::StorageFile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_File)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::StorageFile::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_file_truncated(&self) -> Result<Option<foundation::IReference<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsFileTruncated)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_state_changed(&self, value: &foundation::TypedEventHandler<AppCaptureRecordOperation, AppCaptureRecordingStateChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_duration_generated(&self, value: &foundation::TypedEventHandler<AppCaptureRecordOperation, AppCaptureDurationGeneratedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_DurationGenerated)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_duration_generated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_DurationGenerated)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_file_generated(&self, value: &foundation::TypedEventHandler<AppCaptureRecordOperation, AppCaptureFileGeneratedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_FileGenerated)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_file_generated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_FileGenerated)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppCaptureRecordOperation: IAppCaptureRecordOperation}
DEFINE_IID!(IID_IAppCaptureServices, 1157546165, 13557, 20248, 174, 140, 185, 18, 58, 187, 252, 13);
RT_INTERFACE!{interface IAppCaptureServices(IAppCaptureServicesVtbl, IAppCaptureServices_Abi): IInspectable(IInspectableVtbl) [IID_IAppCaptureServices] {
    fn Record(&self, out: *mut <AppCaptureRecordOperation as RtType>::Abi) -> HRESULT,
    fn RecordTimeSpan(&self, startTime: foundation::DateTime, duration: foundation::TimeSpan, out: *mut <AppCaptureRecordOperation as RtType>::Abi) -> HRESULT,
    fn get_CanCapture(&self, out: *mut bool) -> HRESULT,
    fn get_State(&self, out: *mut <AppCaptureState as RtType>::Abi) -> HRESULT
}}
impl IAppCaptureServices {
    #[inline] pub fn record(&self) -> Result<Option<AppCaptureRecordOperation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Record)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppCaptureRecordOperation::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn record_time_span(&self, startTime: foundation::DateTime, duration: foundation::TimeSpan) -> Result<Option<AppCaptureRecordOperation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RecordTimeSpan)(self.0.as_abi() as *const _ as *mut _, startTime, duration, &mut out);
        if hr == S_OK { Ok(AppCaptureRecordOperation::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_can_capture(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanCapture)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_state(&self) -> Result<Option<AppCaptureState>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppCaptureState::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AppCaptureServices: IAppCaptureServices}
DEFINE_IID!(IID_IAppCaptureSettings, 342375046, 34823, 18643, 136, 58, 151, 14, 228, 83, 42, 57);
RT_INTERFACE!{interface IAppCaptureSettings(IAppCaptureSettingsVtbl, IAppCaptureSettings_Abi): IInspectable(IInspectableVtbl) [IID_IAppCaptureSettings] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_AppCaptureDestinationFolder(&self, value: <super::super::storage::StorageFolder as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_AppCaptureDestinationFolder(&self, out: *mut <super::super::storage::StorageFolder as RtType>::Abi) -> HRESULT,
    fn put_AudioEncodingBitrate(&self, value: u32) -> HRESULT,
    fn get_AudioEncodingBitrate(&self, out: *mut u32) -> HRESULT,
    fn put_IsAudioCaptureEnabled(&self, value: bool) -> HRESULT,
    fn get_IsAudioCaptureEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_CustomVideoEncodingBitrate(&self, value: u32) -> HRESULT,
    fn get_CustomVideoEncodingBitrate(&self, out: *mut u32) -> HRESULT,
    fn put_CustomVideoEncodingHeight(&self, value: u32) -> HRESULT,
    fn get_CustomVideoEncodingHeight(&self, out: *mut u32) -> HRESULT,
    fn put_CustomVideoEncodingWidth(&self, value: u32) -> HRESULT,
    fn get_CustomVideoEncodingWidth(&self, out: *mut u32) -> HRESULT,
    fn put_HistoricalBufferLength(&self, value: u32) -> HRESULT,
    fn get_HistoricalBufferLength(&self, out: *mut u32) -> HRESULT,
    fn put_HistoricalBufferLengthUnit(&self, value: AppCaptureHistoricalBufferLengthUnit) -> HRESULT,
    fn get_HistoricalBufferLengthUnit(&self, out: *mut AppCaptureHistoricalBufferLengthUnit) -> HRESULT,
    fn put_IsHistoricalCaptureEnabled(&self, value: bool) -> HRESULT,
    fn get_IsHistoricalCaptureEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsHistoricalCaptureOnBatteryAllowed(&self, value: bool) -> HRESULT,
    fn get_IsHistoricalCaptureOnBatteryAllowed(&self, out: *mut bool) -> HRESULT,
    fn put_IsHistoricalCaptureOnWirelessDisplayAllowed(&self, value: bool) -> HRESULT,
    fn get_IsHistoricalCaptureOnWirelessDisplayAllowed(&self, out: *mut bool) -> HRESULT,
    fn put_MaximumRecordLength(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_MaximumRecordLength(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy24(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_ScreenshotDestinationFolder(&self, value: <super::super::storage::StorageFolder as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy25(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_ScreenshotDestinationFolder(&self, out: *mut <super::super::storage::StorageFolder as RtType>::Abi) -> HRESULT,
    fn put_VideoEncodingBitrateMode(&self, value: AppCaptureVideoEncodingBitrateMode) -> HRESULT,
    fn get_VideoEncodingBitrateMode(&self, out: *mut AppCaptureVideoEncodingBitrateMode) -> HRESULT,
    fn put_VideoEncodingResolutionMode(&self, value: AppCaptureVideoEncodingResolutionMode) -> HRESULT,
    fn get_VideoEncodingResolutionMode(&self, out: *mut AppCaptureVideoEncodingResolutionMode) -> HRESULT,
    fn put_IsAppCaptureEnabled(&self, value: bool) -> HRESULT,
    fn get_IsAppCaptureEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsCpuConstrained(&self, out: *mut bool) -> HRESULT,
    fn get_IsDisabledByPolicy(&self, out: *mut bool) -> HRESULT,
    fn get_IsMemoryConstrained(&self, out: *mut bool) -> HRESULT,
    fn get_HasHardwareEncoder(&self, out: *mut bool) -> HRESULT
}}
impl IAppCaptureSettings {
    #[cfg(feature="windows-storage")] #[inline] pub fn set_app_capture_destination_folder(&self, value: &super::super::storage::StorageFolder) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AppCaptureDestinationFolder)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_app_capture_destination_folder(&self) -> Result<Option<super::super::storage::StorageFolder>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AppCaptureDestinationFolder)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::StorageFolder::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_audio_encoding_bitrate(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AudioEncodingBitrate)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_encoding_bitrate(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioEncodingBitrate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_audio_capture_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsAudioCaptureEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_audio_capture_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsAudioCaptureEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_custom_video_encoding_bitrate(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CustomVideoEncodingBitrate)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_custom_video_encoding_bitrate(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CustomVideoEncodingBitrate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_custom_video_encoding_height(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CustomVideoEncodingHeight)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_custom_video_encoding_height(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CustomVideoEncodingHeight)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_custom_video_encoding_width(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CustomVideoEncodingWidth)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_custom_video_encoding_width(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CustomVideoEncodingWidth)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_historical_buffer_length(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_HistoricalBufferLength)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_historical_buffer_length(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HistoricalBufferLength)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_historical_buffer_length_unit(&self, value: AppCaptureHistoricalBufferLengthUnit) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_HistoricalBufferLengthUnit)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_historical_buffer_length_unit(&self) -> Result<AppCaptureHistoricalBufferLengthUnit> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HistoricalBufferLengthUnit)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_historical_capture_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsHistoricalCaptureEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_historical_capture_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsHistoricalCaptureEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_historical_capture_on_battery_allowed(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsHistoricalCaptureOnBatteryAllowed)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_historical_capture_on_battery_allowed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsHistoricalCaptureOnBatteryAllowed)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_historical_capture_on_wireless_display_allowed(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsHistoricalCaptureOnWirelessDisplayAllowed)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_historical_capture_on_wireless_display_allowed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsHistoricalCaptureOnWirelessDisplayAllowed)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_maximum_record_length(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MaximumRecordLength)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_maximum_record_length(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaximumRecordLength)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_screenshot_destination_folder(&self, value: &super::super::storage::StorageFolder) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ScreenshotDestinationFolder)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_screenshot_destination_folder(&self) -> Result<Option<super::super::storage::StorageFolder>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ScreenshotDestinationFolder)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::StorageFolder::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_video_encoding_bitrate_mode(&self, value: AppCaptureVideoEncodingBitrateMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_VideoEncodingBitrateMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_video_encoding_bitrate_mode(&self) -> Result<AppCaptureVideoEncodingBitrateMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoEncodingBitrateMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_video_encoding_resolution_mode(&self, value: AppCaptureVideoEncodingResolutionMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_VideoEncodingResolutionMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_video_encoding_resolution_mode(&self) -> Result<AppCaptureVideoEncodingResolutionMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoEncodingResolutionMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_app_capture_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsAppCaptureEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_app_capture_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsAppCaptureEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_cpu_constrained(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCpuConstrained)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_disabled_by_policy(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDisabledByPolicy)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_memory_constrained(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsMemoryConstrained)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_has_hardware_encoder(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HasHardwareEncoder)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AppCaptureSettings: IAppCaptureSettings}
DEFINE_IID!(IID_IAppCaptureSettings2, 4239970023, 57963, 18287, 155, 26, 236, 52, 45, 42, 143, 222);
RT_INTERFACE!{interface IAppCaptureSettings2(IAppCaptureSettings2Vtbl, IAppCaptureSettings2_Abi): IInspectable(IInspectableVtbl) [IID_IAppCaptureSettings2] {
    fn get_IsGpuConstrained(&self, out: *mut bool) -> HRESULT,
    fn get_AlternateShortcutKeys(&self, out: *mut <AppCaptureAlternateShortcutKeys as RtType>::Abi) -> HRESULT
}}
impl IAppCaptureSettings2 {
    #[inline] pub fn get_is_gpu_constrained(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsGpuConstrained)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_alternate_shortcut_keys(&self) -> Result<Option<AppCaptureAlternateShortcutKeys>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AlternateShortcutKeys)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppCaptureAlternateShortcutKeys::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppCaptureSettings3, 2838823678, 35010, 17110, 170, 170, 64, 254, 255, 215, 90, 236);
RT_INTERFACE!{interface IAppCaptureSettings3(IAppCaptureSettings3Vtbl, IAppCaptureSettings3_Abi): IInspectable(IInspectableVtbl) [IID_IAppCaptureSettings3] {
    fn put_IsMicrophoneCaptureEnabled(&self, value: bool) -> HRESULT,
    fn get_IsMicrophoneCaptureEnabled(&self, out: *mut bool) -> HRESULT
}}
impl IAppCaptureSettings3 {
    #[inline] pub fn set_is_microphone_capture_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsMicrophoneCaptureEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_microphone_capture_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsMicrophoneCaptureEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppCaptureSettings4, 130185036, 6785, 18479, 162, 68, 4, 157, 149, 242, 91, 11);
RT_INTERFACE!{interface IAppCaptureSettings4(IAppCaptureSettings4Vtbl, IAppCaptureSettings4_Abi): IInspectable(IInspectableVtbl) [IID_IAppCaptureSettings4] {
    fn put_IsMicrophoneCaptureEnabledByDefault(&self, value: bool) -> HRESULT,
    fn get_IsMicrophoneCaptureEnabledByDefault(&self, out: *mut bool) -> HRESULT,
    fn put_SystemAudioGain(&self, value: f64) -> HRESULT,
    fn get_SystemAudioGain(&self, out: *mut f64) -> HRESULT,
    fn put_MicrophoneGain(&self, value: f64) -> HRESULT,
    fn get_MicrophoneGain(&self, out: *mut f64) -> HRESULT,
    fn put_VideoEncodingFrameRateMode(&self, value: AppCaptureVideoEncodingFrameRateMode) -> HRESULT,
    fn get_VideoEncodingFrameRateMode(&self, out: *mut AppCaptureVideoEncodingFrameRateMode) -> HRESULT
}}
impl IAppCaptureSettings4 {
    #[inline] pub fn set_is_microphone_capture_enabled_by_default(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsMicrophoneCaptureEnabledByDefault)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_microphone_capture_enabled_by_default(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsMicrophoneCaptureEnabledByDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_system_audio_gain(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SystemAudioGain)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_system_audio_gain(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SystemAudioGain)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_microphone_gain(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MicrophoneGain)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_microphone_gain(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MicrophoneGain)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_video_encoding_frame_rate_mode(&self, value: AppCaptureVideoEncodingFrameRateMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_VideoEncodingFrameRateMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_video_encoding_frame_rate_mode(&self) -> Result<AppCaptureVideoEncodingFrameRateMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoEncodingFrameRateMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppCaptureSettings5, 411649314, 45288, 19360, 143, 19, 62, 170, 95, 164, 1, 59);
RT_INTERFACE!{interface IAppCaptureSettings5(IAppCaptureSettings5Vtbl, IAppCaptureSettings5_Abi): IInspectable(IInspectableVtbl) [IID_IAppCaptureSettings5] {
    fn put_IsEchoCancellationEnabled(&self, value: bool) -> HRESULT,
    fn get_IsEchoCancellationEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsCursorImageCaptureEnabled(&self, value: bool) -> HRESULT,
    fn get_IsCursorImageCaptureEnabled(&self, out: *mut bool) -> HRESULT
}}
impl IAppCaptureSettings5 {
    #[inline] pub fn set_is_echo_cancellation_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsEchoCancellationEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_echo_cancellation_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsEchoCancellationEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_cursor_image_capture_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsCursorImageCaptureEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_cursor_image_capture_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCursorImageCaptureEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppCaptureState, 1930642290, 54507, 17614, 149, 56, 70, 95, 80, 106, 196, 234);
RT_INTERFACE!{interface IAppCaptureState(IAppCaptureStateVtbl, IAppCaptureState_Abi): IInspectable(IInspectableVtbl) [IID_IAppCaptureState] {
    fn get_IsTargetRunning(&self, out: *mut bool) -> HRESULT,
    fn get_IsHistoricalCaptureEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_ShouldCaptureMicrophone(&self, out: *mut bool) -> HRESULT,
    fn put_ShouldCaptureMicrophone(&self, value: bool) -> HRESULT,
    fn RestartMicrophoneCapture(&self) -> HRESULT,
    fn get_MicrophoneCaptureState(&self, out: *mut AppCaptureMicrophoneCaptureState) -> HRESULT,
    fn get_MicrophoneCaptureError(&self, out: *mut u32) -> HRESULT,
    fn add_MicrophoneCaptureStateChanged(&self, value: <foundation::TypedEventHandler<AppCaptureState, AppCaptureMicrophoneCaptureStateChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MicrophoneCaptureStateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CaptureTargetClosed(&self, value: <foundation::TypedEventHandler<AppCaptureState, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CaptureTargetClosed(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAppCaptureState {
    #[inline] pub fn get_is_target_running(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsTargetRunning)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_historical_capture_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsHistoricalCaptureEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_should_capture_microphone(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ShouldCaptureMicrophone)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_should_capture_microphone(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ShouldCaptureMicrophone)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn restart_microphone_capture(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RestartMicrophoneCapture)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_microphone_capture_state(&self) -> Result<AppCaptureMicrophoneCaptureState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MicrophoneCaptureState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_microphone_capture_error(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MicrophoneCaptureError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_microphone_capture_state_changed(&self, value: &foundation::TypedEventHandler<AppCaptureState, AppCaptureMicrophoneCaptureStateChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_MicrophoneCaptureStateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_microphone_capture_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_MicrophoneCaptureStateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_capture_target_closed(&self, value: &foundation::TypedEventHandler<AppCaptureState, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_CaptureTargetClosed)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_capture_target_closed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_CaptureTargetClosed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AppCaptureState: IAppCaptureState}
DEFINE_IID!(IID_IAppCaptureStatics, 4179811692, 2686, 20084, 139, 32, 156, 31, 144, 45, 8, 161);
RT_INTERFACE!{static interface IAppCaptureStatics(IAppCaptureStaticsVtbl, IAppCaptureStatics_Abi): IInspectable(IInspectableVtbl) [IID_IAppCaptureStatics] {
    fn GetForCurrentView(&self, out: *mut <AppCapture as RtType>::Abi) -> HRESULT
}}
impl IAppCaptureStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<AppCapture>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetForCurrentView)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppCapture::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAppCaptureStatics2, 3000533460, 33644, 19876, 175, 215, 250, 204, 4, 30, 28, 243);
RT_INTERFACE!{static interface IAppCaptureStatics2(IAppCaptureStatics2Vtbl, IAppCaptureStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IAppCaptureStatics2] {
    fn SetAllowedAsync(&self, allowed: bool, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IAppCaptureStatics2 {
    #[inline] pub fn set_allowed_async(&self, allowed: bool) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetAllowedAsync)(self.0.as_abi() as *const _ as *mut _, allowed, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum AppCaptureVideoEncodingBitrateMode: i32 {
    Custom = 0, High = 1, Standard = 2,
}}
RT_ENUM! { enum AppCaptureVideoEncodingFrameRateMode: i32 {
    Standard = 0, High = 1,
}}
RT_ENUM! { enum AppCaptureVideoEncodingResolutionMode: i32 {
    Custom = 0, High = 1, Standard = 2,
}}
DEFINE_IID!(IID_ICameraCaptureUI, 1213756736, 28563, 19380, 184, 243, 232, 158, 72, 148, 140, 145);
RT_INTERFACE!{interface ICameraCaptureUI(ICameraCaptureUIVtbl, ICameraCaptureUI_Abi): IInspectable(IInspectableVtbl) [IID_ICameraCaptureUI] {
    fn get_PhotoSettings(&self, out: *mut <CameraCaptureUIPhotoCaptureSettings as RtType>::Abi) -> HRESULT,
    fn get_VideoSettings(&self, out: *mut <CameraCaptureUIVideoCaptureSettings as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn CaptureFileAsync(&self, mode: CameraCaptureUIMode, out: *mut <foundation::IAsyncOperation<super::super::storage::StorageFile> as RtType>::Abi) -> HRESULT
}}
impl ICameraCaptureUI {
    #[inline] pub fn get_photo_settings(&self) -> Result<Option<CameraCaptureUIPhotoCaptureSettings>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhotoSettings)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CameraCaptureUIPhotoCaptureSettings::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_settings(&self) -> Result<Option<CameraCaptureUIVideoCaptureSettings>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoSettings)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CameraCaptureUIVideoCaptureSettings::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn capture_file_async(&self, mode: CameraCaptureUIMode) -> Result<foundation::IAsyncOperation<super::super::storage::StorageFile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CaptureFileAsync)(self.0.as_abi() as *const _ as *mut _, mode, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CameraCaptureUI: ICameraCaptureUI}
impl RtActivatable<IActivationFactory> for CameraCaptureUI {}
DEFINE_CLSID!(CameraCaptureUI(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,97,112,116,117,114,101,46,67,97,109,101,114,97,67,97,112,116,117,114,101,85,73,0]) [CLSID_CameraCaptureUI]);
RT_ENUM! { enum CameraCaptureUIMaxPhotoResolution: i32 {
    HighestAvailable = 0, VerySmallQvga = 1, SmallVga = 2, MediumXga = 3, Large3M = 4, VeryLarge5M = 5,
}}
RT_ENUM! { enum CameraCaptureUIMaxVideoResolution: i32 {
    HighestAvailable = 0, LowDefinition = 1, StandardDefinition = 2, HighDefinition = 3,
}}
RT_ENUM! { enum CameraCaptureUIMode: i32 {
    PhotoOrVideo = 0, Photo = 1, Video = 2,
}}
DEFINE_IID!(IID_ICameraCaptureUIPhotoCaptureSettings, 3119890071, 13426, 18088, 138, 158, 4, 206, 66, 204, 201, 125);
RT_INTERFACE!{interface ICameraCaptureUIPhotoCaptureSettings(ICameraCaptureUIPhotoCaptureSettingsVtbl, ICameraCaptureUIPhotoCaptureSettings_Abi): IInspectable(IInspectableVtbl) [IID_ICameraCaptureUIPhotoCaptureSettings] {
    fn get_Format(&self, out: *mut CameraCaptureUIPhotoFormat) -> HRESULT,
    fn put_Format(&self, value: CameraCaptureUIPhotoFormat) -> HRESULT,
    fn get_MaxResolution(&self, out: *mut CameraCaptureUIMaxPhotoResolution) -> HRESULT,
    fn put_MaxResolution(&self, value: CameraCaptureUIMaxPhotoResolution) -> HRESULT,
    fn get_CroppedSizeInPixels(&self, out: *mut foundation::Size) -> HRESULT,
    fn put_CroppedSizeInPixels(&self, value: foundation::Size) -> HRESULT,
    fn get_CroppedAspectRatio(&self, out: *mut foundation::Size) -> HRESULT,
    fn put_CroppedAspectRatio(&self, value: foundation::Size) -> HRESULT,
    fn get_AllowCropping(&self, out: *mut bool) -> HRESULT,
    fn put_AllowCropping(&self, value: bool) -> HRESULT
}}
impl ICameraCaptureUIPhotoCaptureSettings {
    #[inline] pub fn get_format(&self) -> Result<CameraCaptureUIPhotoFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Format)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_format(&self, value: CameraCaptureUIPhotoFormat) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Format)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_resolution(&self) -> Result<CameraCaptureUIMaxPhotoResolution> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxResolution)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_max_resolution(&self, value: CameraCaptureUIMaxPhotoResolution) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MaxResolution)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cropped_size_in_pixels(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CroppedSizeInPixels)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_cropped_size_in_pixels(&self, value: foundation::Size) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CroppedSizeInPixels)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cropped_aspect_ratio(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CroppedAspectRatio)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_cropped_aspect_ratio(&self, value: foundation::Size) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CroppedAspectRatio)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_allow_cropping(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AllowCropping)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_allow_cropping(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AllowCropping)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CameraCaptureUIPhotoCaptureSettings: ICameraCaptureUIPhotoCaptureSettings}
RT_ENUM! { enum CameraCaptureUIPhotoFormat: i32 {
    Jpeg = 0, Png = 1, JpegXR = 2,
}}
DEFINE_IID!(IID_ICameraCaptureUIVideoCaptureSettings, 1693003039, 41613, 16986, 184, 79, 229, 104, 51, 95, 242, 78);
RT_INTERFACE!{interface ICameraCaptureUIVideoCaptureSettings(ICameraCaptureUIVideoCaptureSettingsVtbl, ICameraCaptureUIVideoCaptureSettings_Abi): IInspectable(IInspectableVtbl) [IID_ICameraCaptureUIVideoCaptureSettings] {
    fn get_Format(&self, out: *mut CameraCaptureUIVideoFormat) -> HRESULT,
    fn put_Format(&self, value: CameraCaptureUIVideoFormat) -> HRESULT,
    fn get_MaxResolution(&self, out: *mut CameraCaptureUIMaxVideoResolution) -> HRESULT,
    fn put_MaxResolution(&self, value: CameraCaptureUIMaxVideoResolution) -> HRESULT,
    fn get_MaxDurationInSeconds(&self, out: *mut f32) -> HRESULT,
    fn put_MaxDurationInSeconds(&self, value: f32) -> HRESULT,
    fn get_AllowTrimming(&self, out: *mut bool) -> HRESULT,
    fn put_AllowTrimming(&self, value: bool) -> HRESULT
}}
impl ICameraCaptureUIVideoCaptureSettings {
    #[inline] pub fn get_format(&self) -> Result<CameraCaptureUIVideoFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Format)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_format(&self, value: CameraCaptureUIVideoFormat) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Format)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_resolution(&self) -> Result<CameraCaptureUIMaxVideoResolution> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxResolution)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_max_resolution(&self, value: CameraCaptureUIMaxVideoResolution) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MaxResolution)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_duration_in_seconds(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxDurationInSeconds)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_max_duration_in_seconds(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MaxDurationInSeconds)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_allow_trimming(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AllowTrimming)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_allow_trimming(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AllowTrimming)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CameraCaptureUIVideoCaptureSettings: ICameraCaptureUIVideoCaptureSettings}
RT_ENUM! { enum CameraCaptureUIVideoFormat: i32 {
    Mp4 = 0, Wmv = 1,
}}
RT_CLASS!{static class CameraOptionsUI}
impl RtActivatable<ICameraOptionsUIStatics> for CameraOptionsUI {}
impl CameraOptionsUI {
    #[inline] pub fn show(mediaCapture: &MediaCapture) -> Result<()> {
        <Self as RtActivatable<ICameraOptionsUIStatics>>::get_activation_factory().show(mediaCapture)
    }
}
DEFINE_CLSID!(CameraOptionsUI(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,97,112,116,117,114,101,46,67,97,109,101,114,97,79,112,116,105,111,110,115,85,73,0]) [CLSID_CameraOptionsUI]);
DEFINE_IID!(IID_ICameraOptionsUIStatics, 990731828, 14598, 19325, 148, 108, 123, 222, 132, 68, 153, 174);
RT_INTERFACE!{static interface ICameraOptionsUIStatics(ICameraOptionsUIStaticsVtbl, ICameraOptionsUIStatics_Abi): IInspectable(IInspectableVtbl) [IID_ICameraOptionsUIStatics] {
    fn Show(&self, mediaCapture: <MediaCapture as RtType>::Abi) -> HRESULT
}}
impl ICameraOptionsUIStatics {
    #[inline] pub fn show(&self, mediaCapture: &MediaCapture) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Show)(self.0.as_abi() as *const _ as *mut _, get_abi(mediaCapture) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICapturedFrame, 500358687, 22299, 17624, 142, 128, 160, 138, 21, 120, 118, 110);
RT_INTERFACE!{interface ICapturedFrame(ICapturedFrameVtbl, ICapturedFrame_Abi): IInspectable(IInspectableVtbl) [IID_ICapturedFrame] {
    fn get_Width(&self, out: *mut u32) -> HRESULT,
    fn get_Height(&self, out: *mut u32) -> HRESULT
}}
impl ICapturedFrame {
    #[inline] pub fn get_width(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Width)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_height(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Height)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CapturedFrame: ICapturedFrame}
DEFINE_IID!(IID_ICapturedFrame2, 1413457617, 48504, 18534, 173, 218, 36, 49, 75, 198, 93, 234);
RT_INTERFACE!{interface ICapturedFrame2(ICapturedFrame2Vtbl, ICapturedFrame2_Abi): IInspectable(IInspectableVtbl) [IID_ICapturedFrame2] {
    fn get_ControlValues(&self, out: *mut <CapturedFrameControlValues as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn get_BitmapProperties(&self, out: *mut <super::super::graphics::imaging::BitmapPropertySet as RtType>::Abi) -> HRESULT
}}
impl ICapturedFrame2 {
    #[inline] pub fn get_control_values(&self) -> Result<Option<CapturedFrameControlValues>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ControlValues)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CapturedFrameControlValues::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_bitmap_properties(&self) -> Result<Option<super::super::graphics::imaging::BitmapPropertySet>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BitmapProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::graphics::imaging::BitmapPropertySet::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICapturedFrameControlValues, 2428918655, 19981, 19620, 136, 45, 122, 20, 79, 237, 10, 144);
RT_INTERFACE!{interface ICapturedFrameControlValues(ICapturedFrameControlValuesVtbl, ICapturedFrameControlValues_Abi): IInspectable(IInspectableVtbl) [IID_ICapturedFrameControlValues] {
    fn get_Exposure(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_ExposureCompensation(&self, out: *mut <foundation::IReference<f32> as RtType>::Abi) -> HRESULT,
    fn get_IsoSpeed(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_Focus(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_SceneMode(&self, out: *mut <foundation::IReference<super::devices::CaptureSceneMode> as RtType>::Abi) -> HRESULT,
    fn get_Flashed(&self, out: *mut <foundation::IReference<bool> as RtType>::Abi) -> HRESULT,
    fn get_FlashPowerPercent(&self, out: *mut <foundation::IReference<f32> as RtType>::Abi) -> HRESULT,
    fn get_WhiteBalance(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_ZoomFactor(&self, out: *mut <foundation::IReference<f32> as RtType>::Abi) -> HRESULT
}}
impl ICapturedFrameControlValues {
    #[inline] pub fn get_exposure(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Exposure)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_exposure_compensation(&self) -> Result<Option<foundation::IReference<f32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExposureCompensation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_iso_speed(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsoSpeed)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_focus(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Focus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_scene_mode(&self) -> Result<Option<foundation::IReference<super::devices::CaptureSceneMode>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SceneMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_flashed(&self) -> Result<Option<foundation::IReference<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Flashed)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_flash_power_percent(&self) -> Result<Option<foundation::IReference<f32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FlashPowerPercent)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_white_balance(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_WhiteBalance)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_zoom_factor(&self) -> Result<Option<foundation::IReference<f32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ZoomFactor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CapturedFrameControlValues: ICapturedFrameControlValues}
DEFINE_IID!(IID_ICapturedFrameControlValues2, 1342909320, 1746, 19111, 167, 219, 211, 122, 247, 51, 33, 216);
RT_INTERFACE!{interface ICapturedFrameControlValues2(ICapturedFrameControlValues2Vtbl, ICapturedFrameControlValues2_Abi): IInspectable(IInspectableVtbl) [IID_ICapturedFrameControlValues2] {
    fn get_FocusState(&self, out: *mut <foundation::IReference<super::devices::MediaCaptureFocusState> as RtType>::Abi) -> HRESULT,
    fn get_IsoDigitalGain(&self, out: *mut <foundation::IReference<f64> as RtType>::Abi) -> HRESULT,
    fn get_IsoAnalogGain(&self, out: *mut <foundation::IReference<f64> as RtType>::Abi) -> HRESULT,
    fn get_SensorFrameRate(&self, out: *mut <super::mediaproperties::MediaRatio as RtType>::Abi) -> HRESULT,
    fn get_WhiteBalanceGain(&self, out: *mut <foundation::IReference<WhiteBalanceGain> as RtType>::Abi) -> HRESULT
}}
impl ICapturedFrameControlValues2 {
    #[inline] pub fn get_focus_state(&self) -> Result<Option<foundation::IReference<super::devices::MediaCaptureFocusState>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FocusState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_iso_digital_gain(&self) -> Result<Option<foundation::IReference<f64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsoDigitalGain)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_iso_analog_gain(&self) -> Result<Option<foundation::IReference<f64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsoAnalogGain)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sensor_frame_rate(&self) -> Result<Option<super::mediaproperties::MediaRatio>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SensorFrameRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::mediaproperties::MediaRatio::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_white_balance_gain(&self) -> Result<Option<foundation::IReference<WhiteBalanceGain>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_WhiteBalanceGain)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICapturedFrameWithSoftwareBitmap, 3046017902, 34051, 18869, 158, 134, 137, 125, 38, 163, 255, 61);
RT_INTERFACE!{interface ICapturedFrameWithSoftwareBitmap(ICapturedFrameWithSoftwareBitmapVtbl, ICapturedFrameWithSoftwareBitmap_Abi): IInspectable(IInspectableVtbl) [IID_ICapturedFrameWithSoftwareBitmap] {
    #[cfg(feature="windows-graphics")] fn get_SoftwareBitmap(&self, out: *mut <super::super::graphics::imaging::SoftwareBitmap as RtType>::Abi) -> HRESULT
}}
impl ICapturedFrameWithSoftwareBitmap {
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_software_bitmap(&self) -> Result<Option<super::super::graphics::imaging::SoftwareBitmap>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SoftwareBitmap)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::graphics::imaging::SoftwareBitmap::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICapturedPhoto, 2966322778, 53196, 19820, 138, 209, 8, 105, 32, 138, 202, 22);
RT_INTERFACE!{interface ICapturedPhoto(ICapturedPhotoVtbl, ICapturedPhoto_Abi): IInspectable(IInspectableVtbl) [IID_ICapturedPhoto] {
    fn get_Frame(&self, out: *mut <CapturedFrame as RtType>::Abi) -> HRESULT,
    fn get_Thumbnail(&self, out: *mut <CapturedFrame as RtType>::Abi) -> HRESULT
}}
impl ICapturedPhoto {
    #[inline] pub fn get_frame(&self) -> Result<Option<CapturedFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Frame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CapturedFrame::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_thumbnail(&self) -> Result<Option<CapturedFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Thumbnail)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CapturedFrame::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CapturedPhoto: ICapturedPhoto}
RT_ENUM! { enum ForegroundActivationArgument: i32 {
    SignInRequired = 0, MoreSettings = 1,
}}
RT_ENUM! { enum GameBarCommand: i32 {
    OpenGameBar = 0, RecordHistoricalBuffer = 1, ToggleStartStopRecord = 2, StartRecord = 3, StopRecord = 4, TakeScreenshot = 5, StartBroadcast = 6, StopBroadcast = 7, PauseBroadcast = 8, ResumeBroadcast = 9, ToggleStartStopBroadcast = 10, ToggleMicrophoneCapture = 11, ToggleCameraCapture = 12, ToggleRecordingIndicator = 13,
}}
RT_ENUM! { enum GameBarCommandOrigin: i32 {
    ShortcutKey = 0, Cortana = 1, AppCommand = 2,
}}
DEFINE_IID!(IID_IGameBarServices, 767470935, 20646, 18846, 140, 108, 211, 48, 167, 49, 23, 150);
RT_INTERFACE!{interface IGameBarServices(IGameBarServicesVtbl, IGameBarServices_Abi): IInspectable(IInspectableVtbl) [IID_IGameBarServices] {
    fn get_TargetCapturePolicy(&self, out: *mut GameBarTargetCapturePolicy) -> HRESULT,
    fn EnableCapture(&self) -> HRESULT,
    fn DisableCapture(&self) -> HRESULT,
    fn get_TargetInfo(&self, out: *mut <GameBarServicesTargetInfo as RtType>::Abi) -> HRESULT,
    fn get_SessionId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppBroadcastServices(&self, out: *mut <AppBroadcastServices as RtType>::Abi) -> HRESULT,
    fn get_AppCaptureServices(&self, out: *mut <AppCaptureServices as RtType>::Abi) -> HRESULT,
    fn add_CommandReceived(&self, value: <foundation::TypedEventHandler<GameBarServices, GameBarServicesCommandEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CommandReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IGameBarServices {
    #[inline] pub fn get_target_capture_policy(&self) -> Result<GameBarTargetCapturePolicy> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TargetCapturePolicy)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn enable_capture(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).EnableCapture)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn disable_capture(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).DisableCapture)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_target_info(&self) -> Result<Option<GameBarServicesTargetInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TargetInfo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GameBarServicesTargetInfo::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_session_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SessionId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_app_broadcast_services(&self) -> Result<Option<AppBroadcastServices>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AppBroadcastServices)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppBroadcastServices::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_app_capture_services(&self) -> Result<Option<AppCaptureServices>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AppCaptureServices)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AppCaptureServices::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_command_received(&self, value: &foundation::TypedEventHandler<GameBarServices, GameBarServicesCommandEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_CommandReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_command_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_CommandReceived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GameBarServices: IGameBarServices}
DEFINE_IID!(IID_IGameBarServicesCommandEventArgs, 2806130354, 61814, 20431, 143, 187, 207, 105, 139, 46, 184, 224);
RT_INTERFACE!{interface IGameBarServicesCommandEventArgs(IGameBarServicesCommandEventArgsVtbl, IGameBarServicesCommandEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IGameBarServicesCommandEventArgs] {
    fn get_Command(&self, out: *mut GameBarCommand) -> HRESULT,
    fn get_Origin(&self, out: *mut GameBarCommandOrigin) -> HRESULT
}}
impl IGameBarServicesCommandEventArgs {
    #[inline] pub fn get_command(&self) -> Result<GameBarCommand> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Command)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_origin(&self) -> Result<GameBarCommandOrigin> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Origin)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GameBarServicesCommandEventArgs: IGameBarServicesCommandEventArgs}
RT_ENUM! { enum GameBarServicesDisplayMode: i32 {
    Windowed = 0, FullScreenExclusive = 1,
}}
DEFINE_IID!(IID_IGameBarServicesManager, 978033914, 32651, 19552, 157, 187, 11, 205, 38, 45, 255, 198);
RT_INTERFACE!{interface IGameBarServicesManager(IGameBarServicesManagerVtbl, IGameBarServicesManager_Abi): IInspectable(IInspectableVtbl) [IID_IGameBarServicesManager] {
    fn add_GameBarServicesCreated(&self, value: <foundation::TypedEventHandler<GameBarServicesManager, GameBarServicesManagerGameBarServicesCreatedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_GameBarServicesCreated(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IGameBarServicesManager {
    #[inline] pub fn add_game_bar_services_created(&self, value: &foundation::TypedEventHandler<GameBarServicesManager, GameBarServicesManagerGameBarServicesCreatedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_GameBarServicesCreated)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_game_bar_services_created(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_GameBarServicesCreated)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GameBarServicesManager: IGameBarServicesManager}
impl RtActivatable<IGameBarServicesManagerStatics> for GameBarServicesManager {}
impl GameBarServicesManager {
    #[inline] pub fn get_default() -> Result<Option<GameBarServicesManager>> {
        <Self as RtActivatable<IGameBarServicesManagerStatics>>::get_activation_factory().get_default()
    }
}
DEFINE_CLSID!(GameBarServicesManager(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,97,112,116,117,114,101,46,71,97,109,101,66,97,114,83,101,114,118,105,99,101,115,77,97,110,97,103,101,114,0]) [CLSID_GameBarServicesManager]);
DEFINE_IID!(IID_IGameBarServicesManagerGameBarServicesCreatedEventArgs, 3991780764, 5182, 18851, 165, 234, 11, 25, 149, 200, 212, 110);
RT_INTERFACE!{interface IGameBarServicesManagerGameBarServicesCreatedEventArgs(IGameBarServicesManagerGameBarServicesCreatedEventArgsVtbl, IGameBarServicesManagerGameBarServicesCreatedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IGameBarServicesManagerGameBarServicesCreatedEventArgs] {
    fn get_GameBarServices(&self, out: *mut <GameBarServices as RtType>::Abi) -> HRESULT
}}
impl IGameBarServicesManagerGameBarServicesCreatedEventArgs {
    #[inline] pub fn get_game_bar_services(&self) -> Result<Option<GameBarServices>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_GameBarServices)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GameBarServices::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GameBarServicesManagerGameBarServicesCreatedEventArgs: IGameBarServicesManagerGameBarServicesCreatedEventArgs}
DEFINE_IID!(IID_IGameBarServicesManagerStatics, 885110294, 65317, 18322, 152, 242, 211, 117, 63, 21, 172, 19);
RT_INTERFACE!{static interface IGameBarServicesManagerStatics(IGameBarServicesManagerStaticsVtbl, IGameBarServicesManagerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IGameBarServicesManagerStatics] {
    fn GetDefault(&self, out: *mut <GameBarServicesManager as RtType>::Abi) -> HRESULT
}}
impl IGameBarServicesManagerStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<GameBarServicesManager>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GameBarServicesManager::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGameBarServicesTargetInfo, 3022008210, 5649, 19973, 182, 239, 223, 215, 55, 174, 51, 176);
RT_INTERFACE!{interface IGameBarServicesTargetInfo(IGameBarServicesTargetInfoVtbl, IGameBarServicesTargetInfo_Abi): IInspectable(IInspectableVtbl) [IID_IGameBarServicesTargetInfo] {
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TitleId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayMode(&self, out: *mut GameBarServicesDisplayMode) -> HRESULT
}}
impl IGameBarServicesTargetInfo {
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DisplayName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_app_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AppId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_title_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TitleId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_mode(&self) -> Result<GameBarServicesDisplayMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DisplayMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GameBarServicesTargetInfo: IGameBarServicesTargetInfo}
RT_ENUM! { enum GameBarTargetCapturePolicy: i32 {
    EnabledBySystem = 0, EnabledByUser = 1, NotEnabled = 2, ProhibitedBySystem = 3, ProhibitedByPublisher = 4,
}}
RT_ENUM! { enum KnownVideoProfile: i32 {
    VideoRecording = 0, HighQualityPhoto = 1, BalancedVideoAndPhoto = 2, VideoConferencing = 3, PhotoSequence = 4, HighFrameRate = 5, VariablePhotoSequence = 6, HdrWithWcgVideo = 7, HdrWithWcgPhoto = 8, VideoHdr8 = 9,
}}
DEFINE_IID!(IID_ILowLagMediaRecording, 1103674103, 65343, 18928, 164, 119, 241, 149, 227, 206, 81, 8);
RT_INTERFACE!{interface ILowLagMediaRecording(ILowLagMediaRecordingVtbl, ILowLagMediaRecording_Abi): IInspectable(IInspectableVtbl) [IID_ILowLagMediaRecording] {
    fn StartAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn StopAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn FinishAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl ILowLagMediaRecording {
    #[inline] pub fn start_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StartAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn stop_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StopAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn finish_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FinishAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LowLagMediaRecording: ILowLagMediaRecording}
DEFINE_IID!(IID_ILowLagMediaRecording2, 1667876696, 22084, 16866, 151, 175, 142, 245, 106, 37, 226, 37);
RT_INTERFACE!{interface ILowLagMediaRecording2(ILowLagMediaRecording2Vtbl, ILowLagMediaRecording2_Abi): IInspectable(IInspectableVtbl) [IID_ILowLagMediaRecording2] {
    fn PauseAsync(&self, behavior: super::devices::MediaCapturePauseBehavior, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ResumeAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl ILowLagMediaRecording2 {
    #[inline] pub fn pause_async(&self, behavior: super::devices::MediaCapturePauseBehavior) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PauseAsync)(self.0.as_abi() as *const _ as *mut _, behavior, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn resume_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ResumeAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILowLagMediaRecording3, 1546890002, 18679, 18394, 180, 30, 144, 136, 10, 95, 224, 236);
RT_INTERFACE!{interface ILowLagMediaRecording3(ILowLagMediaRecording3Vtbl, ILowLagMediaRecording3_Abi): IInspectable(IInspectableVtbl) [IID_ILowLagMediaRecording3] {
    fn PauseWithResultAsync(&self, behavior: super::devices::MediaCapturePauseBehavior, out: *mut <foundation::IAsyncOperation<MediaCapturePauseResult> as RtType>::Abi) -> HRESULT,
    fn StopWithResultAsync(&self, out: *mut <foundation::IAsyncOperation<MediaCaptureStopResult> as RtType>::Abi) -> HRESULT
}}
impl ILowLagMediaRecording3 {
    #[inline] pub fn pause_with_result_async(&self, behavior: super::devices::MediaCapturePauseBehavior) -> Result<foundation::IAsyncOperation<MediaCapturePauseResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PauseWithResultAsync)(self.0.as_abi() as *const _ as *mut _, behavior, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn stop_with_result_async(&self) -> Result<foundation::IAsyncOperation<MediaCaptureStopResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StopWithResultAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILowLagPhotoCapture, 2742178231, 27460, 18237, 143, 36, 247, 3, 214, 192, 236, 68);
RT_INTERFACE!{interface ILowLagPhotoCapture(ILowLagPhotoCaptureVtbl, ILowLagPhotoCapture_Abi): IInspectable(IInspectableVtbl) [IID_ILowLagPhotoCapture] {
    fn CaptureAsync(&self, out: *mut <foundation::IAsyncOperation<CapturedPhoto> as RtType>::Abi) -> HRESULT,
    fn FinishAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl ILowLagPhotoCapture {
    #[inline] pub fn capture_async(&self) -> Result<foundation::IAsyncOperation<CapturedPhoto>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CaptureAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn finish_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FinishAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LowLagPhotoCapture: ILowLagPhotoCapture}
DEFINE_IID!(IID_ILowLagPhotoSequenceCapture, 2093172411, 47529, 19601, 143, 250, 40, 126, 156, 102, 134, 105);
RT_INTERFACE!{interface ILowLagPhotoSequenceCapture(ILowLagPhotoSequenceCaptureVtbl, ILowLagPhotoSequenceCapture_Abi): IInspectable(IInspectableVtbl) [IID_ILowLagPhotoSequenceCapture] {
    fn StartAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn StopAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn FinishAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn add_PhotoCaptured(&self, handler: <foundation::TypedEventHandler<LowLagPhotoSequenceCapture, PhotoCapturedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PhotoCaptured(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ILowLagPhotoSequenceCapture {
    #[inline] pub fn start_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StartAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn stop_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StopAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn finish_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FinishAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_photo_captured(&self, handler: &foundation::TypedEventHandler<LowLagPhotoSequenceCapture, PhotoCapturedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PhotoCaptured)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_photo_captured(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PhotoCaptured)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LowLagPhotoSequenceCapture: ILowLagPhotoSequenceCapture}
DEFINE_IID!(IID_IMediaCapture, 3323657140, 64272, 18996, 172, 24, 202, 128, 217, 200, 231, 238);
RT_INTERFACE!{interface IMediaCapture(IMediaCaptureVtbl, IMediaCapture_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCapture] {
    fn InitializeAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn InitializeWithSettingsAsync(&self, mediaCaptureInitializationSettings: <MediaCaptureInitializationSettings as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn StartRecordToStorageFileAsync(&self, encodingProfile: <super::mediaproperties::MediaEncodingProfile as RtType>::Abi, file: <super::super::storage::IStorageFile as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-storage")] fn StartRecordToStreamAsync(&self, encodingProfile: <super::mediaproperties::MediaEncodingProfile as RtType>::Abi, stream: <super::super::storage::streams::IRandomAccessStream as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn StartRecordToCustomSinkAsync(&self, encodingProfile: <super::mediaproperties::MediaEncodingProfile as RtType>::Abi, customMediaSink: <super::IMediaExtension as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn StartRecordToCustomSinkIdAsync(&self, encodingProfile: <super::mediaproperties::MediaEncodingProfile as RtType>::Abi, customSinkActivationId: HSTRING, customSinkSettings: <foundation::collections::IPropertySet as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn StopRecordAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-storage")] fn CapturePhotoToStorageFileAsync(&self, type_: <super::mediaproperties::ImageEncodingProperties as RtType>::Abi, file: <super::super::storage::IStorageFile as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-storage")] fn CapturePhotoToStreamAsync(&self, type_: <super::mediaproperties::ImageEncodingProperties as RtType>::Abi, stream: <super::super::storage::streams::IRandomAccessStream as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn AddEffectAsync(&self, mediaStreamType: MediaStreamType, effectActivationID: HSTRING, effectSettings: <foundation::collections::IPropertySet as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ClearEffectsAsync(&self, mediaStreamType: MediaStreamType, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn SetEncoderProperty(&self, mediaStreamType: MediaStreamType, propertyId: Guid, propertyValue: <IInspectable as RtType>::Abi) -> HRESULT,
    fn GetEncoderProperty(&self, mediaStreamType: MediaStreamType, propertyId: Guid, out: *mut <IInspectable as RtType>::Abi) -> HRESULT,
    fn add_Failed(&self, errorEventHandler: <MediaCaptureFailedEventHandler as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Failed(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_RecordLimitationExceeded(&self, recordLimitationExceededEventHandler: <RecordLimitationExceededEventHandler as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RecordLimitationExceeded(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT,
    fn get_MediaCaptureSettings(&self, out: *mut <MediaCaptureSettings as RtType>::Abi) -> HRESULT,
    fn get_AudioDeviceController(&self, out: *mut <super::devices::AudioDeviceController as RtType>::Abi) -> HRESULT,
    fn get_VideoDeviceController(&self, out: *mut <super::devices::VideoDeviceController as RtType>::Abi) -> HRESULT,
    fn SetPreviewMirroring(&self, value: bool) -> HRESULT,
    fn GetPreviewMirroring(&self, out: *mut bool) -> HRESULT,
    fn SetPreviewRotation(&self, value: VideoRotation) -> HRESULT,
    fn GetPreviewRotation(&self, out: *mut VideoRotation) -> HRESULT,
    fn SetRecordRotation(&self, value: VideoRotation) -> HRESULT,
    fn GetRecordRotation(&self, out: *mut VideoRotation) -> HRESULT
}}
impl IMediaCapture {
    #[inline] pub fn initialize_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).InitializeAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn initialize_with_settings_async(&self, mediaCaptureInitializationSettings: &MediaCaptureInitializationSettings) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).InitializeWithSettingsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(mediaCaptureInitializationSettings) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn start_record_to_storage_file_async(&self, encodingProfile: &super::mediaproperties::MediaEncodingProfile, file: &super::super::storage::IStorageFile) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StartRecordToStorageFileAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(encodingProfile) as *const _ as *mut _, get_abi(file) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn start_record_to_stream_async(&self, encodingProfile: &super::mediaproperties::MediaEncodingProfile, stream: &super::super::storage::streams::IRandomAccessStream) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StartRecordToStreamAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(encodingProfile) as *const _ as *mut _, get_abi(stream) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn start_record_to_custom_sink_async(&self, encodingProfile: &super::mediaproperties::MediaEncodingProfile, customMediaSink: &super::IMediaExtension) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StartRecordToCustomSinkAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(encodingProfile) as *const _ as *mut _, get_abi(customMediaSink) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn start_record_to_custom_sink_id_async(&self, encodingProfile: &super::mediaproperties::MediaEncodingProfile, customSinkActivationId: &HStringArg, customSinkSettings: &foundation::collections::IPropertySet) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StartRecordToCustomSinkIdAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(encodingProfile) as *const _ as *mut _, customSinkActivationId.get(), get_abi(customSinkSettings) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn stop_record_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StopRecordAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn capture_photo_to_storage_file_async(&self, type_: &super::mediaproperties::ImageEncodingProperties, file: &super::super::storage::IStorageFile) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CapturePhotoToStorageFileAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(type_) as *const _ as *mut _, get_abi(file) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn capture_photo_to_stream_async(&self, type_: &super::mediaproperties::ImageEncodingProperties, stream: &super::super::storage::streams::IRandomAccessStream) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CapturePhotoToStreamAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(type_) as *const _ as *mut _, get_abi(stream) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_effect_async(&self, mediaStreamType: MediaStreamType, effectActivationID: &HStringArg, effectSettings: &foundation::collections::IPropertySet) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).AddEffectAsync)(self.0.as_abi() as *const _ as *mut _, mediaStreamType, effectActivationID.get(), get_abi(effectSettings) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn clear_effects_async(&self, mediaStreamType: MediaStreamType) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ClearEffectsAsync)(self.0.as_abi() as *const _ as *mut _, mediaStreamType, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_encoder_property(&self, mediaStreamType: MediaStreamType, propertyId: Guid, propertyValue: &IInspectable) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetEncoderProperty)(self.0.as_abi() as *const _ as *mut _, mediaStreamType, propertyId, get_abi(propertyValue) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_encoder_property(&self, mediaStreamType: MediaStreamType, propertyId: Guid) -> Result<Option<IInspectable>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetEncoderProperty)(self.0.as_abi() as *const _ as *mut _, mediaStreamType, propertyId, &mut out);
        if hr == S_OK { Ok(IInspectable::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_failed(&self, errorEventHandler: &MediaCaptureFailedEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Failed)(self.0.as_abi() as *const _ as *mut _, get_abi(errorEventHandler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_failed(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Failed)(self.0.as_abi() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_record_limitation_exceeded(&self, recordLimitationExceededEventHandler: &RecordLimitationExceededEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_RecordLimitationExceeded)(self.0.as_abi() as *const _ as *mut _, get_abi(recordLimitationExceededEventHandler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_record_limitation_exceeded(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_RecordLimitationExceeded)(self.0.as_abi() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_media_capture_settings(&self) -> Result<Option<MediaCaptureSettings>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaCaptureSettings)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaCaptureSettings::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_device_controller(&self) -> Result<Option<super::devices::AudioDeviceController>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioDeviceController)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::devices::AudioDeviceController::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_device_controller(&self) -> Result<Option<super::devices::VideoDeviceController>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoDeviceController)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::devices::VideoDeviceController::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_preview_mirroring(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetPreviewMirroring)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_preview_mirroring(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).GetPreviewMirroring)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_preview_rotation(&self, value: VideoRotation) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetPreviewRotation)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_preview_rotation(&self) -> Result<VideoRotation> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).GetPreviewRotation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_record_rotation(&self, value: VideoRotation) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetRecordRotation)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_record_rotation(&self) -> Result<VideoRotation> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).GetRecordRotation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaCapture: IMediaCapture}
impl RtActivatable<IMediaCaptureStatics> for MediaCapture {}
impl RtActivatable<IActivationFactory> for MediaCapture {}
impl MediaCapture {
    #[inline] pub fn is_video_profile_supported(videoDeviceId: &HStringArg) -> Result<bool> {
        <Self as RtActivatable<IMediaCaptureStatics>>::get_activation_factory().is_video_profile_supported(videoDeviceId)
    }
    #[inline] pub fn find_all_video_profiles(videoDeviceId: &HStringArg) -> Result<Option<foundation::collections::IVectorView<MediaCaptureVideoProfile>>> {
        <Self as RtActivatable<IMediaCaptureStatics>>::get_activation_factory().find_all_video_profiles(videoDeviceId)
    }
    #[inline] pub fn find_concurrent_profiles(videoDeviceId: &HStringArg) -> Result<Option<foundation::collections::IVectorView<MediaCaptureVideoProfile>>> {
        <Self as RtActivatable<IMediaCaptureStatics>>::get_activation_factory().find_concurrent_profiles(videoDeviceId)
    }
    #[inline] pub fn find_known_video_profiles(videoDeviceId: &HStringArg, name: KnownVideoProfile) -> Result<Option<foundation::collections::IVectorView<MediaCaptureVideoProfile>>> {
        <Self as RtActivatable<IMediaCaptureStatics>>::get_activation_factory().find_known_video_profiles(videoDeviceId, name)
    }
}
DEFINE_CLSID!(MediaCapture(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,97,112,116,117,114,101,46,77,101,100,105,97,67,97,112,116,117,114,101,0]) [CLSID_MediaCapture]);
DEFINE_IID!(IID_IMediaCapture2, 2630255200, 32161, 16451, 182, 82, 33, 184, 135, 141, 175, 249);
RT_INTERFACE!{interface IMediaCapture2(IMediaCapture2Vtbl, IMediaCapture2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCapture2] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn PrepareLowLagRecordToStorageFileAsync(&self, encodingProfile: <super::mediaproperties::MediaEncodingProfile as RtType>::Abi, file: <super::super::storage::IStorageFile as RtType>::Abi, out: *mut <foundation::IAsyncOperation<LowLagMediaRecording> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn PrepareLowLagRecordToStreamAsync(&self, encodingProfile: <super::mediaproperties::MediaEncodingProfile as RtType>::Abi, stream: <super::super::storage::streams::IRandomAccessStream as RtType>::Abi, out: *mut <foundation::IAsyncOperation<LowLagMediaRecording> as RtType>::Abi) -> HRESULT,
    fn PrepareLowLagRecordToCustomSinkAsync(&self, encodingProfile: <super::mediaproperties::MediaEncodingProfile as RtType>::Abi, customMediaSink: <super::IMediaExtension as RtType>::Abi, out: *mut <foundation::IAsyncOperation<LowLagMediaRecording> as RtType>::Abi) -> HRESULT,
    fn PrepareLowLagRecordToCustomSinkIdAsync(&self, encodingProfile: <super::mediaproperties::MediaEncodingProfile as RtType>::Abi, customSinkActivationId: HSTRING, customSinkSettings: <foundation::collections::IPropertySet as RtType>::Abi, out: *mut <foundation::IAsyncOperation<LowLagMediaRecording> as RtType>::Abi) -> HRESULT,
    fn PrepareLowLagPhotoCaptureAsync(&self, type_: <super::mediaproperties::ImageEncodingProperties as RtType>::Abi, out: *mut <foundation::IAsyncOperation<LowLagPhotoCapture> as RtType>::Abi) -> HRESULT,
    fn PrepareLowLagPhotoSequenceCaptureAsync(&self, type_: <super::mediaproperties::ImageEncodingProperties as RtType>::Abi, out: *mut <foundation::IAsyncOperation<LowLagPhotoSequenceCapture> as RtType>::Abi) -> HRESULT,
    fn SetEncodingPropertiesAsync(&self, mediaStreamType: MediaStreamType, mediaEncodingProperties: <super::mediaproperties::IMediaEncodingProperties as RtType>::Abi, encoderProperties: <super::mediaproperties::MediaPropertySet as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IMediaCapture2 {
    #[cfg(feature="windows-storage")] #[inline] pub fn prepare_low_lag_record_to_storage_file_async(&self, encodingProfile: &super::mediaproperties::MediaEncodingProfile, file: &super::super::storage::IStorageFile) -> Result<foundation::IAsyncOperation<LowLagMediaRecording>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PrepareLowLagRecordToStorageFileAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(encodingProfile) as *const _ as *mut _, get_abi(file) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn prepare_low_lag_record_to_stream_async(&self, encodingProfile: &super::mediaproperties::MediaEncodingProfile, stream: &super::super::storage::streams::IRandomAccessStream) -> Result<foundation::IAsyncOperation<LowLagMediaRecording>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PrepareLowLagRecordToStreamAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(encodingProfile) as *const _ as *mut _, get_abi(stream) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn prepare_low_lag_record_to_custom_sink_async(&self, encodingProfile: &super::mediaproperties::MediaEncodingProfile, customMediaSink: &super::IMediaExtension) -> Result<foundation::IAsyncOperation<LowLagMediaRecording>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PrepareLowLagRecordToCustomSinkAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(encodingProfile) as *const _ as *mut _, get_abi(customMediaSink) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn prepare_low_lag_record_to_custom_sink_id_async(&self, encodingProfile: &super::mediaproperties::MediaEncodingProfile, customSinkActivationId: &HStringArg, customSinkSettings: &foundation::collections::IPropertySet) -> Result<foundation::IAsyncOperation<LowLagMediaRecording>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PrepareLowLagRecordToCustomSinkIdAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(encodingProfile) as *const _ as *mut _, customSinkActivationId.get(), get_abi(customSinkSettings) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn prepare_low_lag_photo_capture_async(&self, type_: &super::mediaproperties::ImageEncodingProperties) -> Result<foundation::IAsyncOperation<LowLagPhotoCapture>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PrepareLowLagPhotoCaptureAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(type_) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn prepare_low_lag_photo_sequence_capture_async(&self, type_: &super::mediaproperties::ImageEncodingProperties) -> Result<foundation::IAsyncOperation<LowLagPhotoSequenceCapture>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PrepareLowLagPhotoSequenceCaptureAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(type_) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_encoding_properties_async(&self, mediaStreamType: MediaStreamType, mediaEncodingProperties: &super::mediaproperties::IMediaEncodingProperties, encoderProperties: &super::mediaproperties::MediaPropertySet) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetEncodingPropertiesAsync)(self.0.as_abi() as *const _ as *mut _, mediaStreamType, get_abi(mediaEncodingProperties) as *const _ as *mut _, get_abi(encoderProperties) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaCapture3, 3558043440, 5476, 18030, 188, 10, 175, 148, 224, 42, 176, 22);
RT_INTERFACE!{interface IMediaCapture3(IMediaCapture3Vtbl, IMediaCapture3_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCapture3] {
    fn PrepareVariablePhotoSequenceCaptureAsync(&self, type_: <super::mediaproperties::ImageEncodingProperties as RtType>::Abi, out: *mut <foundation::IAsyncOperation<core::VariablePhotoSequenceCapture> as RtType>::Abi) -> HRESULT,
    fn add_FocusChanged(&self, handler: <foundation::TypedEventHandler<MediaCapture, MediaCaptureFocusChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FocusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PhotoConfirmationCaptured(&self, handler: <foundation::TypedEventHandler<MediaCapture, PhotoConfirmationCapturedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PhotoConfirmationCaptured(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IMediaCapture3 {
    #[inline] pub fn prepare_variable_photo_sequence_capture_async(&self, type_: &super::mediaproperties::ImageEncodingProperties) -> Result<foundation::IAsyncOperation<core::VariablePhotoSequenceCapture>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PrepareVariablePhotoSequenceCaptureAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(type_) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_focus_changed(&self, handler: &foundation::TypedEventHandler<MediaCapture, MediaCaptureFocusChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_FocusChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_focus_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_FocusChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_photo_confirmation_captured(&self, handler: &foundation::TypedEventHandler<MediaCapture, PhotoConfirmationCapturedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PhotoConfirmationCaptured)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_photo_confirmation_captured(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PhotoConfirmationCaptured)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaCapture4, 3134025686, 64264, 18759, 174, 162, 206, 20, 239, 240, 206, 19);
RT_INTERFACE!{interface IMediaCapture4(IMediaCapture4Vtbl, IMediaCapture4_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCapture4] {
    fn AddAudioEffectAsync(&self, definition: <super::effects::IAudioEffectDefinition as RtType>::Abi, out: *mut <foundation::IAsyncOperation<super::IMediaExtension> as RtType>::Abi) -> HRESULT,
    fn AddVideoEffectAsync(&self, definition: <super::effects::IVideoEffectDefinition as RtType>::Abi, mediaStreamType: MediaStreamType, out: *mut <foundation::IAsyncOperation<super::IMediaExtension> as RtType>::Abi) -> HRESULT,
    fn PauseRecordAsync(&self, behavior: super::devices::MediaCapturePauseBehavior, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ResumeRecordAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn add_CameraStreamStateChanged(&self, handler: <foundation::TypedEventHandler<MediaCapture, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CameraStreamStateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_CameraStreamState(&self, out: *mut super::devices::CameraStreamState) -> HRESULT,
    fn GetPreviewFrameAsync(&self, out: *mut <foundation::IAsyncOperation<super::VideoFrame> as RtType>::Abi) -> HRESULT,
    fn GetPreviewFrameCopyAsync(&self, destination: <super::VideoFrame as RtType>::Abi, out: *mut <foundation::IAsyncOperation<super::VideoFrame> as RtType>::Abi) -> HRESULT,
    fn add_ThermalStatusChanged(&self, handler: <foundation::TypedEventHandler<MediaCapture, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ThermalStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_ThermalStatus(&self, out: *mut MediaCaptureThermalStatus) -> HRESULT,
    fn PrepareAdvancedPhotoCaptureAsync(&self, encodingProperties: <super::mediaproperties::ImageEncodingProperties as RtType>::Abi, out: *mut <foundation::IAsyncOperation<AdvancedPhotoCapture> as RtType>::Abi) -> HRESULT
}}
impl IMediaCapture4 {
    #[inline] pub fn add_audio_effect_async(&self, definition: &super::effects::IAudioEffectDefinition) -> Result<foundation::IAsyncOperation<super::IMediaExtension>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).AddAudioEffectAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(definition) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_video_effect_async(&self, definition: &super::effects::IVideoEffectDefinition, mediaStreamType: MediaStreamType) -> Result<foundation::IAsyncOperation<super::IMediaExtension>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).AddVideoEffectAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(definition) as *const _ as *mut _, mediaStreamType, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn pause_record_async(&self, behavior: super::devices::MediaCapturePauseBehavior) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PauseRecordAsync)(self.0.as_abi() as *const _ as *mut _, behavior, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn resume_record_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ResumeRecordAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_camera_stream_state_changed(&self, handler: &foundation::TypedEventHandler<MediaCapture, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_CameraStreamStateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_camera_stream_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_CameraStreamStateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_camera_stream_state(&self) -> Result<super::devices::CameraStreamState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CameraStreamState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_preview_frame_async(&self) -> Result<foundation::IAsyncOperation<super::VideoFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetPreviewFrameAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_preview_frame_copy_async(&self, destination: &super::VideoFrame) -> Result<foundation::IAsyncOperation<super::VideoFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetPreviewFrameCopyAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(destination) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_thermal_status_changed(&self, handler: &foundation::TypedEventHandler<MediaCapture, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ThermalStatusChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_thermal_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ThermalStatusChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_thermal_status(&self) -> Result<MediaCaptureThermalStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ThermalStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn prepare_advanced_photo_capture_async(&self, encodingProperties: &super::mediaproperties::ImageEncodingProperties) -> Result<foundation::IAsyncOperation<AdvancedPhotoCapture>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PrepareAdvancedPhotoCaptureAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(encodingProperties) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaCapture5, 3665329186, 15003, 18208, 167, 30, 151, 144, 10, 49, 110, 90);
RT_INTERFACE!{interface IMediaCapture5(IMediaCapture5Vtbl, IMediaCapture5_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCapture5] {
    fn RemoveEffectAsync(&self, effect: <super::IMediaExtension as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn PauseRecordWithResultAsync(&self, behavior: super::devices::MediaCapturePauseBehavior, out: *mut <foundation::IAsyncOperation<MediaCapturePauseResult> as RtType>::Abi) -> HRESULT,
    fn StopRecordWithResultAsync(&self, out: *mut <foundation::IAsyncOperation<MediaCaptureStopResult> as RtType>::Abi) -> HRESULT,
    fn get_FrameSources(&self, out: *mut <foundation::collections::IMapView<HString, frames::MediaFrameSource> as RtType>::Abi) -> HRESULT,
    fn CreateFrameReaderAsync(&self, inputSource: <frames::MediaFrameSource as RtType>::Abi, out: *mut <foundation::IAsyncOperation<frames::MediaFrameReader> as RtType>::Abi) -> HRESULT,
    fn CreateFrameReaderWithSubtypeAsync(&self, inputSource: <frames::MediaFrameSource as RtType>::Abi, outputSubtype: HSTRING, out: *mut <foundation::IAsyncOperation<frames::MediaFrameReader> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn CreateFrameReaderWithSubtypeAndSizeAsync(&self, inputSource: <frames::MediaFrameSource as RtType>::Abi, outputSubtype: HSTRING, outputSize: super::super::graphics::imaging::BitmapSize, out: *mut <foundation::IAsyncOperation<frames::MediaFrameReader> as RtType>::Abi) -> HRESULT
}}
impl IMediaCapture5 {
    #[inline] pub fn remove_effect_async(&self, effect: &super::IMediaExtension) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RemoveEffectAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(effect) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn pause_record_with_result_async(&self, behavior: super::devices::MediaCapturePauseBehavior) -> Result<foundation::IAsyncOperation<MediaCapturePauseResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PauseRecordWithResultAsync)(self.0.as_abi() as *const _ as *mut _, behavior, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn stop_record_with_result_async(&self) -> Result<foundation::IAsyncOperation<MediaCaptureStopResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StopRecordWithResultAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_frame_sources(&self) -> Result<Option<foundation::collections::IMapView<HString, frames::MediaFrameSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameSources)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_frame_reader_async(&self, inputSource: &frames::MediaFrameSource) -> Result<foundation::IAsyncOperation<frames::MediaFrameReader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFrameReaderAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(inputSource) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_frame_reader_with_subtype_async(&self, inputSource: &frames::MediaFrameSource, outputSubtype: &HStringArg) -> Result<foundation::IAsyncOperation<frames::MediaFrameReader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFrameReaderWithSubtypeAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(inputSource) as *const _ as *mut _, outputSubtype.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_frame_reader_with_subtype_and_size_async(&self, inputSource: &frames::MediaFrameSource, outputSubtype: &HStringArg, outputSize: super::super::graphics::imaging::BitmapSize) -> Result<foundation::IAsyncOperation<frames::MediaFrameReader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFrameReaderWithSubtypeAndSizeAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(inputSource) as *const _ as *mut _, outputSubtype.get(), outputSize, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaCapture6, 579422397, 19232, 19377, 159, 214, 165, 131, 33, 42, 16, 18);
RT_INTERFACE!{interface IMediaCapture6(IMediaCapture6Vtbl, IMediaCapture6_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCapture6] {
    fn add_CaptureDeviceExclusiveControlStatusChanged(&self, handler: <foundation::TypedEventHandler<MediaCapture, MediaCaptureDeviceExclusiveControlStatusChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CaptureDeviceExclusiveControlStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn CreateMultiSourceFrameReaderAsync(&self, inputSources: <foundation::collections::IIterable<frames::MediaFrameSource> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<frames::MultiSourceMediaFrameReader> as RtType>::Abi) -> HRESULT
}}
impl IMediaCapture6 {
    #[inline] pub fn add_capture_device_exclusive_control_status_changed(&self, handler: &foundation::TypedEventHandler<MediaCapture, MediaCaptureDeviceExclusiveControlStatusChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_CaptureDeviceExclusiveControlStatusChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_capture_device_exclusive_control_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_CaptureDeviceExclusiveControlStatusChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn create_multi_source_frame_reader_async(&self, inputSources: &foundation::collections::IIterable<frames::MediaFrameSource>) -> Result<foundation::IAsyncOperation<frames::MultiSourceMediaFrameReader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateMultiSourceFrameReaderAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(inputSources) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum MediaCaptureDeviceExclusiveControlStatus: i32 {
    ExclusiveControlAvailable = 0, SharedReadOnlyAvailable = 1,
}}
DEFINE_IID!(IID_IMediaCaptureDeviceExclusiveControlStatusChangedEventArgs, 2637140493, 42376, 17350, 137, 214, 90, 211, 34, 175, 0, 106);
RT_INTERFACE!{interface IMediaCaptureDeviceExclusiveControlStatusChangedEventArgs(IMediaCaptureDeviceExclusiveControlStatusChangedEventArgsVtbl, IMediaCaptureDeviceExclusiveControlStatusChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCaptureDeviceExclusiveControlStatusChangedEventArgs] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Status(&self, out: *mut MediaCaptureDeviceExclusiveControlStatus) -> HRESULT
}}
impl IMediaCaptureDeviceExclusiveControlStatusChangedEventArgs {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<MediaCaptureDeviceExclusiveControlStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaCaptureDeviceExclusiveControlStatusChangedEventArgs: IMediaCaptureDeviceExclusiveControlStatusChangedEventArgs}
DEFINE_IID!(IID_IMediaCaptureFailedEventArgs, 2164122612, 21700, 17088, 141, 25, 206, 161, 168, 124, 161, 139);
RT_INTERFACE!{interface IMediaCaptureFailedEventArgs(IMediaCaptureFailedEventArgsVtbl, IMediaCaptureFailedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCaptureFailedEventArgs] {
    fn get_Message(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Code(&self, out: *mut u32) -> HRESULT
}}
impl IMediaCaptureFailedEventArgs {
    #[inline] pub fn get_message(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Message)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_code(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Code)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaCaptureFailedEventArgs: IMediaCaptureFailedEventArgs}
DEFINE_IID!(IID_MediaCaptureFailedEventHandler, 538243067, 23768, 20232, 163, 20, 13, 54, 13, 165, 159, 20);
RT_DELEGATE!{delegate MediaCaptureFailedEventHandler(MediaCaptureFailedEventHandlerVtbl, MediaCaptureFailedEventHandler_Abi, MediaCaptureFailedEventHandlerImpl) [IID_MediaCaptureFailedEventHandler] {
    fn Invoke(&self, sender: <MediaCapture as RtType>::Abi, errorEventArgs: <MediaCaptureFailedEventArgs as RtType>::Abi) -> HRESULT
}}
impl MediaCaptureFailedEventHandler {
    #[inline] pub fn invoke(&self, sender: &MediaCapture, errorEventArgs: &MediaCaptureFailedEventArgs) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Invoke)(self.0.as_abi() as *const _ as *mut _, get_abi(sender) as *const _ as *mut _, get_abi(errorEventArgs) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaCaptureFocusChangedEventArgs, 2179054719, 8823, 18750, 171, 238, 211, 244, 79, 249, 140, 4);
RT_INTERFACE!{interface IMediaCaptureFocusChangedEventArgs(IMediaCaptureFocusChangedEventArgsVtbl, IMediaCaptureFocusChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCaptureFocusChangedEventArgs] {
    fn get_FocusState(&self, out: *mut super::devices::MediaCaptureFocusState) -> HRESULT
}}
impl IMediaCaptureFocusChangedEventArgs {
    #[inline] pub fn get_focus_state(&self) -> Result<super::devices::MediaCaptureFocusState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FocusState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaCaptureFocusChangedEventArgs: IMediaCaptureFocusChangedEventArgs}
DEFINE_IID!(IID_IMediaCaptureInitializationSettings, 2541927024, 60005, 18688, 147, 86, 140, 168, 135, 114, 104, 132);
RT_INTERFACE!{interface IMediaCaptureInitializationSettings(IMediaCaptureInitializationSettingsVtbl, IMediaCaptureInitializationSettings_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCaptureInitializationSettings] {
    fn put_AudioDeviceId(&self, value: HSTRING) -> HRESULT,
    fn get_AudioDeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_VideoDeviceId(&self, value: HSTRING) -> HRESULT,
    fn get_VideoDeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_StreamingCaptureMode(&self, value: StreamingCaptureMode) -> HRESULT,
    fn get_StreamingCaptureMode(&self, out: *mut StreamingCaptureMode) -> HRESULT,
    fn put_PhotoCaptureSource(&self, value: PhotoCaptureSource) -> HRESULT,
    fn get_PhotoCaptureSource(&self, out: *mut PhotoCaptureSource) -> HRESULT
}}
impl IMediaCaptureInitializationSettings {
    #[inline] pub fn set_audio_device_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AudioDeviceId)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioDeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_video_device_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_VideoDeviceId)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_video_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoDeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_streaming_capture_mode(&self, value: StreamingCaptureMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_StreamingCaptureMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_streaming_capture_mode(&self) -> Result<StreamingCaptureMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StreamingCaptureMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_photo_capture_source(&self, value: PhotoCaptureSource) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PhotoCaptureSource)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_photo_capture_source(&self) -> Result<PhotoCaptureSource> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhotoCaptureSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaCaptureInitializationSettings: IMediaCaptureInitializationSettings}
impl RtActivatable<IActivationFactory> for MediaCaptureInitializationSettings {}
DEFINE_CLSID!(MediaCaptureInitializationSettings(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,97,112,116,117,114,101,46,77,101,100,105,97,67,97,112,116,117,114,101,73,110,105,116,105,97,108,105,122,97,116,105,111,110,83,101,116,116,105,110,103,115,0]) [CLSID_MediaCaptureInitializationSettings]);
DEFINE_IID!(IID_IMediaCaptureInitializationSettings2, 1078855206, 51676, 17385, 174, 228, 230, 191, 27, 87, 180, 76);
RT_INTERFACE!{interface IMediaCaptureInitializationSettings2(IMediaCaptureInitializationSettings2Vtbl, IMediaCaptureInitializationSettings2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCaptureInitializationSettings2] {
    fn put_MediaCategory(&self, value: MediaCategory) -> HRESULT,
    fn get_MediaCategory(&self, out: *mut MediaCategory) -> HRESULT,
    fn put_AudioProcessing(&self, value: super::AudioProcessing) -> HRESULT,
    fn get_AudioProcessing(&self, out: *mut super::AudioProcessing) -> HRESULT
}}
impl IMediaCaptureInitializationSettings2 {
    #[inline] pub fn set_media_category(&self, value: MediaCategory) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MediaCategory)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_media_category(&self) -> Result<MediaCategory> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaCategory)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_audio_processing(&self, value: super::AudioProcessing) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AudioProcessing)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_processing(&self) -> Result<super::AudioProcessing> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioProcessing)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaCaptureInitializationSettings3, 1096831389, 48712, 18224, 129, 4, 12, 246, 233, 233, 121, 72);
RT_INTERFACE!{interface IMediaCaptureInitializationSettings3(IMediaCaptureInitializationSettings3Vtbl, IMediaCaptureInitializationSettings3_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCaptureInitializationSettings3] {
    fn put_AudioSource(&self, value: <super::core::IMediaSource as RtType>::Abi) -> HRESULT,
    fn get_AudioSource(&self, out: *mut <super::core::IMediaSource as RtType>::Abi) -> HRESULT,
    fn put_VideoSource(&self, value: <super::core::IMediaSource as RtType>::Abi) -> HRESULT,
    fn get_VideoSource(&self, out: *mut <super::core::IMediaSource as RtType>::Abi) -> HRESULT
}}
impl IMediaCaptureInitializationSettings3 {
    #[inline] pub fn set_audio_source(&self, value: &super::core::IMediaSource) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AudioSource)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_source(&self) -> Result<Option<super::core::IMediaSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::core::IMediaSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_video_source(&self, value: &super::core::IMediaSource) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_VideoSource)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_video_source(&self) -> Result<Option<super::core::IMediaSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::core::IMediaSource::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaCaptureInitializationSettings4, 4110591287, 19639, 19752, 149, 237, 79, 159, 1, 46, 5, 24);
RT_INTERFACE!{interface IMediaCaptureInitializationSettings4(IMediaCaptureInitializationSettings4Vtbl, IMediaCaptureInitializationSettings4_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCaptureInitializationSettings4] {
    fn get_VideoProfile(&self, out: *mut <MediaCaptureVideoProfile as RtType>::Abi) -> HRESULT,
    fn put_VideoProfile(&self, value: <MediaCaptureVideoProfile as RtType>::Abi) -> HRESULT,
    fn get_PreviewMediaDescription(&self, out: *mut <MediaCaptureVideoProfileMediaDescription as RtType>::Abi) -> HRESULT,
    fn put_PreviewMediaDescription(&self, value: <MediaCaptureVideoProfileMediaDescription as RtType>::Abi) -> HRESULT,
    fn get_RecordMediaDescription(&self, out: *mut <MediaCaptureVideoProfileMediaDescription as RtType>::Abi) -> HRESULT,
    fn put_RecordMediaDescription(&self, value: <MediaCaptureVideoProfileMediaDescription as RtType>::Abi) -> HRESULT,
    fn get_PhotoMediaDescription(&self, out: *mut <MediaCaptureVideoProfileMediaDescription as RtType>::Abi) -> HRESULT,
    fn put_PhotoMediaDescription(&self, value: <MediaCaptureVideoProfileMediaDescription as RtType>::Abi) -> HRESULT
}}
impl IMediaCaptureInitializationSettings4 {
    #[inline] pub fn get_video_profile(&self) -> Result<Option<MediaCaptureVideoProfile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoProfile)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaCaptureVideoProfile::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_video_profile(&self, value: &MediaCaptureVideoProfile) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_VideoProfile)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_preview_media_description(&self) -> Result<Option<MediaCaptureVideoProfileMediaDescription>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PreviewMediaDescription)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaCaptureVideoProfileMediaDescription::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_preview_media_description(&self, value: &MediaCaptureVideoProfileMediaDescription) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PreviewMediaDescription)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_record_media_description(&self) -> Result<Option<MediaCaptureVideoProfileMediaDescription>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_RecordMediaDescription)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaCaptureVideoProfileMediaDescription::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_record_media_description(&self, value: &MediaCaptureVideoProfileMediaDescription) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_RecordMediaDescription)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_photo_media_description(&self) -> Result<Option<MediaCaptureVideoProfileMediaDescription>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhotoMediaDescription)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaCaptureVideoProfileMediaDescription::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_photo_media_description(&self, value: &MediaCaptureVideoProfileMediaDescription) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PhotoMediaDescription)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaCaptureInitializationSettings5, 3584222136, 9766, 20116, 183, 179, 83, 8, 160, 246, 75, 26);
RT_INTERFACE!{interface IMediaCaptureInitializationSettings5(IMediaCaptureInitializationSettings5Vtbl, IMediaCaptureInitializationSettings5_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCaptureInitializationSettings5] {
    fn get_SourceGroup(&self, out: *mut <frames::MediaFrameSourceGroup as RtType>::Abi) -> HRESULT,
    fn put_SourceGroup(&self, value: <frames::MediaFrameSourceGroup as RtType>::Abi) -> HRESULT,
    fn get_SharingMode(&self, out: *mut MediaCaptureSharingMode) -> HRESULT,
    fn put_SharingMode(&self, value: MediaCaptureSharingMode) -> HRESULT,
    fn get_MemoryPreference(&self, out: *mut MediaCaptureMemoryPreference) -> HRESULT,
    fn put_MemoryPreference(&self, value: MediaCaptureMemoryPreference) -> HRESULT
}}
impl IMediaCaptureInitializationSettings5 {
    #[inline] pub fn get_source_group(&self) -> Result<Option<frames::MediaFrameSourceGroup>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SourceGroup)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(frames::MediaFrameSourceGroup::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_source_group(&self, value: &frames::MediaFrameSourceGroup) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SourceGroup)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sharing_mode(&self) -> Result<MediaCaptureSharingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SharingMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_sharing_mode(&self, value: MediaCaptureSharingMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SharingMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_memory_preference(&self) -> Result<MediaCaptureMemoryPreference> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MemoryPreference)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_memory_preference(&self, value: MediaCaptureMemoryPreference) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MemoryPreference)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaCaptureInitializationSettings6, 3001183047, 15793, 19763, 171, 99, 15, 250, 9, 5, 101, 133);
RT_INTERFACE!{interface IMediaCaptureInitializationSettings6(IMediaCaptureInitializationSettings6Vtbl, IMediaCaptureInitializationSettings6_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCaptureInitializationSettings6] {
    fn get_AlwaysPlaySystemShutterSound(&self, out: *mut bool) -> HRESULT,
    fn put_AlwaysPlaySystemShutterSound(&self, value: bool) -> HRESULT
}}
impl IMediaCaptureInitializationSettings6 {
    #[inline] pub fn get_always_play_system_shutter_sound(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AlwaysPlaySystemShutterSound)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_always_play_system_shutter_sound(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AlwaysPlaySystemShutterSound)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum MediaCaptureMemoryPreference: i32 {
    Auto = 0, Cpu = 1,
}}
DEFINE_IID!(IID_IMediaCapturePauseResult, 2932112547, 17527, 19204, 160, 111, 44, 28, 81, 130, 254, 157);
RT_INTERFACE!{interface IMediaCapturePauseResult(IMediaCapturePauseResultVtbl, IMediaCapturePauseResult_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCapturePauseResult] {
    fn get_LastFrame(&self, out: *mut <super::VideoFrame as RtType>::Abi) -> HRESULT,
    fn get_RecordDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT
}}
impl IMediaCapturePauseResult {
    #[inline] pub fn get_last_frame(&self) -> Result<Option<super::VideoFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_LastFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::VideoFrame::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_record_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RecordDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaCapturePauseResult: IMediaCapturePauseResult}
DEFINE_IID!(IID_IMediaCaptureSettings, 495168254, 27973, 17527, 141, 196, 172, 91, 192, 28, 64, 145);
RT_INTERFACE!{interface IMediaCaptureSettings(IMediaCaptureSettingsVtbl, IMediaCaptureSettings_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCaptureSettings] {
    fn get_AudioDeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoDeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_StreamingCaptureMode(&self, out: *mut StreamingCaptureMode) -> HRESULT,
    fn get_PhotoCaptureSource(&self, out: *mut PhotoCaptureSource) -> HRESULT,
    fn get_VideoDeviceCharacteristic(&self, out: *mut VideoDeviceCharacteristic) -> HRESULT
}}
impl IMediaCaptureSettings {
    #[inline] pub fn get_audio_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioDeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoDeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_streaming_capture_mode(&self) -> Result<StreamingCaptureMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StreamingCaptureMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_photo_capture_source(&self) -> Result<PhotoCaptureSource> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhotoCaptureSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_video_device_characteristic(&self) -> Result<VideoDeviceCharacteristic> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoDeviceCharacteristic)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaCaptureSettings: IMediaCaptureSettings}
DEFINE_IID!(IID_IMediaCaptureSettings2, 1872657659, 64159, 19219, 156, 190, 90, 185, 79, 31, 52, 147);
RT_INTERFACE!{interface IMediaCaptureSettings2(IMediaCaptureSettings2Vtbl, IMediaCaptureSettings2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCaptureSettings2] {
    fn get_ConcurrentRecordAndPhotoSupported(&self, out: *mut bool) -> HRESULT,
    fn get_ConcurrentRecordAndPhotoSequenceSupported(&self, out: *mut bool) -> HRESULT,
    fn get_CameraSoundRequiredForRegion(&self, out: *mut bool) -> HRESULT,
    fn get_Horizontal35mmEquivalentFocalLength(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_PitchOffsetDegrees(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_Vertical35mmEquivalentFocalLength(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_MediaCategory(&self, out: *mut MediaCategory) -> HRESULT,
    fn get_AudioProcessing(&self, out: *mut super::AudioProcessing) -> HRESULT
}}
impl IMediaCaptureSettings2 {
    #[inline] pub fn get_concurrent_record_and_photo_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConcurrentRecordAndPhotoSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_concurrent_record_and_photo_sequence_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConcurrentRecordAndPhotoSequenceSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_camera_sound_required_for_region(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CameraSoundRequiredForRegion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_horizontal_35mm_equivalent_focal_length(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Horizontal35mmEquivalentFocalLength)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_pitch_offset_degrees(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PitchOffsetDegrees)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_vertical_35mm_equivalent_focal_length(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Vertical35mmEquivalentFocalLength)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_media_category(&self) -> Result<MediaCategory> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaCategory)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_processing(&self) -> Result<super::AudioProcessing> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioProcessing)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaCaptureSettings3, 809265090, 32856, 19227, 184, 119, 140, 46, 243, 82, 132, 64);
RT_INTERFACE!{interface IMediaCaptureSettings3(IMediaCaptureSettings3Vtbl, IMediaCaptureSettings3_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCaptureSettings3] {
    #[cfg(feature="windows-graphics")] fn get_Direct3D11Device(&self, out: *mut <super::super::graphics::directx::direct3d11::IDirect3DDevice as RtType>::Abi) -> HRESULT
}}
impl IMediaCaptureSettings3 {
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_direct3d11_device(&self) -> Result<Option<super::super::graphics::directx::direct3d11::IDirect3DDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Direct3D11Device)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::graphics::directx::direct3d11::IDirect3DDevice::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum MediaCaptureSharingMode: i32 {
    ExclusiveControl = 0, SharedReadOnly = 1,
}}
DEFINE_IID!(IID_IMediaCaptureStatics, 2901377535, 39405, 17989, 150, 94, 25, 37, 207, 198, 56, 52);
RT_INTERFACE!{static interface IMediaCaptureStatics(IMediaCaptureStaticsVtbl, IMediaCaptureStatics_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCaptureStatics] {
    fn IsVideoProfileSupported(&self, videoDeviceId: HSTRING, out: *mut bool) -> HRESULT,
    fn FindAllVideoProfiles(&self, videoDeviceId: HSTRING, out: *mut <foundation::collections::IVectorView<MediaCaptureVideoProfile> as RtType>::Abi) -> HRESULT,
    fn FindConcurrentProfiles(&self, videoDeviceId: HSTRING, out: *mut <foundation::collections::IVectorView<MediaCaptureVideoProfile> as RtType>::Abi) -> HRESULT,
    fn FindKnownVideoProfiles(&self, videoDeviceId: HSTRING, name: KnownVideoProfile, out: *mut <foundation::collections::IVectorView<MediaCaptureVideoProfile> as RtType>::Abi) -> HRESULT
}}
impl IMediaCaptureStatics {
    #[inline] pub fn is_video_profile_supported(&self, videoDeviceId: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsVideoProfileSupported)(self.0.as_abi() as *const _ as *mut _, videoDeviceId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn find_all_video_profiles(&self, videoDeviceId: &HStringArg) -> Result<Option<foundation::collections::IVectorView<MediaCaptureVideoProfile>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindAllVideoProfiles)(self.0.as_abi() as *const _ as *mut _, videoDeviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_concurrent_profiles(&self, videoDeviceId: &HStringArg) -> Result<Option<foundation::collections::IVectorView<MediaCaptureVideoProfile>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindConcurrentProfiles)(self.0.as_abi() as *const _ as *mut _, videoDeviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_known_video_profiles(&self, videoDeviceId: &HStringArg, name: KnownVideoProfile) -> Result<Option<foundation::collections::IVectorView<MediaCaptureVideoProfile>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindKnownVideoProfiles)(self.0.as_abi() as *const _ as *mut _, videoDeviceId.get(), name, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaCaptureStopResult, 4191906346, 41106, 19153, 151, 212, 242, 1, 249, 208, 130, 219);
RT_INTERFACE!{interface IMediaCaptureStopResult(IMediaCaptureStopResultVtbl, IMediaCaptureStopResult_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCaptureStopResult] {
    fn get_LastFrame(&self, out: *mut <super::VideoFrame as RtType>::Abi) -> HRESULT,
    fn get_RecordDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT
}}
impl IMediaCaptureStopResult {
    #[inline] pub fn get_last_frame(&self) -> Result<Option<super::VideoFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_LastFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::VideoFrame::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_record_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RecordDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaCaptureStopResult: IMediaCaptureStopResult}
RT_ENUM! { enum MediaCaptureThermalStatus: i32 {
    Normal = 0, Overheated = 1,
}}
DEFINE_IID!(IID_IMediaCaptureVideoPreview, 661811315, 21662, 17535, 162, 10, 79, 3, 196, 121, 216, 192);
RT_INTERFACE!{interface IMediaCaptureVideoPreview(IMediaCaptureVideoPreviewVtbl, IMediaCaptureVideoPreview_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCaptureVideoPreview] {
    fn StartPreviewAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn StartPreviewToCustomSinkAsync(&self, encodingProfile: <super::mediaproperties::MediaEncodingProfile as RtType>::Abi, customMediaSink: <super::IMediaExtension as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn StartPreviewToCustomSinkIdAsync(&self, encodingProfile: <super::mediaproperties::MediaEncodingProfile as RtType>::Abi, customSinkActivationId: HSTRING, customSinkSettings: <foundation::collections::IPropertySet as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn StopPreviewAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IMediaCaptureVideoPreview {
    #[inline] pub fn start_preview_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StartPreviewAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn start_preview_to_custom_sink_async(&self, encodingProfile: &super::mediaproperties::MediaEncodingProfile, customMediaSink: &super::IMediaExtension) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StartPreviewToCustomSinkAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(encodingProfile) as *const _ as *mut _, get_abi(customMediaSink) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn start_preview_to_custom_sink_id_async(&self, encodingProfile: &super::mediaproperties::MediaEncodingProfile, customSinkActivationId: &HStringArg, customSinkSettings: &foundation::collections::IPropertySet) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StartPreviewToCustomSinkIdAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(encodingProfile) as *const _ as *mut _, customSinkActivationId.get(), get_abi(customSinkSettings) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn stop_preview_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StopPreviewAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaCaptureVideoProfile, 564163519, 41966, 20175, 158, 246, 80, 176, 188, 78, 19, 5);
RT_INTERFACE!{interface IMediaCaptureVideoProfile(IMediaCaptureVideoProfileVtbl, IMediaCaptureVideoProfile_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCaptureVideoProfile] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoDeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SupportedPreviewMediaDescription(&self, out: *mut <foundation::collections::IVectorView<MediaCaptureVideoProfileMediaDescription> as RtType>::Abi) -> HRESULT,
    fn get_SupportedRecordMediaDescription(&self, out: *mut <foundation::collections::IVectorView<MediaCaptureVideoProfileMediaDescription> as RtType>::Abi) -> HRESULT,
    fn get_SupportedPhotoMediaDescription(&self, out: *mut <foundation::collections::IVectorView<MediaCaptureVideoProfileMediaDescription> as RtType>::Abi) -> HRESULT,
    fn GetConcurrency(&self, out: *mut <foundation::collections::IVectorView<MediaCaptureVideoProfile> as RtType>::Abi) -> HRESULT
}}
impl IMediaCaptureVideoProfile {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoDeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_preview_media_description(&self) -> Result<Option<foundation::collections::IVectorView<MediaCaptureVideoProfileMediaDescription>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedPreviewMediaDescription)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_record_media_description(&self) -> Result<Option<foundation::collections::IVectorView<MediaCaptureVideoProfileMediaDescription>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedRecordMediaDescription)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_photo_media_description(&self) -> Result<Option<foundation::collections::IVectorView<MediaCaptureVideoProfileMediaDescription>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedPhotoMediaDescription)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_concurrency(&self) -> Result<Option<foundation::collections::IVectorView<MediaCaptureVideoProfile>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetConcurrency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaCaptureVideoProfile: IMediaCaptureVideoProfile}
DEFINE_IID!(IID_IMediaCaptureVideoProfile2, 2547894623, 38094, 18063, 147, 22, 252, 91, 194, 99, 143, 107);
RT_INTERFACE!{interface IMediaCaptureVideoProfile2(IMediaCaptureVideoProfile2Vtbl, IMediaCaptureVideoProfile2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCaptureVideoProfile2] {
    fn get_FrameSourceInfos(&self, out: *mut <foundation::collections::IVectorView<frames::MediaFrameSourceInfo> as RtType>::Abi) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<Guid, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl IMediaCaptureVideoProfile2 {
    #[inline] pub fn get_frame_source_infos(&self) -> Result<Option<foundation::collections::IVectorView<frames::MediaFrameSourceInfo>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameSourceInfos)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<Guid, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaCaptureVideoProfileMediaDescription, 2148708335, 46737, 18943, 131, 242, 193, 231, 110, 170, 234, 27);
RT_INTERFACE!{interface IMediaCaptureVideoProfileMediaDescription(IMediaCaptureVideoProfileMediaDescriptionVtbl, IMediaCaptureVideoProfileMediaDescription_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCaptureVideoProfileMediaDescription] {
    fn get_Width(&self, out: *mut u32) -> HRESULT,
    fn get_Height(&self, out: *mut u32) -> HRESULT,
    fn get_FrameRate(&self, out: *mut f64) -> HRESULT,
    fn get_IsVariablePhotoSequenceSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsHdrVideoSupported(&self, out: *mut bool) -> HRESULT
}}
impl IMediaCaptureVideoProfileMediaDescription {
    #[inline] pub fn get_width(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Width)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_height(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Height)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_frame_rate(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_variable_photo_sequence_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsVariablePhotoSequenceSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_hdr_video_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsHdrVideoSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaCaptureVideoProfileMediaDescription: IMediaCaptureVideoProfileMediaDescription}
DEFINE_IID!(IID_IMediaCaptureVideoProfileMediaDescription2, 3332828947, 12845, 16698, 184, 90, 104, 168, 142, 2, 244, 233);
RT_INTERFACE!{interface IMediaCaptureVideoProfileMediaDescription2(IMediaCaptureVideoProfileMediaDescription2Vtbl, IMediaCaptureVideoProfileMediaDescription2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCaptureVideoProfileMediaDescription2] {
    fn get_Subtype(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<Guid, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl IMediaCaptureVideoProfileMediaDescription2 {
    #[inline] pub fn get_subtype(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Subtype)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<Guid, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum MediaCategory: i32 {
    Other = 0, Communications = 1, Media = 2, GameChat = 3, Speech = 4,
}}
RT_ENUM! { enum MediaStreamType: i32 {
    VideoPreview = 0, VideoRecord = 1, Audio = 2, Photo = 3,
}}
DEFINE_IID!(IID_IOptionalReferencePhotoCapturedEventArgs, 1192200371, 7789, 16465, 156, 139, 241, 216, 90, 240, 71, 183);
RT_INTERFACE!{interface IOptionalReferencePhotoCapturedEventArgs(IOptionalReferencePhotoCapturedEventArgsVtbl, IOptionalReferencePhotoCapturedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IOptionalReferencePhotoCapturedEventArgs] {
    fn get_Frame(&self, out: *mut <CapturedFrame as RtType>::Abi) -> HRESULT,
    fn get_Context(&self, out: *mut <IInspectable as RtType>::Abi) -> HRESULT
}}
impl IOptionalReferencePhotoCapturedEventArgs {
    #[inline] pub fn get_frame(&self) -> Result<Option<CapturedFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Frame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CapturedFrame::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_context(&self) -> Result<Option<IInspectable>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Context)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IInspectable::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class OptionalReferencePhotoCapturedEventArgs: IOptionalReferencePhotoCapturedEventArgs}
DEFINE_IID!(IID_IPhotoCapturedEventArgs, 926677953, 38990, 20464, 191, 133, 28, 0, 170, 188, 90, 69);
RT_INTERFACE!{interface IPhotoCapturedEventArgs(IPhotoCapturedEventArgsVtbl, IPhotoCapturedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPhotoCapturedEventArgs] {
    fn get_Frame(&self, out: *mut <CapturedFrame as RtType>::Abi) -> HRESULT,
    fn get_Thumbnail(&self, out: *mut <CapturedFrame as RtType>::Abi) -> HRESULT,
    fn get_CaptureTimeOffset(&self, out: *mut foundation::TimeSpan) -> HRESULT
}}
impl IPhotoCapturedEventArgs {
    #[inline] pub fn get_frame(&self) -> Result<Option<CapturedFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Frame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CapturedFrame::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_thumbnail(&self) -> Result<Option<CapturedFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Thumbnail)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CapturedFrame::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_capture_time_offset(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CaptureTimeOffset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PhotoCapturedEventArgs: IPhotoCapturedEventArgs}
RT_ENUM! { enum PhotoCaptureSource: i32 {
    Auto = 0, VideoPreview = 1, Photo = 2,
}}
DEFINE_IID!(IID_IPhotoConfirmationCapturedEventArgs, 2873570930, 49802, 18471, 143, 141, 54, 54, 211, 190, 181, 30);
RT_INTERFACE!{interface IPhotoConfirmationCapturedEventArgs(IPhotoConfirmationCapturedEventArgsVtbl, IPhotoConfirmationCapturedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPhotoConfirmationCapturedEventArgs] {
    fn get_Frame(&self, out: *mut <CapturedFrame as RtType>::Abi) -> HRESULT,
    fn get_CaptureTimeOffset(&self, out: *mut foundation::TimeSpan) -> HRESULT
}}
impl IPhotoConfirmationCapturedEventArgs {
    #[inline] pub fn get_frame(&self) -> Result<Option<CapturedFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Frame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CapturedFrame::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_capture_time_offset(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CaptureTimeOffset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PhotoConfirmationCapturedEventArgs: IPhotoConfirmationCapturedEventArgs}
RT_ENUM! { enum PowerlineFrequency: i32 {
    Disabled = 0, FiftyHertz = 1, SixtyHertz = 2, Auto = 3,
}}
DEFINE_IID!(IID_RecordLimitationExceededEventHandler, 1068404526, 20449, 20477, 170, 186, 225, 241, 51, 125, 78, 83);
RT_DELEGATE!{delegate RecordLimitationExceededEventHandler(RecordLimitationExceededEventHandlerVtbl, RecordLimitationExceededEventHandler_Abi, RecordLimitationExceededEventHandlerImpl) [IID_RecordLimitationExceededEventHandler] {
    fn Invoke(&self, sender: <MediaCapture as RtType>::Abi) -> HRESULT
}}
impl RecordLimitationExceededEventHandler {
    #[inline] pub fn invoke(&self, sender: &MediaCapture) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Invoke)(self.0.as_abi() as *const _ as *mut _, get_abi(sender) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum StreamingCaptureMode: i32 {
    AudioAndVideo = 0, Audio = 1, Video = 2,
}}
RT_ENUM! { enum VideoDeviceCharacteristic: i32 {
    AllStreamsIndependent = 0, PreviewRecordStreamsIdentical = 1, PreviewPhotoStreamsIdentical = 2, RecordPhotoStreamsIdentical = 3, AllStreamsIdentical = 4,
}}
RT_ENUM! { enum VideoRotation: i32 {
    None = 0, Clockwise90Degrees = 1, Clockwise180Degrees = 2, Clockwise270Degrees = 3,
}}
DEFINE_IID!(IID_IVideoStreamConfiguration, 3631680111, 17296, 19294, 173, 62, 15, 138, 240, 150, 52, 144);
RT_INTERFACE!{interface IVideoStreamConfiguration(IVideoStreamConfigurationVtbl, IVideoStreamConfiguration_Abi): IInspectable(IInspectableVtbl) [IID_IVideoStreamConfiguration] {
    fn get_InputProperties(&self, out: *mut <super::mediaproperties::VideoEncodingProperties as RtType>::Abi) -> HRESULT,
    fn get_OutputProperties(&self, out: *mut <super::mediaproperties::VideoEncodingProperties as RtType>::Abi) -> HRESULT
}}
impl IVideoStreamConfiguration {
    #[inline] pub fn get_input_properties(&self) -> Result<Option<super::mediaproperties::VideoEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_InputProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::mediaproperties::VideoEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_output_properties(&self) -> Result<Option<super::mediaproperties::VideoEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_OutputProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::mediaproperties::VideoEncodingProperties::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VideoStreamConfiguration: IVideoStreamConfiguration}
RT_STRUCT! { struct WhiteBalanceGain {
    R: f64, G: f64, B: f64,
}}
pub mod core { // Windows.Media.Capture.Core
use crate::prelude::*;
DEFINE_IID!(IID_IVariablePhotoCapturedEventArgs, 3521858652, 6995, 20042, 139, 92, 219, 120, 135, 172, 148, 155);
RT_INTERFACE!{interface IVariablePhotoCapturedEventArgs(IVariablePhotoCapturedEventArgsVtbl, IVariablePhotoCapturedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IVariablePhotoCapturedEventArgs] {
    fn get_Frame(&self, out: *mut <super::CapturedFrame as RtType>::Abi) -> HRESULT,
    fn get_CaptureTimeOffset(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_UsedFrameControllerIndex(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_CapturedFrameControlValues(&self, out: *mut <super::CapturedFrameControlValues as RtType>::Abi) -> HRESULT
}}
impl IVariablePhotoCapturedEventArgs {
    #[inline] pub fn get_frame(&self) -> Result<Option<super::CapturedFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Frame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::CapturedFrame::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_capture_time_offset(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CaptureTimeOffset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_used_frame_controller_index(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsedFrameControllerIndex)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_captured_frame_control_values(&self) -> Result<Option<super::CapturedFrameControlValues>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CapturedFrameControlValues)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::CapturedFrameControlValues::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VariablePhotoCapturedEventArgs: IVariablePhotoCapturedEventArgs}
DEFINE_IID!(IID_IVariablePhotoSequenceCapture, 3490786589, 798, 16449, 166, 214, 189, 116, 36, 118, 168, 238);
RT_INTERFACE!{interface IVariablePhotoSequenceCapture(IVariablePhotoSequenceCaptureVtbl, IVariablePhotoSequenceCapture_Abi): IInspectable(IInspectableVtbl) [IID_IVariablePhotoSequenceCapture] {
    fn StartAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn StopAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn FinishAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn add_PhotoCaptured(&self, handler: <foundation::TypedEventHandler<VariablePhotoSequenceCapture, VariablePhotoCapturedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PhotoCaptured(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Stopped(&self, handler: <foundation::TypedEventHandler<VariablePhotoSequenceCapture, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Stopped(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IVariablePhotoSequenceCapture {
    #[inline] pub fn start_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StartAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn stop_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StopAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn finish_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FinishAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_photo_captured(&self, handler: &foundation::TypedEventHandler<VariablePhotoSequenceCapture, VariablePhotoCapturedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PhotoCaptured)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_photo_captured(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PhotoCaptured)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stopped(&self, handler: &foundation::TypedEventHandler<VariablePhotoSequenceCapture, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Stopped)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stopped(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Stopped)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class VariablePhotoSequenceCapture: IVariablePhotoSequenceCapture}
DEFINE_IID!(IID_IVariablePhotoSequenceCapture2, 4264321724, 20656, 17379, 145, 124, 227, 185, 39, 152, 148, 47);
RT_INTERFACE!{interface IVariablePhotoSequenceCapture2(IVariablePhotoSequenceCapture2Vtbl, IVariablePhotoSequenceCapture2_Abi): IInspectable(IInspectableVtbl) [IID_IVariablePhotoSequenceCapture2] {
    fn UpdateSettingsAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IVariablePhotoSequenceCapture2 {
    #[inline] pub fn update_settings_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).UpdateSettingsAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
} // Windows.Media.Capture.Core
pub mod frames { // Windows.Media.Capture.Frames
use crate::prelude::*;
DEFINE_IID!(IID_IAudioMediaFrame, 2745827071, 32801, 17435, 154, 70, 231, 240, 19, 123, 121, 129);
RT_INTERFACE!{interface IAudioMediaFrame(IAudioMediaFrameVtbl, IAudioMediaFrame_Abi): IInspectable(IInspectableVtbl) [IID_IAudioMediaFrame] {
    fn get_FrameReference(&self, out: *mut <MediaFrameReference as RtType>::Abi) -> HRESULT,
    fn get_AudioEncodingProperties(&self, out: *mut <super::super::mediaproperties::AudioEncodingProperties as RtType>::Abi) -> HRESULT,
    fn GetAudioFrame(&self, out: *mut <super::super::AudioFrame as RtType>::Abi) -> HRESULT
}}
impl IAudioMediaFrame {
    #[inline] pub fn get_frame_reference(&self) -> Result<Option<MediaFrameReference>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameReference)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaFrameReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_encoding_properties(&self) -> Result<Option<super::super::mediaproperties::AudioEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioEncodingProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::mediaproperties::AudioEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_frame(&self) -> Result<Option<super::super::AudioFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAudioFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::AudioFrame::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioMediaFrame: IAudioMediaFrame}
DEFINE_IID!(IID_IBufferMediaFrame, 3048297415, 39812, 16482, 183, 156, 163, 101, 178, 89, 104, 84);
RT_INTERFACE!{interface IBufferMediaFrame(IBufferMediaFrameVtbl, IBufferMediaFrame_Abi): IInspectable(IInspectableVtbl) [IID_IBufferMediaFrame] {
    fn get_FrameReference(&self, out: *mut <MediaFrameReference as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_Buffer(&self, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IBufferMediaFrame {
    #[inline] pub fn get_frame_reference(&self) -> Result<Option<MediaFrameReference>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameReference)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaFrameReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_buffer(&self) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Buffer)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BufferMediaFrame: IBufferMediaFrame}
DEFINE_IID!(IID_IDepthMediaFrame, 1192451663, 34121, 17856, 146, 91, 128, 211, 94, 253, 177, 10);
RT_INTERFACE!{interface IDepthMediaFrame(IDepthMediaFrameVtbl, IDepthMediaFrame_Abi): IInspectable(IInspectableVtbl) [IID_IDepthMediaFrame] {
    fn get_FrameReference(&self, out: *mut <MediaFrameReference as RtType>::Abi) -> HRESULT,
    fn get_VideoMediaFrame(&self, out: *mut <VideoMediaFrame as RtType>::Abi) -> HRESULT,
    fn get_DepthFormat(&self, out: *mut <DepthMediaFrameFormat as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-perception")] fn TryCreateCoordinateMapper(&self, cameraIntrinsics: <super::super::devices::core::CameraIntrinsics as RtType>::Abi, coordinateSystem: <crate::windows::perception::spatial::SpatialCoordinateSystem as RtType>::Abi, out: *mut <super::super::devices::core::DepthCorrelatedCoordinateMapper as RtType>::Abi) -> HRESULT
}}
impl IDepthMediaFrame {
    #[inline] pub fn get_frame_reference(&self) -> Result<Option<MediaFrameReference>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameReference)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaFrameReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_media_frame(&self) -> Result<Option<VideoMediaFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoMediaFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoMediaFrame::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_depth_format(&self) -> Result<Option<DepthMediaFrameFormat>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DepthFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DepthMediaFrameFormat::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-perception")] #[inline] pub fn try_create_coordinate_mapper(&self, cameraIntrinsics: &super::super::devices::core::CameraIntrinsics, coordinateSystem: &crate::windows::perception::spatial::SpatialCoordinateSystem) -> Result<Option<super::super::devices::core::DepthCorrelatedCoordinateMapper>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryCreateCoordinateMapper)(self.0.as_abi() as *const _ as *mut _, get_abi(cameraIntrinsics) as *const _ as *mut _, get_abi(coordinateSystem) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::core::DepthCorrelatedCoordinateMapper::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DepthMediaFrame: IDepthMediaFrame}
DEFINE_IID!(IID_IDepthMediaFrame2, 1825195837, 50340, 16758, 176, 205, 51, 234, 227, 179, 90, 163);
RT_INTERFACE!{interface IDepthMediaFrame2(IDepthMediaFrame2Vtbl, IDepthMediaFrame2_Abi): IInspectable(IInspectableVtbl) [IID_IDepthMediaFrame2] {
    fn get_MaxReliableDepth(&self, out: *mut u32) -> HRESULT,
    fn get_MinReliableDepth(&self, out: *mut u32) -> HRESULT
}}
impl IDepthMediaFrame2 {
    #[inline] pub fn get_max_reliable_depth(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxReliableDepth)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_reliable_depth(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinReliableDepth)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDepthMediaFrameFormat, 3272789824, 55081, 17726, 135, 128, 46, 4, 241, 64, 210, 142);
RT_INTERFACE!{interface IDepthMediaFrameFormat(IDepthMediaFrameFormatVtbl, IDepthMediaFrameFormat_Abi): IInspectable(IInspectableVtbl) [IID_IDepthMediaFrameFormat] {
    fn get_VideoFormat(&self, out: *mut <VideoMediaFrameFormat as RtType>::Abi) -> HRESULT,
    fn get_DepthScaleInMeters(&self, out: *mut f64) -> HRESULT
}}
impl IDepthMediaFrameFormat {
    #[inline] pub fn get_video_format(&self) -> Result<Option<VideoMediaFrameFormat>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoMediaFrameFormat::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_depth_scale_in_meters(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DepthScaleInMeters)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DepthMediaFrameFormat: IDepthMediaFrameFormat}
DEFINE_IID!(IID_IInfraredMediaFrame, 1070675203, 75, 20238, 145, 172, 70, 82, 153, 180, 22, 88);
RT_INTERFACE!{interface IInfraredMediaFrame(IInfraredMediaFrameVtbl, IInfraredMediaFrame_Abi): IInspectable(IInspectableVtbl) [IID_IInfraredMediaFrame] {
    fn get_FrameReference(&self, out: *mut <MediaFrameReference as RtType>::Abi) -> HRESULT,
    fn get_VideoMediaFrame(&self, out: *mut <VideoMediaFrame as RtType>::Abi) -> HRESULT,
    fn get_IsIlluminated(&self, out: *mut bool) -> HRESULT
}}
impl IInfraredMediaFrame {
    #[inline] pub fn get_frame_reference(&self) -> Result<Option<MediaFrameReference>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameReference)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaFrameReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_media_frame(&self) -> Result<Option<VideoMediaFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoMediaFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoMediaFrame::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_illuminated(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsIlluminated)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class InfraredMediaFrame: IInfraredMediaFrame}
DEFINE_IID!(IID_IMediaFrameArrivedEventArgs, 188943069, 42128, 17461, 173, 161, 154, 255, 213, 82, 57, 247);
RT_INTERFACE!{interface IMediaFrameArrivedEventArgs(IMediaFrameArrivedEventArgsVtbl, IMediaFrameArrivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaFrameArrivedEventArgs] {
    
}}
RT_CLASS!{class MediaFrameArrivedEventArgs: IMediaFrameArrivedEventArgs}
DEFINE_IID!(IID_IMediaFrameFormat, 1905273678, 45689, 19095, 169, 219, 189, 90, 47, 183, 143, 57);
RT_INTERFACE!{interface IMediaFrameFormat(IMediaFrameFormatVtbl, IMediaFrameFormat_Abi): IInspectable(IInspectableVtbl) [IID_IMediaFrameFormat] {
    fn get_MajorType(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Subtype(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FrameRate(&self, out: *mut <super::super::mediaproperties::MediaRatio as RtType>::Abi) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<Guid, IInspectable> as RtType>::Abi) -> HRESULT,
    fn get_VideoFormat(&self, out: *mut <VideoMediaFrameFormat as RtType>::Abi) -> HRESULT
}}
impl IMediaFrameFormat {
    #[inline] pub fn get_major_type(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MajorType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_subtype(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Subtype)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_frame_rate(&self) -> Result<Option<super::super::mediaproperties::MediaRatio>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::mediaproperties::MediaRatio::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<Guid, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format(&self) -> Result<Option<VideoMediaFrameFormat>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoMediaFrameFormat::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaFrameFormat: IMediaFrameFormat}
DEFINE_IID!(IID_IMediaFrameFormat2, 1669686080, 24199, 19472, 134, 209, 109, 240, 151, 166, 198, 168);
RT_INTERFACE!{interface IMediaFrameFormat2(IMediaFrameFormat2Vtbl, IMediaFrameFormat2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaFrameFormat2] {
    fn get_AudioEncodingProperties(&self, out: *mut <super::super::mediaproperties::AudioEncodingProperties as RtType>::Abi) -> HRESULT
}}
impl IMediaFrameFormat2 {
    #[inline] pub fn get_audio_encoding_properties(&self) -> Result<Option<super::super::mediaproperties::AudioEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioEncodingProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::mediaproperties::AudioEncodingProperties::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaFrameReader, 3838395285, 8232, 18669, 144, 176, 209, 193, 177, 98, 226, 76);
RT_INTERFACE!{interface IMediaFrameReader(IMediaFrameReaderVtbl, IMediaFrameReader_Abi): IInspectable(IInspectableVtbl) [IID_IMediaFrameReader] {
    fn add_FrameArrived(&self, handler: <foundation::TypedEventHandler<MediaFrameReader, MediaFrameArrivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FrameArrived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn TryAcquireLatestFrame(&self, out: *mut <MediaFrameReference as RtType>::Abi) -> HRESULT,
    fn StartAsync(&self, out: *mut <foundation::IAsyncOperation<MediaFrameReaderStartStatus> as RtType>::Abi) -> HRESULT,
    fn StopAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IMediaFrameReader {
    #[inline] pub fn add_frame_arrived(&self, handler: &foundation::TypedEventHandler<MediaFrameReader, MediaFrameArrivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_FrameArrived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_frame_arrived(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_FrameArrived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_acquire_latest_frame(&self) -> Result<Option<MediaFrameReference>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryAcquireLatestFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaFrameReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn start_async(&self) -> Result<foundation::IAsyncOperation<MediaFrameReaderStartStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StartAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn stop_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StopAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaFrameReader: IMediaFrameReader}
DEFINE_IID!(IID_IMediaFrameReader2, 2266048435, 34097, 16464, 135, 204, 161, 55, 51, 207, 62, 155);
RT_INTERFACE!{interface IMediaFrameReader2(IMediaFrameReader2Vtbl, IMediaFrameReader2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaFrameReader2] {
    fn put_AcquisitionMode(&self, value: MediaFrameReaderAcquisitionMode) -> HRESULT,
    fn get_AcquisitionMode(&self, out: *mut MediaFrameReaderAcquisitionMode) -> HRESULT
}}
impl IMediaFrameReader2 {
    #[inline] pub fn set_acquisition_mode(&self, value: MediaFrameReaderAcquisitionMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AcquisitionMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_acquisition_mode(&self) -> Result<MediaFrameReaderAcquisitionMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AcquisitionMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum MediaFrameReaderAcquisitionMode: i32 {
    Realtime = 0, Buffered = 1,
}}
RT_ENUM! { enum MediaFrameReaderStartStatus: i32 {
    Success = 0, UnknownFailure = 1, DeviceNotAvailable = 2, OutputFormatNotSupported = 3, ExclusiveControlNotAvailable = 4,
}}
DEFINE_IID!(IID_IMediaFrameReference, 4139288129, 61660, 16452, 141, 201, 150, 28, 237, 208, 91, 173);
RT_INTERFACE!{interface IMediaFrameReference(IMediaFrameReferenceVtbl, IMediaFrameReference_Abi): IInspectable(IInspectableVtbl) [IID_IMediaFrameReference] {
    fn get_SourceKind(&self, out: *mut MediaFrameSourceKind) -> HRESULT,
    fn get_Format(&self, out: *mut <MediaFrameFormat as RtType>::Abi) -> HRESULT,
    fn get_SystemRelativeTime(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<Guid, IInspectable> as RtType>::Abi) -> HRESULT,
    fn get_BufferMediaFrame(&self, out: *mut <BufferMediaFrame as RtType>::Abi) -> HRESULT,
    fn get_VideoMediaFrame(&self, out: *mut <VideoMediaFrame as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-perception")] fn get_CoordinateSystem(&self, out: *mut <crate::windows::perception::spatial::SpatialCoordinateSystem as RtType>::Abi) -> HRESULT
}}
impl IMediaFrameReference {
    #[inline] pub fn get_source_kind(&self) -> Result<MediaFrameSourceKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SourceKind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_format(&self) -> Result<Option<MediaFrameFormat>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Format)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaFrameFormat::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_system_relative_time(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SystemRelativeTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<Guid, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_buffer_media_frame(&self) -> Result<Option<BufferMediaFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BufferMediaFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BufferMediaFrame::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_media_frame(&self) -> Result<Option<VideoMediaFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoMediaFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoMediaFrame::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-perception")] #[inline] pub fn get_coordinate_system(&self) -> Result<Option<crate::windows::perception::spatial::SpatialCoordinateSystem>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CoordinateSystem)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::perception::spatial::SpatialCoordinateSystem::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaFrameReference: IMediaFrameReference}
DEFINE_IID!(IID_IMediaFrameReference2, 3720101580, 54706, 18927, 131, 106, 148, 125, 152, 155, 128, 193);
RT_INTERFACE!{interface IMediaFrameReference2(IMediaFrameReference2Vtbl, IMediaFrameReference2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaFrameReference2] {
    fn get_AudioMediaFrame(&self, out: *mut <AudioMediaFrame as RtType>::Abi) -> HRESULT
}}
impl IMediaFrameReference2 {
    #[inline] pub fn get_audio_media_frame(&self) -> Result<Option<AudioMediaFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioMediaFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioMediaFrame::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaFrameSource, 3598199123, 37083, 18088, 138, 221, 42, 168, 132, 168, 210, 83);
RT_INTERFACE!{interface IMediaFrameSource(IMediaFrameSourceVtbl, IMediaFrameSource_Abi): IInspectable(IInspectableVtbl) [IID_IMediaFrameSource] {
    fn get_Info(&self, out: *mut <MediaFrameSourceInfo as RtType>::Abi) -> HRESULT,
    fn get_Controller(&self, out: *mut <MediaFrameSourceController as RtType>::Abi) -> HRESULT,
    fn get_SupportedFormats(&self, out: *mut <foundation::collections::IVectorView<MediaFrameFormat> as RtType>::Abi) -> HRESULT,
    fn get_CurrentFormat(&self, out: *mut <MediaFrameFormat as RtType>::Abi) -> HRESULT,
    fn SetFormatAsync(&self, format: <MediaFrameFormat as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn add_FormatChanged(&self, handler: <foundation::TypedEventHandler<MediaFrameSource, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FormatChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn TryGetCameraIntrinsics(&self, format: <MediaFrameFormat as RtType>::Abi, out: *mut <super::super::devices::core::CameraIntrinsics as RtType>::Abi) -> HRESULT
}}
impl IMediaFrameSource {
    #[inline] pub fn get_info(&self) -> Result<Option<MediaFrameSourceInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Info)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaFrameSourceInfo::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_controller(&self) -> Result<Option<MediaFrameSourceController>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Controller)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaFrameSourceController::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_formats(&self) -> Result<Option<foundation::collections::IVectorView<MediaFrameFormat>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedFormats)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_current_format(&self) -> Result<Option<MediaFrameFormat>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CurrentFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaFrameFormat::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_format_async(&self, format: &MediaFrameFormat) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetFormatAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(format) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_format_changed(&self, handler: &foundation::TypedEventHandler<MediaFrameSource, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_FormatChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_format_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_FormatChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_get_camera_intrinsics(&self, format: &MediaFrameFormat) -> Result<Option<super::super::devices::core::CameraIntrinsics>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryGetCameraIntrinsics)(self.0.as_abi() as *const _ as *mut _, get_abi(format) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::core::CameraIntrinsics::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaFrameSource: IMediaFrameSource}
DEFINE_IID!(IID_IMediaFrameSourceController, 1829201461, 12653, 19343, 183, 182, 238, 176, 74, 140, 101, 37);
RT_INTERFACE!{interface IMediaFrameSourceController(IMediaFrameSourceControllerVtbl, IMediaFrameSourceController_Abi): IInspectable(IInspectableVtbl) [IID_IMediaFrameSourceController] {
    fn GetPropertyAsync(&self, propertyId: HSTRING, out: *mut <foundation::IAsyncOperation<MediaFrameSourceGetPropertyResult> as RtType>::Abi) -> HRESULT,
    fn SetPropertyAsync(&self, propertyId: HSTRING, propertyValue: <IInspectable as RtType>::Abi, out: *mut <foundation::IAsyncOperation<MediaFrameSourceSetPropertyStatus> as RtType>::Abi) -> HRESULT,
    fn get_VideoDeviceController(&self, out: *mut <super::super::devices::VideoDeviceController as RtType>::Abi) -> HRESULT
}}
impl IMediaFrameSourceController {
    #[inline] pub fn get_property_async(&self, propertyId: &HStringArg) -> Result<foundation::IAsyncOperation<MediaFrameSourceGetPropertyResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetPropertyAsync)(self.0.as_abi() as *const _ as *mut _, propertyId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_property_async(&self, propertyId: &HStringArg, propertyValue: &IInspectable) -> Result<foundation::IAsyncOperation<MediaFrameSourceSetPropertyStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetPropertyAsync)(self.0.as_abi() as *const _ as *mut _, propertyId.get(), get_abi(propertyValue) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_device_controller(&self) -> Result<Option<super::super::devices::VideoDeviceController>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoDeviceController)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::VideoDeviceController::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaFrameSourceController: IMediaFrameSourceController}
DEFINE_IID!(IID_IMediaFrameSourceController2, 4022640596, 64754, 18947, 180, 228, 172, 150, 40, 115, 155, 238);
RT_INTERFACE!{interface IMediaFrameSourceController2(IMediaFrameSourceController2Vtbl, IMediaFrameSourceController2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaFrameSourceController2] {
    fn GetPropertyByExtendedIdAsync(&self, extendedPropertyIdSize: u32, extendedPropertyId: *mut u8, maxPropertyValueSize: <foundation::IReference<u32> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<MediaFrameSourceGetPropertyResult> as RtType>::Abi) -> HRESULT,
    fn SetPropertyByExtendedIdAsync(&self, extendedPropertyIdSize: u32, extendedPropertyId: *mut u8, propertyValueSize: u32, propertyValue: *mut u8, out: *mut <foundation::IAsyncOperation<MediaFrameSourceSetPropertyStatus> as RtType>::Abi) -> HRESULT
}}
impl IMediaFrameSourceController2 {
    #[inline] pub fn get_property_by_extended_id_async(&self, extendedPropertyId: &[u8], maxPropertyValueSize: &foundation::IReference<u32>) -> Result<foundation::IAsyncOperation<MediaFrameSourceGetPropertyResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetPropertyByExtendedIdAsync)(self.0.as_abi() as *const _ as *mut _, extendedPropertyId.len() as u32, extendedPropertyId.as_ptr() as *mut _, get_abi(maxPropertyValueSize) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_property_by_extended_id_async(&self, extendedPropertyId: &[u8], propertyValue: &[u8]) -> Result<foundation::IAsyncOperation<MediaFrameSourceSetPropertyStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetPropertyByExtendedIdAsync)(self.0.as_abi() as *const _ as *mut _, extendedPropertyId.len() as u32, extendedPropertyId.as_ptr() as *mut _, propertyValue.len() as u32, propertyValue.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaFrameSourceController3, 520943637, 9316, 18001, 177, 232, 74, 130, 219, 219, 84, 222);
RT_INTERFACE!{interface IMediaFrameSourceController3(IMediaFrameSourceController3Vtbl, IMediaFrameSourceController3_Abi): IInspectable(IInspectableVtbl) [IID_IMediaFrameSourceController3] {
    fn get_AudioDeviceController(&self, out: *mut <super::super::devices::AudioDeviceController as RtType>::Abi) -> HRESULT
}}
impl IMediaFrameSourceController3 {
    #[inline] pub fn get_audio_device_controller(&self) -> Result<Option<super::super::devices::AudioDeviceController>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioDeviceController)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::AudioDeviceController::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaFrameSourceGetPropertyResult, 143005378, 14948, 19413, 189, 43, 231, 200, 152, 210, 243, 122);
RT_INTERFACE!{interface IMediaFrameSourceGetPropertyResult(IMediaFrameSourceGetPropertyResultVtbl, IMediaFrameSourceGetPropertyResult_Abi): IInspectable(IInspectableVtbl) [IID_IMediaFrameSourceGetPropertyResult] {
    fn get_Status(&self, out: *mut MediaFrameSourceGetPropertyStatus) -> HRESULT,
    fn get_Value(&self, out: *mut <IInspectable as RtType>::Abi) -> HRESULT
}}
impl IMediaFrameSourceGetPropertyResult {
    #[inline] pub fn get_status(&self) -> Result<MediaFrameSourceGetPropertyStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<Option<IInspectable>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Value)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IInspectable::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaFrameSourceGetPropertyResult: IMediaFrameSourceGetPropertyResult}
RT_ENUM! { enum MediaFrameSourceGetPropertyStatus: i32 {
    Success = 0, UnknownFailure = 1, NotSupported = 2, DeviceNotAvailable = 3, MaxPropertyValueSizeTooSmall = 4, MaxPropertyValueSizeRequired = 5,
}}
DEFINE_IID!(IID_IMediaFrameSourceGroup, 2137021319, 18482, 19295, 174, 61, 65, 47, 170, 179, 125, 52);
RT_INTERFACE!{interface IMediaFrameSourceGroup(IMediaFrameSourceGroupVtbl, IMediaFrameSourceGroup_Abi): IInspectable(IInspectableVtbl) [IID_IMediaFrameSourceGroup] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SourceInfos(&self, out: *mut <foundation::collections::IVectorView<MediaFrameSourceInfo> as RtType>::Abi) -> HRESULT
}}
impl IMediaFrameSourceGroup {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DisplayName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_source_infos(&self) -> Result<Option<foundation::collections::IVectorView<MediaFrameSourceInfo>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SourceInfos)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaFrameSourceGroup: IMediaFrameSourceGroup}
impl RtActivatable<IMediaFrameSourceGroupStatics> for MediaFrameSourceGroup {}
impl MediaFrameSourceGroup {
    #[inline] pub fn find_all_async() -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<MediaFrameSourceGroup>>> {
        <Self as RtActivatable<IMediaFrameSourceGroupStatics>>::get_activation_factory().find_all_async()
    }
    #[inline] pub fn from_id_async(id: &HStringArg) -> Result<foundation::IAsyncOperation<MediaFrameSourceGroup>> {
        <Self as RtActivatable<IMediaFrameSourceGroupStatics>>::get_activation_factory().from_id_async(id)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IMediaFrameSourceGroupStatics>>::get_activation_factory().get_device_selector()
    }
}
DEFINE_CLSID!(MediaFrameSourceGroup(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,97,112,116,117,114,101,46,70,114,97,109,101,115,46,77,101,100,105,97,70,114,97,109,101,83,111,117,114,99,101,71,114,111,117,112,0]) [CLSID_MediaFrameSourceGroup]);
DEFINE_IID!(IID_IMediaFrameSourceGroupStatics, 474529733, 17263, 17672, 148, 207, 213, 216, 183, 50, 100, 69);
RT_INTERFACE!{static interface IMediaFrameSourceGroupStatics(IMediaFrameSourceGroupStaticsVtbl, IMediaFrameSourceGroupStatics_Abi): IInspectable(IInspectableVtbl) [IID_IMediaFrameSourceGroupStatics] {
    fn FindAllAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<MediaFrameSourceGroup>> as RtType>::Abi) -> HRESULT,
    fn FromIdAsync(&self, id: HSTRING, out: *mut <foundation::IAsyncOperation<MediaFrameSourceGroup> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMediaFrameSourceGroupStatics {
    #[inline] pub fn find_all_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<MediaFrameSourceGroup>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindAllAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, id: &HStringArg) -> Result<foundation::IAsyncOperation<MediaFrameSourceGroup>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaFrameSourceInfo, 2277362125, 17921, 16527, 145, 207, 3, 131, 24, 205, 10, 243);
RT_INTERFACE!{interface IMediaFrameSourceInfo(IMediaFrameSourceInfoVtbl, IMediaFrameSourceInfo_Abi): IInspectable(IInspectableVtbl) [IID_IMediaFrameSourceInfo] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MediaStreamType(&self, out: *mut super::MediaStreamType) -> HRESULT,
    fn get_SourceKind(&self, out: *mut MediaFrameSourceKind) -> HRESULT,
    fn get_SourceGroup(&self, out: *mut <MediaFrameSourceGroup as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_DeviceInformation(&self, out: *mut <crate::windows::devices::enumeration::DeviceInformation as RtType>::Abi) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<Guid, IInspectable> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-perception")] fn get_CoordinateSystem(&self, out: *mut <crate::windows::perception::spatial::SpatialCoordinateSystem as RtType>::Abi) -> HRESULT
}}
impl IMediaFrameSourceInfo {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_media_stream_type(&self) -> Result<super::MediaStreamType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaStreamType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_source_kind(&self) -> Result<MediaFrameSourceKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SourceKind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_source_group(&self) -> Result<Option<MediaFrameSourceGroup>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SourceGroup)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaFrameSourceGroup::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_device_information(&self) -> Result<Option<crate::windows::devices::enumeration::DeviceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceInformation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::devices::enumeration::DeviceInformation::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<Guid, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-perception")] #[inline] pub fn get_coordinate_system(&self) -> Result<Option<crate::windows::perception::spatial::SpatialCoordinateSystem>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CoordinateSystem)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::perception::spatial::SpatialCoordinateSystem::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaFrameSourceInfo: IMediaFrameSourceInfo}
DEFINE_IID!(IID_IMediaFrameSourceInfo2, 425359445, 25687, 17094, 167, 105, 25, 182, 91, 211, 46, 110);
RT_INTERFACE!{interface IMediaFrameSourceInfo2(IMediaFrameSourceInfo2Vtbl, IMediaFrameSourceInfo2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaFrameSourceInfo2] {
    fn get_ProfileId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoProfileMediaDescription(&self, out: *mut <foundation::collections::IVectorView<super::MediaCaptureVideoProfileMediaDescription> as RtType>::Abi) -> HRESULT
}}
impl IMediaFrameSourceInfo2 {
    #[inline] pub fn get_profile_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProfileId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_profile_media_description(&self) -> Result<Option<foundation::collections::IVectorView<super::MediaCaptureVideoProfileMediaDescription>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoProfileMediaDescription)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum MediaFrameSourceKind: i32 {
    Custom = 0, Color = 1, Infrared = 2, Depth = 3, Audio = 4, Image = 5,
}}
RT_ENUM! { enum MediaFrameSourceSetPropertyStatus: i32 {
    Success = 0, UnknownFailure = 1, NotSupported = 2, InvalidValue = 3, DeviceNotAvailable = 4, NotInControl = 5,
}}
DEFINE_IID!(IID_IMultiSourceMediaFrameArrivedEventArgs, 1662082561, 53073, 18685, 170, 176, 109, 105, 62, 180, 129, 39);
RT_INTERFACE!{interface IMultiSourceMediaFrameArrivedEventArgs(IMultiSourceMediaFrameArrivedEventArgsVtbl, IMultiSourceMediaFrameArrivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMultiSourceMediaFrameArrivedEventArgs] {
    
}}
RT_CLASS!{class MultiSourceMediaFrameArrivedEventArgs: IMultiSourceMediaFrameArrivedEventArgs}
DEFINE_IID!(IID_IMultiSourceMediaFrameReader, 2366915586, 63331, 18573, 152, 242, 180, 55, 188, 240, 117, 231);
RT_INTERFACE!{interface IMultiSourceMediaFrameReader(IMultiSourceMediaFrameReaderVtbl, IMultiSourceMediaFrameReader_Abi): IInspectable(IInspectableVtbl) [IID_IMultiSourceMediaFrameReader] {
    fn add_FrameArrived(&self, handler: <foundation::TypedEventHandler<MultiSourceMediaFrameReader, MultiSourceMediaFrameArrivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FrameArrived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn TryAcquireLatestFrame(&self, out: *mut <MultiSourceMediaFrameReference as RtType>::Abi) -> HRESULT,
    fn StartAsync(&self, out: *mut <foundation::IAsyncOperation<MultiSourceMediaFrameReaderStartStatus> as RtType>::Abi) -> HRESULT,
    fn StopAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IMultiSourceMediaFrameReader {
    #[inline] pub fn add_frame_arrived(&self, handler: &foundation::TypedEventHandler<MultiSourceMediaFrameReader, MultiSourceMediaFrameArrivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_FrameArrived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_frame_arrived(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_FrameArrived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_acquire_latest_frame(&self) -> Result<Option<MultiSourceMediaFrameReference>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryAcquireLatestFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MultiSourceMediaFrameReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn start_async(&self) -> Result<foundation::IAsyncOperation<MultiSourceMediaFrameReaderStartStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StartAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn stop_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StopAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MultiSourceMediaFrameReader: IMultiSourceMediaFrameReader}
DEFINE_IID!(IID_IMultiSourceMediaFrameReader2, 4015819453, 64604, 19563, 157, 129, 60, 185, 204, 99, 124, 38);
RT_INTERFACE!{interface IMultiSourceMediaFrameReader2(IMultiSourceMediaFrameReader2Vtbl, IMultiSourceMediaFrameReader2_Abi): IInspectable(IInspectableVtbl) [IID_IMultiSourceMediaFrameReader2] {
    fn put_AcquisitionMode(&self, value: MediaFrameReaderAcquisitionMode) -> HRESULT,
    fn get_AcquisitionMode(&self, out: *mut MediaFrameReaderAcquisitionMode) -> HRESULT
}}
impl IMultiSourceMediaFrameReader2 {
    #[inline] pub fn set_acquisition_mode(&self, value: MediaFrameReaderAcquisitionMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AcquisitionMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_acquisition_mode(&self) -> Result<MediaFrameReaderAcquisitionMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AcquisitionMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum MultiSourceMediaFrameReaderStartStatus: i32 {
    Success = 0, NotSupported = 1, InsufficientResources = 2, DeviceNotAvailable = 3, UnknownFailure = 4,
}}
DEFINE_IID!(IID_IMultiSourceMediaFrameReference, 563497754, 32738, 17622, 146, 229, 41, 142, 109, 40, 16, 233);
RT_INTERFACE!{interface IMultiSourceMediaFrameReference(IMultiSourceMediaFrameReferenceVtbl, IMultiSourceMediaFrameReference_Abi): IInspectable(IInspectableVtbl) [IID_IMultiSourceMediaFrameReference] {
    fn TryGetFrameReferenceBySourceId(&self, sourceId: HSTRING, out: *mut <MediaFrameReference as RtType>::Abi) -> HRESULT
}}
impl IMultiSourceMediaFrameReference {
    #[inline] pub fn try_get_frame_reference_by_source_id(&self, sourceId: &HStringArg) -> Result<Option<MediaFrameReference>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryGetFrameReferenceBySourceId)(self.0.as_abi() as *const _ as *mut _, sourceId.get(), &mut out);
        if hr == S_OK { Ok(MediaFrameReference::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MultiSourceMediaFrameReference: IMultiSourceMediaFrameReference}
DEFINE_IID!(IID_IVideoMediaFrame, 14503115, 12989, 20449, 160, 19, 124, 193, 60, 245, 219, 207);
RT_INTERFACE!{interface IVideoMediaFrame(IVideoMediaFrameVtbl, IVideoMediaFrame_Abi): IInspectable(IInspectableVtbl) [IID_IVideoMediaFrame] {
    fn get_FrameReference(&self, out: *mut <MediaFrameReference as RtType>::Abi) -> HRESULT,
    fn get_VideoFormat(&self, out: *mut <VideoMediaFrameFormat as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_SoftwareBitmap(&self, out: *mut <crate::windows::graphics::imaging::SoftwareBitmap as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_Direct3DSurface(&self, out: *mut <crate::windows::graphics::directx::direct3d11::IDirect3DSurface as RtType>::Abi) -> HRESULT,
    fn get_CameraIntrinsics(&self, out: *mut <super::super::devices::core::CameraIntrinsics as RtType>::Abi) -> HRESULT,
    fn get_InfraredMediaFrame(&self, out: *mut <InfraredMediaFrame as RtType>::Abi) -> HRESULT,
    fn get_DepthMediaFrame(&self, out: *mut <DepthMediaFrame as RtType>::Abi) -> HRESULT,
    fn GetVideoFrame(&self, out: *mut <super::super::VideoFrame as RtType>::Abi) -> HRESULT
}}
impl IVideoMediaFrame {
    #[inline] pub fn get_frame_reference(&self) -> Result<Option<MediaFrameReference>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameReference)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaFrameReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format(&self) -> Result<Option<VideoMediaFrameFormat>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoMediaFrameFormat::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_software_bitmap(&self) -> Result<Option<crate::windows::graphics::imaging::SoftwareBitmap>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SoftwareBitmap)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::graphics::imaging::SoftwareBitmap::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_direct3d_surface(&self) -> Result<Option<crate::windows::graphics::directx::direct3d11::IDirect3DSurface>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Direct3DSurface)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::graphics::directx::direct3d11::IDirect3DSurface::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_camera_intrinsics(&self) -> Result<Option<super::super::devices::core::CameraIntrinsics>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CameraIntrinsics)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::core::CameraIntrinsics::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_infrared_media_frame(&self) -> Result<Option<InfraredMediaFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_InfraredMediaFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(InfraredMediaFrame::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_depth_media_frame(&self) -> Result<Option<DepthMediaFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DepthMediaFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DepthMediaFrame::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_frame(&self) -> Result<Option<super::super::VideoFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetVideoFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::VideoFrame::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VideoMediaFrame: IVideoMediaFrame}
DEFINE_IID!(IID_IVideoMediaFrameFormat, 1174568896, 55067, 17863, 143, 20, 109, 154, 10, 230, 4, 228);
RT_INTERFACE!{interface IVideoMediaFrameFormat(IVideoMediaFrameFormatVtbl, IVideoMediaFrameFormat_Abi): IInspectable(IInspectableVtbl) [IID_IVideoMediaFrameFormat] {
    fn get_MediaFrameFormat(&self, out: *mut <MediaFrameFormat as RtType>::Abi) -> HRESULT,
    fn get_DepthFormat(&self, out: *mut <DepthMediaFrameFormat as RtType>::Abi) -> HRESULT,
    fn get_Width(&self, out: *mut u32) -> HRESULT,
    fn get_Height(&self, out: *mut u32) -> HRESULT
}}
impl IVideoMediaFrameFormat {
    #[inline] pub fn get_media_frame_format(&self) -> Result<Option<MediaFrameFormat>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaFrameFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaFrameFormat::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_depth_format(&self) -> Result<Option<DepthMediaFrameFormat>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DepthFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DepthMediaFrameFormat::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_width(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Width)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_height(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Height)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class VideoMediaFrameFormat: IVideoMediaFrameFormat}
} // Windows.Media.Capture.Frames
} // Windows.Media.Capture
pub mod casting { // Windows.Media.Casting
use crate::prelude::*;
DEFINE_IID!(IID_ICastingConnection, 3449099859, 49905, 17560, 139, 120, 95, 180, 205, 54, 64, 221);
RT_INTERFACE!{interface ICastingConnection(ICastingConnectionVtbl, ICastingConnection_Abi): IInspectable(IInspectableVtbl) [IID_ICastingConnection] {
    fn get_State(&self, out: *mut CastingConnectionState) -> HRESULT,
    fn get_Device(&self, out: *mut <CastingDevice as RtType>::Abi) -> HRESULT,
    fn get_Source(&self, out: *mut <CastingSource as RtType>::Abi) -> HRESULT,
    fn put_Source(&self, value: <CastingSource as RtType>::Abi) -> HRESULT,
    fn add_StateChanged(&self, handler: <foundation::TypedEventHandler<CastingConnection, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ErrorOccurred(&self, handler: <foundation::TypedEventHandler<CastingConnection, CastingConnectionErrorOccurredEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ErrorOccurred(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn RequestStartCastingAsync(&self, value: <CastingSource as RtType>::Abi, out: *mut <foundation::IAsyncOperation<CastingConnectionErrorStatus> as RtType>::Abi) -> HRESULT,
    fn DisconnectAsync(&self, out: *mut <foundation::IAsyncOperation<CastingConnectionErrorStatus> as RtType>::Abi) -> HRESULT
}}
impl ICastingConnection {
    #[inline] pub fn get_state(&self) -> Result<CastingConnectionState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_device(&self) -> Result<Option<CastingDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Device)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CastingDevice::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_source(&self) -> Result<Option<CastingSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Source)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CastingSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_source(&self, value: &CastingSource) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Source)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_state_changed(&self, handler: &foundation::TypedEventHandler<CastingConnection, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_error_occurred(&self, handler: &foundation::TypedEventHandler<CastingConnection, CastingConnectionErrorOccurredEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ErrorOccurred)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_error_occurred(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ErrorOccurred)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn request_start_casting_async(&self, value: &CastingSource) -> Result<foundation::IAsyncOperation<CastingConnectionErrorStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestStartCastingAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn disconnect_async(&self) -> Result<foundation::IAsyncOperation<CastingConnectionErrorStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).DisconnectAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CastingConnection: ICastingConnection}
DEFINE_IID!(IID_ICastingConnectionErrorOccurredEventArgs, 2818260073, 34585, 20224, 129, 251, 150, 24, 99, 199, 154, 50);
RT_INTERFACE!{interface ICastingConnectionErrorOccurredEventArgs(ICastingConnectionErrorOccurredEventArgsVtbl, ICastingConnectionErrorOccurredEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ICastingConnectionErrorOccurredEventArgs] {
    fn get_ErrorStatus(&self, out: *mut CastingConnectionErrorStatus) -> HRESULT,
    fn get_Message(&self, out: *mut HSTRING) -> HRESULT
}}
impl ICastingConnectionErrorOccurredEventArgs {
    #[inline] pub fn get_error_status(&self) -> Result<CastingConnectionErrorStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ErrorStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_message(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Message)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CastingConnectionErrorOccurredEventArgs: ICastingConnectionErrorOccurredEventArgs}
RT_ENUM! { enum CastingConnectionErrorStatus: i32 {
    Succeeded = 0, DeviceDidNotRespond = 1, DeviceError = 2, DeviceLocked = 3, ProtectedPlaybackFailed = 4, InvalidCastingSource = 5, Unknown = 6,
}}
RT_ENUM! { enum CastingConnectionState: i32 {
    Disconnected = 0, Connected = 1, Rendering = 2, Disconnecting = 3, Connecting = 4,
}}
DEFINE_IID!(IID_ICastingDevice, 3732020355, 19011, 19153, 166, 210, 36, 146, 167, 150, 195, 242);
RT_INTERFACE!{interface ICastingDevice(ICastingDeviceVtbl, ICastingDevice_Abi): IInspectable(IInspectableVtbl) [IID_ICastingDevice] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FriendlyName(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Icon(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamWithContentType as RtType>::Abi) -> HRESULT,
    fn GetSupportedCastingPlaybackTypesAsync(&self, out: *mut <foundation::IAsyncOperation<CastingPlaybackTypes> as RtType>::Abi) -> HRESULT,
    fn CreateCastingConnection(&self, out: *mut <CastingConnection as RtType>::Abi) -> HRESULT
}}
impl ICastingDevice {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_friendly_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FriendlyName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_icon(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamWithContentType>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Icon)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamWithContentType::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_casting_playback_types_async(&self) -> Result<foundation::IAsyncOperation<CastingPlaybackTypes>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetSupportedCastingPlaybackTypesAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_casting_connection(&self) -> Result<Option<CastingConnection>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateCastingConnection)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CastingConnection::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CastingDevice: ICastingDevice}
impl RtActivatable<ICastingDeviceStatics> for CastingDevice {}
impl CastingDevice {
    #[inline] pub fn get_device_selector(type_: CastingPlaybackTypes) -> Result<HString> {
        <Self as RtActivatable<ICastingDeviceStatics>>::get_activation_factory().get_device_selector(type_)
    }
    #[inline] pub fn get_device_selector_from_casting_source_async(castingSource: &CastingSource) -> Result<foundation::IAsyncOperation<HString>> {
        <Self as RtActivatable<ICastingDeviceStatics>>::get_activation_factory().get_device_selector_from_casting_source_async(castingSource)
    }
    #[inline] pub fn from_id_async(value: &HStringArg) -> Result<foundation::IAsyncOperation<CastingDevice>> {
        <Self as RtActivatable<ICastingDeviceStatics>>::get_activation_factory().from_id_async(value)
    }
    #[cfg(feature="windows-devices")] #[inline] pub fn device_info_supports_casting_async(device: &super::super::devices::enumeration::DeviceInformation) -> Result<foundation::IAsyncOperation<bool>> {
        <Self as RtActivatable<ICastingDeviceStatics>>::get_activation_factory().device_info_supports_casting_async(device)
    }
}
DEFINE_CLSID!(CastingDevice(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,97,115,116,105,110,103,46,67,97,115,116,105,110,103,68,101,118,105,99,101,0]) [CLSID_CastingDevice]);
DEFINE_IID!(IID_ICastingDevicePicker, 3704854820, 1425, 18878, 170, 203, 75, 130, 238, 117, 106, 149);
RT_INTERFACE!{interface ICastingDevicePicker(ICastingDevicePickerVtbl, ICastingDevicePicker_Abi): IInspectable(IInspectableVtbl) [IID_ICastingDevicePicker] {
    fn get_Filter(&self, out: *mut <CastingDevicePickerFilter as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_Appearance(&self, out: *mut <super::super::devices::enumeration::DevicePickerAppearance as RtType>::Abi) -> HRESULT,
    fn add_CastingDeviceSelected(&self, handler: <foundation::TypedEventHandler<CastingDevicePicker, CastingDeviceSelectedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CastingDeviceSelected(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CastingDevicePickerDismissed(&self, handler: <foundation::TypedEventHandler<CastingDevicePicker, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CastingDevicePickerDismissed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn Show(&self, selection: foundation::Rect) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowWithPlacement(&self, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> HRESULT,
    fn Hide(&self) -> HRESULT
}}
impl ICastingDevicePicker {
    #[inline] pub fn get_filter(&self) -> Result<Option<CastingDevicePickerFilter>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Filter)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CastingDevicePickerFilter::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_appearance(&self) -> Result<Option<super::super::devices::enumeration::DevicePickerAppearance>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Appearance)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::enumeration::DevicePickerAppearance::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_casting_device_selected(&self, handler: &foundation::TypedEventHandler<CastingDevicePicker, CastingDeviceSelectedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_CastingDeviceSelected)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_casting_device_selected(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_CastingDeviceSelected)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_casting_device_picker_dismissed(&self, handler: &foundation::TypedEventHandler<CastingDevicePicker, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_CastingDevicePickerDismissed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_casting_device_picker_dismissed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_CastingDevicePickerDismissed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn show(&self, selection: foundation::Rect) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Show)(self.0.as_abi() as *const _ as *mut _, selection);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_with_placement(&self, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ShowWithPlacement)(self.0.as_abi() as *const _ as *mut _, selection, preferredPlacement);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn hide(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Hide)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CastingDevicePicker: ICastingDevicePicker}
impl RtActivatable<IActivationFactory> for CastingDevicePicker {}
DEFINE_CLSID!(CastingDevicePicker(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,97,115,116,105,110,103,46,67,97,115,116,105,110,103,68,101,118,105,99,101,80,105,99,107,101,114,0]) [CLSID_CastingDevicePicker]);
DEFINE_IID!(IID_ICastingDevicePickerFilter, 3196871068, 46435, 17236, 174, 51, 159, 218, 173, 140, 98, 145);
RT_INTERFACE!{interface ICastingDevicePickerFilter(ICastingDevicePickerFilterVtbl, ICastingDevicePickerFilter_Abi): IInspectable(IInspectableVtbl) [IID_ICastingDevicePickerFilter] {
    fn get_SupportsAudio(&self, out: *mut bool) -> HRESULT,
    fn put_SupportsAudio(&self, value: bool) -> HRESULT,
    fn get_SupportsVideo(&self, out: *mut bool) -> HRESULT,
    fn put_SupportsVideo(&self, value: bool) -> HRESULT,
    fn get_SupportsPictures(&self, out: *mut bool) -> HRESULT,
    fn put_SupportsPictures(&self, value: bool) -> HRESULT,
    fn get_SupportedCastingSources(&self, out: *mut <foundation::collections::IVector<CastingSource> as RtType>::Abi) -> HRESULT
}}
impl ICastingDevicePickerFilter {
    #[inline] pub fn get_supports_audio(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportsAudio)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_supports_audio(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SupportsAudio)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_supports_video(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportsVideo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_supports_video(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SupportsVideo)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_supports_pictures(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportsPictures)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_supports_pictures(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SupportsPictures)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_casting_sources(&self) -> Result<Option<foundation::collections::IVector<CastingSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedCastingSources)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CastingDevicePickerFilter: ICastingDevicePickerFilter}
DEFINE_IID!(IID_ICastingDeviceSelectedEventArgs, 3695419014, 56663, 19725, 148, 0, 175, 69, 228, 251, 54, 99);
RT_INTERFACE!{interface ICastingDeviceSelectedEventArgs(ICastingDeviceSelectedEventArgsVtbl, ICastingDeviceSelectedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ICastingDeviceSelectedEventArgs] {
    fn get_SelectedCastingDevice(&self, out: *mut <CastingDevice as RtType>::Abi) -> HRESULT
}}
impl ICastingDeviceSelectedEventArgs {
    #[inline] pub fn get_selected_casting_device(&self) -> Result<Option<CastingDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SelectedCastingDevice)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CastingDevice::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CastingDeviceSelectedEventArgs: ICastingDeviceSelectedEventArgs}
DEFINE_IID!(IID_ICastingDeviceStatics, 3889780951, 19731, 16951, 163, 101, 76, 79, 106, 76, 253, 47);
RT_INTERFACE!{static interface ICastingDeviceStatics(ICastingDeviceStaticsVtbl, ICastingDeviceStatics_Abi): IInspectable(IInspectableVtbl) [IID_ICastingDeviceStatics] {
    fn GetDeviceSelector(&self, type_: CastingPlaybackTypes, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromCastingSourceAsync(&self, castingSource: <CastingSource as RtType>::Abi, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn FromIdAsync(&self, value: HSTRING, out: *mut <foundation::IAsyncOperation<CastingDevice> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-devices")] fn DeviceInfoSupportsCastingAsync(&self, device: <super::super::devices::enumeration::DeviceInformation as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl ICastingDeviceStatics {
    #[inline] pub fn get_device_selector(&self, type_: CastingPlaybackTypes) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, type_, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_casting_source_async(&self, castingSource: &CastingSource) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorFromCastingSourceAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(castingSource) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, value: &HStringArg) -> Result<foundation::IAsyncOperation<CastingDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, value.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn device_info_supports_casting_async(&self, device: &super::super::devices::enumeration::DeviceInformation) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).DeviceInfoSupportsCastingAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(device) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum CastingPlaybackTypes: u32 {
    None = 0, Audio = 1, Video = 2, Picture = 4,
}}
DEFINE_IID!(IID_ICastingSource, 4096387698, 13415, 18406, 160, 39, 82, 41, 35, 233, 215, 39);
RT_INTERFACE!{interface ICastingSource(ICastingSourceVtbl, ICastingSource_Abi): IInspectable(IInspectableVtbl) [IID_ICastingSource] {
    fn get_PreferredSourceUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_PreferredSourceUri(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT
}}
impl ICastingSource {
    #[inline] pub fn get_preferred_source_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PreferredSourceUri)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_preferred_source_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PreferredSourceUri)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CastingSource: ICastingSource}
} // Windows.Media.Casting
pub mod closedcaptioning { // Windows.Media.ClosedCaptioning
use crate::prelude::*;
RT_ENUM! { enum ClosedCaptionColor: i32 {
    Default = 0, White = 1, Black = 2, Red = 3, Green = 4, Blue = 5, Yellow = 6, Magenta = 7, Cyan = 8,
}}
RT_ENUM! { enum ClosedCaptionEdgeEffect: i32 {
    Default = 0, None = 1, Raised = 2, Depressed = 3, Uniform = 4, DropShadow = 5,
}}
RT_ENUM! { enum ClosedCaptionOpacity: i32 {
    Default = 0, OneHundredPercent = 1, SeventyFivePercent = 2, TwentyFivePercent = 3, ZeroPercent = 4,
}}
RT_CLASS!{static class ClosedCaptionProperties}
impl RtActivatable<IClosedCaptionPropertiesStatics> for ClosedCaptionProperties {}
impl ClosedCaptionProperties {
    #[inline] pub fn get_font_color() -> Result<ClosedCaptionColor> {
        <Self as RtActivatable<IClosedCaptionPropertiesStatics>>::get_activation_factory().get_font_color()
    }
    #[cfg(feature="windows-ui")] #[inline] pub fn get_computed_font_color() -> Result<super::super::ui::Color> {
        <Self as RtActivatable<IClosedCaptionPropertiesStatics>>::get_activation_factory().get_computed_font_color()
    }
    #[inline] pub fn get_font_opacity() -> Result<ClosedCaptionOpacity> {
        <Self as RtActivatable<IClosedCaptionPropertiesStatics>>::get_activation_factory().get_font_opacity()
    }
    #[inline] pub fn get_font_size() -> Result<ClosedCaptionSize> {
        <Self as RtActivatable<IClosedCaptionPropertiesStatics>>::get_activation_factory().get_font_size()
    }
    #[inline] pub fn get_font_style() -> Result<ClosedCaptionStyle> {
        <Self as RtActivatable<IClosedCaptionPropertiesStatics>>::get_activation_factory().get_font_style()
    }
    #[inline] pub fn get_font_effect() -> Result<ClosedCaptionEdgeEffect> {
        <Self as RtActivatable<IClosedCaptionPropertiesStatics>>::get_activation_factory().get_font_effect()
    }
    #[inline] pub fn get_background_color() -> Result<ClosedCaptionColor> {
        <Self as RtActivatable<IClosedCaptionPropertiesStatics>>::get_activation_factory().get_background_color()
    }
    #[cfg(feature="windows-ui")] #[inline] pub fn get_computed_background_color() -> Result<super::super::ui::Color> {
        <Self as RtActivatable<IClosedCaptionPropertiesStatics>>::get_activation_factory().get_computed_background_color()
    }
    #[inline] pub fn get_background_opacity() -> Result<ClosedCaptionOpacity> {
        <Self as RtActivatable<IClosedCaptionPropertiesStatics>>::get_activation_factory().get_background_opacity()
    }
    #[inline] pub fn get_region_color() -> Result<ClosedCaptionColor> {
        <Self as RtActivatable<IClosedCaptionPropertiesStatics>>::get_activation_factory().get_region_color()
    }
    #[cfg(feature="windows-ui")] #[inline] pub fn get_computed_region_color() -> Result<super::super::ui::Color> {
        <Self as RtActivatable<IClosedCaptionPropertiesStatics>>::get_activation_factory().get_computed_region_color()
    }
    #[inline] pub fn get_region_opacity() -> Result<ClosedCaptionOpacity> {
        <Self as RtActivatable<IClosedCaptionPropertiesStatics>>::get_activation_factory().get_region_opacity()
    }
}
DEFINE_CLSID!(ClosedCaptionProperties(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,108,111,115,101,100,67,97,112,116,105,111,110,105,110,103,46,67,108,111,115,101,100,67,97,112,116,105,111,110,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_ClosedCaptionProperties]);
DEFINE_IID!(IID_IClosedCaptionPropertiesStatics, 279584644, 52272, 16705, 181, 3, 82, 114, 40, 158, 12, 32);
RT_INTERFACE!{static interface IClosedCaptionPropertiesStatics(IClosedCaptionPropertiesStaticsVtbl, IClosedCaptionPropertiesStatics_Abi): IInspectable(IInspectableVtbl) [IID_IClosedCaptionPropertiesStatics] {
    fn get_FontColor(&self, out: *mut ClosedCaptionColor) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_ComputedFontColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    fn get_FontOpacity(&self, out: *mut ClosedCaptionOpacity) -> HRESULT,
    fn get_FontSize(&self, out: *mut ClosedCaptionSize) -> HRESULT,
    fn get_FontStyle(&self, out: *mut ClosedCaptionStyle) -> HRESULT,
    fn get_FontEffect(&self, out: *mut ClosedCaptionEdgeEffect) -> HRESULT,
    fn get_BackgroundColor(&self, out: *mut ClosedCaptionColor) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_ComputedBackgroundColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    fn get_BackgroundOpacity(&self, out: *mut ClosedCaptionOpacity) -> HRESULT,
    fn get_RegionColor(&self, out: *mut ClosedCaptionColor) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy10(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_ComputedRegionColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    fn get_RegionOpacity(&self, out: *mut ClosedCaptionOpacity) -> HRESULT
}}
impl IClosedCaptionPropertiesStatics {
    #[inline] pub fn get_font_color(&self) -> Result<ClosedCaptionColor> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FontColor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_computed_font_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ComputedFontColor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_font_opacity(&self) -> Result<ClosedCaptionOpacity> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FontOpacity)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_font_size(&self) -> Result<ClosedCaptionSize> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FontSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_font_style(&self) -> Result<ClosedCaptionStyle> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FontStyle)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_font_effect(&self) -> Result<ClosedCaptionEdgeEffect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FontEffect)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_background_color(&self) -> Result<ClosedCaptionColor> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BackgroundColor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_computed_background_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ComputedBackgroundColor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_background_opacity(&self) -> Result<ClosedCaptionOpacity> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BackgroundOpacity)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_region_color(&self) -> Result<ClosedCaptionColor> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RegionColor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_computed_region_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ComputedRegionColor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_region_opacity(&self) -> Result<ClosedCaptionOpacity> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RegionOpacity)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum ClosedCaptionSize: i32 {
    Default = 0, FiftyPercent = 1, OneHundredPercent = 2, OneHundredFiftyPercent = 3, TwoHundredPercent = 4,
}}
RT_ENUM! { enum ClosedCaptionStyle: i32 {
    Default = 0, MonospacedWithSerifs = 1, ProportionalWithSerifs = 2, MonospacedWithoutSerifs = 3, ProportionalWithoutSerifs = 4, Casual = 5, Cursive = 6, SmallCapitals = 7,
}}
} // Windows.Media.ClosedCaptioning
pub mod contentrestrictions { // Windows.Media.ContentRestrictions
use crate::prelude::*;
RT_ENUM! { enum ContentAccessRestrictionLevel: i32 {
    Allow = 0, Warn = 1, Block = 2, Hide = 3,
}}
DEFINE_IID!(IID_IContentRestrictionsBrowsePolicy, 2348888996, 17454, 17946, 135, 87, 250, 210, 245, 189, 55, 228);
RT_INTERFACE!{interface IContentRestrictionsBrowsePolicy(IContentRestrictionsBrowsePolicyVtbl, IContentRestrictionsBrowsePolicy_Abi): IInspectable(IInspectableVtbl) [IID_IContentRestrictionsBrowsePolicy] {
    fn get_GeographicRegion(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MaxBrowsableAgeRating(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_PreferredAgeRating(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT
}}
impl IContentRestrictionsBrowsePolicy {
    #[inline] pub fn get_geographic_region(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_GeographicRegion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_max_browsable_age_rating(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxBrowsableAgeRating)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_preferred_age_rating(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PreferredAgeRating)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContentRestrictionsBrowsePolicy: IContentRestrictionsBrowsePolicy}
RT_ENUM! { enum RatedContentCategory: i32 {
    General = 0, Application = 1, Game = 2, Movie = 3, Television = 4, Music = 5,
}}
DEFINE_IID!(IID_IRatedContentDescription, 1766352607, 26290, 19907, 150, 177, 240, 144, 238, 222, 226, 85);
RT_INTERFACE!{interface IRatedContentDescription(IRatedContentDescriptionVtbl, IRatedContentDescription_Abi): IInspectable(IInspectableVtbl) [IID_IRatedContentDescription] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Id(&self, value: HSTRING) -> HRESULT,
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Image(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Image(&self, value: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    fn get_Category(&self, out: *mut RatedContentCategory) -> HRESULT,
    fn put_Category(&self, value: RatedContentCategory) -> HRESULT,
    fn get_Ratings(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT,
    fn put_Ratings(&self, value: <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT
}}
impl IRatedContentDescription {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Id)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Title)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_title(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Title)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_image(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Image)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_image(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Image)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_category(&self) -> Result<RatedContentCategory> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Category)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_category(&self, value: RatedContentCategory) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Category)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_ratings(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Ratings)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_ratings(&self, value: &foundation::collections::IVector<HString>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Ratings)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class RatedContentDescription: IRatedContentDescription}
impl RtActivatable<IRatedContentDescriptionFactory> for RatedContentDescription {}
impl RatedContentDescription {
    #[inline] pub fn create(id: &HStringArg, title: &HStringArg, category: RatedContentCategory) -> Result<RatedContentDescription> {
        <Self as RtActivatable<IRatedContentDescriptionFactory>>::get_activation_factory().create(id, title, category)
    }
}
DEFINE_CLSID!(RatedContentDescription(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,110,116,101,110,116,82,101,115,116,114,105,99,116,105,111,110,115,46,82,97,116,101,100,67,111,110,116,101,110,116,68,101,115,99,114,105,112,116,105,111,110,0]) [CLSID_RatedContentDescription]);
DEFINE_IID!(IID_IRatedContentDescriptionFactory, 775479138, 39824, 20390, 137, 193, 75, 141, 47, 251, 53, 115);
RT_INTERFACE!{static interface IRatedContentDescriptionFactory(IRatedContentDescriptionFactoryVtbl, IRatedContentDescriptionFactory_Abi): IInspectable(IInspectableVtbl) [IID_IRatedContentDescriptionFactory] {
    fn Create(&self, id: HSTRING, title: HSTRING, category: RatedContentCategory, out: *mut <RatedContentDescription as RtType>::Abi) -> HRESULT
}}
impl IRatedContentDescriptionFactory {
    #[inline] pub fn create(&self, id: &HStringArg, title: &HStringArg, category: RatedContentCategory) -> Result<RatedContentDescription> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, id.get(), title.get(), category, &mut out);
        if hr == S_OK { Ok(RatedContentDescription::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRatedContentRestrictions, 1065296843, 47623, 17409, 164, 157, 139, 146, 34, 32, 87, 35);
RT_INTERFACE!{interface IRatedContentRestrictions(IRatedContentRestrictionsVtbl, IRatedContentRestrictions_Abi): IInspectable(IInspectableVtbl) [IID_IRatedContentRestrictions] {
    fn GetBrowsePolicyAsync(&self, out: *mut <foundation::IAsyncOperation<ContentRestrictionsBrowsePolicy> as RtType>::Abi) -> HRESULT,
    fn GetRestrictionLevelAsync(&self, ratedContentDescription: <RatedContentDescription as RtType>::Abi, out: *mut <foundation::IAsyncOperation<ContentAccessRestrictionLevel> as RtType>::Abi) -> HRESULT,
    fn RequestContentAccessAsync(&self, ratedContentDescription: <RatedContentDescription as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn add_RestrictionsChanged(&self, handler: <foundation::EventHandler<IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RestrictionsChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IRatedContentRestrictions {
    #[inline] pub fn get_browse_policy_async(&self) -> Result<foundation::IAsyncOperation<ContentRestrictionsBrowsePolicy>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetBrowsePolicyAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_restriction_level_async(&self, ratedContentDescription: &RatedContentDescription) -> Result<foundation::IAsyncOperation<ContentAccessRestrictionLevel>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetRestrictionLevelAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(ratedContentDescription) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_content_access_async(&self, ratedContentDescription: &RatedContentDescription) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestContentAccessAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(ratedContentDescription) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_restrictions_changed(&self, handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_RestrictionsChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_restrictions_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_RestrictionsChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class RatedContentRestrictions: IRatedContentRestrictions}
impl RtActivatable<IRatedContentRestrictionsFactory> for RatedContentRestrictions {}
impl RtActivatable<IActivationFactory> for RatedContentRestrictions {}
impl RatedContentRestrictions {
    #[inline] pub fn create_with_max_age_rating(maxAgeRating: u32) -> Result<RatedContentRestrictions> {
        <Self as RtActivatable<IRatedContentRestrictionsFactory>>::get_activation_factory().create_with_max_age_rating(maxAgeRating)
    }
}
DEFINE_CLSID!(RatedContentRestrictions(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,110,116,101,110,116,82,101,115,116,114,105,99,116,105,111,110,115,46,82,97,116,101,100,67,111,110,116,101,110,116,82,101,115,116,114,105,99,116,105,111,110,115,0]) [CLSID_RatedContentRestrictions]);
DEFINE_IID!(IID_IRatedContentRestrictionsFactory, 4216007062, 50109, 18704, 150, 25, 151, 207, 208, 105, 77, 86);
RT_INTERFACE!{static interface IRatedContentRestrictionsFactory(IRatedContentRestrictionsFactoryVtbl, IRatedContentRestrictionsFactory_Abi): IInspectable(IInspectableVtbl) [IID_IRatedContentRestrictionsFactory] {
    fn CreateWithMaxAgeRating(&self, maxAgeRating: u32, out: *mut <RatedContentRestrictions as RtType>::Abi) -> HRESULT
}}
impl IRatedContentRestrictionsFactory {
    #[inline] pub fn create_with_max_age_rating(&self, maxAgeRating: u32) -> Result<RatedContentRestrictions> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithMaxAgeRating)(self.0.as_abi() as *const _ as *mut _, maxAgeRating, &mut out);
        if hr == S_OK { Ok(RatedContentRestrictions::wrap_nonnull(out)) } else { err(hr) }
    }}
}
} // Windows.Media.ContentRestrictions
pub mod control { // Windows.Media.Control
use crate::prelude::*;
DEFINE_IID!(IID_ICurrentSessionChangedEventArgs, 1768540985, 3066, 24544, 141, 115, 9, 204, 94, 84, 8, 225);
RT_INTERFACE!{interface ICurrentSessionChangedEventArgs(ICurrentSessionChangedEventArgsVtbl, ICurrentSessionChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ICurrentSessionChangedEventArgs] {
    
}}
RT_CLASS!{class CurrentSessionChangedEventArgs: ICurrentSessionChangedEventArgs}
DEFINE_IID!(IID_IGlobalSystemMediaTransportControlsSession, 1900595253, 39700, 23266, 171, 133, 220, 155, 28, 20, 225, 168);
RT_INTERFACE!{interface IGlobalSystemMediaTransportControlsSession(IGlobalSystemMediaTransportControlsSessionVtbl, IGlobalSystemMediaTransportControlsSession_Abi): IInspectable(IInspectableVtbl) [IID_IGlobalSystemMediaTransportControlsSession] {
    fn get_SourceAppUserModelId(&self, out: *mut HSTRING) -> HRESULT,
    fn TryGetMediaPropertiesAsync(&self, out: *mut <foundation::IAsyncOperation<GlobalSystemMediaTransportControlsSessionMediaProperties> as RtType>::Abi) -> HRESULT,
    fn GetTimelineProperties(&self, out: *mut <GlobalSystemMediaTransportControlsSessionTimelineProperties as RtType>::Abi) -> HRESULT,
    fn GetPlaybackInfo(&self, out: *mut <GlobalSystemMediaTransportControlsSessionPlaybackInfo as RtType>::Abi) -> HRESULT,
    fn TryPlayAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryPauseAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryStopAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryRecordAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryFastForwardAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryRewindAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TrySkipNextAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TrySkipPreviousAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryChangeChannelUpAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryChangeChannelDownAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryTogglePlayPauseAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryChangeAutoRepeatModeAsync(&self, requestedAutoRepeatMode: super::MediaPlaybackAutoRepeatMode, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryChangePlaybackRateAsync(&self, requestedPlaybackRate: f64, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryChangeShuffleActiveAsync(&self, requestedShuffleState: bool, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryChangePlaybackPositionAsync(&self, requestedPlaybackPosition: i64, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn add_TimelinePropertiesChanged(&self, handler: <foundation::TypedEventHandler<GlobalSystemMediaTransportControlsSession, TimelinePropertiesChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TimelinePropertiesChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PlaybackInfoChanged(&self, handler: <foundation::TypedEventHandler<GlobalSystemMediaTransportControlsSession, PlaybackInfoChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PlaybackInfoChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_MediaPropertiesChanged(&self, handler: <foundation::TypedEventHandler<GlobalSystemMediaTransportControlsSession, MediaPropertiesChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MediaPropertiesChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IGlobalSystemMediaTransportControlsSession {
    #[inline] pub fn get_source_app_user_model_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SourceAppUserModelId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_media_properties_async(&self) -> Result<foundation::IAsyncOperation<GlobalSystemMediaTransportControlsSessionMediaProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryGetMediaPropertiesAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_timeline_properties(&self) -> Result<Option<GlobalSystemMediaTransportControlsSessionTimelineProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetTimelineProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GlobalSystemMediaTransportControlsSessionTimelineProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_playback_info(&self) -> Result<Option<GlobalSystemMediaTransportControlsSessionPlaybackInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetPlaybackInfo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GlobalSystemMediaTransportControlsSessionPlaybackInfo::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_play_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryPlayAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_pause_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryPauseAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_stop_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryStopAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_record_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryRecordAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_fast_forward_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryFastForwardAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_rewind_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryRewindAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_skip_next_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TrySkipNextAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_skip_previous_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TrySkipPreviousAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_change_channel_up_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryChangeChannelUpAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_change_channel_down_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryChangeChannelDownAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_toggle_play_pause_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryTogglePlayPauseAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_change_auto_repeat_mode_async(&self, requestedAutoRepeatMode: super::MediaPlaybackAutoRepeatMode) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryChangeAutoRepeatModeAsync)(self.0.as_abi() as *const _ as *mut _, requestedAutoRepeatMode, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_change_playback_rate_async(&self, requestedPlaybackRate: f64) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryChangePlaybackRateAsync)(self.0.as_abi() as *const _ as *mut _, requestedPlaybackRate, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_change_shuffle_active_async(&self, requestedShuffleState: bool) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryChangeShuffleActiveAsync)(self.0.as_abi() as *const _ as *mut _, requestedShuffleState, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_change_playback_position_async(&self, requestedPlaybackPosition: i64) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryChangePlaybackPositionAsync)(self.0.as_abi() as *const _ as *mut _, requestedPlaybackPosition, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_timeline_properties_changed(&self, handler: &foundation::TypedEventHandler<GlobalSystemMediaTransportControlsSession, TimelinePropertiesChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_TimelinePropertiesChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_timeline_properties_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_TimelinePropertiesChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_playback_info_changed(&self, handler: &foundation::TypedEventHandler<GlobalSystemMediaTransportControlsSession, PlaybackInfoChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PlaybackInfoChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_playback_info_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PlaybackInfoChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_media_properties_changed(&self, handler: &foundation::TypedEventHandler<GlobalSystemMediaTransportControlsSession, MediaPropertiesChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_MediaPropertiesChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_media_properties_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_MediaPropertiesChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GlobalSystemMediaTransportControlsSession: IGlobalSystemMediaTransportControlsSession}
DEFINE_IID!(IID_IGlobalSystemMediaTransportControlsSessionManager, 3402534572, 59502, 20554, 171, 49, 95, 248, 255, 27, 206, 73);
RT_INTERFACE!{interface IGlobalSystemMediaTransportControlsSessionManager(IGlobalSystemMediaTransportControlsSessionManagerVtbl, IGlobalSystemMediaTransportControlsSessionManager_Abi): IInspectable(IInspectableVtbl) [IID_IGlobalSystemMediaTransportControlsSessionManager] {
    fn GetCurrentSession(&self, out: *mut <GlobalSystemMediaTransportControlsSession as RtType>::Abi) -> HRESULT,
    fn GetSessions(&self, out: *mut <foundation::collections::IVectorView<GlobalSystemMediaTransportControlsSession> as RtType>::Abi) -> HRESULT,
    fn add_CurrentSessionChanged(&self, handler: <foundation::TypedEventHandler<GlobalSystemMediaTransportControlsSessionManager, CurrentSessionChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CurrentSessionChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SessionsChanged(&self, handler: <foundation::TypedEventHandler<GlobalSystemMediaTransportControlsSessionManager, SessionsChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SessionsChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IGlobalSystemMediaTransportControlsSessionManager {
    #[inline] pub fn get_current_session(&self) -> Result<Option<GlobalSystemMediaTransportControlsSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCurrentSession)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GlobalSystemMediaTransportControlsSession::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sessions(&self) -> Result<Option<foundation::collections::IVectorView<GlobalSystemMediaTransportControlsSession>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetSessions)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_current_session_changed(&self, handler: &foundation::TypedEventHandler<GlobalSystemMediaTransportControlsSessionManager, CurrentSessionChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_CurrentSessionChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_current_session_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_CurrentSessionChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_sessions_changed(&self, handler: &foundation::TypedEventHandler<GlobalSystemMediaTransportControlsSessionManager, SessionsChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SessionsChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_sessions_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SessionsChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GlobalSystemMediaTransportControlsSessionManager: IGlobalSystemMediaTransportControlsSessionManager}
impl RtActivatable<IGlobalSystemMediaTransportControlsSessionManagerStatics> for GlobalSystemMediaTransportControlsSessionManager {}
impl GlobalSystemMediaTransportControlsSessionManager {
    #[inline] pub fn request_async() -> Result<foundation::IAsyncOperation<GlobalSystemMediaTransportControlsSessionManager>> {
        <Self as RtActivatable<IGlobalSystemMediaTransportControlsSessionManagerStatics>>::get_activation_factory().request_async()
    }
}
DEFINE_CLSID!(GlobalSystemMediaTransportControlsSessionManager(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,110,116,114,111,108,46,71,108,111,98,97,108,83,121,115,116,101,109,77,101,100,105,97,84,114,97,110,115,112,111,114,116,67,111,110,116,114,111,108,115,83,101,115,115,105,111,110,77,97,110,97,103,101,114,0]) [CLSID_GlobalSystemMediaTransportControlsSessionManager]);
DEFINE_IID!(IID_IGlobalSystemMediaTransportControlsSessionManagerStatics, 542164206, 4512, 22494, 174, 215, 201, 124, 112, 51, 130, 69);
RT_INTERFACE!{static interface IGlobalSystemMediaTransportControlsSessionManagerStatics(IGlobalSystemMediaTransportControlsSessionManagerStaticsVtbl, IGlobalSystemMediaTransportControlsSessionManagerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IGlobalSystemMediaTransportControlsSessionManagerStatics] {
    fn RequestAsync(&self, out: *mut <foundation::IAsyncOperation<GlobalSystemMediaTransportControlsSessionManager> as RtType>::Abi) -> HRESULT
}}
impl IGlobalSystemMediaTransportControlsSessionManagerStatics {
    #[inline] pub fn request_async(&self) -> Result<foundation::IAsyncOperation<GlobalSystemMediaTransportControlsSessionManager>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGlobalSystemMediaTransportControlsSessionMediaProperties, 1753574646, 44468, 21682, 172, 22, 5, 131, 121, 7, 172, 182);
RT_INTERFACE!{interface IGlobalSystemMediaTransportControlsSessionMediaProperties(IGlobalSystemMediaTransportControlsSessionMediaPropertiesVtbl, IGlobalSystemMediaTransportControlsSessionMediaProperties_Abi): IInspectable(IInspectableVtbl) [IID_IGlobalSystemMediaTransportControlsSessionMediaProperties] {
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Subtitle(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AlbumArtist(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Artist(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AlbumTitle(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TrackNumber(&self, out: *mut i32) -> HRESULT,
    fn get_Genres(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT,
    fn get_AlbumTrackCount(&self, out: *mut i32) -> HRESULT,
    fn get_PlaybackType(&self, out: *mut <foundation::IReference<super::MediaPlaybackType> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_Thumbnail(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT
}}
impl IGlobalSystemMediaTransportControlsSessionMediaProperties {
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Title)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_subtitle(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Subtitle)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_album_artist(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AlbumArtist)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_artist(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Artist)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_album_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AlbumTitle)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_track_number(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TrackNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_genres(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Genres)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_album_track_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AlbumTrackCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_playback_type(&self) -> Result<Option<foundation::IReference<super::MediaPlaybackType>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_thumbnail(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Thumbnail)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GlobalSystemMediaTransportControlsSessionMediaProperties: IGlobalSystemMediaTransportControlsSessionMediaProperties}
DEFINE_IID!(IID_IGlobalSystemMediaTransportControlsSessionPlaybackControls, 1694606310, 48250, 20538, 187, 27, 104, 241, 88, 243, 251, 3);
RT_INTERFACE!{interface IGlobalSystemMediaTransportControlsSessionPlaybackControls(IGlobalSystemMediaTransportControlsSessionPlaybackControlsVtbl, IGlobalSystemMediaTransportControlsSessionPlaybackControls_Abi): IInspectable(IInspectableVtbl) [IID_IGlobalSystemMediaTransportControlsSessionPlaybackControls] {
    fn get_IsPlayEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsPauseEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsStopEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsRecordEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsFastForwardEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsRewindEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsNextEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsPreviousEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsChannelUpEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsChannelDownEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsPlayPauseToggleEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsShuffleEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsRepeatEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsPlaybackRateEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsPlaybackPositionEnabled(&self, out: *mut bool) -> HRESULT
}}
impl IGlobalSystemMediaTransportControlsSessionPlaybackControls {
    #[inline] pub fn get_is_play_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPlayEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_pause_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPauseEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_stop_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStopEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_record_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsRecordEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_fast_forward_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsFastForwardEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_rewind_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsRewindEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_next_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsNextEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_previous_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPreviousEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_channel_up_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsChannelUpEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_channel_down_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsChannelDownEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_play_pause_toggle_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPlayPauseToggleEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_shuffle_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsShuffleEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_repeat_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsRepeatEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_playback_rate_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPlaybackRateEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_playback_position_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPlaybackPositionEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GlobalSystemMediaTransportControlsSessionPlaybackControls: IGlobalSystemMediaTransportControlsSessionPlaybackControls}
DEFINE_IID!(IID_IGlobalSystemMediaTransportControlsSessionPlaybackInfo, 2494871247, 59578, 20909, 135, 167, 193, 10, 222, 16, 97, 39);
RT_INTERFACE!{interface IGlobalSystemMediaTransportControlsSessionPlaybackInfo(IGlobalSystemMediaTransportControlsSessionPlaybackInfoVtbl, IGlobalSystemMediaTransportControlsSessionPlaybackInfo_Abi): IInspectable(IInspectableVtbl) [IID_IGlobalSystemMediaTransportControlsSessionPlaybackInfo] {
    fn get_Controls(&self, out: *mut <GlobalSystemMediaTransportControlsSessionPlaybackControls as RtType>::Abi) -> HRESULT,
    fn get_PlaybackStatus(&self, out: *mut GlobalSystemMediaTransportControlsSessionPlaybackStatus) -> HRESULT,
    fn get_PlaybackType(&self, out: *mut <foundation::IReference<super::MediaPlaybackType> as RtType>::Abi) -> HRESULT,
    fn get_AutoRepeatMode(&self, out: *mut <foundation::IReference<super::MediaPlaybackAutoRepeatMode> as RtType>::Abi) -> HRESULT,
    fn get_PlaybackRate(&self, out: *mut <foundation::IReference<f64> as RtType>::Abi) -> HRESULT,
    fn get_IsShuffleActive(&self, out: *mut <foundation::IReference<bool> as RtType>::Abi) -> HRESULT
}}
impl IGlobalSystemMediaTransportControlsSessionPlaybackInfo {
    #[inline] pub fn get_controls(&self) -> Result<Option<GlobalSystemMediaTransportControlsSessionPlaybackControls>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Controls)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GlobalSystemMediaTransportControlsSessionPlaybackControls::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_playback_status(&self) -> Result<GlobalSystemMediaTransportControlsSessionPlaybackStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_playback_type(&self) -> Result<Option<foundation::IReference<super::MediaPlaybackType>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_repeat_mode(&self) -> Result<Option<foundation::IReference<super::MediaPlaybackAutoRepeatMode>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutoRepeatMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_playback_rate(&self) -> Result<Option<foundation::IReference<f64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_shuffle_active(&self) -> Result<Option<foundation::IReference<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsShuffleActive)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GlobalSystemMediaTransportControlsSessionPlaybackInfo: IGlobalSystemMediaTransportControlsSessionPlaybackInfo}
RT_ENUM! { enum GlobalSystemMediaTransportControlsSessionPlaybackStatus: i32 {
    Closed = 0, Opened = 1, Changing = 2, Stopped = 3, Playing = 4, Paused = 5,
}}
DEFINE_IID!(IID_IGlobalSystemMediaTransportControlsSessionTimelineProperties, 3991093558, 28453, 22669, 142, 207, 234, 91, 103, 53, 170, 165);
RT_INTERFACE!{interface IGlobalSystemMediaTransportControlsSessionTimelineProperties(IGlobalSystemMediaTransportControlsSessionTimelinePropertiesVtbl, IGlobalSystemMediaTransportControlsSessionTimelineProperties_Abi): IInspectable(IInspectableVtbl) [IID_IGlobalSystemMediaTransportControlsSessionTimelineProperties] {
    fn get_StartTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_EndTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_MinSeekTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_MaxSeekTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_LastUpdatedTime(&self, out: *mut foundation::DateTime) -> HRESULT
}}
impl IGlobalSystemMediaTransportControlsSessionTimelineProperties {
    #[inline] pub fn get_start_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StartTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_end_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_EndTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_seek_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinSeekTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_seek_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxSeekTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_last_updated_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LastUpdatedTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GlobalSystemMediaTransportControlsSessionTimelineProperties: IGlobalSystemMediaTransportControlsSessionTimelineProperties}
DEFINE_IID!(IID_IMediaPropertiesChangedEventArgs, 2100773323, 44528, 23791, 145, 186, 207, 171, 205, 215, 118, 120);
RT_INTERFACE!{interface IMediaPropertiesChangedEventArgs(IMediaPropertiesChangedEventArgsVtbl, IMediaPropertiesChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPropertiesChangedEventArgs] {
    
}}
RT_CLASS!{class MediaPropertiesChangedEventArgs: IMediaPropertiesChangedEventArgs}
DEFINE_IID!(IID_IPlaybackInfoChangedEventArgs, 2020038338, 48141, 20645, 136, 7, 5, 66, 145, 254, 241, 57);
RT_INTERFACE!{interface IPlaybackInfoChangedEventArgs(IPlaybackInfoChangedEventArgsVtbl, IPlaybackInfoChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPlaybackInfoChangedEventArgs] {
    
}}
RT_CLASS!{class PlaybackInfoChangedEventArgs: IPlaybackInfoChangedEventArgs}
DEFINE_IID!(IID_ISessionsChangedEventArgs, 3153120562, 17092, 23128, 179, 23, 243, 75, 191, 189, 38, 224);
RT_INTERFACE!{interface ISessionsChangedEventArgs(ISessionsChangedEventArgsVtbl, ISessionsChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ISessionsChangedEventArgs] {
    
}}
RT_CLASS!{class SessionsChangedEventArgs: ISessionsChangedEventArgs}
DEFINE_IID!(IID_ITimelinePropertiesChangedEventArgs, 688077359, 51491, 23159, 188, 175, 5, 95, 244, 21, 173, 50);
RT_INTERFACE!{interface ITimelinePropertiesChangedEventArgs(ITimelinePropertiesChangedEventArgsVtbl, ITimelinePropertiesChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ITimelinePropertiesChangedEventArgs] {
    
}}
RT_CLASS!{class TimelinePropertiesChangedEventArgs: ITimelinePropertiesChangedEventArgs}
} // Windows.Media.Control
pub mod core { // Windows.Media.Core
use crate::prelude::*;
RT_ENUM! { enum AudioDecoderDegradation: i32 {
    None = 0, DownmixTo2Channels = 1, DownmixTo6Channels = 2, DownmixTo8Channels = 3,
}}
RT_ENUM! { enum AudioDecoderDegradationReason: i32 {
    None = 0, LicensingRequirement = 1, SpatialAudioNotSupported = 2,
}}
DEFINE_IID!(IID_IAudioStreamDescriptor, 506893028, 16423, 18503, 167, 11, 223, 29, 154, 42, 123, 4);
RT_INTERFACE!{interface IAudioStreamDescriptor(IAudioStreamDescriptorVtbl, IAudioStreamDescriptor_Abi): IInspectable(IInspectableVtbl) [IID_IAudioStreamDescriptor] {
    fn get_EncodingProperties(&self, out: *mut <super::mediaproperties::AudioEncodingProperties as RtType>::Abi) -> HRESULT
}}
impl IAudioStreamDescriptor {
    #[inline] pub fn get_encoding_properties(&self) -> Result<Option<super::mediaproperties::AudioEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EncodingProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::mediaproperties::AudioEncodingProperties::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioStreamDescriptor: IAudioStreamDescriptor}
impl RtActivatable<IAudioStreamDescriptorFactory> for AudioStreamDescriptor {}
impl AudioStreamDescriptor {
    #[inline] pub fn create(encodingProperties: &super::mediaproperties::AudioEncodingProperties) -> Result<AudioStreamDescriptor> {
        <Self as RtActivatable<IAudioStreamDescriptorFactory>>::get_activation_factory().create(encodingProperties)
    }
}
DEFINE_CLSID!(AudioStreamDescriptor(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,65,117,100,105,111,83,116,114,101,97,109,68,101,115,99,114,105,112,116,111,114,0]) [CLSID_AudioStreamDescriptor]);
DEFINE_IID!(IID_IAudioStreamDescriptor2, 778629622, 42056, 18811, 136, 64, 133, 8, 38, 101, 172, 249);
RT_INTERFACE!{interface IAudioStreamDescriptor2(IAudioStreamDescriptor2Vtbl, IAudioStreamDescriptor2_Abi): IInspectable(IInspectableVtbl) [IID_IAudioStreamDescriptor2] {
    fn put_LeadingEncoderPadding(&self, value: <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_LeadingEncoderPadding(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn put_TrailingEncoderPadding(&self, value: <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_TrailingEncoderPadding(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT
}}
impl IAudioStreamDescriptor2 {
    #[inline] pub fn set_leading_encoder_padding(&self, value: &foundation::IReference<u32>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_LeadingEncoderPadding)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_leading_encoder_padding(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_LeadingEncoderPadding)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_trailing_encoder_padding(&self, value: &foundation::IReference<u32>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_TrailingEncoderPadding)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_trailing_encoder_padding(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TrailingEncoderPadding)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAudioStreamDescriptor3, 1294077345, 36483, 17647, 137, 115, 47, 99, 233, 147, 243, 107);
RT_INTERFACE!{interface IAudioStreamDescriptor3(IAudioStreamDescriptor3Vtbl, IAudioStreamDescriptor3_Abi): IInspectable(IInspectableVtbl) [IID_IAudioStreamDescriptor3] {
    fn Copy(&self, out: *mut <AudioStreamDescriptor as RtType>::Abi) -> HRESULT
}}
impl IAudioStreamDescriptor3 {
    #[inline] pub fn copy(&self) -> Result<Option<AudioStreamDescriptor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Copy)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioStreamDescriptor::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAudioStreamDescriptorFactory, 1250348702, 19633, 17280, 142, 12, 131, 80, 75, 127, 91, 243);
RT_INTERFACE!{static interface IAudioStreamDescriptorFactory(IAudioStreamDescriptorFactoryVtbl, IAudioStreamDescriptorFactory_Abi): IInspectable(IInspectableVtbl) [IID_IAudioStreamDescriptorFactory] {
    fn Create(&self, encodingProperties: <super::mediaproperties::AudioEncodingProperties as RtType>::Abi, out: *mut <AudioStreamDescriptor as RtType>::Abi) -> HRESULT
}}
impl IAudioStreamDescriptorFactory {
    #[inline] pub fn create(&self, encodingProperties: &super::mediaproperties::AudioEncodingProperties) -> Result<AudioStreamDescriptor> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(encodingProperties) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioStreamDescriptor::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAudioTrack, 4063981175, 16119, 16606, 185, 67, 6, 139, 19, 33, 112, 29);
RT_INTERFACE!{interface IAudioTrack(IAudioTrackVtbl, IAudioTrack_Abi): IInspectable(IInspectableVtbl) [IID_IAudioTrack] {
    fn add_OpenFailed(&self, handler: <foundation::TypedEventHandler<AudioTrack, AudioTrackOpenFailedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_OpenFailed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn GetEncodingProperties(&self, out: *mut <super::mediaproperties::AudioEncodingProperties as RtType>::Abi) -> HRESULT,
    fn get_PlaybackItem(&self, out: *mut <super::playback::MediaPlaybackItem as RtType>::Abi) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SupportInfo(&self, out: *mut <AudioTrackSupportInfo as RtType>::Abi) -> HRESULT
}}
impl IAudioTrack {
    #[inline] pub fn add_open_failed(&self, handler: &foundation::TypedEventHandler<AudioTrack, AudioTrackOpenFailedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_OpenFailed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_open_failed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_OpenFailed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_encoding_properties(&self) -> Result<Option<super::mediaproperties::AudioEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetEncodingProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::mediaproperties::AudioEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_playback_item(&self) -> Result<Option<super::playback::MediaPlaybackItem>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackItem)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::playback::MediaPlaybackItem::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Name)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_support_info(&self) -> Result<Option<AudioTrackSupportInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportInfo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioTrackSupportInfo::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioTrack: IMediaTrack}
DEFINE_IID!(IID_IAudioTrackOpenFailedEventArgs, 4007508409, 47996, 16658, 191, 118, 147, 132, 103, 111, 130, 75);
RT_INTERFACE!{interface IAudioTrackOpenFailedEventArgs(IAudioTrackOpenFailedEventArgsVtbl, IAudioTrackOpenFailedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAudioTrackOpenFailedEventArgs] {
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl IAudioTrackOpenFailedEventArgs {
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioTrackOpenFailedEventArgs: IAudioTrackOpenFailedEventArgs}
DEFINE_IID!(IID_IAudioTrackSupportInfo, 395046903, 52281, 17574, 185, 81, 74, 86, 83, 240, 115, 250);
RT_INTERFACE!{interface IAudioTrackSupportInfo(IAudioTrackSupportInfoVtbl, IAudioTrackSupportInfo_Abi): IInspectable(IInspectableVtbl) [IID_IAudioTrackSupportInfo] {
    fn get_DecoderStatus(&self, out: *mut MediaDecoderStatus) -> HRESULT,
    fn get_Degradation(&self, out: *mut AudioDecoderDegradation) -> HRESULT,
    fn get_DegradationReason(&self, out: *mut AudioDecoderDegradationReason) -> HRESULT,
    fn get_MediaSourceStatus(&self, out: *mut MediaSourceStatus) -> HRESULT
}}
impl IAudioTrackSupportInfo {
    #[inline] pub fn get_decoder_status(&self) -> Result<MediaDecoderStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DecoderStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_degradation(&self) -> Result<AudioDecoderDegradation> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Degradation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_degradation_reason(&self) -> Result<AudioDecoderDegradationReason> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DegradationReason)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_media_source_status(&self) -> Result<MediaSourceStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaSourceStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioTrackSupportInfo: IAudioTrackSupportInfo}
DEFINE_IID!(IID_IChapterCue, 1923710977, 54154, 19466, 143, 166, 117, 205, 218, 244, 102, 76);
RT_INTERFACE!{interface IChapterCue(IChapterCueVtbl, IChapterCue_Abi): IInspectable(IInspectableVtbl) [IID_IChapterCue] {
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT
}}
impl IChapterCue {
    #[inline] pub fn set_title(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Title)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Title)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ChapterCue: IChapterCue}
impl RtActivatable<IActivationFactory> for ChapterCue {}
DEFINE_CLSID!(ChapterCue(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,67,104,97,112,116,101,114,67,117,101,0]) [CLSID_ChapterCue]);
RT_ENUM! { enum CodecCategory: i32 {
    Encoder = 0, Decoder = 1,
}}
DEFINE_IID!(IID_ICodecInfo, 1374199685, 60055, 18844, 134, 172, 76, 229, 231, 63, 58, 66);
RT_INTERFACE!{interface ICodecInfo(ICodecInfoVtbl, ICodecInfo_Abi): IInspectable(IInspectableVtbl) [IID_ICodecInfo] {
    fn get_Kind(&self, out: *mut CodecKind) -> HRESULT,
    fn get_Category(&self, out: *mut CodecCategory) -> HRESULT,
    fn get_Subtypes(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsTrusted(&self, out: *mut bool) -> HRESULT
}}
impl ICodecInfo {
    #[inline] pub fn get_kind(&self) -> Result<CodecKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Kind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_category(&self) -> Result<CodecCategory> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Category)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_subtypes(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Subtypes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DisplayName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_trusted(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsTrusted)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CodecInfo: ICodecInfo}
RT_ENUM! { enum CodecKind: i32 {
    Audio = 0, Video = 1,
}}
DEFINE_IID!(IID_ICodecQuery, 573216058, 44897, 19972, 128, 138, 164, 99, 78, 47, 58, 196);
RT_INTERFACE!{interface ICodecQuery(ICodecQueryVtbl, ICodecQuery_Abi): IInspectable(IInspectableVtbl) [IID_ICodecQuery] {
    fn FindAllAsync(&self, kind: CodecKind, category: CodecCategory, subType: HSTRING, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<CodecInfo>> as RtType>::Abi) -> HRESULT
}}
impl ICodecQuery {
    #[inline] pub fn find_all_async(&self, kind: CodecKind, category: CodecCategory, subType: &HStringArg) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<CodecInfo>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindAllAsync)(self.0.as_abi() as *const _ as *mut _, kind, category, subType.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CodecQuery: ICodecQuery}
impl RtActivatable<IActivationFactory> for CodecQuery {}
DEFINE_CLSID!(CodecQuery(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,67,111,100,101,99,81,117,101,114,121,0]) [CLSID_CodecQuery]);
RT_CLASS!{static class CodecSubtypes}
impl RtActivatable<ICodecSubtypesStatics> for CodecSubtypes {}
impl CodecSubtypes {
    #[inline] pub fn get_video_format_dv25() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_dv25()
    }
    #[inline] pub fn get_video_format_dv50() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_dv50()
    }
    #[inline] pub fn get_video_format_dvc() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_dvc()
    }
    #[inline] pub fn get_video_format_dvh1() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_dvh1()
    }
    #[inline] pub fn get_video_format_dvh_d() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_dvh_d()
    }
    #[inline] pub fn get_video_format_dvsd() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_dvsd()
    }
    #[inline] pub fn get_video_format_dvsl() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_dvsl()
    }
    #[inline] pub fn get_video_format_h263() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_h263()
    }
    #[inline] pub fn get_video_format_h264() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_h264()
    }
    #[inline] pub fn get_video_format_h265() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_h265()
    }
    #[inline] pub fn get_video_format_h264es() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_h264es()
    }
    #[inline] pub fn get_video_format_hevc() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_hevc()
    }
    #[inline] pub fn get_video_format_hevc_es() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_hevc_es()
    }
    #[inline] pub fn get_video_format_m4s2() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_m4s2()
    }
    #[inline] pub fn get_video_format_mjpg() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_mjpg()
    }
    #[inline] pub fn get_video_format_mp43() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_mp43()
    }
    #[inline] pub fn get_video_format_mp4s() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_mp4s()
    }
    #[inline] pub fn get_video_format_mp4v() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_mp4v()
    }
    #[inline] pub fn get_video_format_mpeg2() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_mpeg2()
    }
    #[inline] pub fn get_video_format_vp80() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_vp80()
    }
    #[inline] pub fn get_video_format_vp90() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_vp90()
    }
    #[inline] pub fn get_video_format_mpg1() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_mpg1()
    }
    #[inline] pub fn get_video_format_mss1() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_mss1()
    }
    #[inline] pub fn get_video_format_mss2() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_mss2()
    }
    #[inline] pub fn get_video_format_wmv1() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_wmv1()
    }
    #[inline] pub fn get_video_format_wmv2() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_wmv2()
    }
    #[inline] pub fn get_video_format_wmv3() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_wmv3()
    }
    #[inline] pub fn get_video_format_wvc1() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_wvc1()
    }
    #[inline] pub fn get_video_format_420o() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_video_format_420o()
    }
    #[inline] pub fn get_audio_format_aac() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_audio_format_aac()
    }
    #[inline] pub fn get_audio_format_adts() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_audio_format_adts()
    }
    #[inline] pub fn get_audio_format_alac() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_audio_format_alac()
    }
    #[inline] pub fn get_audio_format_amr_nb() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_audio_format_amr_nb()
    }
    #[inline] pub fn get_audio_format_amr_wb() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_audio_format_amr_wb()
    }
    #[inline] pub fn get_audio_format_amr_wp() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_audio_format_amr_wp()
    }
    #[inline] pub fn get_audio_format_dolby_ac3() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_audio_format_dolby_ac3()
    }
    #[inline] pub fn get_audio_format_dolby_ac3_spdif() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_audio_format_dolby_ac3_spdif()
    }
    #[inline] pub fn get_audio_format_dolby_dd_plus() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_audio_format_dolby_dd_plus()
    }
    #[inline] pub fn get_audio_format_drm() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_audio_format_drm()
    }
    #[inline] pub fn get_audio_format_dts() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_audio_format_dts()
    }
    #[inline] pub fn get_audio_format_flac() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_audio_format_flac()
    }
    #[inline] pub fn get_audio_format_float() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_audio_format_float()
    }
    #[inline] pub fn get_audio_format_mp3() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_audio_format_mp3()
    }
    #[inline] pub fn get_audio_format_mpeg() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_audio_format_mpeg()
    }
    #[inline] pub fn get_audio_format_msp1() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_audio_format_msp1()
    }
    #[inline] pub fn get_audio_format_opus() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_audio_format_opus()
    }
    #[inline] pub fn get_audio_format_pcm() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_audio_format_pcm()
    }
    #[inline] pub fn get_audio_format_wma_spdif() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_audio_format_wma_spdif()
    }
    #[inline] pub fn get_audio_format_wmaudio_lossless() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_audio_format_wmaudio_lossless()
    }
    #[inline] pub fn get_audio_format_wmaudio_v8() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_audio_format_wmaudio_v8()
    }
    #[inline] pub fn get_audio_format_wmaudio_v9() -> Result<HString> {
        <Self as RtActivatable<ICodecSubtypesStatics>>::get_activation_factory().get_audio_format_wmaudio_v9()
    }
}
DEFINE_CLSID!(CodecSubtypes(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,67,111,100,101,99,83,117,98,116,121,112,101,115,0]) [CLSID_CodecSubtypes]);
DEFINE_IID!(IID_ICodecSubtypesStatics, 2792015090, 34955, 16932, 140, 246, 42, 141, 78, 176, 35, 130);
RT_INTERFACE!{static interface ICodecSubtypesStatics(ICodecSubtypesStaticsVtbl, ICodecSubtypesStatics_Abi): IInspectable(IInspectableVtbl) [IID_ICodecSubtypesStatics] {
    fn get_VideoFormatDV25(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatDV50(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatDvc(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatDvh1(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatDvhD(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatDvsd(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatDvsl(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatH263(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatH264(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatH265(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatH264ES(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatHevc(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatHevcES(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatM4S2(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatMjpg(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatMP43(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatMP4S(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatMP4V(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatMpeg2(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatVP80(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatVP90(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatMpg1(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatMss1(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatMss2(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatWmv1(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatWmv2(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatWmv3(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormatWvc1(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoFormat420O(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AudioFormatAac(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AudioFormatAdts(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AudioFormatAlac(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AudioFormatAmrNB(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AudioFormatAmrWB(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AudioFormatAmrWP(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AudioFormatDolbyAC3(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AudioFormatDolbyAC3Spdif(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AudioFormatDolbyDDPlus(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AudioFormatDrm(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AudioFormatDts(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AudioFormatFlac(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AudioFormatFloat(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AudioFormatMP3(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AudioFormatMPeg(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AudioFormatMsp1(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AudioFormatOpus(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AudioFormatPcm(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AudioFormatWmaSpdif(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AudioFormatWMAudioLossless(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AudioFormatWMAudioV8(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AudioFormatWMAudioV9(&self, out: *mut HSTRING) -> HRESULT
}}
impl ICodecSubtypesStatics {
    #[inline] pub fn get_video_format_dv25(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatDV25)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_dv50(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatDV50)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_dvc(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatDvc)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_dvh1(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatDvh1)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_dvh_d(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatDvhD)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_dvsd(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatDvsd)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_dvsl(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatDvsl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_h263(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatH263)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_h264(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatH264)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_h265(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatH265)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_h264es(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatH264ES)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_hevc(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatHevc)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_hevc_es(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatHevcES)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_m4s2(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatM4S2)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_mjpg(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatMjpg)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_mp43(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatMP43)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_mp4s(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatMP4S)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_mp4v(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatMP4V)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_mpeg2(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatMpeg2)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_vp80(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatVP80)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_vp90(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatVP90)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_mpg1(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatMpg1)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_mss1(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatMss1)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_mss2(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatMss2)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_wmv1(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatWmv1)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_wmv2(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatWmv2)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_wmv3(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatWmv3)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_wvc1(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormatWvc1)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_format_420o(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFormat420O)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_format_aac(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioFormatAac)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_format_adts(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioFormatAdts)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_format_alac(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioFormatAlac)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_format_amr_nb(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioFormatAmrNB)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_format_amr_wb(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioFormatAmrWB)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_format_amr_wp(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioFormatAmrWP)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_format_dolby_ac3(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioFormatDolbyAC3)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_format_dolby_ac3_spdif(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioFormatDolbyAC3Spdif)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_format_dolby_dd_plus(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioFormatDolbyDDPlus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_format_drm(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioFormatDrm)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_format_dts(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioFormatDts)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_format_flac(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioFormatFlac)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_format_float(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioFormatFloat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_format_mp3(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioFormatMP3)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_format_mpeg(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioFormatMPeg)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_format_msp1(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioFormatMsp1)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_format_opus(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioFormatOpus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_format_pcm(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioFormatPcm)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_format_wma_spdif(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioFormatWmaSpdif)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_format_wmaudio_lossless(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioFormatWMAudioLossless)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_format_wmaudio_v8(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioFormatWMAudioV8)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_format_wmaudio_v9(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioFormatWMAudioV9)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDataCue, 2088724333, 8124, 20013, 154, 135, 238, 56, 189, 29, 198, 55);
RT_INTERFACE!{interface IDataCue(IDataCueVtbl, IDataCue_Abi): IInspectable(IInspectableVtbl) [IID_IDataCue] {
    #[cfg(feature="windows-storage")] fn put_Data(&self, value: <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_Data(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IDataCue {
    #[cfg(feature="windows-storage")] #[inline] pub fn set_data(&self, value: &super::super::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Data)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_data(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Data)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DataCue: IDataCue}
impl RtActivatable<IActivationFactory> for DataCue {}
DEFINE_CLSID!(DataCue(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,68,97,116,97,67,117,101,0]) [CLSID_DataCue]);
DEFINE_IID!(IID_IDataCue2, 3159759637, 38386, 18920, 150, 241, 141, 213, 218, 198, 141, 147);
RT_INTERFACE!{interface IDataCue2(IDataCue2Vtbl, IDataCue2_Abi): IInspectable(IInspectableVtbl) [IID_IDataCue2] {
    fn get_Properties(&self, out: *mut <foundation::collections::PropertySet as RtType>::Abi) -> HRESULT
}}
impl IDataCue2 {
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::PropertySet>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::PropertySet::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IFaceDetectedEventArgs, 428966950, 50779, 18106, 133, 248, 19, 136, 5, 118, 201, 10);
RT_INTERFACE!{interface IFaceDetectedEventArgs(IFaceDetectedEventArgsVtbl, IFaceDetectedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IFaceDetectedEventArgs] {
    fn get_ResultFrame(&self, out: *mut <FaceDetectionEffectFrame as RtType>::Abi) -> HRESULT
}}
impl IFaceDetectedEventArgs {
    #[inline] pub fn get_result_frame(&self) -> Result<Option<FaceDetectionEffectFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResultFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(FaceDetectionEffectFrame::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class FaceDetectedEventArgs: IFaceDetectedEventArgs}
DEFINE_IID!(IID_IFaceDetectionEffect, 2920672210, 1346, 17065, 188, 144, 242, 131, 162, 159, 70, 193);
RT_INTERFACE!{interface IFaceDetectionEffect(IFaceDetectionEffectVtbl, IFaceDetectionEffect_Abi): IInspectable(IInspectableVtbl) [IID_IFaceDetectionEffect] {
    fn put_Enabled(&self, value: bool) -> HRESULT,
    fn get_Enabled(&self, out: *mut bool) -> HRESULT,
    fn put_DesiredDetectionInterval(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_DesiredDetectionInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn add_FaceDetected(&self, handler: <foundation::TypedEventHandler<FaceDetectionEffect, FaceDetectedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FaceDetected(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl IFaceDetectionEffect {
    #[inline] pub fn set_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Enabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Enabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_detection_interval(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DesiredDetectionInterval)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_desired_detection_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DesiredDetectionInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_face_detected(&self, handler: &foundation::TypedEventHandler<FaceDetectionEffect, FaceDetectedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_FaceDetected)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_face_detected(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_FaceDetected)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class FaceDetectionEffect: IFaceDetectionEffect}
DEFINE_IID!(IID_IFaceDetectionEffectDefinition, 1138532481, 47176, 20275, 183, 2, 31, 210, 98, 79, 176, 22);
RT_INTERFACE!{interface IFaceDetectionEffectDefinition(IFaceDetectionEffectDefinitionVtbl, IFaceDetectionEffectDefinition_Abi): IInspectable(IInspectableVtbl) [IID_IFaceDetectionEffectDefinition] {
    fn put_DetectionMode(&self, value: FaceDetectionMode) -> HRESULT,
    fn get_DetectionMode(&self, out: *mut FaceDetectionMode) -> HRESULT,
    fn put_SynchronousDetectionEnabled(&self, value: bool) -> HRESULT,
    fn get_SynchronousDetectionEnabled(&self, out: *mut bool) -> HRESULT
}}
impl IFaceDetectionEffectDefinition {
    #[inline] pub fn set_detection_mode(&self, value: FaceDetectionMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DetectionMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_detection_mode(&self) -> Result<FaceDetectionMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DetectionMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_synchronous_detection_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SynchronousDetectionEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_synchronous_detection_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SynchronousDetectionEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class FaceDetectionEffectDefinition: super::effects::IVideoEffectDefinition}
impl RtActivatable<IActivationFactory> for FaceDetectionEffectDefinition {}
DEFINE_CLSID!(FaceDetectionEffectDefinition(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,70,97,99,101,68,101,116,101,99,116,105,111,110,69,102,102,101,99,116,68,101,102,105,110,105,116,105,111,110,0]) [CLSID_FaceDetectionEffectDefinition]);
DEFINE_IID!(IID_IFaceDetectionEffectFrame, 2326825363, 24008, 17531, 162, 71, 82, 112, 189, 128, 46, 206);
RT_INTERFACE!{interface IFaceDetectionEffectFrame(IFaceDetectionEffectFrameVtbl, IFaceDetectionEffectFrame_Abi): IInspectable(IInspectableVtbl) [IID_IFaceDetectionEffectFrame] {
    fn get_DetectedFaces(&self, out: *mut <foundation::collections::IVectorView<super::faceanalysis::DetectedFace> as RtType>::Abi) -> HRESULT
}}
impl IFaceDetectionEffectFrame {
    #[inline] pub fn get_detected_faces(&self) -> Result<Option<foundation::collections::IVectorView<super::faceanalysis::DetectedFace>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DetectedFaces)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class FaceDetectionEffectFrame: IFaceDetectionEffectFrame}
RT_ENUM! { enum FaceDetectionMode: i32 {
    HighPerformance = 0, Balanced = 1, HighQuality = 2,
}}
DEFINE_IID!(IID_IHighDynamicRangeControl, 1441900462, 55639, 19913, 157, 28, 133, 83, 168, 42, 125, 153);
RT_INTERFACE!{interface IHighDynamicRangeControl(IHighDynamicRangeControlVtbl, IHighDynamicRangeControl_Abi): IInspectable(IInspectableVtbl) [IID_IHighDynamicRangeControl] {
    fn put_Enabled(&self, value: bool) -> HRESULT,
    fn get_Enabled(&self, out: *mut bool) -> HRESULT
}}
impl IHighDynamicRangeControl {
    #[inline] pub fn set_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Enabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Enabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class HighDynamicRangeControl: IHighDynamicRangeControl}
DEFINE_IID!(IID_IHighDynamicRangeOutput, 257392747, 9531, 16665, 187, 64, 58, 144, 229, 19, 132, 247);
RT_INTERFACE!{interface IHighDynamicRangeOutput(IHighDynamicRangeOutputVtbl, IHighDynamicRangeOutput_Abi): IInspectable(IInspectableVtbl) [IID_IHighDynamicRangeOutput] {
    fn get_Certainty(&self, out: *mut f64) -> HRESULT,
    fn get_FrameControllers(&self, out: *mut <foundation::collections::IVectorView<super::devices::core::FrameController> as RtType>::Abi) -> HRESULT
}}
impl IHighDynamicRangeOutput {
    #[inline] pub fn get_certainty(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Certainty)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_frame_controllers(&self) -> Result<Option<foundation::collections::IVectorView<super::devices::core::FrameController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameControllers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class HighDynamicRangeOutput: IHighDynamicRangeOutput}
DEFINE_IID!(IID_IImageCue, 1384284802, 13947, 17419, 145, 22, 60, 132, 87, 13, 210, 112);
RT_INTERFACE!{interface IImageCue(IImageCueVtbl, IImageCue_Abi): IInspectable(IInspectableVtbl) [IID_IImageCue] {
    fn get_Position(&self, out: *mut TimedTextPoint) -> HRESULT,
    fn put_Position(&self, value: TimedTextPoint) -> HRESULT,
    fn get_Extent(&self, out: *mut TimedTextSize) -> HRESULT,
    fn put_Extent(&self, value: TimedTextSize) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn put_SoftwareBitmap(&self, value: <super::super::graphics::imaging::SoftwareBitmap as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn get_SoftwareBitmap(&self, out: *mut <super::super::graphics::imaging::SoftwareBitmap as RtType>::Abi) -> HRESULT
}}
impl IImageCue {
    #[inline] pub fn get_position(&self) -> Result<TimedTextPoint> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_position(&self, value: TimedTextPoint) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Position)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_extent(&self) -> Result<TimedTextSize> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Extent)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_extent(&self, value: TimedTextSize) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Extent)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_software_bitmap(&self, value: &super::super::graphics::imaging::SoftwareBitmap) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SoftwareBitmap)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_software_bitmap(&self) -> Result<Option<super::super::graphics::imaging::SoftwareBitmap>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SoftwareBitmap)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::graphics::imaging::SoftwareBitmap::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ImageCue: IImageCue}
impl RtActivatable<IActivationFactory> for ImageCue {}
DEFINE_CLSID!(ImageCue(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,73,109,97,103,101,67,117,101,0]) [CLSID_ImageCue]);
DEFINE_IID!(IID_IInitializeMediaStreamSourceRequestedEventArgs, 633095649, 39688, 19502, 168, 85, 69, 66, 241, 167, 93, 235);
RT_INTERFACE!{interface IInitializeMediaStreamSourceRequestedEventArgs(IInitializeMediaStreamSourceRequestedEventArgsVtbl, IInitializeMediaStreamSourceRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IInitializeMediaStreamSourceRequestedEventArgs] {
    fn get_Source(&self, out: *mut <MediaStreamSource as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_RandomAccessStream(&self, out: *mut <super::super::storage::streams::IRandomAccessStream as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IInitializeMediaStreamSourceRequestedEventArgs {
    #[inline] pub fn get_source(&self) -> Result<Option<MediaStreamSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Source)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaStreamSource::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_random_access_stream(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStream>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_RandomAccessStream)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStream::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InitializeMediaStreamSourceRequestedEventArgs: IInitializeMediaStreamSourceRequestedEventArgs}
RT_CLASS!{static class LowLightFusion}
impl RtActivatable<ILowLightFusionStatics> for LowLightFusion {}
impl LowLightFusion {
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_supported_bitmap_pixel_formats() -> Result<Option<foundation::collections::IVectorView<super::super::graphics::imaging::BitmapPixelFormat>>> {
        <Self as RtActivatable<ILowLightFusionStatics>>::get_activation_factory().get_supported_bitmap_pixel_formats()
    }
    #[inline] pub fn get_max_supported_frame_count() -> Result<i32> {
        <Self as RtActivatable<ILowLightFusionStatics>>::get_activation_factory().get_max_supported_frame_count()
    }
    #[cfg(feature="windows-graphics")] #[inline] pub fn fuse_async(frameSet: &foundation::collections::IIterable<super::super::graphics::imaging::SoftwareBitmap>) -> Result<foundation::IAsyncOperationWithProgress<LowLightFusionResult, f64>> {
        <Self as RtActivatable<ILowLightFusionStatics>>::get_activation_factory().fuse_async(frameSet)
    }
}
DEFINE_CLSID!(LowLightFusion(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,76,111,119,76,105,103,104,116,70,117,115,105,111,110,0]) [CLSID_LowLightFusion]);
DEFINE_IID!(IID_ILowLightFusionResult, 2028846645, 10144, 17120, 156, 211, 115, 141, 32, 137, 222, 156);
RT_INTERFACE!{interface ILowLightFusionResult(ILowLightFusionResultVtbl, ILowLightFusionResult_Abi): IInspectable(IInspectableVtbl) [IID_ILowLightFusionResult] {
    #[cfg(feature="windows-graphics")] fn get_Frame(&self, out: *mut <super::super::graphics::imaging::SoftwareBitmap as RtType>::Abi) -> HRESULT
}}
impl ILowLightFusionResult {
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_frame(&self) -> Result<Option<super::super::graphics::imaging::SoftwareBitmap>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Frame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::graphics::imaging::SoftwareBitmap::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LowLightFusionResult: ILowLightFusionResult}
DEFINE_IID!(IID_ILowLightFusionStatics, 1392836973, 49822, 16610, 135, 169, 158, 31, 210, 241, 146, 245);
RT_INTERFACE!{static interface ILowLightFusionStatics(ILowLightFusionStaticsVtbl, ILowLightFusionStatics_Abi): IInspectable(IInspectableVtbl) [IID_ILowLightFusionStatics] {
    #[cfg(feature="windows-graphics")] fn get_SupportedBitmapPixelFormats(&self, out: *mut <foundation::collections::IVectorView<super::super::graphics::imaging::BitmapPixelFormat> as RtType>::Abi) -> HRESULT,
    fn get_MaxSupportedFrameCount(&self, out: *mut i32) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn FuseAsync(&self, frameSet: <foundation::collections::IIterable<super::super::graphics::imaging::SoftwareBitmap> as RtType>::Abi, out: *mut <foundation::IAsyncOperationWithProgress<LowLightFusionResult, f64> as RtType>::Abi) -> HRESULT
}}
impl ILowLightFusionStatics {
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_supported_bitmap_pixel_formats(&self) -> Result<Option<foundation::collections::IVectorView<super::super::graphics::imaging::BitmapPixelFormat>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedBitmapPixelFormats)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_max_supported_frame_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxSupportedFrameCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn fuse_async(&self, frameSet: &foundation::collections::IIterable<super::super::graphics::imaging::SoftwareBitmap>) -> Result<foundation::IAsyncOperationWithProgress<LowLightFusionResult, f64>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FuseAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(frameSet) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperationWithProgress::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaBinder, 729694378, 56839, 16975, 131, 241, 241, 222, 70, 196, 250, 46);
RT_INTERFACE!{interface IMediaBinder(IMediaBinderVtbl, IMediaBinder_Abi): IInspectable(IInspectableVtbl) [IID_IMediaBinder] {
    fn add_Binding(&self, handler: <foundation::TypedEventHandler<MediaBinder, MediaBindingEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Binding(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Token(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Token(&self, value: HSTRING) -> HRESULT,
    fn get_Source(&self, out: *mut <MediaSource as RtType>::Abi) -> HRESULT
}}
impl IMediaBinder {
    #[inline] pub fn add_binding(&self, handler: &foundation::TypedEventHandler<MediaBinder, MediaBindingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Binding)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_binding(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Binding)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_token(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Token)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_token(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Token)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_source(&self) -> Result<Option<MediaSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Source)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaSource::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaBinder: IMediaBinder}
impl RtActivatable<IActivationFactory> for MediaBinder {}
DEFINE_CLSID!(MediaBinder(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,77,101,100,105,97,66,105,110,100,101,114,0]) [CLSID_MediaBinder]);
DEFINE_IID!(IID_IMediaBindingEventArgs, 3055333978, 7021, 17968, 168, 109, 47, 8, 55, 247, 18, 229);
RT_INTERFACE!{interface IMediaBindingEventArgs(IMediaBindingEventArgsVtbl, IMediaBindingEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaBindingEventArgs] {
    fn add_Canceled(&self, handler: <foundation::TypedEventHandler<MediaBindingEventArgs, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Canceled(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_MediaBinder(&self, out: *mut <MediaBinder as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT,
    fn SetUri(&self, uri: <foundation::Uri as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SetStream(&self, stream: <super::super::storage::streams::IRandomAccessStream as RtType>::Abi, contentType: HSTRING) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SetStreamReference(&self, stream: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi, contentType: HSTRING) -> HRESULT
}}
impl IMediaBindingEventArgs {
    #[inline] pub fn add_canceled(&self, handler: &foundation::TypedEventHandler<MediaBindingEventArgs, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Canceled)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_canceled(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Canceled)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_media_binder(&self) -> Result<Option<MediaBinder>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaBinder)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaBinder::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_uri(&self, uri: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetUri)(self.0.as_abi() as *const _ as *mut _, get_abi(uri) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_stream(&self, stream: &super::super::storage::streams::IRandomAccessStream, contentType: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetStream)(self.0.as_abi() as *const _ as *mut _, get_abi(stream) as *const _ as *mut _, contentType.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_stream_reference(&self, stream: &super::super::storage::streams::IRandomAccessStreamReference, contentType: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetStreamReference)(self.0.as_abi() as *const _ as *mut _, get_abi(stream) as *const _ as *mut _, contentType.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaBindingEventArgs: IMediaBindingEventArgs}
DEFINE_IID!(IID_IMediaBindingEventArgs2, 73714923, 47962, 18479, 184, 186, 240, 40, 76, 105, 101, 103);
RT_INTERFACE!{interface IMediaBindingEventArgs2(IMediaBindingEventArgs2Vtbl, IMediaBindingEventArgs2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaBindingEventArgs2] {
    fn SetAdaptiveMediaSource(&self, mediaSource: <super::streaming::adaptive::AdaptiveMediaSource as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SetStorageFile(&self, file: <super::super::storage::IStorageFile as RtType>::Abi) -> HRESULT
}}
impl IMediaBindingEventArgs2 {
    #[inline] pub fn set_adaptive_media_source(&self, mediaSource: &super::streaming::adaptive::AdaptiveMediaSource) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetAdaptiveMediaSource)(self.0.as_abi() as *const _ as *mut _, get_abi(mediaSource) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_storage_file(&self, file: &super::super::storage::IStorageFile) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetStorageFile)(self.0.as_abi() as *const _ as *mut _, get_abi(file) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaBindingEventArgs3, 4176168798, 6590, 17660, 165, 237, 122, 186, 49, 80, 55, 249);
RT_INTERFACE!{interface IMediaBindingEventArgs3(IMediaBindingEventArgs3Vtbl, IMediaBindingEventArgs3_Abi): IInspectable(IInspectableVtbl) [IID_IMediaBindingEventArgs3] {
    #[cfg(feature="windows-networking")] fn SetDownloadOperation(&self, downloadOperation: <super::super::networking::backgroundtransfer::DownloadOperation as RtType>::Abi) -> HRESULT
}}
impl IMediaBindingEventArgs3 {
    #[cfg(feature="windows-networking")] #[inline] pub fn set_download_operation(&self, downloadOperation: &super::super::networking::backgroundtransfer::DownloadOperation) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetDownloadOperation)(self.0.as_abi() as *const _ as *mut _, get_abi(downloadOperation) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaCue, 3352387165, 23004, 17183, 160, 238, 39, 116, 67, 35, 179, 109);
RT_INTERFACE!{interface IMediaCue(IMediaCueVtbl, IMediaCue_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCue] {
    fn put_StartTime(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_StartTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_Duration(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_Id(&self, value: HSTRING) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMediaCue {
    #[inline] pub fn set_start_time(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_StartTime)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_start_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StartTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_duration(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Duration)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Id)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaCueEventArgs, 3509536759, 24484, 20072, 159, 229, 50, 22, 13, 206, 229, 126);
RT_INTERFACE!{interface IMediaCueEventArgs(IMediaCueEventArgsVtbl, IMediaCueEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCueEventArgs] {
    fn get_Cue(&self, out: *mut <IMediaCue as RtType>::Abi) -> HRESULT
}}
impl IMediaCueEventArgs {
    #[inline] pub fn get_cue(&self) -> Result<Option<IMediaCue>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Cue)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IMediaCue::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaCueEventArgs: IMediaCueEventArgs}
RT_ENUM! { enum MediaDecoderStatus: i32 {
    FullySupported = 0, UnsupportedSubtype = 1, UnsupportedEncoderProperties = 2, Degraded = 3,
}}
DEFINE_IID!(IID_IMediaSource, 3888100761, 41117, 19489, 188, 223, 32, 175, 79, 134, 179, 217);
RT_INTERFACE!{interface IMediaSource(IMediaSourceVtbl, IMediaSource_Abi): IInspectable(IInspectableVtbl) [IID_IMediaSource] {
    
}}
RT_CLASS!{class MediaSource: IMediaSource2}
impl RtActivatable<IMediaSourceStatics> for MediaSource {}
impl RtActivatable<IMediaSourceStatics2> for MediaSource {}
impl RtActivatable<IMediaSourceStatics3> for MediaSource {}
impl RtActivatable<IMediaSourceStatics4> for MediaSource {}
impl MediaSource {
    #[inline] pub fn create_from_adaptive_media_source(mediaSource: &super::streaming::adaptive::AdaptiveMediaSource) -> Result<Option<MediaSource>> {
        <Self as RtActivatable<IMediaSourceStatics>>::get_activation_factory().create_from_adaptive_media_source(mediaSource)
    }
    #[inline] pub fn create_from_media_stream_source(mediaSource: &MediaStreamSource) -> Result<Option<MediaSource>> {
        <Self as RtActivatable<IMediaSourceStatics>>::get_activation_factory().create_from_media_stream_source(mediaSource)
    }
    #[inline] pub fn create_from_mse_stream_source(mediaSource: &MseStreamSource) -> Result<Option<MediaSource>> {
        <Self as RtActivatable<IMediaSourceStatics>>::get_activation_factory().create_from_mse_stream_source(mediaSource)
    }
    #[inline] pub fn create_from_imediasource(mediaSource: &IMediaSource) -> Result<Option<MediaSource>> {
        <Self as RtActivatable<IMediaSourceStatics>>::get_activation_factory().create_from_imediasource(mediaSource)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_storage_file(file: &super::super::storage::IStorageFile) -> Result<Option<MediaSource>> {
        <Self as RtActivatable<IMediaSourceStatics>>::get_activation_factory().create_from_storage_file(file)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_stream(stream: &super::super::storage::streams::IRandomAccessStream, contentType: &HStringArg) -> Result<Option<MediaSource>> {
        <Self as RtActivatable<IMediaSourceStatics>>::get_activation_factory().create_from_stream(stream, contentType)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_stream_reference(stream: &super::super::storage::streams::IRandomAccessStreamReference, contentType: &HStringArg) -> Result<Option<MediaSource>> {
        <Self as RtActivatable<IMediaSourceStatics>>::get_activation_factory().create_from_stream_reference(stream, contentType)
    }
    #[inline] pub fn create_from_uri(uri: &foundation::Uri) -> Result<Option<MediaSource>> {
        <Self as RtActivatable<IMediaSourceStatics>>::get_activation_factory().create_from_uri(uri)
    }
    #[inline] pub fn create_from_media_binder(binder: &MediaBinder) -> Result<Option<MediaSource>> {
        <Self as RtActivatable<IMediaSourceStatics2>>::get_activation_factory().create_from_media_binder(binder)
    }
    #[inline] pub fn create_from_media_frame_source(frameSource: &super::capture::frames::MediaFrameSource) -> Result<Option<MediaSource>> {
        <Self as RtActivatable<IMediaSourceStatics3>>::get_activation_factory().create_from_media_frame_source(frameSource)
    }
    #[cfg(feature="windows-networking")] #[inline] pub fn create_from_download_operation(downloadOperation: &super::super::networking::backgroundtransfer::DownloadOperation) -> Result<Option<MediaSource>> {
        <Self as RtActivatable<IMediaSourceStatics4>>::get_activation_factory().create_from_download_operation(downloadOperation)
    }
}
DEFINE_CLSID!(MediaSource(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,77,101,100,105,97,83,111,117,114,99,101,0]) [CLSID_MediaSource]);
DEFINE_IID!(IID_IMediaSource2, 783683656, 25951, 19511, 184, 19, 180, 228, 93, 250, 10, 190);
RT_INTERFACE!{interface IMediaSource2(IMediaSource2Vtbl, IMediaSource2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaSource2] {
    fn add_OpenOperationCompleted(&self, handler: <foundation::TypedEventHandler<MediaSource, MediaSourceOpenOperationCompletedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_OpenOperationCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_CustomProperties(&self, out: *mut <foundation::collections::ValueSet as RtType>::Abi) -> HRESULT,
    fn get_Duration(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_IsOpen(&self, out: *mut bool) -> HRESULT,
    fn get_ExternalTimedTextSources(&self, out: *mut <foundation::collections::IObservableVector<TimedTextSource> as RtType>::Abi) -> HRESULT,
    fn get_ExternalTimedMetadataTracks(&self, out: *mut <foundation::collections::IObservableVector<TimedMetadataTrack> as RtType>::Abi) -> HRESULT
}}
impl IMediaSource2 {
    #[inline] pub fn add_open_operation_completed(&self, handler: &foundation::TypedEventHandler<MediaSource, MediaSourceOpenOperationCompletedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_OpenOperationCompleted)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_open_operation_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_OpenOperationCompleted)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_custom_properties(&self) -> Result<Option<foundation::collections::ValueSet>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CustomProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::ValueSet::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_open(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsOpen)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_external_timed_text_sources(&self) -> Result<Option<foundation::collections::IObservableVector<TimedTextSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExternalTimedTextSources)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IObservableVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_external_timed_metadata_tracks(&self) -> Result<Option<foundation::collections::IObservableVector<TimedMetadataTrack>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExternalTimedMetadataTracks)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IObservableVector::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaSource3, 3047099803, 19310, 16877, 187, 180, 124, 117, 9, 169, 148, 173);
RT_INTERFACE!{interface IMediaSource3(IMediaSource3Vtbl, IMediaSource3_Abi): IInspectable(IInspectableVtbl) [IID_IMediaSource3] {
    fn add_StateChanged(&self, handler: <foundation::TypedEventHandler<MediaSource, MediaSourceStateChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_State(&self, out: *mut MediaSourceState) -> HRESULT,
    fn Reset(&self) -> HRESULT
}}
impl IMediaSource3 {
    #[inline] pub fn add_state_changed(&self, handler: &foundation::TypedEventHandler<MediaSource, MediaSourceStateChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_state(&self) -> Result<MediaSourceState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn reset(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Reset)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaSource4, 3182406999, 36607, 19555, 133, 166, 132, 222, 10, 227, 228, 242);
RT_INTERFACE!{interface IMediaSource4(IMediaSource4Vtbl, IMediaSource4_Abi): IInspectable(IInspectableVtbl) [IID_IMediaSource4] {
    fn get_AdaptiveMediaSource(&self, out: *mut <super::streaming::adaptive::AdaptiveMediaSource as RtType>::Abi) -> HRESULT,
    fn get_MediaStreamSource(&self, out: *mut <MediaStreamSource as RtType>::Abi) -> HRESULT,
    fn get_MseStreamSource(&self, out: *mut <MseStreamSource as RtType>::Abi) -> HRESULT,
    fn get_Uri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn OpenAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IMediaSource4 {
    #[inline] pub fn get_adaptive_media_source(&self) -> Result<Option<super::streaming::adaptive::AdaptiveMediaSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AdaptiveMediaSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::streaming::adaptive::AdaptiveMediaSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_media_stream_source(&self) -> Result<Option<MediaStreamSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaStreamSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaStreamSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_mse_stream_source(&self) -> Result<Option<MseStreamSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MseStreamSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MseStreamSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Uri)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn open_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).OpenAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaSource5, 857350830, 60718, 18978, 148, 200, 183, 67, 169, 43, 48, 34);
RT_INTERFACE!{interface IMediaSource5(IMediaSource5Vtbl, IMediaSource5_Abi): IInspectable(IInspectableVtbl) [IID_IMediaSource5] {
    #[cfg(feature="windows-networking")] fn get_DownloadOperation(&self, out: *mut <super::super::networking::backgroundtransfer::DownloadOperation as RtType>::Abi) -> HRESULT
}}
impl IMediaSource5 {
    #[cfg(feature="windows-networking")] #[inline] pub fn get_download_operation(&self) -> Result<Option<super::super::networking::backgroundtransfer::DownloadOperation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DownloadOperation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::networking::backgroundtransfer::DownloadOperation::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaSourceAppServiceConnection, 1642195607, 6422, 18448, 183, 244, 182, 66, 190, 130, 149, 150);
RT_INTERFACE!{interface IMediaSourceAppServiceConnection(IMediaSourceAppServiceConnectionVtbl, IMediaSourceAppServiceConnection_Abi): IInspectable(IInspectableVtbl) [IID_IMediaSourceAppServiceConnection] {
    fn add_InitializeMediaStreamSourceRequested(&self, handler: <foundation::TypedEventHandler<MediaSourceAppServiceConnection, InitializeMediaStreamSourceRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_InitializeMediaStreamSourceRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn Start(&self) -> HRESULT
}}
impl IMediaSourceAppServiceConnection {
    #[inline] pub fn add_initialize_media_stream_source_requested(&self, handler: &foundation::TypedEventHandler<MediaSourceAppServiceConnection, InitializeMediaStreamSourceRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_InitializeMediaStreamSourceRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_initialize_media_stream_source_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_InitializeMediaStreamSourceRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaSourceAppServiceConnection: IMediaSourceAppServiceConnection}
impl RtActivatable<IMediaSourceAppServiceConnectionFactory> for MediaSourceAppServiceConnection {}
impl MediaSourceAppServiceConnection {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub fn create(appServiceConnection: &super::super::applicationmodel::appservice::AppServiceConnection) -> Result<MediaSourceAppServiceConnection> {
        <Self as RtActivatable<IMediaSourceAppServiceConnectionFactory>>::get_activation_factory().create(appServiceConnection)
    }
}
DEFINE_CLSID!(MediaSourceAppServiceConnection(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,77,101,100,105,97,83,111,117,114,99,101,65,112,112,83,101,114,118,105,99,101,67,111,110,110,101,99,116,105,111,110,0]) [CLSID_MediaSourceAppServiceConnection]);
DEFINE_IID!(IID_IMediaSourceAppServiceConnectionFactory, 1706627819, 32953, 17657, 156, 30, 225, 32, 246, 217, 40, 56);
RT_INTERFACE!{static interface IMediaSourceAppServiceConnectionFactory(IMediaSourceAppServiceConnectionFactoryVtbl, IMediaSourceAppServiceConnectionFactory_Abi): IInspectable(IInspectableVtbl) [IID_IMediaSourceAppServiceConnectionFactory] {
    #[cfg(feature="windows-applicationmodel")] fn Create(&self, appServiceConnection: <super::super::applicationmodel::appservice::AppServiceConnection as RtType>::Abi, out: *mut <MediaSourceAppServiceConnection as RtType>::Abi) -> HRESULT
}}
impl IMediaSourceAppServiceConnectionFactory {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub fn create(&self, appServiceConnection: &super::super::applicationmodel::appservice::AppServiceConnection) -> Result<MediaSourceAppServiceConnection> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(appServiceConnection) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaSourceAppServiceConnection::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaSourceError, 1544194405, 14277, 20125, 141, 33, 28, 222, 233, 12, 236, 198);
RT_INTERFACE!{interface IMediaSourceError(IMediaSourceErrorVtbl, IMediaSourceError_Abi): IInspectable(IInspectableVtbl) [IID_IMediaSourceError] {
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl IMediaSourceError {
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaSourceError: IMediaSourceError}
DEFINE_IID!(IID_IMediaSourceOpenOperationCompletedEventArgs, 4234685675, 57985, 18300, 168, 224, 26, 205, 101, 65, 20, 200);
RT_INTERFACE!{interface IMediaSourceOpenOperationCompletedEventArgs(IMediaSourceOpenOperationCompletedEventArgsVtbl, IMediaSourceOpenOperationCompletedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaSourceOpenOperationCompletedEventArgs] {
    fn get_Error(&self, out: *mut <MediaSourceError as RtType>::Abi) -> HRESULT
}}
impl IMediaSourceOpenOperationCompletedEventArgs {
    #[inline] pub fn get_error(&self) -> Result<Option<MediaSourceError>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Error)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaSourceError::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaSourceOpenOperationCompletedEventArgs: IMediaSourceOpenOperationCompletedEventArgs}
RT_ENUM! { enum MediaSourceState: i32 {
    Initial = 0, Opening = 1, Opened = 2, Failed = 3, Closed = 4,
}}
DEFINE_IID!(IID_IMediaSourceStateChangedEventArgs, 170962818, 36977, 19372, 188, 57, 202, 42, 147, 183, 23, 169);
RT_INTERFACE!{interface IMediaSourceStateChangedEventArgs(IMediaSourceStateChangedEventArgsVtbl, IMediaSourceStateChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaSourceStateChangedEventArgs] {
    fn get_OldState(&self, out: *mut MediaSourceState) -> HRESULT,
    fn get_NewState(&self, out: *mut MediaSourceState) -> HRESULT
}}
impl IMediaSourceStateChangedEventArgs {
    #[inline] pub fn get_old_state(&self) -> Result<MediaSourceState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OldState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_new_state(&self) -> Result<MediaSourceState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_NewState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaSourceStateChangedEventArgs: IMediaSourceStateChangedEventArgs}
DEFINE_IID!(IID_IMediaSourceStatics, 4152192932, 18002, 16654, 177, 216, 233, 165, 226, 69, 164, 92);
RT_INTERFACE!{static interface IMediaSourceStatics(IMediaSourceStaticsVtbl, IMediaSourceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IMediaSourceStatics] {
    fn CreateFromAdaptiveMediaSource(&self, mediaSource: <super::streaming::adaptive::AdaptiveMediaSource as RtType>::Abi, out: *mut <MediaSource as RtType>::Abi) -> HRESULT,
    fn CreateFromMediaStreamSource(&self, mediaSource: <MediaStreamSource as RtType>::Abi, out: *mut <MediaSource as RtType>::Abi) -> HRESULT,
    fn CreateFromMseStreamSource(&self, mediaSource: <MseStreamSource as RtType>::Abi, out: *mut <MediaSource as RtType>::Abi) -> HRESULT,
    fn CreateFromIMediaSource(&self, mediaSource: <IMediaSource as RtType>::Abi, out: *mut <MediaSource as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-storage")] fn CreateFromStorageFile(&self, file: <super::super::storage::IStorageFile as RtType>::Abi, out: *mut <MediaSource as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn CreateFromStream(&self, stream: <super::super::storage::streams::IRandomAccessStream as RtType>::Abi, contentType: HSTRING, out: *mut <MediaSource as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-storage")] fn CreateFromStreamReference(&self, stream: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi, contentType: HSTRING, out: *mut <MediaSource as RtType>::Abi) -> HRESULT,
    fn CreateFromUri(&self, uri: <foundation::Uri as RtType>::Abi, out: *mut <MediaSource as RtType>::Abi) -> HRESULT
}}
impl IMediaSourceStatics {
    #[inline] pub fn create_from_adaptive_media_source(&self, mediaSource: &super::streaming::adaptive::AdaptiveMediaSource) -> Result<Option<MediaSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromAdaptiveMediaSource)(self.0.as_abi() as *const _ as *mut _, get_abi(mediaSource) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_media_stream_source(&self, mediaSource: &MediaStreamSource) -> Result<Option<MediaSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromMediaStreamSource)(self.0.as_abi() as *const _ as *mut _, get_abi(mediaSource) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_mse_stream_source(&self, mediaSource: &MseStreamSource) -> Result<Option<MediaSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromMseStreamSource)(self.0.as_abi() as *const _ as *mut _, get_abi(mediaSource) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_imediasource(&self, mediaSource: &IMediaSource) -> Result<Option<MediaSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromIMediaSource)(self.0.as_abi() as *const _ as *mut _, get_abi(mediaSource) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaSource::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_storage_file(&self, file: &super::super::storage::IStorageFile) -> Result<Option<MediaSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromStorageFile)(self.0.as_abi() as *const _ as *mut _, get_abi(file) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaSource::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_stream(&self, stream: &super::super::storage::streams::IRandomAccessStream, contentType: &HStringArg) -> Result<Option<MediaSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromStream)(self.0.as_abi() as *const _ as *mut _, get_abi(stream) as *const _ as *mut _, contentType.get(), &mut out);
        if hr == S_OK { Ok(MediaSource::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_stream_reference(&self, stream: &super::super::storage::streams::IRandomAccessStreamReference, contentType: &HStringArg) -> Result<Option<MediaSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromStreamReference)(self.0.as_abi() as *const _ as *mut _, get_abi(stream) as *const _ as *mut _, contentType.get(), &mut out);
        if hr == S_OK { Ok(MediaSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_uri(&self, uri: &foundation::Uri) -> Result<Option<MediaSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromUri)(self.0.as_abi() as *const _ as *mut _, get_abi(uri) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaSource::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaSourceStatics2, 4007748004, 32531, 18582, 184, 203, 223, 13, 229, 188, 185, 241);
RT_INTERFACE!{static interface IMediaSourceStatics2(IMediaSourceStatics2Vtbl, IMediaSourceStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaSourceStatics2] {
    fn CreateFromMediaBinder(&self, binder: <MediaBinder as RtType>::Abi, out: *mut <MediaSource as RtType>::Abi) -> HRESULT
}}
impl IMediaSourceStatics2 {
    #[inline] pub fn create_from_media_binder(&self, binder: &MediaBinder) -> Result<Option<MediaSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromMediaBinder)(self.0.as_abi() as *const _ as *mut _, get_abi(binder) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaSource::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaSourceStatics3, 1161441494, 11242, 16674, 159, 115, 234, 206, 4, 82, 110, 53);
RT_INTERFACE!{static interface IMediaSourceStatics3(IMediaSourceStatics3Vtbl, IMediaSourceStatics3_Abi): IInspectable(IInspectableVtbl) [IID_IMediaSourceStatics3] {
    fn CreateFromMediaFrameSource(&self, frameSource: <super::capture::frames::MediaFrameSource as RtType>::Abi, out: *mut <MediaSource as RtType>::Abi) -> HRESULT
}}
impl IMediaSourceStatics3 {
    #[inline] pub fn create_from_media_frame_source(&self, frameSource: &super::capture::frames::MediaFrameSource) -> Result<Option<MediaSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromMediaFrameSource)(self.0.as_abi() as *const _ as *mut _, get_abi(frameSource) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaSource::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaSourceStatics4, 672873468, 58634, 17448, 165, 0, 156, 78, 217, 24, 211, 240);
RT_INTERFACE!{static interface IMediaSourceStatics4(IMediaSourceStatics4Vtbl, IMediaSourceStatics4_Abi): IInspectable(IInspectableVtbl) [IID_IMediaSourceStatics4] {
    #[cfg(feature="windows-networking")] fn CreateFromDownloadOperation(&self, downloadOperation: <super::super::networking::backgroundtransfer::DownloadOperation as RtType>::Abi, out: *mut <MediaSource as RtType>::Abi) -> HRESULT
}}
impl IMediaSourceStatics4 {
    #[cfg(feature="windows-networking")] #[inline] pub fn create_from_download_operation(&self, downloadOperation: &super::super::networking::backgroundtransfer::DownloadOperation) -> Result<Option<MediaSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromDownloadOperation)(self.0.as_abi() as *const _ as *mut _, get_abi(downloadOperation) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaSource::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum MediaSourceStatus: i32 {
    FullySupported = 0, Unknown = 1,
}}
DEFINE_IID!(IID_IMediaStreamDescriptor, 2163306094, 37623, 17694, 151, 210, 175, 216, 7, 66, 218, 112);
RT_INTERFACE!{interface IMediaStreamDescriptor(IMediaStreamDescriptorVtbl, IMediaStreamDescriptor_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamDescriptor] {
    fn get_IsSelected(&self, out: *mut bool) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Language(&self, value: HSTRING) -> HRESULT,
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMediaStreamDescriptor {
    #[inline] pub fn get_is_selected(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsSelected)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Name)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Name)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_language(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Language)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_language(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Language)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaStreamDescriptor2, 1349714191, 59570, 16497, 176, 11, 235, 243, 55, 167, 107, 88);
RT_INTERFACE!{interface IMediaStreamDescriptor2(IMediaStreamDescriptor2Vtbl, IMediaStreamDescriptor2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamDescriptor2] {
    fn put_Label(&self, value: HSTRING) -> HRESULT,
    fn get_Label(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMediaStreamDescriptor2 {
    #[inline] pub fn set_label(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Label)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_label(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Label)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaStreamSample, 1552791079, 19328, 17249, 152, 55, 108, 183, 72, 26, 217, 214);
RT_INTERFACE!{interface IMediaStreamSample(IMediaStreamSampleVtbl, IMediaStreamSample_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamSample] {
    fn add_Processed(&self, handler: <foundation::TypedEventHandler<MediaStreamSample, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Processed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Buffer(&self, out: *mut <super::super::storage::streams::Buffer as RtType>::Abi) -> HRESULT,
    fn get_Timestamp(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_ExtendedProperties(&self, out: *mut <MediaStreamSamplePropertySet as RtType>::Abi) -> HRESULT,
    fn get_Protection(&self, out: *mut <MediaStreamSampleProtectionProperties as RtType>::Abi) -> HRESULT,
    fn put_DecodeTimestamp(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_DecodeTimestamp(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_Duration(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_KeyFrame(&self, value: bool) -> HRESULT,
    fn get_KeyFrame(&self, out: *mut bool) -> HRESULT,
    fn put_Discontinuous(&self, value: bool) -> HRESULT,
    fn get_Discontinuous(&self, out: *mut bool) -> HRESULT
}}
impl IMediaStreamSample {
    #[inline] pub fn add_processed(&self, handler: &foundation::TypedEventHandler<MediaStreamSample, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Processed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_processed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Processed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_buffer(&self) -> Result<Option<super::super::storage::streams::Buffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Buffer)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::Buffer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_properties(&self) -> Result<Option<MediaStreamSamplePropertySet>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaStreamSamplePropertySet::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_protection(&self) -> Result<Option<MediaStreamSampleProtectionProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Protection)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaStreamSampleProtectionProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_decode_timestamp(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DecodeTimestamp)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_decode_timestamp(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DecodeTimestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_duration(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Duration)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_key_frame(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_KeyFrame)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_key_frame(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_KeyFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_discontinuous(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Discontinuous)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_discontinuous(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Discontinuous)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaStreamSample: IMediaStreamSample}
impl RtActivatable<IMediaStreamSampleStatics> for MediaStreamSample {}
impl RtActivatable<IMediaStreamSampleStatics2> for MediaStreamSample {}
impl MediaStreamSample {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_buffer(buffer: &super::super::storage::streams::IBuffer, timestamp: foundation::TimeSpan) -> Result<Option<MediaStreamSample>> {
        <Self as RtActivatable<IMediaStreamSampleStatics>>::get_activation_factory().create_from_buffer(buffer, timestamp)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_stream_async(stream: &super::super::storage::streams::IInputStream, count: u32, timestamp: foundation::TimeSpan) -> Result<foundation::IAsyncOperation<MediaStreamSample>> {
        <Self as RtActivatable<IMediaStreamSampleStatics>>::get_activation_factory().create_from_stream_async(stream, count, timestamp)
    }
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_from_direct3d11_surface(surface: &super::super::graphics::directx::direct3d11::IDirect3DSurface, timestamp: foundation::TimeSpan) -> Result<Option<MediaStreamSample>> {
        <Self as RtActivatable<IMediaStreamSampleStatics2>>::get_activation_factory().create_from_direct3d11_surface(surface, timestamp)
    }
}
DEFINE_CLSID!(MediaStreamSample(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,77,101,100,105,97,83,116,114,101,97,109,83,97,109,112,108,101,0]) [CLSID_MediaStreamSample]);
DEFINE_IID!(IID_IMediaStreamSample2, 1158121105, 64744, 18246, 161, 200, 16, 194, 93, 61, 124, 211);
RT_INTERFACE!{interface IMediaStreamSample2(IMediaStreamSample2Vtbl, IMediaStreamSample2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamSample2] {
    #[cfg(feature="windows-graphics")] fn get_Direct3D11Surface(&self, out: *mut <super::super::graphics::directx::direct3d11::IDirect3DSurface as RtType>::Abi) -> HRESULT
}}
impl IMediaStreamSample2 {
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_direct3d11_surface(&self) -> Result<Option<super::super::graphics::directx::direct3d11::IDirect3DSurface>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Direct3D11Surface)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::graphics::directx::direct3d11::IDirect3DSurface::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaStreamSamplePropertySet: foundation::collections::IMap<Guid, IInspectable>}
DEFINE_IID!(IID_IMediaStreamSampleProtectionProperties, 1320714898, 60639, 18750, 132, 29, 221, 74, 221, 124, 172, 162);
RT_INTERFACE!{interface IMediaStreamSampleProtectionProperties(IMediaStreamSampleProtectionPropertiesVtbl, IMediaStreamSampleProtectionProperties_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamSampleProtectionProperties] {
    fn SetKeyIdentifier(&self, valueSize: u32, value: *mut u8) -> HRESULT,
    fn GetKeyIdentifier(&self, valueSize: *mut u32, value: *mut *mut u8) -> HRESULT,
    fn SetInitializationVector(&self, valueSize: u32, value: *mut u8) -> HRESULT,
    fn GetInitializationVector(&self, valueSize: *mut u32, value: *mut *mut u8) -> HRESULT,
    fn SetSubSampleMapping(&self, valueSize: u32, value: *mut u8) -> HRESULT,
    fn GetSubSampleMapping(&self, valueSize: *mut u32, value: *mut *mut u8) -> HRESULT
}}
impl IMediaStreamSampleProtectionProperties {
    #[inline] pub fn set_key_identifier(&self, value: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetKeyIdentifier)(self.0.as_abi() as *const _ as *mut _, value.len() as u32, value.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_key_identifier(&self) -> Result<ComArray<u8>> { unsafe { 
        let mut valueSize = 0; let mut value = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetKeyIdentifier)(self.0.as_abi() as *const _ as *mut _, &mut valueSize, &mut value);
        if hr == S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { err(hr) }
    }}
    #[inline] pub fn set_initialization_vector(&self, value: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetInitializationVector)(self.0.as_abi() as *const _ as *mut _, value.len() as u32, value.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_initialization_vector(&self) -> Result<ComArray<u8>> { unsafe { 
        let mut valueSize = 0; let mut value = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetInitializationVector)(self.0.as_abi() as *const _ as *mut _, &mut valueSize, &mut value);
        if hr == S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { err(hr) }
    }}
    #[inline] pub fn set_sub_sample_mapping(&self, value: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetSubSampleMapping)(self.0.as_abi() as *const _ as *mut _, value.len() as u32, value.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sub_sample_mapping(&self) -> Result<ComArray<u8>> { unsafe { 
        let mut valueSize = 0; let mut value = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetSubSampleMapping)(self.0.as_abi() as *const _ as *mut _, &mut valueSize, &mut value);
        if hr == S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaStreamSampleProtectionProperties: IMediaStreamSampleProtectionProperties}
DEFINE_IID!(IID_IMediaStreamSampleStatics, 3755942287, 42703, 17785, 190, 65, 115, 221, 148, 26, 217, 114);
RT_INTERFACE!{static interface IMediaStreamSampleStatics(IMediaStreamSampleStaticsVtbl, IMediaStreamSampleStatics_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamSampleStatics] {
    #[cfg(feature="windows-storage")] fn CreateFromBuffer(&self, buffer: <super::super::storage::streams::IBuffer as RtType>::Abi, timestamp: foundation::TimeSpan, out: *mut <MediaStreamSample as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn CreateFromStreamAsync(&self, stream: <super::super::storage::streams::IInputStream as RtType>::Abi, count: u32, timestamp: foundation::TimeSpan, out: *mut <foundation::IAsyncOperation<MediaStreamSample> as RtType>::Abi) -> HRESULT
}}
impl IMediaStreamSampleStatics {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_buffer(&self, buffer: &super::super::storage::streams::IBuffer, timestamp: foundation::TimeSpan) -> Result<Option<MediaStreamSample>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromBuffer)(self.0.as_abi() as *const _ as *mut _, get_abi(buffer) as *const _ as *mut _, timestamp, &mut out);
        if hr == S_OK { Ok(MediaStreamSample::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_stream_async(&self, stream: &super::super::storage::streams::IInputStream, count: u32, timestamp: foundation::TimeSpan) -> Result<foundation::IAsyncOperation<MediaStreamSample>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromStreamAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(stream) as *const _ as *mut _, count, timestamp, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaStreamSampleStatics2, 2667484449, 27974, 18764, 162, 248, 214, 98, 146, 46, 45, 215);
RT_INTERFACE!{static interface IMediaStreamSampleStatics2(IMediaStreamSampleStatics2Vtbl, IMediaStreamSampleStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamSampleStatics2] {
    #[cfg(feature="windows-graphics")] fn CreateFromDirect3D11Surface(&self, surface: <super::super::graphics::directx::direct3d11::IDirect3DSurface as RtType>::Abi, timestamp: foundation::TimeSpan, out: *mut <MediaStreamSample as RtType>::Abi) -> HRESULT
}}
impl IMediaStreamSampleStatics2 {
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_from_direct3d11_surface(&self, surface: &super::super::graphics::directx::direct3d11::IDirect3DSurface, timestamp: foundation::TimeSpan) -> Result<Option<MediaStreamSample>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromDirect3D11Surface)(self.0.as_abi() as *const _ as *mut _, get_abi(surface) as *const _ as *mut _, timestamp, &mut out);
        if hr == S_OK { Ok(MediaStreamSample::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaStreamSource, 923981123, 17899, 16696, 170, 98, 192, 30, 38, 243, 132, 63);
RT_INTERFACE!{interface IMediaStreamSource(IMediaStreamSourceVtbl, IMediaStreamSource_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamSource] {
    fn add_Closed(&self, handler: <foundation::TypedEventHandler<MediaStreamSource, MediaStreamSourceClosedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Starting(&self, handler: <foundation::TypedEventHandler<MediaStreamSource, MediaStreamSourceStartingEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Starting(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Paused(&self, handler: <foundation::TypedEventHandler<MediaStreamSource, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Paused(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SampleRequested(&self, handler: <foundation::TypedEventHandler<MediaStreamSource, MediaStreamSourceSampleRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SampleRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SwitchStreamsRequested(&self, handler: <foundation::TypedEventHandler<MediaStreamSource, MediaStreamSourceSwitchStreamsRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SwitchStreamsRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn NotifyError(&self, errorStatus: MediaStreamSourceErrorStatus) -> HRESULT,
    fn AddStreamDescriptor(&self, descriptor: <IMediaStreamDescriptor as RtType>::Abi) -> HRESULT,
    fn put_MediaProtectionManager(&self, value: <super::protection::MediaProtectionManager as RtType>::Abi) -> HRESULT,
    fn get_MediaProtectionManager(&self, out: *mut <super::protection::MediaProtectionManager as RtType>::Abi) -> HRESULT,
    fn put_Duration(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_CanSeek(&self, value: bool) -> HRESULT,
    fn get_CanSeek(&self, out: *mut bool) -> HRESULT,
    fn put_BufferTime(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_BufferTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn SetBufferedRange(&self, startOffset: foundation::TimeSpan, endOffset: foundation::TimeSpan) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy21(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_MusicProperties(&self, out: *mut <super::super::storage::fileproperties::MusicProperties as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy22(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_VideoProperties(&self, out: *mut <super::super::storage::fileproperties::VideoProperties as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy23(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Thumbnail(&self, value: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy24(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Thumbnail(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    fn AddProtectionKey(&self, streamDescriptor: <IMediaStreamDescriptor as RtType>::Abi, keyIdentifierSize: u32, keyIdentifier: *mut u8, licenseDataSize: u32, licenseData: *mut u8) -> HRESULT
}}
impl IMediaStreamSource {
    #[inline] pub fn add_closed(&self, handler: &foundation::TypedEventHandler<MediaStreamSource, MediaStreamSourceClosedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Closed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_closed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Closed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_starting(&self, handler: &foundation::TypedEventHandler<MediaStreamSource, MediaStreamSourceStartingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Starting)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_starting(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Starting)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_paused(&self, handler: &foundation::TypedEventHandler<MediaStreamSource, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Paused)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_paused(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Paused)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_sample_requested(&self, handler: &foundation::TypedEventHandler<MediaStreamSource, MediaStreamSourceSampleRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SampleRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_sample_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SampleRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_switch_streams_requested(&self, handler: &foundation::TypedEventHandler<MediaStreamSource, MediaStreamSourceSwitchStreamsRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SwitchStreamsRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_switch_streams_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SwitchStreamsRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_error(&self, errorStatus: MediaStreamSourceErrorStatus) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).NotifyError)(self.0.as_abi() as *const _ as *mut _, errorStatus);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stream_descriptor(&self, descriptor: &IMediaStreamDescriptor) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AddStreamDescriptor)(self.0.as_abi() as *const _ as *mut _, get_abi(descriptor) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_media_protection_manager(&self, value: &super::protection::MediaProtectionManager) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MediaProtectionManager)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_media_protection_manager(&self) -> Result<Option<super::protection::MediaProtectionManager>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaProtectionManager)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::protection::MediaProtectionManager::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_duration(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Duration)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_can_seek(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CanSeek)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_can_seek(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanSeek)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_buffer_time(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BufferTime)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_buffer_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BufferTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_buffered_range(&self, startOffset: foundation::TimeSpan, endOffset: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetBufferedRange)(self.0.as_abi() as *const _ as *mut _, startOffset, endOffset);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_music_properties(&self) -> Result<Option<super::super::storage::fileproperties::MusicProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MusicProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::fileproperties::MusicProperties::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_video_properties(&self) -> Result<Option<super::super::storage::fileproperties::VideoProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::fileproperties::VideoProperties::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_thumbnail(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Thumbnail)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_thumbnail(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Thumbnail)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_protection_key(&self, streamDescriptor: &IMediaStreamDescriptor, keyIdentifier: &[u8], licenseData: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AddProtectionKey)(self.0.as_abi() as *const _ as *mut _, get_abi(streamDescriptor) as *const _ as *mut _, keyIdentifier.len() as u32, keyIdentifier.as_ptr() as *mut _, licenseData.len() as u32, licenseData.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaStreamSource: IMediaStreamSource}
impl RtActivatable<IMediaStreamSourceFactory> for MediaStreamSource {}
impl MediaStreamSource {
    #[inline] pub fn create_from_descriptor(descriptor: &IMediaStreamDescriptor) -> Result<MediaStreamSource> {
        <Self as RtActivatable<IMediaStreamSourceFactory>>::get_activation_factory().create_from_descriptor(descriptor)
    }
    #[inline] pub fn create_from_descriptors(descriptor: &IMediaStreamDescriptor, descriptor2: &IMediaStreamDescriptor) -> Result<MediaStreamSource> {
        <Self as RtActivatable<IMediaStreamSourceFactory>>::get_activation_factory().create_from_descriptors(descriptor, descriptor2)
    }
}
DEFINE_CLSID!(MediaStreamSource(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,77,101,100,105,97,83,116,114,101,97,109,83,111,117,114,99,101,0]) [CLSID_MediaStreamSource]);
DEFINE_IID!(IID_IMediaStreamSource2, 3965046957, 11882, 20340, 173, 187, 181, 98, 209, 83, 56, 73);
RT_INTERFACE!{interface IMediaStreamSource2(IMediaStreamSource2Vtbl, IMediaStreamSource2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamSource2] {
    fn add_SampleRendered(&self, handler: <foundation::TypedEventHandler<MediaStreamSource, MediaStreamSourceSampleRenderedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SampleRendered(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IMediaStreamSource2 {
    #[inline] pub fn add_sample_rendered(&self, handler: &foundation::TypedEventHandler<MediaStreamSource, MediaStreamSourceSampleRenderedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SampleRendered)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_sample_rendered(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SampleRendered)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaStreamSource3, 1781147462, 15837, 19935, 161, 33, 148, 4, 94, 207, 148, 64);
RT_INTERFACE!{interface IMediaStreamSource3(IMediaStreamSource3Vtbl, IMediaStreamSource3_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamSource3] {
    fn put_MaxSupportedPlaybackRate(&self, value: <foundation::IReference<f64> as RtType>::Abi) -> HRESULT,
    fn get_MaxSupportedPlaybackRate(&self, out: *mut <foundation::IReference<f64> as RtType>::Abi) -> HRESULT
}}
impl IMediaStreamSource3 {
    #[inline] pub fn set_max_supported_playback_rate(&self, value: &foundation::IReference<f64>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MaxSupportedPlaybackRate)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_supported_playback_rate(&self) -> Result<Option<foundation::IReference<f64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxSupportedPlaybackRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaStreamSource4, 487390379, 33549, 16764, 163, 169, 36, 84, 253, 100, 21, 199);
RT_INTERFACE!{interface IMediaStreamSource4(IMediaStreamSource4Vtbl, IMediaStreamSource4_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamSource4] {
    fn put_IsLive(&self, value: bool) -> HRESULT,
    fn get_IsLive(&self, out: *mut bool) -> HRESULT
}}
impl IMediaStreamSource4 {
    #[inline] pub fn set_is_live(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsLive)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_live(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsLive)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaStreamSourceClosedEventArgs, 3448536754, 18454, 20004, 136, 240, 73, 30, 247, 56, 100, 6);
RT_INTERFACE!{interface IMediaStreamSourceClosedEventArgs(IMediaStreamSourceClosedEventArgsVtbl, IMediaStreamSourceClosedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamSourceClosedEventArgs] {
    fn get_Request(&self, out: *mut <MediaStreamSourceClosedRequest as RtType>::Abi) -> HRESULT
}}
impl IMediaStreamSourceClosedEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<MediaStreamSourceClosedRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Request)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaStreamSourceClosedRequest::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaStreamSourceClosedEventArgs: IMediaStreamSourceClosedEventArgs}
RT_ENUM! { enum MediaStreamSourceClosedReason: i32 {
    Done = 0, UnknownError = 1, AppReportedError = 2, UnsupportedProtectionSystem = 3, ProtectionSystemFailure = 4, UnsupportedEncodingFormat = 5, MissingSampleRequestedEventHandler = 6,
}}
DEFINE_IID!(IID_IMediaStreamSourceClosedRequest, 2424045801, 6307, 18769, 136, 122, 44, 30, 235, 213, 198, 158);
RT_INTERFACE!{interface IMediaStreamSourceClosedRequest(IMediaStreamSourceClosedRequestVtbl, IMediaStreamSourceClosedRequest_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamSourceClosedRequest] {
    fn get_Reason(&self, out: *mut MediaStreamSourceClosedReason) -> HRESULT
}}
impl IMediaStreamSourceClosedRequest {
    #[inline] pub fn get_reason(&self) -> Result<MediaStreamSourceClosedReason> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reason)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaStreamSourceClosedRequest: IMediaStreamSourceClosedRequest}
RT_ENUM! { enum MediaStreamSourceErrorStatus: i32 {
    Other = 0, OutOfMemory = 1, FailedToOpenFile = 2, FailedToConnectToServer = 3, ConnectionToServerLost = 4, UnspecifiedNetworkError = 5, DecodeError = 6, UnsupportedMediaFormat = 7,
}}
DEFINE_IID!(IID_IMediaStreamSourceFactory, 4017610969, 53592, 19322, 134, 63, 32, 51, 66, 251, 253, 65);
RT_INTERFACE!{static interface IMediaStreamSourceFactory(IMediaStreamSourceFactoryVtbl, IMediaStreamSourceFactory_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamSourceFactory] {
    fn CreateFromDescriptor(&self, descriptor: <IMediaStreamDescriptor as RtType>::Abi, out: *mut <MediaStreamSource as RtType>::Abi) -> HRESULT,
    fn CreateFromDescriptors(&self, descriptor: <IMediaStreamDescriptor as RtType>::Abi, descriptor2: <IMediaStreamDescriptor as RtType>::Abi, out: *mut <MediaStreamSource as RtType>::Abi) -> HRESULT
}}
impl IMediaStreamSourceFactory {
    #[inline] pub fn create_from_descriptor(&self, descriptor: &IMediaStreamDescriptor) -> Result<MediaStreamSource> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromDescriptor)(self.0.as_abi() as *const _ as *mut _, get_abi(descriptor) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaStreamSource::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_descriptors(&self, descriptor: &IMediaStreamDescriptor, descriptor2: &IMediaStreamDescriptor) -> Result<MediaStreamSource> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromDescriptors)(self.0.as_abi() as *const _ as *mut _, get_abi(descriptor) as *const _ as *mut _, get_abi(descriptor2) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaStreamSource::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaStreamSourceSampleRenderedEventArgs, 2640935685, 54514, 19578, 157, 254, 141, 108, 208, 179, 238, 132);
RT_INTERFACE!{interface IMediaStreamSourceSampleRenderedEventArgs(IMediaStreamSourceSampleRenderedEventArgsVtbl, IMediaStreamSourceSampleRenderedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamSourceSampleRenderedEventArgs] {
    fn get_SampleLag(&self, out: *mut foundation::TimeSpan) -> HRESULT
}}
impl IMediaStreamSourceSampleRenderedEventArgs {
    #[inline] pub fn get_sample_lag(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SampleLag)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaStreamSourceSampleRenderedEventArgs: IMediaStreamSourceSampleRenderedEventArgs}
DEFINE_IID!(IID_IMediaStreamSourceSampleRequest, 1303593385, 13569, 19867, 131, 249, 143, 35, 92, 130, 37, 50);
RT_INTERFACE!{interface IMediaStreamSourceSampleRequest(IMediaStreamSourceSampleRequestVtbl, IMediaStreamSourceSampleRequest_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamSourceSampleRequest] {
    fn get_StreamDescriptor(&self, out: *mut <IMediaStreamDescriptor as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <MediaStreamSourceSampleRequestDeferral as RtType>::Abi) -> HRESULT,
    fn put_Sample(&self, value: <MediaStreamSample as RtType>::Abi) -> HRESULT,
    fn get_Sample(&self, out: *mut <MediaStreamSample as RtType>::Abi) -> HRESULT,
    fn ReportSampleProgress(&self, progress: u32) -> HRESULT
}}
impl IMediaStreamSourceSampleRequest {
    #[inline] pub fn get_stream_descriptor(&self) -> Result<Option<IMediaStreamDescriptor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_StreamDescriptor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IMediaStreamDescriptor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<MediaStreamSourceSampleRequestDeferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaStreamSourceSampleRequestDeferral::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_sample(&self, value: &MediaStreamSample) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Sample)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sample(&self) -> Result<Option<MediaStreamSample>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Sample)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaStreamSample::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_sample_progress(&self, progress: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ReportSampleProgress)(self.0.as_abi() as *const _ as *mut _, progress);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaStreamSourceSampleRequest: IMediaStreamSourceSampleRequest}
DEFINE_IID!(IID_IMediaStreamSourceSampleRequestDeferral, 2023083010, 63874, 17352, 157, 22, 198, 45, 153, 147, 25, 190);
RT_INTERFACE!{interface IMediaStreamSourceSampleRequestDeferral(IMediaStreamSourceSampleRequestDeferralVtbl, IMediaStreamSourceSampleRequestDeferral_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamSourceSampleRequestDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IMediaStreamSourceSampleRequestDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Complete)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaStreamSourceSampleRequestDeferral: IMediaStreamSourceSampleRequestDeferral}
DEFINE_IID!(IID_IMediaStreamSourceSampleRequestedEventArgs, 284801950, 29125, 18735, 132, 127, 13, 161, 243, 94, 129, 248);
RT_INTERFACE!{interface IMediaStreamSourceSampleRequestedEventArgs(IMediaStreamSourceSampleRequestedEventArgsVtbl, IMediaStreamSourceSampleRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamSourceSampleRequestedEventArgs] {
    fn get_Request(&self, out: *mut <MediaStreamSourceSampleRequest as RtType>::Abi) -> HRESULT
}}
impl IMediaStreamSourceSampleRequestedEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<MediaStreamSourceSampleRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Request)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaStreamSourceSampleRequest::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaStreamSourceSampleRequestedEventArgs: IMediaStreamSourceSampleRequestedEventArgs}
DEFINE_IID!(IID_IMediaStreamSourceStartingEventArgs, 4094978290, 49780, 18752, 165, 187, 40, 165, 114, 69, 47, 167);
RT_INTERFACE!{interface IMediaStreamSourceStartingEventArgs(IMediaStreamSourceStartingEventArgsVtbl, IMediaStreamSourceStartingEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamSourceStartingEventArgs] {
    fn get_Request(&self, out: *mut <MediaStreamSourceStartingRequest as RtType>::Abi) -> HRESULT
}}
impl IMediaStreamSourceStartingEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<MediaStreamSourceStartingRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Request)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaStreamSourceStartingRequest::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaStreamSourceStartingEventArgs: IMediaStreamSourceStartingEventArgs}
DEFINE_IID!(IID_IMediaStreamSourceStartingRequest, 714118116, 13764, 19227, 167, 145, 13, 153, 219, 86, 221, 29);
RT_INTERFACE!{interface IMediaStreamSourceStartingRequest(IMediaStreamSourceStartingRequestVtbl, IMediaStreamSourceStartingRequest_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamSourceStartingRequest] {
    fn get_StartPosition(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <MediaStreamSourceStartingRequestDeferral as RtType>::Abi) -> HRESULT,
    fn SetActualStartPosition(&self, position: foundation::TimeSpan) -> HRESULT
}}
impl IMediaStreamSourceStartingRequest {
    #[inline] pub fn get_start_position(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_StartPosition)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<MediaStreamSourceStartingRequestDeferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaStreamSourceStartingRequestDeferral::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_actual_start_position(&self, position: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetActualStartPosition)(self.0.as_abi() as *const _ as *mut _, position);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaStreamSourceStartingRequest: IMediaStreamSourceStartingRequest}
DEFINE_IID!(IID_IMediaStreamSourceStartingRequestDeferral, 1058231973, 25408, 19908, 153, 16, 6, 142, 217, 245, 152, 248);
RT_INTERFACE!{interface IMediaStreamSourceStartingRequestDeferral(IMediaStreamSourceStartingRequestDeferralVtbl, IMediaStreamSourceStartingRequestDeferral_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamSourceStartingRequestDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IMediaStreamSourceStartingRequestDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Complete)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaStreamSourceStartingRequestDeferral: IMediaStreamSourceStartingRequestDeferral}
DEFINE_IID!(IID_IMediaStreamSourceSwitchStreamsRequest, 1102610574, 14505, 20163, 155, 160, 182, 155, 133, 80, 30, 144);
RT_INTERFACE!{interface IMediaStreamSourceSwitchStreamsRequest(IMediaStreamSourceSwitchStreamsRequestVtbl, IMediaStreamSourceSwitchStreamsRequest_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamSourceSwitchStreamsRequest] {
    fn get_OldStreamDescriptor(&self, out: *mut <IMediaStreamDescriptor as RtType>::Abi) -> HRESULT,
    fn get_NewStreamDescriptor(&self, out: *mut <IMediaStreamDescriptor as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <MediaStreamSourceSwitchStreamsRequestDeferral as RtType>::Abi) -> HRESULT
}}
impl IMediaStreamSourceSwitchStreamsRequest {
    #[inline] pub fn get_old_stream_descriptor(&self) -> Result<Option<IMediaStreamDescriptor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_OldStreamDescriptor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IMediaStreamDescriptor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_new_stream_descriptor(&self) -> Result<Option<IMediaStreamDescriptor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_NewStreamDescriptor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IMediaStreamDescriptor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<MediaStreamSourceSwitchStreamsRequestDeferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaStreamSourceSwitchStreamsRequestDeferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaStreamSourceSwitchStreamsRequest: IMediaStreamSourceSwitchStreamsRequest}
DEFINE_IID!(IID_IMediaStreamSourceSwitchStreamsRequestDeferral, 3202603061, 42245, 20378, 185, 67, 43, 140, 177, 180, 187, 217);
RT_INTERFACE!{interface IMediaStreamSourceSwitchStreamsRequestDeferral(IMediaStreamSourceSwitchStreamsRequestDeferralVtbl, IMediaStreamSourceSwitchStreamsRequestDeferral_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamSourceSwitchStreamsRequestDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IMediaStreamSourceSwitchStreamsRequestDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Complete)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaStreamSourceSwitchStreamsRequestDeferral: IMediaStreamSourceSwitchStreamsRequestDeferral}
DEFINE_IID!(IID_IMediaStreamSourceSwitchStreamsRequestedEventArgs, 1109404530, 28321, 18039, 152, 30, 53, 10, 13, 164, 18, 170);
RT_INTERFACE!{interface IMediaStreamSourceSwitchStreamsRequestedEventArgs(IMediaStreamSourceSwitchStreamsRequestedEventArgsVtbl, IMediaStreamSourceSwitchStreamsRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaStreamSourceSwitchStreamsRequestedEventArgs] {
    fn get_Request(&self, out: *mut <MediaStreamSourceSwitchStreamsRequest as RtType>::Abi) -> HRESULT
}}
impl IMediaStreamSourceSwitchStreamsRequestedEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<MediaStreamSourceSwitchStreamsRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Request)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaStreamSourceSwitchStreamsRequest::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaStreamSourceSwitchStreamsRequestedEventArgs: IMediaStreamSourceSwitchStreamsRequestedEventArgs}
DEFINE_IID!(IID_IMediaTrack, 65141500, 51505, 18714, 180, 107, 193, 14, 232, 194, 86, 183);
RT_INTERFACE!{interface IMediaTrack(IMediaTrackVtbl, IMediaTrack_Abi): IInspectable(IInspectableVtbl) [IID_IMediaTrack] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TrackKind(&self, out: *mut MediaTrackKind) -> HRESULT,
    fn put_Label(&self, value: HSTRING) -> HRESULT,
    fn get_Label(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMediaTrack {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_language(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Language)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_track_kind(&self) -> Result<MediaTrackKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TrackKind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_label(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Label)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_label(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Label)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum MediaTrackKind: i32 {
    Audio = 0, Video = 1, TimedMetadata = 2,
}}
RT_ENUM! { enum MseAppendMode: i32 {
    Segments = 0, Sequence = 1,
}}
RT_ENUM! { enum MseEndOfStreamStatus: i32 {
    Success = 0, NetworkError = 1, DecodeError = 2, UnknownError = 3,
}}
RT_ENUM! { enum MseReadyState: i32 {
    Closed = 0, Open = 1, Ended = 2,
}}
DEFINE_IID!(IID_IMseSourceBuffer, 203072483, 57229, 16505, 163, 254, 104, 73, 24, 75, 78, 47);
RT_INTERFACE!{interface IMseSourceBuffer(IMseSourceBufferVtbl, IMseSourceBuffer_Abi): IInspectable(IInspectableVtbl) [IID_IMseSourceBuffer] {
    fn add_UpdateStarting(&self, handler: <foundation::TypedEventHandler<MseSourceBuffer, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_UpdateStarting(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Updated(&self, handler: <foundation::TypedEventHandler<MseSourceBuffer, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Updated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_UpdateEnded(&self, handler: <foundation::TypedEventHandler<MseSourceBuffer, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_UpdateEnded(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ErrorOccurred(&self, handler: <foundation::TypedEventHandler<MseSourceBuffer, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ErrorOccurred(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Aborted(&self, handler: <foundation::TypedEventHandler<MseSourceBuffer, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Aborted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Mode(&self, out: *mut MseAppendMode) -> HRESULT,
    fn put_Mode(&self, value: MseAppendMode) -> HRESULT,
    fn get_IsUpdating(&self, out: *mut bool) -> HRESULT,
    fn get_Buffered(&self, out: *mut <foundation::collections::IVectorView<MseTimeRange> as RtType>::Abi) -> HRESULT,
    fn get_TimestampOffset(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_TimestampOffset(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_AppendWindowStart(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_AppendWindowStart(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_AppendWindowEnd(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn put_AppendWindowEnd(&self, value: <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy20(&self) -> (),
    #[cfg(feature="windows-storage")] fn AppendBuffer(&self, buffer: <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy21(&self) -> (),
    #[cfg(feature="windows-storage")] fn AppendStream(&self, stream: <super::super::storage::streams::IInputStream as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy22(&self) -> (),
    #[cfg(feature="windows-storage")] fn AppendStreamMaxSize(&self, stream: <super::super::storage::streams::IInputStream as RtType>::Abi, maxSize: u64) -> HRESULT,
    fn Abort(&self) -> HRESULT,
    fn Remove(&self, start: foundation::TimeSpan, end: <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT
}}
impl IMseSourceBuffer {
    #[inline] pub fn add_update_starting(&self, handler: &foundation::TypedEventHandler<MseSourceBuffer, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_UpdateStarting)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_update_starting(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_UpdateStarting)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_updated(&self, handler: &foundation::TypedEventHandler<MseSourceBuffer, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Updated)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Updated)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_update_ended(&self, handler: &foundation::TypedEventHandler<MseSourceBuffer, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_UpdateEnded)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_update_ended(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_UpdateEnded)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_error_occurred(&self, handler: &foundation::TypedEventHandler<MseSourceBuffer, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ErrorOccurred)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_error_occurred(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ErrorOccurred)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_aborted(&self, handler: &foundation::TypedEventHandler<MseSourceBuffer, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Aborted)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_aborted(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Aborted)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_mode(&self) -> Result<MseAppendMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_mode(&self, value: MseAppendMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Mode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_updating(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsUpdating)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_buffered(&self) -> Result<Option<foundation::collections::IVectorView<MseTimeRange>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Buffered)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp_offset(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TimestampOffset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_timestamp_offset(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_TimestampOffset)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_append_window_start(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AppendWindowStart)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_append_window_start(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AppendWindowStart)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_append_window_end(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AppendWindowEnd)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_append_window_end(&self, value: &foundation::IReference<foundation::TimeSpan>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AppendWindowEnd)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn append_buffer(&self, buffer: &super::super::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AppendBuffer)(self.0.as_abi() as *const _ as *mut _, get_abi(buffer) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn append_stream(&self, stream: &super::super::storage::streams::IInputStream) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AppendStream)(self.0.as_abi() as *const _ as *mut _, get_abi(stream) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn append_stream_max_size(&self, stream: &super::super::storage::streams::IInputStream, maxSize: u64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AppendStreamMaxSize)(self.0.as_abi() as *const _ as *mut _, get_abi(stream) as *const _ as *mut _, maxSize);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn abort(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Abort)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove(&self, start: foundation::TimeSpan, end: &foundation::IReference<foundation::TimeSpan>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Remove)(self.0.as_abi() as *const _ as *mut _, start, get_abi(end) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MseSourceBuffer: IMseSourceBuffer}
DEFINE_IID!(IID_IMseSourceBufferList, 2516248807, 43239, 20159, 137, 39, 20, 94, 148, 11, 165, 17);
RT_INTERFACE!{interface IMseSourceBufferList(IMseSourceBufferListVtbl, IMseSourceBufferList_Abi): IInspectable(IInspectableVtbl) [IID_IMseSourceBufferList] {
    fn add_SourceBufferAdded(&self, handler: <foundation::TypedEventHandler<MseSourceBufferList, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourceBufferAdded(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SourceBufferRemoved(&self, handler: <foundation::TypedEventHandler<MseSourceBufferList, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourceBufferRemoved(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Buffers(&self, out: *mut <foundation::collections::IVectorView<MseSourceBuffer> as RtType>::Abi) -> HRESULT
}}
impl IMseSourceBufferList {
    #[inline] pub fn add_source_buffer_added(&self, handler: &foundation::TypedEventHandler<MseSourceBufferList, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SourceBufferAdded)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_buffer_added(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SourceBufferAdded)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_source_buffer_removed(&self, handler: &foundation::TypedEventHandler<MseSourceBufferList, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SourceBufferRemoved)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_buffer_removed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SourceBufferRemoved)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_buffers(&self) -> Result<Option<foundation::collections::IVectorView<MseSourceBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Buffers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MseSourceBufferList: IMseSourceBufferList}
DEFINE_IID!(IID_IMseStreamSource, 2964593037, 756, 18723, 136, 221, 129, 188, 63, 54, 15, 250);
RT_INTERFACE!{interface IMseStreamSource(IMseStreamSourceVtbl, IMseStreamSource_Abi): IInspectable(IInspectableVtbl) [IID_IMseStreamSource] {
    fn add_Opened(&self, handler: <foundation::TypedEventHandler<MseStreamSource, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Opened(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Ended(&self, handler: <foundation::TypedEventHandler<MseStreamSource, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Ended(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Closed(&self, handler: <foundation::TypedEventHandler<MseStreamSource, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_SourceBuffers(&self, out: *mut <MseSourceBufferList as RtType>::Abi) -> HRESULT,
    fn get_ActiveSourceBuffers(&self, out: *mut <MseSourceBufferList as RtType>::Abi) -> HRESULT,
    fn get_ReadyState(&self, out: *mut MseReadyState) -> HRESULT,
    fn get_Duration(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn put_Duration(&self, value: <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn AddSourceBuffer(&self, mimeType: HSTRING, out: *mut <MseSourceBuffer as RtType>::Abi) -> HRESULT,
    fn RemoveSourceBuffer(&self, buffer: <MseSourceBuffer as RtType>::Abi) -> HRESULT,
    fn EndOfStream(&self, status: MseEndOfStreamStatus) -> HRESULT
}}
impl IMseStreamSource {
    #[inline] pub fn add_opened(&self, handler: &foundation::TypedEventHandler<MseStreamSource, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Opened)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_opened(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Opened)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_ended(&self, handler: &foundation::TypedEventHandler<MseStreamSource, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Ended)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_ended(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Ended)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_closed(&self, handler: &foundation::TypedEventHandler<MseStreamSource, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Closed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_closed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Closed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_source_buffers(&self) -> Result<Option<MseSourceBufferList>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SourceBuffers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MseSourceBufferList::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_active_source_buffers(&self) -> Result<Option<MseSourceBufferList>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ActiveSourceBuffers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MseSourceBufferList::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_ready_state(&self) -> Result<MseReadyState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReadyState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_duration(&self, value: &foundation::IReference<foundation::TimeSpan>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Duration)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_source_buffer(&self, mimeType: &HStringArg) -> Result<Option<MseSourceBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).AddSourceBuffer)(self.0.as_abi() as *const _ as *mut _, mimeType.get(), &mut out);
        if hr == S_OK { Ok(MseSourceBuffer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_buffer(&self, buffer: &MseSourceBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RemoveSourceBuffer)(self.0.as_abi() as *const _ as *mut _, get_abi(buffer) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn end_of_stream(&self, status: MseEndOfStreamStatus) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).EndOfStream)(self.0.as_abi() as *const _ as *mut _, status);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MseStreamSource: IMseStreamSource}
impl RtActivatable<IMseStreamSourceStatics> for MseStreamSource {}
impl RtActivatable<IActivationFactory> for MseStreamSource {}
impl MseStreamSource {
    #[inline] pub fn is_content_type_supported(contentType: &HStringArg) -> Result<bool> {
        <Self as RtActivatable<IMseStreamSourceStatics>>::get_activation_factory().is_content_type_supported(contentType)
    }
}
DEFINE_CLSID!(MseStreamSource(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,77,115,101,83,116,114,101,97,109,83,111,117,114,99,101,0]) [CLSID_MseStreamSource]);
DEFINE_IID!(IID_IMseStreamSource2, 1727364407, 63975, 16778, 156, 222, 160, 32, 233, 86, 85, 43);
RT_INTERFACE!{interface IMseStreamSource2(IMseStreamSource2Vtbl, IMseStreamSource2_Abi): IInspectable(IInspectableVtbl) [IID_IMseStreamSource2] {
    fn get_LiveSeekableRange(&self, out: *mut <foundation::IReference<MseTimeRange> as RtType>::Abi) -> HRESULT,
    fn put_LiveSeekableRange(&self, value: <foundation::IReference<MseTimeRange> as RtType>::Abi) -> HRESULT
}}
impl IMseStreamSource2 {
    #[inline] pub fn get_live_seekable_range(&self) -> Result<Option<foundation::IReference<MseTimeRange>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_LiveSeekableRange)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_live_seekable_range(&self, value: &foundation::IReference<MseTimeRange>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_LiveSeekableRange)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMseStreamSourceStatics, 1180460957, 54640, 17358, 186, 33, 11, 255, 95, 63, 189, 10);
RT_INTERFACE!{static interface IMseStreamSourceStatics(IMseStreamSourceStaticsVtbl, IMseStreamSourceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IMseStreamSourceStatics] {
    fn IsContentTypeSupported(&self, contentType: HSTRING, out: *mut bool) -> HRESULT
}}
impl IMseStreamSourceStatics {
    #[inline] pub fn is_content_type_supported(&self, contentType: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsContentTypeSupported)(self.0.as_abi() as *const _ as *mut _, contentType.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_STRUCT! { struct MseTimeRange {
    Start: foundation::TimeSpan, End: foundation::TimeSpan,
}}
DEFINE_IID!(IID_ISceneAnalysisEffect, 3226182425, 51777, 18451, 191, 253, 123, 8, 176, 237, 37, 87);
RT_INTERFACE!{interface ISceneAnalysisEffect(ISceneAnalysisEffectVtbl, ISceneAnalysisEffect_Abi): IInspectable(IInspectableVtbl) [IID_ISceneAnalysisEffect] {
    fn get_HighDynamicRangeAnalyzer(&self, out: *mut <HighDynamicRangeControl as RtType>::Abi) -> HRESULT,
    fn put_DesiredAnalysisInterval(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_DesiredAnalysisInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn add_SceneAnalyzed(&self, handler: <foundation::TypedEventHandler<SceneAnalysisEffect, SceneAnalyzedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SceneAnalyzed(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ISceneAnalysisEffect {
    #[inline] pub fn get_high_dynamic_range_analyzer(&self) -> Result<Option<HighDynamicRangeControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_HighDynamicRangeAnalyzer)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HighDynamicRangeControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_analysis_interval(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DesiredAnalysisInterval)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_desired_analysis_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DesiredAnalysisInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_scene_analyzed(&self, handler: &foundation::TypedEventHandler<SceneAnalysisEffect, SceneAnalyzedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SceneAnalyzed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_scene_analyzed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SceneAnalyzed)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SceneAnalysisEffect: ISceneAnalysisEffect}
RT_CLASS!{class SceneAnalysisEffectDefinition: super::effects::IVideoEffectDefinition}
impl RtActivatable<IActivationFactory> for SceneAnalysisEffectDefinition {}
DEFINE_CLSID!(SceneAnalysisEffectDefinition(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,83,99,101,110,101,65,110,97,108,121,115,105,115,69,102,102,101,99,116,68,101,102,105,110,105,116,105,111,110,0]) [CLSID_SceneAnalysisEffectDefinition]);
DEFINE_IID!(IID_ISceneAnalysisEffectFrame, 3635482188, 32729, 17121, 133, 235, 101, 114, 194, 151, 201, 135);
RT_INTERFACE!{interface ISceneAnalysisEffectFrame(ISceneAnalysisEffectFrameVtbl, ISceneAnalysisEffectFrame_Abi): IInspectable(IInspectableVtbl) [IID_ISceneAnalysisEffectFrame] {
    fn get_FrameControlValues(&self, out: *mut <super::capture::CapturedFrameControlValues as RtType>::Abi) -> HRESULT,
    fn get_HighDynamicRange(&self, out: *mut <HighDynamicRangeOutput as RtType>::Abi) -> HRESULT
}}
impl ISceneAnalysisEffectFrame {
    #[inline] pub fn get_frame_control_values(&self) -> Result<Option<super::capture::CapturedFrameControlValues>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameControlValues)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::capture::CapturedFrameControlValues::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_high_dynamic_range(&self) -> Result<Option<HighDynamicRangeOutput>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_HighDynamicRange)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HighDynamicRangeOutput::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SceneAnalysisEffectFrame: ISceneAnalysisEffectFrame}
DEFINE_IID!(IID_ISceneAnalysisEffectFrame2, 760097214, 1567, 18350, 153, 21, 2, 82, 75, 95, 154, 95);
RT_INTERFACE!{interface ISceneAnalysisEffectFrame2(ISceneAnalysisEffectFrame2Vtbl, ISceneAnalysisEffectFrame2_Abi): IInspectable(IInspectableVtbl) [IID_ISceneAnalysisEffectFrame2] {
    fn get_AnalysisRecommendation(&self, out: *mut SceneAnalysisRecommendation) -> HRESULT
}}
impl ISceneAnalysisEffectFrame2 {
    #[inline] pub fn get_analysis_recommendation(&self) -> Result<SceneAnalysisRecommendation> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AnalysisRecommendation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum SceneAnalysisRecommendation: i32 {
    Standard = 0, Hdr = 1, LowLight = 2,
}}
DEFINE_IID!(IID_ISceneAnalyzedEventArgs, 342594952, 10321, 17892, 173, 85, 68, 207, 141, 248, 219, 77);
RT_INTERFACE!{interface ISceneAnalyzedEventArgs(ISceneAnalyzedEventArgsVtbl, ISceneAnalyzedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ISceneAnalyzedEventArgs] {
    fn get_ResultFrame(&self, out: *mut <SceneAnalysisEffectFrame as RtType>::Abi) -> HRESULT
}}
impl ISceneAnalyzedEventArgs {
    #[inline] pub fn get_result_frame(&self) -> Result<Option<SceneAnalysisEffectFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResultFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SceneAnalysisEffectFrame::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SceneAnalyzedEventArgs: ISceneAnalyzedEventArgs}
DEFINE_IID!(IID_ISingleSelectMediaTrackList, 1998614303, 49999, 18767, 128, 119, 43, 173, 159, 244, 236, 241);
RT_INTERFACE!{interface ISingleSelectMediaTrackList(ISingleSelectMediaTrackListVtbl, ISingleSelectMediaTrackList_Abi): IInspectable(IInspectableVtbl) [IID_ISingleSelectMediaTrackList] {
    fn add_SelectedIndexChanged(&self, handler: <foundation::TypedEventHandler<ISingleSelectMediaTrackList, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SelectedIndexChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn put_SelectedIndex(&self, value: i32) -> HRESULT,
    fn get_SelectedIndex(&self, out: *mut i32) -> HRESULT
}}
impl ISingleSelectMediaTrackList {
    #[inline] pub fn add_selected_index_changed(&self, handler: &foundation::TypedEventHandler<ISingleSelectMediaTrackList, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SelectedIndexChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_selected_index_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SelectedIndexChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_selected_index(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SelectedIndex)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_selected_index(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SelectedIndex)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpeechCue, 2934068444, 5925, 19373, 128, 67, 169, 132, 153, 176, 23, 162);
RT_INTERFACE!{interface ISpeechCue(ISpeechCueVtbl, ISpeechCue_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechCue] {
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Text(&self, value: HSTRING) -> HRESULT,
    fn get_StartPositionInInput(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_StartPositionInInput(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_EndPositionInInput(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn put_EndPositionInInput(&self, value: <foundation::IReference<i32> as RtType>::Abi) -> HRESULT
}}
impl ISpeechCue {
    #[inline] pub fn get_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Text)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_text(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Text)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_start_position_in_input(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_StartPositionInInput)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_start_position_in_input(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_StartPositionInInput)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_end_position_in_input(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EndPositionInInput)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_end_position_in_input(&self, value: &foundation::IReference<i32>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_EndPositionInInput)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SpeechCue: ISpeechCue}
impl RtActivatable<IActivationFactory> for SpeechCue {}
DEFINE_CLSID!(SpeechCue(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,83,112,101,101,99,104,67,117,101,0]) [CLSID_SpeechCue]);
RT_ENUM! { enum TimedMetadataKind: i32 {
    Caption = 0, Chapter = 1, Custom = 2, Data = 3, Description = 4, Subtitle = 5, ImageSubtitle = 6, Speech = 7,
}}
DEFINE_IID!(IID_ITimedMetadataStreamDescriptor, 322123455, 10602, 17982, 159, 249, 1, 205, 37, 105, 20, 8);
RT_INTERFACE!{interface ITimedMetadataStreamDescriptor(ITimedMetadataStreamDescriptorVtbl, ITimedMetadataStreamDescriptor_Abi): IInspectable(IInspectableVtbl) [IID_ITimedMetadataStreamDescriptor] {
    fn get_EncodingProperties(&self, out: *mut <super::mediaproperties::TimedMetadataEncodingProperties as RtType>::Abi) -> HRESULT,
    fn Copy(&self, out: *mut <TimedMetadataStreamDescriptor as RtType>::Abi) -> HRESULT
}}
impl ITimedMetadataStreamDescriptor {
    #[inline] pub fn get_encoding_properties(&self) -> Result<Option<super::mediaproperties::TimedMetadataEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EncodingProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::mediaproperties::TimedMetadataEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn copy(&self) -> Result<Option<TimedMetadataStreamDescriptor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Copy)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(TimedMetadataStreamDescriptor::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class TimedMetadataStreamDescriptor: IMediaStreamDescriptor}
impl RtActivatable<ITimedMetadataStreamDescriptorFactory> for TimedMetadataStreamDescriptor {}
impl TimedMetadataStreamDescriptor {
    #[inline] pub fn create(encodingProperties: &super::mediaproperties::TimedMetadataEncodingProperties) -> Result<TimedMetadataStreamDescriptor> {
        <Self as RtActivatable<ITimedMetadataStreamDescriptorFactory>>::get_activation_factory().create(encodingProperties)
    }
}
DEFINE_CLSID!(TimedMetadataStreamDescriptor(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,84,105,109,101,100,77,101,116,97,100,97,116,97,83,116,114,101,97,109,68,101,115,99,114,105,112,116,111,114,0]) [CLSID_TimedMetadataStreamDescriptor]);
DEFINE_IID!(IID_ITimedMetadataStreamDescriptorFactory, 3223838256, 29538, 20473, 152, 177, 45, 253, 11, 141, 28, 174);
RT_INTERFACE!{static interface ITimedMetadataStreamDescriptorFactory(ITimedMetadataStreamDescriptorFactoryVtbl, ITimedMetadataStreamDescriptorFactory_Abi): IInspectable(IInspectableVtbl) [IID_ITimedMetadataStreamDescriptorFactory] {
    fn Create(&self, encodingProperties: <super::mediaproperties::TimedMetadataEncodingProperties as RtType>::Abi, out: *mut <TimedMetadataStreamDescriptor as RtType>::Abi) -> HRESULT
}}
impl ITimedMetadataStreamDescriptorFactory {
    #[inline] pub fn create(&self, encodingProperties: &super::mediaproperties::TimedMetadataEncodingProperties) -> Result<TimedMetadataStreamDescriptor> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(encodingProperties) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(TimedMetadataStreamDescriptor::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ITimedMetadataTrack, 2657807774, 63098, 18857, 179, 48, 207, 3, 176, 233, 207, 7);
RT_INTERFACE!{interface ITimedMetadataTrack(ITimedMetadataTrackVtbl, ITimedMetadataTrack_Abi): IInspectable(IInspectableVtbl) [IID_ITimedMetadataTrack] {
    fn add_CueEntered(&self, handler: <foundation::TypedEventHandler<TimedMetadataTrack, MediaCueEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CueEntered(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CueExited(&self, handler: <foundation::TypedEventHandler<TimedMetadataTrack, MediaCueEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CueExited(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_TrackFailed(&self, handler: <foundation::TypedEventHandler<TimedMetadataTrack, TimedMetadataTrackFailedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TrackFailed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Cues(&self, out: *mut <foundation::collections::IVectorView<IMediaCue> as RtType>::Abi) -> HRESULT,
    fn get_ActiveCues(&self, out: *mut <foundation::collections::IVectorView<IMediaCue> as RtType>::Abi) -> HRESULT,
    fn get_TimedMetadataKind(&self, out: *mut TimedMetadataKind) -> HRESULT,
    fn get_DispatchType(&self, out: *mut HSTRING) -> HRESULT,
    fn AddCue(&self, cue: <IMediaCue as RtType>::Abi) -> HRESULT,
    fn RemoveCue(&self, cue: <IMediaCue as RtType>::Abi) -> HRESULT
}}
impl ITimedMetadataTrack {
    #[inline] pub fn add_cue_entered(&self, handler: &foundation::TypedEventHandler<TimedMetadataTrack, MediaCueEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_CueEntered)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_cue_entered(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_CueEntered)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_cue_exited(&self, handler: &foundation::TypedEventHandler<TimedMetadataTrack, MediaCueEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_CueExited)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_cue_exited(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_CueExited)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_track_failed(&self, handler: &foundation::TypedEventHandler<TimedMetadataTrack, TimedMetadataTrackFailedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_TrackFailed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_track_failed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_TrackFailed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cues(&self) -> Result<Option<foundation::collections::IVectorView<IMediaCue>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Cues)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_active_cues(&self) -> Result<Option<foundation::collections::IVectorView<IMediaCue>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ActiveCues)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_timed_metadata_kind(&self) -> Result<TimedMetadataKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TimedMetadataKind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dispatch_type(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DispatchType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_cue(&self, cue: &IMediaCue) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AddCue)(self.0.as_abi() as *const _ as *mut _, get_abi(cue) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove_cue(&self, cue: &IMediaCue) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RemoveCue)(self.0.as_abi() as *const _ as *mut _, get_abi(cue) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class TimedMetadataTrack: ITimedMetadataTrack}
impl RtActivatable<ITimedMetadataTrackFactory> for TimedMetadataTrack {}
impl TimedMetadataTrack {
    #[inline] pub fn create(id: &HStringArg, language: &HStringArg, kind: TimedMetadataKind) -> Result<TimedMetadataTrack> {
        <Self as RtActivatable<ITimedMetadataTrackFactory>>::get_activation_factory().create(id, language, kind)
    }
}
DEFINE_CLSID!(TimedMetadataTrack(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,84,105,109,101,100,77,101,116,97,100,97,116,97,84,114,97,99,107,0]) [CLSID_TimedMetadataTrack]);
DEFINE_IID!(IID_ITimedMetadataTrack2, 565491272, 40861, 16570, 168, 243, 26, 146, 117, 58, 239, 11);
RT_INTERFACE!{interface ITimedMetadataTrack2(ITimedMetadataTrack2Vtbl, ITimedMetadataTrack2_Abi): IInspectable(IInspectableVtbl) [IID_ITimedMetadataTrack2] {
    fn get_PlaybackItem(&self, out: *mut <super::playback::MediaPlaybackItem as RtType>::Abi) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT
}}
impl ITimedMetadataTrack2 {
    #[inline] pub fn get_playback_item(&self) -> Result<Option<super::playback::MediaPlaybackItem>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackItem)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::playback::MediaPlaybackItem::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Name)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ITimedMetadataTrackError, 3010885909, 16660, 18457, 185, 217, 221, 118, 8, 158, 114, 248);
RT_INTERFACE!{interface ITimedMetadataTrackError(ITimedMetadataTrackErrorVtbl, ITimedMetadataTrackError_Abi): IInspectable(IInspectableVtbl) [IID_ITimedMetadataTrackError] {
    fn get_ErrorCode(&self, out: *mut TimedMetadataTrackErrorCode) -> HRESULT,
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl ITimedMetadataTrackError {
    #[inline] pub fn get_error_code(&self) -> Result<TimedMetadataTrackErrorCode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ErrorCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class TimedMetadataTrackError: ITimedMetadataTrackError}
RT_ENUM! { enum TimedMetadataTrackErrorCode: i32 {
    None = 0, DataFormatError = 1, NetworkError = 2, InternalError = 3,
}}
DEFINE_IID!(IID_ITimedMetadataTrackFactory, 2379576849, 38835, 19999, 133, 44, 15, 72, 44, 129, 173, 38);
RT_INTERFACE!{static interface ITimedMetadataTrackFactory(ITimedMetadataTrackFactoryVtbl, ITimedMetadataTrackFactory_Abi): IInspectable(IInspectableVtbl) [IID_ITimedMetadataTrackFactory] {
    fn Create(&self, id: HSTRING, language: HSTRING, kind: TimedMetadataKind, out: *mut <TimedMetadataTrack as RtType>::Abi) -> HRESULT
}}
impl ITimedMetadataTrackFactory {
    #[inline] pub fn create(&self, id: &HStringArg, language: &HStringArg, kind: TimedMetadataKind) -> Result<TimedMetadataTrack> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, id.get(), language.get(), kind, &mut out);
        if hr == S_OK { Ok(TimedMetadataTrack::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ITimedMetadataTrackFailedEventArgs, 2776615377, 26505, 19789, 176, 127, 132, 180, 243, 26, 203, 112);
RT_INTERFACE!{interface ITimedMetadataTrackFailedEventArgs(ITimedMetadataTrackFailedEventArgsVtbl, ITimedMetadataTrackFailedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ITimedMetadataTrackFailedEventArgs] {
    fn get_Error(&self, out: *mut <TimedMetadataTrackError as RtType>::Abi) -> HRESULT
}}
impl ITimedMetadataTrackFailedEventArgs {
    #[inline] pub fn get_error(&self) -> Result<Option<TimedMetadataTrackError>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Error)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(TimedMetadataTrackError::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class TimedMetadataTrackFailedEventArgs: ITimedMetadataTrackFailedEventArgs}
DEFINE_IID!(IID_ITimedMetadataTrackProvider, 998187044, 63310, 19166, 147, 197, 33, 157, 160, 91, 104, 86);
RT_INTERFACE!{interface ITimedMetadataTrackProvider(ITimedMetadataTrackProviderVtbl, ITimedMetadataTrackProvider_Abi): IInspectable(IInspectableVtbl) [IID_ITimedMetadataTrackProvider] {
    fn get_TimedMetadataTracks(&self, out: *mut <foundation::collections::IVectorView<TimedMetadataTrack> as RtType>::Abi) -> HRESULT
}}
impl ITimedMetadataTrackProvider {
    #[inline] pub fn get_timed_metadata_tracks(&self) -> Result<Option<foundation::collections::IVectorView<TimedMetadataTrack>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TimedMetadataTracks)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ITimedTextCue, 1372036689, 15238, 18765, 179, 89, 187, 46, 167, 172, 169, 169);
RT_INTERFACE!{interface ITimedTextCue(ITimedTextCueVtbl, ITimedTextCue_Abi): IInspectable(IInspectableVtbl) [IID_ITimedTextCue] {
    fn get_CueRegion(&self, out: *mut <TimedTextRegion as RtType>::Abi) -> HRESULT,
    fn put_CueRegion(&self, value: <TimedTextRegion as RtType>::Abi) -> HRESULT,
    fn get_CueStyle(&self, out: *mut <TimedTextStyle as RtType>::Abi) -> HRESULT,
    fn put_CueStyle(&self, value: <TimedTextStyle as RtType>::Abi) -> HRESULT,
    fn get_Lines(&self, out: *mut <foundation::collections::IVector<TimedTextLine> as RtType>::Abi) -> HRESULT
}}
impl ITimedTextCue {
    #[inline] pub fn get_cue_region(&self) -> Result<Option<TimedTextRegion>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CueRegion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(TimedTextRegion::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_cue_region(&self, value: &TimedTextRegion) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CueRegion)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cue_style(&self) -> Result<Option<TimedTextStyle>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CueStyle)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(TimedTextStyle::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_cue_style(&self, value: &TimedTextStyle) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CueStyle)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_lines(&self) -> Result<Option<foundation::collections::IVector<TimedTextLine>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Lines)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class TimedTextCue: ITimedTextCue}
impl RtActivatable<IActivationFactory> for TimedTextCue {}
DEFINE_CLSID!(TimedTextCue(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,84,105,109,101,100,84,101,120,116,67,117,101,0]) [CLSID_TimedTextCue]);
RT_ENUM! { enum TimedTextDisplayAlignment: i32 {
    Before = 0, After = 1, Center = 2,
}}
RT_STRUCT! { struct TimedTextDouble {
    Value: f64, Unit: TimedTextUnit,
}}
RT_ENUM! { enum TimedTextFlowDirection: i32 {
    LeftToRight = 0, RightToLeft = 1,
}}
RT_ENUM! { enum TimedTextFontStyle: i32 {
    Normal = 0, Oblique = 1, Italic = 2,
}}
DEFINE_IID!(IID_ITimedTextLine, 2542632162, 29448, 19558, 190, 80, 101, 119, 114, 137, 245, 223);
RT_INTERFACE!{interface ITimedTextLine(ITimedTextLineVtbl, ITimedTextLine_Abi): IInspectable(IInspectableVtbl) [IID_ITimedTextLine] {
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Text(&self, value: HSTRING) -> HRESULT,
    fn get_Subformats(&self, out: *mut <foundation::collections::IVector<TimedTextSubformat> as RtType>::Abi) -> HRESULT
}}
impl ITimedTextLine {
    #[inline] pub fn get_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Text)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_text(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Text)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_subformats(&self) -> Result<Option<foundation::collections::IVector<TimedTextSubformat>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Subformats)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class TimedTextLine: ITimedTextLine}
impl RtActivatable<IActivationFactory> for TimedTextLine {}
DEFINE_CLSID!(TimedTextLine(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,84,105,109,101,100,84,101,120,116,76,105,110,101,0]) [CLSID_TimedTextLine]);
RT_ENUM! { enum TimedTextLineAlignment: i32 {
    Start = 0, End = 1, Center = 2,
}}
RT_STRUCT! { struct TimedTextPadding {
    Before: f64, After: f64, Start: f64, End: f64, Unit: TimedTextUnit,
}}
RT_STRUCT! { struct TimedTextPoint {
    X: f64, Y: f64, Unit: TimedTextUnit,
}}
DEFINE_IID!(IID_ITimedTextRegion, 516982815, 35334, 16930, 159, 89, 178, 27, 244, 1, 36, 180);
RT_INTERFACE!{interface ITimedTextRegion(ITimedTextRegionVtbl, ITimedTextRegion_Abi): IInspectable(IInspectableVtbl) [IID_ITimedTextRegion] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT,
    fn get_Position(&self, out: *mut TimedTextPoint) -> HRESULT,
    fn put_Position(&self, value: TimedTextPoint) -> HRESULT,
    fn get_Extent(&self, out: *mut TimedTextSize) -> HRESULT,
    fn put_Extent(&self, value: TimedTextSize) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Background(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_Background(&self, value: super::super::ui::Color) -> HRESULT,
    fn get_WritingMode(&self, out: *mut TimedTextWritingMode) -> HRESULT,
    fn put_WritingMode(&self, value: TimedTextWritingMode) -> HRESULT,
    fn get_DisplayAlignment(&self, out: *mut TimedTextDisplayAlignment) -> HRESULT,
    fn put_DisplayAlignment(&self, value: TimedTextDisplayAlignment) -> HRESULT,
    fn get_LineHeight(&self, out: *mut TimedTextDouble) -> HRESULT,
    fn put_LineHeight(&self, value: TimedTextDouble) -> HRESULT,
    fn get_IsOverflowClipped(&self, out: *mut bool) -> HRESULT,
    fn put_IsOverflowClipped(&self, value: bool) -> HRESULT,
    fn get_Padding(&self, out: *mut TimedTextPadding) -> HRESULT,
    fn put_Padding(&self, value: TimedTextPadding) -> HRESULT,
    fn get_TextWrapping(&self, out: *mut TimedTextWrapping) -> HRESULT,
    fn put_TextWrapping(&self, value: TimedTextWrapping) -> HRESULT,
    fn get_ZIndex(&self, out: *mut i32) -> HRESULT,
    fn put_ZIndex(&self, value: i32) -> HRESULT,
    fn get_ScrollMode(&self, out: *mut TimedTextScrollMode) -> HRESULT,
    fn put_ScrollMode(&self, value: TimedTextScrollMode) -> HRESULT
}}
impl ITimedTextRegion {
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Name)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Name)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<TimedTextPoint> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_position(&self, value: TimedTextPoint) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Position)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_extent(&self) -> Result<TimedTextSize> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Extent)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_extent(&self, value: TimedTextSize) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Extent)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_background(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Background)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_background(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Background)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_writing_mode(&self) -> Result<TimedTextWritingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_WritingMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_writing_mode(&self, value: TimedTextWritingMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_WritingMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_display_alignment(&self) -> Result<TimedTextDisplayAlignment> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DisplayAlignment)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_display_alignment(&self, value: TimedTextDisplayAlignment) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DisplayAlignment)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_line_height(&self) -> Result<TimedTextDouble> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LineHeight)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_line_height(&self, value: TimedTextDouble) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_LineHeight)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_overflow_clipped(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsOverflowClipped)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_overflow_clipped(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsOverflowClipped)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_padding(&self) -> Result<TimedTextPadding> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Padding)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_padding(&self, value: TimedTextPadding) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Padding)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_text_wrapping(&self) -> Result<TimedTextWrapping> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TextWrapping)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_text_wrapping(&self, value: TimedTextWrapping) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_TextWrapping)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_z_index(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ZIndex)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_z_index(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ZIndex)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_scroll_mode(&self) -> Result<TimedTextScrollMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ScrollMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_scroll_mode(&self, value: TimedTextScrollMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ScrollMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class TimedTextRegion: ITimedTextRegion}
impl RtActivatable<IActivationFactory> for TimedTextRegion {}
DEFINE_CLSID!(TimedTextRegion(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,84,105,109,101,100,84,101,120,116,82,101,103,105,111,110,0]) [CLSID_TimedTextRegion]);
RT_ENUM! { enum TimedTextScrollMode: i32 {
    Popon = 0, Rollup = 1,
}}
RT_STRUCT! { struct TimedTextSize {
    Height: f64, Width: f64, Unit: TimedTextUnit,
}}
DEFINE_IID!(IID_ITimedTextSource, 3303906214, 4127, 16461, 169, 73, 130, 243, 63, 205, 147, 183);
RT_INTERFACE!{interface ITimedTextSource(ITimedTextSourceVtbl, ITimedTextSource_Abi): IInspectable(IInspectableVtbl) [IID_ITimedTextSource] {
    fn add_Resolved(&self, handler: <foundation::TypedEventHandler<TimedTextSource, TimedTextSourceResolveResultEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Resolved(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ITimedTextSource {
    #[inline] pub fn add_resolved(&self, handler: &foundation::TypedEventHandler<TimedTextSource, TimedTextSourceResolveResultEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Resolved)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_resolved(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Resolved)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class TimedTextSource: ITimedTextSource}
impl RtActivatable<ITimedTextSourceStatics> for TimedTextSource {}
impl RtActivatable<ITimedTextSourceStatics2> for TimedTextSource {}
impl TimedTextSource {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_stream(stream: &super::super::storage::streams::IRandomAccessStream) -> Result<Option<TimedTextSource>> {
        <Self as RtActivatable<ITimedTextSourceStatics>>::get_activation_factory().create_from_stream(stream)
    }
    #[inline] pub fn create_from_uri(uri: &foundation::Uri) -> Result<Option<TimedTextSource>> {
        <Self as RtActivatable<ITimedTextSourceStatics>>::get_activation_factory().create_from_uri(uri)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_stream_with_language(stream: &super::super::storage::streams::IRandomAccessStream, defaultLanguage: &HStringArg) -> Result<Option<TimedTextSource>> {
        <Self as RtActivatable<ITimedTextSourceStatics>>::get_activation_factory().create_from_stream_with_language(stream, defaultLanguage)
    }
    #[inline] pub fn create_from_uri_with_language(uri: &foundation::Uri, defaultLanguage: &HStringArg) -> Result<Option<TimedTextSource>> {
        <Self as RtActivatable<ITimedTextSourceStatics>>::get_activation_factory().create_from_uri_with_language(uri, defaultLanguage)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_stream_with_index(stream: &super::super::storage::streams::IRandomAccessStream, indexStream: &super::super::storage::streams::IRandomAccessStream) -> Result<Option<TimedTextSource>> {
        <Self as RtActivatable<ITimedTextSourceStatics2>>::get_activation_factory().create_from_stream_with_index(stream, indexStream)
    }
    #[inline] pub fn create_from_uri_with_index(uri: &foundation::Uri, indexUri: &foundation::Uri) -> Result<Option<TimedTextSource>> {
        <Self as RtActivatable<ITimedTextSourceStatics2>>::get_activation_factory().create_from_uri_with_index(uri, indexUri)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_stream_with_index_and_language(stream: &super::super::storage::streams::IRandomAccessStream, indexStream: &super::super::storage::streams::IRandomAccessStream, defaultLanguage: &HStringArg) -> Result<Option<TimedTextSource>> {
        <Self as RtActivatable<ITimedTextSourceStatics2>>::get_activation_factory().create_from_stream_with_index_and_language(stream, indexStream, defaultLanguage)
    }
    #[inline] pub fn create_from_uri_with_index_and_language(uri: &foundation::Uri, indexUri: &foundation::Uri, defaultLanguage: &HStringArg) -> Result<Option<TimedTextSource>> {
        <Self as RtActivatable<ITimedTextSourceStatics2>>::get_activation_factory().create_from_uri_with_index_and_language(uri, indexUri, defaultLanguage)
    }
}
DEFINE_CLSID!(TimedTextSource(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,84,105,109,101,100,84,101,120,116,83,111,117,114,99,101,0]) [CLSID_TimedTextSource]);
DEFINE_IID!(IID_ITimedTextSourceResolveResultEventArgs, 1217428636, 56536, 19507, 154, 211, 108, 220, 231, 177, 197, 102);
RT_INTERFACE!{interface ITimedTextSourceResolveResultEventArgs(ITimedTextSourceResolveResultEventArgsVtbl, ITimedTextSourceResolveResultEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ITimedTextSourceResolveResultEventArgs] {
    fn get_Error(&self, out: *mut <TimedMetadataTrackError as RtType>::Abi) -> HRESULT,
    fn get_Tracks(&self, out: *mut <foundation::collections::IVectorView<TimedMetadataTrack> as RtType>::Abi) -> HRESULT
}}
impl ITimedTextSourceResolveResultEventArgs {
    #[inline] pub fn get_error(&self) -> Result<Option<TimedMetadataTrackError>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Error)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(TimedMetadataTrackError::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_tracks(&self) -> Result<Option<foundation::collections::IVectorView<TimedMetadataTrack>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Tracks)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class TimedTextSourceResolveResultEventArgs: ITimedTextSourceResolveResultEventArgs}
DEFINE_IID!(IID_ITimedTextSourceStatics, 2117146707, 39610, 19140, 187, 152, 47, 177, 118, 195, 191, 221);
RT_INTERFACE!{static interface ITimedTextSourceStatics(ITimedTextSourceStaticsVtbl, ITimedTextSourceStatics_Abi): IInspectable(IInspectableVtbl) [IID_ITimedTextSourceStatics] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn CreateFromStream(&self, stream: <super::super::storage::streams::IRandomAccessStream as RtType>::Abi, out: *mut <TimedTextSource as RtType>::Abi) -> HRESULT,
    fn CreateFromUri(&self, uri: <foundation::Uri as RtType>::Abi, out: *mut <TimedTextSource as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn CreateFromStreamWithLanguage(&self, stream: <super::super::storage::streams::IRandomAccessStream as RtType>::Abi, defaultLanguage: HSTRING, out: *mut <TimedTextSource as RtType>::Abi) -> HRESULT,
    fn CreateFromUriWithLanguage(&self, uri: <foundation::Uri as RtType>::Abi, defaultLanguage: HSTRING, out: *mut <TimedTextSource as RtType>::Abi) -> HRESULT
}}
impl ITimedTextSourceStatics {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_stream(&self, stream: &super::super::storage::streams::IRandomAccessStream) -> Result<Option<TimedTextSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromStream)(self.0.as_abi() as *const _ as *mut _, get_abi(stream) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(TimedTextSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_uri(&self, uri: &foundation::Uri) -> Result<Option<TimedTextSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromUri)(self.0.as_abi() as *const _ as *mut _, get_abi(uri) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(TimedTextSource::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_stream_with_language(&self, stream: &super::super::storage::streams::IRandomAccessStream, defaultLanguage: &HStringArg) -> Result<Option<TimedTextSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromStreamWithLanguage)(self.0.as_abi() as *const _ as *mut _, get_abi(stream) as *const _ as *mut _, defaultLanguage.get(), &mut out);
        if hr == S_OK { Ok(TimedTextSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_uri_with_language(&self, uri: &foundation::Uri, defaultLanguage: &HStringArg) -> Result<Option<TimedTextSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromUriWithLanguage)(self.0.as_abi() as *const _ as *mut _, get_abi(uri) as *const _ as *mut _, defaultLanguage.get(), &mut out);
        if hr == S_OK { Ok(TimedTextSource::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ITimedTextSourceStatics2, 3060495874, 37438, 17402, 150, 51, 88, 112, 117, 129, 45, 181);
RT_INTERFACE!{static interface ITimedTextSourceStatics2(ITimedTextSourceStatics2Vtbl, ITimedTextSourceStatics2_Abi): IInspectable(IInspectableVtbl) [IID_ITimedTextSourceStatics2] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn CreateFromStreamWithIndex(&self, stream: <super::super::storage::streams::IRandomAccessStream as RtType>::Abi, indexStream: <super::super::storage::streams::IRandomAccessStream as RtType>::Abi, out: *mut <TimedTextSource as RtType>::Abi) -> HRESULT,
    fn CreateFromUriWithIndex(&self, uri: <foundation::Uri as RtType>::Abi, indexUri: <foundation::Uri as RtType>::Abi, out: *mut <TimedTextSource as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn CreateFromStreamWithIndexAndLanguage(&self, stream: <super::super::storage::streams::IRandomAccessStream as RtType>::Abi, indexStream: <super::super::storage::streams::IRandomAccessStream as RtType>::Abi, defaultLanguage: HSTRING, out: *mut <TimedTextSource as RtType>::Abi) -> HRESULT,
    fn CreateFromUriWithIndexAndLanguage(&self, uri: <foundation::Uri as RtType>::Abi, indexUri: <foundation::Uri as RtType>::Abi, defaultLanguage: HSTRING, out: *mut <TimedTextSource as RtType>::Abi) -> HRESULT
}}
impl ITimedTextSourceStatics2 {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_stream_with_index(&self, stream: &super::super::storage::streams::IRandomAccessStream, indexStream: &super::super::storage::streams::IRandomAccessStream) -> Result<Option<TimedTextSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromStreamWithIndex)(self.0.as_abi() as *const _ as *mut _, get_abi(stream) as *const _ as *mut _, get_abi(indexStream) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(TimedTextSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_uri_with_index(&self, uri: &foundation::Uri, indexUri: &foundation::Uri) -> Result<Option<TimedTextSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromUriWithIndex)(self.0.as_abi() as *const _ as *mut _, get_abi(uri) as *const _ as *mut _, get_abi(indexUri) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(TimedTextSource::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_stream_with_index_and_language(&self, stream: &super::super::storage::streams::IRandomAccessStream, indexStream: &super::super::storage::streams::IRandomAccessStream, defaultLanguage: &HStringArg) -> Result<Option<TimedTextSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromStreamWithIndexAndLanguage)(self.0.as_abi() as *const _ as *mut _, get_abi(stream) as *const _ as *mut _, get_abi(indexStream) as *const _ as *mut _, defaultLanguage.get(), &mut out);
        if hr == S_OK { Ok(TimedTextSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_uri_with_index_and_language(&self, uri: &foundation::Uri, indexUri: &foundation::Uri, defaultLanguage: &HStringArg) -> Result<Option<TimedTextSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromUriWithIndexAndLanguage)(self.0.as_abi() as *const _ as *mut _, get_abi(uri) as *const _ as *mut _, get_abi(indexUri) as *const _ as *mut _, defaultLanguage.get(), &mut out);
        if hr == S_OK { Ok(TimedTextSource::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ITimedTextStyle, 464664653, 43045, 16578, 167, 245, 40, 30, 174, 223, 59, 85);
RT_INTERFACE!{interface ITimedTextStyle(ITimedTextStyleVtbl, ITimedTextStyle_Abi): IInspectable(IInspectableVtbl) [IID_ITimedTextStyle] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT,
    fn get_FontFamily(&self, out: *mut HSTRING) -> HRESULT,
    fn put_FontFamily(&self, value: HSTRING) -> HRESULT,
    fn get_FontSize(&self, out: *mut TimedTextDouble) -> HRESULT,
    fn put_FontSize(&self, value: TimedTextDouble) -> HRESULT,
    fn get_FontWeight(&self, out: *mut TimedTextWeight) -> HRESULT,
    fn put_FontWeight(&self, value: TimedTextWeight) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Foreground(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy9(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_Foreground(&self, value: super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy10(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Background(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy11(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_Background(&self, value: super::super::ui::Color) -> HRESULT,
    fn get_IsBackgroundAlwaysShown(&self, out: *mut bool) -> HRESULT,
    fn put_IsBackgroundAlwaysShown(&self, value: bool) -> HRESULT,
    fn get_FlowDirection(&self, out: *mut TimedTextFlowDirection) -> HRESULT,
    fn put_FlowDirection(&self, value: TimedTextFlowDirection) -> HRESULT,
    fn get_LineAlignment(&self, out: *mut TimedTextLineAlignment) -> HRESULT,
    fn put_LineAlignment(&self, value: TimedTextLineAlignment) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy18(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_OutlineColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy19(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_OutlineColor(&self, value: super::super::ui::Color) -> HRESULT,
    fn get_OutlineThickness(&self, out: *mut TimedTextDouble) -> HRESULT,
    fn put_OutlineThickness(&self, value: TimedTextDouble) -> HRESULT,
    fn get_OutlineRadius(&self, out: *mut TimedTextDouble) -> HRESULT,
    fn put_OutlineRadius(&self, value: TimedTextDouble) -> HRESULT
}}
impl ITimedTextStyle {
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Name)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Name)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_font_family(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FontFamily)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_font_family(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_FontFamily)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_font_size(&self) -> Result<TimedTextDouble> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FontSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_font_size(&self, value: TimedTextDouble) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_FontSize)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_font_weight(&self) -> Result<TimedTextWeight> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FontWeight)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_font_weight(&self, value: TimedTextWeight) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_FontWeight)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_foreground(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Foreground)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_foreground(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Foreground)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_background(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Background)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_background(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Background)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_background_always_shown(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsBackgroundAlwaysShown)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_background_always_shown(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsBackgroundAlwaysShown)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_flow_direction(&self) -> Result<TimedTextFlowDirection> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FlowDirection)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_flow_direction(&self, value: TimedTextFlowDirection) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_FlowDirection)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_line_alignment(&self) -> Result<TimedTextLineAlignment> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LineAlignment)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_line_alignment(&self, value: TimedTextLineAlignment) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_LineAlignment)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_outline_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OutlineColor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_outline_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_OutlineColor)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_outline_thickness(&self) -> Result<TimedTextDouble> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OutlineThickness)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_outline_thickness(&self, value: TimedTextDouble) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_OutlineThickness)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_outline_radius(&self) -> Result<TimedTextDouble> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OutlineRadius)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_outline_radius(&self, value: TimedTextDouble) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_OutlineRadius)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class TimedTextStyle: ITimedTextStyle}
impl RtActivatable<IActivationFactory> for TimedTextStyle {}
DEFINE_CLSID!(TimedTextStyle(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,84,105,109,101,100,84,101,120,116,83,116,121,108,101,0]) [CLSID_TimedTextStyle]);
DEFINE_IID!(IID_ITimedTextStyle2, 1700743469, 24849, 18311, 137, 204, 104, 111, 236, 229, 126, 20);
RT_INTERFACE!{interface ITimedTextStyle2(ITimedTextStyle2Vtbl, ITimedTextStyle2_Abi): IInspectable(IInspectableVtbl) [IID_ITimedTextStyle2] {
    fn get_FontStyle(&self, out: *mut TimedTextFontStyle) -> HRESULT,
    fn put_FontStyle(&self, value: TimedTextFontStyle) -> HRESULT,
    fn get_IsUnderlineEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsUnderlineEnabled(&self, value: bool) -> HRESULT,
    fn get_IsLineThroughEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsLineThroughEnabled(&self, value: bool) -> HRESULT,
    fn get_IsOverlineEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsOverlineEnabled(&self, value: bool) -> HRESULT
}}
impl ITimedTextStyle2 {
    #[inline] pub fn get_font_style(&self) -> Result<TimedTextFontStyle> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FontStyle)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_font_style(&self, value: TimedTextFontStyle) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_FontStyle)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_underline_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsUnderlineEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_underline_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsUnderlineEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_line_through_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsLineThroughEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_line_through_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsLineThroughEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_overline_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsOverlineEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_overline_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsOverlineEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ITimedTextSubformat, 3608367151, 12897, 18210, 160, 194, 185, 55, 178, 57, 15, 20);
RT_INTERFACE!{interface ITimedTextSubformat(ITimedTextSubformatVtbl, ITimedTextSubformat_Abi): IInspectable(IInspectableVtbl) [IID_ITimedTextSubformat] {
    fn get_StartIndex(&self, out: *mut i32) -> HRESULT,
    fn put_StartIndex(&self, value: i32) -> HRESULT,
    fn get_Length(&self, out: *mut i32) -> HRESULT,
    fn put_Length(&self, value: i32) -> HRESULT,
    fn get_SubformatStyle(&self, out: *mut <TimedTextStyle as RtType>::Abi) -> HRESULT,
    fn put_SubformatStyle(&self, value: <TimedTextStyle as RtType>::Abi) -> HRESULT
}}
impl ITimedTextSubformat {
    #[inline] pub fn get_start_index(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StartIndex)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_start_index(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_StartIndex)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_length(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Length)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_length(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Length)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_subformat_style(&self) -> Result<Option<TimedTextStyle>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SubformatStyle)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(TimedTextStyle::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_subformat_style(&self, value: &TimedTextStyle) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SubformatStyle)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class TimedTextSubformat: ITimedTextSubformat}
impl RtActivatable<IActivationFactory> for TimedTextSubformat {}
DEFINE_CLSID!(TimedTextSubformat(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,84,105,109,101,100,84,101,120,116,83,117,98,102,111,114,109,97,116,0]) [CLSID_TimedTextSubformat]);
RT_ENUM! { enum TimedTextUnit: i32 {
    Pixels = 0, Percentage = 1,
}}
RT_ENUM! { enum TimedTextWeight: i32 {
    Normal = 400, Bold = 700,
}}
RT_ENUM! { enum TimedTextWrapping: i32 {
    NoWrap = 0, Wrap = 1,
}}
RT_ENUM! { enum TimedTextWritingMode: i32 {
    LeftRightTopBottom = 0, RightLeftTopBottom = 1, TopBottomRightLeft = 2, TopBottomLeftRight = 3, LeftRight = 4, RightLeft = 5, TopBottom = 6,
}}
DEFINE_IID!(IID_IVideoStabilizationEffect, 134784592, 38552, 20055, 135, 123, 189, 124, 178, 238, 15, 138);
RT_INTERFACE!{interface IVideoStabilizationEffect(IVideoStabilizationEffectVtbl, IVideoStabilizationEffect_Abi): IInspectable(IInspectableVtbl) [IID_IVideoStabilizationEffect] {
    fn put_Enabled(&self, value: bool) -> HRESULT,
    fn get_Enabled(&self, out: *mut bool) -> HRESULT,
    fn add_EnabledChanged(&self, handler: <foundation::TypedEventHandler<VideoStabilizationEffect, VideoStabilizationEffectEnabledChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EnabledChanged(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn GetRecommendedStreamConfiguration(&self, controller: <super::devices::VideoDeviceController as RtType>::Abi, desiredProperties: <super::mediaproperties::VideoEncodingProperties as RtType>::Abi, out: *mut <super::capture::VideoStreamConfiguration as RtType>::Abi) -> HRESULT
}}
impl IVideoStabilizationEffect {
    #[inline] pub fn set_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Enabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Enabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_enabled_changed(&self, handler: &foundation::TypedEventHandler<VideoStabilizationEffect, VideoStabilizationEffectEnabledChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_EnabledChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_enabled_changed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_EnabledChanged)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_recommended_stream_configuration(&self, controller: &super::devices::VideoDeviceController, desiredProperties: &super::mediaproperties::VideoEncodingProperties) -> Result<Option<super::capture::VideoStreamConfiguration>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetRecommendedStreamConfiguration)(self.0.as_abi() as *const _ as *mut _, get_abi(controller) as *const _ as *mut _, get_abi(desiredProperties) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::capture::VideoStreamConfiguration::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VideoStabilizationEffect: IVideoStabilizationEffect}
RT_CLASS!{class VideoStabilizationEffectDefinition: super::effects::IVideoEffectDefinition}
impl RtActivatable<IActivationFactory> for VideoStabilizationEffectDefinition {}
DEFINE_CLSID!(VideoStabilizationEffectDefinition(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,86,105,100,101,111,83,116,97,98,105,108,105,122,97,116,105,111,110,69,102,102,101,99,116,68,101,102,105,110,105,116,105,111,110,0]) [CLSID_VideoStabilizationEffectDefinition]);
DEFINE_IID!(IID_IVideoStabilizationEffectEnabledChangedEventArgs, 410976040, 26555, 18195, 185, 0, 65, 104, 218, 22, 69, 41);
RT_INTERFACE!{interface IVideoStabilizationEffectEnabledChangedEventArgs(IVideoStabilizationEffectEnabledChangedEventArgsVtbl, IVideoStabilizationEffectEnabledChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IVideoStabilizationEffectEnabledChangedEventArgs] {
    fn get_Reason(&self, out: *mut VideoStabilizationEffectEnabledChangedReason) -> HRESULT
}}
impl IVideoStabilizationEffectEnabledChangedEventArgs {
    #[inline] pub fn get_reason(&self) -> Result<VideoStabilizationEffectEnabledChangedReason> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reason)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class VideoStabilizationEffectEnabledChangedEventArgs: IVideoStabilizationEffectEnabledChangedEventArgs}
RT_ENUM! { enum VideoStabilizationEffectEnabledChangedReason: i32 {
    Programmatic = 0, PixelRateTooHigh = 1, RunningSlowly = 2,
}}
DEFINE_IID!(IID_IVideoStreamDescriptor, 317590869, 39979, 17472, 128, 87, 44, 122, 144, 240, 203, 236);
RT_INTERFACE!{interface IVideoStreamDescriptor(IVideoStreamDescriptorVtbl, IVideoStreamDescriptor_Abi): IInspectable(IInspectableVtbl) [IID_IVideoStreamDescriptor] {
    fn get_EncodingProperties(&self, out: *mut <super::mediaproperties::VideoEncodingProperties as RtType>::Abi) -> HRESULT
}}
impl IVideoStreamDescriptor {
    #[inline] pub fn get_encoding_properties(&self) -> Result<Option<super::mediaproperties::VideoEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EncodingProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::mediaproperties::VideoEncodingProperties::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VideoStreamDescriptor: IVideoStreamDescriptor}
impl RtActivatable<IVideoStreamDescriptorFactory> for VideoStreamDescriptor {}
impl VideoStreamDescriptor {
    #[inline] pub fn create(encodingProperties: &super::mediaproperties::VideoEncodingProperties) -> Result<VideoStreamDescriptor> {
        <Self as RtActivatable<IVideoStreamDescriptorFactory>>::get_activation_factory().create(encodingProperties)
    }
}
DEFINE_CLSID!(VideoStreamDescriptor(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,86,105,100,101,111,83,116,114,101,97,109,68,101,115,99,114,105,112,116,111,114,0]) [CLSID_VideoStreamDescriptor]);
DEFINE_IID!(IID_IVideoStreamDescriptor2, 2335206928, 17726, 16520, 131, 45, 195, 111, 164, 249, 74, 243);
RT_INTERFACE!{interface IVideoStreamDescriptor2(IVideoStreamDescriptor2Vtbl, IVideoStreamDescriptor2_Abi): IInspectable(IInspectableVtbl) [IID_IVideoStreamDescriptor2] {
    fn Copy(&self, out: *mut <VideoStreamDescriptor as RtType>::Abi) -> HRESULT
}}
impl IVideoStreamDescriptor2 {
    #[inline] pub fn copy(&self) -> Result<Option<VideoStreamDescriptor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Copy)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoStreamDescriptor::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVideoStreamDescriptorFactory, 1229911761, 47989, 17362, 158, 94, 123, 121, 163, 175, 206, 212);
RT_INTERFACE!{static interface IVideoStreamDescriptorFactory(IVideoStreamDescriptorFactoryVtbl, IVideoStreamDescriptorFactory_Abi): IInspectable(IInspectableVtbl) [IID_IVideoStreamDescriptorFactory] {
    fn Create(&self, encodingProperties: <super::mediaproperties::VideoEncodingProperties as RtType>::Abi, out: *mut <VideoStreamDescriptor as RtType>::Abi) -> HRESULT
}}
impl IVideoStreamDescriptorFactory {
    #[inline] pub fn create(&self, encodingProperties: &super::mediaproperties::VideoEncodingProperties) -> Result<VideoStreamDescriptor> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(encodingProperties) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoStreamDescriptor::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVideoTrack, 2582886387, 58008, 17302, 187, 106, 165, 27, 230, 162, 162, 10);
RT_INTERFACE!{interface IVideoTrack(IVideoTrackVtbl, IVideoTrack_Abi): IInspectable(IInspectableVtbl) [IID_IVideoTrack] {
    fn add_OpenFailed(&self, handler: <foundation::TypedEventHandler<VideoTrack, VideoTrackOpenFailedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_OpenFailed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn GetEncodingProperties(&self, out: *mut <super::mediaproperties::VideoEncodingProperties as RtType>::Abi) -> HRESULT,
    fn get_PlaybackItem(&self, out: *mut <super::playback::MediaPlaybackItem as RtType>::Abi) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SupportInfo(&self, out: *mut <VideoTrackSupportInfo as RtType>::Abi) -> HRESULT
}}
impl IVideoTrack {
    #[inline] pub fn add_open_failed(&self, handler: &foundation::TypedEventHandler<VideoTrack, VideoTrackOpenFailedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_OpenFailed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_open_failed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_OpenFailed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_encoding_properties(&self) -> Result<Option<super::mediaproperties::VideoEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetEncodingProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::mediaproperties::VideoEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_playback_item(&self) -> Result<Option<super::playback::MediaPlaybackItem>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackItem)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::playback::MediaPlaybackItem::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Name)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_support_info(&self) -> Result<Option<VideoTrackSupportInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportInfo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoTrackSupportInfo::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VideoTrack: IMediaTrack}
DEFINE_IID!(IID_IVideoTrackOpenFailedEventArgs, 1987699249, 1273, 19586, 164, 238, 134, 2, 200, 187, 71, 84);
RT_INTERFACE!{interface IVideoTrackOpenFailedEventArgs(IVideoTrackOpenFailedEventArgsVtbl, IVideoTrackOpenFailedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IVideoTrackOpenFailedEventArgs] {
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl IVideoTrackOpenFailedEventArgs {
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class VideoTrackOpenFailedEventArgs: IVideoTrackOpenFailedEventArgs}
DEFINE_IID!(IID_IVideoTrackSupportInfo, 1270166688, 64607, 17677, 143, 240, 119, 141, 89, 4, 134, 222);
RT_INTERFACE!{interface IVideoTrackSupportInfo(IVideoTrackSupportInfoVtbl, IVideoTrackSupportInfo_Abi): IInspectable(IInspectableVtbl) [IID_IVideoTrackSupportInfo] {
    fn get_DecoderStatus(&self, out: *mut MediaDecoderStatus) -> HRESULT,
    fn get_MediaSourceStatus(&self, out: *mut MediaSourceStatus) -> HRESULT
}}
impl IVideoTrackSupportInfo {
    #[inline] pub fn get_decoder_status(&self) -> Result<MediaDecoderStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DecoderStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_media_source_status(&self) -> Result<MediaSourceStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaSourceStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class VideoTrackSupportInfo: IVideoTrackSupportInfo}
pub mod preview { // Windows.Media.Core.Preview
use crate::prelude::*;
RT_CLASS!{static class SoundLevelBroker}
impl RtActivatable<ISoundLevelBrokerStatics> for SoundLevelBroker {}
impl SoundLevelBroker {
    #[inline] pub fn get_sound_level() -> Result<super::super::SoundLevel> {
        <Self as RtActivatable<ISoundLevelBrokerStatics>>::get_activation_factory().get_sound_level()
    }
    #[inline] pub fn add_sound_level_changed(handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<ISoundLevelBrokerStatics>>::get_activation_factory().add_sound_level_changed(handler)
    }
    #[inline] pub fn remove_sound_level_changed(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<ISoundLevelBrokerStatics>>::get_activation_factory().remove_sound_level_changed(token)
    }
}
DEFINE_CLSID!(SoundLevelBroker(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,67,111,114,101,46,80,114,101,118,105,101,119,46,83,111,117,110,100,76,101,118,101,108,66,114,111,107,101,114,0]) [CLSID_SoundLevelBroker]);
DEFINE_IID!(IID_ISoundLevelBrokerStatics, 1784887649, 56301, 17996, 160, 154, 51, 65, 47, 92, 170, 63);
RT_INTERFACE!{static interface ISoundLevelBrokerStatics(ISoundLevelBrokerStaticsVtbl, ISoundLevelBrokerStatics_Abi): IInspectable(IInspectableVtbl) [IID_ISoundLevelBrokerStatics] {
    fn get_SoundLevel(&self, out: *mut super::super::SoundLevel) -> HRESULT,
    fn add_SoundLevelChanged(&self, handler: <foundation::EventHandler<IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SoundLevelChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ISoundLevelBrokerStatics {
    #[inline] pub fn get_sound_level(&self) -> Result<super::super::SoundLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SoundLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_sound_level_changed(&self, handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SoundLevelChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_sound_level_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SoundLevelChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
} // Windows.Media.Core.Preview
} // Windows.Media.Core
pub mod devices { // Windows.Media.Devices
use crate::prelude::*;
DEFINE_IID!(IID_IAdvancedPhotoCaptureSettings, 150177338, 24, 17499, 147, 210, 100, 109, 28, 94, 208, 92);
RT_INTERFACE!{interface IAdvancedPhotoCaptureSettings(IAdvancedPhotoCaptureSettingsVtbl, IAdvancedPhotoCaptureSettings_Abi): IInspectable(IInspectableVtbl) [IID_IAdvancedPhotoCaptureSettings] {
    fn get_Mode(&self, out: *mut AdvancedPhotoMode) -> HRESULT,
    fn put_Mode(&self, value: AdvancedPhotoMode) -> HRESULT
}}
impl IAdvancedPhotoCaptureSettings {
    #[inline] pub fn get_mode(&self) -> Result<AdvancedPhotoMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_mode(&self, value: AdvancedPhotoMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Mode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AdvancedPhotoCaptureSettings: IAdvancedPhotoCaptureSettings}
impl RtActivatable<IActivationFactory> for AdvancedPhotoCaptureSettings {}
DEFINE_CLSID!(AdvancedPhotoCaptureSettings(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,68,101,118,105,99,101,115,46,65,100,118,97,110,99,101,100,80,104,111,116,111,67,97,112,116,117,114,101,83,101,116,116,105,110,103,115,0]) [CLSID_AdvancedPhotoCaptureSettings]);
DEFINE_IID!(IID_IAdvancedPhotoControl, 3316733062, 36865, 18050, 147, 9, 104, 234, 224, 8, 14, 236);
RT_INTERFACE!{interface IAdvancedPhotoControl(IAdvancedPhotoControlVtbl, IAdvancedPhotoControl_Abi): IInspectable(IInspectableVtbl) [IID_IAdvancedPhotoControl] {
    fn get_Supported(&self, out: *mut bool) -> HRESULT,
    fn get_SupportedModes(&self, out: *mut <foundation::collections::IVectorView<AdvancedPhotoMode> as RtType>::Abi) -> HRESULT,
    fn get_Mode(&self, out: *mut AdvancedPhotoMode) -> HRESULT,
    fn Configure(&self, settings: <AdvancedPhotoCaptureSettings as RtType>::Abi) -> HRESULT
}}
impl IAdvancedPhotoControl {
    #[inline] pub fn get_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Supported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_modes(&self) -> Result<Option<foundation::collections::IVectorView<AdvancedPhotoMode>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedModes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_mode(&self) -> Result<AdvancedPhotoMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn configure(&self, settings: &AdvancedPhotoCaptureSettings) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Configure)(self.0.as_abi() as *const _ as *mut _, get_abi(settings) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AdvancedPhotoControl: IAdvancedPhotoControl}
RT_ENUM! { enum AdvancedPhotoMode: i32 {
    Auto = 0, Standard = 1, Hdr = 2, LowLight = 3,
}}
DEFINE_IID!(IID_IAdvancedVideoCaptureDeviceController, 3731879123, 11158, 17795, 128, 171, 181, 176, 29, 198, 168, 215);
RT_INTERFACE!{interface IAdvancedVideoCaptureDeviceController(IAdvancedVideoCaptureDeviceControllerVtbl, IAdvancedVideoCaptureDeviceController_Abi): IInspectable(IInspectableVtbl) [IID_IAdvancedVideoCaptureDeviceController] {
    fn SetDeviceProperty(&self, propertyId: HSTRING, propertyValue: <IInspectable as RtType>::Abi) -> HRESULT,
    fn GetDeviceProperty(&self, propertyId: HSTRING, out: *mut <IInspectable as RtType>::Abi) -> HRESULT
}}
impl IAdvancedVideoCaptureDeviceController {
    #[inline] pub fn set_device_property(&self, propertyId: &HStringArg, propertyValue: &IInspectable) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetDeviceProperty)(self.0.as_abi() as *const _ as *mut _, propertyId.get(), get_abi(propertyValue) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_device_property(&self, propertyId: &HStringArg) -> Result<Option<IInspectable>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceProperty)(self.0.as_abi() as *const _ as *mut _, propertyId.get(), &mut out);
        if hr == S_OK { Ok(IInspectable::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAdvancedVideoCaptureDeviceController2, 2344177551, 61722, 17371, 180, 2, 17, 147, 11, 128, 174, 86);
RT_INTERFACE!{interface IAdvancedVideoCaptureDeviceController2(IAdvancedVideoCaptureDeviceController2Vtbl, IAdvancedVideoCaptureDeviceController2_Abi): IInspectable(IInspectableVtbl) [IID_IAdvancedVideoCaptureDeviceController2] {
    fn get_LowLagPhotoSequence(&self, out: *mut <LowLagPhotoSequenceControl as RtType>::Abi) -> HRESULT,
    fn get_LowLagPhoto(&self, out: *mut <LowLagPhotoControl as RtType>::Abi) -> HRESULT,
    fn get_SceneModeControl(&self, out: *mut <SceneModeControl as RtType>::Abi) -> HRESULT,
    fn get_TorchControl(&self, out: *mut <TorchControl as RtType>::Abi) -> HRESULT,
    fn get_FlashControl(&self, out: *mut <FlashControl as RtType>::Abi) -> HRESULT,
    fn get_WhiteBalanceControl(&self, out: *mut <WhiteBalanceControl as RtType>::Abi) -> HRESULT,
    fn get_ExposureControl(&self, out: *mut <ExposureControl as RtType>::Abi) -> HRESULT,
    fn get_FocusControl(&self, out: *mut <FocusControl as RtType>::Abi) -> HRESULT,
    fn get_ExposureCompensationControl(&self, out: *mut <ExposureCompensationControl as RtType>::Abi) -> HRESULT,
    fn get_IsoSpeedControl(&self, out: *mut <IsoSpeedControl as RtType>::Abi) -> HRESULT,
    fn get_RegionsOfInterestControl(&self, out: *mut <RegionsOfInterestControl as RtType>::Abi) -> HRESULT,
    fn get_PrimaryUse(&self, out: *mut CaptureUse) -> HRESULT,
    fn put_PrimaryUse(&self, value: CaptureUse) -> HRESULT
}}
impl IAdvancedVideoCaptureDeviceController2 {
    #[inline] pub fn get_low_lag_photo_sequence(&self) -> Result<Option<LowLagPhotoSequenceControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_LowLagPhotoSequence)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(LowLagPhotoSequenceControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_low_lag_photo(&self) -> Result<Option<LowLagPhotoControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_LowLagPhoto)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(LowLagPhotoControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_scene_mode_control(&self) -> Result<Option<SceneModeControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SceneModeControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SceneModeControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_torch_control(&self) -> Result<Option<TorchControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TorchControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(TorchControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_flash_control(&self) -> Result<Option<FlashControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FlashControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(FlashControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_white_balance_control(&self) -> Result<Option<WhiteBalanceControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_WhiteBalanceControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(WhiteBalanceControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_exposure_control(&self) -> Result<Option<ExposureControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExposureControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ExposureControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_focus_control(&self) -> Result<Option<FocusControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FocusControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(FocusControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_exposure_compensation_control(&self) -> Result<Option<ExposureCompensationControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExposureCompensationControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ExposureCompensationControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_iso_speed_control(&self) -> Result<Option<IsoSpeedControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsoSpeedControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IsoSpeedControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_regions_of_interest_control(&self) -> Result<Option<RegionsOfInterestControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_RegionsOfInterestControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(RegionsOfInterestControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_primary_use(&self) -> Result<CaptureUse> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PrimaryUse)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_primary_use(&self, value: CaptureUse) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PrimaryUse)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAdvancedVideoCaptureDeviceController3, 2844495668, 60941, 18188, 185, 240, 66, 41, 196, 187, 208, 137);
RT_INTERFACE!{interface IAdvancedVideoCaptureDeviceController3(IAdvancedVideoCaptureDeviceController3Vtbl, IAdvancedVideoCaptureDeviceController3_Abi): IInspectable(IInspectableVtbl) [IID_IAdvancedVideoCaptureDeviceController3] {
    fn get_VariablePhotoSequenceController(&self, out: *mut <core::VariablePhotoSequenceController as RtType>::Abi) -> HRESULT,
    fn get_PhotoConfirmationControl(&self, out: *mut <PhotoConfirmationControl as RtType>::Abi) -> HRESULT,
    fn get_ZoomControl(&self, out: *mut <ZoomControl as RtType>::Abi) -> HRESULT
}}
impl IAdvancedVideoCaptureDeviceController3 {
    #[inline] pub fn get_variable_photo_sequence_controller(&self) -> Result<Option<core::VariablePhotoSequenceController>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VariablePhotoSequenceController)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(core::VariablePhotoSequenceController::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_photo_confirmation_control(&self) -> Result<Option<PhotoConfirmationControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhotoConfirmationControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PhotoConfirmationControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_zoom_control(&self) -> Result<Option<ZoomControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ZoomControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ZoomControl::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAdvancedVideoCaptureDeviceController4, 3936337839, 54129, 16835, 154, 23, 130, 74, 135, 235, 223, 210);
RT_INTERFACE!{interface IAdvancedVideoCaptureDeviceController4(IAdvancedVideoCaptureDeviceController4Vtbl, IAdvancedVideoCaptureDeviceController4_Abi): IInspectable(IInspectableVtbl) [IID_IAdvancedVideoCaptureDeviceController4] {
    fn get_ExposurePriorityVideoControl(&self, out: *mut <ExposurePriorityVideoControl as RtType>::Abi) -> HRESULT,
    fn get_DesiredOptimization(&self, out: *mut MediaCaptureOptimization) -> HRESULT,
    fn put_DesiredOptimization(&self, value: MediaCaptureOptimization) -> HRESULT,
    fn get_HdrVideoControl(&self, out: *mut <HdrVideoControl as RtType>::Abi) -> HRESULT,
    fn get_OpticalImageStabilizationControl(&self, out: *mut <OpticalImageStabilizationControl as RtType>::Abi) -> HRESULT,
    fn get_AdvancedPhotoControl(&self, out: *mut <AdvancedPhotoControl as RtType>::Abi) -> HRESULT
}}
impl IAdvancedVideoCaptureDeviceController4 {
    #[inline] pub fn get_exposure_priority_video_control(&self) -> Result<Option<ExposurePriorityVideoControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExposurePriorityVideoControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ExposurePriorityVideoControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_desired_optimization(&self) -> Result<MediaCaptureOptimization> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DesiredOptimization)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_optimization(&self, value: MediaCaptureOptimization) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DesiredOptimization)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_hdr_video_control(&self) -> Result<Option<HdrVideoControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_HdrVideoControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HdrVideoControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_optical_image_stabilization_control(&self) -> Result<Option<OpticalImageStabilizationControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_OpticalImageStabilizationControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(OpticalImageStabilizationControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_advanced_photo_control(&self) -> Result<Option<AdvancedPhotoControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AdvancedPhotoControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AdvancedPhotoControl::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAdvancedVideoCaptureDeviceController5, 860957463, 47563, 18979, 184, 117, 249, 234, 171, 83, 84, 146);
RT_INTERFACE!{interface IAdvancedVideoCaptureDeviceController5(IAdvancedVideoCaptureDeviceController5Vtbl, IAdvancedVideoCaptureDeviceController5_Abi): IInspectable(IInspectableVtbl) [IID_IAdvancedVideoCaptureDeviceController5] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn GetDevicePropertyById(&self, propertyId: HSTRING, maxPropertyValueSize: <foundation::IReference<u32> as RtType>::Abi, out: *mut <VideoDeviceControllerGetDevicePropertyResult as RtType>::Abi) -> HRESULT,
    fn SetDevicePropertyById(&self, propertyId: HSTRING, propertyValue: <IInspectable as RtType>::Abi, out: *mut VideoDeviceControllerSetDevicePropertyStatus) -> HRESULT,
    fn GetDevicePropertyByExtendedId(&self, extendedPropertyIdSize: u32, extendedPropertyId: *mut u8, maxPropertyValueSize: <foundation::IReference<u32> as RtType>::Abi, out: *mut <VideoDeviceControllerGetDevicePropertyResult as RtType>::Abi) -> HRESULT,
    fn SetDevicePropertyByExtendedId(&self, extendedPropertyIdSize: u32, extendedPropertyId: *mut u8, propertyValueSize: u32, propertyValue: *mut u8, out: *mut VideoDeviceControllerSetDevicePropertyStatus) -> HRESULT
}}
impl IAdvancedVideoCaptureDeviceController5 {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_property_by_id(&self, propertyId: &HStringArg, maxPropertyValueSize: &foundation::IReference<u32>) -> Result<Option<VideoDeviceControllerGetDevicePropertyResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDevicePropertyById)(self.0.as_abi() as *const _ as *mut _, propertyId.get(), get_abi(maxPropertyValueSize) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoDeviceControllerGetDevicePropertyResult::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_device_property_by_id(&self, propertyId: &HStringArg, propertyValue: &IInspectable) -> Result<VideoDeviceControllerSetDevicePropertyStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).SetDevicePropertyById)(self.0.as_abi() as *const _ as *mut _, propertyId.get(), get_abi(propertyValue) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_device_property_by_extended_id(&self, extendedPropertyId: &[u8], maxPropertyValueSize: &foundation::IReference<u32>) -> Result<Option<VideoDeviceControllerGetDevicePropertyResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDevicePropertyByExtendedId)(self.0.as_abi() as *const _ as *mut _, extendedPropertyId.len() as u32, extendedPropertyId.as_ptr() as *mut _, get_abi(maxPropertyValueSize) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoDeviceControllerGetDevicePropertyResult::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_device_property_by_extended_id(&self, extendedPropertyId: &[u8], propertyValue: &[u8]) -> Result<VideoDeviceControllerSetDevicePropertyStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).SetDevicePropertyByExtendedId)(self.0.as_abi() as *const _ as *mut _, extendedPropertyId.len() as u32, extendedPropertyId.as_ptr() as *mut _, propertyValue.len() as u32, propertyValue.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAdvancedVideoCaptureDeviceController6, 3059104339, 26785, 17591, 159, 137, 181, 250, 151, 172, 12, 190);
RT_INTERFACE!{interface IAdvancedVideoCaptureDeviceController6(IAdvancedVideoCaptureDeviceController6Vtbl, IAdvancedVideoCaptureDeviceController6_Abi): IInspectable(IInspectableVtbl) [IID_IAdvancedVideoCaptureDeviceController6] {
    fn get_VideoTemporalDenoisingControl(&self, out: *mut <VideoTemporalDenoisingControl as RtType>::Abi) -> HRESULT
}}
impl IAdvancedVideoCaptureDeviceController6 {
    #[inline] pub fn get_video_temporal_denoising_control(&self) -> Result<Option<VideoTemporalDenoisingControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoTemporalDenoisingControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoTemporalDenoisingControl::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAudioDeviceController, 3990135688, 31175, 20348, 144, 232, 239, 147, 75, 33, 88, 10);
RT_INTERFACE!{interface IAudioDeviceController(IAudioDeviceControllerVtbl, IAudioDeviceController_Abi): IInspectable(IInspectableVtbl) [IID_IAudioDeviceController] {
    fn put_Muted(&self, value: bool) -> HRESULT,
    fn get_Muted(&self, out: *mut bool) -> HRESULT,
    fn put_VolumePercent(&self, value: f32) -> HRESULT,
    fn get_VolumePercent(&self, out: *mut f32) -> HRESULT
}}
impl IAudioDeviceController {
    #[inline] pub fn set_muted(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Muted)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_muted(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Muted)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_volume_percent(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_VolumePercent)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_volume_percent(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VolumePercent)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioDeviceController: IAudioDeviceController}
DEFINE_IID!(IID_IAudioDeviceModule, 2261756982, 18369, 19251, 152, 82, 135, 115, 236, 75, 225, 35);
RT_INTERFACE!{interface IAudioDeviceModule(IAudioDeviceModuleVtbl, IAudioDeviceModule_Abi): IInspectable(IInspectableVtbl) [IID_IAudioDeviceModule] {
    fn get_ClassId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_InstanceId(&self, out: *mut u32) -> HRESULT,
    fn get_MajorVersion(&self, out: *mut u32) -> HRESULT,
    fn get_MinorVersion(&self, out: *mut u32) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SendCommandAsync(&self, command: <super::super::storage::streams::IBuffer as RtType>::Abi, out: *mut <foundation::IAsyncOperation<ModuleCommandResult> as RtType>::Abi) -> HRESULT
}}
impl IAudioDeviceModule {
    #[inline] pub fn get_class_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ClassId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DisplayName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_instance_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InstanceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_major_version(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MajorVersion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_minor_version(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinorVersion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn send_command_async(&self, command: &super::super::storage::streams::IBuffer) -> Result<foundation::IAsyncOperation<ModuleCommandResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SendCommandAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(command) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioDeviceModule: IAudioDeviceModule}
DEFINE_IID!(IID_IAudioDeviceModuleNotificationEventArgs, 3823357103, 8780, 18622, 149, 107, 154, 19, 19, 78, 150, 232);
RT_INTERFACE!{interface IAudioDeviceModuleNotificationEventArgs(IAudioDeviceModuleNotificationEventArgsVtbl, IAudioDeviceModuleNotificationEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAudioDeviceModuleNotificationEventArgs] {
    fn get_Module(&self, out: *mut <AudioDeviceModule as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_NotificationData(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IAudioDeviceModuleNotificationEventArgs {
    #[inline] pub fn get_module(&self) -> Result<Option<AudioDeviceModule>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Module)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioDeviceModule::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_notification_data(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_NotificationData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioDeviceModuleNotificationEventArgs: IAudioDeviceModuleNotificationEventArgs}
DEFINE_IID!(IID_IAudioDeviceModulesManager, 1789135949, 38410, 19740, 179, 24, 0, 34, 96, 69, 71, 237);
RT_INTERFACE!{interface IAudioDeviceModulesManager(IAudioDeviceModulesManagerVtbl, IAudioDeviceModulesManager_Abi): IInspectable(IInspectableVtbl) [IID_IAudioDeviceModulesManager] {
    fn add_ModuleNotificationReceived(&self, handler: <foundation::TypedEventHandler<AudioDeviceModulesManager, AudioDeviceModuleNotificationEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ModuleNotificationReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn FindAllById(&self, moduleId: HSTRING, out: *mut <foundation::collections::IVectorView<AudioDeviceModule> as RtType>::Abi) -> HRESULT,
    fn FindAll(&self, out: *mut <foundation::collections::IVectorView<AudioDeviceModule> as RtType>::Abi) -> HRESULT
}}
impl IAudioDeviceModulesManager {
    #[inline] pub fn add_module_notification_received(&self, handler: &foundation::TypedEventHandler<AudioDeviceModulesManager, AudioDeviceModuleNotificationEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ModuleNotificationReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_module_notification_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ModuleNotificationReceived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn find_all_by_id(&self, moduleId: &HStringArg) -> Result<Option<foundation::collections::IVectorView<AudioDeviceModule>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindAllById)(self.0.as_abi() as *const _ as *mut _, moduleId.get(), &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all(&self) -> Result<Option<foundation::collections::IVectorView<AudioDeviceModule>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindAll)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioDeviceModulesManager: IAudioDeviceModulesManager}
impl RtActivatable<IAudioDeviceModulesManagerFactory> for AudioDeviceModulesManager {}
impl AudioDeviceModulesManager {
    #[inline] pub fn create(deviceId: &HStringArg) -> Result<AudioDeviceModulesManager> {
        <Self as RtActivatable<IAudioDeviceModulesManagerFactory>>::get_activation_factory().create(deviceId)
    }
}
DEFINE_CLSID!(AudioDeviceModulesManager(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,68,101,118,105,99,101,115,46,65,117,100,105,111,68,101,118,105,99,101,77,111,100,117,108,101,115,77,97,110,97,103,101,114,0]) [CLSID_AudioDeviceModulesManager]);
DEFINE_IID!(IID_IAudioDeviceModulesManagerFactory, 2377135728, 58957, 18291, 150, 192, 188, 126, 191, 14, 6, 63);
RT_INTERFACE!{static interface IAudioDeviceModulesManagerFactory(IAudioDeviceModulesManagerFactoryVtbl, IAudioDeviceModulesManagerFactory_Abi): IInspectable(IInspectableVtbl) [IID_IAudioDeviceModulesManagerFactory] {
    fn Create(&self, deviceId: HSTRING, out: *mut <AudioDeviceModulesManager as RtType>::Abi) -> HRESULT
}}
impl IAudioDeviceModulesManagerFactory {
    #[inline] pub fn create(&self, deviceId: &HStringArg) -> Result<AudioDeviceModulesManager> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(AudioDeviceModulesManager::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum AudioDeviceRole: i32 {
    Default = 0, Communications = 1,
}}
RT_ENUM! { enum AutoFocusRange: i32 {
    FullRange = 0, Macro = 1, Normal = 2,
}}
DEFINE_IID!(IID_ICallControl, 2770391254, 44685, 17883, 128, 17, 202, 73, 211, 179, 229, 120);
RT_INTERFACE!{interface ICallControl(ICallControlVtbl, ICallControl_Abi): IInspectable(IInspectableVtbl) [IID_ICallControl] {
    fn IndicateNewIncomingCall(&self, enableRinger: bool, callerId: HSTRING, out: *mut u64) -> HRESULT,
    fn IndicateNewOutgoingCall(&self, out: *mut u64) -> HRESULT,
    fn IndicateActiveCall(&self, callToken: u64) -> HRESULT,
    fn EndCall(&self, callToken: u64) -> HRESULT,
    fn get_HasRinger(&self, out: *mut bool) -> HRESULT,
    fn add_AnswerRequested(&self, handler: <CallControlEventHandler as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AnswerRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_HangUpRequested(&self, handler: <CallControlEventHandler as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_HangUpRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_DialRequested(&self, handler: <DialRequestedEventHandler as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DialRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_RedialRequested(&self, handler: <RedialRequestedEventHandler as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RedialRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_KeypadPressed(&self, handler: <KeypadPressedEventHandler as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_KeypadPressed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_AudioTransferRequested(&self, handler: <CallControlEventHandler as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AudioTransferRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICallControl {
    #[inline] pub fn indicate_new_incoming_call(&self, enableRinger: bool, callerId: &HStringArg) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IndicateNewIncomingCall)(self.0.as_abi() as *const _ as *mut _, enableRinger, callerId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn indicate_new_outgoing_call(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IndicateNewOutgoingCall)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn indicate_active_call(&self, callToken: u64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).IndicateActiveCall)(self.0.as_abi() as *const _ as *mut _, callToken);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn end_call(&self, callToken: u64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).EndCall)(self.0.as_abi() as *const _ as *mut _, callToken);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_has_ringer(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HasRinger)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_answer_requested(&self, handler: &CallControlEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AnswerRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_answer_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AnswerRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_hang_up_requested(&self, handler: &CallControlEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_HangUpRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_hang_up_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_HangUpRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_dial_requested(&self, handler: &DialRequestedEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_DialRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_dial_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_DialRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_redial_requested(&self, handler: &RedialRequestedEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_RedialRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_redial_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_RedialRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_keypad_pressed(&self, handler: &KeypadPressedEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_KeypadPressed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_keypad_pressed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_KeypadPressed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_audio_transfer_requested(&self, handler: &CallControlEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AudioTransferRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_audio_transfer_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AudioTransferRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CallControl: ICallControl}
impl RtActivatable<ICallControlStatics> for CallControl {}
impl CallControl {
    #[inline] pub fn get_default() -> Result<Option<CallControl>> {
        <Self as RtActivatable<ICallControlStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn from_id(deviceId: &HStringArg) -> Result<Option<CallControl>> {
        <Self as RtActivatable<ICallControlStatics>>::get_activation_factory().from_id(deviceId)
    }
}
DEFINE_CLSID!(CallControl(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,68,101,118,105,99,101,115,46,67,97,108,108,67,111,110,116,114,111,108,0]) [CLSID_CallControl]);
DEFINE_IID!(IID_CallControlEventHandler, 1500476831, 20703, 17492, 188, 99, 77, 61, 1, 182, 25, 88);
RT_DELEGATE!{delegate CallControlEventHandler(CallControlEventHandlerVtbl, CallControlEventHandler_Abi, CallControlEventHandlerImpl) [IID_CallControlEventHandler] {
    fn Invoke(&self, sender: <CallControl as RtType>::Abi) -> HRESULT
}}
impl CallControlEventHandler {
    #[inline] pub fn invoke(&self, sender: &CallControl) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Invoke)(self.0.as_abi() as *const _ as *mut _, get_abi(sender) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICallControlStatics, 60054229, 34219, 16609, 175, 25, 86, 201, 67, 3, 176, 25);
RT_INTERFACE!{static interface ICallControlStatics(ICallControlStaticsVtbl, ICallControlStatics_Abi): IInspectable(IInspectableVtbl) [IID_ICallControlStatics] {
    fn GetDefault(&self, out: *mut <CallControl as RtType>::Abi) -> HRESULT,
    fn FromId(&self, deviceId: HSTRING, out: *mut <CallControl as RtType>::Abi) -> HRESULT
}}
impl ICallControlStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<CallControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CallControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id(&self, deviceId: &HStringArg) -> Result<Option<CallControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromId)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(CallControl::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum CameraStreamState: i32 {
    NotStreaming = 0, Streaming = 1, BlockedForPrivacy = 2, Shutdown = 3,
}}
RT_ENUM! { enum CaptureSceneMode: i32 {
    Auto = 0, Manual = 1, Macro = 2, Portrait = 3, Sport = 4, Snow = 5, Night = 6, Beach = 7, Sunset = 8, Candlelight = 9, Landscape = 10, NightPortrait = 11, Backlit = 12,
}}
RT_ENUM! { enum CaptureUse: i32 {
    None = 0, Photo = 1, Video = 2,
}}
RT_ENUM! { enum ColorTemperaturePreset: i32 {
    Auto = 0, Manual = 1, Cloudy = 2, Daylight = 3, Flash = 4, Fluorescent = 5, Tungsten = 6, Candlelight = 7,
}}
RT_CLASS!{class DefaultAudioCaptureDeviceChangedEventArgs: IDefaultAudioDeviceChangedEventArgs}
DEFINE_IID!(IID_IDefaultAudioDeviceChangedEventArgs, 286230575, 7173, 18007, 161, 142, 71, 201, 182, 159, 7, 171);
RT_INTERFACE!{interface IDefaultAudioDeviceChangedEventArgs(IDefaultAudioDeviceChangedEventArgsVtbl, IDefaultAudioDeviceChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IDefaultAudioDeviceChangedEventArgs] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Role(&self, out: *mut AudioDeviceRole) -> HRESULT
}}
impl IDefaultAudioDeviceChangedEventArgs {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_role(&self) -> Result<AudioDeviceRole> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Role)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DefaultAudioRenderDeviceChangedEventArgs: IDefaultAudioDeviceChangedEventArgs}
DEFINE_IID!(IID_IDialRequestedEventArgs, 58430110, 38204, 17030, 136, 102, 79, 15, 55, 108, 133, 90);
RT_INTERFACE!{interface IDialRequestedEventArgs(IDialRequestedEventArgsVtbl, IDialRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IDialRequestedEventArgs] {
    fn Handled(&self) -> HRESULT,
    fn get_Contact(&self, out: *mut <IInspectable as RtType>::Abi) -> HRESULT
}}
impl IDialRequestedEventArgs {
    #[inline] pub fn handled(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Handled)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_contact(&self) -> Result<Option<IInspectable>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Contact)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IInspectable::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DialRequestedEventArgs: IDialRequestedEventArgs}
DEFINE_IID!(IID_DialRequestedEventHandler, 1522270171, 49695, 19396, 137, 27, 37, 126, 40, 193, 177, 164);
RT_DELEGATE!{delegate DialRequestedEventHandler(DialRequestedEventHandlerVtbl, DialRequestedEventHandler_Abi, DialRequestedEventHandlerImpl) [IID_DialRequestedEventHandler] {
    fn Invoke(&self, sender: <CallControl as RtType>::Abi, e: <DialRequestedEventArgs as RtType>::Abi) -> HRESULT
}}
impl DialRequestedEventHandler {
    #[inline] pub fn invoke(&self, sender: &CallControl, e: &DialRequestedEventArgs) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Invoke)(self.0.as_abi() as *const _ as *mut _, get_abi(sender) as *const _ as *mut _, get_abi(e) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IExposureCompensationControl, 2177427508, 56556, 16401, 166, 16, 31, 56, 71, 230, 74, 202);
RT_INTERFACE!{interface IExposureCompensationControl(IExposureCompensationControlVtbl, IExposureCompensationControl_Abi): IInspectable(IInspectableVtbl) [IID_IExposureCompensationControl] {
    fn get_Supported(&self, out: *mut bool) -> HRESULT,
    fn get_Min(&self, out: *mut f32) -> HRESULT,
    fn get_Max(&self, out: *mut f32) -> HRESULT,
    fn get_Step(&self, out: *mut f32) -> HRESULT,
    fn get_Value(&self, out: *mut f32) -> HRESULT,
    fn SetValueAsync(&self, value: f32, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IExposureCompensationControl {
    #[inline] pub fn get_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Supported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Min)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Max)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_step(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Step)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Value)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_value_async(&self, value: f32) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetValueAsync)(self.0.as_abi() as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ExposureCompensationControl: IExposureCompensationControl}
DEFINE_IID!(IID_IExposureControl, 166251490, 44438, 20264, 160, 224, 150, 237, 126, 27, 95, 210);
RT_INTERFACE!{interface IExposureControl(IExposureControlVtbl, IExposureControl_Abi): IInspectable(IInspectableVtbl) [IID_IExposureControl] {
    fn get_Supported(&self, out: *mut bool) -> HRESULT,
    fn get_Auto(&self, out: *mut bool) -> HRESULT,
    fn SetAutoAsync(&self, value: bool, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn get_Min(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Max(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Step(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Value(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn SetValueAsync(&self, shutterDuration: foundation::TimeSpan, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IExposureControl {
    #[inline] pub fn get_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Supported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_auto(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Auto)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto_async(&self, value: bool) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetAutoAsync)(self.0.as_abi() as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_min(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Min)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Max)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_step(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Step)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Value)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_value_async(&self, shutterDuration: foundation::TimeSpan) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetValueAsync)(self.0.as_abi() as *const _ as *mut _, shutterDuration, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ExposureControl: IExposureControl}
DEFINE_IID!(IID_IExposurePriorityVideoControl, 749879459, 20840, 17009, 158, 165, 71, 98, 26, 152, 163, 82);
RT_INTERFACE!{interface IExposurePriorityVideoControl(IExposurePriorityVideoControlVtbl, IExposurePriorityVideoControl_Abi): IInspectable(IInspectableVtbl) [IID_IExposurePriorityVideoControl] {
    fn get_Supported(&self, out: *mut bool) -> HRESULT,
    fn get_Enabled(&self, out: *mut bool) -> HRESULT,
    fn put_Enabled(&self, value: bool) -> HRESULT
}}
impl IExposurePriorityVideoControl {
    #[inline] pub fn get_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Supported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Enabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Enabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ExposurePriorityVideoControl: IExposurePriorityVideoControl}
DEFINE_IID!(IID_IFlashControl, 3740540350, 32104, 17891, 140, 15, 190, 123, 179, 40, 55, 208);
RT_INTERFACE!{interface IFlashControl(IFlashControlVtbl, IFlashControl_Abi): IInspectable(IInspectableVtbl) [IID_IFlashControl] {
    fn get_Supported(&self, out: *mut bool) -> HRESULT,
    fn get_PowerSupported(&self, out: *mut bool) -> HRESULT,
    fn get_RedEyeReductionSupported(&self, out: *mut bool) -> HRESULT,
    fn get_Enabled(&self, out: *mut bool) -> HRESULT,
    fn put_Enabled(&self, value: bool) -> HRESULT,
    fn get_Auto(&self, out: *mut bool) -> HRESULT,
    fn put_Auto(&self, value: bool) -> HRESULT,
    fn get_RedEyeReduction(&self, out: *mut bool) -> HRESULT,
    fn put_RedEyeReduction(&self, value: bool) -> HRESULT,
    fn get_PowerPercent(&self, out: *mut f32) -> HRESULT,
    fn put_PowerPercent(&self, value: f32) -> HRESULT
}}
impl IFlashControl {
    #[inline] pub fn get_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Supported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_power_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PowerSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_red_eye_reduction_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RedEyeReductionSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Enabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Enabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_auto(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Auto)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Auto)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_red_eye_reduction(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RedEyeReduction)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_red_eye_reduction(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_RedEyeReduction)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_power_percent(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PowerPercent)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_power_percent(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PowerPercent)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class FlashControl: IFlashControl}
DEFINE_IID!(IID_IFlashControl2, 2099891358, 30177, 19191, 189, 125, 78, 56, 225, 192, 108, 214);
RT_INTERFACE!{interface IFlashControl2(IFlashControl2Vtbl, IFlashControl2_Abi): IInspectable(IInspectableVtbl) [IID_IFlashControl2] {
    fn get_AssistantLightSupported(&self, out: *mut bool) -> HRESULT,
    fn get_AssistantLightEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_AssistantLightEnabled(&self, value: bool) -> HRESULT
}}
impl IFlashControl2 {
    #[inline] pub fn get_assistant_light_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AssistantLightSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_assistant_light_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AssistantLightEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_assistant_light_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AssistantLightEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IFocusControl, 3235416566, 21032, 17491, 177, 83, 133, 96, 101, 146, 178, 56);
RT_INTERFACE!{interface IFocusControl(IFocusControlVtbl, IFocusControl_Abi): IInspectable(IInspectableVtbl) [IID_IFocusControl] {
    fn get_Supported(&self, out: *mut bool) -> HRESULT,
    fn get_SupportedPresets(&self, out: *mut <foundation::collections::IVectorView<FocusPreset> as RtType>::Abi) -> HRESULT,
    fn get_Preset(&self, out: *mut FocusPreset) -> HRESULT,
    fn SetPresetAsync(&self, preset: FocusPreset, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn SetPresetWithCompletionOptionAsync(&self, preset: FocusPreset, completeBeforeFocus: bool, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn get_Min(&self, out: *mut u32) -> HRESULT,
    fn get_Max(&self, out: *mut u32) -> HRESULT,
    fn get_Step(&self, out: *mut u32) -> HRESULT,
    fn get_Value(&self, out: *mut u32) -> HRESULT,
    fn SetValueAsync(&self, focus: u32, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn FocusAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IFocusControl {
    #[inline] pub fn get_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Supported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_presets(&self) -> Result<Option<foundation::collections::IVectorView<FocusPreset>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedPresets)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_preset(&self) -> Result<FocusPreset> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Preset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_preset_async(&self, preset: FocusPreset) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetPresetAsync)(self.0.as_abi() as *const _ as *mut _, preset, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_preset_with_completion_option_async(&self, preset: FocusPreset, completeBeforeFocus: bool) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetPresetWithCompletionOptionAsync)(self.0.as_abi() as *const _ as *mut _, preset, completeBeforeFocus, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_min(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Min)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Max)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_step(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Step)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Value)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_value_async(&self, focus: u32) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetValueAsync)(self.0.as_abi() as *const _ as *mut _, focus, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn focus_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FocusAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class FocusControl: IFocusControl}
DEFINE_IID!(IID_IFocusControl2, 1065156424, 50484, 20126, 148, 195, 82, 239, 42, 253, 93, 7);
RT_INTERFACE!{interface IFocusControl2(IFocusControl2Vtbl, IFocusControl2_Abi): IInspectable(IInspectableVtbl) [IID_IFocusControl2] {
    fn get_FocusChangedSupported(&self, out: *mut bool) -> HRESULT,
    fn get_WaitForFocusSupported(&self, out: *mut bool) -> HRESULT,
    fn get_SupportedFocusModes(&self, out: *mut <foundation::collections::IVectorView<FocusMode> as RtType>::Abi) -> HRESULT,
    fn get_SupportedFocusDistances(&self, out: *mut <foundation::collections::IVectorView<ManualFocusDistance> as RtType>::Abi) -> HRESULT,
    fn get_SupportedFocusRanges(&self, out: *mut <foundation::collections::IVectorView<AutoFocusRange> as RtType>::Abi) -> HRESULT,
    fn get_Mode(&self, out: *mut FocusMode) -> HRESULT,
    fn get_FocusState(&self, out: *mut MediaCaptureFocusState) -> HRESULT,
    fn UnlockAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn LockAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn Configure(&self, settings: <FocusSettings as RtType>::Abi) -> HRESULT
}}
impl IFocusControl2 {
    #[inline] pub fn get_focus_changed_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FocusChangedSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_wait_for_focus_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_WaitForFocusSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_focus_modes(&self) -> Result<Option<foundation::collections::IVectorView<FocusMode>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedFocusModes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_focus_distances(&self) -> Result<Option<foundation::collections::IVectorView<ManualFocusDistance>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedFocusDistances)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_focus_ranges(&self) -> Result<Option<foundation::collections::IVectorView<AutoFocusRange>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedFocusRanges)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_mode(&self) -> Result<FocusMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_focus_state(&self) -> Result<MediaCaptureFocusState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FocusState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn unlock_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).UnlockAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn lock_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).LockAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn configure(&self, settings: &FocusSettings) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Configure)(self.0.as_abi() as *const _ as *mut _, get_abi(settings) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum FocusMode: i32 {
    Auto = 0, Single = 1, Continuous = 2, Manual = 3,
}}
RT_ENUM! { enum FocusPreset: i32 {
    Auto = 0, Manual = 1, AutoMacro = 2, AutoNormal = 3, AutoInfinity = 4, AutoHyperfocal = 5,
}}
DEFINE_IID!(IID_IFocusSettings, 2039844715, 12899, 17013, 133, 214, 174, 174, 137, 28, 150, 238);
RT_INTERFACE!{interface IFocusSettings(IFocusSettingsVtbl, IFocusSettings_Abi): IInspectable(IInspectableVtbl) [IID_IFocusSettings] {
    fn get_Mode(&self, out: *mut FocusMode) -> HRESULT,
    fn put_Mode(&self, value: FocusMode) -> HRESULT,
    fn get_AutoFocusRange(&self, out: *mut AutoFocusRange) -> HRESULT,
    fn put_AutoFocusRange(&self, value: AutoFocusRange) -> HRESULT,
    fn get_Value(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn put_Value(&self, value: <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_Distance(&self, out: *mut <foundation::IReference<ManualFocusDistance> as RtType>::Abi) -> HRESULT,
    fn put_Distance(&self, value: <foundation::IReference<ManualFocusDistance> as RtType>::Abi) -> HRESULT,
    fn get_WaitForFocus(&self, out: *mut bool) -> HRESULT,
    fn put_WaitForFocus(&self, value: bool) -> HRESULT,
    fn get_DisableDriverFallback(&self, out: *mut bool) -> HRESULT,
    fn put_DisableDriverFallback(&self, value: bool) -> HRESULT
}}
impl IFocusSettings {
    #[inline] pub fn get_mode(&self) -> Result<FocusMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_mode(&self, value: FocusMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Mode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_focus_range(&self) -> Result<AutoFocusRange> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutoFocusRange)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto_focus_range(&self, value: AutoFocusRange) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AutoFocusRange)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Value)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_value(&self, value: &foundation::IReference<u32>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Value)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_distance(&self) -> Result<Option<foundation::IReference<ManualFocusDistance>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Distance)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_distance(&self, value: &foundation::IReference<ManualFocusDistance>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Distance)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_wait_for_focus(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_WaitForFocus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_wait_for_focus(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_WaitForFocus)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_disable_driver_fallback(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DisableDriverFallback)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_disable_driver_fallback(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DisableDriverFallback)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class FocusSettings: IFocusSettings}
impl RtActivatable<IActivationFactory> for FocusSettings {}
DEFINE_CLSID!(FocusSettings(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,68,101,118,105,99,101,115,46,70,111,99,117,115,83,101,116,116,105,110,103,115,0]) [CLSID_FocusSettings]);
DEFINE_IID!(IID_IHdrVideoControl, 1440277200, 12480, 17343, 155, 154, 151, 153, 215, 12, 237, 148);
RT_INTERFACE!{interface IHdrVideoControl(IHdrVideoControlVtbl, IHdrVideoControl_Abi): IInspectable(IInspectableVtbl) [IID_IHdrVideoControl] {
    fn get_Supported(&self, out: *mut bool) -> HRESULT,
    fn get_SupportedModes(&self, out: *mut <foundation::collections::IVectorView<HdrVideoMode> as RtType>::Abi) -> HRESULT,
    fn get_Mode(&self, out: *mut HdrVideoMode) -> HRESULT,
    fn put_Mode(&self, value: HdrVideoMode) -> HRESULT
}}
impl IHdrVideoControl {
    #[inline] pub fn get_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Supported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_modes(&self) -> Result<Option<foundation::collections::IVectorView<HdrVideoMode>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedModes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_mode(&self) -> Result<HdrVideoMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_mode(&self, value: HdrVideoMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Mode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class HdrVideoControl: IHdrVideoControl}
RT_ENUM! { enum HdrVideoMode: i32 {
    Off = 0, On = 1, Auto = 2,
}}
DEFINE_IID!(IID_IIsoSpeedControl, 666288930, 9645, 20251, 170, 171, 82, 74, 179, 118, 202, 51);
RT_INTERFACE!{interface IIsoSpeedControl(IIsoSpeedControlVtbl, IIsoSpeedControl_Abi): IInspectable(IInspectableVtbl) [IID_IIsoSpeedControl] {
    fn get_Supported(&self, out: *mut bool) -> HRESULT,
    fn get_SupportedPresets(&self, out: *mut <foundation::collections::IVectorView<IsoSpeedPreset> as RtType>::Abi) -> HRESULT,
    fn get_Preset(&self, out: *mut IsoSpeedPreset) -> HRESULT,
    fn SetPresetAsync(&self, preset: IsoSpeedPreset, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IIsoSpeedControl {
    #[inline] pub fn get_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Supported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_presets(&self) -> Result<Option<foundation::collections::IVectorView<IsoSpeedPreset>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedPresets)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_preset(&self) -> Result<IsoSpeedPreset> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Preset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_preset_async(&self, preset: IsoSpeedPreset) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetPresetAsync)(self.0.as_abi() as *const _ as *mut _, preset, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class IsoSpeedControl: IIsoSpeedControl}
DEFINE_IID!(IID_IIsoSpeedControl2, 1863678194, 28023, 20362, 140, 47, 97, 48, 182, 57, 80, 83);
RT_INTERFACE!{interface IIsoSpeedControl2(IIsoSpeedControl2Vtbl, IIsoSpeedControl2_Abi): IInspectable(IInspectableVtbl) [IID_IIsoSpeedControl2] {
    fn get_Min(&self, out: *mut u32) -> HRESULT,
    fn get_Max(&self, out: *mut u32) -> HRESULT,
    fn get_Step(&self, out: *mut u32) -> HRESULT,
    fn get_Value(&self, out: *mut u32) -> HRESULT,
    fn SetValueAsync(&self, isoSpeed: u32, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn get_Auto(&self, out: *mut bool) -> HRESULT,
    fn SetAutoAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IIsoSpeedControl2 {
    #[inline] pub fn get_min(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Min)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Max)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_step(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Step)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Value)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_value_async(&self, isoSpeed: u32) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetValueAsync)(self.0.as_abi() as *const _ as *mut _, isoSpeed, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_auto(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Auto)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetAutoAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum IsoSpeedPreset: i32 {
    Auto = 0, Iso50 = 1, Iso80 = 2, Iso100 = 3, Iso200 = 4, Iso400 = 5, Iso800 = 6, Iso1600 = 7, Iso3200 = 8, Iso6400 = 9, Iso12800 = 10, Iso25600 = 11,
}}
DEFINE_IID!(IID_IKeypadPressedEventArgs, 3550755072, 46330, 18893, 148, 66, 137, 175, 101, 104, 246, 1);
RT_INTERFACE!{interface IKeypadPressedEventArgs(IKeypadPressedEventArgsVtbl, IKeypadPressedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IKeypadPressedEventArgs] {
    fn get_TelephonyKey(&self, out: *mut TelephonyKey) -> HRESULT
}}
impl IKeypadPressedEventArgs {
    #[inline] pub fn get_telephony_key(&self) -> Result<TelephonyKey> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TelephonyKey)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class KeypadPressedEventArgs: IKeypadPressedEventArgs}
DEFINE_IID!(IID_KeypadPressedEventHandler, 3862406228, 50471, 16940, 137, 38, 201, 175, 131, 181, 89, 160);
RT_DELEGATE!{delegate KeypadPressedEventHandler(KeypadPressedEventHandlerVtbl, KeypadPressedEventHandler_Abi, KeypadPressedEventHandlerImpl) [IID_KeypadPressedEventHandler] {
    fn Invoke(&self, sender: <CallControl as RtType>::Abi, e: <KeypadPressedEventArgs as RtType>::Abi) -> HRESULT
}}
impl KeypadPressedEventHandler {
    #[inline] pub fn invoke(&self, sender: &CallControl, e: &KeypadPressedEventArgs) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Invoke)(self.0.as_abi() as *const _ as *mut _, get_abi(sender) as *const _ as *mut _, get_abi(e) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILowLagPhotoControl, 1834765776, 64223, 16733, 174, 230, 59, 170, 82, 147, 0, 201);
RT_INTERFACE!{interface ILowLagPhotoControl(ILowLagPhotoControlVtbl, ILowLagPhotoControl_Abi): IInspectable(IInspectableVtbl) [IID_ILowLagPhotoControl] {
    fn GetHighestConcurrentFrameRate(&self, captureProperties: <super::mediaproperties::IMediaEncodingProperties as RtType>::Abi, out: *mut <super::mediaproperties::MediaRatio as RtType>::Abi) -> HRESULT,
    fn GetCurrentFrameRate(&self, out: *mut <super::mediaproperties::MediaRatio as RtType>::Abi) -> HRESULT,
    fn get_ThumbnailEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_ThumbnailEnabled(&self, value: bool) -> HRESULT,
    fn get_ThumbnailFormat(&self, out: *mut super::mediaproperties::MediaThumbnailFormat) -> HRESULT,
    fn put_ThumbnailFormat(&self, value: super::mediaproperties::MediaThumbnailFormat) -> HRESULT,
    fn get_DesiredThumbnailSize(&self, out: *mut u32) -> HRESULT,
    fn put_DesiredThumbnailSize(&self, value: u32) -> HRESULT,
    fn get_HardwareAcceleratedThumbnailSupported(&self, out: *mut u32) -> HRESULT
}}
impl ILowLagPhotoControl {
    #[inline] pub fn get_highest_concurrent_frame_rate(&self, captureProperties: &super::mediaproperties::IMediaEncodingProperties) -> Result<Option<super::mediaproperties::MediaRatio>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetHighestConcurrentFrameRate)(self.0.as_abi() as *const _ as *mut _, get_abi(captureProperties) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::mediaproperties::MediaRatio::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_current_frame_rate(&self) -> Result<Option<super::mediaproperties::MediaRatio>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCurrentFrameRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::mediaproperties::MediaRatio::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_thumbnail_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ThumbnailEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_thumbnail_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ThumbnailEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_thumbnail_format(&self) -> Result<super::mediaproperties::MediaThumbnailFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ThumbnailFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_thumbnail_format(&self, value: super::mediaproperties::MediaThumbnailFormat) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ThumbnailFormat)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_desired_thumbnail_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DesiredThumbnailSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_thumbnail_size(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DesiredThumbnailSize)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_hardware_accelerated_thumbnail_supported(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HardwareAcceleratedThumbnailSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class LowLagPhotoControl: ILowLagPhotoControl}
DEFINE_IID!(IID_ILowLagPhotoSequenceControl, 1037013149, 27926, 16540, 186, 254, 185, 165, 148, 198, 253, 230);
RT_INTERFACE!{interface ILowLagPhotoSequenceControl(ILowLagPhotoSequenceControlVtbl, ILowLagPhotoSequenceControl_Abi): IInspectable(IInspectableVtbl) [IID_ILowLagPhotoSequenceControl] {
    fn get_Supported(&self, out: *mut bool) -> HRESULT,
    fn get_MaxPastPhotos(&self, out: *mut u32) -> HRESULT,
    fn get_MaxPhotosPerSecond(&self, out: *mut f32) -> HRESULT,
    fn get_PastPhotoLimit(&self, out: *mut u32) -> HRESULT,
    fn put_PastPhotoLimit(&self, value: u32) -> HRESULT,
    fn get_PhotosPerSecondLimit(&self, out: *mut f32) -> HRESULT,
    fn put_PhotosPerSecondLimit(&self, value: f32) -> HRESULT,
    fn GetHighestConcurrentFrameRate(&self, captureProperties: <super::mediaproperties::IMediaEncodingProperties as RtType>::Abi, out: *mut <super::mediaproperties::MediaRatio as RtType>::Abi) -> HRESULT,
    fn GetCurrentFrameRate(&self, out: *mut <super::mediaproperties::MediaRatio as RtType>::Abi) -> HRESULT,
    fn get_ThumbnailEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_ThumbnailEnabled(&self, value: bool) -> HRESULT,
    fn get_ThumbnailFormat(&self, out: *mut super::mediaproperties::MediaThumbnailFormat) -> HRESULT,
    fn put_ThumbnailFormat(&self, value: super::mediaproperties::MediaThumbnailFormat) -> HRESULT,
    fn get_DesiredThumbnailSize(&self, out: *mut u32) -> HRESULT,
    fn put_DesiredThumbnailSize(&self, value: u32) -> HRESULT,
    fn get_HardwareAcceleratedThumbnailSupported(&self, out: *mut u32) -> HRESULT
}}
impl ILowLagPhotoSequenceControl {
    #[inline] pub fn get_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Supported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_past_photos(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxPastPhotos)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_photos_per_second(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxPhotosPerSecond)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_past_photo_limit(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PastPhotoLimit)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_past_photo_limit(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PastPhotoLimit)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_photos_per_second_limit(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhotosPerSecondLimit)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_photos_per_second_limit(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PhotosPerSecondLimit)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_highest_concurrent_frame_rate(&self, captureProperties: &super::mediaproperties::IMediaEncodingProperties) -> Result<Option<super::mediaproperties::MediaRatio>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetHighestConcurrentFrameRate)(self.0.as_abi() as *const _ as *mut _, get_abi(captureProperties) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::mediaproperties::MediaRatio::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_current_frame_rate(&self) -> Result<Option<super::mediaproperties::MediaRatio>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCurrentFrameRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::mediaproperties::MediaRatio::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_thumbnail_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ThumbnailEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_thumbnail_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ThumbnailEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_thumbnail_format(&self) -> Result<super::mediaproperties::MediaThumbnailFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ThumbnailFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_thumbnail_format(&self, value: super::mediaproperties::MediaThumbnailFormat) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ThumbnailFormat)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_desired_thumbnail_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DesiredThumbnailSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_thumbnail_size(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DesiredThumbnailSize)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_hardware_accelerated_thumbnail_supported(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HardwareAcceleratedThumbnailSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class LowLagPhotoSequenceControl: ILowLagPhotoSequenceControl}
RT_ENUM! { enum ManualFocusDistance: i32 {
    Infinity = 0, Hyperfocal = 1, Nearest = 2,
}}
RT_ENUM! { enum MediaCaptureFocusState: i32 {
    Uninitialized = 0, Lost = 1, Searching = 2, Focused = 3, Failed = 4,
}}
RT_ENUM! { enum MediaCaptureOptimization: i32 {
    Default = 0, Quality = 1, Latency = 2, Power = 3, LatencyThenQuality = 4, LatencyThenPower = 5, PowerAndQuality = 6,
}}
RT_ENUM! { enum MediaCapturePauseBehavior: i32 {
    RetainHardwareResources = 0, ReleaseHardwareResources = 1,
}}
RT_CLASS!{static class MediaDevice}
impl RtActivatable<IMediaDeviceStatics> for MediaDevice {}
impl MediaDevice {
    #[inline] pub fn get_audio_capture_selector() -> Result<HString> {
        <Self as RtActivatable<IMediaDeviceStatics>>::get_activation_factory().get_audio_capture_selector()
    }
    #[inline] pub fn get_audio_render_selector() -> Result<HString> {
        <Self as RtActivatable<IMediaDeviceStatics>>::get_activation_factory().get_audio_render_selector()
    }
    #[inline] pub fn get_video_capture_selector() -> Result<HString> {
        <Self as RtActivatable<IMediaDeviceStatics>>::get_activation_factory().get_video_capture_selector()
    }
    #[inline] pub fn get_default_audio_capture_id(role: AudioDeviceRole) -> Result<HString> {
        <Self as RtActivatable<IMediaDeviceStatics>>::get_activation_factory().get_default_audio_capture_id(role)
    }
    #[inline] pub fn get_default_audio_render_id(role: AudioDeviceRole) -> Result<HString> {
        <Self as RtActivatable<IMediaDeviceStatics>>::get_activation_factory().get_default_audio_render_id(role)
    }
    #[inline] pub fn add_default_audio_capture_device_changed(handler: &foundation::TypedEventHandler<IInspectable, DefaultAudioCaptureDeviceChangedEventArgs>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IMediaDeviceStatics>>::get_activation_factory().add_default_audio_capture_device_changed(handler)
    }
    #[inline] pub fn remove_default_audio_capture_device_changed(cookie: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IMediaDeviceStatics>>::get_activation_factory().remove_default_audio_capture_device_changed(cookie)
    }
    #[inline] pub fn add_default_audio_render_device_changed(handler: &foundation::TypedEventHandler<IInspectable, DefaultAudioRenderDeviceChangedEventArgs>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IMediaDeviceStatics>>::get_activation_factory().add_default_audio_render_device_changed(handler)
    }
    #[inline] pub fn remove_default_audio_render_device_changed(cookie: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IMediaDeviceStatics>>::get_activation_factory().remove_default_audio_render_device_changed(cookie)
    }
}
DEFINE_CLSID!(MediaDevice(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,68,101,118,105,99,101,115,46,77,101,100,105,97,68,101,118,105,99,101,0]) [CLSID_MediaDevice]);
DEFINE_IID!(IID_IMediaDeviceControl, 4020821929, 28533, 18531, 186, 11, 88, 63, 48, 54, 180, 222);
RT_INTERFACE!{interface IMediaDeviceControl(IMediaDeviceControlVtbl, IMediaDeviceControl_Abi): IInspectable(IInspectableVtbl) [IID_IMediaDeviceControl] {
    fn get_Capabilities(&self, out: *mut <MediaDeviceControlCapabilities as RtType>::Abi) -> HRESULT,
    fn TryGetValue(&self, value: *mut f64, out: *mut bool) -> HRESULT,
    fn TrySetValue(&self, value: f64, out: *mut bool) -> HRESULT,
    fn TryGetAuto(&self, value: *mut bool, out: *mut bool) -> HRESULT,
    fn TrySetAuto(&self, value: bool, out: *mut bool) -> HRESULT
}}
impl IMediaDeviceControl {
    #[inline] pub fn get_capabilities(&self) -> Result<Option<MediaDeviceControlCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Capabilities)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaDeviceControlCapabilities::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_value(&self) -> Result<(f64, bool)> { unsafe { 
        let mut value = zeroed(); let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).TryGetValue)(self.0.as_abi() as *const _ as *mut _, &mut value, &mut out);
        if hr == S_OK { Ok((value, out)) } else { err(hr) }
    }}
    #[inline] pub fn try_set_value(&self, value: f64) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).TrySetValue)(self.0.as_abi() as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_get_auto(&self) -> Result<(bool, bool)> { unsafe { 
        let mut value = zeroed(); let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).TryGetAuto)(self.0.as_abi() as *const _ as *mut _, &mut value, &mut out);
        if hr == S_OK { Ok((value, out)) } else { err(hr) }
    }}
    #[inline] pub fn try_set_auto(&self, value: bool) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).TrySetAuto)(self.0.as_abi() as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaDeviceControl: IMediaDeviceControl}
DEFINE_IID!(IID_IMediaDeviceControlCapabilities, 587225110, 60293, 17378, 185, 43, 130, 64, 213, 238, 112, 236);
RT_INTERFACE!{interface IMediaDeviceControlCapabilities(IMediaDeviceControlCapabilitiesVtbl, IMediaDeviceControlCapabilities_Abi): IInspectable(IInspectableVtbl) [IID_IMediaDeviceControlCapabilities] {
    fn get_Supported(&self, out: *mut bool) -> HRESULT,
    fn get_Min(&self, out: *mut f64) -> HRESULT,
    fn get_Max(&self, out: *mut f64) -> HRESULT,
    fn get_Step(&self, out: *mut f64) -> HRESULT,
    fn get_Default(&self, out: *mut f64) -> HRESULT,
    fn get_AutoModeSupported(&self, out: *mut bool) -> HRESULT
}}
impl IMediaDeviceControlCapabilities {
    #[inline] pub fn get_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Supported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Min)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Max)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_step(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Step)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_default(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Default)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_mode_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutoModeSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaDeviceControlCapabilities: IMediaDeviceControlCapabilities}
DEFINE_IID!(IID_IMediaDeviceController, 4143510990, 8346, 18683, 134, 252, 212, 69, 120, 243, 23, 230);
RT_INTERFACE!{interface IMediaDeviceController(IMediaDeviceControllerVtbl, IMediaDeviceController_Abi): IInspectable(IInspectableVtbl) [IID_IMediaDeviceController] {
    fn GetAvailableMediaStreamProperties(&self, mediaStreamType: super::capture::MediaStreamType, out: *mut <foundation::collections::IVectorView<super::mediaproperties::IMediaEncodingProperties> as RtType>::Abi) -> HRESULT,
    fn GetMediaStreamProperties(&self, mediaStreamType: super::capture::MediaStreamType, out: *mut <super::mediaproperties::IMediaEncodingProperties as RtType>::Abi) -> HRESULT,
    fn SetMediaStreamPropertiesAsync(&self, mediaStreamType: super::capture::MediaStreamType, mediaEncodingProperties: <super::mediaproperties::IMediaEncodingProperties as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IMediaDeviceController {
    #[inline] pub fn get_available_media_stream_properties(&self, mediaStreamType: super::capture::MediaStreamType) -> Result<Option<foundation::collections::IVectorView<super::mediaproperties::IMediaEncodingProperties>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAvailableMediaStreamProperties)(self.0.as_abi() as *const _ as *mut _, mediaStreamType, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_media_stream_properties(&self, mediaStreamType: super::capture::MediaStreamType) -> Result<Option<super::mediaproperties::IMediaEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetMediaStreamProperties)(self.0.as_abi() as *const _ as *mut _, mediaStreamType, &mut out);
        if hr == S_OK { Ok(super::mediaproperties::IMediaEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_media_stream_properties_async(&self, mediaStreamType: super::capture::MediaStreamType, mediaEncodingProperties: &super::mediaproperties::IMediaEncodingProperties) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetMediaStreamPropertiesAsync)(self.0.as_abi() as *const _ as *mut _, mediaStreamType, get_abi(mediaEncodingProperties) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaDeviceStatics, 2855115328, 37023, 19386, 191, 139, 12, 13, 41, 111, 20, 240);
RT_INTERFACE!{static interface IMediaDeviceStatics(IMediaDeviceStaticsVtbl, IMediaDeviceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IMediaDeviceStatics] {
    fn GetAudioCaptureSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn GetAudioRenderSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn GetVideoCaptureSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn GetDefaultAudioCaptureId(&self, role: AudioDeviceRole, out: *mut HSTRING) -> HRESULT,
    fn GetDefaultAudioRenderId(&self, role: AudioDeviceRole, out: *mut HSTRING) -> HRESULT,
    fn add_DefaultAudioCaptureDeviceChanged(&self, handler: <foundation::TypedEventHandler<IInspectable, DefaultAudioCaptureDeviceChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DefaultAudioCaptureDeviceChanged(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_DefaultAudioRenderDeviceChanged(&self, handler: <foundation::TypedEventHandler<IInspectable, DefaultAudioRenderDeviceChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DefaultAudioRenderDeviceChanged(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl IMediaDeviceStatics {
    #[inline] pub fn get_audio_capture_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAudioCaptureSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_render_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAudioRenderSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_capture_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetVideoCaptureSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_audio_capture_id(&self, role: AudioDeviceRole) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultAudioCaptureId)(self.0.as_abi() as *const _ as *mut _, role, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_audio_render_id(&self, role: AudioDeviceRole) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultAudioRenderId)(self.0.as_abi() as *const _ as *mut _, role, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_default_audio_capture_device_changed(&self, handler: &foundation::TypedEventHandler<IInspectable, DefaultAudioCaptureDeviceChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_DefaultAudioCaptureDeviceChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_default_audio_capture_device_changed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_DefaultAudioCaptureDeviceChanged)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_default_audio_render_device_changed(&self, handler: &foundation::TypedEventHandler<IInspectable, DefaultAudioRenderDeviceChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_DefaultAudioRenderDeviceChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_default_audio_render_device_changed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_DefaultAudioRenderDeviceChanged)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IModuleCommandResult, 1376591540, 4980, 19581, 177, 228, 57, 220, 223, 62, 174, 78);
RT_INTERFACE!{interface IModuleCommandResult(IModuleCommandResultVtbl, IModuleCommandResult_Abi): IInspectable(IInspectableVtbl) [IID_IModuleCommandResult] {
    fn get_Status(&self, out: *mut SendCommandStatus) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_Result(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IModuleCommandResult {
    #[inline] pub fn get_status(&self) -> Result<SendCommandStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_result(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Result)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ModuleCommandResult: IModuleCommandResult}
DEFINE_IID!(IID_IOpticalImageStabilizationControl, 3215825949, 188, 16955, 142, 178, 160, 23, 140, 169, 66, 71);
RT_INTERFACE!{interface IOpticalImageStabilizationControl(IOpticalImageStabilizationControlVtbl, IOpticalImageStabilizationControl_Abi): IInspectable(IInspectableVtbl) [IID_IOpticalImageStabilizationControl] {
    fn get_Supported(&self, out: *mut bool) -> HRESULT,
    fn get_SupportedModes(&self, out: *mut <foundation::collections::IVectorView<OpticalImageStabilizationMode> as RtType>::Abi) -> HRESULT,
    fn get_Mode(&self, out: *mut OpticalImageStabilizationMode) -> HRESULT,
    fn put_Mode(&self, value: OpticalImageStabilizationMode) -> HRESULT
}}
impl IOpticalImageStabilizationControl {
    #[inline] pub fn get_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Supported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_modes(&self) -> Result<Option<foundation::collections::IVectorView<OpticalImageStabilizationMode>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedModes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_mode(&self) -> Result<OpticalImageStabilizationMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_mode(&self, value: OpticalImageStabilizationMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Mode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class OpticalImageStabilizationControl: IOpticalImageStabilizationControl}
RT_ENUM! { enum OpticalImageStabilizationMode: i32 {
    Off = 0, On = 1, Auto = 2,
}}
DEFINE_IID!(IID_IPhotoConfirmationControl, 3371430755, 65374, 17794, 169, 168, 5, 80, 248, 90, 74, 118);
RT_INTERFACE!{interface IPhotoConfirmationControl(IPhotoConfirmationControlVtbl, IPhotoConfirmationControl_Abi): IInspectable(IInspectableVtbl) [IID_IPhotoConfirmationControl] {
    fn get_Supported(&self, out: *mut bool) -> HRESULT,
    fn get_Enabled(&self, out: *mut bool) -> HRESULT,
    fn put_Enabled(&self, value: bool) -> HRESULT,
    fn get_PixelFormat(&self, out: *mut super::mediaproperties::MediaPixelFormat) -> HRESULT,
    fn put_PixelFormat(&self, format: super::mediaproperties::MediaPixelFormat) -> HRESULT
}}
impl IPhotoConfirmationControl {
    #[inline] pub fn get_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Supported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Enabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Enabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_pixel_format(&self) -> Result<super::mediaproperties::MediaPixelFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PixelFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_pixel_format(&self, format: super::mediaproperties::MediaPixelFormat) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PixelFormat)(self.0.as_abi() as *const _ as *mut _, format);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PhotoConfirmationControl: IPhotoConfirmationControl}
DEFINE_IID!(IID_IRedialRequestedEventArgs, 2125812233, 30379, 19505, 180, 14, 75, 88, 55, 157, 88, 12);
RT_INTERFACE!{interface IRedialRequestedEventArgs(IRedialRequestedEventArgsVtbl, IRedialRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IRedialRequestedEventArgs] {
    fn Handled(&self) -> HRESULT
}}
impl IRedialRequestedEventArgs {
    #[inline] pub fn handled(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Handled)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class RedialRequestedEventArgs: IRedialRequestedEventArgs}
DEFINE_IID!(IID_RedialRequestedEventHandler, 3136444369, 20157, 19332, 159, 71, 110, 196, 61, 117, 216, 177);
RT_DELEGATE!{delegate RedialRequestedEventHandler(RedialRequestedEventHandlerVtbl, RedialRequestedEventHandler_Abi, RedialRequestedEventHandlerImpl) [IID_RedialRequestedEventHandler] {
    fn Invoke(&self, sender: <CallControl as RtType>::Abi, e: <RedialRequestedEventArgs as RtType>::Abi) -> HRESULT
}}
impl RedialRequestedEventHandler {
    #[inline] pub fn invoke(&self, sender: &CallControl, e: &RedialRequestedEventArgs) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Invoke)(self.0.as_abi() as *const _ as *mut _, get_abi(sender) as *const _ as *mut _, get_abi(e) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRegionOfInterest, 3857500212, 52838, 19973, 167, 143, 207, 57, 26, 94, 194, 209);
RT_INTERFACE!{interface IRegionOfInterest(IRegionOfInterestVtbl, IRegionOfInterest_Abi): IInspectable(IInspectableVtbl) [IID_IRegionOfInterest] {
    fn get_AutoFocusEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_AutoFocusEnabled(&self, value: bool) -> HRESULT,
    fn get_AutoWhiteBalanceEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_AutoWhiteBalanceEnabled(&self, value: bool) -> HRESULT,
    fn get_AutoExposureEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_AutoExposureEnabled(&self, value: bool) -> HRESULT,
    fn get_Bounds(&self, out: *mut foundation::Rect) -> HRESULT,
    fn put_Bounds(&self, value: foundation::Rect) -> HRESULT
}}
impl IRegionOfInterest {
    #[inline] pub fn get_auto_focus_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutoFocusEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto_focus_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AutoFocusEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_white_balance_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutoWhiteBalanceEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto_white_balance_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AutoWhiteBalanceEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_exposure_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutoExposureEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto_exposure_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AutoExposureEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_bounds(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Bounds)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_bounds(&self, value: foundation::Rect) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Bounds)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class RegionOfInterest: IRegionOfInterest}
impl RtActivatable<IActivationFactory> for RegionOfInterest {}
DEFINE_CLSID!(RegionOfInterest(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,68,101,118,105,99,101,115,46,82,101,103,105,111,110,79,102,73,110,116,101,114,101,115,116,0]) [CLSID_RegionOfInterest]);
DEFINE_IID!(IID_IRegionOfInterest2, 436087441, 29610, 19793, 138, 157, 86, 204, 247, 219, 127, 84);
RT_INTERFACE!{interface IRegionOfInterest2(IRegionOfInterest2Vtbl, IRegionOfInterest2_Abi): IInspectable(IInspectableVtbl) [IID_IRegionOfInterest2] {
    fn get_Type(&self, out: *mut RegionOfInterestType) -> HRESULT,
    fn put_Type(&self, value: RegionOfInterestType) -> HRESULT,
    fn get_BoundsNormalized(&self, out: *mut bool) -> HRESULT,
    fn put_BoundsNormalized(&self, value: bool) -> HRESULT,
    fn get_Weight(&self, out: *mut u32) -> HRESULT,
    fn put_Weight(&self, value: u32) -> HRESULT
}}
impl IRegionOfInterest2 {
    #[inline] pub fn get_type(&self) -> Result<RegionOfInterestType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Type)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_type(&self, value: RegionOfInterestType) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Type)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_bounds_normalized(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BoundsNormalized)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_bounds_normalized(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BoundsNormalized)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_weight(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Weight)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_weight(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Weight)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum RegionOfInterestType: i32 {
    Unknown = 0, Face = 1,
}}
DEFINE_IID!(IID_IRegionsOfInterestControl, 3273913639, 43787, 17752, 139, 91, 223, 86, 147, 219, 3, 120);
RT_INTERFACE!{interface IRegionsOfInterestControl(IRegionsOfInterestControlVtbl, IRegionsOfInterestControl_Abi): IInspectable(IInspectableVtbl) [IID_IRegionsOfInterestControl] {
    fn get_MaxRegions(&self, out: *mut u32) -> HRESULT,
    fn SetRegionsAsync(&self, regions: <foundation::collections::IIterable<RegionOfInterest> as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn SetRegionsWithLockAsync(&self, regions: <foundation::collections::IIterable<RegionOfInterest> as RtType>::Abi, lockValues: bool, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ClearRegionsAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn get_AutoFocusSupported(&self, out: *mut bool) -> HRESULT,
    fn get_AutoWhiteBalanceSupported(&self, out: *mut bool) -> HRESULT,
    fn get_AutoExposureSupported(&self, out: *mut bool) -> HRESULT
}}
impl IRegionsOfInterestControl {
    #[inline] pub fn get_max_regions(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxRegions)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_regions_async(&self, regions: &foundation::collections::IIterable<RegionOfInterest>) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetRegionsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(regions) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_regions_with_lock_async(&self, regions: &foundation::collections::IIterable<RegionOfInterest>, lockValues: bool) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetRegionsWithLockAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(regions) as *const _ as *mut _, lockValues, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn clear_regions_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ClearRegionsAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_focus_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutoFocusSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_white_balance_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutoWhiteBalanceSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_exposure_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutoExposureSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class RegionsOfInterestControl: IRegionsOfInterestControl}
DEFINE_IID!(IID_ISceneModeControl, 3566099191, 36185, 18516, 140, 98, 18, 199, 11, 168, 155, 124);
RT_INTERFACE!{interface ISceneModeControl(ISceneModeControlVtbl, ISceneModeControl_Abi): IInspectable(IInspectableVtbl) [IID_ISceneModeControl] {
    fn get_SupportedModes(&self, out: *mut <foundation::collections::IVectorView<CaptureSceneMode> as RtType>::Abi) -> HRESULT,
    fn get_Value(&self, out: *mut CaptureSceneMode) -> HRESULT,
    fn SetValueAsync(&self, sceneMode: CaptureSceneMode, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl ISceneModeControl {
    #[inline] pub fn get_supported_modes(&self) -> Result<Option<foundation::collections::IVectorView<CaptureSceneMode>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedModes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<CaptureSceneMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Value)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_value_async(&self, sceneMode: CaptureSceneMode) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetValueAsync)(self.0.as_abi() as *const _ as *mut _, sceneMode, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SceneModeControl: ISceneModeControl}
RT_ENUM! { enum SendCommandStatus: i32 {
    Success = 0, DeviceNotAvailable = 1,
}}
RT_ENUM! { enum TelephonyKey: i32 {
    D0 = 0, D1 = 1, D2 = 2, D3 = 3, D4 = 4, D5 = 5, D6 = 6, D7 = 7, D8 = 8, D9 = 9, Star = 10, Pound = 11, A = 12, B = 13, C = 14, D = 15,
}}
DEFINE_IID!(IID_ITorchControl, 2785359461, 33360, 16748, 145, 154, 114, 66, 150, 175, 163, 6);
RT_INTERFACE!{interface ITorchControl(ITorchControlVtbl, ITorchControl_Abi): IInspectable(IInspectableVtbl) [IID_ITorchControl] {
    fn get_Supported(&self, out: *mut bool) -> HRESULT,
    fn get_PowerSupported(&self, out: *mut bool) -> HRESULT,
    fn get_Enabled(&self, out: *mut bool) -> HRESULT,
    fn put_Enabled(&self, value: bool) -> HRESULT,
    fn get_PowerPercent(&self, out: *mut f32) -> HRESULT,
    fn put_PowerPercent(&self, value: f32) -> HRESULT
}}
impl ITorchControl {
    #[inline] pub fn get_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Supported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_power_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PowerSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Enabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Enabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_power_percent(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PowerPercent)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_power_percent(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PowerPercent)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class TorchControl: ITorchControl}
DEFINE_IID!(IID_IVideoDeviceController, 2572506485, 11822, 16568, 182, 199, 248, 45, 16, 1, 50, 16);
RT_INTERFACE!{interface IVideoDeviceController(IVideoDeviceControllerVtbl, IVideoDeviceController_Abi): IInspectable(IInspectableVtbl) [IID_IVideoDeviceController] {
    fn get_Brightness(&self, out: *mut <MediaDeviceControl as RtType>::Abi) -> HRESULT,
    fn get_Contrast(&self, out: *mut <MediaDeviceControl as RtType>::Abi) -> HRESULT,
    fn get_Hue(&self, out: *mut <MediaDeviceControl as RtType>::Abi) -> HRESULT,
    fn get_WhiteBalance(&self, out: *mut <MediaDeviceControl as RtType>::Abi) -> HRESULT,
    fn get_BacklightCompensation(&self, out: *mut <MediaDeviceControl as RtType>::Abi) -> HRESULT,
    fn get_Pan(&self, out: *mut <MediaDeviceControl as RtType>::Abi) -> HRESULT,
    fn get_Tilt(&self, out: *mut <MediaDeviceControl as RtType>::Abi) -> HRESULT,
    fn get_Zoom(&self, out: *mut <MediaDeviceControl as RtType>::Abi) -> HRESULT,
    fn get_Roll(&self, out: *mut <MediaDeviceControl as RtType>::Abi) -> HRESULT,
    fn get_Exposure(&self, out: *mut <MediaDeviceControl as RtType>::Abi) -> HRESULT,
    fn get_Focus(&self, out: *mut <MediaDeviceControl as RtType>::Abi) -> HRESULT,
    fn TrySetPowerlineFrequency(&self, value: super::capture::PowerlineFrequency, out: *mut bool) -> HRESULT,
    fn TryGetPowerlineFrequency(&self, value: *mut super::capture::PowerlineFrequency, out: *mut bool) -> HRESULT
}}
impl IVideoDeviceController {
    #[inline] pub fn get_brightness(&self) -> Result<Option<MediaDeviceControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Brightness)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaDeviceControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_contrast(&self) -> Result<Option<MediaDeviceControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Contrast)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaDeviceControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_hue(&self) -> Result<Option<MediaDeviceControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Hue)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaDeviceControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_white_balance(&self) -> Result<Option<MediaDeviceControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_WhiteBalance)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaDeviceControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_backlight_compensation(&self) -> Result<Option<MediaDeviceControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BacklightCompensation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaDeviceControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_pan(&self) -> Result<Option<MediaDeviceControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Pan)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaDeviceControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_tilt(&self) -> Result<Option<MediaDeviceControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Tilt)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaDeviceControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_zoom(&self) -> Result<Option<MediaDeviceControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Zoom)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaDeviceControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_roll(&self) -> Result<Option<MediaDeviceControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Roll)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaDeviceControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_exposure(&self) -> Result<Option<MediaDeviceControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Exposure)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaDeviceControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_focus(&self) -> Result<Option<MediaDeviceControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Focus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaDeviceControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_set_powerline_frequency(&self, value: super::capture::PowerlineFrequency) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).TrySetPowerlineFrequency)(self.0.as_abi() as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_get_powerline_frequency(&self) -> Result<(super::capture::PowerlineFrequency, bool)> { unsafe { 
        let mut value = zeroed(); let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).TryGetPowerlineFrequency)(self.0.as_abi() as *const _ as *mut _, &mut value, &mut out);
        if hr == S_OK { Ok((value, out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VideoDeviceController: IVideoDeviceController}
DEFINE_IID!(IID_IVideoDeviceControllerGetDevicePropertyResult, 3319301013, 28373, 18320, 139, 93, 14, 241, 57, 53, 208, 248);
RT_INTERFACE!{interface IVideoDeviceControllerGetDevicePropertyResult(IVideoDeviceControllerGetDevicePropertyResultVtbl, IVideoDeviceControllerGetDevicePropertyResult_Abi): IInspectable(IInspectableVtbl) [IID_IVideoDeviceControllerGetDevicePropertyResult] {
    fn get_Status(&self, out: *mut VideoDeviceControllerGetDevicePropertyStatus) -> HRESULT,
    fn get_Value(&self, out: *mut <IInspectable as RtType>::Abi) -> HRESULT
}}
impl IVideoDeviceControllerGetDevicePropertyResult {
    #[inline] pub fn get_status(&self) -> Result<VideoDeviceControllerGetDevicePropertyStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<Option<IInspectable>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Value)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IInspectable::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VideoDeviceControllerGetDevicePropertyResult: IVideoDeviceControllerGetDevicePropertyResult}
RT_ENUM! { enum VideoDeviceControllerGetDevicePropertyStatus: i32 {
    Success = 0, UnknownFailure = 1, BufferTooSmall = 2, NotSupported = 3, DeviceNotAvailable = 4, MaxPropertyValueSizeTooSmall = 5, MaxPropertyValueSizeRequired = 6,
}}
RT_ENUM! { enum VideoDeviceControllerSetDevicePropertyStatus: i32 {
    Success = 0, UnknownFailure = 1, NotSupported = 2, InvalidValue = 3, DeviceNotAvailable = 4, NotInControl = 5,
}}
DEFINE_IID!(IID_IVideoTemporalDenoisingControl, 2058569525, 15914, 18994, 186, 255, 67, 88, 196, 251, 221, 87);
RT_INTERFACE!{interface IVideoTemporalDenoisingControl(IVideoTemporalDenoisingControlVtbl, IVideoTemporalDenoisingControl_Abi): IInspectable(IInspectableVtbl) [IID_IVideoTemporalDenoisingControl] {
    fn get_Supported(&self, out: *mut bool) -> HRESULT,
    fn get_SupportedModes(&self, out: *mut <foundation::collections::IVectorView<VideoTemporalDenoisingMode> as RtType>::Abi) -> HRESULT,
    fn get_Mode(&self, out: *mut VideoTemporalDenoisingMode) -> HRESULT,
    fn put_Mode(&self, value: VideoTemporalDenoisingMode) -> HRESULT
}}
impl IVideoTemporalDenoisingControl {
    #[inline] pub fn get_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Supported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_modes(&self) -> Result<Option<foundation::collections::IVectorView<VideoTemporalDenoisingMode>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedModes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_mode(&self) -> Result<VideoTemporalDenoisingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_mode(&self, value: VideoTemporalDenoisingMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Mode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class VideoTemporalDenoisingControl: IVideoTemporalDenoisingControl}
RT_ENUM! { enum VideoTemporalDenoisingMode: i32 {
    Off = 0, On = 1, Auto = 2,
}}
DEFINE_IID!(IID_IWhiteBalanceControl, 2015298686, 29026, 18888, 168, 249, 148, 129, 197, 101, 54, 62);
RT_INTERFACE!{interface IWhiteBalanceControl(IWhiteBalanceControlVtbl, IWhiteBalanceControl_Abi): IInspectable(IInspectableVtbl) [IID_IWhiteBalanceControl] {
    fn get_Supported(&self, out: *mut bool) -> HRESULT,
    fn get_Preset(&self, out: *mut ColorTemperaturePreset) -> HRESULT,
    fn SetPresetAsync(&self, preset: ColorTemperaturePreset, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn get_Min(&self, out: *mut u32) -> HRESULT,
    fn get_Max(&self, out: *mut u32) -> HRESULT,
    fn get_Step(&self, out: *mut u32) -> HRESULT,
    fn get_Value(&self, out: *mut u32) -> HRESULT,
    fn SetValueAsync(&self, temperature: u32, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IWhiteBalanceControl {
    #[inline] pub fn get_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Supported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_preset(&self) -> Result<ColorTemperaturePreset> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Preset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_preset_async(&self, preset: ColorTemperaturePreset) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetPresetAsync)(self.0.as_abi() as *const _ as *mut _, preset, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_min(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Min)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Max)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_step(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Step)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Value)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_value_async(&self, temperature: u32) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetValueAsync)(self.0.as_abi() as *const _ as *mut _, temperature, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WhiteBalanceControl: IWhiteBalanceControl}
DEFINE_IID!(IID_IZoomControl, 975047442, 13018, 19479, 191, 215, 141, 12, 115, 200, 245, 165);
RT_INTERFACE!{interface IZoomControl(IZoomControlVtbl, IZoomControl_Abi): IInspectable(IInspectableVtbl) [IID_IZoomControl] {
    fn get_Supported(&self, out: *mut bool) -> HRESULT,
    fn get_Min(&self, out: *mut f32) -> HRESULT,
    fn get_Max(&self, out: *mut f32) -> HRESULT,
    fn get_Step(&self, out: *mut f32) -> HRESULT,
    fn get_Value(&self, out: *mut f32) -> HRESULT,
    fn put_Value(&self, value: f32) -> HRESULT
}}
impl IZoomControl {
    #[inline] pub fn get_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Supported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Min)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Max)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_step(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Step)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Value)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_value(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Value)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ZoomControl: IZoomControl}
DEFINE_IID!(IID_IZoomControl2, 1770274224, 11929, 17985, 133, 41, 24, 79, 49, 157, 22, 113);
RT_INTERFACE!{interface IZoomControl2(IZoomControl2Vtbl, IZoomControl2_Abi): IInspectable(IInspectableVtbl) [IID_IZoomControl2] {
    fn get_SupportedModes(&self, out: *mut <foundation::collections::IVectorView<ZoomTransitionMode> as RtType>::Abi) -> HRESULT,
    fn get_Mode(&self, out: *mut ZoomTransitionMode) -> HRESULT,
    fn Configure(&self, settings: <ZoomSettings as RtType>::Abi) -> HRESULT
}}
impl IZoomControl2 {
    #[inline] pub fn get_supported_modes(&self) -> Result<Option<foundation::collections::IVectorView<ZoomTransitionMode>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedModes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_mode(&self) -> Result<ZoomTransitionMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn configure(&self, settings: &ZoomSettings) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Configure)(self.0.as_abi() as *const _ as *mut _, get_abi(settings) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IZoomSettings, 1792437028, 5300, 19453, 177, 143, 136, 254, 36, 70, 59, 82);
RT_INTERFACE!{interface IZoomSettings(IZoomSettingsVtbl, IZoomSettings_Abi): IInspectable(IInspectableVtbl) [IID_IZoomSettings] {
    fn get_Mode(&self, out: *mut ZoomTransitionMode) -> HRESULT,
    fn put_Mode(&self, value: ZoomTransitionMode) -> HRESULT,
    fn get_Value(&self, out: *mut f32) -> HRESULT,
    fn put_Value(&self, value: f32) -> HRESULT
}}
impl IZoomSettings {
    #[inline] pub fn get_mode(&self) -> Result<ZoomTransitionMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_mode(&self, value: ZoomTransitionMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Mode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Value)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_value(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Value)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ZoomSettings: IZoomSettings}
impl RtActivatable<IActivationFactory> for ZoomSettings {}
DEFINE_CLSID!(ZoomSettings(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,68,101,118,105,99,101,115,46,90,111,111,109,83,101,116,116,105,110,103,115,0]) [CLSID_ZoomSettings]);
RT_ENUM! { enum ZoomTransitionMode: i32 {
    Auto = 0, Direct = 1, Smooth = 2,
}}
pub mod core { // Windows.Media.Devices.Core
use crate::prelude::*;
DEFINE_IID!(IID_ICameraIntrinsics, 178711858, 25993, 18906, 175, 222, 89, 66, 112, 202, 10, 172);
RT_INTERFACE!{interface ICameraIntrinsics(ICameraIntrinsicsVtbl, ICameraIntrinsics_Abi): IInspectable(IInspectableVtbl) [IID_ICameraIntrinsics] {
    fn get_FocalLength(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn get_PrincipalPoint(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn get_RadialDistortion(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn get_TangentialDistortion(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn get_ImageWidth(&self, out: *mut u32) -> HRESULT,
    fn get_ImageHeight(&self, out: *mut u32) -> HRESULT,
    fn ProjectOntoFrame(&self, coordinate: foundation::numerics::Vector3, out: *mut foundation::Point) -> HRESULT,
    fn UnprojectAtUnitDepth(&self, pixelCoordinate: foundation::Point, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn ProjectManyOntoFrame(&self, coordinatesSize: u32, coordinates: *mut foundation::numerics::Vector3, resultsSize: u32, results: *mut foundation::Point) -> HRESULT,
    fn UnprojectPixelsAtUnitDepth(&self, pixelCoordinatesSize: u32, pixelCoordinates: *mut foundation::Point, resultsSize: u32, results: *mut foundation::numerics::Vector2) -> HRESULT
}}
impl ICameraIntrinsics {
    #[inline] pub fn get_focal_length(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FocalLength)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_principal_point(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PrincipalPoint)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_radial_distortion(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RadialDistortion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tangential_distortion(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TangentialDistortion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_image_width(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ImageWidth)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_image_height(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ImageHeight)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn project_onto_frame(&self, coordinate: foundation::numerics::Vector3) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).ProjectOntoFrame)(self.0.as_abi() as *const _ as *mut _, coordinate, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn unproject_at_unit_depth(&self, pixelCoordinate: foundation::Point) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).UnprojectAtUnitDepth)(self.0.as_abi() as *const _ as *mut _, pixelCoordinate, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn project_many_onto_frame(&self, coordinates: &[foundation::numerics::Vector3], results: &mut [foundation::Point]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ProjectManyOntoFrame)(self.0.as_abi() as *const _ as *mut _, coordinates.len() as u32, coordinates.as_ptr() as *mut _, results.len() as u32, results.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn unproject_pixels_at_unit_depth(&self, pixelCoordinates: &[foundation::Point], results: &mut [foundation::numerics::Vector2]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).UnprojectPixelsAtUnitDepth)(self.0.as_abi() as *const _ as *mut _, pixelCoordinates.len() as u32, pixelCoordinates.as_ptr() as *mut _, results.len() as u32, results.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CameraIntrinsics: ICameraIntrinsics}
impl RtActivatable<ICameraIntrinsicsFactory> for CameraIntrinsics {}
impl CameraIntrinsics {
    #[inline] pub fn create(focalLength: foundation::numerics::Vector2, principalPoint: foundation::numerics::Vector2, radialDistortion: foundation::numerics::Vector3, tangentialDistortion: foundation::numerics::Vector2, imageWidth: u32, imageHeight: u32) -> Result<CameraIntrinsics> {
        <Self as RtActivatable<ICameraIntrinsicsFactory>>::get_activation_factory().create(focalLength, principalPoint, radialDistortion, tangentialDistortion, imageWidth, imageHeight)
    }
}
DEFINE_CLSID!(CameraIntrinsics(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,68,101,118,105,99,101,115,46,67,111,114,101,46,67,97,109,101,114,97,73,110,116,114,105,110,115,105,99,115,0]) [CLSID_CameraIntrinsics]);
DEFINE_IID!(IID_ICameraIntrinsics2, 215655495, 1944, 19277, 131, 159, 197, 236, 65, 77, 178, 122);
RT_INTERFACE!{interface ICameraIntrinsics2(ICameraIntrinsics2Vtbl, ICameraIntrinsics2_Abi): IInspectable(IInspectableVtbl) [IID_ICameraIntrinsics2] {
    fn get_UndistortedProjectionTransform(&self, out: *mut foundation::numerics::Matrix4x4) -> HRESULT,
    fn DistortPoint(&self, input: foundation::Point, out: *mut foundation::Point) -> HRESULT,
    fn DistortPoints(&self, inputsSize: u32, inputs: *mut foundation::Point, resultsSize: u32, results: *mut foundation::Point) -> HRESULT,
    fn UndistortPoint(&self, input: foundation::Point, out: *mut foundation::Point) -> HRESULT,
    fn UndistortPoints(&self, inputsSize: u32, inputs: *mut foundation::Point, resultsSize: u32, results: *mut foundation::Point) -> HRESULT
}}
impl ICameraIntrinsics2 {
    #[inline] pub fn get_undistorted_projection_transform(&self) -> Result<foundation::numerics::Matrix4x4> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UndistortedProjectionTransform)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn distort_point(&self, input: foundation::Point) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).DistortPoint)(self.0.as_abi() as *const _ as *mut _, input, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn distort_points(&self, inputs: &[foundation::Point], results: &mut [foundation::Point]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).DistortPoints)(self.0.as_abi() as *const _ as *mut _, inputs.len() as u32, inputs.as_ptr() as *mut _, results.len() as u32, results.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn undistort_point(&self, input: foundation::Point) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).UndistortPoint)(self.0.as_abi() as *const _ as *mut _, input, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn undistort_points(&self, inputs: &[foundation::Point], results: &mut [foundation::Point]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).UndistortPoints)(self.0.as_abi() as *const _ as *mut _, inputs.len() as u32, inputs.as_ptr() as *mut _, results.len() as u32, results.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICameraIntrinsicsFactory, 3235759238, 8498, 18996, 166, 89, 155, 254, 42, 5, 87, 18);
RT_INTERFACE!{static interface ICameraIntrinsicsFactory(ICameraIntrinsicsFactoryVtbl, ICameraIntrinsicsFactory_Abi): IInspectable(IInspectableVtbl) [IID_ICameraIntrinsicsFactory] {
    fn Create(&self, focalLength: foundation::numerics::Vector2, principalPoint: foundation::numerics::Vector2, radialDistortion: foundation::numerics::Vector3, tangentialDistortion: foundation::numerics::Vector2, imageWidth: u32, imageHeight: u32, out: *mut <CameraIntrinsics as RtType>::Abi) -> HRESULT
}}
impl ICameraIntrinsicsFactory {
    #[inline] pub fn create(&self, focalLength: foundation::numerics::Vector2, principalPoint: foundation::numerics::Vector2, radialDistortion: foundation::numerics::Vector3, tangentialDistortion: foundation::numerics::Vector2, imageWidth: u32, imageHeight: u32) -> Result<CameraIntrinsics> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, focalLength, principalPoint, radialDistortion, tangentialDistortion, imageWidth, imageHeight, &mut out);
        if hr == S_OK { Ok(CameraIntrinsics::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDepthCorrelatedCoordinateMapper, 4183656955, 35568, 19632, 146, 109, 105, 104, 102, 229, 4, 106);
RT_INTERFACE!{interface IDepthCorrelatedCoordinateMapper(IDepthCorrelatedCoordinateMapperVtbl, IDepthCorrelatedCoordinateMapper_Abi): IInspectable(IInspectableVtbl) [IID_IDepthCorrelatedCoordinateMapper] {
    #[cfg(feature="windows-perception")] fn UnprojectPoint(&self, sourcePoint: foundation::Point, targetCoordinateSystem: <crate::windows::perception::spatial::SpatialCoordinateSystem as RtType>::Abi, out: *mut foundation::numerics::Vector3) -> HRESULT,
    #[cfg(feature="windows-perception")] fn UnprojectPoints(&self, sourcePointsSize: u32, sourcePoints: *mut foundation::Point, targetCoordinateSystem: <crate::windows::perception::spatial::SpatialCoordinateSystem as RtType>::Abi, resultsSize: u32, results: *mut foundation::numerics::Vector3) -> HRESULT,
    #[cfg(feature="windows-perception")] fn MapPoint(&self, sourcePoint: foundation::Point, targetCoordinateSystem: <crate::windows::perception::spatial::SpatialCoordinateSystem as RtType>::Abi, targetCameraIntrinsics: <CameraIntrinsics as RtType>::Abi, out: *mut foundation::Point) -> HRESULT,
    #[cfg(feature="windows-perception")] fn MapPoints(&self, sourcePointsSize: u32, sourcePoints: *mut foundation::Point, targetCoordinateSystem: <crate::windows::perception::spatial::SpatialCoordinateSystem as RtType>::Abi, targetCameraIntrinsics: <CameraIntrinsics as RtType>::Abi, resultsSize: u32, results: *mut foundation::Point) -> HRESULT
}}
impl IDepthCorrelatedCoordinateMapper {
    #[cfg(feature="windows-perception")] #[inline] pub fn unproject_point(&self, sourcePoint: foundation::Point, targetCoordinateSystem: &crate::windows::perception::spatial::SpatialCoordinateSystem) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).UnprojectPoint)(self.0.as_abi() as *const _ as *mut _, sourcePoint, get_abi(targetCoordinateSystem) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-perception")] #[inline] pub fn unproject_points(&self, sourcePoints: &[foundation::Point], targetCoordinateSystem: &crate::windows::perception::spatial::SpatialCoordinateSystem, results: &mut [foundation::numerics::Vector3]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).UnprojectPoints)(self.0.as_abi() as *const _ as *mut _, sourcePoints.len() as u32, sourcePoints.as_ptr() as *mut _, get_abi(targetCoordinateSystem) as *const _ as *mut _, results.len() as u32, results.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-perception")] #[inline] pub fn map_point(&self, sourcePoint: foundation::Point, targetCoordinateSystem: &crate::windows::perception::spatial::SpatialCoordinateSystem, targetCameraIntrinsics: &CameraIntrinsics) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).MapPoint)(self.0.as_abi() as *const _ as *mut _, sourcePoint, get_abi(targetCoordinateSystem) as *const _ as *mut _, get_abi(targetCameraIntrinsics) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-perception")] #[inline] pub fn map_points(&self, sourcePoints: &[foundation::Point], targetCoordinateSystem: &crate::windows::perception::spatial::SpatialCoordinateSystem, targetCameraIntrinsics: &CameraIntrinsics, results: &mut [foundation::Point]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).MapPoints)(self.0.as_abi() as *const _ as *mut _, sourcePoints.len() as u32, sourcePoints.as_ptr() as *mut _, get_abi(targetCoordinateSystem) as *const _ as *mut _, get_abi(targetCameraIntrinsics) as *const _ as *mut _, results.len() as u32, results.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DepthCorrelatedCoordinateMapper: IDepthCorrelatedCoordinateMapper}
DEFINE_IID!(IID_IFrameControlCapabilities, 2835328608, 20126, 17271, 167, 137, 226, 76, 74, 231, 229, 68);
RT_INTERFACE!{interface IFrameControlCapabilities(IFrameControlCapabilitiesVtbl, IFrameControlCapabilities_Abi): IInspectable(IInspectableVtbl) [IID_IFrameControlCapabilities] {
    fn get_Exposure(&self, out: *mut <FrameExposureCapabilities as RtType>::Abi) -> HRESULT,
    fn get_ExposureCompensation(&self, out: *mut <FrameExposureCompensationCapabilities as RtType>::Abi) -> HRESULT,
    fn get_IsoSpeed(&self, out: *mut <FrameIsoSpeedCapabilities as RtType>::Abi) -> HRESULT,
    fn get_Focus(&self, out: *mut <FrameFocusCapabilities as RtType>::Abi) -> HRESULT,
    fn get_PhotoConfirmationSupported(&self, out: *mut bool) -> HRESULT
}}
impl IFrameControlCapabilities {
    #[inline] pub fn get_exposure(&self) -> Result<Option<FrameExposureCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Exposure)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(FrameExposureCapabilities::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_exposure_compensation(&self) -> Result<Option<FrameExposureCompensationCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExposureCompensation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(FrameExposureCompensationCapabilities::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_iso_speed(&self) -> Result<Option<FrameIsoSpeedCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsoSpeed)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(FrameIsoSpeedCapabilities::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_focus(&self) -> Result<Option<FrameFocusCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Focus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(FrameFocusCapabilities::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_photo_confirmation_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhotoConfirmationSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class FrameControlCapabilities: IFrameControlCapabilities}
DEFINE_IID!(IID_IFrameControlCapabilities2, 3466265700, 18224, 17423, 189, 62, 239, 232, 168, 242, 48, 168);
RT_INTERFACE!{interface IFrameControlCapabilities2(IFrameControlCapabilities2Vtbl, IFrameControlCapabilities2_Abi): IInspectable(IInspectableVtbl) [IID_IFrameControlCapabilities2] {
    fn get_Flash(&self, out: *mut <FrameFlashCapabilities as RtType>::Abi) -> HRESULT
}}
impl IFrameControlCapabilities2 {
    #[inline] pub fn get_flash(&self) -> Result<Option<FrameFlashCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Flash)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(FrameFlashCapabilities::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IFrameController, 3244579289, 47855, 16466, 145, 119, 72, 175, 242, 175, 117, 34);
RT_INTERFACE!{interface IFrameController(IFrameControllerVtbl, IFrameController_Abi): IInspectable(IInspectableVtbl) [IID_IFrameController] {
    fn get_ExposureControl(&self, out: *mut <FrameExposureControl as RtType>::Abi) -> HRESULT,
    fn get_ExposureCompensationControl(&self, out: *mut <FrameExposureCompensationControl as RtType>::Abi) -> HRESULT,
    fn get_IsoSpeedControl(&self, out: *mut <FrameIsoSpeedControl as RtType>::Abi) -> HRESULT,
    fn get_FocusControl(&self, out: *mut <FrameFocusControl as RtType>::Abi) -> HRESULT,
    fn get_PhotoConfirmationEnabled(&self, out: *mut <foundation::IReference<bool> as RtType>::Abi) -> HRESULT,
    fn put_PhotoConfirmationEnabled(&self, value: <foundation::IReference<bool> as RtType>::Abi) -> HRESULT
}}
impl IFrameController {
    #[inline] pub fn get_exposure_control(&self) -> Result<Option<FrameExposureControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExposureControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(FrameExposureControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_exposure_compensation_control(&self) -> Result<Option<FrameExposureCompensationControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExposureCompensationControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(FrameExposureCompensationControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_iso_speed_control(&self) -> Result<Option<FrameIsoSpeedControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsoSpeedControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(FrameIsoSpeedControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_focus_control(&self) -> Result<Option<FrameFocusControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FocusControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(FrameFocusControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_photo_confirmation_enabled(&self) -> Result<Option<foundation::IReference<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhotoConfirmationEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_photo_confirmation_enabled(&self, value: &foundation::IReference<bool>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PhotoConfirmationEnabled)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class FrameController: IFrameController}
impl RtActivatable<IActivationFactory> for FrameController {}
DEFINE_CLSID!(FrameController(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,68,101,118,105,99,101,115,46,67,111,114,101,46,70,114,97,109,101,67,111,110,116,114,111,108,108,101,114,0]) [CLSID_FrameController]);
DEFINE_IID!(IID_IFrameController2, 13876341, 55420, 18523, 138, 9, 92, 53, 133, 104, 180, 39);
RT_INTERFACE!{interface IFrameController2(IFrameController2Vtbl, IFrameController2_Abi): IInspectable(IInspectableVtbl) [IID_IFrameController2] {
    fn get_FlashControl(&self, out: *mut <FrameFlashControl as RtType>::Abi) -> HRESULT
}}
impl IFrameController2 {
    #[inline] pub fn get_flash_control(&self) -> Result<Option<FrameFlashControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FlashControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(FrameFlashControl::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IFrameExposureCapabilities, 3183385827, 14725, 20082, 151, 194, 5, 144, 214, 19, 7, 161);
RT_INTERFACE!{interface IFrameExposureCapabilities(IFrameExposureCapabilitiesVtbl, IFrameExposureCapabilities_Abi): IInspectable(IInspectableVtbl) [IID_IFrameExposureCapabilities] {
    fn get_Supported(&self, out: *mut bool) -> HRESULT,
    fn get_Min(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Max(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Step(&self, out: *mut foundation::TimeSpan) -> HRESULT
}}
impl IFrameExposureCapabilities {
    #[inline] pub fn get_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Supported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Min)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Max)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_step(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Step)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class FrameExposureCapabilities: IFrameExposureCapabilities}
DEFINE_IID!(IID_IFrameExposureCompensationCapabilities, 3112740899, 32869, 16878, 176, 79, 114, 34, 101, 149, 69, 0);
RT_INTERFACE!{interface IFrameExposureCompensationCapabilities(IFrameExposureCompensationCapabilitiesVtbl, IFrameExposureCompensationCapabilities_Abi): IInspectable(IInspectableVtbl) [IID_IFrameExposureCompensationCapabilities] {
    fn get_Supported(&self, out: *mut bool) -> HRESULT,
    fn get_Min(&self, out: *mut f32) -> HRESULT,
    fn get_Max(&self, out: *mut f32) -> HRESULT,
    fn get_Step(&self, out: *mut f32) -> HRESULT
}}
impl IFrameExposureCompensationCapabilities {
    #[inline] pub fn get_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Supported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Min)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Max)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_step(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Step)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class FrameExposureCompensationCapabilities: IFrameExposureCompensationCapabilities}
DEFINE_IID!(IID_IFrameExposureCompensationControl, 3914897097, 63481, 18634, 133, 145, 162, 101, 49, 203, 21, 120);
RT_INTERFACE!{interface IFrameExposureCompensationControl(IFrameExposureCompensationControlVtbl, IFrameExposureCompensationControl_Abi): IInspectable(IInspectableVtbl) [IID_IFrameExposureCompensationControl] {
    fn get_Value(&self, out: *mut <foundation::IReference<f32> as RtType>::Abi) -> HRESULT,
    fn put_Value(&self, value: <foundation::IReference<f32> as RtType>::Abi) -> HRESULT
}}
impl IFrameExposureCompensationControl {
    #[inline] pub fn get_value(&self) -> Result<Option<foundation::IReference<f32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Value)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_value(&self, value: &foundation::IReference<f32>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Value)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class FrameExposureCompensationControl: IFrameExposureCompensationControl}
DEFINE_IID!(IID_IFrameExposureControl, 2975881825, 65455, 18258, 182, 33, 245, 182, 241, 23, 244, 50);
RT_INTERFACE!{interface IFrameExposureControl(IFrameExposureControlVtbl, IFrameExposureControl_Abi): IInspectable(IInspectableVtbl) [IID_IFrameExposureControl] {
    fn get_Auto(&self, out: *mut bool) -> HRESULT,
    fn put_Auto(&self, value: bool) -> HRESULT,
    fn get_Value(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn put_Value(&self, value: <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT
}}
impl IFrameExposureControl {
    #[inline] pub fn get_auto(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Auto)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Auto)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Value)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_value(&self, value: &foundation::IReference<foundation::TimeSpan>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Value)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class FrameExposureControl: IFrameExposureControl}
DEFINE_IID!(IID_IFrameFlashCapabilities, 3146989986, 24254, 20322, 130, 35, 14, 43, 5, 191, 187, 208);
RT_INTERFACE!{interface IFrameFlashCapabilities(IFrameFlashCapabilitiesVtbl, IFrameFlashCapabilities_Abi): IInspectable(IInspectableVtbl) [IID_IFrameFlashCapabilities] {
    fn get_Supported(&self, out: *mut bool) -> HRESULT,
    fn get_RedEyeReductionSupported(&self, out: *mut bool) -> HRESULT,
    fn get_PowerSupported(&self, out: *mut bool) -> HRESULT
}}
impl IFrameFlashCapabilities {
    #[inline] pub fn get_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Supported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_red_eye_reduction_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RedEyeReductionSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_power_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PowerSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class FrameFlashCapabilities: IFrameFlashCapabilities}
DEFINE_IID!(IID_IFrameFlashControl, 1976956615, 48453, 20395, 147, 117, 69, 172, 4, 179, 50, 194);
RT_INTERFACE!{interface IFrameFlashControl(IFrameFlashControlVtbl, IFrameFlashControl_Abi): IInspectable(IInspectableVtbl) [IID_IFrameFlashControl] {
    fn get_Mode(&self, out: *mut FrameFlashMode) -> HRESULT,
    fn put_Mode(&self, value: FrameFlashMode) -> HRESULT,
    fn get_Auto(&self, out: *mut bool) -> HRESULT,
    fn put_Auto(&self, value: bool) -> HRESULT,
    fn get_RedEyeReduction(&self, out: *mut bool) -> HRESULT,
    fn put_RedEyeReduction(&self, value: bool) -> HRESULT,
    fn get_PowerPercent(&self, out: *mut f32) -> HRESULT,
    fn put_PowerPercent(&self, value: f32) -> HRESULT
}}
impl IFrameFlashControl {
    #[inline] pub fn get_mode(&self) -> Result<FrameFlashMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_mode(&self, value: FrameFlashMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Mode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_auto(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Auto)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Auto)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_red_eye_reduction(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RedEyeReduction)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_red_eye_reduction(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_RedEyeReduction)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_power_percent(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PowerPercent)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_power_percent(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PowerPercent)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class FrameFlashControl: IFrameFlashControl}
RT_ENUM! { enum FrameFlashMode: i32 {
    Disable = 0, Enable = 1, Global = 2,
}}
DEFINE_IID!(IID_IFrameFocusCapabilities, 2066074968, 448, 16485, 156, 64, 193, 167, 33, 66, 92, 26);
RT_INTERFACE!{interface IFrameFocusCapabilities(IFrameFocusCapabilitiesVtbl, IFrameFocusCapabilities_Abi): IInspectable(IInspectableVtbl) [IID_IFrameFocusCapabilities] {
    fn get_Supported(&self, out: *mut bool) -> HRESULT,
    fn get_Min(&self, out: *mut u32) -> HRESULT,
    fn get_Max(&self, out: *mut u32) -> HRESULT,
    fn get_Step(&self, out: *mut u32) -> HRESULT
}}
impl IFrameFocusCapabilities {
    #[inline] pub fn get_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Supported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Min)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Max)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_step(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Step)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class FrameFocusCapabilities: IFrameFocusCapabilities}
DEFINE_IID!(IID_IFrameFocusControl, 657322448, 55570, 16916, 166, 123, 227, 138, 141, 72, 216, 198);
RT_INTERFACE!{interface IFrameFocusControl(IFrameFocusControlVtbl, IFrameFocusControl_Abi): IInspectable(IInspectableVtbl) [IID_IFrameFocusControl] {
    fn get_Value(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn put_Value(&self, value: <foundation::IReference<u32> as RtType>::Abi) -> HRESULT
}}
impl IFrameFocusControl {
    #[inline] pub fn get_value(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Value)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_value(&self, value: &foundation::IReference<u32>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Value)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class FrameFocusControl: IFrameFocusControl}
DEFINE_IID!(IID_IFrameIsoSpeedCapabilities, 381550433, 28150, 19145, 185, 42, 159, 110, 205, 26, 210, 250);
RT_INTERFACE!{interface IFrameIsoSpeedCapabilities(IFrameIsoSpeedCapabilitiesVtbl, IFrameIsoSpeedCapabilities_Abi): IInspectable(IInspectableVtbl) [IID_IFrameIsoSpeedCapabilities] {
    fn get_Supported(&self, out: *mut bool) -> HRESULT,
    fn get_Min(&self, out: *mut u32) -> HRESULT,
    fn get_Max(&self, out: *mut u32) -> HRESULT,
    fn get_Step(&self, out: *mut u32) -> HRESULT
}}
impl IFrameIsoSpeedCapabilities {
    #[inline] pub fn get_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Supported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Min)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Max)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_step(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Step)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class FrameIsoSpeedCapabilities: IFrameIsoSpeedCapabilities}
DEFINE_IID!(IID_IFrameIsoSpeedControl, 436465645, 30826, 19573, 165, 87, 122, 185, 168, 95, 88, 140);
RT_INTERFACE!{interface IFrameIsoSpeedControl(IFrameIsoSpeedControlVtbl, IFrameIsoSpeedControl_Abi): IInspectable(IInspectableVtbl) [IID_IFrameIsoSpeedControl] {
    fn get_Auto(&self, out: *mut bool) -> HRESULT,
    fn put_Auto(&self, value: bool) -> HRESULT,
    fn get_Value(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn put_Value(&self, value: <foundation::IReference<u32> as RtType>::Abi) -> HRESULT
}}
impl IFrameIsoSpeedControl {
    #[inline] pub fn get_auto(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Auto)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Auto)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Value)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_value(&self, value: &foundation::IReference<u32>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Value)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class FrameIsoSpeedControl: IFrameIsoSpeedControl}
DEFINE_IID!(IID_IVariablePhotoSequenceController, 2143287424, 60812, 17405, 167, 195, 179, 88, 9, 228, 34, 154);
RT_INTERFACE!{interface IVariablePhotoSequenceController(IVariablePhotoSequenceControllerVtbl, IVariablePhotoSequenceController_Abi): IInspectable(IInspectableVtbl) [IID_IVariablePhotoSequenceController] {
    fn get_Supported(&self, out: *mut bool) -> HRESULT,
    fn get_MaxPhotosPerSecond(&self, out: *mut f32) -> HRESULT,
    fn get_PhotosPerSecondLimit(&self, out: *mut f32) -> HRESULT,
    fn put_PhotosPerSecondLimit(&self, value: f32) -> HRESULT,
    fn GetHighestConcurrentFrameRate(&self, captureProperties: <super::super::mediaproperties::IMediaEncodingProperties as RtType>::Abi, out: *mut <super::super::mediaproperties::MediaRatio as RtType>::Abi) -> HRESULT,
    fn GetCurrentFrameRate(&self, out: *mut <super::super::mediaproperties::MediaRatio as RtType>::Abi) -> HRESULT,
    fn get_FrameCapabilities(&self, out: *mut <FrameControlCapabilities as RtType>::Abi) -> HRESULT,
    fn get_DesiredFrameControllers(&self, out: *mut <foundation::collections::IVector<FrameController> as RtType>::Abi) -> HRESULT
}}
impl IVariablePhotoSequenceController {
    #[inline] pub fn get_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Supported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_photos_per_second(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxPhotosPerSecond)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_photos_per_second_limit(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhotosPerSecondLimit)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_photos_per_second_limit(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PhotosPerSecondLimit)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_highest_concurrent_frame_rate(&self, captureProperties: &super::super::mediaproperties::IMediaEncodingProperties) -> Result<Option<super::super::mediaproperties::MediaRatio>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetHighestConcurrentFrameRate)(self.0.as_abi() as *const _ as *mut _, get_abi(captureProperties) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::mediaproperties::MediaRatio::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_current_frame_rate(&self) -> Result<Option<super::super::mediaproperties::MediaRatio>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCurrentFrameRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::mediaproperties::MediaRatio::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_frame_capabilities(&self) -> Result<Option<FrameControlCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameCapabilities)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(FrameControlCapabilities::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_desired_frame_controllers(&self) -> Result<Option<foundation::collections::IVector<FrameController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DesiredFrameControllers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VariablePhotoSequenceController: IVariablePhotoSequenceController}
} // Windows.Media.Devices.Core
} // Windows.Media.Devices
pub mod dialprotocol { // Windows.Media.DialProtocol
use crate::prelude::*;
DEFINE_IID!(IID_IDialApp, 1432353747, 17847, 18931, 187, 215, 48, 45, 182, 8, 70, 70);
RT_INTERFACE!{interface IDialApp(IDialAppVtbl, IDialApp_Abi): IInspectable(IInspectableVtbl) [IID_IDialApp] {
    fn get_AppName(&self, out: *mut HSTRING) -> HRESULT,
    fn RequestLaunchAsync(&self, appArgument: HSTRING, out: *mut <foundation::IAsyncOperation<DialAppLaunchResult> as RtType>::Abi) -> HRESULT,
    fn StopAsync(&self, out: *mut <foundation::IAsyncOperation<DialAppStopResult> as RtType>::Abi) -> HRESULT,
    fn GetAppStateAsync(&self, out: *mut <foundation::IAsyncOperation<DialAppStateDetails> as RtType>::Abi) -> HRESULT
}}
impl IDialApp {
    #[inline] pub fn get_app_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AppName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_launch_async(&self, appArgument: &HStringArg) -> Result<foundation::IAsyncOperation<DialAppLaunchResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestLaunchAsync)(self.0.as_abi() as *const _ as *mut _, appArgument.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn stop_async(&self) -> Result<foundation::IAsyncOperation<DialAppStopResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StopAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_app_state_async(&self) -> Result<foundation::IAsyncOperation<DialAppStateDetails>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAppStateAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DialApp: IDialApp}
RT_ENUM! { enum DialAppLaunchResult: i32 {
    Launched = 0, FailedToLaunch = 1, NotFound = 2, NetworkFailure = 3,
}}
RT_ENUM! { enum DialAppState: i32 {
    Unknown = 0, Stopped = 1, Running = 2, NetworkFailure = 3,
}}
DEFINE_IID!(IID_IDialAppStateDetails, 3720651937, 62942, 16397, 190, 164, 140, 132, 102, 187, 41, 97);
RT_INTERFACE!{interface IDialAppStateDetails(IDialAppStateDetailsVtbl, IDialAppStateDetails_Abi): IInspectable(IInspectableVtbl) [IID_IDialAppStateDetails] {
    fn get_State(&self, out: *mut DialAppState) -> HRESULT,
    fn get_FullXml(&self, out: *mut HSTRING) -> HRESULT
}}
impl IDialAppStateDetails {
    #[inline] pub fn get_state(&self) -> Result<DialAppState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_full_xml(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FullXml)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DialAppStateDetails: IDialAppStateDetails}
RT_ENUM! { enum DialAppStopResult: i32 {
    Stopped = 0, StopFailed = 1, OperationNotSupported = 2, NetworkFailure = 3,
}}
DEFINE_IID!(IID_IDialDevice, 4293979567, 30111, 16850, 162, 10, 127, 41, 206, 11, 55, 132);
RT_INTERFACE!{interface IDialDevice(IDialDeviceVtbl, IDialDevice_Abi): IInspectable(IInspectableVtbl) [IID_IDialDevice] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn GetDialApp(&self, appName: HSTRING, out: *mut <DialApp as RtType>::Abi) -> HRESULT
}}
impl IDialDevice {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_dial_app(&self, appName: &HStringArg) -> Result<Option<DialApp>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDialApp)(self.0.as_abi() as *const _ as *mut _, appName.get(), &mut out);
        if hr == S_OK { Ok(DialApp::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DialDevice: IDialDevice}
impl RtActivatable<IDialDeviceStatics> for DialDevice {}
impl DialDevice {
    #[inline] pub fn get_device_selector(appName: &HStringArg) -> Result<HString> {
        <Self as RtActivatable<IDialDeviceStatics>>::get_activation_factory().get_device_selector(appName)
    }
    #[inline] pub fn from_id_async(value: &HStringArg) -> Result<foundation::IAsyncOperation<DialDevice>> {
        <Self as RtActivatable<IDialDeviceStatics>>::get_activation_factory().from_id_async(value)
    }
    #[cfg(feature="windows-devices")] #[inline] pub fn device_info_supports_dial_async(device: &super::super::devices::enumeration::DeviceInformation) -> Result<foundation::IAsyncOperation<bool>> {
        <Self as RtActivatable<IDialDeviceStatics>>::get_activation_factory().device_info_supports_dial_async(device)
    }
}
DEFINE_CLSID!(DialDevice(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,68,105,97,108,80,114,111,116,111,99,111,108,46,68,105,97,108,68,101,118,105,99,101,0]) [CLSID_DialDevice]);
DEFINE_IID!(IID_IDialDevice2, 3132617685, 23547, 20154, 139, 50, 181, 124, 92, 94, 229, 201);
RT_INTERFACE!{interface IDialDevice2(IDialDevice2Vtbl, IDialDevice2_Abi): IInspectable(IInspectableVtbl) [IID_IDialDevice2] {
    fn get_FriendlyName(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_Thumbnail(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT
}}
impl IDialDevice2 {
    #[inline] pub fn get_friendly_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FriendlyName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_thumbnail(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Thumbnail)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum DialDeviceDisplayStatus: i32 {
    None = 0, Connecting = 1, Connected = 2, Disconnecting = 3, Disconnected = 4, Error = 5,
}}
DEFINE_IID!(IID_IDialDevicePicker, 3128840714, 65369, 20299, 189, 172, 216, 159, 73, 90, 214, 225);
RT_INTERFACE!{interface IDialDevicePicker(IDialDevicePickerVtbl, IDialDevicePicker_Abi): IInspectable(IInspectableVtbl) [IID_IDialDevicePicker] {
    fn get_Filter(&self, out: *mut <DialDevicePickerFilter as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_Appearance(&self, out: *mut <super::super::devices::enumeration::DevicePickerAppearance as RtType>::Abi) -> HRESULT,
    fn add_DialDeviceSelected(&self, handler: <foundation::TypedEventHandler<DialDevicePicker, DialDeviceSelectedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DialDeviceSelected(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_DisconnectButtonClicked(&self, handler: <foundation::TypedEventHandler<DialDevicePicker, DialDisconnectButtonClickedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DisconnectButtonClicked(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_DialDevicePickerDismissed(&self, handler: <foundation::TypedEventHandler<DialDevicePicker, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DialDevicePickerDismissed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn Show(&self, selection: foundation::Rect) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy9(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowWithPlacement(&self, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> HRESULT,
    fn PickSingleDialDeviceAsync(&self, selection: foundation::Rect, out: *mut <foundation::IAsyncOperation<DialDevice> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy11(&self) -> (),
    #[cfg(feature="windows-ui")] fn PickSingleDialDeviceAsyncWithPlacement(&self, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, out: *mut <foundation::IAsyncOperation<DialDevice> as RtType>::Abi) -> HRESULT,
    fn Hide(&self) -> HRESULT,
    fn SetDisplayStatus(&self, device: <DialDevice as RtType>::Abi, status: DialDeviceDisplayStatus) -> HRESULT
}}
impl IDialDevicePicker {
    #[inline] pub fn get_filter(&self) -> Result<Option<DialDevicePickerFilter>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Filter)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DialDevicePickerFilter::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_appearance(&self) -> Result<Option<super::super::devices::enumeration::DevicePickerAppearance>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Appearance)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::enumeration::DevicePickerAppearance::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_dial_device_selected(&self, handler: &foundation::TypedEventHandler<DialDevicePicker, DialDeviceSelectedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_DialDeviceSelected)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_dial_device_selected(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_DialDeviceSelected)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_disconnect_button_clicked(&self, handler: &foundation::TypedEventHandler<DialDevicePicker, DialDisconnectButtonClickedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_DisconnectButtonClicked)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_disconnect_button_clicked(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_DisconnectButtonClicked)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_dial_device_picker_dismissed(&self, handler: &foundation::TypedEventHandler<DialDevicePicker, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_DialDevicePickerDismissed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_dial_device_picker_dismissed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_DialDevicePickerDismissed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn show(&self, selection: foundation::Rect) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Show)(self.0.as_abi() as *const _ as *mut _, selection);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_with_placement(&self, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ShowWithPlacement)(self.0.as_abi() as *const _ as *mut _, selection, preferredPlacement);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn pick_single_dial_device_async(&self, selection: foundation::Rect) -> Result<foundation::IAsyncOperation<DialDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PickSingleDialDeviceAsync)(self.0.as_abi() as *const _ as *mut _, selection, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn pick_single_dial_device_async_with_placement(&self, selection: foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<foundation::IAsyncOperation<DialDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PickSingleDialDeviceAsyncWithPlacement)(self.0.as_abi() as *const _ as *mut _, selection, preferredPlacement, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn hide(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Hide)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_display_status(&self, device: &DialDevice, status: DialDeviceDisplayStatus) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetDisplayStatus)(self.0.as_abi() as *const _ as *mut _, get_abi(device) as *const _ as *mut _, status);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DialDevicePicker: IDialDevicePicker}
impl RtActivatable<IActivationFactory> for DialDevicePicker {}
DEFINE_CLSID!(DialDevicePicker(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,68,105,97,108,80,114,111,116,111,99,111,108,46,68,105,97,108,68,101,118,105,99,101,80,105,99,107,101,114,0]) [CLSID_DialDevicePicker]);
DEFINE_IID!(IID_IDialDevicePickerFilter, 3246166970, 34496, 18525, 184, 214, 15, 154, 143, 100, 21, 144);
RT_INTERFACE!{interface IDialDevicePickerFilter(IDialDevicePickerFilterVtbl, IDialDevicePickerFilter_Abi): IInspectable(IInspectableVtbl) [IID_IDialDevicePickerFilter] {
    fn get_SupportedAppNames(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT
}}
impl IDialDevicePickerFilter {
    #[inline] pub fn get_supported_app_names(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedAppNames)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DialDevicePickerFilter: IDialDevicePickerFilter}
DEFINE_IID!(IID_IDialDeviceSelectedEventArgs, 1208717997, 44150, 18411, 156, 6, 161, 147, 4, 218, 2, 71);
RT_INTERFACE!{interface IDialDeviceSelectedEventArgs(IDialDeviceSelectedEventArgsVtbl, IDialDeviceSelectedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IDialDeviceSelectedEventArgs] {
    fn get_SelectedDialDevice(&self, out: *mut <DialDevice as RtType>::Abi) -> HRESULT
}}
impl IDialDeviceSelectedEventArgs {
    #[inline] pub fn get_selected_dial_device(&self) -> Result<Option<DialDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SelectedDialDevice)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DialDevice::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DialDeviceSelectedEventArgs: IDialDeviceSelectedEventArgs}
DEFINE_IID!(IID_IDialDeviceStatics, 2859060373, 504, 18264, 132, 97, 43, 189, 28, 220, 60, 243);
RT_INTERFACE!{static interface IDialDeviceStatics(IDialDeviceStaticsVtbl, IDialDeviceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IDialDeviceStatics] {
    fn GetDeviceSelector(&self, appName: HSTRING, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, value: HSTRING, out: *mut <foundation::IAsyncOperation<DialDevice> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-devices")] fn DeviceInfoSupportsDialAsync(&self, device: <super::super::devices::enumeration::DeviceInformation as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl IDialDeviceStatics {
    #[inline] pub fn get_device_selector(&self, appName: &HStringArg) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, appName.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, value: &HStringArg) -> Result<foundation::IAsyncOperation<DialDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, value.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn device_info_supports_dial_async(&self, device: &super::super::devices::enumeration::DeviceInformation) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).DeviceInfoSupportsDialAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(device) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDialDisconnectButtonClickedEventArgs, 1383485778, 40065, 20053, 173, 194, 14, 190, 153, 205, 227, 182);
RT_INTERFACE!{interface IDialDisconnectButtonClickedEventArgs(IDialDisconnectButtonClickedEventArgsVtbl, IDialDisconnectButtonClickedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IDialDisconnectButtonClickedEventArgs] {
    fn get_Device(&self, out: *mut <DialDevice as RtType>::Abi) -> HRESULT
}}
impl IDialDisconnectButtonClickedEventArgs {
    #[inline] pub fn get_device(&self) -> Result<Option<DialDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Device)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DialDevice::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DialDisconnectButtonClickedEventArgs: IDialDisconnectButtonClickedEventArgs}
DEFINE_IID!(IID_IDialReceiverApp, 4248730711, 20549, 18190, 179, 4, 77, 217, 177, 62, 125, 17);
RT_INTERFACE!{interface IDialReceiverApp(IDialReceiverAppVtbl, IDialReceiverApp_Abi): IInspectable(IInspectableVtbl) [IID_IDialReceiverApp] {
    fn GetAdditionalDataAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IMap<HString, HString>> as RtType>::Abi) -> HRESULT,
    fn SetAdditionalDataAsync(&self, additionalData: <foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>> as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IDialReceiverApp {
    #[inline] pub fn get_additional_data_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IMap<HString, HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAdditionalDataAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_additional_data_async(&self, additionalData: &foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>>) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetAdditionalDataAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(additionalData) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DialReceiverApp: IDialReceiverApp}
impl RtActivatable<IDialReceiverAppStatics> for DialReceiverApp {}
impl DialReceiverApp {
    #[inline] pub fn get_current() -> Result<Option<DialReceiverApp>> {
        <Self as RtActivatable<IDialReceiverAppStatics>>::get_activation_factory().get_current()
    }
}
DEFINE_CLSID!(DialReceiverApp(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,68,105,97,108,80,114,111,116,111,99,111,108,46,68,105,97,108,82,101,99,101,105,118,101,114,65,112,112,0]) [CLSID_DialReceiverApp]);
DEFINE_IID!(IID_IDialReceiverApp2, 1393317893, 37168, 17068, 165, 4, 25, 119, 220, 178, 234, 138);
RT_INTERFACE!{interface IDialReceiverApp2(IDialReceiverApp2Vtbl, IDialReceiverApp2_Abi): IInspectable(IInspectableVtbl) [IID_IDialReceiverApp2] {
    fn GetUniqueDeviceNameAsync(&self, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT
}}
impl IDialReceiverApp2 {
    #[inline] pub fn get_unique_device_name_async(&self) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetUniqueDeviceNameAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDialReceiverAppStatics, 1394096700, 19510, 19714, 178, 138, 242, 169, 218, 56, 236, 82);
RT_INTERFACE!{static interface IDialReceiverAppStatics(IDialReceiverAppStaticsVtbl, IDialReceiverAppStatics_Abi): IInspectable(IInspectableVtbl) [IID_IDialReceiverAppStatics] {
    fn get_Current(&self, out: *mut <DialReceiverApp as RtType>::Abi) -> HRESULT
}}
impl IDialReceiverAppStatics {
    #[inline] pub fn get_current(&self) -> Result<Option<DialReceiverApp>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Current)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DialReceiverApp::wrap(out)) } else { err(hr) }
    }}
}
} // Windows.Media.DialProtocol
pub mod editing { // Windows.Media.Editing
use crate::prelude::*;
DEFINE_IID!(IID_IBackgroundAudioTrack, 1267839933, 40481, 16998, 169, 194, 103, 221, 1, 26, 35, 87);
RT_INTERFACE!{interface IBackgroundAudioTrack(IBackgroundAudioTrackVtbl, IBackgroundAudioTrack_Abi): IInspectable(IInspectableVtbl) [IID_IBackgroundAudioTrack] {
    fn get_TrimTimeFromStart(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_TrimTimeFromStart(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_TrimTimeFromEnd(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_TrimTimeFromEnd(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_OriginalDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_TrimmedDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_UserData(&self, out: *mut <foundation::collections::IMap<HString, HString> as RtType>::Abi) -> HRESULT,
    fn put_Delay(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_Delay(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_Volume(&self, value: f64) -> HRESULT,
    fn get_Volume(&self, out: *mut f64) -> HRESULT,
    fn Clone(&self, out: *mut <BackgroundAudioTrack as RtType>::Abi) -> HRESULT,
    fn GetAudioEncodingProperties(&self, out: *mut <super::mediaproperties::AudioEncodingProperties as RtType>::Abi) -> HRESULT,
    fn get_AudioEffectDefinitions(&self, out: *mut <foundation::collections::IVector<super::effects::IAudioEffectDefinition> as RtType>::Abi) -> HRESULT
}}
impl IBackgroundAudioTrack {
    #[inline] pub fn get_trim_time_from_start(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TrimTimeFromStart)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_trim_time_from_start(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_TrimTimeFromStart)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_trim_time_from_end(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TrimTimeFromEnd)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_trim_time_from_end(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_TrimTimeFromEnd)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_original_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OriginalDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_trimmed_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TrimmedDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_user_data(&self) -> Result<Option<foundation::collections::IMap<HString, HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_UserData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMap::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_delay(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Delay)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_delay(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Delay)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_volume(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Volume)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_volume(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Volume)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn clone(&self) -> Result<Option<BackgroundAudioTrack>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Clone)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BackgroundAudioTrack::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_encoding_properties(&self) -> Result<Option<super::mediaproperties::AudioEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAudioEncodingProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::mediaproperties::AudioEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_effect_definitions(&self) -> Result<Option<foundation::collections::IVector<super::effects::IAudioEffectDefinition>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioEffectDefinitions)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BackgroundAudioTrack: IBackgroundAudioTrack}
impl RtActivatable<IBackgroundAudioTrackStatics> for BackgroundAudioTrack {}
impl BackgroundAudioTrack {
    #[inline] pub fn create_from_embedded_audio_track(embeddedAudioTrack: &EmbeddedAudioTrack) -> Result<Option<BackgroundAudioTrack>> {
        <Self as RtActivatable<IBackgroundAudioTrackStatics>>::get_activation_factory().create_from_embedded_audio_track(embeddedAudioTrack)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_file_async(file: &super::super::storage::IStorageFile) -> Result<foundation::IAsyncOperation<BackgroundAudioTrack>> {
        <Self as RtActivatable<IBackgroundAudioTrackStatics>>::get_activation_factory().create_from_file_async(file)
    }
}
DEFINE_CLSID!(BackgroundAudioTrack(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,69,100,105,116,105,110,103,46,66,97,99,107,103,114,111,117,110,100,65,117,100,105,111,84,114,97,99,107,0]) [CLSID_BackgroundAudioTrack]);
DEFINE_IID!(IID_IBackgroundAudioTrackStatics, 3652305111, 53272, 17064, 165, 89, 203, 77, 158, 151, 230, 100);
RT_INTERFACE!{static interface IBackgroundAudioTrackStatics(IBackgroundAudioTrackStaticsVtbl, IBackgroundAudioTrackStatics_Abi): IInspectable(IInspectableVtbl) [IID_IBackgroundAudioTrackStatics] {
    fn CreateFromEmbeddedAudioTrack(&self, embeddedAudioTrack: <EmbeddedAudioTrack as RtType>::Abi, out: *mut <BackgroundAudioTrack as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn CreateFromFileAsync(&self, file: <super::super::storage::IStorageFile as RtType>::Abi, out: *mut <foundation::IAsyncOperation<BackgroundAudioTrack> as RtType>::Abi) -> HRESULT
}}
impl IBackgroundAudioTrackStatics {
    #[inline] pub fn create_from_embedded_audio_track(&self, embeddedAudioTrack: &EmbeddedAudioTrack) -> Result<Option<BackgroundAudioTrack>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromEmbeddedAudioTrack)(self.0.as_abi() as *const _ as *mut _, get_abi(embeddedAudioTrack) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BackgroundAudioTrack::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_file_async(&self, file: &super::super::storage::IStorageFile) -> Result<foundation::IAsyncOperation<BackgroundAudioTrack>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromFileAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(file) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IEmbeddedAudioTrack, 1441684090, 11568, 16314, 161, 144, 79, 26, 100, 84, 248, 143);
RT_INTERFACE!{interface IEmbeddedAudioTrack(IEmbeddedAudioTrackVtbl, IEmbeddedAudioTrack_Abi): IInspectable(IInspectableVtbl) [IID_IEmbeddedAudioTrack] {
    fn GetAudioEncodingProperties(&self, out: *mut <super::mediaproperties::AudioEncodingProperties as RtType>::Abi) -> HRESULT
}}
impl IEmbeddedAudioTrack {
    #[inline] pub fn get_audio_encoding_properties(&self) -> Result<Option<super::mediaproperties::AudioEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAudioEncodingProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::mediaproperties::AudioEncodingProperties::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class EmbeddedAudioTrack: IEmbeddedAudioTrack}
DEFINE_IID!(IID_IMediaClip, 1408389990, 24506, 16036, 134, 147, 36, 118, 24, 17, 20, 10);
RT_INTERFACE!{interface IMediaClip(IMediaClipVtbl, IMediaClip_Abi): IInspectable(IInspectableVtbl) [IID_IMediaClip] {
    fn get_TrimTimeFromStart(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_TrimTimeFromStart(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_TrimTimeFromEnd(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_TrimTimeFromEnd(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_OriginalDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_TrimmedDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_UserData(&self, out: *mut <foundation::collections::IMap<HString, HString> as RtType>::Abi) -> HRESULT,
    fn Clone(&self, out: *mut <MediaClip as RtType>::Abi) -> HRESULT,
    fn get_StartTimeInComposition(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_EndTimeInComposition(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_EmbeddedAudioTracks(&self, out: *mut <foundation::collections::IVectorView<EmbeddedAudioTrack> as RtType>::Abi) -> HRESULT,
    fn get_SelectedEmbeddedAudioTrackIndex(&self, out: *mut u32) -> HRESULT,
    fn put_SelectedEmbeddedAudioTrackIndex(&self, value: u32) -> HRESULT,
    fn put_Volume(&self, value: f64) -> HRESULT,
    fn get_Volume(&self, out: *mut f64) -> HRESULT,
    fn GetVideoEncodingProperties(&self, out: *mut <super::mediaproperties::VideoEncodingProperties as RtType>::Abi) -> HRESULT,
    fn get_AudioEffectDefinitions(&self, out: *mut <foundation::collections::IVector<super::effects::IAudioEffectDefinition> as RtType>::Abi) -> HRESULT,
    fn get_VideoEffectDefinitions(&self, out: *mut <foundation::collections::IVector<super::effects::IVideoEffectDefinition> as RtType>::Abi) -> HRESULT
}}
impl IMediaClip {
    #[inline] pub fn get_trim_time_from_start(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TrimTimeFromStart)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_trim_time_from_start(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_TrimTimeFromStart)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_trim_time_from_end(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TrimTimeFromEnd)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_trim_time_from_end(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_TrimTimeFromEnd)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_original_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OriginalDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_trimmed_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TrimmedDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_user_data(&self) -> Result<Option<foundation::collections::IMap<HString, HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_UserData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMap::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn clone(&self) -> Result<Option<MediaClip>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Clone)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaClip::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_start_time_in_composition(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StartTimeInComposition)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_end_time_in_composition(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_EndTimeInComposition)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_embedded_audio_tracks(&self) -> Result<Option<foundation::collections::IVectorView<EmbeddedAudioTrack>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EmbeddedAudioTracks)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_selected_embedded_audio_track_index(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SelectedEmbeddedAudioTrackIndex)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_selected_embedded_audio_track_index(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SelectedEmbeddedAudioTrackIndex)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_volume(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Volume)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_volume(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Volume)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_video_encoding_properties(&self) -> Result<Option<super::mediaproperties::VideoEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetVideoEncodingProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::mediaproperties::VideoEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_effect_definitions(&self) -> Result<Option<foundation::collections::IVector<super::effects::IAudioEffectDefinition>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioEffectDefinitions)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_effect_definitions(&self) -> Result<Option<foundation::collections::IVector<super::effects::IVideoEffectDefinition>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoEffectDefinitions)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaClip: IMediaClip}
impl RtActivatable<IMediaClipStatics> for MediaClip {}
impl RtActivatable<IMediaClipStatics2> for MediaClip {}
impl MediaClip {
    #[cfg(feature="windows-ui")] #[inline] pub fn create_from_color(color: super::super::ui::Color, originalDuration: foundation::TimeSpan) -> Result<Option<MediaClip>> {
        <Self as RtActivatable<IMediaClipStatics>>::get_activation_factory().create_from_color(color, originalDuration)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_file_async(file: &super::super::storage::IStorageFile) -> Result<foundation::IAsyncOperation<MediaClip>> {
        <Self as RtActivatable<IMediaClipStatics>>::get_activation_factory().create_from_file_async(file)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_image_file_async(file: &super::super::storage::IStorageFile, originalDuration: foundation::TimeSpan) -> Result<foundation::IAsyncOperation<MediaClip>> {
        <Self as RtActivatable<IMediaClipStatics>>::get_activation_factory().create_from_image_file_async(file, originalDuration)
    }
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_from_surface(surface: &super::super::graphics::directx::direct3d11::IDirect3DSurface, originalDuration: foundation::TimeSpan) -> Result<Option<MediaClip>> {
        <Self as RtActivatable<IMediaClipStatics2>>::get_activation_factory().create_from_surface(surface, originalDuration)
    }
}
DEFINE_CLSID!(MediaClip(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,69,100,105,116,105,110,103,46,77,101,100,105,97,67,108,105,112,0]) [CLSID_MediaClip]);
DEFINE_IID!(IID_IMediaClipStatics, 4198509416, 37519, 17348, 188, 110, 120, 58, 26, 53, 150, 86);
RT_INTERFACE!{static interface IMediaClipStatics(IMediaClipStaticsVtbl, IMediaClipStatics_Abi): IInspectable(IInspectableVtbl) [IID_IMediaClipStatics] {
    #[cfg(not(feature="windows-ui"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-ui")] fn CreateFromColor(&self, color: super::super::ui::Color, originalDuration: foundation::TimeSpan, out: *mut <MediaClip as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn CreateFromFileAsync(&self, file: <super::super::storage::IStorageFile as RtType>::Abi, out: *mut <foundation::IAsyncOperation<MediaClip> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn CreateFromImageFileAsync(&self, file: <super::super::storage::IStorageFile as RtType>::Abi, originalDuration: foundation::TimeSpan, out: *mut <foundation::IAsyncOperation<MediaClip> as RtType>::Abi) -> HRESULT
}}
impl IMediaClipStatics {
    #[cfg(feature="windows-ui")] #[inline] pub fn create_from_color(&self, color: super::super::ui::Color, originalDuration: foundation::TimeSpan) -> Result<Option<MediaClip>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromColor)(self.0.as_abi() as *const _ as *mut _, color, originalDuration, &mut out);
        if hr == S_OK { Ok(MediaClip::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_file_async(&self, file: &super::super::storage::IStorageFile) -> Result<foundation::IAsyncOperation<MediaClip>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromFileAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(file) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_image_file_async(&self, file: &super::super::storage::IStorageFile, originalDuration: foundation::TimeSpan) -> Result<foundation::IAsyncOperation<MediaClip>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromImageFileAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(file) as *const _ as *mut _, originalDuration, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaClipStatics2, 1528682419, 34126, 19867, 135, 125, 71, 116, 165, 86, 205, 18);
RT_INTERFACE!{static interface IMediaClipStatics2(IMediaClipStatics2Vtbl, IMediaClipStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaClipStatics2] {
    #[cfg(feature="windows-graphics")] fn CreateFromSurface(&self, surface: <super::super::graphics::directx::direct3d11::IDirect3DSurface as RtType>::Abi, originalDuration: foundation::TimeSpan, out: *mut <MediaClip as RtType>::Abi) -> HRESULT
}}
impl IMediaClipStatics2 {
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_from_surface(&self, surface: &super::super::graphics::directx::direct3d11::IDirect3DSurface, originalDuration: foundation::TimeSpan) -> Result<Option<MediaClip>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromSurface)(self.0.as_abi() as *const _ as *mut _, get_abi(surface) as *const _ as *mut _, originalDuration, &mut out);
        if hr == S_OK { Ok(MediaClip::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaComposition, 772204037, 56433, 16854, 184, 55, 45, 43, 193, 74, 41, 71);
RT_INTERFACE!{interface IMediaComposition(IMediaCompositionVtbl, IMediaComposition_Abi): IInspectable(IInspectableVtbl) [IID_IMediaComposition] {
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Clips(&self, out: *mut <foundation::collections::IVector<MediaClip> as RtType>::Abi) -> HRESULT,
    fn get_BackgroundAudioTracks(&self, out: *mut <foundation::collections::IVector<BackgroundAudioTrack> as RtType>::Abi) -> HRESULT,
    fn get_UserData(&self, out: *mut <foundation::collections::IMap<HString, HString> as RtType>::Abi) -> HRESULT,
    fn Clone(&self, out: *mut <MediaComposition as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn SaveAsync(&self, file: <super::super::storage::IStorageFile as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-graphics")] fn GetThumbnailAsync(&self, timeFromStart: foundation::TimeSpan, scaledWidth: i32, scaledHeight: i32, framePrecision: VideoFramePrecision, out: *mut <foundation::IAsyncOperation<super::super::graphics::imaging::ImageStream> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-graphics")] fn GetThumbnailsAsync(&self, timesFromStart: <foundation::collections::IIterable<foundation::TimeSpan> as RtType>::Abi, scaledWidth: i32, scaledHeight: i32, framePrecision: VideoFramePrecision, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<super::super::graphics::imaging::ImageStream>> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-storage")] fn RenderToFileAsync(&self, destination: <super::super::storage::IStorageFile as RtType>::Abi, out: *mut <foundation::IAsyncOperationWithProgress<super::transcoding::TranscodeFailureReason, f64> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy9(&self) -> (),
    #[cfg(feature="windows-storage")] fn RenderToFileWithTrimmingPreferenceAsync(&self, destination: <super::super::storage::IStorageFile as RtType>::Abi, trimmingPreference: MediaTrimmingPreference, out: *mut <foundation::IAsyncOperationWithProgress<super::transcoding::TranscodeFailureReason, f64> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy10(&self) -> (),
    #[cfg(feature="windows-storage")] fn RenderToFileWithProfileAsync(&self, destination: <super::super::storage::IStorageFile as RtType>::Abi, trimmingPreference: MediaTrimmingPreference, encodingProfile: <super::mediaproperties::MediaEncodingProfile as RtType>::Abi, out: *mut <foundation::IAsyncOperationWithProgress<super::transcoding::TranscodeFailureReason, f64> as RtType>::Abi) -> HRESULT,
    fn CreateDefaultEncodingProfile(&self, out: *mut <super::mediaproperties::MediaEncodingProfile as RtType>::Abi) -> HRESULT,
    fn GenerateMediaStreamSource(&self, out: *mut <super::core::MediaStreamSource as RtType>::Abi) -> HRESULT,
    fn GenerateMediaStreamSourceWithProfile(&self, encodingProfile: <super::mediaproperties::MediaEncodingProfile as RtType>::Abi, out: *mut <super::core::MediaStreamSource as RtType>::Abi) -> HRESULT,
    fn GeneratePreviewMediaStreamSource(&self, scaledWidth: i32, scaledHeight: i32, out: *mut <super::core::MediaStreamSource as RtType>::Abi) -> HRESULT
}}
impl IMediaComposition {
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_clips(&self) -> Result<Option<foundation::collections::IVector<MediaClip>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Clips)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_background_audio_tracks(&self) -> Result<Option<foundation::collections::IVector<BackgroundAudioTrack>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BackgroundAudioTracks)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_user_data(&self) -> Result<Option<foundation::collections::IMap<HString, HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_UserData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMap::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn clone(&self) -> Result<Option<MediaComposition>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Clone)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaComposition::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn save_async(&self, file: &super::super::storage::IStorageFile) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SaveAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(file) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_thumbnail_async(&self, timeFromStart: foundation::TimeSpan, scaledWidth: i32, scaledHeight: i32, framePrecision: VideoFramePrecision) -> Result<foundation::IAsyncOperation<super::super::graphics::imaging::ImageStream>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetThumbnailAsync)(self.0.as_abi() as *const _ as *mut _, timeFromStart, scaledWidth, scaledHeight, framePrecision, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_thumbnails_async(&self, timesFromStart: &foundation::collections::IIterable<foundation::TimeSpan>, scaledWidth: i32, scaledHeight: i32, framePrecision: VideoFramePrecision) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<super::super::graphics::imaging::ImageStream>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetThumbnailsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(timesFromStart) as *const _ as *mut _, scaledWidth, scaledHeight, framePrecision, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn render_to_file_async(&self, destination: &super::super::storage::IStorageFile) -> Result<foundation::IAsyncOperationWithProgress<super::transcoding::TranscodeFailureReason, f64>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RenderToFileAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(destination) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperationWithProgress::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn render_to_file_with_trimming_preference_async(&self, destination: &super::super::storage::IStorageFile, trimmingPreference: MediaTrimmingPreference) -> Result<foundation::IAsyncOperationWithProgress<super::transcoding::TranscodeFailureReason, f64>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RenderToFileWithTrimmingPreferenceAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(destination) as *const _ as *mut _, trimmingPreference, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperationWithProgress::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn render_to_file_with_profile_async(&self, destination: &super::super::storage::IStorageFile, trimmingPreference: MediaTrimmingPreference, encodingProfile: &super::mediaproperties::MediaEncodingProfile) -> Result<foundation::IAsyncOperationWithProgress<super::transcoding::TranscodeFailureReason, f64>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RenderToFileWithProfileAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(destination) as *const _ as *mut _, trimmingPreference, get_abi(encodingProfile) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperationWithProgress::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_default_encoding_profile(&self) -> Result<Option<super::mediaproperties::MediaEncodingProfile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateDefaultEncodingProfile)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::mediaproperties::MediaEncodingProfile::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn generate_media_stream_source(&self) -> Result<Option<super::core::MediaStreamSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GenerateMediaStreamSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::core::MediaStreamSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn generate_media_stream_source_with_profile(&self, encodingProfile: &super::mediaproperties::MediaEncodingProfile) -> Result<Option<super::core::MediaStreamSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GenerateMediaStreamSourceWithProfile)(self.0.as_abi() as *const _ as *mut _, get_abi(encodingProfile) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::core::MediaStreamSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn generate_preview_media_stream_source(&self, scaledWidth: i32, scaledHeight: i32) -> Result<Option<super::core::MediaStreamSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GeneratePreviewMediaStreamSource)(self.0.as_abi() as *const _ as *mut _, scaledWidth, scaledHeight, &mut out);
        if hr == S_OK { Ok(super::core::MediaStreamSource::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaComposition: IMediaComposition}
impl RtActivatable<IMediaCompositionStatics> for MediaComposition {}
impl RtActivatable<IActivationFactory> for MediaComposition {}
impl MediaComposition {
    #[cfg(feature="windows-storage")] #[inline] pub fn load_async(file: &super::super::storage::StorageFile) -> Result<foundation::IAsyncOperation<MediaComposition>> {
        <Self as RtActivatable<IMediaCompositionStatics>>::get_activation_factory().load_async(file)
    }
}
DEFINE_CLSID!(MediaComposition(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,69,100,105,116,105,110,103,46,77,101,100,105,97,67,111,109,112,111,115,105,116,105,111,110,0]) [CLSID_MediaComposition]);
DEFINE_IID!(IID_IMediaComposition2, 2778616690, 9062, 18732, 190, 200, 230, 223, 186, 109, 2, 129);
RT_INTERFACE!{interface IMediaComposition2(IMediaComposition2Vtbl, IMediaComposition2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaComposition2] {
    fn get_OverlayLayers(&self, out: *mut <foundation::collections::IVector<MediaOverlayLayer> as RtType>::Abi) -> HRESULT
}}
impl IMediaComposition2 {
    #[inline] pub fn get_overlay_layers(&self) -> Result<Option<foundation::collections::IVector<MediaOverlayLayer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_OverlayLayers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaCompositionStatics, 2275446532, 58154, 17870, 143, 102, 163, 13, 240, 118, 98, 36);
RT_INTERFACE!{static interface IMediaCompositionStatics(IMediaCompositionStaticsVtbl, IMediaCompositionStatics_Abi): IInspectable(IInspectableVtbl) [IID_IMediaCompositionStatics] {
    #[cfg(feature="windows-storage")] fn LoadAsync(&self, file: <super::super::storage::StorageFile as RtType>::Abi, out: *mut <foundation::IAsyncOperation<MediaComposition> as RtType>::Abi) -> HRESULT
}}
impl IMediaCompositionStatics {
    #[cfg(feature="windows-storage")] #[inline] pub fn load_async(&self, file: &super::super::storage::StorageFile) -> Result<foundation::IAsyncOperation<MediaComposition>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).LoadAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(file) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaOverlay, 2835525213, 30825, 18480, 138, 177, 148, 220, 1, 192, 95, 164);
RT_INTERFACE!{interface IMediaOverlay(IMediaOverlayVtbl, IMediaOverlay_Abi): IInspectable(IInspectableVtbl) [IID_IMediaOverlay] {
    fn get_Position(&self, out: *mut foundation::Rect) -> HRESULT,
    fn put_Position(&self, value: foundation::Rect) -> HRESULT,
    fn put_Delay(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_Delay(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Opacity(&self, out: *mut f64) -> HRESULT,
    fn put_Opacity(&self, value: f64) -> HRESULT,
    fn Clone(&self, out: *mut <MediaOverlay as RtType>::Abi) -> HRESULT,
    fn get_Clip(&self, out: *mut <MediaClip as RtType>::Abi) -> HRESULT,
    fn get_AudioEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_AudioEnabled(&self, value: bool) -> HRESULT
}}
impl IMediaOverlay {
    #[inline] pub fn get_position(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_position(&self, value: foundation::Rect) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Position)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_delay(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Delay)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_delay(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Delay)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_opacity(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Opacity)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_opacity(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Opacity)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn clone(&self) -> Result<Option<MediaOverlay>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Clone)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaOverlay::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_clip(&self) -> Result<Option<MediaClip>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Clip)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaClip::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_audio_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AudioEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaOverlay: IMediaOverlay}
impl RtActivatable<IMediaOverlayFactory> for MediaOverlay {}
impl MediaOverlay {
    #[inline] pub fn create(clip: &MediaClip) -> Result<MediaOverlay> {
        <Self as RtActivatable<IMediaOverlayFactory>>::get_activation_factory().create(clip)
    }
    #[inline] pub fn create_with_position_and_opacity(clip: &MediaClip, position: foundation::Rect, opacity: f64) -> Result<MediaOverlay> {
        <Self as RtActivatable<IMediaOverlayFactory>>::get_activation_factory().create_with_position_and_opacity(clip, position, opacity)
    }
}
DEFINE_CLSID!(MediaOverlay(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,69,100,105,116,105,110,103,46,77,101,100,105,97,79,118,101,114,108,97,121,0]) [CLSID_MediaOverlay]);
DEFINE_IID!(IID_IMediaOverlayFactory, 3045360266, 24968, 20367, 162, 224, 170, 85, 45, 89, 142, 24);
RT_INTERFACE!{static interface IMediaOverlayFactory(IMediaOverlayFactoryVtbl, IMediaOverlayFactory_Abi): IInspectable(IInspectableVtbl) [IID_IMediaOverlayFactory] {
    fn Create(&self, clip: <MediaClip as RtType>::Abi, out: *mut <MediaOverlay as RtType>::Abi) -> HRESULT,
    fn CreateWithPositionAndOpacity(&self, clip: <MediaClip as RtType>::Abi, position: foundation::Rect, opacity: f64, out: *mut <MediaOverlay as RtType>::Abi) -> HRESULT
}}
impl IMediaOverlayFactory {
    #[inline] pub fn create(&self, clip: &MediaClip) -> Result<MediaOverlay> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(clip) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaOverlay::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_position_and_opacity(&self, clip: &MediaClip, position: foundation::Rect, opacity: f64) -> Result<MediaOverlay> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithPositionAndOpacity)(self.0.as_abi() as *const _ as *mut _, get_abi(clip) as *const _ as *mut _, position, opacity, &mut out);
        if hr == S_OK { Ok(MediaOverlay::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaOverlayLayer, 2799286871, 61146, 18118, 187, 229, 227, 152, 200, 65, 104, 172);
RT_INTERFACE!{interface IMediaOverlayLayer(IMediaOverlayLayerVtbl, IMediaOverlayLayer_Abi): IInspectable(IInspectableVtbl) [IID_IMediaOverlayLayer] {
    fn Clone(&self, out: *mut <MediaOverlayLayer as RtType>::Abi) -> HRESULT,
    fn get_Overlays(&self, out: *mut <foundation::collections::IVector<MediaOverlay> as RtType>::Abi) -> HRESULT,
    fn get_CustomCompositorDefinition(&self, out: *mut <super::effects::IVideoCompositorDefinition as RtType>::Abi) -> HRESULT
}}
impl IMediaOverlayLayer {
    #[inline] pub fn clone(&self) -> Result<Option<MediaOverlayLayer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Clone)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaOverlayLayer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_overlays(&self) -> Result<Option<foundation::collections::IVector<MediaOverlay>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Overlays)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_custom_compositor_definition(&self) -> Result<Option<super::effects::IVideoCompositorDefinition>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CustomCompositorDefinition)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::effects::IVideoCompositorDefinition::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaOverlayLayer: IMediaOverlayLayer}
impl RtActivatable<IMediaOverlayLayerFactory> for MediaOverlayLayer {}
impl RtActivatable<IActivationFactory> for MediaOverlayLayer {}
impl MediaOverlayLayer {
    #[inline] pub fn create_with_compositor_definition(compositorDefinition: &super::effects::IVideoCompositorDefinition) -> Result<MediaOverlayLayer> {
        <Self as RtActivatable<IMediaOverlayLayerFactory>>::get_activation_factory().create_with_compositor_definition(compositorDefinition)
    }
}
DEFINE_CLSID!(MediaOverlayLayer(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,69,100,105,116,105,110,103,46,77,101,100,105,97,79,118,101,114,108,97,121,76,97,121,101,114,0]) [CLSID_MediaOverlayLayer]);
DEFINE_IID!(IID_IMediaOverlayLayerFactory, 2491200627, 41886, 17250, 171, 191, 159, 139, 80, 112, 160, 98);
RT_INTERFACE!{static interface IMediaOverlayLayerFactory(IMediaOverlayLayerFactoryVtbl, IMediaOverlayLayerFactory_Abi): IInspectable(IInspectableVtbl) [IID_IMediaOverlayLayerFactory] {
    fn CreateWithCompositorDefinition(&self, compositorDefinition: <super::effects::IVideoCompositorDefinition as RtType>::Abi, out: *mut <MediaOverlayLayer as RtType>::Abi) -> HRESULT
}}
impl IMediaOverlayLayerFactory {
    #[inline] pub fn create_with_compositor_definition(&self, compositorDefinition: &super::effects::IVideoCompositorDefinition) -> Result<MediaOverlayLayer> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithCompositorDefinition)(self.0.as_abi() as *const _ as *mut _, get_abi(compositorDefinition) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaOverlayLayer::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum MediaTrimmingPreference: i32 {
    Fast = 0, Precise = 1,
}}
RT_ENUM! { enum VideoFramePrecision: i32 {
    NearestFrame = 0, NearestKeyFrame = 1,
}}
} // Windows.Media.Editing
pub mod effects { // Windows.Media.Effects
use crate::prelude::*;
DEFINE_IID!(IID_IAudioCaptureEffectsManager, 2407907953, 909, 17299, 130, 152, 84, 1, 16, 96, 142, 239);
RT_INTERFACE!{interface IAudioCaptureEffectsManager(IAudioCaptureEffectsManagerVtbl, IAudioCaptureEffectsManager_Abi): IInspectable(IInspectableVtbl) [IID_IAudioCaptureEffectsManager] {
    fn add_AudioCaptureEffectsChanged(&self, handler: <foundation::TypedEventHandler<AudioCaptureEffectsManager, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AudioCaptureEffectsChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn GetAudioCaptureEffects(&self, out: *mut <foundation::collections::IVectorView<AudioEffect> as RtType>::Abi) -> HRESULT
}}
impl IAudioCaptureEffectsManager {
    #[inline] pub fn add_audio_capture_effects_changed(&self, handler: &foundation::TypedEventHandler<AudioCaptureEffectsManager, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AudioCaptureEffectsChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_audio_capture_effects_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AudioCaptureEffectsChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_capture_effects(&self) -> Result<Option<foundation::collections::IVectorView<AudioEffect>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAudioCaptureEffects)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioCaptureEffectsManager: IAudioCaptureEffectsManager}
DEFINE_IID!(IID_IAudioEffect, 883620433, 37383, 16469, 190, 147, 110, 87, 52, 168, 106, 228);
RT_INTERFACE!{interface IAudioEffect(IAudioEffectVtbl, IAudioEffect_Abi): IInspectable(IInspectableVtbl) [IID_IAudioEffect] {
    fn get_AudioEffectType(&self, out: *mut AudioEffectType) -> HRESULT
}}
impl IAudioEffect {
    #[inline] pub fn get_audio_effect_type(&self) -> Result<AudioEffectType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioEffectType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioEffect: IAudioEffect}
DEFINE_IID!(IID_IAudioEffectDefinition, 3839359348, 32128, 20339, 144, 137, 227, 28, 157, 185, 194, 148);
RT_INTERFACE!{interface IAudioEffectDefinition(IAudioEffectDefinitionVtbl, IAudioEffectDefinition_Abi): IInspectable(IInspectableVtbl) [IID_IAudioEffectDefinition] {
    fn get_ActivatableClassId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT
}}
impl IAudioEffectDefinition {
    #[inline] pub fn get_activatable_class_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ActivatableClassId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IPropertySet>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IPropertySet::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioEffectDefinition: IAudioEffectDefinition}
impl RtActivatable<IAudioEffectDefinitionFactory> for AudioEffectDefinition {}
impl AudioEffectDefinition {
    #[inline] pub fn create(activatableClassId: &HStringArg) -> Result<AudioEffectDefinition> {
        <Self as RtActivatable<IAudioEffectDefinitionFactory>>::get_activation_factory().create(activatableClassId)
    }
    #[inline] pub fn create_with_properties(activatableClassId: &HStringArg, props: &foundation::collections::IPropertySet) -> Result<AudioEffectDefinition> {
        <Self as RtActivatable<IAudioEffectDefinitionFactory>>::get_activation_factory().create_with_properties(activatableClassId, props)
    }
}
DEFINE_CLSID!(AudioEffectDefinition(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,69,102,102,101,99,116,115,46,65,117,100,105,111,69,102,102,101,99,116,68,101,102,105,110,105,116,105,111,110,0]) [CLSID_AudioEffectDefinition]);
DEFINE_IID!(IID_IAudioEffectDefinitionFactory, 2384307782, 59141, 17901, 138, 43, 252, 78, 79, 64, 90, 151);
RT_INTERFACE!{static interface IAudioEffectDefinitionFactory(IAudioEffectDefinitionFactoryVtbl, IAudioEffectDefinitionFactory_Abi): IInspectable(IInspectableVtbl) [IID_IAudioEffectDefinitionFactory] {
    fn Create(&self, activatableClassId: HSTRING, out: *mut <AudioEffectDefinition as RtType>::Abi) -> HRESULT,
    fn CreateWithProperties(&self, activatableClassId: HSTRING, props: <foundation::collections::IPropertySet as RtType>::Abi, out: *mut <AudioEffectDefinition as RtType>::Abi) -> HRESULT
}}
impl IAudioEffectDefinitionFactory {
    #[inline] pub fn create(&self, activatableClassId: &HStringArg) -> Result<AudioEffectDefinition> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get(), &mut out);
        if hr == S_OK { Ok(AudioEffectDefinition::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_properties(&self, activatableClassId: &HStringArg, props: &foundation::collections::IPropertySet) -> Result<AudioEffectDefinition> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithProperties)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get(), get_abi(props) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioEffectDefinition::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class AudioEffectsManager}
impl RtActivatable<IAudioEffectsManagerStatics> for AudioEffectsManager {}
impl AudioEffectsManager {
    #[inline] pub fn create_audio_render_effects_manager(deviceId: &HStringArg, category: super::render::AudioRenderCategory) -> Result<Option<AudioRenderEffectsManager>> {
        <Self as RtActivatable<IAudioEffectsManagerStatics>>::get_activation_factory().create_audio_render_effects_manager(deviceId, category)
    }
    #[inline] pub fn create_audio_render_effects_manager_with_mode(deviceId: &HStringArg, category: super::render::AudioRenderCategory, mode: super::AudioProcessing) -> Result<Option<AudioRenderEffectsManager>> {
        <Self as RtActivatable<IAudioEffectsManagerStatics>>::get_activation_factory().create_audio_render_effects_manager_with_mode(deviceId, category, mode)
    }
    #[inline] pub fn create_audio_capture_effects_manager(deviceId: &HStringArg, category: super::capture::MediaCategory) -> Result<Option<AudioCaptureEffectsManager>> {
        <Self as RtActivatable<IAudioEffectsManagerStatics>>::get_activation_factory().create_audio_capture_effects_manager(deviceId, category)
    }
    #[inline] pub fn create_audio_capture_effects_manager_with_mode(deviceId: &HStringArg, category: super::capture::MediaCategory, mode: super::AudioProcessing) -> Result<Option<AudioCaptureEffectsManager>> {
        <Self as RtActivatable<IAudioEffectsManagerStatics>>::get_activation_factory().create_audio_capture_effects_manager_with_mode(deviceId, category, mode)
    }
}
DEFINE_CLSID!(AudioEffectsManager(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,69,102,102,101,99,116,115,46,65,117,100,105,111,69,102,102,101,99,116,115,77,97,110,97,103,101,114,0]) [CLSID_AudioEffectsManager]);
DEFINE_IID!(IID_IAudioEffectsManagerStatics, 1715497988, 34554, 18380, 163, 21, 244, 137, 216, 195, 254, 16);
RT_INTERFACE!{static interface IAudioEffectsManagerStatics(IAudioEffectsManagerStaticsVtbl, IAudioEffectsManagerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IAudioEffectsManagerStatics] {
    fn CreateAudioRenderEffectsManager(&self, deviceId: HSTRING, category: super::render::AudioRenderCategory, out: *mut <AudioRenderEffectsManager as RtType>::Abi) -> HRESULT,
    fn CreateAudioRenderEffectsManagerWithMode(&self, deviceId: HSTRING, category: super::render::AudioRenderCategory, mode: super::AudioProcessing, out: *mut <AudioRenderEffectsManager as RtType>::Abi) -> HRESULT,
    fn CreateAudioCaptureEffectsManager(&self, deviceId: HSTRING, category: super::capture::MediaCategory, out: *mut <AudioCaptureEffectsManager as RtType>::Abi) -> HRESULT,
    fn CreateAudioCaptureEffectsManagerWithMode(&self, deviceId: HSTRING, category: super::capture::MediaCategory, mode: super::AudioProcessing, out: *mut <AudioCaptureEffectsManager as RtType>::Abi) -> HRESULT
}}
impl IAudioEffectsManagerStatics {
    #[inline] pub fn create_audio_render_effects_manager(&self, deviceId: &HStringArg, category: super::render::AudioRenderCategory) -> Result<Option<AudioRenderEffectsManager>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateAudioRenderEffectsManager)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), category, &mut out);
        if hr == S_OK { Ok(AudioRenderEffectsManager::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_audio_render_effects_manager_with_mode(&self, deviceId: &HStringArg, category: super::render::AudioRenderCategory, mode: super::AudioProcessing) -> Result<Option<AudioRenderEffectsManager>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateAudioRenderEffectsManagerWithMode)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), category, mode, &mut out);
        if hr == S_OK { Ok(AudioRenderEffectsManager::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_audio_capture_effects_manager(&self, deviceId: &HStringArg, category: super::capture::MediaCategory) -> Result<Option<AudioCaptureEffectsManager>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateAudioCaptureEffectsManager)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), category, &mut out);
        if hr == S_OK { Ok(AudioCaptureEffectsManager::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_audio_capture_effects_manager_with_mode(&self, deviceId: &HStringArg, category: super::capture::MediaCategory, mode: super::AudioProcessing) -> Result<Option<AudioCaptureEffectsManager>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateAudioCaptureEffectsManagerWithMode)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), category, mode, &mut out);
        if hr == S_OK { Ok(AudioCaptureEffectsManager::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum AudioEffectType: i32 {
    Other = 0, AcousticEchoCancellation = 1, NoiseSuppression = 2, AutomaticGainControl = 3, BeamForming = 4, ConstantToneRemoval = 5, Equalizer = 6, LoudnessEqualizer = 7, BassBoost = 8, VirtualSurround = 9, VirtualHeadphones = 10, SpeakerFill = 11, RoomCorrection = 12, BassManagement = 13, EnvironmentalEffects = 14, SpeakerProtection = 15, SpeakerCompensation = 16, DynamicRangeCompression = 17,
}}
DEFINE_IID!(IID_IAudioRenderEffectsManager, 1305053542, 34641, 17074, 191, 203, 57, 202, 120, 100, 189, 71);
RT_INTERFACE!{interface IAudioRenderEffectsManager(IAudioRenderEffectsManagerVtbl, IAudioRenderEffectsManager_Abi): IInspectable(IInspectableVtbl) [IID_IAudioRenderEffectsManager] {
    fn add_AudioRenderEffectsChanged(&self, handler: <foundation::TypedEventHandler<AudioRenderEffectsManager, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AudioRenderEffectsChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn GetAudioRenderEffects(&self, out: *mut <foundation::collections::IVectorView<AudioEffect> as RtType>::Abi) -> HRESULT
}}
impl IAudioRenderEffectsManager {
    #[inline] pub fn add_audio_render_effects_changed(&self, handler: &foundation::TypedEventHandler<AudioRenderEffectsManager, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AudioRenderEffectsChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_audio_render_effects_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AudioRenderEffectsChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_render_effects(&self) -> Result<Option<foundation::collections::IVectorView<AudioEffect>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAudioRenderEffects)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioRenderEffectsManager: IAudioRenderEffectsManager}
DEFINE_IID!(IID_IAudioRenderEffectsManager2, 2823081225, 24268, 17587, 187, 78, 29, 176, 114, 135, 19, 156);
RT_INTERFACE!{interface IAudioRenderEffectsManager2(IAudioRenderEffectsManager2Vtbl, IAudioRenderEffectsManager2_Abi): IInspectable(IInspectableVtbl) [IID_IAudioRenderEffectsManager2] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_EffectsProviderThumbnail(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamWithContentType as RtType>::Abi) -> HRESULT,
    fn get_EffectsProviderSettingsLabel(&self, out: *mut HSTRING) -> HRESULT,
    fn ShowSettingsUI(&self) -> HRESULT
}}
impl IAudioRenderEffectsManager2 {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_effects_provider_thumbnail(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamWithContentType>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EffectsProviderThumbnail)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamWithContentType::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_effects_provider_settings_label(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EffectsProviderSettingsLabel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_settings_ui(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ShowSettingsUI)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBasicAudioEffect, 2349214803, 27584, 18616, 169, 154, 75, 65, 85, 15, 19, 89);
RT_INTERFACE!{interface IBasicAudioEffect(IBasicAudioEffectVtbl, IBasicAudioEffect_Abi): IInspectable(IInspectableVtbl) [IID_IBasicAudioEffect] {
    fn get_UseInputFrameForOutput(&self, out: *mut bool) -> HRESULT,
    fn get_SupportedEncodingProperties(&self, out: *mut <foundation::collections::IVectorView<super::mediaproperties::AudioEncodingProperties> as RtType>::Abi) -> HRESULT,
    fn SetEncodingProperties(&self, encodingProperties: <super::mediaproperties::AudioEncodingProperties as RtType>::Abi) -> HRESULT,
    fn ProcessFrame(&self, context: <ProcessAudioFrameContext as RtType>::Abi) -> HRESULT,
    fn Close(&self, reason: MediaEffectClosedReason) -> HRESULT,
    fn DiscardQueuedFrames(&self) -> HRESULT
}}
impl IBasicAudioEffect {
    #[inline] pub fn get_use_input_frame_for_output(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UseInputFrameForOutput)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_encoding_properties(&self) -> Result<Option<foundation::collections::IVectorView<super::mediaproperties::AudioEncodingProperties>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedEncodingProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_encoding_properties(&self, encodingProperties: &super::mediaproperties::AudioEncodingProperties) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetEncodingProperties)(self.0.as_abi() as *const _ as *mut _, get_abi(encodingProperties) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn process_frame(&self, context: &ProcessAudioFrameContext) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ProcessFrame)(self.0.as_abi() as *const _ as *mut _, get_abi(context) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn close(&self, reason: MediaEffectClosedReason) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Close)(self.0.as_abi() as *const _ as *mut _, reason);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn discard_queued_frames(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).DiscardQueuedFrames)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBasicVideoEffect, 2187511791, 45920, 16574, 148, 155, 47, 244, 47, 243, 86, 147);
RT_INTERFACE!{interface IBasicVideoEffect(IBasicVideoEffectVtbl, IBasicVideoEffect_Abi): IInspectable(IInspectableVtbl) [IID_IBasicVideoEffect] {
    fn get_IsReadOnly(&self, out: *mut bool) -> HRESULT,
    fn get_SupportedMemoryTypes(&self, out: *mut MediaMemoryTypes) -> HRESULT,
    fn get_TimeIndependent(&self, out: *mut bool) -> HRESULT,
    fn get_SupportedEncodingProperties(&self, out: *mut <foundation::collections::IVectorView<super::mediaproperties::VideoEncodingProperties> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-graphics")] fn SetEncodingProperties(&self, encodingProperties: <super::mediaproperties::VideoEncodingProperties as RtType>::Abi, device: <super::super::graphics::directx::direct3d11::IDirect3DDevice as RtType>::Abi) -> HRESULT,
    fn ProcessFrame(&self, context: <ProcessVideoFrameContext as RtType>::Abi) -> HRESULT,
    fn Close(&self, reason: MediaEffectClosedReason) -> HRESULT,
    fn DiscardQueuedFrames(&self) -> HRESULT
}}
impl IBasicVideoEffect {
    #[inline] pub fn get_is_read_only(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsReadOnly)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_memory_types(&self) -> Result<MediaMemoryTypes> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedMemoryTypes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_time_independent(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TimeIndependent)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_encoding_properties(&self) -> Result<Option<foundation::collections::IVectorView<super::mediaproperties::VideoEncodingProperties>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedEncodingProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_encoding_properties(&self, encodingProperties: &super::mediaproperties::VideoEncodingProperties, device: &super::super::graphics::directx::direct3d11::IDirect3DDevice) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetEncodingProperties)(self.0.as_abi() as *const _ as *mut _, get_abi(encodingProperties) as *const _ as *mut _, get_abi(device) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn process_frame(&self, context: &ProcessVideoFrameContext) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ProcessFrame)(self.0.as_abi() as *const _ as *mut _, get_abi(context) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn close(&self, reason: MediaEffectClosedReason) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Close)(self.0.as_abi() as *const _ as *mut _, reason);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn discard_queued_frames(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).DiscardQueuedFrames)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositeVideoFrameContext, 1815085643, 62740, 17016, 165, 247, 185, 24, 128, 73, 209, 16);
RT_INTERFACE!{interface ICompositeVideoFrameContext(ICompositeVideoFrameContextVtbl, ICompositeVideoFrameContext_Abi): IInspectable(IInspectableVtbl) [IID_ICompositeVideoFrameContext] {
    #[cfg(feature="windows-graphics")] fn get_SurfacesToOverlay(&self, out: *mut <foundation::collections::IVectorView<super::super::graphics::directx::direct3d11::IDirect3DSurface> as RtType>::Abi) -> HRESULT,
    fn get_BackgroundFrame(&self, out: *mut <super::VideoFrame as RtType>::Abi) -> HRESULT,
    fn get_OutputFrame(&self, out: *mut <super::VideoFrame as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn GetOverlayForSurface(&self, surfaceToOverlay: <super::super::graphics::directx::direct3d11::IDirect3DSurface as RtType>::Abi, out: *mut <super::editing::MediaOverlay as RtType>::Abi) -> HRESULT
}}
impl ICompositeVideoFrameContext {
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_surfaces_to_overlay(&self) -> Result<Option<foundation::collections::IVectorView<super::super::graphics::directx::direct3d11::IDirect3DSurface>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SurfacesToOverlay)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_background_frame(&self) -> Result<Option<super::VideoFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BackgroundFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::VideoFrame::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_output_frame(&self) -> Result<Option<super::VideoFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_OutputFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::VideoFrame::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_overlay_for_surface(&self, surfaceToOverlay: &super::super::graphics::directx::direct3d11::IDirect3DSurface) -> Result<Option<super::editing::MediaOverlay>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetOverlayForSurface)(self.0.as_abi() as *const _ as *mut _, get_abi(surfaceToOverlay) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::editing::MediaOverlay::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositeVideoFrameContext: ICompositeVideoFrameContext}
RT_ENUM! { enum MediaEffectClosedReason: i32 {
    Done = 0, UnknownError = 1, UnsupportedEncodingFormat = 2, EffectCurrentlyUnloaded = 3,
}}
RT_ENUM! { enum MediaMemoryTypes: i32 {
    Gpu = 0, Cpu = 1, GpuAndCpu = 2,
}}
DEFINE_IID!(IID_IProcessAudioFrameContext, 1289300294, 4642, 18983, 165, 134, 251, 62, 32, 39, 50, 85);
RT_INTERFACE!{interface IProcessAudioFrameContext(IProcessAudioFrameContextVtbl, IProcessAudioFrameContext_Abi): IInspectable(IInspectableVtbl) [IID_IProcessAudioFrameContext] {
    fn get_InputFrame(&self, out: *mut <super::AudioFrame as RtType>::Abi) -> HRESULT,
    fn get_OutputFrame(&self, out: *mut <super::AudioFrame as RtType>::Abi) -> HRESULT
}}
impl IProcessAudioFrameContext {
    #[inline] pub fn get_input_frame(&self) -> Result<Option<super::AudioFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_InputFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::AudioFrame::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_output_frame(&self) -> Result<Option<super::AudioFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_OutputFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::AudioFrame::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ProcessAudioFrameContext: IProcessAudioFrameContext}
DEFINE_IID!(IID_IProcessVideoFrameContext, 661589547, 25697, 16414, 186, 120, 15, 218, 214, 17, 78, 236);
RT_INTERFACE!{interface IProcessVideoFrameContext(IProcessVideoFrameContextVtbl, IProcessVideoFrameContext_Abi): IInspectable(IInspectableVtbl) [IID_IProcessVideoFrameContext] {
    fn get_InputFrame(&self, out: *mut <super::VideoFrame as RtType>::Abi) -> HRESULT,
    fn get_OutputFrame(&self, out: *mut <super::VideoFrame as RtType>::Abi) -> HRESULT
}}
impl IProcessVideoFrameContext {
    #[inline] pub fn get_input_frame(&self) -> Result<Option<super::VideoFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_InputFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::VideoFrame::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_output_frame(&self) -> Result<Option<super::VideoFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_OutputFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::VideoFrame::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ProcessVideoFrameContext: IProcessVideoFrameContext}
DEFINE_IID!(IID_IVideoCompositor, 2232464446, 16908, 16911, 150, 199, 124, 152, 187, 161, 252, 85);
RT_INTERFACE!{interface IVideoCompositor(IVideoCompositorVtbl, IVideoCompositor_Abi): IInspectable(IInspectableVtbl) [IID_IVideoCompositor] {
    fn get_TimeIndependent(&self, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-graphics")] fn SetEncodingProperties(&self, backgroundProperties: <super::mediaproperties::VideoEncodingProperties as RtType>::Abi, device: <super::super::graphics::directx::direct3d11::IDirect3DDevice as RtType>::Abi) -> HRESULT,
    fn CompositeFrame(&self, context: <CompositeVideoFrameContext as RtType>::Abi) -> HRESULT,
    fn Close(&self, reason: MediaEffectClosedReason) -> HRESULT,
    fn DiscardQueuedFrames(&self) -> HRESULT
}}
impl IVideoCompositor {
    #[inline] pub fn get_time_independent(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TimeIndependent)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_encoding_properties(&self, backgroundProperties: &super::mediaproperties::VideoEncodingProperties, device: &super::super::graphics::directx::direct3d11::IDirect3DDevice) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetEncodingProperties)(self.0.as_abi() as *const _ as *mut _, get_abi(backgroundProperties) as *const _ as *mut _, get_abi(device) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn composite_frame(&self, context: &CompositeVideoFrameContext) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).CompositeFrame)(self.0.as_abi() as *const _ as *mut _, get_abi(context) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn close(&self, reason: MediaEffectClosedReason) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Close)(self.0.as_abi() as *const _ as *mut _, reason);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn discard_queued_frames(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).DiscardQueuedFrames)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVideoCompositorDefinition, 2034677968, 8208, 19171, 154, 178, 44, 239, 66, 237, 212, 210);
RT_INTERFACE!{interface IVideoCompositorDefinition(IVideoCompositorDefinitionVtbl, IVideoCompositorDefinition_Abi): IInspectable(IInspectableVtbl) [IID_IVideoCompositorDefinition] {
    fn get_ActivatableClassId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT
}}
impl IVideoCompositorDefinition {
    #[inline] pub fn get_activatable_class_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ActivatableClassId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IPropertySet>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IPropertySet::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VideoCompositorDefinition: IVideoCompositorDefinition}
impl RtActivatable<IVideoCompositorDefinitionFactory> for VideoCompositorDefinition {}
impl VideoCompositorDefinition {
    #[inline] pub fn create(activatableClassId: &HStringArg) -> Result<VideoCompositorDefinition> {
        <Self as RtActivatable<IVideoCompositorDefinitionFactory>>::get_activation_factory().create(activatableClassId)
    }
    #[inline] pub fn create_with_properties(activatableClassId: &HStringArg, props: &foundation::collections::IPropertySet) -> Result<VideoCompositorDefinition> {
        <Self as RtActivatable<IVideoCompositorDefinitionFactory>>::get_activation_factory().create_with_properties(activatableClassId, props)
    }
}
DEFINE_CLSID!(VideoCompositorDefinition(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,69,102,102,101,99,116,115,46,86,105,100,101,111,67,111,109,112,111,115,105,116,111,114,68,101,102,105,110,105,116,105,111,110,0]) [CLSID_VideoCompositorDefinition]);
DEFINE_IID!(IID_IVideoCompositorDefinitionFactory, 1130822928, 26808, 19794, 137, 182, 2, 169, 104, 204, 168, 153);
RT_INTERFACE!{static interface IVideoCompositorDefinitionFactory(IVideoCompositorDefinitionFactoryVtbl, IVideoCompositorDefinitionFactory_Abi): IInspectable(IInspectableVtbl) [IID_IVideoCompositorDefinitionFactory] {
    fn Create(&self, activatableClassId: HSTRING, out: *mut <VideoCompositorDefinition as RtType>::Abi) -> HRESULT,
    fn CreateWithProperties(&self, activatableClassId: HSTRING, props: <foundation::collections::IPropertySet as RtType>::Abi, out: *mut <VideoCompositorDefinition as RtType>::Abi) -> HRESULT
}}
impl IVideoCompositorDefinitionFactory {
    #[inline] pub fn create(&self, activatableClassId: &HStringArg) -> Result<VideoCompositorDefinition> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get(), &mut out);
        if hr == S_OK { Ok(VideoCompositorDefinition::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_properties(&self, activatableClassId: &HStringArg, props: &foundation::collections::IPropertySet) -> Result<VideoCompositorDefinition> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithProperties)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get(), get_abi(props) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoCompositorDefinition::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVideoEffectDefinition, 972262640, 36111, 20286, 132, 252, 45, 70, 165, 41, 121, 67);
RT_INTERFACE!{interface IVideoEffectDefinition(IVideoEffectDefinitionVtbl, IVideoEffectDefinition_Abi): IInspectable(IInspectableVtbl) [IID_IVideoEffectDefinition] {
    fn get_ActivatableClassId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT
}}
impl IVideoEffectDefinition {
    #[inline] pub fn get_activatable_class_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ActivatableClassId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IPropertySet>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IPropertySet::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VideoEffectDefinition: IVideoEffectDefinition}
impl RtActivatable<IVideoEffectDefinitionFactory> for VideoEffectDefinition {}
impl VideoEffectDefinition {
    #[inline] pub fn create(activatableClassId: &HStringArg) -> Result<VideoEffectDefinition> {
        <Self as RtActivatable<IVideoEffectDefinitionFactory>>::get_activation_factory().create(activatableClassId)
    }
    #[inline] pub fn create_with_properties(activatableClassId: &HStringArg, props: &foundation::collections::IPropertySet) -> Result<VideoEffectDefinition> {
        <Self as RtActivatable<IVideoEffectDefinitionFactory>>::get_activation_factory().create_with_properties(activatableClassId, props)
    }
}
DEFINE_CLSID!(VideoEffectDefinition(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,69,102,102,101,99,116,115,46,86,105,100,101,111,69,102,102,101,99,116,68,101,102,105,110,105,116,105,111,110,0]) [CLSID_VideoEffectDefinition]);
DEFINE_IID!(IID_IVideoEffectDefinitionFactory, 2168691534, 28211, 17039, 157, 33, 181, 170, 254, 247, 97, 124);
RT_INTERFACE!{static interface IVideoEffectDefinitionFactory(IVideoEffectDefinitionFactoryVtbl, IVideoEffectDefinitionFactory_Abi): IInspectable(IInspectableVtbl) [IID_IVideoEffectDefinitionFactory] {
    fn Create(&self, activatableClassId: HSTRING, out: *mut <VideoEffectDefinition as RtType>::Abi) -> HRESULT,
    fn CreateWithProperties(&self, activatableClassId: HSTRING, props: <foundation::collections::IPropertySet as RtType>::Abi, out: *mut <VideoEffectDefinition as RtType>::Abi) -> HRESULT
}}
impl IVideoEffectDefinitionFactory {
    #[inline] pub fn create(&self, activatableClassId: &HStringArg) -> Result<VideoEffectDefinition> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get(), &mut out);
        if hr == S_OK { Ok(VideoEffectDefinition::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_properties(&self, activatableClassId: &HStringArg, props: &foundation::collections::IPropertySet) -> Result<VideoEffectDefinition> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithProperties)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get(), get_abi(props) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoEffectDefinition::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVideoTransformEffectDefinition, 2523183978, 7846, 19110, 128, 116, 171, 232, 133, 30, 202, 226);
RT_INTERFACE!{interface IVideoTransformEffectDefinition(IVideoTransformEffectDefinitionVtbl, IVideoTransformEffectDefinition_Abi): IInspectable(IInspectableVtbl) [IID_IVideoTransformEffectDefinition] {
    #[cfg(not(feature="windows-ui"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_PaddingColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_PaddingColor(&self, value: super::super::ui::Color) -> HRESULT,
    fn get_OutputSize(&self, out: *mut foundation::Size) -> HRESULT,
    fn put_OutputSize(&self, value: foundation::Size) -> HRESULT,
    fn get_CropRectangle(&self, out: *mut foundation::Rect) -> HRESULT,
    fn put_CropRectangle(&self, value: foundation::Rect) -> HRESULT,
    fn get_Rotation(&self, out: *mut super::mediaproperties::MediaRotation) -> HRESULT,
    fn put_Rotation(&self, value: super::mediaproperties::MediaRotation) -> HRESULT,
    fn get_Mirror(&self, out: *mut super::mediaproperties::MediaMirroringOptions) -> HRESULT,
    fn put_Mirror(&self, value: super::mediaproperties::MediaMirroringOptions) -> HRESULT,
    fn put_ProcessingAlgorithm(&self, value: super::transcoding::MediaVideoProcessingAlgorithm) -> HRESULT,
    fn get_ProcessingAlgorithm(&self, out: *mut super::transcoding::MediaVideoProcessingAlgorithm) -> HRESULT
}}
impl IVideoTransformEffectDefinition {
    #[cfg(feature="windows-ui")] #[inline] pub fn get_padding_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PaddingColor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_padding_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PaddingColor)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_output_size(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OutputSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_output_size(&self, value: foundation::Size) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_OutputSize)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_crop_rectangle(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CropRectangle)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_crop_rectangle(&self, value: foundation::Rect) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CropRectangle)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_rotation(&self) -> Result<super::mediaproperties::MediaRotation> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Rotation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_rotation(&self, value: super::mediaproperties::MediaRotation) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Rotation)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_mirror(&self) -> Result<super::mediaproperties::MediaMirroringOptions> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mirror)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_mirror(&self, value: super::mediaproperties::MediaMirroringOptions) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Mirror)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_processing_algorithm(&self, value: super::transcoding::MediaVideoProcessingAlgorithm) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ProcessingAlgorithm)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_processing_algorithm(&self) -> Result<super::transcoding::MediaVideoProcessingAlgorithm> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProcessingAlgorithm)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class VideoTransformEffectDefinition: IVideoEffectDefinition}
impl RtActivatable<IActivationFactory> for VideoTransformEffectDefinition {}
DEFINE_CLSID!(VideoTransformEffectDefinition(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,69,102,102,101,99,116,115,46,86,105,100,101,111,84,114,97,110,115,102,111,114,109,69,102,102,101,99,116,68,101,102,105,110,105,116,105,111,110,0]) [CLSID_VideoTransformEffectDefinition]);
DEFINE_IID!(IID_IVideoTransformEffectDefinition2, 4037544095, 26312, 18068, 159, 217, 17, 54, 171, 247, 68, 74);
RT_INTERFACE!{interface IVideoTransformEffectDefinition2(IVideoTransformEffectDefinition2Vtbl, IVideoTransformEffectDefinition2_Abi): IInspectable(IInspectableVtbl) [IID_IVideoTransformEffectDefinition2] {
    fn get_SphericalProjection(&self, out: *mut <VideoTransformSphericalProjection as RtType>::Abi) -> HRESULT
}}
impl IVideoTransformEffectDefinition2 {
    #[inline] pub fn get_spherical_projection(&self) -> Result<Option<VideoTransformSphericalProjection>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SphericalProjection)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoTransformSphericalProjection::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVideoTransformSphericalProjection, 3477340656, 39922, 19513, 159, 65, 224, 34, 81, 74, 132, 104);
RT_INTERFACE!{interface IVideoTransformSphericalProjection(IVideoTransformSphericalProjectionVtbl, IVideoTransformSphericalProjection_Abi): IInspectable(IInspectableVtbl) [IID_IVideoTransformSphericalProjection] {
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsEnabled(&self, value: bool) -> HRESULT,
    fn get_FrameFormat(&self, out: *mut super::mediaproperties::SphericalVideoFrameFormat) -> HRESULT,
    fn put_FrameFormat(&self, value: super::mediaproperties::SphericalVideoFrameFormat) -> HRESULT,
    fn get_ProjectionMode(&self, out: *mut super::playback::SphericalVideoProjectionMode) -> HRESULT,
    fn put_ProjectionMode(&self, value: super::playback::SphericalVideoProjectionMode) -> HRESULT,
    fn get_HorizontalFieldOfViewInDegrees(&self, out: *mut f64) -> HRESULT,
    fn put_HorizontalFieldOfViewInDegrees(&self, value: f64) -> HRESULT,
    fn get_ViewOrientation(&self, out: *mut foundation::numerics::Quaternion) -> HRESULT,
    fn put_ViewOrientation(&self, value: foundation::numerics::Quaternion) -> HRESULT
}}
impl IVideoTransformSphericalProjection {
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_frame_format(&self) -> Result<super::mediaproperties::SphericalVideoFrameFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_frame_format(&self, value: super::mediaproperties::SphericalVideoFrameFormat) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_FrameFormat)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_projection_mode(&self) -> Result<super::playback::SphericalVideoProjectionMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProjectionMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_projection_mode(&self, value: super::playback::SphericalVideoProjectionMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ProjectionMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_horizontal_field_of_view_in_degrees(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HorizontalFieldOfViewInDegrees)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_horizontal_field_of_view_in_degrees(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_HorizontalFieldOfViewInDegrees)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_view_orientation(&self) -> Result<foundation::numerics::Quaternion> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ViewOrientation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_view_orientation(&self, value: foundation::numerics::Quaternion) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ViewOrientation)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class VideoTransformSphericalProjection: IVideoTransformSphericalProjection}
} // Windows.Media.Effects
pub mod faceanalysis { // Windows.Media.FaceAnalysis
use crate::prelude::*;
DEFINE_IID!(IID_IDetectedFace, 2181092436, 26300, 13535, 148, 16, 232, 148, 0, 25, 84, 20);
RT_INTERFACE!{interface IDetectedFace(IDetectedFaceVtbl, IDetectedFace_Abi): IInspectable(IInspectableVtbl) [IID_IDetectedFace] {
    #[cfg(feature="windows-graphics")] fn get_FaceBox(&self, out: *mut super::super::graphics::imaging::BitmapBounds) -> HRESULT
}}
impl IDetectedFace {
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_face_box(&self) -> Result<super::super::graphics::imaging::BitmapBounds> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FaceBox)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DetectedFace: IDetectedFace}
DEFINE_IID!(IID_IFaceDetector, 381055708, 65135, 12567, 141, 149, 195, 240, 77, 81, 99, 12);
RT_INTERFACE!{interface IFaceDetector(IFaceDetectorVtbl, IFaceDetector_Abi): IInspectable(IInspectableVtbl) [IID_IFaceDetector] {
    #[cfg(feature="windows-graphics")] fn DetectFacesAsync(&self, image: <super::super::graphics::imaging::SoftwareBitmap as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVector<DetectedFace>> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn DetectFacesWithSearchAreaAsync(&self, image: <super::super::graphics::imaging::SoftwareBitmap as RtType>::Abi, searchArea: super::super::graphics::imaging::BitmapBounds, out: *mut <foundation::IAsyncOperation<foundation::collections::IVector<DetectedFace>> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn get_MinDetectableFaceSize(&self, out: *mut super::super::graphics::imaging::BitmapSize) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn put_MinDetectableFaceSize(&self, value: super::super::graphics::imaging::BitmapSize) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn get_MaxDetectableFaceSize(&self, out: *mut super::super::graphics::imaging::BitmapSize) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn put_MaxDetectableFaceSize(&self, value: super::super::graphics::imaging::BitmapSize) -> HRESULT
}}
impl IFaceDetector {
    #[cfg(feature="windows-graphics")] #[inline] pub fn detect_faces_async(&self, image: &super::super::graphics::imaging::SoftwareBitmap) -> Result<foundation::IAsyncOperation<foundation::collections::IVector<DetectedFace>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).DetectFacesAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(image) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn detect_faces_with_search_area_async(&self, image: &super::super::graphics::imaging::SoftwareBitmap, searchArea: super::super::graphics::imaging::BitmapBounds) -> Result<foundation::IAsyncOperation<foundation::collections::IVector<DetectedFace>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).DetectFacesWithSearchAreaAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(image) as *const _ as *mut _, searchArea, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_min_detectable_face_size(&self) -> Result<super::super::graphics::imaging::BitmapSize> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinDetectableFaceSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_min_detectable_face_size(&self, value: super::super::graphics::imaging::BitmapSize) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MinDetectableFaceSize)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_max_detectable_face_size(&self) -> Result<super::super::graphics::imaging::BitmapSize> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxDetectableFaceSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_max_detectable_face_size(&self, value: super::super::graphics::imaging::BitmapSize) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MaxDetectableFaceSize)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class FaceDetector: IFaceDetector}
impl RtActivatable<IFaceDetectorStatics> for FaceDetector {}
impl FaceDetector {
    #[inline] pub fn create_async() -> Result<foundation::IAsyncOperation<FaceDetector>> {
        <Self as RtActivatable<IFaceDetectorStatics>>::get_activation_factory().create_async()
    }
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_supported_bitmap_pixel_formats() -> Result<Option<foundation::collections::IVectorView<super::super::graphics::imaging::BitmapPixelFormat>>> {
        <Self as RtActivatable<IFaceDetectorStatics>>::get_activation_factory().get_supported_bitmap_pixel_formats()
    }
    #[cfg(feature="windows-graphics")] #[inline] pub fn is_bitmap_pixel_format_supported(bitmapPixelFormat: super::super::graphics::imaging::BitmapPixelFormat) -> Result<bool> {
        <Self as RtActivatable<IFaceDetectorStatics>>::get_activation_factory().is_bitmap_pixel_format_supported(bitmapPixelFormat)
    }
    #[inline] pub fn get_is_supported() -> Result<bool> {
        <Self as RtActivatable<IFaceDetectorStatics>>::get_activation_factory().get_is_supported()
    }
}
DEFINE_CLSID!(FaceDetector(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,70,97,99,101,65,110,97,108,121,115,105,115,46,70,97,99,101,68,101,116,101,99,116,111,114,0]) [CLSID_FaceDetector]);
DEFINE_IID!(IID_IFaceDetectorStatics, 3154390375, 36935, 13302, 136, 27, 103, 70, 193, 178, 24, 184);
RT_INTERFACE!{static interface IFaceDetectorStatics(IFaceDetectorStaticsVtbl, IFaceDetectorStatics_Abi): IInspectable(IInspectableVtbl) [IID_IFaceDetectorStatics] {
    fn CreateAsync(&self, out: *mut <foundation::IAsyncOperation<FaceDetector> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-graphics")] fn GetSupportedBitmapPixelFormats(&self, out: *mut <foundation::collections::IVectorView<super::super::graphics::imaging::BitmapPixelFormat> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-graphics")] fn IsBitmapPixelFormatSupported(&self, bitmapPixelFormat: super::super::graphics::imaging::BitmapPixelFormat, out: *mut bool) -> HRESULT,
    fn get_IsSupported(&self, out: *mut bool) -> HRESULT
}}
impl IFaceDetectorStatics {
    #[inline] pub fn create_async(&self) -> Result<foundation::IAsyncOperation<FaceDetector>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_supported_bitmap_pixel_formats(&self) -> Result<Option<foundation::collections::IVectorView<super::super::graphics::imaging::BitmapPixelFormat>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetSupportedBitmapPixelFormats)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn is_bitmap_pixel_format_supported(&self, bitmapPixelFormat: super::super::graphics::imaging::BitmapPixelFormat) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsBitmapPixelFormatSupported)(self.0.as_abi() as *const _ as *mut _, bitmapPixelFormat, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IFaceTracker, 1806073228, 43073, 17440, 147, 230, 36, 32, 161, 136, 79, 207);
RT_INTERFACE!{interface IFaceTracker(IFaceTrackerVtbl, IFaceTracker_Abi): IInspectable(IInspectableVtbl) [IID_IFaceTracker] {
    fn ProcessNextFrameAsync(&self, videoFrame: <super::VideoFrame as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVector<DetectedFace>> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn get_MinDetectableFaceSize(&self, out: *mut super::super::graphics::imaging::BitmapSize) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn put_MinDetectableFaceSize(&self, value: super::super::graphics::imaging::BitmapSize) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn get_MaxDetectableFaceSize(&self, out: *mut super::super::graphics::imaging::BitmapSize) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn put_MaxDetectableFaceSize(&self, value: super::super::graphics::imaging::BitmapSize) -> HRESULT
}}
impl IFaceTracker {
    #[inline] pub fn process_next_frame_async(&self, videoFrame: &super::VideoFrame) -> Result<foundation::IAsyncOperation<foundation::collections::IVector<DetectedFace>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ProcessNextFrameAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(videoFrame) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_min_detectable_face_size(&self) -> Result<super::super::graphics::imaging::BitmapSize> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinDetectableFaceSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_min_detectable_face_size(&self, value: super::super::graphics::imaging::BitmapSize) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MinDetectableFaceSize)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_max_detectable_face_size(&self) -> Result<super::super::graphics::imaging::BitmapSize> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxDetectableFaceSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_max_detectable_face_size(&self, value: super::super::graphics::imaging::BitmapSize) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MaxDetectableFaceSize)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class FaceTracker: IFaceTracker}
impl RtActivatable<IFaceTrackerStatics> for FaceTracker {}
impl FaceTracker {
    #[inline] pub fn create_async() -> Result<foundation::IAsyncOperation<FaceTracker>> {
        <Self as RtActivatable<IFaceTrackerStatics>>::get_activation_factory().create_async()
    }
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_supported_bitmap_pixel_formats() -> Result<Option<foundation::collections::IVectorView<super::super::graphics::imaging::BitmapPixelFormat>>> {
        <Self as RtActivatable<IFaceTrackerStatics>>::get_activation_factory().get_supported_bitmap_pixel_formats()
    }
    #[cfg(feature="windows-graphics")] #[inline] pub fn is_bitmap_pixel_format_supported(bitmapPixelFormat: super::super::graphics::imaging::BitmapPixelFormat) -> Result<bool> {
        <Self as RtActivatable<IFaceTrackerStatics>>::get_activation_factory().is_bitmap_pixel_format_supported(bitmapPixelFormat)
    }
    #[inline] pub fn get_is_supported() -> Result<bool> {
        <Self as RtActivatable<IFaceTrackerStatics>>::get_activation_factory().get_is_supported()
    }
}
DEFINE_CLSID!(FaceTracker(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,70,97,99,101,65,110,97,108,121,115,105,115,46,70,97,99,101,84,114,97,99,107,101,114,0]) [CLSID_FaceTracker]);
DEFINE_IID!(IID_IFaceTrackerStatics, 3915551128, 6145, 16293, 147, 46, 49, 215, 103, 175, 108, 77);
RT_INTERFACE!{static interface IFaceTrackerStatics(IFaceTrackerStaticsVtbl, IFaceTrackerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IFaceTrackerStatics] {
    fn CreateAsync(&self, out: *mut <foundation::IAsyncOperation<FaceTracker> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-graphics")] fn GetSupportedBitmapPixelFormats(&self, out: *mut <foundation::collections::IVectorView<super::super::graphics::imaging::BitmapPixelFormat> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-graphics")] fn IsBitmapPixelFormatSupported(&self, bitmapPixelFormat: super::super::graphics::imaging::BitmapPixelFormat, out: *mut bool) -> HRESULT,
    fn get_IsSupported(&self, out: *mut bool) -> HRESULT
}}
impl IFaceTrackerStatics {
    #[inline] pub fn create_async(&self) -> Result<foundation::IAsyncOperation<FaceTracker>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_supported_bitmap_pixel_formats(&self) -> Result<Option<foundation::collections::IVectorView<super::super::graphics::imaging::BitmapPixelFormat>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetSupportedBitmapPixelFormats)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn is_bitmap_pixel_format_supported(&self, bitmapPixelFormat: super::super::graphics::imaging::BitmapPixelFormat) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsBitmapPixelFormatSupported)(self.0.as_abi() as *const _ as *mut _, bitmapPixelFormat, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
} // Windows.Media.FaceAnalysis
pub mod import { // Windows.Media.Import
use crate::prelude::*;
RT_ENUM! { enum PhotoImportAccessMode: i32 {
    ReadWrite = 0, ReadOnly = 1, ReadAndDelete = 2,
}}
RT_ENUM! { enum PhotoImportConnectionTransport: i32 {
    Unknown = 0, Usb = 1, IP = 2, Bluetooth = 3,
}}
RT_ENUM! { enum PhotoImportContentType: i32 {
    Unknown = 0, Image = 1, Video = 2,
}}
RT_ENUM! { enum PhotoImportContentTypeFilter: i32 {
    OnlyImages = 0, OnlyVideos = 1, ImagesAndVideos = 2, ImagesAndVideosFromCameraRoll = 3,
}}
DEFINE_IID!(IID_IPhotoImportDeleteImportedItemsFromSourceResult, 4108391160, 33853, 17034, 161, 166, 129, 81, 2, 146, 176, 174);
RT_INTERFACE!{interface IPhotoImportDeleteImportedItemsFromSourceResult(IPhotoImportDeleteImportedItemsFromSourceResultVtbl, IPhotoImportDeleteImportedItemsFromSourceResult_Abi): IInspectable(IInspectableVtbl) [IID_IPhotoImportDeleteImportedItemsFromSourceResult] {
    fn get_Session(&self, out: *mut <PhotoImportSession as RtType>::Abi) -> HRESULT,
    fn get_HasSucceeded(&self, out: *mut bool) -> HRESULT,
    fn get_DeletedItems(&self, out: *mut <foundation::collections::IVectorView<PhotoImportItem> as RtType>::Abi) -> HRESULT,
    fn get_PhotosCount(&self, out: *mut u32) -> HRESULT,
    fn get_PhotosSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn get_VideosCount(&self, out: *mut u32) -> HRESULT,
    fn get_VideosSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn get_SidecarsCount(&self, out: *mut u32) -> HRESULT,
    fn get_SidecarsSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn get_SiblingsCount(&self, out: *mut u32) -> HRESULT,
    fn get_SiblingsSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn get_TotalCount(&self, out: *mut u32) -> HRESULT,
    fn get_TotalSizeInBytes(&self, out: *mut u64) -> HRESULT
}}
impl IPhotoImportDeleteImportedItemsFromSourceResult {
    #[inline] pub fn get_session(&self) -> Result<Option<PhotoImportSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Session)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PhotoImportSession::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_has_succeeded(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HasSucceeded)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_deleted_items(&self) -> Result<Option<foundation::collections::IVectorView<PhotoImportItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeletedItems)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_photos_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhotosCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_photos_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhotosSizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_videos_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideosCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_videos_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideosSizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sidecars_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SidecarsCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sidecars_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SidecarsSizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_siblings_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SiblingsCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_siblings_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SiblingsSizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_total_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TotalCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_total_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TotalSizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PhotoImportDeleteImportedItemsFromSourceResult: IPhotoImportDeleteImportedItemsFromSourceResult}
DEFINE_IID!(IID_IPhotoImportFindItemsResult, 957736519, 27768, 18731, 132, 78, 143, 229, 232, 246, 191, 185);
RT_INTERFACE!{interface IPhotoImportFindItemsResult(IPhotoImportFindItemsResultVtbl, IPhotoImportFindItemsResult_Abi): IInspectable(IInspectableVtbl) [IID_IPhotoImportFindItemsResult] {
    fn get_Session(&self, out: *mut <PhotoImportSession as RtType>::Abi) -> HRESULT,
    fn get_HasSucceeded(&self, out: *mut bool) -> HRESULT,
    fn get_FoundItems(&self, out: *mut <foundation::collections::IVectorView<PhotoImportItem> as RtType>::Abi) -> HRESULT,
    fn get_PhotosCount(&self, out: *mut u32) -> HRESULT,
    fn get_PhotosSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn get_VideosCount(&self, out: *mut u32) -> HRESULT,
    fn get_VideosSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn get_SidecarsCount(&self, out: *mut u32) -> HRESULT,
    fn get_SidecarsSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn get_SiblingsCount(&self, out: *mut u32) -> HRESULT,
    fn get_SiblingsSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn get_TotalCount(&self, out: *mut u32) -> HRESULT,
    fn get_TotalSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn SelectAll(&self) -> HRESULT,
    fn SelectNone(&self) -> HRESULT,
    fn SelectNewAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn SetImportMode(&self, value: PhotoImportImportMode) -> HRESULT,
    fn get_ImportMode(&self, out: *mut PhotoImportImportMode) -> HRESULT,
    fn get_SelectedPhotosCount(&self, out: *mut u32) -> HRESULT,
    fn get_SelectedPhotosSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn get_SelectedVideosCount(&self, out: *mut u32) -> HRESULT,
    fn get_SelectedVideosSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn get_SelectedSidecarsCount(&self, out: *mut u32) -> HRESULT,
    fn get_SelectedSidecarsSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn get_SelectedSiblingsCount(&self, out: *mut u32) -> HRESULT,
    fn get_SelectedSiblingsSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn get_SelectedTotalCount(&self, out: *mut u32) -> HRESULT,
    fn get_SelectedTotalSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn add_SelectionChanged(&self, value: <foundation::TypedEventHandler<PhotoImportFindItemsResult, PhotoImportSelectionChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SelectionChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn ImportItemsAsync(&self, out: *mut <foundation::IAsyncOperationWithProgress<PhotoImportImportItemsResult, PhotoImportProgress> as RtType>::Abi) -> HRESULT,
    fn add_ItemImported(&self, value: <foundation::TypedEventHandler<PhotoImportFindItemsResult, PhotoImportItemImportedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ItemImported(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IPhotoImportFindItemsResult {
    #[inline] pub fn get_session(&self) -> Result<Option<PhotoImportSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Session)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PhotoImportSession::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_has_succeeded(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HasSucceeded)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_found_items(&self) -> Result<Option<foundation::collections::IVectorView<PhotoImportItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FoundItems)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_photos_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhotosCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_photos_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhotosSizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_videos_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideosCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_videos_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideosSizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sidecars_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SidecarsCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sidecars_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SidecarsSizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_siblings_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SiblingsCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_siblings_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SiblingsSizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_total_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TotalCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_total_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TotalSizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn select_all(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SelectAll)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn select_none(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SelectNone)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn select_new_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SelectNewAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_import_mode(&self, value: PhotoImportImportMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetImportMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_import_mode(&self) -> Result<PhotoImportImportMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ImportMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_selected_photos_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SelectedPhotosCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_selected_photos_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SelectedPhotosSizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_selected_videos_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SelectedVideosCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_selected_videos_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SelectedVideosSizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_selected_sidecars_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SelectedSidecarsCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_selected_sidecars_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SelectedSidecarsSizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_selected_siblings_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SelectedSiblingsCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_selected_siblings_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SelectedSiblingsSizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_selected_total_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SelectedTotalCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_selected_total_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SelectedTotalSizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_selection_changed(&self, value: &foundation::TypedEventHandler<PhotoImportFindItemsResult, PhotoImportSelectionChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SelectionChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_selection_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SelectionChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn import_items_async(&self) -> Result<foundation::IAsyncOperationWithProgress<PhotoImportImportItemsResult, PhotoImportProgress>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ImportItemsAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperationWithProgress::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_item_imported(&self, value: &foundation::TypedEventHandler<PhotoImportFindItemsResult, PhotoImportItemImportedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ItemImported)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_item_imported(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ItemImported)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PhotoImportFindItemsResult: IPhotoImportFindItemsResult}
DEFINE_IID!(IID_IPhotoImportFindItemsResult2, 4225591867, 60665, 16490, 129, 94, 80, 21, 98, 91, 10, 136);
RT_INTERFACE!{interface IPhotoImportFindItemsResult2(IPhotoImportFindItemsResult2Vtbl, IPhotoImportFindItemsResult2_Abi): IInspectable(IInspectableVtbl) [IID_IPhotoImportFindItemsResult2] {
    fn AddItemsInDateRangeToSelection(&self, rangeStart: foundation::DateTime, rangeLength: foundation::TimeSpan) -> HRESULT
}}
impl IPhotoImportFindItemsResult2 {
    #[inline] pub fn add_items_in_date_range_to_selection(&self, rangeStart: foundation::DateTime, rangeLength: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AddItemsInDateRangeToSelection)(self.0.as_abi() as *const _ as *mut _, rangeStart, rangeLength);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPhotoImportImportItemsResult, 3839161464, 54297, 17475, 168, 78, 240, 106, 133, 12, 11, 0);
RT_INTERFACE!{interface IPhotoImportImportItemsResult(IPhotoImportImportItemsResultVtbl, IPhotoImportImportItemsResult_Abi): IInspectable(IInspectableVtbl) [IID_IPhotoImportImportItemsResult] {
    fn get_Session(&self, out: *mut <PhotoImportSession as RtType>::Abi) -> HRESULT,
    fn get_HasSucceeded(&self, out: *mut bool) -> HRESULT,
    fn get_ImportedItems(&self, out: *mut <foundation::collections::IVectorView<PhotoImportItem> as RtType>::Abi) -> HRESULT,
    fn get_PhotosCount(&self, out: *mut u32) -> HRESULT,
    fn get_PhotosSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn get_VideosCount(&self, out: *mut u32) -> HRESULT,
    fn get_VideosSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn get_SidecarsCount(&self, out: *mut u32) -> HRESULT,
    fn get_SidecarsSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn get_SiblingsCount(&self, out: *mut u32) -> HRESULT,
    fn get_SiblingsSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn get_TotalCount(&self, out: *mut u32) -> HRESULT,
    fn get_TotalSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn DeleteImportedItemsFromSourceAsync(&self, out: *mut <foundation::IAsyncOperationWithProgress<PhotoImportDeleteImportedItemsFromSourceResult, f64> as RtType>::Abi) -> HRESULT
}}
impl IPhotoImportImportItemsResult {
    #[inline] pub fn get_session(&self) -> Result<Option<PhotoImportSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Session)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PhotoImportSession::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_has_succeeded(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HasSucceeded)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_imported_items(&self) -> Result<Option<foundation::collections::IVectorView<PhotoImportItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ImportedItems)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_photos_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhotosCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_photos_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhotosSizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_videos_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideosCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_videos_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideosSizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sidecars_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SidecarsCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sidecars_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SidecarsSizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_siblings_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SiblingsCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_siblings_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SiblingsSizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_total_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TotalCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_total_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TotalSizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn delete_imported_items_from_source_async(&self) -> Result<foundation::IAsyncOperationWithProgress<PhotoImportDeleteImportedItemsFromSourceResult, f64>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).DeleteImportedItemsFromSourceAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperationWithProgress::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PhotoImportImportItemsResult: IPhotoImportImportItemsResult}
RT_ENUM! { enum PhotoImportImportMode: i32 {
    ImportEverything = 0, IgnoreSidecars = 1, IgnoreSiblings = 2, IgnoreSidecarsAndSiblings = 3,
}}
DEFINE_IID!(IID_IPhotoImportItem, 2849013366, 39932, 17336, 179, 86, 99, 59, 106, 152, 140, 158);
RT_INTERFACE!{interface IPhotoImportItem(IPhotoImportItemVtbl, IPhotoImportItem_Abi): IInspectable(IInspectableVtbl) [IID_IPhotoImportItem] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ItemKey(&self, out: *mut u64) -> HRESULT,
    fn get_ContentType(&self, out: *mut PhotoImportContentType) -> HRESULT,
    fn get_SizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn get_Date(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_Sibling(&self, out: *mut <PhotoImportSidecar as RtType>::Abi) -> HRESULT,
    fn get_Sidecars(&self, out: *mut <foundation::collections::IVectorView<PhotoImportSidecar> as RtType>::Abi) -> HRESULT,
    fn get_VideoSegments(&self, out: *mut <foundation::collections::IVectorView<PhotoImportVideoSegment> as RtType>::Abi) -> HRESULT,
    fn get_IsSelected(&self, out: *mut bool) -> HRESULT,
    fn put_IsSelected(&self, value: bool) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy10(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Thumbnail(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    fn get_ImportedFileNames(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT,
    fn get_DeletedFileNames(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT
}}
impl IPhotoImportItem {
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Name)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_item_key(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ItemKey)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_content_type(&self) -> Result<PhotoImportContentType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ContentType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_date(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Date)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sibling(&self) -> Result<Option<PhotoImportSidecar>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Sibling)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PhotoImportSidecar::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sidecars(&self) -> Result<Option<foundation::collections::IVectorView<PhotoImportSidecar>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Sidecars)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_segments(&self) -> Result<Option<foundation::collections::IVectorView<PhotoImportVideoSegment>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoSegments)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_selected(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsSelected)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_selected(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsSelected)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_thumbnail(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Thumbnail)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_imported_file_names(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ImportedFileNames)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deleted_file_names(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeletedFileNames)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PhotoImportItem: IPhotoImportItem}
DEFINE_IID!(IID_IPhotoImportItem2, 4043650309, 62779, 18083, 158, 48, 54, 16, 121, 26, 145, 16);
RT_INTERFACE!{interface IPhotoImportItem2(IPhotoImportItem2Vtbl, IPhotoImportItem2_Abi): IInspectable(IInspectableVtbl) [IID_IPhotoImportItem2] {
    fn get_Path(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPhotoImportItem2 {
    #[inline] pub fn get_path(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Path)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPhotoImportItemImportedEventArgs, 1120612317, 32104, 18357, 188, 124, 206, 183, 62, 12, 119, 220);
RT_INTERFACE!{interface IPhotoImportItemImportedEventArgs(IPhotoImportItemImportedEventArgsVtbl, IPhotoImportItemImportedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPhotoImportItemImportedEventArgs] {
    fn get_ImportedItem(&self, out: *mut <PhotoImportItem as RtType>::Abi) -> HRESULT
}}
impl IPhotoImportItemImportedEventArgs {
    #[inline] pub fn get_imported_item(&self) -> Result<Option<PhotoImportItem>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ImportedItem)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PhotoImportItem::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PhotoImportItemImportedEventArgs: IPhotoImportItemImportedEventArgs}
RT_ENUM! { enum PhotoImportItemSelectionMode: i32 {
    SelectAll = 0, SelectNone = 1, SelectNew = 2,
}}
RT_CLASS!{static class PhotoImportManager}
impl RtActivatable<IPhotoImportManagerStatics> for PhotoImportManager {}
impl PhotoImportManager {
    #[inline] pub fn is_supported_async() -> Result<foundation::IAsyncOperation<bool>> {
        <Self as RtActivatable<IPhotoImportManagerStatics>>::get_activation_factory().is_supported_async()
    }
    #[inline] pub fn find_all_sources_async() -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<PhotoImportSource>>> {
        <Self as RtActivatable<IPhotoImportManagerStatics>>::get_activation_factory().find_all_sources_async()
    }
    #[inline] pub fn get_pending_operations() -> Result<Option<foundation::collections::IVectorView<PhotoImportOperation>>> {
        <Self as RtActivatable<IPhotoImportManagerStatics>>::get_activation_factory().get_pending_operations()
    }
}
DEFINE_CLSID!(PhotoImportManager(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,73,109,112,111,114,116,46,80,104,111,116,111,73,109,112,111,114,116,77,97,110,97,103,101,114,0]) [CLSID_PhotoImportManager]);
DEFINE_IID!(IID_IPhotoImportManagerStatics, 661753917, 41030, 20230, 155, 156, 191, 214, 98, 232, 50, 135);
RT_INTERFACE!{static interface IPhotoImportManagerStatics(IPhotoImportManagerStaticsVtbl, IPhotoImportManagerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IPhotoImportManagerStatics] {
    fn IsSupportedAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn FindAllSourcesAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<PhotoImportSource>> as RtType>::Abi) -> HRESULT,
    fn GetPendingOperations(&self, out: *mut <foundation::collections::IVectorView<PhotoImportOperation> as RtType>::Abi) -> HRESULT
}}
impl IPhotoImportManagerStatics {
    #[inline] pub fn is_supported_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).IsSupportedAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_sources_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<PhotoImportSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindAllSourcesAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_pending_operations(&self) -> Result<Option<foundation::collections::IVectorView<PhotoImportOperation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetPendingOperations)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPhotoImportOperation, 3656882148, 41114, 20196, 164, 177, 32, 148, 2, 119, 165, 190);
RT_INTERFACE!{interface IPhotoImportOperation(IPhotoImportOperationVtbl, IPhotoImportOperation_Abi): IInspectable(IInspectableVtbl) [IID_IPhotoImportOperation] {
    fn get_Stage(&self, out: *mut PhotoImportStage) -> HRESULT,
    fn get_Session(&self, out: *mut <PhotoImportSession as RtType>::Abi) -> HRESULT,
    fn get_ContinueFindingItemsAsync(&self, out: *mut <foundation::IAsyncOperationWithProgress<PhotoImportFindItemsResult, u32> as RtType>::Abi) -> HRESULT,
    fn get_ContinueImportingItemsAsync(&self, out: *mut <foundation::IAsyncOperationWithProgress<PhotoImportImportItemsResult, PhotoImportProgress> as RtType>::Abi) -> HRESULT,
    fn get_ContinueDeletingImportedItemsFromSourceAsync(&self, out: *mut <foundation::IAsyncOperationWithProgress<PhotoImportDeleteImportedItemsFromSourceResult, f64> as RtType>::Abi) -> HRESULT
}}
impl IPhotoImportOperation {
    #[inline] pub fn get_stage(&self) -> Result<PhotoImportStage> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Stage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_session(&self) -> Result<Option<PhotoImportSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Session)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PhotoImportSession::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_continue_finding_items_async(&self) -> Result<foundation::IAsyncOperationWithProgress<PhotoImportFindItemsResult, u32>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ContinueFindingItemsAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperationWithProgress::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_continue_importing_items_async(&self) -> Result<foundation::IAsyncOperationWithProgress<PhotoImportImportItemsResult, PhotoImportProgress>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ContinueImportingItemsAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperationWithProgress::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_continue_deleting_imported_items_from_source_async(&self) -> Result<foundation::IAsyncOperationWithProgress<PhotoImportDeleteImportedItemsFromSourceResult, f64>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ContinueDeletingImportedItemsFromSourceAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperationWithProgress::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PhotoImportOperation: IPhotoImportOperation}
RT_ENUM! { enum PhotoImportPowerSource: i32 {
    Unknown = 0, Battery = 1, External = 2,
}}
RT_STRUCT! { struct PhotoImportProgress {
    ItemsImported: u32, TotalItemsToImport: u32, BytesImported: u64, TotalBytesToImport: u64, ImportProgress: f64,
}}
DEFINE_IID!(IID_IPhotoImportSelectionChangedEventArgs, 273028994, 64157, 19504, 139, 201, 77, 100, 145, 21, 114, 213);
RT_INTERFACE!{interface IPhotoImportSelectionChangedEventArgs(IPhotoImportSelectionChangedEventArgsVtbl, IPhotoImportSelectionChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPhotoImportSelectionChangedEventArgs] {
    fn get_IsSelectionEmpty(&self, out: *mut bool) -> HRESULT
}}
impl IPhotoImportSelectionChangedEventArgs {
    #[inline] pub fn get_is_selection_empty(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsSelectionEmpty)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PhotoImportSelectionChangedEventArgs: IPhotoImportSelectionChangedEventArgs}
DEFINE_IID!(IID_IPhotoImportSession, 2858652014, 60635, 20222, 148, 198, 95, 92, 175, 227, 76, 251);
RT_INTERFACE!{interface IPhotoImportSession(IPhotoImportSessionVtbl, IPhotoImportSession_Abi): IInspectable(IInspectableVtbl) [IID_IPhotoImportSession] {
    fn get_Source(&self, out: *mut <PhotoImportSource as RtType>::Abi) -> HRESULT,
    fn get_SessionId(&self, out: *mut Guid) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_DestinationFolder(&self, value: <super::super::storage::IStorageFolder as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_DestinationFolder(&self, out: *mut <super::super::storage::IStorageFolder as RtType>::Abi) -> HRESULT,
    fn put_AppendSessionDateToDestinationFolder(&self, value: bool) -> HRESULT,
    fn get_AppendSessionDateToDestinationFolder(&self, out: *mut bool) -> HRESULT,
    fn put_SubfolderCreationMode(&self, value: PhotoImportSubfolderCreationMode) -> HRESULT,
    fn get_SubfolderCreationMode(&self, out: *mut PhotoImportSubfolderCreationMode) -> HRESULT,
    fn put_DestinationFileNamePrefix(&self, value: HSTRING) -> HRESULT,
    fn get_DestinationFileNamePrefix(&self, out: *mut HSTRING) -> HRESULT,
    fn FindItemsAsync(&self, contentTypeFilter: PhotoImportContentTypeFilter, itemSelectionMode: PhotoImportItemSelectionMode, out: *mut <foundation::IAsyncOperationWithProgress<PhotoImportFindItemsResult, u32> as RtType>::Abi) -> HRESULT
}}
impl IPhotoImportSession {
    #[inline] pub fn get_source(&self) -> Result<Option<PhotoImportSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Source)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PhotoImportSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_session_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SessionId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_destination_folder(&self, value: &super::super::storage::IStorageFolder) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DestinationFolder)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_destination_folder(&self) -> Result<Option<super::super::storage::IStorageFolder>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DestinationFolder)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::IStorageFolder::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_append_session_date_to_destination_folder(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AppendSessionDateToDestinationFolder)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_append_session_date_to_destination_folder(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AppendSessionDateToDestinationFolder)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_subfolder_creation_mode(&self, value: PhotoImportSubfolderCreationMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SubfolderCreationMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_subfolder_creation_mode(&self) -> Result<PhotoImportSubfolderCreationMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SubfolderCreationMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_destination_file_name_prefix(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DestinationFileNamePrefix)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_destination_file_name_prefix(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DestinationFileNamePrefix)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_items_async(&self, contentTypeFilter: PhotoImportContentTypeFilter, itemSelectionMode: PhotoImportItemSelectionMode) -> Result<foundation::IAsyncOperationWithProgress<PhotoImportFindItemsResult, u32>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindItemsAsync)(self.0.as_abi() as *const _ as *mut _, contentTypeFilter, itemSelectionMode, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperationWithProgress::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PhotoImportSession: IPhotoImportSession}
DEFINE_IID!(IID_IPhotoImportSession2, 710043408, 16070, 18077, 163, 117, 43, 159, 71, 133, 57, 30);
RT_INTERFACE!{interface IPhotoImportSession2(IPhotoImportSession2Vtbl, IPhotoImportSession2_Abi): IInspectable(IInspectableVtbl) [IID_IPhotoImportSession2] {
    fn put_SubfolderDateFormat(&self, value: PhotoImportSubfolderDateFormat) -> HRESULT,
    fn get_SubfolderDateFormat(&self, out: *mut PhotoImportSubfolderDateFormat) -> HRESULT,
    fn put_RememberDeselectedItems(&self, value: bool) -> HRESULT,
    fn get_RememberDeselectedItems(&self, out: *mut bool) -> HRESULT
}}
impl IPhotoImportSession2 {
    #[inline] pub fn set_subfolder_date_format(&self, value: PhotoImportSubfolderDateFormat) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SubfolderDateFormat)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_subfolder_date_format(&self) -> Result<PhotoImportSubfolderDateFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SubfolderDateFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_remember_deselected_items(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_RememberDeselectedItems)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_remember_deselected_items(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RememberDeselectedItems)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPhotoImportSidecar, 1188550487, 63490, 17607, 156, 152, 122, 113, 244, 188, 20, 134);
RT_INTERFACE!{interface IPhotoImportSidecar(IPhotoImportSidecarVtbl, IPhotoImportSidecar_Abi): IInspectable(IInspectableVtbl) [IID_IPhotoImportSidecar] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn get_Date(&self, out: *mut foundation::DateTime) -> HRESULT
}}
impl IPhotoImportSidecar {
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Name)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_date(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Date)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PhotoImportSidecar: IPhotoImportSidecar}
DEFINE_IID!(IID_IPhotoImportSource, 529441630, 5211, 19670, 135, 241, 84, 150, 90, 152, 47, 239);
RT_INTERFACE!{interface IPhotoImportSource(IPhotoImportSourceVtbl, IPhotoImportSource_Abi): IInspectable(IInspectableVtbl) [IID_IPhotoImportSource] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Manufacturer(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Model(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SerialNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ConnectionProtocol(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ConnectionTransport(&self, out: *mut PhotoImportConnectionTransport) -> HRESULT,
    fn get_Type(&self, out: *mut PhotoImportSourceType) -> HRESULT,
    fn get_PowerSource(&self, out: *mut PhotoImportPowerSource) -> HRESULT,
    fn get_BatteryLevelPercent(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_DateTime(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_StorageMedia(&self, out: *mut <foundation::collections::IVectorView<PhotoImportStorageMedium> as RtType>::Abi) -> HRESULT,
    fn get_IsLocked(&self, out: *mut <foundation::IReference<bool> as RtType>::Abi) -> HRESULT,
    fn get_IsMassStorage(&self, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy15(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Thumbnail(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    fn CreateImportSession(&self, out: *mut <PhotoImportSession as RtType>::Abi) -> HRESULT
}}
impl IPhotoImportSource {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DisplayName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Description)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_manufacturer(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Manufacturer)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_model(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Model)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_serial_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SerialNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connection_protocol(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConnectionProtocol)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connection_transport(&self) -> Result<PhotoImportConnectionTransport> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConnectionTransport)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_type(&self) -> Result<PhotoImportSourceType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Type)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_power_source(&self) -> Result<PhotoImportPowerSource> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PowerSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_battery_level_percent(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BatteryLevelPercent)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_date_time(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DateTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_storage_media(&self) -> Result<Option<foundation::collections::IVectorView<PhotoImportStorageMedium>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_StorageMedia)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_locked(&self) -> Result<Option<foundation::IReference<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsLocked)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_mass_storage(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsMassStorage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_thumbnail(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Thumbnail)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_import_session(&self) -> Result<Option<PhotoImportSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateImportSession)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PhotoImportSession::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PhotoImportSource: IPhotoImportSource}
impl RtActivatable<IPhotoImportSourceStatics> for PhotoImportSource {}
impl PhotoImportSource {
    #[inline] pub fn from_id_async(sourceId: &HStringArg) -> Result<foundation::IAsyncOperation<PhotoImportSource>> {
        <Self as RtActivatable<IPhotoImportSourceStatics>>::get_activation_factory().from_id_async(sourceId)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn from_folder_async(sourceRootFolder: &super::super::storage::IStorageFolder) -> Result<foundation::IAsyncOperation<PhotoImportSource>> {
        <Self as RtActivatable<IPhotoImportSourceStatics>>::get_activation_factory().from_folder_async(sourceRootFolder)
    }
}
DEFINE_CLSID!(PhotoImportSource(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,73,109,112,111,114,116,46,80,104,111,116,111,73,109,112,111,114,116,83,111,117,114,99,101,0]) [CLSID_PhotoImportSource]);
DEFINE_IID!(IID_IPhotoImportSourceStatics, 86566278, 13016, 18044, 140, 238, 35, 161, 178, 244, 62, 133);
RT_INTERFACE!{static interface IPhotoImportSourceStatics(IPhotoImportSourceStaticsVtbl, IPhotoImportSourceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IPhotoImportSourceStatics] {
    fn FromIdAsync(&self, sourceId: HSTRING, out: *mut <foundation::IAsyncOperation<PhotoImportSource> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn FromFolderAsync(&self, sourceRootFolder: <super::super::storage::IStorageFolder as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PhotoImportSource> as RtType>::Abi) -> HRESULT
}}
impl IPhotoImportSourceStatics {
    #[inline] pub fn from_id_async(&self, sourceId: &HStringArg) -> Result<foundation::IAsyncOperation<PhotoImportSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, sourceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn from_folder_async(&self, sourceRootFolder: &super::super::storage::IStorageFolder) -> Result<foundation::IAsyncOperation<PhotoImportSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromFolderAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(sourceRootFolder) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum PhotoImportSourceType: i32 {
    Generic = 0, Camera = 1, MediaPlayer = 2, Phone = 3, Video = 4, PersonalInfoManager = 5, AudioRecorder = 6,
}}
RT_ENUM! { enum PhotoImportStage: i32 {
    NotStarted = 0, FindingItems = 1, ImportingItems = 2, DeletingImportedItemsFromSource = 3,
}}
DEFINE_IID!(IID_IPhotoImportStorageMedium, 4072255635, 64645, 18559, 135, 194, 88, 214, 117, 208, 91, 7);
RT_INTERFACE!{interface IPhotoImportStorageMedium(IPhotoImportStorageMediumVtbl, IPhotoImportStorageMedium_Abi): IInspectable(IInspectableVtbl) [IID_IPhotoImportStorageMedium] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SerialNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn get_StorageMediumType(&self, out: *mut PhotoImportStorageMediumType) -> HRESULT,
    fn get_SupportedAccessMode(&self, out: *mut PhotoImportAccessMode) -> HRESULT,
    fn get_CapacityInBytes(&self, out: *mut u64) -> HRESULT,
    fn get_AvailableSpaceInBytes(&self, out: *mut u64) -> HRESULT,
    fn Refresh(&self) -> HRESULT
}}
impl IPhotoImportStorageMedium {
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Name)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Description)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_serial_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SerialNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_storage_medium_type(&self) -> Result<PhotoImportStorageMediumType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StorageMediumType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_access_mode(&self) -> Result<PhotoImportAccessMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedAccessMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_capacity_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CapacityInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_available_space_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AvailableSpaceInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn refresh(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Refresh)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PhotoImportStorageMedium: IPhotoImportStorageMedium}
RT_ENUM! { enum PhotoImportStorageMediumType: i32 {
    Undefined = 0, Fixed = 1, Removable = 2,
}}
RT_ENUM! { enum PhotoImportSubfolderCreationMode: i32 {
    DoNotCreateSubfolders = 0, CreateSubfoldersFromFileDate = 1, CreateSubfoldersFromExifDate = 2, KeepOriginalFolderStructure = 3,
}}
RT_ENUM! { enum PhotoImportSubfolderDateFormat: i32 {
    Year = 0, YearMonth = 1, YearMonthDay = 2,
}}
DEFINE_IID!(IID_IPhotoImportVideoSegment, 1648099977, 12826, 16856, 145, 102, 140, 98, 163, 51, 39, 108);
RT_INTERFACE!{interface IPhotoImportVideoSegment(IPhotoImportVideoSegmentVtbl, IPhotoImportVideoSegment_Abi): IInspectable(IInspectableVtbl) [IID_IPhotoImportVideoSegment] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn get_Date(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_Sibling(&self, out: *mut <PhotoImportSidecar as RtType>::Abi) -> HRESULT,
    fn get_Sidecars(&self, out: *mut <foundation::collections::IVectorView<PhotoImportSidecar> as RtType>::Abi) -> HRESULT
}}
impl IPhotoImportVideoSegment {
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Name)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_size_in_bytes(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SizeInBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_date(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Date)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sibling(&self) -> Result<Option<PhotoImportSidecar>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Sibling)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PhotoImportSidecar::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sidecars(&self) -> Result<Option<foundation::collections::IVectorView<PhotoImportSidecar>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Sidecars)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PhotoImportVideoSegment: IPhotoImportVideoSegment}
} // Windows.Media.Import
pub mod mediaproperties { // Windows.Media.MediaProperties
use crate::prelude::*;
DEFINE_IID!(IID_IAudioEncodingProperties, 1656519190, 92, 19259, 138, 11, 10, 9, 14, 150, 135, 243);
RT_INTERFACE!{interface IAudioEncodingProperties(IAudioEncodingPropertiesVtbl, IAudioEncodingProperties_Abi): IInspectable(IInspectableVtbl) [IID_IAudioEncodingProperties] {
    fn put_Bitrate(&self, value: u32) -> HRESULT,
    fn get_Bitrate(&self, out: *mut u32) -> HRESULT,
    fn put_ChannelCount(&self, value: u32) -> HRESULT,
    fn get_ChannelCount(&self, out: *mut u32) -> HRESULT,
    fn put_SampleRate(&self, value: u32) -> HRESULT,
    fn get_SampleRate(&self, out: *mut u32) -> HRESULT,
    fn put_BitsPerSample(&self, value: u32) -> HRESULT,
    fn get_BitsPerSample(&self, out: *mut u32) -> HRESULT
}}
impl IAudioEncodingProperties {
    #[inline] pub fn set_bitrate(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Bitrate)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_bitrate(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Bitrate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_channel_count(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ChannelCount)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_channel_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ChannelCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_sample_rate(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SampleRate)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sample_rate(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SampleRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_bits_per_sample(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BitsPerSample)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_bits_per_sample(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BitsPerSample)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AudioEncodingProperties: IAudioEncodingProperties}
impl RtActivatable<IAudioEncodingPropertiesStatics> for AudioEncodingProperties {}
impl RtActivatable<IAudioEncodingPropertiesStatics2> for AudioEncodingProperties {}
impl RtActivatable<IActivationFactory> for AudioEncodingProperties {}
impl AudioEncodingProperties {
    #[inline] pub fn create_aac(sampleRate: u32, channelCount: u32, bitrate: u32) -> Result<Option<AudioEncodingProperties>> {
        <Self as RtActivatable<IAudioEncodingPropertiesStatics>>::get_activation_factory().create_aac(sampleRate, channelCount, bitrate)
    }
    #[inline] pub fn create_aac_adts(sampleRate: u32, channelCount: u32, bitrate: u32) -> Result<Option<AudioEncodingProperties>> {
        <Self as RtActivatable<IAudioEncodingPropertiesStatics>>::get_activation_factory().create_aac_adts(sampleRate, channelCount, bitrate)
    }
    #[inline] pub fn create_mp3(sampleRate: u32, channelCount: u32, bitrate: u32) -> Result<Option<AudioEncodingProperties>> {
        <Self as RtActivatable<IAudioEncodingPropertiesStatics>>::get_activation_factory().create_mp3(sampleRate, channelCount, bitrate)
    }
    #[inline] pub fn create_pcm(sampleRate: u32, channelCount: u32, bitsPerSample: u32) -> Result<Option<AudioEncodingProperties>> {
        <Self as RtActivatable<IAudioEncodingPropertiesStatics>>::get_activation_factory().create_pcm(sampleRate, channelCount, bitsPerSample)
    }
    #[inline] pub fn create_wma(sampleRate: u32, channelCount: u32, bitrate: u32) -> Result<Option<AudioEncodingProperties>> {
        <Self as RtActivatable<IAudioEncodingPropertiesStatics>>::get_activation_factory().create_wma(sampleRate, channelCount, bitrate)
    }
    #[inline] pub fn create_alac(sampleRate: u32, channelCount: u32, bitsPerSample: u32) -> Result<Option<AudioEncodingProperties>> {
        <Self as RtActivatable<IAudioEncodingPropertiesStatics2>>::get_activation_factory().create_alac(sampleRate, channelCount, bitsPerSample)
    }
    #[inline] pub fn create_flac(sampleRate: u32, channelCount: u32, bitsPerSample: u32) -> Result<Option<AudioEncodingProperties>> {
        <Self as RtActivatable<IAudioEncodingPropertiesStatics2>>::get_activation_factory().create_flac(sampleRate, channelCount, bitsPerSample)
    }
}
DEFINE_CLSID!(AudioEncodingProperties(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,77,101,100,105,97,80,114,111,112,101,114,116,105,101,115,46,65,117,100,105,111,69,110,99,111,100,105,110,103,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_AudioEncodingProperties]);
DEFINE_IID!(IID_IAudioEncodingProperties2, 3294450906, 32957, 19491, 128, 213, 114, 212, 161, 129, 232, 148);
RT_INTERFACE!{interface IAudioEncodingProperties2(IAudioEncodingProperties2Vtbl, IAudioEncodingProperties2_Abi): IInspectable(IInspectableVtbl) [IID_IAudioEncodingProperties2] {
    fn get_IsSpatial(&self, out: *mut bool) -> HRESULT
}}
impl IAudioEncodingProperties2 {
    #[inline] pub fn get_is_spatial(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsSpatial)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAudioEncodingProperties3, 2271216449, 29836, 20365, 176, 253, 16, 202, 240, 143, 240, 135);
RT_INTERFACE!{interface IAudioEncodingProperties3(IAudioEncodingProperties3Vtbl, IAudioEncodingProperties3_Abi): IInspectable(IInspectableVtbl) [IID_IAudioEncodingProperties3] {
    fn Copy(&self, out: *mut <AudioEncodingProperties as RtType>::Abi) -> HRESULT
}}
impl IAudioEncodingProperties3 {
    #[inline] pub fn copy(&self) -> Result<Option<AudioEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Copy)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioEncodingProperties::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAudioEncodingPropertiesStatics, 212677420, 60393, 17703, 179, 109, 228, 42, 19, 207, 56, 219);
RT_INTERFACE!{static interface IAudioEncodingPropertiesStatics(IAudioEncodingPropertiesStaticsVtbl, IAudioEncodingPropertiesStatics_Abi): IInspectable(IInspectableVtbl) [IID_IAudioEncodingPropertiesStatics] {
    fn CreateAac(&self, sampleRate: u32, channelCount: u32, bitrate: u32, out: *mut <AudioEncodingProperties as RtType>::Abi) -> HRESULT,
    fn CreateAacAdts(&self, sampleRate: u32, channelCount: u32, bitrate: u32, out: *mut <AudioEncodingProperties as RtType>::Abi) -> HRESULT,
    fn CreateMp3(&self, sampleRate: u32, channelCount: u32, bitrate: u32, out: *mut <AudioEncodingProperties as RtType>::Abi) -> HRESULT,
    fn CreatePcm(&self, sampleRate: u32, channelCount: u32, bitsPerSample: u32, out: *mut <AudioEncodingProperties as RtType>::Abi) -> HRESULT,
    fn CreateWma(&self, sampleRate: u32, channelCount: u32, bitrate: u32, out: *mut <AudioEncodingProperties as RtType>::Abi) -> HRESULT
}}
impl IAudioEncodingPropertiesStatics {
    #[inline] pub fn create_aac(&self, sampleRate: u32, channelCount: u32, bitrate: u32) -> Result<Option<AudioEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateAac)(self.0.as_abi() as *const _ as *mut _, sampleRate, channelCount, bitrate, &mut out);
        if hr == S_OK { Ok(AudioEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_aac_adts(&self, sampleRate: u32, channelCount: u32, bitrate: u32) -> Result<Option<AudioEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateAacAdts)(self.0.as_abi() as *const _ as *mut _, sampleRate, channelCount, bitrate, &mut out);
        if hr == S_OK { Ok(AudioEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_mp3(&self, sampleRate: u32, channelCount: u32, bitrate: u32) -> Result<Option<AudioEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateMp3)(self.0.as_abi() as *const _ as *mut _, sampleRate, channelCount, bitrate, &mut out);
        if hr == S_OK { Ok(AudioEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_pcm(&self, sampleRate: u32, channelCount: u32, bitsPerSample: u32) -> Result<Option<AudioEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreatePcm)(self.0.as_abi() as *const _ as *mut _, sampleRate, channelCount, bitsPerSample, &mut out);
        if hr == S_OK { Ok(AudioEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_wma(&self, sampleRate: u32, channelCount: u32, bitrate: u32) -> Result<Option<AudioEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWma)(self.0.as_abi() as *const _ as *mut _, sampleRate, channelCount, bitrate, &mut out);
        if hr == S_OK { Ok(AudioEncodingProperties::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAudioEncodingPropertiesStatics2, 1955148143, 30624, 17213, 142, 213, 64, 64, 40, 14, 134, 101);
RT_INTERFACE!{static interface IAudioEncodingPropertiesStatics2(IAudioEncodingPropertiesStatics2Vtbl, IAudioEncodingPropertiesStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IAudioEncodingPropertiesStatics2] {
    fn CreateAlac(&self, sampleRate: u32, channelCount: u32, bitsPerSample: u32, out: *mut <AudioEncodingProperties as RtType>::Abi) -> HRESULT,
    fn CreateFlac(&self, sampleRate: u32, channelCount: u32, bitsPerSample: u32, out: *mut <AudioEncodingProperties as RtType>::Abi) -> HRESULT
}}
impl IAudioEncodingPropertiesStatics2 {
    #[inline] pub fn create_alac(&self, sampleRate: u32, channelCount: u32, bitsPerSample: u32) -> Result<Option<AudioEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateAlac)(self.0.as_abi() as *const _ as *mut _, sampleRate, channelCount, bitsPerSample, &mut out);
        if hr == S_OK { Ok(AudioEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_flac(&self, sampleRate: u32, channelCount: u32, bitsPerSample: u32) -> Result<Option<AudioEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFlac)(self.0.as_abi() as *const _ as *mut _, sampleRate, channelCount, bitsPerSample, &mut out);
        if hr == S_OK { Ok(AudioEncodingProperties::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAudioEncodingPropertiesWithFormatUserData, 2565934457, 5098, 18943, 190, 112, 38, 115, 219, 105, 112, 44);
RT_INTERFACE!{interface IAudioEncodingPropertiesWithFormatUserData(IAudioEncodingPropertiesWithFormatUserDataVtbl, IAudioEncodingPropertiesWithFormatUserData_Abi): IInspectable(IInspectableVtbl) [IID_IAudioEncodingPropertiesWithFormatUserData] {
    fn SetFormatUserData(&self, valueSize: u32, value: *mut u8) -> HRESULT,
    fn GetFormatUserData(&self, valueSize: *mut u32, value: *mut *mut u8) -> HRESULT
}}
impl IAudioEncodingPropertiesWithFormatUserData {
    #[inline] pub fn set_format_user_data(&self, value: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetFormatUserData)(self.0.as_abi() as *const _ as *mut _, value.len() as u32, value.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_format_user_data(&self) -> Result<ComArray<u8>> { unsafe { 
        let mut valueSize = 0; let mut value = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetFormatUserData)(self.0.as_abi() as *const _ as *mut _, &mut valueSize, &mut value);
        if hr == S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { err(hr) }
    }}
}
RT_ENUM! { enum AudioEncodingQuality: i32 {
    Auto = 0, High = 1, Medium = 2, Low = 3,
}}
DEFINE_IID!(IID_IContainerEncodingProperties, 1504455255, 45866, 18334, 138, 97, 75, 127, 46, 158, 126, 160);
RT_INTERFACE!{interface IContainerEncodingProperties(IContainerEncodingPropertiesVtbl, IContainerEncodingProperties_Abi): IInspectable(IInspectableVtbl) [IID_IContainerEncodingProperties] {
    
}}
RT_CLASS!{class ContainerEncodingProperties: IContainerEncodingProperties}
impl RtActivatable<IActivationFactory> for ContainerEncodingProperties {}
DEFINE_CLSID!(ContainerEncodingProperties(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,77,101,100,105,97,80,114,111,112,101,114,116,105,101,115,46,67,111,110,116,97,105,110,101,114,69,110,99,111,100,105,110,103,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_ContainerEncodingProperties]);
DEFINE_IID!(IID_IContainerEncodingProperties2, 2993864745, 44582, 18457, 186, 173, 173, 122, 73, 176, 168, 118);
RT_INTERFACE!{interface IContainerEncodingProperties2(IContainerEncodingProperties2Vtbl, IContainerEncodingProperties2_Abi): IInspectable(IInspectableVtbl) [IID_IContainerEncodingProperties2] {
    fn Copy(&self, out: *mut <ContainerEncodingProperties as RtType>::Abi) -> HRESULT
}}
impl IContainerEncodingProperties2 {
    #[inline] pub fn copy(&self) -> Result<Option<ContainerEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Copy)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContainerEncodingProperties::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class H264ProfileIds}
impl RtActivatable<IH264ProfileIdsStatics> for H264ProfileIds {}
impl H264ProfileIds {
    #[inline] pub fn get_constrained_baseline() -> Result<i32> {
        <Self as RtActivatable<IH264ProfileIdsStatics>>::get_activation_factory().get_constrained_baseline()
    }
    #[inline] pub fn get_baseline() -> Result<i32> {
        <Self as RtActivatable<IH264ProfileIdsStatics>>::get_activation_factory().get_baseline()
    }
    #[inline] pub fn get_extended() -> Result<i32> {
        <Self as RtActivatable<IH264ProfileIdsStatics>>::get_activation_factory().get_extended()
    }
    #[inline] pub fn get_main() -> Result<i32> {
        <Self as RtActivatable<IH264ProfileIdsStatics>>::get_activation_factory().get_main()
    }
    #[inline] pub fn get_high() -> Result<i32> {
        <Self as RtActivatable<IH264ProfileIdsStatics>>::get_activation_factory().get_high()
    }
    #[inline] pub fn get_high_10() -> Result<i32> {
        <Self as RtActivatable<IH264ProfileIdsStatics>>::get_activation_factory().get_high_10()
    }
    #[inline] pub fn get_high_422() -> Result<i32> {
        <Self as RtActivatable<IH264ProfileIdsStatics>>::get_activation_factory().get_high_422()
    }
    #[inline] pub fn get_high_444() -> Result<i32> {
        <Self as RtActivatable<IH264ProfileIdsStatics>>::get_activation_factory().get_high_444()
    }
    #[inline] pub fn get_stereo_high() -> Result<i32> {
        <Self as RtActivatable<IH264ProfileIdsStatics>>::get_activation_factory().get_stereo_high()
    }
    #[inline] pub fn get_multiview_high() -> Result<i32> {
        <Self as RtActivatable<IH264ProfileIdsStatics>>::get_activation_factory().get_multiview_high()
    }
}
DEFINE_CLSID!(H264ProfileIds(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,77,101,100,105,97,80,114,111,112,101,114,116,105,101,115,46,72,50,54,52,80,114,111,102,105,108,101,73,100,115,0]) [CLSID_H264ProfileIds]);
DEFINE_IID!(IID_IH264ProfileIdsStatics, 946162855, 33898, 20375, 162, 229, 195, 161, 91, 191, 112, 253);
RT_INTERFACE!{static interface IH264ProfileIdsStatics(IH264ProfileIdsStaticsVtbl, IH264ProfileIdsStatics_Abi): IInspectable(IInspectableVtbl) [IID_IH264ProfileIdsStatics] {
    fn get_ConstrainedBaseline(&self, out: *mut i32) -> HRESULT,
    fn get_Baseline(&self, out: *mut i32) -> HRESULT,
    fn get_Extended(&self, out: *mut i32) -> HRESULT,
    fn get_Main(&self, out: *mut i32) -> HRESULT,
    fn get_High(&self, out: *mut i32) -> HRESULT,
    fn get_High10(&self, out: *mut i32) -> HRESULT,
    fn get_High422(&self, out: *mut i32) -> HRESULT,
    fn get_High444(&self, out: *mut i32) -> HRESULT,
    fn get_StereoHigh(&self, out: *mut i32) -> HRESULT,
    fn get_MultiviewHigh(&self, out: *mut i32) -> HRESULT
}}
impl IH264ProfileIdsStatics {
    #[inline] pub fn get_constrained_baseline(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConstrainedBaseline)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_baseline(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Baseline)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Extended)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_main(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Main)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_high(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_High)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_high_10(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_High10)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_high_422(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_High422)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_high_444(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_High444)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_stereo_high(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StereoHigh)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_multiview_high(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MultiviewHigh)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IImageEncodingProperties, 2019710517, 62257, 16777, 177, 195, 180, 141, 90, 224, 52, 241);
RT_INTERFACE!{interface IImageEncodingProperties(IImageEncodingPropertiesVtbl, IImageEncodingProperties_Abi): IInspectable(IInspectableVtbl) [IID_IImageEncodingProperties] {
    fn put_Width(&self, value: u32) -> HRESULT,
    fn get_Width(&self, out: *mut u32) -> HRESULT,
    fn put_Height(&self, value: u32) -> HRESULT,
    fn get_Height(&self, out: *mut u32) -> HRESULT
}}
impl IImageEncodingProperties {
    #[inline] pub fn set_width(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Width)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_width(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Width)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_height(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Height)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_height(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Height)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ImageEncodingProperties: IImageEncodingProperties}
impl RtActivatable<IImageEncodingPropertiesStatics> for ImageEncodingProperties {}
impl RtActivatable<IImageEncodingPropertiesStatics2> for ImageEncodingProperties {}
impl RtActivatable<IImageEncodingPropertiesStatics3> for ImageEncodingProperties {}
impl RtActivatable<IActivationFactory> for ImageEncodingProperties {}
impl ImageEncodingProperties {
    #[inline] pub fn create_jpeg() -> Result<Option<ImageEncodingProperties>> {
        <Self as RtActivatable<IImageEncodingPropertiesStatics>>::get_activation_factory().create_jpeg()
    }
    #[inline] pub fn create_png() -> Result<Option<ImageEncodingProperties>> {
        <Self as RtActivatable<IImageEncodingPropertiesStatics>>::get_activation_factory().create_png()
    }
    #[inline] pub fn create_jpeg_xr() -> Result<Option<ImageEncodingProperties>> {
        <Self as RtActivatable<IImageEncodingPropertiesStatics>>::get_activation_factory().create_jpeg_xr()
    }
    #[inline] pub fn create_uncompressed(format: MediaPixelFormat) -> Result<Option<ImageEncodingProperties>> {
        <Self as RtActivatable<IImageEncodingPropertiesStatics2>>::get_activation_factory().create_uncompressed(format)
    }
    #[inline] pub fn create_bmp() -> Result<Option<ImageEncodingProperties>> {
        <Self as RtActivatable<IImageEncodingPropertiesStatics2>>::get_activation_factory().create_bmp()
    }
    #[inline] pub fn create_heif() -> Result<Option<ImageEncodingProperties>> {
        <Self as RtActivatable<IImageEncodingPropertiesStatics3>>::get_activation_factory().create_heif()
    }
}
DEFINE_CLSID!(ImageEncodingProperties(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,77,101,100,105,97,80,114,111,112,101,114,116,105,101,115,46,73,109,97,103,101,69,110,99,111,100,105,110,103,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_ImageEncodingProperties]);
DEFINE_IID!(IID_IImageEncodingProperties2, 3360989919, 51491, 18075, 172, 142, 106, 159, 60, 28, 217, 227);
RT_INTERFACE!{interface IImageEncodingProperties2(IImageEncodingProperties2Vtbl, IImageEncodingProperties2_Abi): IInspectable(IInspectableVtbl) [IID_IImageEncodingProperties2] {
    fn Copy(&self, out: *mut <ImageEncodingProperties as RtType>::Abi) -> HRESULT
}}
impl IImageEncodingProperties2 {
    #[inline] pub fn copy(&self) -> Result<Option<ImageEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Copy)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ImageEncodingProperties::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IImageEncodingPropertiesStatics, 628910300, 35737, 17310, 170, 89, 145, 58, 54, 22, 18, 151);
RT_INTERFACE!{static interface IImageEncodingPropertiesStatics(IImageEncodingPropertiesStaticsVtbl, IImageEncodingPropertiesStatics_Abi): IInspectable(IInspectableVtbl) [IID_IImageEncodingPropertiesStatics] {
    fn CreateJpeg(&self, out: *mut <ImageEncodingProperties as RtType>::Abi) -> HRESULT,
    fn CreatePng(&self, out: *mut <ImageEncodingProperties as RtType>::Abi) -> HRESULT,
    fn CreateJpegXR(&self, out: *mut <ImageEncodingProperties as RtType>::Abi) -> HRESULT
}}
impl IImageEncodingPropertiesStatics {
    #[inline] pub fn create_jpeg(&self) -> Result<Option<ImageEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateJpeg)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ImageEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_png(&self) -> Result<Option<ImageEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreatePng)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ImageEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_jpeg_xr(&self) -> Result<Option<ImageEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateJpegXR)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ImageEncodingProperties::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IImageEncodingPropertiesStatics2, 4139932457, 14372, 18096, 149, 110, 80, 19, 41, 225, 190, 60);
RT_INTERFACE!{static interface IImageEncodingPropertiesStatics2(IImageEncodingPropertiesStatics2Vtbl, IImageEncodingPropertiesStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IImageEncodingPropertiesStatics2] {
    fn CreateUncompressed(&self, format: MediaPixelFormat, out: *mut <ImageEncodingProperties as RtType>::Abi) -> HRESULT,
    fn CreateBmp(&self, out: *mut <ImageEncodingProperties as RtType>::Abi) -> HRESULT
}}
impl IImageEncodingPropertiesStatics2 {
    #[inline] pub fn create_uncompressed(&self, format: MediaPixelFormat) -> Result<Option<ImageEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateUncompressed)(self.0.as_abi() as *const _ as *mut _, format, &mut out);
        if hr == S_OK { Ok(ImageEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_bmp(&self) -> Result<Option<ImageEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateBmp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ImageEncodingProperties::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IImageEncodingPropertiesStatics3, 1223983437, 41727, 18652, 142, 160, 233, 6, 128, 102, 54, 86);
RT_INTERFACE!{static interface IImageEncodingPropertiesStatics3(IImageEncodingPropertiesStatics3Vtbl, IImageEncodingPropertiesStatics3_Abi): IInspectable(IInspectableVtbl) [IID_IImageEncodingPropertiesStatics3] {
    fn CreateHeif(&self, out: *mut <ImageEncodingProperties as RtType>::Abi) -> HRESULT
}}
impl IImageEncodingPropertiesStatics3 {
    #[inline] pub fn create_heif(&self) -> Result<Option<ImageEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateHeif)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ImageEncodingProperties::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaEncodingProfile, 3889952168, 7609, 18307, 135, 107, 61, 254, 18, 172, 253, 179);
RT_INTERFACE!{interface IMediaEncodingProfile(IMediaEncodingProfileVtbl, IMediaEncodingProfile_Abi): IInspectable(IInspectableVtbl) [IID_IMediaEncodingProfile] {
    fn put_Audio(&self, value: <AudioEncodingProperties as RtType>::Abi) -> HRESULT,
    fn get_Audio(&self, out: *mut <AudioEncodingProperties as RtType>::Abi) -> HRESULT,
    fn put_Video(&self, value: <VideoEncodingProperties as RtType>::Abi) -> HRESULT,
    fn get_Video(&self, out: *mut <VideoEncodingProperties as RtType>::Abi) -> HRESULT,
    fn put_Container(&self, value: <ContainerEncodingProperties as RtType>::Abi) -> HRESULT,
    fn get_Container(&self, out: *mut <ContainerEncodingProperties as RtType>::Abi) -> HRESULT
}}
impl IMediaEncodingProfile {
    #[inline] pub fn set_audio(&self, value: &AudioEncodingProperties) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Audio)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_audio(&self) -> Result<Option<AudioEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Audio)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AudioEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_video(&self, value: &VideoEncodingProperties) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Video)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_video(&self) -> Result<Option<VideoEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Video)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_container(&self, value: &ContainerEncodingProperties) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Container)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_container(&self) -> Result<Option<ContainerEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Container)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ContainerEncodingProperties::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaEncodingProfile: IMediaEncodingProfile}
impl RtActivatable<IMediaEncodingProfileStatics> for MediaEncodingProfile {}
impl RtActivatable<IMediaEncodingProfileStatics2> for MediaEncodingProfile {}
impl RtActivatable<IMediaEncodingProfileStatics3> for MediaEncodingProfile {}
impl RtActivatable<IActivationFactory> for MediaEncodingProfile {}
impl MediaEncodingProfile {
    #[inline] pub fn create_m4a(quality: AudioEncodingQuality) -> Result<Option<MediaEncodingProfile>> {
        <Self as RtActivatable<IMediaEncodingProfileStatics>>::get_activation_factory().create_m4a(quality)
    }
    #[inline] pub fn create_mp3(quality: AudioEncodingQuality) -> Result<Option<MediaEncodingProfile>> {
        <Self as RtActivatable<IMediaEncodingProfileStatics>>::get_activation_factory().create_mp3(quality)
    }
    #[inline] pub fn create_wma(quality: AudioEncodingQuality) -> Result<Option<MediaEncodingProfile>> {
        <Self as RtActivatable<IMediaEncodingProfileStatics>>::get_activation_factory().create_wma(quality)
    }
    #[inline] pub fn create_mp4(quality: VideoEncodingQuality) -> Result<Option<MediaEncodingProfile>> {
        <Self as RtActivatable<IMediaEncodingProfileStatics>>::get_activation_factory().create_mp4(quality)
    }
    #[inline] pub fn create_wmv(quality: VideoEncodingQuality) -> Result<Option<MediaEncodingProfile>> {
        <Self as RtActivatable<IMediaEncodingProfileStatics>>::get_activation_factory().create_wmv(quality)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_file_async(file: &super::super::storage::IStorageFile) -> Result<foundation::IAsyncOperation<MediaEncodingProfile>> {
        <Self as RtActivatable<IMediaEncodingProfileStatics>>::get_activation_factory().create_from_file_async(file)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_stream_async(stream: &super::super::storage::streams::IRandomAccessStream) -> Result<foundation::IAsyncOperation<MediaEncodingProfile>> {
        <Self as RtActivatable<IMediaEncodingProfileStatics>>::get_activation_factory().create_from_stream_async(stream)
    }
    #[inline] pub fn create_wav(quality: AudioEncodingQuality) -> Result<Option<MediaEncodingProfile>> {
        <Self as RtActivatable<IMediaEncodingProfileStatics2>>::get_activation_factory().create_wav(quality)
    }
    #[inline] pub fn create_avi(quality: VideoEncodingQuality) -> Result<Option<MediaEncodingProfile>> {
        <Self as RtActivatable<IMediaEncodingProfileStatics2>>::get_activation_factory().create_avi(quality)
    }
    #[inline] pub fn create_alac(quality: AudioEncodingQuality) -> Result<Option<MediaEncodingProfile>> {
        <Self as RtActivatable<IMediaEncodingProfileStatics3>>::get_activation_factory().create_alac(quality)
    }
    #[inline] pub fn create_flac(quality: AudioEncodingQuality) -> Result<Option<MediaEncodingProfile>> {
        <Self as RtActivatable<IMediaEncodingProfileStatics3>>::get_activation_factory().create_flac(quality)
    }
    #[inline] pub fn create_hevc(quality: VideoEncodingQuality) -> Result<Option<MediaEncodingProfile>> {
        <Self as RtActivatable<IMediaEncodingProfileStatics3>>::get_activation_factory().create_hevc(quality)
    }
}
DEFINE_CLSID!(MediaEncodingProfile(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,77,101,100,105,97,80,114,111,112,101,114,116,105,101,115,46,77,101,100,105,97,69,110,99,111,100,105,110,103,80,114,111,102,105,108,101,0]) [CLSID_MediaEncodingProfile]);
DEFINE_IID!(IID_IMediaEncodingProfile2, 882589194, 16437, 18574, 152, 119, 133, 99, 40, 101, 237, 16);
RT_INTERFACE!{interface IMediaEncodingProfile2(IMediaEncodingProfile2Vtbl, IMediaEncodingProfile2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaEncodingProfile2] {
    fn SetAudioTracks(&self, value: <foundation::collections::IIterable<super::core::AudioStreamDescriptor> as RtType>::Abi) -> HRESULT,
    fn GetAudioTracks(&self, out: *mut <foundation::collections::IVector<super::core::AudioStreamDescriptor> as RtType>::Abi) -> HRESULT,
    fn SetVideoTracks(&self, value: <foundation::collections::IIterable<super::core::VideoStreamDescriptor> as RtType>::Abi) -> HRESULT,
    fn GetVideoTracks(&self, out: *mut <foundation::collections::IVector<super::core::VideoStreamDescriptor> as RtType>::Abi) -> HRESULT
}}
impl IMediaEncodingProfile2 {
    #[inline] pub fn set_audio_tracks(&self, value: &foundation::collections::IIterable<super::core::AudioStreamDescriptor>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetAudioTracks)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_tracks(&self) -> Result<Option<foundation::collections::IVector<super::core::AudioStreamDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAudioTracks)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_video_tracks(&self, value: &foundation::collections::IIterable<super::core::VideoStreamDescriptor>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetVideoTracks)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_video_tracks(&self) -> Result<Option<foundation::collections::IVector<super::core::VideoStreamDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetVideoTracks)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaEncodingProfile3, 3127819912, 30064, 20073, 172, 207, 86, 17, 173, 1, 95, 136);
RT_INTERFACE!{interface IMediaEncodingProfile3(IMediaEncodingProfile3Vtbl, IMediaEncodingProfile3_Abi): IInspectable(IInspectableVtbl) [IID_IMediaEncodingProfile3] {
    fn SetTimedMetadataTracks(&self, value: <foundation::collections::IIterable<super::core::TimedMetadataStreamDescriptor> as RtType>::Abi) -> HRESULT,
    fn GetTimedMetadataTracks(&self, out: *mut <foundation::collections::IVector<super::core::TimedMetadataStreamDescriptor> as RtType>::Abi) -> HRESULT
}}
impl IMediaEncodingProfile3 {
    #[inline] pub fn set_timed_metadata_tracks(&self, value: &foundation::collections::IIterable<super::core::TimedMetadataStreamDescriptor>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetTimedMetadataTracks)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_timed_metadata_tracks(&self) -> Result<Option<foundation::collections::IVector<super::core::TimedMetadataStreamDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetTimedMetadataTracks)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaEncodingProfileStatics, 427767084, 11998, 19013, 168, 150, 129, 122, 72, 84, 248, 254);
RT_INTERFACE!{static interface IMediaEncodingProfileStatics(IMediaEncodingProfileStaticsVtbl, IMediaEncodingProfileStatics_Abi): IInspectable(IInspectableVtbl) [IID_IMediaEncodingProfileStatics] {
    fn CreateM4a(&self, quality: AudioEncodingQuality, out: *mut <MediaEncodingProfile as RtType>::Abi) -> HRESULT,
    fn CreateMp3(&self, quality: AudioEncodingQuality, out: *mut <MediaEncodingProfile as RtType>::Abi) -> HRESULT,
    fn CreateWma(&self, quality: AudioEncodingQuality, out: *mut <MediaEncodingProfile as RtType>::Abi) -> HRESULT,
    fn CreateMp4(&self, quality: VideoEncodingQuality, out: *mut <MediaEncodingProfile as RtType>::Abi) -> HRESULT,
    fn CreateWmv(&self, quality: VideoEncodingQuality, out: *mut <MediaEncodingProfile as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn CreateFromFileAsync(&self, file: <super::super::storage::IStorageFile as RtType>::Abi, out: *mut <foundation::IAsyncOperation<MediaEncodingProfile> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn CreateFromStreamAsync(&self, stream: <super::super::storage::streams::IRandomAccessStream as RtType>::Abi, out: *mut <foundation::IAsyncOperation<MediaEncodingProfile> as RtType>::Abi) -> HRESULT
}}
impl IMediaEncodingProfileStatics {
    #[inline] pub fn create_m4a(&self, quality: AudioEncodingQuality) -> Result<Option<MediaEncodingProfile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateM4a)(self.0.as_abi() as *const _ as *mut _, quality, &mut out);
        if hr == S_OK { Ok(MediaEncodingProfile::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_mp3(&self, quality: AudioEncodingQuality) -> Result<Option<MediaEncodingProfile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateMp3)(self.0.as_abi() as *const _ as *mut _, quality, &mut out);
        if hr == S_OK { Ok(MediaEncodingProfile::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_wma(&self, quality: AudioEncodingQuality) -> Result<Option<MediaEncodingProfile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWma)(self.0.as_abi() as *const _ as *mut _, quality, &mut out);
        if hr == S_OK { Ok(MediaEncodingProfile::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_mp4(&self, quality: VideoEncodingQuality) -> Result<Option<MediaEncodingProfile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateMp4)(self.0.as_abi() as *const _ as *mut _, quality, &mut out);
        if hr == S_OK { Ok(MediaEncodingProfile::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_wmv(&self, quality: VideoEncodingQuality) -> Result<Option<MediaEncodingProfile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWmv)(self.0.as_abi() as *const _ as *mut _, quality, &mut out);
        if hr == S_OK { Ok(MediaEncodingProfile::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_file_async(&self, file: &super::super::storage::IStorageFile) -> Result<foundation::IAsyncOperation<MediaEncodingProfile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromFileAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(file) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_stream_async(&self, stream: &super::super::storage::streams::IRandomAccessStream) -> Result<foundation::IAsyncOperation<MediaEncodingProfile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromStreamAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(stream) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaEncodingProfileStatics2, 3465406287, 27380, 17032, 143, 226, 121, 173, 241, 247, 154, 67);
RT_INTERFACE!{static interface IMediaEncodingProfileStatics2(IMediaEncodingProfileStatics2Vtbl, IMediaEncodingProfileStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaEncodingProfileStatics2] {
    fn CreateWav(&self, quality: AudioEncodingQuality, out: *mut <MediaEncodingProfile as RtType>::Abi) -> HRESULT,
    fn CreateAvi(&self, quality: VideoEncodingQuality, out: *mut <MediaEncodingProfile as RtType>::Abi) -> HRESULT
}}
impl IMediaEncodingProfileStatics2 {
    #[inline] pub fn create_wav(&self, quality: AudioEncodingQuality) -> Result<Option<MediaEncodingProfile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWav)(self.0.as_abi() as *const _ as *mut _, quality, &mut out);
        if hr == S_OK { Ok(MediaEncodingProfile::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_avi(&self, quality: VideoEncodingQuality) -> Result<Option<MediaEncodingProfile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateAvi)(self.0.as_abi() as *const _ as *mut _, quality, &mut out);
        if hr == S_OK { Ok(MediaEncodingProfile::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaEncodingProfileStatics3, 2430256554, 53110, 17044, 169, 237, 26, 20, 32, 245, 31, 107);
RT_INTERFACE!{static interface IMediaEncodingProfileStatics3(IMediaEncodingProfileStatics3Vtbl, IMediaEncodingProfileStatics3_Abi): IInspectable(IInspectableVtbl) [IID_IMediaEncodingProfileStatics3] {
    fn CreateAlac(&self, quality: AudioEncodingQuality, out: *mut <MediaEncodingProfile as RtType>::Abi) -> HRESULT,
    fn CreateFlac(&self, quality: AudioEncodingQuality, out: *mut <MediaEncodingProfile as RtType>::Abi) -> HRESULT,
    fn CreateHevc(&self, quality: VideoEncodingQuality, out: *mut <MediaEncodingProfile as RtType>::Abi) -> HRESULT
}}
impl IMediaEncodingProfileStatics3 {
    #[inline] pub fn create_alac(&self, quality: AudioEncodingQuality) -> Result<Option<MediaEncodingProfile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateAlac)(self.0.as_abi() as *const _ as *mut _, quality, &mut out);
        if hr == S_OK { Ok(MediaEncodingProfile::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_flac(&self, quality: AudioEncodingQuality) -> Result<Option<MediaEncodingProfile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFlac)(self.0.as_abi() as *const _ as *mut _, quality, &mut out);
        if hr == S_OK { Ok(MediaEncodingProfile::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_hevc(&self, quality: VideoEncodingQuality) -> Result<Option<MediaEncodingProfile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateHevc)(self.0.as_abi() as *const _ as *mut _, quality, &mut out);
        if hr == S_OK { Ok(MediaEncodingProfile::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaEncodingProperties, 3019909878, 44244, 20058, 162, 75, 93, 116, 152, 168, 184, 196);
RT_INTERFACE!{interface IMediaEncodingProperties(IMediaEncodingPropertiesVtbl, IMediaEncodingProperties_Abi): IInspectable(IInspectableVtbl) [IID_IMediaEncodingProperties] {
    fn get_Properties(&self, out: *mut <MediaPropertySet as RtType>::Abi) -> HRESULT,
    fn get_Type(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Subtype(&self, value: HSTRING) -> HRESULT,
    fn get_Subtype(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMediaEncodingProperties {
    #[inline] pub fn get_properties(&self) -> Result<Option<MediaPropertySet>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPropertySet::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_type(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Type)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_subtype(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Subtype)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_subtype(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Subtype)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class MediaEncodingSubtypes}
impl RtActivatable<IMediaEncodingSubtypesStatics> for MediaEncodingSubtypes {}
impl RtActivatable<IMediaEncodingSubtypesStatics2> for MediaEncodingSubtypes {}
impl RtActivatable<IMediaEncodingSubtypesStatics3> for MediaEncodingSubtypes {}
impl RtActivatable<IMediaEncodingSubtypesStatics4> for MediaEncodingSubtypes {}
impl RtActivatable<IMediaEncodingSubtypesStatics5> for MediaEncodingSubtypes {}
impl MediaEncodingSubtypes {
    #[inline] pub fn get_aac() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_aac()
    }
    #[inline] pub fn get_aac_adts() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_aac_adts()
    }
    #[inline] pub fn get_ac3() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_ac3()
    }
    #[inline] pub fn get_amr_nb() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_amr_nb()
    }
    #[inline] pub fn get_amr_wb() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_amr_wb()
    }
    #[inline] pub fn get_argb32() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_argb32()
    }
    #[inline] pub fn get_asf() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_asf()
    }
    #[inline] pub fn get_avi() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_avi()
    }
    #[inline] pub fn get_bgra8() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_bgra8()
    }
    #[inline] pub fn get_bmp() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_bmp()
    }
    #[inline] pub fn get_eac3() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_eac3()
    }
    #[inline] pub fn get_float() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_float()
    }
    #[inline] pub fn get_gif() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_gif()
    }
    #[inline] pub fn get_h263() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_h263()
    }
    #[inline] pub fn get_h264() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_h264()
    }
    #[inline] pub fn get_h264_es() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_h264_es()
    }
    #[inline] pub fn get_hevc() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_hevc()
    }
    #[inline] pub fn get_hevc_es() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_hevc_es()
    }
    #[inline] pub fn get_iyuv() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_iyuv()
    }
    #[inline] pub fn get_jpeg() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_jpeg()
    }
    #[inline] pub fn get_jpeg_xr() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_jpeg_xr()
    }
    #[inline] pub fn get_mjpg() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_mjpg()
    }
    #[inline] pub fn get_mpeg() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_mpeg()
    }
    #[inline] pub fn get_mpeg1() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_mpeg1()
    }
    #[inline] pub fn get_mpeg2() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_mpeg2()
    }
    #[inline] pub fn get_mp3() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_mp3()
    }
    #[inline] pub fn get_mpeg4() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_mpeg4()
    }
    #[inline] pub fn get_nv12() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_nv12()
    }
    #[inline] pub fn get_pcm() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_pcm()
    }
    #[inline] pub fn get_png() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_png()
    }
    #[inline] pub fn get_rgb24() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_rgb24()
    }
    #[inline] pub fn get_rgb32() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_rgb32()
    }
    #[inline] pub fn get_tiff() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_tiff()
    }
    #[inline] pub fn get_wave() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_wave()
    }
    #[inline] pub fn get_wma8() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_wma8()
    }
    #[inline] pub fn get_wma9() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_wma9()
    }
    #[inline] pub fn get_wmv3() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_wmv3()
    }
    #[inline] pub fn get_wvc1() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_wvc1()
    }
    #[inline] pub fn get_yuy2() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_yuy2()
    }
    #[inline] pub fn get_yv12() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics>>::get_activation_factory().get_yv12()
    }
    #[inline] pub fn get_vp9() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics2>>::get_activation_factory().get_vp9()
    }
    #[inline] pub fn get_l8() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics2>>::get_activation_factory().get_l8()
    }
    #[inline] pub fn get_l16() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics2>>::get_activation_factory().get_l16()
    }
    #[inline] pub fn get_d16() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics2>>::get_activation_factory().get_d16()
    }
    #[inline] pub fn get_alac() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics3>>::get_activation_factory().get_alac()
    }
    #[inline] pub fn get_flac() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics3>>::get_activation_factory().get_flac()
    }
    #[inline] pub fn get_p010() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics4>>::get_activation_factory().get_p010()
    }
    #[inline] pub fn get_heif() -> Result<HString> {
        <Self as RtActivatable<IMediaEncodingSubtypesStatics5>>::get_activation_factory().get_heif()
    }
}
DEFINE_CLSID!(MediaEncodingSubtypes(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,77,101,100,105,97,80,114,111,112,101,114,116,105,101,115,46,77,101,100,105,97,69,110,99,111,100,105,110,103,83,117,98,116,121,112,101,115,0]) [CLSID_MediaEncodingSubtypes]);
DEFINE_IID!(IID_IMediaEncodingSubtypesStatics, 934696974, 41329, 17508, 186, 90, 83, 24, 158, 72, 193, 200);
RT_INTERFACE!{static interface IMediaEncodingSubtypesStatics(IMediaEncodingSubtypesStaticsVtbl, IMediaEncodingSubtypesStatics_Abi): IInspectable(IInspectableVtbl) [IID_IMediaEncodingSubtypesStatics] {
    fn get_Aac(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AacAdts(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Ac3(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AmrNb(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AmrWb(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Argb32(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Asf(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Avi(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Bgra8(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Bmp(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Eac3(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Float(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Gif(&self, out: *mut HSTRING) -> HRESULT,
    fn get_H263(&self, out: *mut HSTRING) -> HRESULT,
    fn get_H264(&self, out: *mut HSTRING) -> HRESULT,
    fn get_H264Es(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Hevc(&self, out: *mut HSTRING) -> HRESULT,
    fn get_HevcEs(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Iyuv(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Jpeg(&self, out: *mut HSTRING) -> HRESULT,
    fn get_JpegXr(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Mjpg(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Mpeg(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Mpeg1(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Mpeg2(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Mp3(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Mpeg4(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Nv12(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Pcm(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Png(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Rgb24(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Rgb32(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Tiff(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Wave(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Wma8(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Wma9(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Wmv3(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Wvc1(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Yuy2(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Yv12(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMediaEncodingSubtypesStatics {
    #[inline] pub fn get_aac(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Aac)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_aac_adts(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AacAdts)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_ac3(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Ac3)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_amr_nb(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AmrNb)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_amr_wb(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AmrWb)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_argb32(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Argb32)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_asf(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Asf)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_avi(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Avi)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_bgra8(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Bgra8)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_bmp(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Bmp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_eac3(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Eac3)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_float(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Float)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_gif(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Gif)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_h263(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_H263)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_h264(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_H264)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_h264_es(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_H264Es)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_hevc(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Hevc)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_hevc_es(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_HevcEs)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_iyuv(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Iyuv)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_jpeg(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Jpeg)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_jpeg_xr(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_JpegXr)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_mjpg(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mjpg)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_mpeg(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mpeg)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_mpeg1(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mpeg1)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_mpeg2(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mpeg2)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_mp3(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mp3)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_mpeg4(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mpeg4)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_nv12(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Nv12)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_pcm(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Pcm)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_png(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Png)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_rgb24(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Rgb24)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_rgb32(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Rgb32)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_tiff(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Tiff)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_wave(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Wave)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_wma8(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Wma8)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_wma9(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Wma9)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_wmv3(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Wmv3)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_wvc1(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Wvc1)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_yuy2(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Yuy2)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_yv12(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Yv12)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaEncodingSubtypesStatics2, 1266471485, 17151, 19763, 133, 49, 6, 38, 190, 228, 181, 45);
RT_INTERFACE!{static interface IMediaEncodingSubtypesStatics2(IMediaEncodingSubtypesStatics2Vtbl, IMediaEncodingSubtypesStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaEncodingSubtypesStatics2] {
    fn get_Vp9(&self, out: *mut HSTRING) -> HRESULT,
    fn get_L8(&self, out: *mut HSTRING) -> HRESULT,
    fn get_L16(&self, out: *mut HSTRING) -> HRESULT,
    fn get_D16(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMediaEncodingSubtypesStatics2 {
    #[inline] pub fn get_vp9(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Vp9)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_l8(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_L8)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_l16(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_L16)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_d16(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_D16)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaEncodingSubtypesStatics3, 3122926820, 34877, 17998, 164, 79, 9, 125, 160, 142, 247, 255);
RT_INTERFACE!{static interface IMediaEncodingSubtypesStatics3(IMediaEncodingSubtypesStatics3Vtbl, IMediaEncodingSubtypesStatics3_Abi): IInspectable(IInspectableVtbl) [IID_IMediaEncodingSubtypesStatics3] {
    fn get_Alac(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Flac(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMediaEncodingSubtypesStatics3 {
    #[inline] pub fn get_alac(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Alac)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_flac(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Flac)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaEncodingSubtypesStatics4, 3723289994, 14665, 17988, 138, 44, 89, 239, 2, 198, 66, 250);
RT_INTERFACE!{static interface IMediaEncodingSubtypesStatics4(IMediaEncodingSubtypesStatics4Vtbl, IMediaEncodingSubtypesStatics4_Abi): IInspectable(IInspectableVtbl) [IID_IMediaEncodingSubtypesStatics4] {
    fn get_P010(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMediaEncodingSubtypesStatics4 {
    #[inline] pub fn get_p010(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_P010)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaEncodingSubtypesStatics5, 1523884039, 65486, 18272, 152, 40, 93, 12, 153, 99, 126, 106);
RT_INTERFACE!{static interface IMediaEncodingSubtypesStatics5(IMediaEncodingSubtypesStatics5Vtbl, IMediaEncodingSubtypesStatics5_Abi): IInspectable(IInspectableVtbl) [IID_IMediaEncodingSubtypesStatics5] {
    fn get_Heif(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMediaEncodingSubtypesStatics5 {
    #[inline] pub fn get_heif(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Heif)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum MediaMirroringOptions: u32 {
    None = 0, Horizontal = 1, Vertical = 2,
}}
RT_ENUM! { enum MediaPixelFormat: i32 {
    Nv12 = 0, Bgra8 = 1, P010 = 2,
}}
RT_CLASS!{class MediaPropertySet: foundation::collections::IMap<Guid, IInspectable>}
impl RtActivatable<IActivationFactory> for MediaPropertySet {}
DEFINE_CLSID!(MediaPropertySet(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,77,101,100,105,97,80,114,111,112,101,114,116,105,101,115,46,77,101,100,105,97,80,114,111,112,101,114,116,121,83,101,116,0]) [CLSID_MediaPropertySet]);
DEFINE_IID!(IID_IMediaRatio, 3536912101, 35113, 16413, 172, 120, 125, 53, 126, 55, 129, 99);
RT_INTERFACE!{interface IMediaRatio(IMediaRatioVtbl, IMediaRatio_Abi): IInspectable(IInspectableVtbl) [IID_IMediaRatio] {
    fn put_Numerator(&self, value: u32) -> HRESULT,
    fn get_Numerator(&self, out: *mut u32) -> HRESULT,
    fn put_Denominator(&self, value: u32) -> HRESULT,
    fn get_Denominator(&self, out: *mut u32) -> HRESULT
}}
impl IMediaRatio {
    #[inline] pub fn set_numerator(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Numerator)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_numerator(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Numerator)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_denominator(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Denominator)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_denominator(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Denominator)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaRatio: IMediaRatio}
RT_ENUM! { enum MediaRotation: i32 {
    None = 0, Clockwise90Degrees = 1, Clockwise180Degrees = 2, Clockwise270Degrees = 3,
}}
RT_ENUM! { enum MediaThumbnailFormat: i32 {
    Bmp = 0, Bgra8 = 1,
}}
RT_CLASS!{static class Mpeg2ProfileIds}
impl RtActivatable<IMpeg2ProfileIdsStatics> for Mpeg2ProfileIds {}
impl Mpeg2ProfileIds {
    #[inline] pub fn get_simple() -> Result<i32> {
        <Self as RtActivatable<IMpeg2ProfileIdsStatics>>::get_activation_factory().get_simple()
    }
    #[inline] pub fn get_main() -> Result<i32> {
        <Self as RtActivatable<IMpeg2ProfileIdsStatics>>::get_activation_factory().get_main()
    }
    #[inline] pub fn get_signal_noise_ratio_scalable() -> Result<i32> {
        <Self as RtActivatable<IMpeg2ProfileIdsStatics>>::get_activation_factory().get_signal_noise_ratio_scalable()
    }
    #[inline] pub fn get_spatially_scalable() -> Result<i32> {
        <Self as RtActivatable<IMpeg2ProfileIdsStatics>>::get_activation_factory().get_spatially_scalable()
    }
    #[inline] pub fn get_high() -> Result<i32> {
        <Self as RtActivatable<IMpeg2ProfileIdsStatics>>::get_activation_factory().get_high()
    }
}
DEFINE_CLSID!(Mpeg2ProfileIds(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,77,101,100,105,97,80,114,111,112,101,114,116,105,101,115,46,77,112,101,103,50,80,114,111,102,105,108,101,73,100,115,0]) [CLSID_Mpeg2ProfileIds]);
DEFINE_IID!(IID_IMpeg2ProfileIdsStatics, 2757885829, 58746, 16680, 155, 33, 213, 51, 27, 4, 35, 92);
RT_INTERFACE!{static interface IMpeg2ProfileIdsStatics(IMpeg2ProfileIdsStaticsVtbl, IMpeg2ProfileIdsStatics_Abi): IInspectable(IInspectableVtbl) [IID_IMpeg2ProfileIdsStatics] {
    fn get_Simple(&self, out: *mut i32) -> HRESULT,
    fn get_Main(&self, out: *mut i32) -> HRESULT,
    fn get_SignalNoiseRatioScalable(&self, out: *mut i32) -> HRESULT,
    fn get_SpatiallyScalable(&self, out: *mut i32) -> HRESULT,
    fn get_High(&self, out: *mut i32) -> HRESULT
}}
impl IMpeg2ProfileIdsStatics {
    #[inline] pub fn get_simple(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Simple)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_main(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Main)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_signal_noise_ratio_scalable(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SignalNoiseRatioScalable)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_spatially_scalable(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SpatiallyScalable)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_high(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_High)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum SphericalVideoFrameFormat: i32 {
    None = 0, Unsupported = 1, Equirectangular = 2,
}}
RT_ENUM! { enum StereoscopicVideoPackingMode: i32 {
    None = 0, SideBySide = 1, TopBottom = 2,
}}
DEFINE_IID!(IID_ITimedMetadataEncodingProperties, 1372401875, 54928, 19706, 151, 244, 74, 57, 142, 157, 180, 32);
RT_INTERFACE!{interface ITimedMetadataEncodingProperties(ITimedMetadataEncodingPropertiesVtbl, ITimedMetadataEncodingProperties_Abi): IInspectable(IInspectableVtbl) [IID_ITimedMetadataEncodingProperties] {
    fn SetFormatUserData(&self, valueSize: u32, value: *mut u8) -> HRESULT,
    fn GetFormatUserData(&self, valueSize: *mut u32, value: *mut *mut u8) -> HRESULT,
    fn Copy(&self, out: *mut <TimedMetadataEncodingProperties as RtType>::Abi) -> HRESULT
}}
impl ITimedMetadataEncodingProperties {
    #[inline] pub fn set_format_user_data(&self, value: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetFormatUserData)(self.0.as_abi() as *const _ as *mut _, value.len() as u32, value.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_format_user_data(&self) -> Result<ComArray<u8>> { unsafe { 
        let mut valueSize = 0; let mut value = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetFormatUserData)(self.0.as_abi() as *const _ as *mut _, &mut valueSize, &mut value);
        if hr == S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { err(hr) }
    }}
    #[inline] pub fn copy(&self) -> Result<Option<TimedMetadataEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Copy)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(TimedMetadataEncodingProperties::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class TimedMetadataEncodingProperties: IMediaEncodingProperties}
impl RtActivatable<IActivationFactory> for TimedMetadataEncodingProperties {}
DEFINE_CLSID!(TimedMetadataEncodingProperties(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,77,101,100,105,97,80,114,111,112,101,114,116,105,101,115,46,84,105,109,101,100,77,101,116,97,100,97,116,97,69,110,99,111,100,105,110,103,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_TimedMetadataEncodingProperties]);
DEFINE_IID!(IID_IVideoEncodingProperties, 1995336858, 14274, 20266, 136, 10, 18, 130, 187, 180, 55, 61);
RT_INTERFACE!{interface IVideoEncodingProperties(IVideoEncodingPropertiesVtbl, IVideoEncodingProperties_Abi): IInspectable(IInspectableVtbl) [IID_IVideoEncodingProperties] {
    fn put_Bitrate(&self, value: u32) -> HRESULT,
    fn get_Bitrate(&self, out: *mut u32) -> HRESULT,
    fn put_Width(&self, value: u32) -> HRESULT,
    fn get_Width(&self, out: *mut u32) -> HRESULT,
    fn put_Height(&self, value: u32) -> HRESULT,
    fn get_Height(&self, out: *mut u32) -> HRESULT,
    fn get_FrameRate(&self, out: *mut <MediaRatio as RtType>::Abi) -> HRESULT,
    fn get_PixelAspectRatio(&self, out: *mut <MediaRatio as RtType>::Abi) -> HRESULT
}}
impl IVideoEncodingProperties {
    #[inline] pub fn set_bitrate(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Bitrate)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_bitrate(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Bitrate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_width(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Width)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_width(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Width)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_height(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Height)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_height(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Height)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_frame_rate(&self) -> Result<Option<MediaRatio>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaRatio::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_pixel_aspect_ratio(&self) -> Result<Option<MediaRatio>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PixelAspectRatio)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaRatio::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VideoEncodingProperties: IVideoEncodingProperties}
impl RtActivatable<IVideoEncodingPropertiesStatics> for VideoEncodingProperties {}
impl RtActivatable<IVideoEncodingPropertiesStatics2> for VideoEncodingProperties {}
impl RtActivatable<IActivationFactory> for VideoEncodingProperties {}
impl VideoEncodingProperties {
    #[inline] pub fn create_h264() -> Result<Option<VideoEncodingProperties>> {
        <Self as RtActivatable<IVideoEncodingPropertiesStatics>>::get_activation_factory().create_h264()
    }
    #[inline] pub fn create_mpeg2() -> Result<Option<VideoEncodingProperties>> {
        <Self as RtActivatable<IVideoEncodingPropertiesStatics>>::get_activation_factory().create_mpeg2()
    }
    #[inline] pub fn create_uncompressed(subtype: &HStringArg, width: u32, height: u32) -> Result<Option<VideoEncodingProperties>> {
        <Self as RtActivatable<IVideoEncodingPropertiesStatics>>::get_activation_factory().create_uncompressed(subtype, width, height)
    }
    #[inline] pub fn create_hevc() -> Result<Option<VideoEncodingProperties>> {
        <Self as RtActivatable<IVideoEncodingPropertiesStatics2>>::get_activation_factory().create_hevc()
    }
}
DEFINE_CLSID!(VideoEncodingProperties(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,77,101,100,105,97,80,114,111,112,101,114,116,105,101,115,46,86,105,100,101,111,69,110,99,111,100,105,110,103,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_VideoEncodingProperties]);
DEFINE_IID!(IID_IVideoEncodingProperties2, 4148404719, 54373, 17040, 169, 75, 239, 15, 21, 40, 248, 227);
RT_INTERFACE!{interface IVideoEncodingProperties2(IVideoEncodingProperties2Vtbl, IVideoEncodingProperties2_Abi): IInspectable(IInspectableVtbl) [IID_IVideoEncodingProperties2] {
    fn SetFormatUserData(&self, valueSize: u32, value: *mut u8) -> HRESULT,
    fn GetFormatUserData(&self, valueSize: *mut u32, value: *mut *mut u8) -> HRESULT,
    fn put_ProfileId(&self, value: i32) -> HRESULT,
    fn get_ProfileId(&self, out: *mut i32) -> HRESULT
}}
impl IVideoEncodingProperties2 {
    #[inline] pub fn set_format_user_data(&self, value: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetFormatUserData)(self.0.as_abi() as *const _ as *mut _, value.len() as u32, value.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_format_user_data(&self) -> Result<ComArray<u8>> { unsafe { 
        let mut valueSize = 0; let mut value = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetFormatUserData)(self.0.as_abi() as *const _ as *mut _, &mut valueSize, &mut value);
        if hr == S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { err(hr) }
    }}
    #[inline] pub fn set_profile_id(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ProfileId)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_profile_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProfileId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVideoEncodingProperties3, 946589124, 34618, 18335, 179, 235, 86, 193, 252, 190, 198, 215);
RT_INTERFACE!{interface IVideoEncodingProperties3(IVideoEncodingProperties3Vtbl, IVideoEncodingProperties3_Abi): IInspectable(IInspectableVtbl) [IID_IVideoEncodingProperties3] {
    fn get_StereoscopicVideoPackingMode(&self, out: *mut StereoscopicVideoPackingMode) -> HRESULT
}}
impl IVideoEncodingProperties3 {
    #[inline] pub fn get_stereoscopic_video_packing_mode(&self) -> Result<StereoscopicVideoPackingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StereoscopicVideoPackingMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVideoEncodingProperties4, 1917775892, 49420, 16626, 157, 114, 62, 225, 59, 69, 250, 142);
RT_INTERFACE!{interface IVideoEncodingProperties4(IVideoEncodingProperties4Vtbl, IVideoEncodingProperties4_Abi): IInspectable(IInspectableVtbl) [IID_IVideoEncodingProperties4] {
    fn get_SphericalVideoFrameFormat(&self, out: *mut SphericalVideoFrameFormat) -> HRESULT
}}
impl IVideoEncodingProperties4 {
    #[inline] pub fn get_spherical_video_frame_format(&self) -> Result<SphericalVideoFrameFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SphericalVideoFrameFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVideoEncodingProperties5, 1230571535, 10031, 20174, 164, 223, 192, 204, 219, 51, 216, 64);
RT_INTERFACE!{interface IVideoEncodingProperties5(IVideoEncodingProperties5Vtbl, IVideoEncodingProperties5_Abi): IInspectable(IInspectableVtbl) [IID_IVideoEncodingProperties5] {
    fn Copy(&self, out: *mut <VideoEncodingProperties as RtType>::Abi) -> HRESULT
}}
impl IVideoEncodingProperties5 {
    #[inline] pub fn copy(&self) -> Result<Option<VideoEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Copy)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoEncodingProperties::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVideoEncodingPropertiesStatics, 1021398340, 7621, 17371, 159, 56, 235, 235, 249, 1, 82, 203);
RT_INTERFACE!{static interface IVideoEncodingPropertiesStatics(IVideoEncodingPropertiesStaticsVtbl, IVideoEncodingPropertiesStatics_Abi): IInspectable(IInspectableVtbl) [IID_IVideoEncodingPropertiesStatics] {
    fn CreateH264(&self, out: *mut <VideoEncodingProperties as RtType>::Abi) -> HRESULT,
    fn CreateMpeg2(&self, out: *mut <VideoEncodingProperties as RtType>::Abi) -> HRESULT,
    fn CreateUncompressed(&self, subtype: HSTRING, width: u32, height: u32, out: *mut <VideoEncodingProperties as RtType>::Abi) -> HRESULT
}}
impl IVideoEncodingPropertiesStatics {
    #[inline] pub fn create_h264(&self) -> Result<Option<VideoEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateH264)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_mpeg2(&self) -> Result<Option<VideoEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateMpeg2)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoEncodingProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_uncompressed(&self, subtype: &HStringArg, width: u32, height: u32) -> Result<Option<VideoEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateUncompressed)(self.0.as_abi() as *const _ as *mut _, subtype.get(), width, height, &mut out);
        if hr == S_OK { Ok(VideoEncodingProperties::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVideoEncodingPropertiesStatics2, 3474898269, 18942, 19712, 181, 154, 207, 164, 223, 197, 25, 68);
RT_INTERFACE!{static interface IVideoEncodingPropertiesStatics2(IVideoEncodingPropertiesStatics2Vtbl, IVideoEncodingPropertiesStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IVideoEncodingPropertiesStatics2] {
    fn CreateHevc(&self, out: *mut <VideoEncodingProperties as RtType>::Abi) -> HRESULT
}}
impl IVideoEncodingPropertiesStatics2 {
    #[inline] pub fn create_hevc(&self) -> Result<Option<VideoEncodingProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateHevc)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VideoEncodingProperties::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum VideoEncodingQuality: i32 {
    Auto = 0, HD1080p = 1, HD720p = 2, Wvga = 3, Ntsc = 4, Pal = 5, Vga = 6, Qvga = 7, Uhd2160p = 8, Uhd4320p = 9,
}}
} // Windows.Media.MediaProperties
pub mod ocr { // Windows.Media.Ocr
use crate::prelude::*;
DEFINE_IID!(IID_IOcrEngine, 1511308353, 23414, 12608, 182, 128, 136, 37, 86, 38, 131, 172);
RT_INTERFACE!{interface IOcrEngine(IOcrEngineVtbl, IOcrEngine_Abi): IInspectable(IInspectableVtbl) [IID_IOcrEngine] {
    #[cfg(not(feature="windows-graphics"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-graphics")] fn RecognizeAsync(&self, bitmap: <super::super::graphics::imaging::SoftwareBitmap as RtType>::Abi, out: *mut <foundation::IAsyncOperation<OcrResult> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-globalization")] fn get_RecognizerLanguage(&self, out: *mut <super::super::globalization::Language as RtType>::Abi) -> HRESULT
}}
impl IOcrEngine {
    #[cfg(feature="windows-graphics")] #[inline] pub fn recognize_async(&self, bitmap: &super::super::graphics::imaging::SoftwareBitmap) -> Result<foundation::IAsyncOperation<OcrResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RecognizeAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(bitmap) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_recognizer_language(&self) -> Result<Option<super::super::globalization::Language>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_RecognizerLanguage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::globalization::Language::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class OcrEngine: IOcrEngine}
impl RtActivatable<IOcrEngineStatics> for OcrEngine {}
impl OcrEngine {
    #[inline] pub fn get_max_image_dimension() -> Result<u32> {
        <Self as RtActivatable<IOcrEngineStatics>>::get_activation_factory().get_max_image_dimension()
    }
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_available_recognizer_languages() -> Result<Option<foundation::collections::IVectorView<super::super::globalization::Language>>> {
        <Self as RtActivatable<IOcrEngineStatics>>::get_activation_factory().get_available_recognizer_languages()
    }
    #[cfg(feature="windows-globalization")] #[inline] pub fn is_language_supported(language: &super::super::globalization::Language) -> Result<bool> {
        <Self as RtActivatable<IOcrEngineStatics>>::get_activation_factory().is_language_supported(language)
    }
    #[cfg(feature="windows-globalization")] #[inline] pub fn try_create_from_language(language: &super::super::globalization::Language) -> Result<Option<OcrEngine>> {
        <Self as RtActivatable<IOcrEngineStatics>>::get_activation_factory().try_create_from_language(language)
    }
    #[inline] pub fn try_create_from_user_profile_languages() -> Result<Option<OcrEngine>> {
        <Self as RtActivatable<IOcrEngineStatics>>::get_activation_factory().try_create_from_user_profile_languages()
    }
}
DEFINE_CLSID!(OcrEngine(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,79,99,114,46,79,99,114,69,110,103,105,110,101,0]) [CLSID_OcrEngine]);
DEFINE_IID!(IID_IOcrEngineStatics, 1543481434, 13188, 13632, 153, 64, 105, 145, 32, 212, 40, 168);
RT_INTERFACE!{static interface IOcrEngineStatics(IOcrEngineStaticsVtbl, IOcrEngineStatics_Abi): IInspectable(IInspectableVtbl) [IID_IOcrEngineStatics] {
    fn get_MaxImageDimension(&self, out: *mut u32) -> HRESULT,
    #[cfg(not(feature="windows-globalization"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-globalization")] fn get_AvailableRecognizerLanguages(&self, out: *mut <foundation::collections::IVectorView<super::super::globalization::Language> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-globalization"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-globalization")] fn IsLanguageSupported(&self, language: <super::super::globalization::Language as RtType>::Abi, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-globalization"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-globalization")] fn TryCreateFromLanguage(&self, language: <super::super::globalization::Language as RtType>::Abi, out: *mut <OcrEngine as RtType>::Abi) -> HRESULT,
    fn TryCreateFromUserProfileLanguages(&self, out: *mut <OcrEngine as RtType>::Abi) -> HRESULT
}}
impl IOcrEngineStatics {
    #[inline] pub fn get_max_image_dimension(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxImageDimension)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_available_recognizer_languages(&self) -> Result<Option<foundation::collections::IVectorView<super::super::globalization::Language>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AvailableRecognizerLanguages)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-globalization")] #[inline] pub fn is_language_supported(&self, language: &super::super::globalization::Language) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsLanguageSupported)(self.0.as_abi() as *const _ as *mut _, get_abi(language) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-globalization")] #[inline] pub fn try_create_from_language(&self, language: &super::super::globalization::Language) -> Result<Option<OcrEngine>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryCreateFromLanguage)(self.0.as_abi() as *const _ as *mut _, get_abi(language) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(OcrEngine::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_create_from_user_profile_languages(&self) -> Result<Option<OcrEngine>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryCreateFromUserProfileLanguages)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(OcrEngine::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IOcrLine, 4432239, 58143, 14884, 137, 156, 212, 68, 189, 8, 129, 36);
RT_INTERFACE!{interface IOcrLine(IOcrLineVtbl, IOcrLine_Abi): IInspectable(IInspectableVtbl) [IID_IOcrLine] {
    fn get_Words(&self, out: *mut <foundation::collections::IVectorView<OcrWord> as RtType>::Abi) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT
}}
impl IOcrLine {
    #[inline] pub fn get_words(&self) -> Result<Option<foundation::collections::IVectorView<OcrWord>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Words)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Text)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class OcrLine: IOcrLine}
DEFINE_IID!(IID_IOcrResult, 2614244786, 5979, 15722, 146, 226, 56, 140, 32, 110, 47, 99);
RT_INTERFACE!{interface IOcrResult(IOcrResultVtbl, IOcrResult_Abi): IInspectable(IInspectableVtbl) [IID_IOcrResult] {
    fn get_Lines(&self, out: *mut <foundation::collections::IVectorView<OcrLine> as RtType>::Abi) -> HRESULT,
    fn get_TextAngle(&self, out: *mut <foundation::IReference<f64> as RtType>::Abi) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT
}}
impl IOcrResult {
    #[inline] pub fn get_lines(&self) -> Result<Option<foundation::collections::IVectorView<OcrLine>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Lines)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_text_angle(&self) -> Result<Option<foundation::IReference<f64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TextAngle)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Text)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class OcrResult: IOcrResult}
DEFINE_IID!(IID_IOcrWord, 1009403770, 23769, 13605, 186, 42, 35, 209, 224, 166, 138, 29);
RT_INTERFACE!{interface IOcrWord(IOcrWordVtbl, IOcrWord_Abi): IInspectable(IInspectableVtbl) [IID_IOcrWord] {
    fn get_BoundingRect(&self, out: *mut foundation::Rect) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT
}}
impl IOcrWord {
    #[inline] pub fn get_bounding_rect(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BoundingRect)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Text)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class OcrWord: IOcrWord}
} // Windows.Media.Ocr
pub mod playto { // Windows.Media.PlayTo
use crate::prelude::*;
DEFINE_IID!(IID_ICurrentTimeChangeRequestedEventArgs, 2574324516, 60871, 19445, 145, 246, 60, 134, 39, 219, 89, 229);
RT_INTERFACE!{interface ICurrentTimeChangeRequestedEventArgs(ICurrentTimeChangeRequestedEventArgsVtbl, ICurrentTimeChangeRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ICurrentTimeChangeRequestedEventArgs] {
    fn get_Time(&self, out: *mut foundation::TimeSpan) -> HRESULT
}}
impl ICurrentTimeChangeRequestedEventArgs {
    #[inline] pub fn get_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Time)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CurrentTimeChangeRequestedEventArgs: ICurrentTimeChangeRequestedEventArgs}
DEFINE_IID!(IID_IMuteChangeRequestedEventArgs, 3837064694, 44831, 20254, 180, 55, 125, 163, 36, 0, 225, 212);
RT_INTERFACE!{interface IMuteChangeRequestedEventArgs(IMuteChangeRequestedEventArgsVtbl, IMuteChangeRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMuteChangeRequestedEventArgs] {
    fn get_Mute(&self, out: *mut bool) -> HRESULT
}}
impl IMuteChangeRequestedEventArgs {
    #[inline] pub fn get_mute(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mute)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MuteChangeRequestedEventArgs: IMuteChangeRequestedEventArgs}
DEFINE_IID!(IID_IPlaybackRateChangeRequestedEventArgs, 257319342, 11400, 19658, 133, 64, 213, 134, 9, 93, 19, 165);
RT_INTERFACE!{interface IPlaybackRateChangeRequestedEventArgs(IPlaybackRateChangeRequestedEventArgsVtbl, IPlaybackRateChangeRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPlaybackRateChangeRequestedEventArgs] {
    fn get_Rate(&self, out: *mut f64) -> HRESULT
}}
impl IPlaybackRateChangeRequestedEventArgs {
    #[inline] pub fn get_rate(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Rate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PlaybackRateChangeRequestedEventArgs: IPlaybackRateChangeRequestedEventArgs}
DEFINE_IID!(IID_IPlayToConnection, 288341960, 62005, 20446, 141, 65, 155, 242, 124, 158, 154, 64);
RT_INTERFACE!{interface IPlayToConnection(IPlayToConnectionVtbl, IPlayToConnection_Abi): IInspectable(IInspectableVtbl) [IID_IPlayToConnection] {
    fn get_State(&self, out: *mut PlayToConnectionState) -> HRESULT,
    fn add_StateChanged(&self, handler: <foundation::TypedEventHandler<PlayToConnection, PlayToConnectionStateChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Transferred(&self, handler: <foundation::TypedEventHandler<PlayToConnection, PlayToConnectionTransferredEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Transferred(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Error(&self, handler: <foundation::TypedEventHandler<PlayToConnection, PlayToConnectionErrorEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Error(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IPlayToConnection {
    #[inline] pub fn get_state(&self) -> Result<PlayToConnectionState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_state_changed(&self, handler: &foundation::TypedEventHandler<PlayToConnection, PlayToConnectionStateChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_transferred(&self, handler: &foundation::TypedEventHandler<PlayToConnection, PlayToConnectionTransferredEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Transferred)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_transferred(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Transferred)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_error(&self, handler: &foundation::TypedEventHandler<PlayToConnection, PlayToConnectionErrorEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Error)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_error(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Error)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayToConnection: IPlayToConnection}
RT_ENUM! { enum PlayToConnectionError: i32 {
    None = 0, DeviceNotResponding = 1, DeviceError = 2, DeviceLocked = 3, ProtectedPlaybackFailed = 4,
}}
DEFINE_IID!(IID_IPlayToConnectionErrorEventArgs, 3210653094, 35046, 17503, 157, 64, 217, 185, 248, 147, 152, 150);
RT_INTERFACE!{interface IPlayToConnectionErrorEventArgs(IPlayToConnectionErrorEventArgsVtbl, IPlayToConnectionErrorEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPlayToConnectionErrorEventArgs] {
    fn get_Code(&self, out: *mut PlayToConnectionError) -> HRESULT,
    fn get_Message(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPlayToConnectionErrorEventArgs {
    #[inline] pub fn get_code(&self) -> Result<PlayToConnectionError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Code)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_message(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Message)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayToConnectionErrorEventArgs: IPlayToConnectionErrorEventArgs}
RT_ENUM! { enum PlayToConnectionState: i32 {
    Disconnected = 0, Connected = 1, Rendering = 2,
}}
DEFINE_IID!(IID_IPlayToConnectionStateChangedEventArgs, 1757721871, 3104, 18816, 134, 2, 88, 198, 34, 56, 212, 35);
RT_INTERFACE!{interface IPlayToConnectionStateChangedEventArgs(IPlayToConnectionStateChangedEventArgsVtbl, IPlayToConnectionStateChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPlayToConnectionStateChangedEventArgs] {
    fn get_PreviousState(&self, out: *mut PlayToConnectionState) -> HRESULT,
    fn get_CurrentState(&self, out: *mut PlayToConnectionState) -> HRESULT
}}
impl IPlayToConnectionStateChangedEventArgs {
    #[inline] pub fn get_previous_state(&self) -> Result<PlayToConnectionState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PreviousState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_current_state(&self) -> Result<PlayToConnectionState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CurrentState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayToConnectionStateChangedEventArgs: IPlayToConnectionStateChangedEventArgs}
DEFINE_IID!(IID_IPlayToConnectionTransferredEventArgs, 4209187130, 1667, 18393, 141, 240, 24, 203, 180, 137, 132, 216);
RT_INTERFACE!{interface IPlayToConnectionTransferredEventArgs(IPlayToConnectionTransferredEventArgsVtbl, IPlayToConnectionTransferredEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPlayToConnectionTransferredEventArgs] {
    fn get_PreviousSource(&self, out: *mut <PlayToSource as RtType>::Abi) -> HRESULT,
    fn get_CurrentSource(&self, out: *mut <PlayToSource as RtType>::Abi) -> HRESULT
}}
impl IPlayToConnectionTransferredEventArgs {
    #[inline] pub fn get_previous_source(&self) -> Result<Option<PlayToSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PreviousSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PlayToSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_current_source(&self) -> Result<Option<PlayToSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CurrentSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PlayToSource::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayToConnectionTransferredEventArgs: IPlayToConnectionTransferredEventArgs}
DEFINE_IID!(IID_IPlayToManager, 4117373038, 7031, 17135, 143, 13, 185, 73, 248, 217, 178, 96);
RT_INTERFACE!{interface IPlayToManager(IPlayToManagerVtbl, IPlayToManager_Abi): IInspectable(IInspectableVtbl) [IID_IPlayToManager] {
    fn add_SourceRequested(&self, handler: <foundation::TypedEventHandler<PlayToManager, PlayToSourceRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourceRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SourceSelected(&self, handler: <foundation::TypedEventHandler<PlayToManager, PlayToSourceSelectedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourceSelected(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn put_DefaultSourceSelection(&self, value: bool) -> HRESULT,
    fn get_DefaultSourceSelection(&self, out: *mut bool) -> HRESULT
}}
impl IPlayToManager {
    #[inline] pub fn add_source_requested(&self, handler: &foundation::TypedEventHandler<PlayToManager, PlayToSourceRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SourceRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SourceRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_source_selected(&self, handler: &foundation::TypedEventHandler<PlayToManager, PlayToSourceSelectedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SourceSelected)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_selected(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SourceSelected)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_default_source_selection(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DefaultSourceSelection)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_default_source_selection(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DefaultSourceSelection)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayToManager: IPlayToManager}
impl RtActivatable<IPlayToManagerStatics> for PlayToManager {}
impl PlayToManager {
    #[inline] pub fn get_for_current_view() -> Result<Option<PlayToManager>> {
        <Self as RtActivatable<IPlayToManagerStatics>>::get_activation_factory().get_for_current_view()
    }
    #[inline] pub fn show_play_to_ui() -> Result<()> {
        <Self as RtActivatable<IPlayToManagerStatics>>::get_activation_factory().show_play_to_ui()
    }
}
DEFINE_CLSID!(PlayToManager(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,108,97,121,84,111,46,80,108,97,121,84,111,77,97,110,97,103,101,114,0]) [CLSID_PlayToManager]);
DEFINE_IID!(IID_IPlayToManagerStatics, 1692838023, 14722, 20283, 186, 32, 97, 85, 228, 53, 50, 91);
RT_INTERFACE!{static interface IPlayToManagerStatics(IPlayToManagerStaticsVtbl, IPlayToManagerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IPlayToManagerStatics] {
    fn GetForCurrentView(&self, out: *mut <PlayToManager as RtType>::Abi) -> HRESULT,
    fn ShowPlayToUI(&self) -> HRESULT
}}
impl IPlayToManagerStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<PlayToManager>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetForCurrentView)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PlayToManager::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_play_to_ui(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ShowPlayToUI)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPlayToReceiver, 2887110471, 41314, 19110, 175, 27, 58, 163, 95, 59, 144, 105);
RT_INTERFACE!{interface IPlayToReceiver(IPlayToReceiverVtbl, IPlayToReceiver_Abi): IInspectable(IInspectableVtbl) [IID_IPlayToReceiver] {
    fn add_PlayRequested(&self, handler: <foundation::TypedEventHandler<PlayToReceiver, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PlayRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PauseRequested(&self, handler: <foundation::TypedEventHandler<PlayToReceiver, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PauseRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SourceChangeRequested(&self, handler: <foundation::TypedEventHandler<PlayToReceiver, SourceChangeRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourceChangeRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PlaybackRateChangeRequested(&self, handler: <foundation::TypedEventHandler<PlayToReceiver, PlaybackRateChangeRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PlaybackRateChangeRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CurrentTimeChangeRequested(&self, handler: <foundation::TypedEventHandler<PlayToReceiver, CurrentTimeChangeRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CurrentTimeChangeRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_MuteChangeRequested(&self, handler: <foundation::TypedEventHandler<PlayToReceiver, MuteChangeRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MuteChangeRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_VolumeChangeRequested(&self, handler: <foundation::TypedEventHandler<PlayToReceiver, VolumeChangeRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VolumeChangeRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_TimeUpdateRequested(&self, handler: <foundation::TypedEventHandler<PlayToReceiver, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TimeUpdateRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_StopRequested(&self, handler: <foundation::TypedEventHandler<PlayToReceiver, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StopRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn NotifyVolumeChange(&self, volume: f64, mute: bool) -> HRESULT,
    fn NotifyRateChange(&self, rate: f64) -> HRESULT,
    fn NotifyLoadedMetadata(&self) -> HRESULT,
    fn NotifyTimeUpdate(&self, currentTime: foundation::TimeSpan) -> HRESULT,
    fn NotifyDurationChange(&self, duration: foundation::TimeSpan) -> HRESULT,
    fn NotifySeeking(&self) -> HRESULT,
    fn NotifySeeked(&self) -> HRESULT,
    fn NotifyPaused(&self) -> HRESULT,
    fn NotifyPlaying(&self) -> HRESULT,
    fn NotifyEnded(&self) -> HRESULT,
    fn NotifyError(&self) -> HRESULT,
    fn NotifyStopped(&self) -> HRESULT,
    fn get_FriendlyName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_FriendlyName(&self, value: HSTRING) -> HRESULT,
    fn put_SupportsImage(&self, value: bool) -> HRESULT,
    fn get_SupportsImage(&self, out: *mut bool) -> HRESULT,
    fn put_SupportsAudio(&self, value: bool) -> HRESULT,
    fn get_SupportsAudio(&self, out: *mut bool) -> HRESULT,
    fn put_SupportsVideo(&self, value: bool) -> HRESULT,
    fn get_SupportsVideo(&self, out: *mut bool) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT,
    fn StartAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn StopAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IPlayToReceiver {
    #[inline] pub fn add_play_requested(&self, handler: &foundation::TypedEventHandler<PlayToReceiver, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PlayRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_play_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PlayRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pause_requested(&self, handler: &foundation::TypedEventHandler<PlayToReceiver, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PauseRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pause_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PauseRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_source_change_requested(&self, handler: &foundation::TypedEventHandler<PlayToReceiver, SourceChangeRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SourceChangeRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_change_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SourceChangeRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_playback_rate_change_requested(&self, handler: &foundation::TypedEventHandler<PlayToReceiver, PlaybackRateChangeRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PlaybackRateChangeRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_playback_rate_change_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PlaybackRateChangeRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_current_time_change_requested(&self, handler: &foundation::TypedEventHandler<PlayToReceiver, CurrentTimeChangeRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_CurrentTimeChangeRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_current_time_change_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_CurrentTimeChangeRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_mute_change_requested(&self, handler: &foundation::TypedEventHandler<PlayToReceiver, MuteChangeRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_MuteChangeRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_mute_change_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_MuteChangeRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_volume_change_requested(&self, handler: &foundation::TypedEventHandler<PlayToReceiver, VolumeChangeRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_VolumeChangeRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_volume_change_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_VolumeChangeRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_time_update_requested(&self, handler: &foundation::TypedEventHandler<PlayToReceiver, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_TimeUpdateRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_time_update_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_TimeUpdateRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stop_requested(&self, handler: &foundation::TypedEventHandler<PlayToReceiver, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StopRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stop_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StopRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_volume_change(&self, volume: f64, mute: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).NotifyVolumeChange)(self.0.as_abi() as *const _ as *mut _, volume, mute);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_rate_change(&self, rate: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).NotifyRateChange)(self.0.as_abi() as *const _ as *mut _, rate);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_loaded_metadata(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).NotifyLoadedMetadata)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_time_update(&self, currentTime: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).NotifyTimeUpdate)(self.0.as_abi() as *const _ as *mut _, currentTime);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_duration_change(&self, duration: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).NotifyDurationChange)(self.0.as_abi() as *const _ as *mut _, duration);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_seeking(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).NotifySeeking)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_seeked(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).NotifySeeked)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_paused(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).NotifyPaused)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_playing(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).NotifyPlaying)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_ended(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).NotifyEnded)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_error(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).NotifyError)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_stopped(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).NotifyStopped)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_friendly_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FriendlyName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_friendly_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_FriendlyName)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_supports_image(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SupportsImage)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_supports_image(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportsImage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_supports_audio(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SupportsAudio)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_supports_audio(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportsAudio)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_supports_video(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SupportsVideo)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_supports_video(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportsVideo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IPropertySet>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IPropertySet::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn start_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StartAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn stop_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StopAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayToReceiver: IPlayToReceiver}
impl RtActivatable<IActivationFactory> for PlayToReceiver {}
DEFINE_CLSID!(PlayToReceiver(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,108,97,121,84,111,46,80,108,97,121,84,111,82,101,99,101,105,118,101,114,0]) [CLSID_PlayToReceiver]);
DEFINE_IID!(IID_IPlayToSource, 2131986952, 64439, 19209, 131, 86, 170, 95, 78, 51, 92, 49);
RT_INTERFACE!{interface IPlayToSource(IPlayToSourceVtbl, IPlayToSource_Abi): IInspectable(IInspectableVtbl) [IID_IPlayToSource] {
    fn get_Connection(&self, out: *mut <PlayToConnection as RtType>::Abi) -> HRESULT,
    fn get_Next(&self, out: *mut <PlayToSource as RtType>::Abi) -> HRESULT,
    fn put_Next(&self, value: <PlayToSource as RtType>::Abi) -> HRESULT,
    fn PlayNext(&self) -> HRESULT
}}
impl IPlayToSource {
    #[inline] pub fn get_connection(&self) -> Result<Option<PlayToConnection>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Connection)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PlayToConnection::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_next(&self) -> Result<Option<PlayToSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Next)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PlayToSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_next(&self, value: &PlayToSource) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Next)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn play_next(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).PlayNext)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayToSource: IPlayToSource}
DEFINE_IID!(IID_IPlayToSourceDeferral, 1090554141, 10126, 20265, 133, 155, 169, 229, 1, 5, 62, 125);
RT_INTERFACE!{interface IPlayToSourceDeferral(IPlayToSourceDeferralVtbl, IPlayToSourceDeferral_Abi): IInspectable(IInspectableVtbl) [IID_IPlayToSourceDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IPlayToSourceDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Complete)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayToSourceDeferral: IPlayToSourceDeferral}
DEFINE_IID!(IID_IPlayToSourceRequest, 4166534757, 25844, 17568, 172, 13, 70, 141, 43, 143, 218, 131);
RT_INTERFACE!{interface IPlayToSourceRequest(IPlayToSourceRequestVtbl, IPlayToSourceRequest_Abi): IInspectable(IInspectableVtbl) [IID_IPlayToSourceRequest] {
    fn get_Deadline(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn DisplayErrorString(&self, errorString: HSTRING) -> HRESULT,
    fn GetDeferral(&self, out: *mut <PlayToSourceDeferral as RtType>::Abi) -> HRESULT,
    fn SetSource(&self, value: <PlayToSource as RtType>::Abi) -> HRESULT
}}
impl IPlayToSourceRequest {
    #[inline] pub fn get_deadline(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Deadline)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn display_error_string(&self, errorString: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).DisplayErrorString)(self.0.as_abi() as *const _ as *mut _, errorString.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<PlayToSourceDeferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PlayToSourceDeferral::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_source(&self, value: &PlayToSource) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetSource)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayToSourceRequest: IPlayToSourceRequest}
DEFINE_IID!(IID_IPlayToSourceRequestedEventArgs, 3318596400, 10719, 20166, 157, 169, 159, 189, 252, 252, 27, 62);
RT_INTERFACE!{interface IPlayToSourceRequestedEventArgs(IPlayToSourceRequestedEventArgsVtbl, IPlayToSourceRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPlayToSourceRequestedEventArgs] {
    fn get_SourceRequest(&self, out: *mut <PlayToSourceRequest as RtType>::Abi) -> HRESULT
}}
impl IPlayToSourceRequestedEventArgs {
    #[inline] pub fn get_source_request(&self) -> Result<Option<PlayToSourceRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SourceRequest)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PlayToSourceRequest::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayToSourceRequestedEventArgs: IPlayToSourceRequestedEventArgs}
DEFINE_IID!(IID_IPlayToSourceSelectedEventArgs, 211649809, 20994, 19915, 140, 103, 171, 218, 18, 187, 60, 18);
RT_INTERFACE!{interface IPlayToSourceSelectedEventArgs(IPlayToSourceSelectedEventArgsVtbl, IPlayToSourceSelectedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPlayToSourceSelectedEventArgs] {
    fn get_FriendlyName(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Icon(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamWithContentType as RtType>::Abi) -> HRESULT,
    fn get_SupportsImage(&self, out: *mut bool) -> HRESULT,
    fn get_SupportsAudio(&self, out: *mut bool) -> HRESULT,
    fn get_SupportsVideo(&self, out: *mut bool) -> HRESULT
}}
impl IPlayToSourceSelectedEventArgs {
    #[inline] pub fn get_friendly_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FriendlyName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_icon(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamWithContentType>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Icon)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamWithContentType::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supports_image(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportsImage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supports_audio(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportsAudio)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supports_video(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportsVideo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayToSourceSelectedEventArgs: IPlayToSourceSelectedEventArgs}
DEFINE_IID!(IID_IPlayToSourceWithPreferredSourceUri, 2863813611, 13057, 19908, 175, 186, 178, 242, 237, 150, 53, 160);
RT_INTERFACE!{interface IPlayToSourceWithPreferredSourceUri(IPlayToSourceWithPreferredSourceUriVtbl, IPlayToSourceWithPreferredSourceUri_Abi): IInspectable(IInspectableVtbl) [IID_IPlayToSourceWithPreferredSourceUri] {
    fn get_PreferredSourceUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_PreferredSourceUri(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT
}}
impl IPlayToSourceWithPreferredSourceUri {
    #[inline] pub fn get_preferred_source_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PreferredSourceUri)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_preferred_source_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PreferredSourceUri)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISourceChangeRequestedEventArgs, 4215224982, 31398, 19083, 134, 231, 84, 246, 198, 211, 79, 100);
RT_INTERFACE!{interface ISourceChangeRequestedEventArgs(ISourceChangeRequestedEventArgsVtbl, ISourceChangeRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ISourceChangeRequestedEventArgs] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Stream(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamWithContentType as RtType>::Abi) -> HRESULT,
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Author(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Album(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Genre(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Date(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Thumbnail(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    fn get_Rating(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl ISourceChangeRequestedEventArgs {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_stream(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamWithContentType>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Stream)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamWithContentType::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Title)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_author(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Author)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_album(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Album)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_genre(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Genre)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Description)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_date(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Date)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_thumbnail(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Thumbnail)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_rating(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Rating)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SourceChangeRequestedEventArgs: ISourceChangeRequestedEventArgs}
DEFINE_IID!(IID_IVolumeChangeRequestedEventArgs, 1862430044, 53109, 19499, 145, 62, 109, 124, 108, 50, 145, 121);
RT_INTERFACE!{interface IVolumeChangeRequestedEventArgs(IVolumeChangeRequestedEventArgsVtbl, IVolumeChangeRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IVolumeChangeRequestedEventArgs] {
    fn get_Volume(&self, out: *mut f64) -> HRESULT
}}
impl IVolumeChangeRequestedEventArgs {
    #[inline] pub fn get_volume(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Volume)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class VolumeChangeRequestedEventArgs: IVolumeChangeRequestedEventArgs}
} // Windows.Media.PlayTo
pub mod playback { // Windows.Media.Playback
use crate::prelude::*;
RT_ENUM! { enum AutoLoadedDisplayPropertyKind: i32 {
    None = 0, MusicOrVideo = 1, Music = 2, Video = 3,
}}
RT_CLASS!{static class BackgroundMediaPlayer}
impl RtActivatable<IBackgroundMediaPlayerStatics> for BackgroundMediaPlayer {}
impl BackgroundMediaPlayer {
    #[inline] pub fn get_current() -> Result<Option<MediaPlayer>> {
        <Self as RtActivatable<IBackgroundMediaPlayerStatics>>::get_activation_factory().get_current()
    }
    #[inline] pub fn add_message_received_from_background(value: &foundation::EventHandler<MediaPlayerDataReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IBackgroundMediaPlayerStatics>>::get_activation_factory().add_message_received_from_background(value)
    }
    #[inline] pub fn remove_message_received_from_background(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IBackgroundMediaPlayerStatics>>::get_activation_factory().remove_message_received_from_background(token)
    }
    #[inline] pub fn add_message_received_from_foreground(value: &foundation::EventHandler<MediaPlayerDataReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IBackgroundMediaPlayerStatics>>::get_activation_factory().add_message_received_from_foreground(value)
    }
    #[inline] pub fn remove_message_received_from_foreground(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IBackgroundMediaPlayerStatics>>::get_activation_factory().remove_message_received_from_foreground(token)
    }
    #[inline] pub fn send_message_to_background(value: &foundation::collections::ValueSet) -> Result<()> {
        <Self as RtActivatable<IBackgroundMediaPlayerStatics>>::get_activation_factory().send_message_to_background(value)
    }
    #[inline] pub fn send_message_to_foreground(value: &foundation::collections::ValueSet) -> Result<()> {
        <Self as RtActivatable<IBackgroundMediaPlayerStatics>>::get_activation_factory().send_message_to_foreground(value)
    }
    #[inline] pub fn is_media_playing() -> Result<bool> {
        <Self as RtActivatable<IBackgroundMediaPlayerStatics>>::get_activation_factory().is_media_playing()
    }
    #[inline] pub fn shutdown() -> Result<()> {
        <Self as RtActivatable<IBackgroundMediaPlayerStatics>>::get_activation_factory().shutdown()
    }
}
DEFINE_CLSID!(BackgroundMediaPlayer(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,108,97,121,98,97,99,107,46,66,97,99,107,103,114,111,117,110,100,77,101,100,105,97,80,108,97,121,101,114,0]) [CLSID_BackgroundMediaPlayer]);
DEFINE_IID!(IID_IBackgroundMediaPlayerStatics, 2238569409, 22007, 18207, 160, 242, 104, 172, 76, 144, 69, 146);
RT_INTERFACE!{static interface IBackgroundMediaPlayerStatics(IBackgroundMediaPlayerStaticsVtbl, IBackgroundMediaPlayerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IBackgroundMediaPlayerStatics] {
    fn get_Current(&self, out: *mut <MediaPlayer as RtType>::Abi) -> HRESULT,
    fn add_MessageReceivedFromBackground(&self, value: <foundation::EventHandler<MediaPlayerDataReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MessageReceivedFromBackground(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_MessageReceivedFromForeground(&self, value: <foundation::EventHandler<MediaPlayerDataReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MessageReceivedFromForeground(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn SendMessageToBackground(&self, value: <foundation::collections::ValueSet as RtType>::Abi) -> HRESULT,
    fn SendMessageToForeground(&self, value: <foundation::collections::ValueSet as RtType>::Abi) -> HRESULT,
    fn IsMediaPlaying(&self, out: *mut bool) -> HRESULT,
    fn Shutdown(&self) -> HRESULT
}}
impl IBackgroundMediaPlayerStatics {
    #[inline] pub fn get_current(&self) -> Result<Option<MediaPlayer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Current)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlayer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_message_received_from_background(&self, value: &foundation::EventHandler<MediaPlayerDataReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_MessageReceivedFromBackground)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_message_received_from_background(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_MessageReceivedFromBackground)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_message_received_from_foreground(&self, value: &foundation::EventHandler<MediaPlayerDataReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_MessageReceivedFromForeground)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_message_received_from_foreground(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_MessageReceivedFromForeground)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn send_message_to_background(&self, value: &foundation::collections::ValueSet) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SendMessageToBackground)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn send_message_to_foreground(&self, value: &foundation::collections::ValueSet) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SendMessageToForeground)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn is_media_playing(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsMediaPlaying)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn shutdown(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Shutdown)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICurrentMediaPlaybackItemChangedEventArgs, 390310034, 23619, 18965, 150, 122, 87, 45, 45, 15, 38, 198);
RT_INTERFACE!{interface ICurrentMediaPlaybackItemChangedEventArgs(ICurrentMediaPlaybackItemChangedEventArgsVtbl, ICurrentMediaPlaybackItemChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ICurrentMediaPlaybackItemChangedEventArgs] {
    fn get_NewItem(&self, out: *mut <MediaPlaybackItem as RtType>::Abi) -> HRESULT,
    fn get_OldItem(&self, out: *mut <MediaPlaybackItem as RtType>::Abi) -> HRESULT
}}
impl ICurrentMediaPlaybackItemChangedEventArgs {
    #[inline] pub fn get_new_item(&self) -> Result<Option<MediaPlaybackItem>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_NewItem)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackItem::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_old_item(&self) -> Result<Option<MediaPlaybackItem>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_OldItem)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackItem::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CurrentMediaPlaybackItemChangedEventArgs: ICurrentMediaPlaybackItemChangedEventArgs}
DEFINE_IID!(IID_ICurrentMediaPlaybackItemChangedEventArgs2, 494970142, 39278, 16553, 190, 72, 230, 110, 201, 11, 43, 125);
RT_INTERFACE!{interface ICurrentMediaPlaybackItemChangedEventArgs2(ICurrentMediaPlaybackItemChangedEventArgs2Vtbl, ICurrentMediaPlaybackItemChangedEventArgs2_Abi): IInspectable(IInspectableVtbl) [IID_ICurrentMediaPlaybackItemChangedEventArgs2] {
    fn get_Reason(&self, out: *mut MediaPlaybackItemChangedReason) -> HRESULT
}}
impl ICurrentMediaPlaybackItemChangedEventArgs2 {
    #[inline] pub fn get_reason(&self) -> Result<MediaPlaybackItemChangedReason> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reason)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum FailedMediaStreamKind: i32 {
    Unknown = 0, Audio = 1, Video = 2,
}}
DEFINE_IID!(IID_IMediaBreak, 1900798576, 3567, 20156, 164, 137, 107, 52, 147, 14, 21, 88);
RT_INTERFACE!{interface IMediaBreak(IMediaBreakVtbl, IMediaBreak_Abi): IInspectable(IInspectableVtbl) [IID_IMediaBreak] {
    fn get_PlaybackList(&self, out: *mut <MediaPlaybackList as RtType>::Abi) -> HRESULT,
    fn get_PresentationPosition(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_InsertionMethod(&self, out: *mut MediaBreakInsertionMethod) -> HRESULT,
    fn get_CustomProperties(&self, out: *mut <foundation::collections::ValueSet as RtType>::Abi) -> HRESULT,
    fn get_CanStart(&self, out: *mut bool) -> HRESULT,
    fn put_CanStart(&self, value: bool) -> HRESULT
}}
impl IMediaBreak {
    #[inline] pub fn get_playback_list(&self) -> Result<Option<MediaPlaybackList>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackList)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackList::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_presentation_position(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PresentationPosition)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_insertion_method(&self) -> Result<MediaBreakInsertionMethod> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InsertionMethod)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_custom_properties(&self) -> Result<Option<foundation::collections::ValueSet>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CustomProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::ValueSet::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_can_start(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanStart)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_can_start(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CanStart)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaBreak: IMediaBreak}
impl RtActivatable<IMediaBreakFactory> for MediaBreak {}
impl MediaBreak {
    #[inline] pub fn create(insertionMethod: MediaBreakInsertionMethod) -> Result<MediaBreak> {
        <Self as RtActivatable<IMediaBreakFactory>>::get_activation_factory().create(insertionMethod)
    }
    #[inline] pub fn create_with_presentation_position(insertionMethod: MediaBreakInsertionMethod, presentationPosition: foundation::TimeSpan) -> Result<MediaBreak> {
        <Self as RtActivatable<IMediaBreakFactory>>::get_activation_factory().create_with_presentation_position(insertionMethod, presentationPosition)
    }
}
DEFINE_CLSID!(MediaBreak(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,108,97,121,98,97,99,107,46,77,101,100,105,97,66,114,101,97,107,0]) [CLSID_MediaBreak]);
DEFINE_IID!(IID_IMediaBreakEndedEventArgs, 850997878, 7261, 20462, 135, 50, 35, 109, 195, 168, 133, 128);
RT_INTERFACE!{interface IMediaBreakEndedEventArgs(IMediaBreakEndedEventArgsVtbl, IMediaBreakEndedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaBreakEndedEventArgs] {
    fn get_MediaBreak(&self, out: *mut <MediaBreak as RtType>::Abi) -> HRESULT
}}
impl IMediaBreakEndedEventArgs {
    #[inline] pub fn get_media_break(&self) -> Result<Option<MediaBreak>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaBreak)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaBreak::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaBreakEndedEventArgs: IMediaBreakEndedEventArgs}
DEFINE_IID!(IID_IMediaBreakFactory, 1159127042, 6368, 16505, 139, 95, 211, 52, 149, 193, 93, 46);
RT_INTERFACE!{static interface IMediaBreakFactory(IMediaBreakFactoryVtbl, IMediaBreakFactory_Abi): IInspectable(IInspectableVtbl) [IID_IMediaBreakFactory] {
    fn Create(&self, insertionMethod: MediaBreakInsertionMethod, out: *mut <MediaBreak as RtType>::Abi) -> HRESULT,
    fn CreateWithPresentationPosition(&self, insertionMethod: MediaBreakInsertionMethod, presentationPosition: foundation::TimeSpan, out: *mut <MediaBreak as RtType>::Abi) -> HRESULT
}}
impl IMediaBreakFactory {
    #[inline] pub fn create(&self, insertionMethod: MediaBreakInsertionMethod) -> Result<MediaBreak> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, insertionMethod, &mut out);
        if hr == S_OK { Ok(MediaBreak::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_presentation_position(&self, insertionMethod: MediaBreakInsertionMethod, presentationPosition: foundation::TimeSpan) -> Result<MediaBreak> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithPresentationPosition)(self.0.as_abi() as *const _ as *mut _, insertionMethod, presentationPosition, &mut out);
        if hr == S_OK { Ok(MediaBreak::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum MediaBreakInsertionMethod: i32 {
    Interrupt = 0, Replace = 1,
}}
DEFINE_IID!(IID_IMediaBreakManager, 2824134065, 65204, 19867, 157, 151, 15, 219, 229, 142, 94, 57);
RT_INTERFACE!{interface IMediaBreakManager(IMediaBreakManagerVtbl, IMediaBreakManager_Abi): IInspectable(IInspectableVtbl) [IID_IMediaBreakManager] {
    fn add_BreaksSeekedOver(&self, handler: <foundation::TypedEventHandler<MediaBreakManager, MediaBreakSeekedOverEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BreaksSeekedOver(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_BreakStarted(&self, handler: <foundation::TypedEventHandler<MediaBreakManager, MediaBreakStartedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BreakStarted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_BreakEnded(&self, handler: <foundation::TypedEventHandler<MediaBreakManager, MediaBreakEndedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BreakEnded(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_BreakSkipped(&self, handler: <foundation::TypedEventHandler<MediaBreakManager, MediaBreakSkippedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BreakSkipped(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_CurrentBreak(&self, out: *mut <MediaBreak as RtType>::Abi) -> HRESULT,
    fn get_PlaybackSession(&self, out: *mut <MediaPlaybackSession as RtType>::Abi) -> HRESULT,
    fn PlayBreak(&self, value: <MediaBreak as RtType>::Abi) -> HRESULT,
    fn SkipCurrentBreak(&self) -> HRESULT
}}
impl IMediaBreakManager {
    #[inline] pub fn add_breaks_seeked_over(&self, handler: &foundation::TypedEventHandler<MediaBreakManager, MediaBreakSeekedOverEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_BreaksSeekedOver)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_breaks_seeked_over(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_BreaksSeekedOver)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_break_started(&self, handler: &foundation::TypedEventHandler<MediaBreakManager, MediaBreakStartedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_BreakStarted)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_break_started(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_BreakStarted)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_break_ended(&self, handler: &foundation::TypedEventHandler<MediaBreakManager, MediaBreakEndedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_BreakEnded)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_break_ended(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_BreakEnded)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_break_skipped(&self, handler: &foundation::TypedEventHandler<MediaBreakManager, MediaBreakSkippedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_BreakSkipped)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_break_skipped(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_BreakSkipped)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_current_break(&self) -> Result<Option<MediaBreak>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CurrentBreak)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaBreak::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_playback_session(&self) -> Result<Option<MediaPlaybackSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackSession)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackSession::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn play_break(&self, value: &MediaBreak) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).PlayBreak)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn skip_current_break(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SkipCurrentBreak)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaBreakManager: IMediaBreakManager}
DEFINE_IID!(IID_IMediaBreakSchedule, 2711246867, 39094, 16856, 131, 218, 249, 113, 210, 43, 123, 186);
RT_INTERFACE!{interface IMediaBreakSchedule(IMediaBreakScheduleVtbl, IMediaBreakSchedule_Abi): IInspectable(IInspectableVtbl) [IID_IMediaBreakSchedule] {
    fn add_ScheduleChanged(&self, handler: <foundation::TypedEventHandler<MediaBreakSchedule, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ScheduleChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn InsertMidrollBreak(&self, mediaBreak: <MediaBreak as RtType>::Abi) -> HRESULT,
    fn RemoveMidrollBreak(&self, mediaBreak: <MediaBreak as RtType>::Abi) -> HRESULT,
    fn get_MidrollBreaks(&self, out: *mut <foundation::collections::IVectorView<MediaBreak> as RtType>::Abi) -> HRESULT,
    fn put_PrerollBreak(&self, value: <MediaBreak as RtType>::Abi) -> HRESULT,
    fn get_PrerollBreak(&self, out: *mut <MediaBreak as RtType>::Abi) -> HRESULT,
    fn put_PostrollBreak(&self, value: <MediaBreak as RtType>::Abi) -> HRESULT,
    fn get_PostrollBreak(&self, out: *mut <MediaBreak as RtType>::Abi) -> HRESULT,
    fn get_PlaybackItem(&self, out: *mut <MediaPlaybackItem as RtType>::Abi) -> HRESULT
}}
impl IMediaBreakSchedule {
    #[inline] pub fn add_schedule_changed(&self, handler: &foundation::TypedEventHandler<MediaBreakSchedule, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ScheduleChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_schedule_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ScheduleChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_midroll_break(&self, mediaBreak: &MediaBreak) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).InsertMidrollBreak)(self.0.as_abi() as *const _ as *mut _, get_abi(mediaBreak) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove_midroll_break(&self, mediaBreak: &MediaBreak) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RemoveMidrollBreak)(self.0.as_abi() as *const _ as *mut _, get_abi(mediaBreak) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_midroll_breaks(&self) -> Result<Option<foundation::collections::IVectorView<MediaBreak>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MidrollBreaks)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_preroll_break(&self, value: &MediaBreak) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PrerollBreak)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_preroll_break(&self) -> Result<Option<MediaBreak>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PrerollBreak)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaBreak::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_postroll_break(&self, value: &MediaBreak) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PostrollBreak)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_postroll_break(&self) -> Result<Option<MediaBreak>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PostrollBreak)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaBreak::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_playback_item(&self) -> Result<Option<MediaPlaybackItem>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackItem)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackItem::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaBreakSchedule: IMediaBreakSchedule}
DEFINE_IID!(IID_IMediaBreakSeekedOverEventArgs, 3853150022, 1542, 17554, 185, 211, 195, 200, 253, 224, 164, 234);
RT_INTERFACE!{interface IMediaBreakSeekedOverEventArgs(IMediaBreakSeekedOverEventArgsVtbl, IMediaBreakSeekedOverEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaBreakSeekedOverEventArgs] {
    fn get_SeekedOverBreaks(&self, out: *mut <foundation::collections::IVectorView<MediaBreak> as RtType>::Abi) -> HRESULT,
    fn get_OldPosition(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_NewPosition(&self, out: *mut foundation::TimeSpan) -> HRESULT
}}
impl IMediaBreakSeekedOverEventArgs {
    #[inline] pub fn get_seeked_over_breaks(&self) -> Result<Option<foundation::collections::IVectorView<MediaBreak>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SeekedOverBreaks)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_old_position(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OldPosition)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_new_position(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_NewPosition)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaBreakSeekedOverEventArgs: IMediaBreakSeekedOverEventArgs}
DEFINE_IID!(IID_IMediaBreakSkippedEventArgs, 1860783109, 12116, 19006, 163, 171, 36, 195, 178, 112, 180, 163);
RT_INTERFACE!{interface IMediaBreakSkippedEventArgs(IMediaBreakSkippedEventArgsVtbl, IMediaBreakSkippedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaBreakSkippedEventArgs] {
    fn get_MediaBreak(&self, out: *mut <MediaBreak as RtType>::Abi) -> HRESULT
}}
impl IMediaBreakSkippedEventArgs {
    #[inline] pub fn get_media_break(&self) -> Result<Option<MediaBreak>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaBreak)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaBreak::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaBreakSkippedEventArgs: IMediaBreakSkippedEventArgs}
DEFINE_IID!(IID_IMediaBreakStartedEventArgs, 2826894961, 57300, 17738, 149, 110, 10, 74, 100, 131, 149, 248);
RT_INTERFACE!{interface IMediaBreakStartedEventArgs(IMediaBreakStartedEventArgsVtbl, IMediaBreakStartedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaBreakStartedEventArgs] {
    fn get_MediaBreak(&self, out: *mut <MediaBreak as RtType>::Abi) -> HRESULT
}}
impl IMediaBreakStartedEventArgs {
    #[inline] pub fn get_media_break(&self) -> Result<Option<MediaBreak>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaBreak)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaBreak::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaBreakStartedEventArgs: IMediaBreakStartedEventArgs}
RT_ENUM! { enum MediaCommandEnablingRule: i32 {
    Auto = 0, Always = 1, Never = 2,
}}
DEFINE_IID!(IID_IMediaEnginePlaybackSource, 1545407399, 14422, 18617, 141, 198, 36, 75, 241, 7, 191, 140);
RT_INTERFACE!{interface IMediaEnginePlaybackSource(IMediaEnginePlaybackSourceVtbl, IMediaEnginePlaybackSource_Abi): IInspectable(IInspectableVtbl) [IID_IMediaEnginePlaybackSource] {
    fn get_CurrentItem(&self, out: *mut <MediaPlaybackItem as RtType>::Abi) -> HRESULT,
    fn SetPlaybackSource(&self, source: <IMediaPlaybackSource as RtType>::Abi) -> HRESULT
}}
impl IMediaEnginePlaybackSource {
    #[inline] pub fn get_current_item(&self) -> Result<Option<MediaPlaybackItem>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CurrentItem)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackItem::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_playback_source(&self, source: &IMediaPlaybackSource) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetPlaybackSource)(self.0.as_abi() as *const _ as *mut _, get_abi(source) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaItemDisplayProperties, 507255624, 28823, 17284, 162, 23, 193, 41, 29, 250, 140, 22);
RT_INTERFACE!{interface IMediaItemDisplayProperties(IMediaItemDisplayPropertiesVtbl, IMediaItemDisplayProperties_Abi): IInspectable(IInspectableVtbl) [IID_IMediaItemDisplayProperties] {
    fn get_Type(&self, out: *mut super::MediaPlaybackType) -> HRESULT,
    fn put_Type(&self, value: super::MediaPlaybackType) -> HRESULT,
    fn get_MusicProperties(&self, out: *mut <super::MusicDisplayProperties as RtType>::Abi) -> HRESULT,
    fn get_VideoProperties(&self, out: *mut <super::VideoDisplayProperties as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Thumbnail(&self, out: *mut <super::super::storage::streams::RandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Thumbnail(&self, value: <super::super::storage::streams::RandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    fn ClearAll(&self) -> HRESULT
}}
impl IMediaItemDisplayProperties {
    #[inline] pub fn get_type(&self) -> Result<super::MediaPlaybackType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Type)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_type(&self, value: super::MediaPlaybackType) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Type)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_music_properties(&self) -> Result<Option<super::MusicDisplayProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MusicProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::MusicDisplayProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_properties(&self) -> Result<Option<super::VideoDisplayProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::VideoDisplayProperties::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_thumbnail(&self) -> Result<Option<super::super::storage::streams::RandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Thumbnail)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::RandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_thumbnail(&self, value: &super::super::storage::streams::RandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Thumbnail)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn clear_all(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ClearAll)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaItemDisplayProperties: IMediaItemDisplayProperties}
RT_CLASS!{class MediaPlaybackAudioTrackList: foundation::collections::IVectorView<super::core::AudioTrack>}
DEFINE_IID!(IID_IMediaPlaybackCommandManager, 1523508646, 23734, 19034, 133, 33, 204, 134, 177, 193, 237, 55);
RT_INTERFACE!{interface IMediaPlaybackCommandManager(IMediaPlaybackCommandManagerVtbl, IMediaPlaybackCommandManager_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackCommandManager] {
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsEnabled(&self, value: bool) -> HRESULT,
    fn get_MediaPlayer(&self, out: *mut <MediaPlayer as RtType>::Abi) -> HRESULT,
    fn get_PlayBehavior(&self, out: *mut <MediaPlaybackCommandManagerCommandBehavior as RtType>::Abi) -> HRESULT,
    fn get_PauseBehavior(&self, out: *mut <MediaPlaybackCommandManagerCommandBehavior as RtType>::Abi) -> HRESULT,
    fn get_NextBehavior(&self, out: *mut <MediaPlaybackCommandManagerCommandBehavior as RtType>::Abi) -> HRESULT,
    fn get_PreviousBehavior(&self, out: *mut <MediaPlaybackCommandManagerCommandBehavior as RtType>::Abi) -> HRESULT,
    fn get_FastForwardBehavior(&self, out: *mut <MediaPlaybackCommandManagerCommandBehavior as RtType>::Abi) -> HRESULT,
    fn get_RewindBehavior(&self, out: *mut <MediaPlaybackCommandManagerCommandBehavior as RtType>::Abi) -> HRESULT,
    fn get_ShuffleBehavior(&self, out: *mut <MediaPlaybackCommandManagerCommandBehavior as RtType>::Abi) -> HRESULT,
    fn get_AutoRepeatModeBehavior(&self, out: *mut <MediaPlaybackCommandManagerCommandBehavior as RtType>::Abi) -> HRESULT,
    fn get_PositionBehavior(&self, out: *mut <MediaPlaybackCommandManagerCommandBehavior as RtType>::Abi) -> HRESULT,
    fn get_RateBehavior(&self, out: *mut <MediaPlaybackCommandManagerCommandBehavior as RtType>::Abi) -> HRESULT,
    fn add_PlayReceived(&self, handler: <foundation::TypedEventHandler<MediaPlaybackCommandManager, MediaPlaybackCommandManagerPlayReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PlayReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PauseReceived(&self, handler: <foundation::TypedEventHandler<MediaPlaybackCommandManager, MediaPlaybackCommandManagerPauseReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PauseReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_NextReceived(&self, handler: <foundation::TypedEventHandler<MediaPlaybackCommandManager, MediaPlaybackCommandManagerNextReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NextReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PreviousReceived(&self, handler: <foundation::TypedEventHandler<MediaPlaybackCommandManager, MediaPlaybackCommandManagerPreviousReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PreviousReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_FastForwardReceived(&self, handler: <foundation::TypedEventHandler<MediaPlaybackCommandManager, MediaPlaybackCommandManagerFastForwardReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FastForwardReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_RewindReceived(&self, handler: <foundation::TypedEventHandler<MediaPlaybackCommandManager, MediaPlaybackCommandManagerRewindReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RewindReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ShuffleReceived(&self, handler: <foundation::TypedEventHandler<MediaPlaybackCommandManager, MediaPlaybackCommandManagerShuffleReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ShuffleReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_AutoRepeatModeReceived(&self, handler: <foundation::TypedEventHandler<MediaPlaybackCommandManager, MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AutoRepeatModeReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PositionReceived(&self, handler: <foundation::TypedEventHandler<MediaPlaybackCommandManager, MediaPlaybackCommandManagerPositionReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PositionReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_RateReceived(&self, handler: <foundation::TypedEventHandler<MediaPlaybackCommandManager, MediaPlaybackCommandManagerRateReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RateReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IMediaPlaybackCommandManager {
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_media_player(&self) -> Result<Option<MediaPlayer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaPlayer)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlayer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_play_behavior(&self) -> Result<Option<MediaPlaybackCommandManagerCommandBehavior>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlayBehavior)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackCommandManagerCommandBehavior::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_pause_behavior(&self) -> Result<Option<MediaPlaybackCommandManagerCommandBehavior>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PauseBehavior)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackCommandManagerCommandBehavior::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_next_behavior(&self) -> Result<Option<MediaPlaybackCommandManagerCommandBehavior>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_NextBehavior)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackCommandManagerCommandBehavior::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_previous_behavior(&self) -> Result<Option<MediaPlaybackCommandManagerCommandBehavior>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PreviousBehavior)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackCommandManagerCommandBehavior::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_fast_forward_behavior(&self) -> Result<Option<MediaPlaybackCommandManagerCommandBehavior>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FastForwardBehavior)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackCommandManagerCommandBehavior::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_rewind_behavior(&self) -> Result<Option<MediaPlaybackCommandManagerCommandBehavior>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_RewindBehavior)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackCommandManagerCommandBehavior::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_shuffle_behavior(&self) -> Result<Option<MediaPlaybackCommandManagerCommandBehavior>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ShuffleBehavior)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackCommandManagerCommandBehavior::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_repeat_mode_behavior(&self) -> Result<Option<MediaPlaybackCommandManagerCommandBehavior>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutoRepeatModeBehavior)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackCommandManagerCommandBehavior::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_position_behavior(&self) -> Result<Option<MediaPlaybackCommandManagerCommandBehavior>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PositionBehavior)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackCommandManagerCommandBehavior::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_rate_behavior(&self) -> Result<Option<MediaPlaybackCommandManagerCommandBehavior>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_RateBehavior)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackCommandManagerCommandBehavior::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_play_received(&self, handler: &foundation::TypedEventHandler<MediaPlaybackCommandManager, MediaPlaybackCommandManagerPlayReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PlayReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_play_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PlayReceived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pause_received(&self, handler: &foundation::TypedEventHandler<MediaPlaybackCommandManager, MediaPlaybackCommandManagerPauseReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PauseReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pause_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PauseReceived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_next_received(&self, handler: &foundation::TypedEventHandler<MediaPlaybackCommandManager, MediaPlaybackCommandManagerNextReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_NextReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_next_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_NextReceived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_previous_received(&self, handler: &foundation::TypedEventHandler<MediaPlaybackCommandManager, MediaPlaybackCommandManagerPreviousReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PreviousReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_previous_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PreviousReceived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_fast_forward_received(&self, handler: &foundation::TypedEventHandler<MediaPlaybackCommandManager, MediaPlaybackCommandManagerFastForwardReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_FastForwardReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_fast_forward_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_FastForwardReceived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_rewind_received(&self, handler: &foundation::TypedEventHandler<MediaPlaybackCommandManager, MediaPlaybackCommandManagerRewindReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_RewindReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_rewind_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_RewindReceived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_shuffle_received(&self, handler: &foundation::TypedEventHandler<MediaPlaybackCommandManager, MediaPlaybackCommandManagerShuffleReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ShuffleReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_shuffle_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ShuffleReceived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_auto_repeat_mode_received(&self, handler: &foundation::TypedEventHandler<MediaPlaybackCommandManager, MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AutoRepeatModeReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_auto_repeat_mode_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AutoRepeatModeReceived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_position_received(&self, handler: &foundation::TypedEventHandler<MediaPlaybackCommandManager, MediaPlaybackCommandManagerPositionReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PositionReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_position_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PositionReceived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_rate_received(&self, handler: &foundation::TypedEventHandler<MediaPlaybackCommandManager, MediaPlaybackCommandManagerRateReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_RateReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_rate_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_RateReceived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlaybackCommandManager: IMediaPlaybackCommandManager}
DEFINE_IID!(IID_IMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs, 1030704931, 21040, 17425, 160, 233, 186, 217, 76, 42, 4, 92);
RT_INTERFACE!{interface IMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs(IMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgsVtbl, IMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn get_AutoRepeatMode(&self, out: *mut super::MediaPlaybackAutoRepeatMode) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Handled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Handled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_repeat_mode(&self) -> Result<super::MediaPlaybackAutoRepeatMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutoRepeatMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs: IMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs}
DEFINE_IID!(IID_IMediaPlaybackCommandManagerCommandBehavior, 2020351608, 52856, 18960, 175, 214, 132, 63, 203, 185, 12, 46);
RT_INTERFACE!{interface IMediaPlaybackCommandManagerCommandBehavior(IMediaPlaybackCommandManagerCommandBehaviorVtbl, IMediaPlaybackCommandManagerCommandBehavior_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackCommandManagerCommandBehavior] {
    fn get_CommandManager(&self, out: *mut <MediaPlaybackCommandManager as RtType>::Abi) -> HRESULT,
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_EnablingRule(&self, out: *mut MediaCommandEnablingRule) -> HRESULT,
    fn put_EnablingRule(&self, value: MediaCommandEnablingRule) -> HRESULT,
    fn add_IsEnabledChanged(&self, handler: <foundation::TypedEventHandler<MediaPlaybackCommandManagerCommandBehavior, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_IsEnabledChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IMediaPlaybackCommandManagerCommandBehavior {
    #[inline] pub fn get_command_manager(&self) -> Result<Option<MediaPlaybackCommandManager>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CommandManager)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackCommandManager::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_enabling_rule(&self) -> Result<MediaCommandEnablingRule> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_EnablingRule)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_enabling_rule(&self, value: MediaCommandEnablingRule) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_EnablingRule)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_is_enabled_changed(&self, handler: &foundation::TypedEventHandler<MediaPlaybackCommandManagerCommandBehavior, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_IsEnabledChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_is_enabled_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_IsEnabledChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlaybackCommandManagerCommandBehavior: IMediaPlaybackCommandManagerCommandBehavior}
DEFINE_IID!(IID_IMediaPlaybackCommandManagerFastForwardReceivedEventArgs, 821060825, 46225, 19722, 188, 33, 48, 152, 189, 19, 50, 233);
RT_INTERFACE!{interface IMediaPlaybackCommandManagerFastForwardReceivedEventArgs(IMediaPlaybackCommandManagerFastForwardReceivedEventArgsVtbl, IMediaPlaybackCommandManagerFastForwardReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackCommandManagerFastForwardReceivedEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IMediaPlaybackCommandManagerFastForwardReceivedEventArgs {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Handled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Handled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlaybackCommandManagerFastForwardReceivedEventArgs: IMediaPlaybackCommandManagerFastForwardReceivedEventArgs}
DEFINE_IID!(IID_IMediaPlaybackCommandManagerNextReceivedEventArgs, 3780133939, 41648, 17876, 185, 222, 95, 66, 172, 20, 168, 57);
RT_INTERFACE!{interface IMediaPlaybackCommandManagerNextReceivedEventArgs(IMediaPlaybackCommandManagerNextReceivedEventArgsVtbl, IMediaPlaybackCommandManagerNextReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackCommandManagerNextReceivedEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IMediaPlaybackCommandManagerNextReceivedEventArgs {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Handled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Handled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlaybackCommandManagerNextReceivedEventArgs: IMediaPlaybackCommandManagerNextReceivedEventArgs}
DEFINE_IID!(IID_IMediaPlaybackCommandManagerPauseReceivedEventArgs, 1559022876, 49756, 16929, 177, 108, 195, 201, 140, 224, 18, 214);
RT_INTERFACE!{interface IMediaPlaybackCommandManagerPauseReceivedEventArgs(IMediaPlaybackCommandManagerPauseReceivedEventArgsVtbl, IMediaPlaybackCommandManagerPauseReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackCommandManagerPauseReceivedEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IMediaPlaybackCommandManagerPauseReceivedEventArgs {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Handled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Handled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlaybackCommandManagerPauseReceivedEventArgs: IMediaPlaybackCommandManagerPauseReceivedEventArgs}
DEFINE_IID!(IID_IMediaPlaybackCommandManagerPlayReceivedEventArgs, 2599419982, 22411, 19542, 160, 6, 22, 21, 157, 136, 138, 72);
RT_INTERFACE!{interface IMediaPlaybackCommandManagerPlayReceivedEventArgs(IMediaPlaybackCommandManagerPlayReceivedEventArgsVtbl, IMediaPlaybackCommandManagerPlayReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackCommandManagerPlayReceivedEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IMediaPlaybackCommandManagerPlayReceivedEventArgs {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Handled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Handled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlaybackCommandManagerPlayReceivedEventArgs: IMediaPlaybackCommandManagerPlayReceivedEventArgs}
DEFINE_IID!(IID_IMediaPlaybackCommandManagerPositionReceivedEventArgs, 1435608916, 54823, 19421, 169, 13, 134, 160, 21, 178, 73, 2);
RT_INTERFACE!{interface IMediaPlaybackCommandManagerPositionReceivedEventArgs(IMediaPlaybackCommandManagerPositionReceivedEventArgsVtbl, IMediaPlaybackCommandManagerPositionReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackCommandManagerPositionReceivedEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IMediaPlaybackCommandManagerPositionReceivedEventArgs {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Handled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Handled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlaybackCommandManagerPositionReceivedEventArgs: IMediaPlaybackCommandManagerPositionReceivedEventArgs}
DEFINE_IID!(IID_IMediaPlaybackCommandManagerPreviousReceivedEventArgs, 1381904513, 17970, 20342, 153, 177, 215, 113, 98, 63, 98, 135);
RT_INTERFACE!{interface IMediaPlaybackCommandManagerPreviousReceivedEventArgs(IMediaPlaybackCommandManagerPreviousReceivedEventArgsVtbl, IMediaPlaybackCommandManagerPreviousReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackCommandManagerPreviousReceivedEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IMediaPlaybackCommandManagerPreviousReceivedEventArgs {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Handled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Handled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlaybackCommandManagerPreviousReceivedEventArgs: IMediaPlaybackCommandManagerPreviousReceivedEventArgs}
DEFINE_IID!(IID_IMediaPlaybackCommandManagerRateReceivedEventArgs, 418003257, 18966, 16745, 139, 5, 62, 185, 245, 255, 120, 235);
RT_INTERFACE!{interface IMediaPlaybackCommandManagerRateReceivedEventArgs(IMediaPlaybackCommandManagerRateReceivedEventArgsVtbl, IMediaPlaybackCommandManagerRateReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackCommandManagerRateReceivedEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn get_PlaybackRate(&self, out: *mut f64) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IMediaPlaybackCommandManagerRateReceivedEventArgs {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Handled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Handled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_playback_rate(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlaybackCommandManagerRateReceivedEventArgs: IMediaPlaybackCommandManagerRateReceivedEventArgs}
DEFINE_IID!(IID_IMediaPlaybackCommandManagerRewindReceivedEventArgs, 2668124487, 41920, 16989, 170, 239, 151, 186, 120, 152, 177, 65);
RT_INTERFACE!{interface IMediaPlaybackCommandManagerRewindReceivedEventArgs(IMediaPlaybackCommandManagerRewindReceivedEventArgsVtbl, IMediaPlaybackCommandManagerRewindReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackCommandManagerRewindReceivedEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IMediaPlaybackCommandManagerRewindReceivedEventArgs {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Handled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Handled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlaybackCommandManagerRewindReceivedEventArgs: IMediaPlaybackCommandManagerRewindReceivedEventArgs}
DEFINE_IID!(IID_IMediaPlaybackCommandManagerShuffleReceivedEventArgs, 1352686831, 25582, 19094, 183, 181, 254, 224, 139, 159, 249, 12);
RT_INTERFACE!{interface IMediaPlaybackCommandManagerShuffleReceivedEventArgs(IMediaPlaybackCommandManagerShuffleReceivedEventArgsVtbl, IMediaPlaybackCommandManagerShuffleReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackCommandManagerShuffleReceivedEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn get_IsShuffleRequested(&self, out: *mut bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IMediaPlaybackCommandManagerShuffleReceivedEventArgs {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Handled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Handled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_shuffle_requested(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsShuffleRequested)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlaybackCommandManagerShuffleReceivedEventArgs: IMediaPlaybackCommandManagerShuffleReceivedEventArgs}
DEFINE_IID!(IID_IMediaPlaybackItem, 74487762, 58543, 18603, 178, 131, 105, 41, 230, 116, 236, 226);
RT_INTERFACE!{interface IMediaPlaybackItem(IMediaPlaybackItemVtbl, IMediaPlaybackItem_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackItem] {
    fn add_AudioTracksChanged(&self, handler: <foundation::TypedEventHandler<MediaPlaybackItem, foundation::collections::IVectorChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AudioTracksChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_VideoTracksChanged(&self, handler: <foundation::TypedEventHandler<MediaPlaybackItem, foundation::collections::IVectorChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VideoTracksChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_TimedMetadataTracksChanged(&self, handler: <foundation::TypedEventHandler<MediaPlaybackItem, foundation::collections::IVectorChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TimedMetadataTracksChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Source(&self, out: *mut <super::core::MediaSource as RtType>::Abi) -> HRESULT,
    fn get_AudioTracks(&self, out: *mut <MediaPlaybackAudioTrackList as RtType>::Abi) -> HRESULT,
    fn get_VideoTracks(&self, out: *mut <MediaPlaybackVideoTrackList as RtType>::Abi) -> HRESULT,
    fn get_TimedMetadataTracks(&self, out: *mut <MediaPlaybackTimedMetadataTrackList as RtType>::Abi) -> HRESULT
}}
impl IMediaPlaybackItem {
    #[inline] pub fn add_audio_tracks_changed(&self, handler: &foundation::TypedEventHandler<MediaPlaybackItem, foundation::collections::IVectorChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AudioTracksChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_audio_tracks_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AudioTracksChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_video_tracks_changed(&self, handler: &foundation::TypedEventHandler<MediaPlaybackItem, foundation::collections::IVectorChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_VideoTracksChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_video_tracks_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_VideoTracksChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_timed_metadata_tracks_changed(&self, handler: &foundation::TypedEventHandler<MediaPlaybackItem, foundation::collections::IVectorChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_TimedMetadataTracksChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_timed_metadata_tracks_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_TimedMetadataTracksChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_source(&self) -> Result<Option<super::core::MediaSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Source)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::core::MediaSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_tracks(&self) -> Result<Option<MediaPlaybackAudioTrackList>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioTracks)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackAudioTrackList::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_tracks(&self) -> Result<Option<MediaPlaybackVideoTrackList>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoTracks)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackVideoTrackList::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_timed_metadata_tracks(&self) -> Result<Option<MediaPlaybackTimedMetadataTrackList>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TimedMetadataTracks)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackTimedMetadataTrackList::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlaybackItem: IMediaPlaybackItem}
impl RtActivatable<IMediaPlaybackItemFactory> for MediaPlaybackItem {}
impl RtActivatable<IMediaPlaybackItemFactory2> for MediaPlaybackItem {}
impl RtActivatable<IMediaPlaybackItemStatics> for MediaPlaybackItem {}
impl MediaPlaybackItem {
    #[inline] pub fn create(source: &super::core::MediaSource) -> Result<MediaPlaybackItem> {
        <Self as RtActivatable<IMediaPlaybackItemFactory>>::get_activation_factory().create(source)
    }
    #[inline] pub fn create_with_start_time(source: &super::core::MediaSource, startTime: foundation::TimeSpan) -> Result<MediaPlaybackItem> {
        <Self as RtActivatable<IMediaPlaybackItemFactory2>>::get_activation_factory().create_with_start_time(source, startTime)
    }
    #[inline] pub fn create_with_start_time_and_duration_limit(source: &super::core::MediaSource, startTime: foundation::TimeSpan, durationLimit: foundation::TimeSpan) -> Result<MediaPlaybackItem> {
        <Self as RtActivatable<IMediaPlaybackItemFactory2>>::get_activation_factory().create_with_start_time_and_duration_limit(source, startTime, durationLimit)
    }
    #[inline] pub fn find_from_media_source(source: &super::core::MediaSource) -> Result<Option<MediaPlaybackItem>> {
        <Self as RtActivatable<IMediaPlaybackItemStatics>>::get_activation_factory().find_from_media_source(source)
    }
}
DEFINE_CLSID!(MediaPlaybackItem(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,108,97,121,98,97,99,107,46,77,101,100,105,97,80,108,97,121,98,97,99,107,73,116,101,109,0]) [CLSID_MediaPlaybackItem]);
DEFINE_IID!(IID_IMediaPlaybackItem2, 3629764977, 55279, 19329, 172, 31, 244, 4, 147, 203, 176, 145);
RT_INTERFACE!{interface IMediaPlaybackItem2(IMediaPlaybackItem2Vtbl, IMediaPlaybackItem2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackItem2] {
    fn get_BreakSchedule(&self, out: *mut <MediaBreakSchedule as RtType>::Abi) -> HRESULT,
    fn get_StartTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_DurationLimit(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_CanSkip(&self, out: *mut bool) -> HRESULT,
    fn put_CanSkip(&self, value: bool) -> HRESULT,
    fn GetDisplayProperties(&self, out: *mut <MediaItemDisplayProperties as RtType>::Abi) -> HRESULT,
    fn ApplyDisplayProperties(&self, value: <MediaItemDisplayProperties as RtType>::Abi) -> HRESULT
}}
impl IMediaPlaybackItem2 {
    #[inline] pub fn get_break_schedule(&self) -> Result<Option<MediaBreakSchedule>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BreakSchedule)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaBreakSchedule::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_start_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StartTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_duration_limit(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DurationLimit)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_can_skip(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanSkip)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_can_skip(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CanSkip)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_display_properties(&self) -> Result<Option<MediaItemDisplayProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDisplayProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaItemDisplayProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn apply_display_properties(&self, value: &MediaItemDisplayProperties) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ApplyDisplayProperties)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaPlaybackItem3, 221413920, 47114, 19721, 159, 248, 248, 112, 148, 161, 200, 49);
RT_INTERFACE!{interface IMediaPlaybackItem3(IMediaPlaybackItem3Vtbl, IMediaPlaybackItem3_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackItem3] {
    fn get_IsDisabledInPlaybackList(&self, out: *mut bool) -> HRESULT,
    fn put_IsDisabledInPlaybackList(&self, value: bool) -> HRESULT,
    fn get_TotalDownloadProgress(&self, out: *mut f64) -> HRESULT,
    fn get_AutoLoadedDisplayProperties(&self, out: *mut AutoLoadedDisplayPropertyKind) -> HRESULT,
    fn put_AutoLoadedDisplayProperties(&self, value: AutoLoadedDisplayPropertyKind) -> HRESULT
}}
impl IMediaPlaybackItem3 {
    #[inline] pub fn get_is_disabled_in_playback_list(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDisabledInPlaybackList)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_disabled_in_playback_list(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsDisabledInPlaybackList)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_total_download_progress(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TotalDownloadProgress)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_loaded_display_properties(&self) -> Result<AutoLoadedDisplayPropertyKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutoLoadedDisplayProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto_loaded_display_properties(&self, value: AutoLoadedDisplayPropertyKind) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AutoLoadedDisplayProperties)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum MediaPlaybackItemChangedReason: i32 {
    InitialItem = 0, EndOfStream = 1, Error = 2, AppRequested = 3,
}}
DEFINE_IID!(IID_IMediaPlaybackItemError, 1778118443, 56534, 19961, 164, 80, 219, 244, 198, 241, 194, 194);
RT_INTERFACE!{interface IMediaPlaybackItemError(IMediaPlaybackItemErrorVtbl, IMediaPlaybackItemError_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackItemError] {
    fn get_ErrorCode(&self, out: *mut MediaPlaybackItemErrorCode) -> HRESULT,
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl IMediaPlaybackItemError {
    #[inline] pub fn get_error_code(&self) -> Result<MediaPlaybackItemErrorCode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ErrorCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlaybackItemError: IMediaPlaybackItemError}
RT_ENUM! { enum MediaPlaybackItemErrorCode: i32 {
    None = 0, Aborted = 1, NetworkError = 2, DecodeError = 3, SourceNotSupportedError = 4, EncryptionError = 5,
}}
DEFINE_IID!(IID_IMediaPlaybackItemFactory, 1899232481, 5993, 20473, 167, 193, 56, 210, 196, 212, 35, 96);
RT_INTERFACE!{static interface IMediaPlaybackItemFactory(IMediaPlaybackItemFactoryVtbl, IMediaPlaybackItemFactory_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackItemFactory] {
    fn Create(&self, source: <super::core::MediaSource as RtType>::Abi, out: *mut <MediaPlaybackItem as RtType>::Abi) -> HRESULT
}}
impl IMediaPlaybackItemFactory {
    #[inline] pub fn create(&self, source: &super::core::MediaSource) -> Result<MediaPlaybackItem> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(source) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackItem::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaPlaybackItemFactory2, 3615285050, 47431, 18802, 179, 93, 173, 251, 147, 26, 113, 230);
RT_INTERFACE!{static interface IMediaPlaybackItemFactory2(IMediaPlaybackItemFactory2Vtbl, IMediaPlaybackItemFactory2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackItemFactory2] {
    fn CreateWithStartTime(&self, source: <super::core::MediaSource as RtType>::Abi, startTime: foundation::TimeSpan, out: *mut <MediaPlaybackItem as RtType>::Abi) -> HRESULT,
    fn CreateWithStartTimeAndDurationLimit(&self, source: <super::core::MediaSource as RtType>::Abi, startTime: foundation::TimeSpan, durationLimit: foundation::TimeSpan, out: *mut <MediaPlaybackItem as RtType>::Abi) -> HRESULT
}}
impl IMediaPlaybackItemFactory2 {
    #[inline] pub fn create_with_start_time(&self, source: &super::core::MediaSource, startTime: foundation::TimeSpan) -> Result<MediaPlaybackItem> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithStartTime)(self.0.as_abi() as *const _ as *mut _, get_abi(source) as *const _ as *mut _, startTime, &mut out);
        if hr == S_OK { Ok(MediaPlaybackItem::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_start_time_and_duration_limit(&self, source: &super::core::MediaSource, startTime: foundation::TimeSpan, durationLimit: foundation::TimeSpan) -> Result<MediaPlaybackItem> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithStartTimeAndDurationLimit)(self.0.as_abi() as *const _ as *mut _, get_abi(source) as *const _ as *mut _, startTime, durationLimit, &mut out);
        if hr == S_OK { Ok(MediaPlaybackItem::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaPlaybackItemFailedEventArgs, 1996690250, 59815, 18371, 134, 44, 198, 86, 211, 6, 131, 212);
RT_INTERFACE!{interface IMediaPlaybackItemFailedEventArgs(IMediaPlaybackItemFailedEventArgsVtbl, IMediaPlaybackItemFailedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackItemFailedEventArgs] {
    fn get_Item(&self, out: *mut <MediaPlaybackItem as RtType>::Abi) -> HRESULT,
    fn get_Error(&self, out: *mut <MediaPlaybackItemError as RtType>::Abi) -> HRESULT
}}
impl IMediaPlaybackItemFailedEventArgs {
    #[inline] pub fn get_item(&self) -> Result<Option<MediaPlaybackItem>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Item)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackItem::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_error(&self) -> Result<Option<MediaPlaybackItemError>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Error)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackItemError::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlaybackItemFailedEventArgs: IMediaPlaybackItemFailedEventArgs}
DEFINE_IID!(IID_IMediaPlaybackItemOpenedEventArgs, 3420044674, 12343, 20414, 174, 143, 57, 252, 57, 237, 244, 239);
RT_INTERFACE!{interface IMediaPlaybackItemOpenedEventArgs(IMediaPlaybackItemOpenedEventArgsVtbl, IMediaPlaybackItemOpenedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackItemOpenedEventArgs] {
    fn get_Item(&self, out: *mut <MediaPlaybackItem as RtType>::Abi) -> HRESULT
}}
impl IMediaPlaybackItemOpenedEventArgs {
    #[inline] pub fn get_item(&self) -> Result<Option<MediaPlaybackItem>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Item)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackItem::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlaybackItemOpenedEventArgs: IMediaPlaybackItemOpenedEventArgs}
DEFINE_IID!(IID_IMediaPlaybackItemStatics, 1260120052, 17221, 16444, 138, 103, 245, 222, 145, 223, 76, 134);
RT_INTERFACE!{static interface IMediaPlaybackItemStatics(IMediaPlaybackItemStaticsVtbl, IMediaPlaybackItemStatics_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackItemStatics] {
    fn FindFromMediaSource(&self, source: <super::core::MediaSource as RtType>::Abi, out: *mut <MediaPlaybackItem as RtType>::Abi) -> HRESULT
}}
impl IMediaPlaybackItemStatics {
    #[inline] pub fn find_from_media_source(&self, source: &super::core::MediaSource) -> Result<Option<MediaPlaybackItem>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindFromMediaSource)(self.0.as_abi() as *const _ as *mut _, get_abi(source) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackItem::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaPlaybackList, 2138566300, 56386, 20006, 169, 141, 120, 80, 223, 142, 201, 37);
RT_INTERFACE!{interface IMediaPlaybackList(IMediaPlaybackListVtbl, IMediaPlaybackList_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackList] {
    fn add_ItemFailed(&self, handler: <foundation::TypedEventHandler<MediaPlaybackList, MediaPlaybackItemFailedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ItemFailed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CurrentItemChanged(&self, handler: <foundation::TypedEventHandler<MediaPlaybackList, CurrentMediaPlaybackItemChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CurrentItemChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ItemOpened(&self, handler: <foundation::TypedEventHandler<MediaPlaybackList, MediaPlaybackItemOpenedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ItemOpened(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Items(&self, out: *mut <foundation::collections::IObservableVector<MediaPlaybackItem> as RtType>::Abi) -> HRESULT,
    fn get_AutoRepeatEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_AutoRepeatEnabled(&self, value: bool) -> HRESULT,
    fn get_ShuffleEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_ShuffleEnabled(&self, value: bool) -> HRESULT,
    fn get_CurrentItem(&self, out: *mut <MediaPlaybackItem as RtType>::Abi) -> HRESULT,
    fn get_CurrentItemIndex(&self, out: *mut u32) -> HRESULT,
    fn MoveNext(&self, out: *mut <MediaPlaybackItem as RtType>::Abi) -> HRESULT,
    fn MovePrevious(&self, out: *mut <MediaPlaybackItem as RtType>::Abi) -> HRESULT,
    fn MoveTo(&self, itemIndex: u32, out: *mut <MediaPlaybackItem as RtType>::Abi) -> HRESULT
}}
impl IMediaPlaybackList {
    #[inline] pub fn add_item_failed(&self, handler: &foundation::TypedEventHandler<MediaPlaybackList, MediaPlaybackItemFailedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ItemFailed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_item_failed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ItemFailed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_current_item_changed(&self, handler: &foundation::TypedEventHandler<MediaPlaybackList, CurrentMediaPlaybackItemChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_CurrentItemChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_current_item_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_CurrentItemChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_item_opened(&self, handler: &foundation::TypedEventHandler<MediaPlaybackList, MediaPlaybackItemOpenedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ItemOpened)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_item_opened(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ItemOpened)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_items(&self) -> Result<Option<foundation::collections::IObservableVector<MediaPlaybackItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Items)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IObservableVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_repeat_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutoRepeatEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto_repeat_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AutoRepeatEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_shuffle_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ShuffleEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_shuffle_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ShuffleEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_current_item(&self) -> Result<Option<MediaPlaybackItem>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CurrentItem)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackItem::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_current_item_index(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CurrentItemIndex)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn move_next(&self) -> Result<Option<MediaPlaybackItem>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).MoveNext)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackItem::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn move_previous(&self) -> Result<Option<MediaPlaybackItem>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).MovePrevious)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackItem::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn move_to(&self, itemIndex: u32) -> Result<Option<MediaPlaybackItem>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).MoveTo)(self.0.as_abi() as *const _ as *mut _, itemIndex, &mut out);
        if hr == S_OK { Ok(MediaPlaybackItem::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlaybackList: IMediaPlaybackList}
impl RtActivatable<IActivationFactory> for MediaPlaybackList {}
DEFINE_CLSID!(MediaPlaybackList(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,108,97,121,98,97,99,107,46,77,101,100,105,97,80,108,97,121,98,97,99,107,76,105,115,116,0]) [CLSID_MediaPlaybackList]);
DEFINE_IID!(IID_IMediaPlaybackList2, 235517048, 24586, 17012, 161, 75, 11, 103, 35, 208, 244, 139);
RT_INTERFACE!{interface IMediaPlaybackList2(IMediaPlaybackList2Vtbl, IMediaPlaybackList2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackList2] {
    fn get_MaxPrefetchTime(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn put_MaxPrefetchTime(&self, value: <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_StartingItem(&self, out: *mut <MediaPlaybackItem as RtType>::Abi) -> HRESULT,
    fn put_StartingItem(&self, value: <MediaPlaybackItem as RtType>::Abi) -> HRESULT,
    fn get_ShuffledItems(&self, out: *mut <foundation::collections::IVectorView<MediaPlaybackItem> as RtType>::Abi) -> HRESULT,
    fn SetShuffledItems(&self, value: <foundation::collections::IIterable<MediaPlaybackItem> as RtType>::Abi) -> HRESULT
}}
impl IMediaPlaybackList2 {
    #[inline] pub fn get_max_prefetch_time(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxPrefetchTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_prefetch_time(&self, value: &foundation::IReference<foundation::TimeSpan>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MaxPrefetchTime)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_starting_item(&self) -> Result<Option<MediaPlaybackItem>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_StartingItem)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackItem::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_starting_item(&self, value: &MediaPlaybackItem) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_StartingItem)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_shuffled_items(&self) -> Result<Option<foundation::collections::IVectorView<MediaPlaybackItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ShuffledItems)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_shuffled_items(&self, value: &foundation::collections::IIterable<MediaPlaybackItem>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetShuffledItems)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaPlaybackList3, 3710172073, 48199, 17507, 170, 144, 193, 139, 126, 95, 253, 225);
RT_INTERFACE!{interface IMediaPlaybackList3(IMediaPlaybackList3Vtbl, IMediaPlaybackList3_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackList3] {
    fn get_MaxPlayedItemsToKeepOpen(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn put_MaxPlayedItemsToKeepOpen(&self, value: <foundation::IReference<u32> as RtType>::Abi) -> HRESULT
}}
impl IMediaPlaybackList3 {
    #[inline] pub fn get_max_played_items_to_keep_open(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxPlayedItemsToKeepOpen)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_max_played_items_to_keep_open(&self, value: &foundation::IReference<u32>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MaxPlayedItemsToKeepOpen)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaPlaybackSession, 3274401853, 1031, 16826, 137, 70, 139, 52, 90, 90, 84, 53);
RT_INTERFACE!{interface IMediaPlaybackSession(IMediaPlaybackSessionVtbl, IMediaPlaybackSession_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackSession] {
    fn add_PlaybackStateChanged(&self, value: <foundation::TypedEventHandler<MediaPlaybackSession, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PlaybackStateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PlaybackRateChanged(&self, value: <foundation::TypedEventHandler<MediaPlaybackSession, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PlaybackRateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SeekCompleted(&self, value: <foundation::TypedEventHandler<MediaPlaybackSession, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SeekCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_BufferingStarted(&self, value: <foundation::TypedEventHandler<MediaPlaybackSession, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BufferingStarted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_BufferingEnded(&self, value: <foundation::TypedEventHandler<MediaPlaybackSession, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BufferingEnded(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_BufferingProgressChanged(&self, value: <foundation::TypedEventHandler<MediaPlaybackSession, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BufferingProgressChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_DownloadProgressChanged(&self, value: <foundation::TypedEventHandler<MediaPlaybackSession, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DownloadProgressChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_NaturalDurationChanged(&self, value: <foundation::TypedEventHandler<MediaPlaybackSession, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NaturalDurationChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PositionChanged(&self, value: <foundation::TypedEventHandler<MediaPlaybackSession, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PositionChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_NaturalVideoSizeChanged(&self, value: <foundation::TypedEventHandler<MediaPlaybackSession, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NaturalVideoSizeChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_MediaPlayer(&self, out: *mut <MediaPlayer as RtType>::Abi) -> HRESULT,
    fn get_NaturalDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_Position(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_PlaybackState(&self, out: *mut MediaPlaybackState) -> HRESULT,
    fn get_CanSeek(&self, out: *mut bool) -> HRESULT,
    fn get_CanPause(&self, out: *mut bool) -> HRESULT,
    fn get_IsProtected(&self, out: *mut bool) -> HRESULT,
    fn get_PlaybackRate(&self, out: *mut f64) -> HRESULT,
    fn put_PlaybackRate(&self, value: f64) -> HRESULT,
    fn get_BufferingProgress(&self, out: *mut f64) -> HRESULT,
    fn get_DownloadProgress(&self, out: *mut f64) -> HRESULT,
    fn get_NaturalVideoHeight(&self, out: *mut u32) -> HRESULT,
    fn get_NaturalVideoWidth(&self, out: *mut u32) -> HRESULT,
    fn get_NormalizedSourceRect(&self, out: *mut foundation::Rect) -> HRESULT,
    fn put_NormalizedSourceRect(&self, value: foundation::Rect) -> HRESULT,
    fn get_StereoscopicVideoPackingMode(&self, out: *mut super::mediaproperties::StereoscopicVideoPackingMode) -> HRESULT,
    fn put_StereoscopicVideoPackingMode(&self, value: super::mediaproperties::StereoscopicVideoPackingMode) -> HRESULT
}}
impl IMediaPlaybackSession {
    #[inline] pub fn add_playback_state_changed(&self, value: &foundation::TypedEventHandler<MediaPlaybackSession, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PlaybackStateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_playback_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PlaybackStateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_playback_rate_changed(&self, value: &foundation::TypedEventHandler<MediaPlaybackSession, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PlaybackRateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_playback_rate_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PlaybackRateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_seek_completed(&self, value: &foundation::TypedEventHandler<MediaPlaybackSession, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SeekCompleted)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_seek_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SeekCompleted)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_buffering_started(&self, value: &foundation::TypedEventHandler<MediaPlaybackSession, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_BufferingStarted)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_buffering_started(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_BufferingStarted)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_buffering_ended(&self, value: &foundation::TypedEventHandler<MediaPlaybackSession, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_BufferingEnded)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_buffering_ended(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_BufferingEnded)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_buffering_progress_changed(&self, value: &foundation::TypedEventHandler<MediaPlaybackSession, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_BufferingProgressChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_buffering_progress_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_BufferingProgressChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_download_progress_changed(&self, value: &foundation::TypedEventHandler<MediaPlaybackSession, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_DownloadProgressChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_download_progress_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_DownloadProgressChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_natural_duration_changed(&self, value: &foundation::TypedEventHandler<MediaPlaybackSession, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_NaturalDurationChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_natural_duration_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_NaturalDurationChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_position_changed(&self, value: &foundation::TypedEventHandler<MediaPlaybackSession, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PositionChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_position_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PositionChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_natural_video_size_changed(&self, value: &foundation::TypedEventHandler<MediaPlaybackSession, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_NaturalVideoSizeChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_natural_video_size_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_NaturalVideoSizeChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_media_player(&self) -> Result<Option<MediaPlayer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaPlayer)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlayer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_natural_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_NaturalDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_position(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Position)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_playback_state(&self) -> Result<MediaPlaybackState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_seek(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanSeek)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_pause(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanPause)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_protected(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsProtected)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_playback_rate(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_playback_rate(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PlaybackRate)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_buffering_progress(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BufferingProgress)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_download_progress(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DownloadProgress)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_natural_video_height(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_NaturalVideoHeight)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_natural_video_width(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_NaturalVideoWidth)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_normalized_source_rect(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_NormalizedSourceRect)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_normalized_source_rect(&self, value: foundation::Rect) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_NormalizedSourceRect)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_stereoscopic_video_packing_mode(&self) -> Result<super::mediaproperties::StereoscopicVideoPackingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StereoscopicVideoPackingMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_stereoscopic_video_packing_mode(&self, value: super::mediaproperties::StereoscopicVideoPackingMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_StereoscopicVideoPackingMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlaybackSession: IMediaPlaybackSession}
DEFINE_IID!(IID_IMediaPlaybackSession2, 4172971129, 8136, 16535, 173, 112, 192, 250, 24, 204, 0, 80);
RT_INTERFACE!{interface IMediaPlaybackSession2(IMediaPlaybackSession2Vtbl, IMediaPlaybackSession2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackSession2] {
    fn add_BufferedRangesChanged(&self, value: <foundation::TypedEventHandler<MediaPlaybackSession, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BufferedRangesChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PlayedRangesChanged(&self, value: <foundation::TypedEventHandler<MediaPlaybackSession, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PlayedRangesChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SeekableRangesChanged(&self, value: <foundation::TypedEventHandler<MediaPlaybackSession, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SeekableRangesChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SupportedPlaybackRatesChanged(&self, value: <foundation::TypedEventHandler<MediaPlaybackSession, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SupportedPlaybackRatesChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_SphericalVideoProjection(&self, out: *mut <MediaPlaybackSphericalVideoProjection as RtType>::Abi) -> HRESULT,
    fn get_IsMirroring(&self, out: *mut bool) -> HRESULT,
    fn put_IsMirroring(&self, value: bool) -> HRESULT,
    fn GetBufferedRanges(&self, out: *mut <foundation::collections::IVectorView<super::MediaTimeRange> as RtType>::Abi) -> HRESULT,
    fn GetPlayedRanges(&self, out: *mut <foundation::collections::IVectorView<super::MediaTimeRange> as RtType>::Abi) -> HRESULT,
    fn GetSeekableRanges(&self, out: *mut <foundation::collections::IVectorView<super::MediaTimeRange> as RtType>::Abi) -> HRESULT,
    fn IsSupportedPlaybackRateRange(&self, rate1: f64, rate2: f64, out: *mut bool) -> HRESULT
}}
impl IMediaPlaybackSession2 {
    #[inline] pub fn add_buffered_ranges_changed(&self, value: &foundation::TypedEventHandler<MediaPlaybackSession, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_BufferedRangesChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_buffered_ranges_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_BufferedRangesChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_played_ranges_changed(&self, value: &foundation::TypedEventHandler<MediaPlaybackSession, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PlayedRangesChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_played_ranges_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PlayedRangesChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_seekable_ranges_changed(&self, value: &foundation::TypedEventHandler<MediaPlaybackSession, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SeekableRangesChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_seekable_ranges_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SeekableRangesChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_supported_playback_rates_changed(&self, value: &foundation::TypedEventHandler<MediaPlaybackSession, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SupportedPlaybackRatesChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_supported_playback_rates_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SupportedPlaybackRatesChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_spherical_video_projection(&self) -> Result<Option<MediaPlaybackSphericalVideoProjection>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SphericalVideoProjection)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackSphericalVideoProjection::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_mirroring(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsMirroring)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_mirroring(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsMirroring)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_buffered_ranges(&self) -> Result<Option<foundation::collections::IVectorView<super::MediaTimeRange>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetBufferedRanges)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_played_ranges(&self) -> Result<Option<foundation::collections::IVectorView<super::MediaTimeRange>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetPlayedRanges)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_seekable_ranges(&self) -> Result<Option<foundation::collections::IVectorView<super::MediaTimeRange>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetSeekableRanges)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_supported_playback_rate_range(&self, rate1: f64, rate2: f64) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsSupportedPlaybackRateRange)(self.0.as_abi() as *const _ as *mut _, rate1, rate2, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaPlaybackSession3, 2074260506, 41954, 16479, 183, 123, 164, 129, 44, 35, 139, 102);
RT_INTERFACE!{interface IMediaPlaybackSession3(IMediaPlaybackSession3Vtbl, IMediaPlaybackSession3_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackSession3] {
    fn get_PlaybackRotation(&self, out: *mut super::mediaproperties::MediaRotation) -> HRESULT,
    fn put_PlaybackRotation(&self, value: super::mediaproperties::MediaRotation) -> HRESULT,
    fn GetOutputDegradationPolicyState(&self, out: *mut <MediaPlaybackSessionOutputDegradationPolicyState as RtType>::Abi) -> HRESULT
}}
impl IMediaPlaybackSession3 {
    #[inline] pub fn get_playback_rotation(&self) -> Result<super::mediaproperties::MediaRotation> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackRotation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_playback_rotation(&self, value: super::mediaproperties::MediaRotation) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PlaybackRotation)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_output_degradation_policy_state(&self) -> Result<Option<MediaPlaybackSessionOutputDegradationPolicyState>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetOutputDegradationPolicyState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackSessionOutputDegradationPolicyState::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaPlaybackSessionBufferingStartedEventArgs, 3446321133, 29922, 17333, 177, 21, 118, 35, 108, 51, 121, 26);
RT_INTERFACE!{interface IMediaPlaybackSessionBufferingStartedEventArgs(IMediaPlaybackSessionBufferingStartedEventArgsVtbl, IMediaPlaybackSessionBufferingStartedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackSessionBufferingStartedEventArgs] {
    fn get_IsPlaybackInterruption(&self, out: *mut bool) -> HRESULT
}}
impl IMediaPlaybackSessionBufferingStartedEventArgs {
    #[inline] pub fn get_is_playback_interruption(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPlaybackInterruption)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlaybackSessionBufferingStartedEventArgs: IMediaPlaybackSessionBufferingStartedEventArgs}
DEFINE_IID!(IID_IMediaPlaybackSessionOutputDegradationPolicyState, 1435398781, 63027, 18937, 150, 90, 171, 170, 29, 183, 9, 190);
RT_INTERFACE!{interface IMediaPlaybackSessionOutputDegradationPolicyState(IMediaPlaybackSessionOutputDegradationPolicyStateVtbl, IMediaPlaybackSessionOutputDegradationPolicyState_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackSessionOutputDegradationPolicyState] {
    fn get_VideoConstrictionReason(&self, out: *mut MediaPlaybackSessionVideoConstrictionReason) -> HRESULT
}}
impl IMediaPlaybackSessionOutputDegradationPolicyState {
    #[inline] pub fn get_video_constriction_reason(&self) -> Result<MediaPlaybackSessionVideoConstrictionReason> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoConstrictionReason)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlaybackSessionOutputDegradationPolicyState: IMediaPlaybackSessionOutputDegradationPolicyState}
RT_ENUM! { enum MediaPlaybackSessionVideoConstrictionReason: i32 {
    None = 0, VirtualMachine = 1, UnsupportedDisplayAdapter = 2, UnsignedDriver = 3, FrameServerEnabled = 4, OutputProtectionFailed = 5, Unknown = 6,
}}
DEFINE_IID!(IID_IMediaPlaybackSource, 4020093628, 37655, 18070, 176, 81, 43, 173, 100, 49, 119, 181);
RT_INTERFACE!{interface IMediaPlaybackSource(IMediaPlaybackSourceVtbl, IMediaPlaybackSource_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackSource] {
    
}}
DEFINE_IID!(IID_IMediaPlaybackSphericalVideoProjection, 3557143420, 28430, 18017, 184, 238, 212, 135, 186, 151, 82, 213);
RT_INTERFACE!{interface IMediaPlaybackSphericalVideoProjection(IMediaPlaybackSphericalVideoProjectionVtbl, IMediaPlaybackSphericalVideoProjection_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackSphericalVideoProjection] {
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsEnabled(&self, value: bool) -> HRESULT,
    fn get_FrameFormat(&self, out: *mut super::mediaproperties::SphericalVideoFrameFormat) -> HRESULT,
    fn put_FrameFormat(&self, value: super::mediaproperties::SphericalVideoFrameFormat) -> HRESULT,
    fn get_HorizontalFieldOfViewInDegrees(&self, out: *mut f64) -> HRESULT,
    fn put_HorizontalFieldOfViewInDegrees(&self, value: f64) -> HRESULT,
    fn get_ViewOrientation(&self, out: *mut foundation::numerics::Quaternion) -> HRESULT,
    fn put_ViewOrientation(&self, value: foundation::numerics::Quaternion) -> HRESULT,
    fn get_ProjectionMode(&self, out: *mut SphericalVideoProjectionMode) -> HRESULT,
    fn put_ProjectionMode(&self, value: SphericalVideoProjectionMode) -> HRESULT
}}
impl IMediaPlaybackSphericalVideoProjection {
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_frame_format(&self) -> Result<super::mediaproperties::SphericalVideoFrameFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_frame_format(&self, value: super::mediaproperties::SphericalVideoFrameFormat) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_FrameFormat)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_horizontal_field_of_view_in_degrees(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HorizontalFieldOfViewInDegrees)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_horizontal_field_of_view_in_degrees(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_HorizontalFieldOfViewInDegrees)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_view_orientation(&self) -> Result<foundation::numerics::Quaternion> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ViewOrientation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_view_orientation(&self, value: foundation::numerics::Quaternion) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ViewOrientation)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_projection_mode(&self) -> Result<SphericalVideoProjectionMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProjectionMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_projection_mode(&self, value: SphericalVideoProjectionMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ProjectionMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlaybackSphericalVideoProjection: IMediaPlaybackSphericalVideoProjection}
RT_ENUM! { enum MediaPlaybackState: i32 {
    None = 0, Opening = 1, Buffering = 2, Playing = 3, Paused = 4,
}}
DEFINE_IID!(IID_IMediaPlaybackTimedMetadataTrackList, 1924403993, 48123, 18083, 147, 114, 156, 156, 116, 75, 148, 56);
RT_INTERFACE!{interface IMediaPlaybackTimedMetadataTrackList(IMediaPlaybackTimedMetadataTrackListVtbl, IMediaPlaybackTimedMetadataTrackList_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlaybackTimedMetadataTrackList] {
    fn add_PresentationModeChanged(&self, handler: <foundation::TypedEventHandler<MediaPlaybackTimedMetadataTrackList, TimedMetadataPresentationModeChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PresentationModeChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn GetPresentationMode(&self, index: u32, out: *mut TimedMetadataTrackPresentationMode) -> HRESULT,
    fn SetPresentationMode(&self, index: u32, value: TimedMetadataTrackPresentationMode) -> HRESULT
}}
impl IMediaPlaybackTimedMetadataTrackList {
    #[inline] pub fn add_presentation_mode_changed(&self, handler: &foundation::TypedEventHandler<MediaPlaybackTimedMetadataTrackList, TimedMetadataPresentationModeChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PresentationModeChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_presentation_mode_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PresentationModeChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_presentation_mode(&self, index: u32) -> Result<TimedMetadataTrackPresentationMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).GetPresentationMode)(self.0.as_abi() as *const _ as *mut _, index, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_presentation_mode(&self, index: u32, value: TimedMetadataTrackPresentationMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetPresentationMode)(self.0.as_abi() as *const _ as *mut _, index, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlaybackTimedMetadataTrackList: foundation::collections::IVectorView<super::core::TimedMetadataTrack>}
RT_CLASS!{class MediaPlaybackVideoTrackList: foundation::collections::IVectorView<super::core::VideoTrack>}
DEFINE_IID!(IID_IMediaPlayer, 941261771, 28671, 18843, 141, 100, 40, 133, 223, 193, 36, 158);
RT_INTERFACE!{interface IMediaPlayer(IMediaPlayerVtbl, IMediaPlayer_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlayer] {
    fn get_AutoPlay(&self, out: *mut bool) -> HRESULT,
    fn put_AutoPlay(&self, value: bool) -> HRESULT,
    fn get_NaturalDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_Position(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_BufferingProgress(&self, out: *mut f64) -> HRESULT,
    fn get_CurrentState(&self, out: *mut MediaPlayerState) -> HRESULT,
    fn get_CanSeek(&self, out: *mut bool) -> HRESULT,
    fn get_CanPause(&self, out: *mut bool) -> HRESULT,
    fn get_IsLoopingEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsLoopingEnabled(&self, value: bool) -> HRESULT,
    fn get_IsProtected(&self, out: *mut bool) -> HRESULT,
    fn get_IsMuted(&self, out: *mut bool) -> HRESULT,
    fn put_IsMuted(&self, value: bool) -> HRESULT,
    fn get_PlaybackRate(&self, out: *mut f64) -> HRESULT,
    fn put_PlaybackRate(&self, value: f64) -> HRESULT,
    fn get_Volume(&self, out: *mut f64) -> HRESULT,
    fn put_Volume(&self, value: f64) -> HRESULT,
    fn get_PlaybackMediaMarkers(&self, out: *mut <PlaybackMediaMarkerSequence as RtType>::Abi) -> HRESULT,
    fn add_MediaOpened(&self, value: <foundation::TypedEventHandler<MediaPlayer, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MediaOpened(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_MediaEnded(&self, value: <foundation::TypedEventHandler<MediaPlayer, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MediaEnded(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_MediaFailed(&self, value: <foundation::TypedEventHandler<MediaPlayer, MediaPlayerFailedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MediaFailed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CurrentStateChanged(&self, value: <foundation::TypedEventHandler<MediaPlayer, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CurrentStateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PlaybackMediaMarkerReached(&self, value: <foundation::TypedEventHandler<MediaPlayer, PlaybackMediaMarkerReachedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PlaybackMediaMarkerReached(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_MediaPlayerRateChanged(&self, value: <foundation::TypedEventHandler<MediaPlayer, MediaPlayerRateChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MediaPlayerRateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_VolumeChanged(&self, value: <foundation::TypedEventHandler<MediaPlayer, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VolumeChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SeekCompleted(&self, value: <foundation::TypedEventHandler<MediaPlayer, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SeekCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_BufferingStarted(&self, value: <foundation::TypedEventHandler<MediaPlayer, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BufferingStarted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_BufferingEnded(&self, value: <foundation::TypedEventHandler<MediaPlayer, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BufferingEnded(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn Play(&self) -> HRESULT,
    fn Pause(&self) -> HRESULT,
    fn SetUriSource(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT
}}
impl IMediaPlayer {
    #[inline] pub fn get_auto_play(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutoPlay)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto_play(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AutoPlay)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_natural_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_NaturalDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_position(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Position)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_buffering_progress(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BufferingProgress)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_current_state(&self) -> Result<MediaPlayerState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CurrentState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_seek(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanSeek)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_pause(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanPause)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_looping_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsLoopingEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_looping_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsLoopingEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_protected(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsProtected)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_muted(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsMuted)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_muted(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsMuted)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_playback_rate(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_playback_rate(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PlaybackRate)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_volume(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Volume)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_volume(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Volume)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_playback_media_markers(&self) -> Result<Option<PlaybackMediaMarkerSequence>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackMediaMarkers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PlaybackMediaMarkerSequence::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_media_opened(&self, value: &foundation::TypedEventHandler<MediaPlayer, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_MediaOpened)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_media_opened(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_MediaOpened)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_media_ended(&self, value: &foundation::TypedEventHandler<MediaPlayer, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_MediaEnded)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_media_ended(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_MediaEnded)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_media_failed(&self, value: &foundation::TypedEventHandler<MediaPlayer, MediaPlayerFailedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_MediaFailed)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_media_failed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_MediaFailed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_current_state_changed(&self, value: &foundation::TypedEventHandler<MediaPlayer, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_CurrentStateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_current_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_CurrentStateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_playback_media_marker_reached(&self, value: &foundation::TypedEventHandler<MediaPlayer, PlaybackMediaMarkerReachedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PlaybackMediaMarkerReached)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_playback_media_marker_reached(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PlaybackMediaMarkerReached)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_media_player_rate_changed(&self, value: &foundation::TypedEventHandler<MediaPlayer, MediaPlayerRateChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_MediaPlayerRateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_media_player_rate_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_MediaPlayerRateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_volume_changed(&self, value: &foundation::TypedEventHandler<MediaPlayer, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_VolumeChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_volume_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_VolumeChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_seek_completed(&self, value: &foundation::TypedEventHandler<MediaPlayer, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SeekCompleted)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_seek_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SeekCompleted)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_buffering_started(&self, value: &foundation::TypedEventHandler<MediaPlayer, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_BufferingStarted)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_buffering_started(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_BufferingStarted)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_buffering_ended(&self, value: &foundation::TypedEventHandler<MediaPlayer, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_BufferingEnded)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_buffering_ended(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_BufferingEnded)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn play(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Play)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn pause(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Pause)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_uri_source(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetUriSource)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlayer: IMediaPlayer}
impl RtActivatable<IActivationFactory> for MediaPlayer {}
DEFINE_CLSID!(MediaPlayer(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,108,97,121,98,97,99,107,46,77,101,100,105,97,80,108,97,121,101,114,0]) [CLSID_MediaPlayer]);
DEFINE_IID!(IID_IMediaPlayer2, 1015288344, 8483, 20421, 144, 130, 47, 136, 63, 119, 189, 245);
RT_INTERFACE!{interface IMediaPlayer2(IMediaPlayer2Vtbl, IMediaPlayer2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlayer2] {
    fn get_SystemMediaTransportControls(&self, out: *mut <super::SystemMediaTransportControls as RtType>::Abi) -> HRESULT,
    fn get_AudioCategory(&self, out: *mut MediaPlayerAudioCategory) -> HRESULT,
    fn put_AudioCategory(&self, value: MediaPlayerAudioCategory) -> HRESULT,
    fn get_AudioDeviceType(&self, out: *mut MediaPlayerAudioDeviceType) -> HRESULT,
    fn put_AudioDeviceType(&self, value: MediaPlayerAudioDeviceType) -> HRESULT
}}
impl IMediaPlayer2 {
    #[inline] pub fn get_system_media_transport_controls(&self) -> Result<Option<super::SystemMediaTransportControls>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SystemMediaTransportControls)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::SystemMediaTransportControls::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_category(&self) -> Result<MediaPlayerAudioCategory> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioCategory)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_audio_category(&self, value: MediaPlayerAudioCategory) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AudioCategory)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_device_type(&self) -> Result<MediaPlayerAudioDeviceType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioDeviceType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_audio_device_type(&self, value: MediaPlayerAudioDeviceType) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AudioDeviceType)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaPlayer3, 3993395418, 795, 20459, 189, 155, 146, 224, 160, 168, 210, 153);
RT_INTERFACE!{interface IMediaPlayer3(IMediaPlayer3Vtbl, IMediaPlayer3_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlayer3] {
    fn add_IsMutedChanged(&self, value: <foundation::TypedEventHandler<MediaPlayer, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_IsMutedChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SourceChanged(&self, value: <foundation::TypedEventHandler<MediaPlayer, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourceChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_AudioBalance(&self, out: *mut f64) -> HRESULT,
    fn put_AudioBalance(&self, value: f64) -> HRESULT,
    fn get_RealTimePlayback(&self, out: *mut bool) -> HRESULT,
    fn put_RealTimePlayback(&self, value: bool) -> HRESULT,
    fn get_StereoscopicVideoRenderMode(&self, out: *mut StereoscopicVideoRenderMode) -> HRESULT,
    fn put_StereoscopicVideoRenderMode(&self, value: StereoscopicVideoRenderMode) -> HRESULT,
    fn get_BreakManager(&self, out: *mut <MediaBreakManager as RtType>::Abi) -> HRESULT,
    fn get_CommandManager(&self, out: *mut <MediaPlaybackCommandManager as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy12(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_AudioDevice(&self, out: *mut <super::super::devices::enumeration::DeviceInformation as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy13(&self) -> (),
    #[cfg(feature="windows-devices")] fn put_AudioDevice(&self, value: <super::super::devices::enumeration::DeviceInformation as RtType>::Abi) -> HRESULT,
    fn get_TimelineController(&self, out: *mut <super::MediaTimelineController as RtType>::Abi) -> HRESULT,
    fn put_TimelineController(&self, value: <super::MediaTimelineController as RtType>::Abi) -> HRESULT,
    fn get_TimelineControllerPositionOffset(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_TimelineControllerPositionOffset(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_PlaybackSession(&self, out: *mut <MediaPlaybackSession as RtType>::Abi) -> HRESULT,
    fn StepForwardOneFrame(&self) -> HRESULT,
    fn StepBackwardOneFrame(&self) -> HRESULT,
    fn GetAsCastingSource(&self, out: *mut <super::casting::CastingSource as RtType>::Abi) -> HRESULT
}}
impl IMediaPlayer3 {
    #[inline] pub fn add_is_muted_changed(&self, value: &foundation::TypedEventHandler<MediaPlayer, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_IsMutedChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_is_muted_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_IsMutedChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_source_changed(&self, value: &foundation::TypedEventHandler<MediaPlayer, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SourceChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SourceChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_balance(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioBalance)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_audio_balance(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AudioBalance)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_real_time_playback(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RealTimePlayback)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_real_time_playback(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_RealTimePlayback)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_stereoscopic_video_render_mode(&self) -> Result<StereoscopicVideoRenderMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StereoscopicVideoRenderMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_stereoscopic_video_render_mode(&self, value: StereoscopicVideoRenderMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_StereoscopicVideoRenderMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_break_manager(&self) -> Result<Option<MediaBreakManager>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BreakManager)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaBreakManager::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_command_manager(&self) -> Result<Option<MediaPlaybackCommandManager>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CommandManager)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackCommandManager::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_audio_device(&self) -> Result<Option<super::super::devices::enumeration::DeviceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioDevice)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::devices::enumeration::DeviceInformation::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn set_audio_device(&self, value: &super::super::devices::enumeration::DeviceInformation) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AudioDevice)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_timeline_controller(&self) -> Result<Option<super::MediaTimelineController>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TimelineController)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::MediaTimelineController::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_timeline_controller(&self, value: &super::MediaTimelineController) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_TimelineController)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_timeline_controller_position_offset(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TimelineControllerPositionOffset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_timeline_controller_position_offset(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_TimelineControllerPositionOffset)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_playback_session(&self) -> Result<Option<MediaPlaybackSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackSession)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlaybackSession::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn step_forward_one_frame(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).StepForwardOneFrame)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn step_backward_one_frame(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).StepBackwardOneFrame)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_as_casting_source(&self) -> Result<Option<super::casting::CastingSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAsCastingSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::casting::CastingSource::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaPlayer4, 2147704240, 29768, 18288, 175, 207, 42, 87, 69, 9, 20, 197);
RT_INTERFACE!{interface IMediaPlayer4(IMediaPlayer4Vtbl, IMediaPlayer4_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlayer4] {
    fn SetSurfaceSize(&self, size: foundation::Size) -> HRESULT,
    #[cfg(feature="windows-ui")] fn GetSurface(&self, compositor: <super::super::ui::composition::Compositor as RtType>::Abi, out: *mut <MediaPlayerSurface as RtType>::Abi) -> HRESULT
}}
impl IMediaPlayer4 {
    #[inline] pub fn set_surface_size(&self, size: foundation::Size) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetSurfaceSize)(self.0.as_abi() as *const _ as *mut _, size);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_surface(&self, compositor: &super::super::ui::composition::Compositor) -> Result<Option<MediaPlayerSurface>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetSurface)(self.0.as_abi() as *const _ as *mut _, get_abi(compositor) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlayerSurface::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaPlayer5, 3487905789, 63594, 17478, 191, 77, 200, 231, 146, 183, 180, 179);
RT_INTERFACE!{interface IMediaPlayer5(IMediaPlayer5Vtbl, IMediaPlayer5_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlayer5] {
    fn add_VideoFrameAvailable(&self, value: <foundation::TypedEventHandler<MediaPlayer, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VideoFrameAvailable(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_IsVideoFrameServerEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsVideoFrameServerEnabled(&self, value: bool) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn CopyFrameToVideoSurface(&self, destination: <super::super::graphics::directx::direct3d11::IDirect3DSurface as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn CopyFrameToVideoSurfaceWithTargetRectangle(&self, destination: <super::super::graphics::directx::direct3d11::IDirect3DSurface as RtType>::Abi, targetRectangle: foundation::Rect) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn CopyFrameToStereoscopicVideoSurfaces(&self, destinationLeftEye: <super::super::graphics::directx::direct3d11::IDirect3DSurface as RtType>::Abi, destinationRightEye: <super::super::graphics::directx::direct3d11::IDirect3DSurface as RtType>::Abi) -> HRESULT
}}
impl IMediaPlayer5 {
    #[inline] pub fn add_video_frame_available(&self, value: &foundation::TypedEventHandler<MediaPlayer, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_VideoFrameAvailable)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_video_frame_available(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_VideoFrameAvailable)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_video_frame_server_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsVideoFrameServerEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_video_frame_server_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsVideoFrameServerEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn copy_frame_to_video_surface(&self, destination: &super::super::graphics::directx::direct3d11::IDirect3DSurface) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).CopyFrameToVideoSurface)(self.0.as_abi() as *const _ as *mut _, get_abi(destination) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn copy_frame_to_video_surface_with_target_rectangle(&self, destination: &super::super::graphics::directx::direct3d11::IDirect3DSurface, targetRectangle: foundation::Rect) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).CopyFrameToVideoSurfaceWithTargetRectangle)(self.0.as_abi() as *const _ as *mut _, get_abi(destination) as *const _ as *mut _, targetRectangle);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn copy_frame_to_stereoscopic_video_surfaces(&self, destinationLeftEye: &super::super::graphics::directx::direct3d11::IDirect3DSurface, destinationRightEye: &super::super::graphics::directx::direct3d11::IDirect3DSurface) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).CopyFrameToStereoscopicVideoSurfaces)(self.0.as_abi() as *const _ as *mut _, get_abi(destinationLeftEye) as *const _ as *mut _, get_abi(destinationRightEye) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaPlayer6, 3771375750, 44645, 16716, 176, 16, 139, 197, 95, 0, 230, 146);
RT_INTERFACE!{interface IMediaPlayer6(IMediaPlayer6Vtbl, IMediaPlayer6_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlayer6] {
    fn add_SubtitleFrameChanged(&self, handler: <foundation::TypedEventHandler<MediaPlayer, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SubtitleFrameChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn RenderSubtitlesToSurface(&self, destination: <super::super::graphics::directx::direct3d11::IDirect3DSurface as RtType>::Abi, out: *mut bool) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn RenderSubtitlesToSurfaceWithTargetRectangle(&self, destination: <super::super::graphics::directx::direct3d11::IDirect3DSurface as RtType>::Abi, targetRectangle: foundation::Rect, out: *mut bool) -> HRESULT
}}
impl IMediaPlayer6 {
    #[inline] pub fn add_subtitle_frame_changed(&self, handler: &foundation::TypedEventHandler<MediaPlayer, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SubtitleFrameChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_subtitle_frame_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SubtitleFrameChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn render_subtitles_to_surface(&self, destination: &super::super::graphics::directx::direct3d11::IDirect3DSurface) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).RenderSubtitlesToSurface)(self.0.as_abi() as *const _ as *mut _, get_abi(destination) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn render_subtitles_to_surface_with_target_rectangle(&self, destination: &super::super::graphics::directx::direct3d11::IDirect3DSurface, targetRectangle: foundation::Rect) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).RenderSubtitlesToSurfaceWithTargetRectangle)(self.0.as_abi() as *const _ as *mut _, get_abi(destination) as *const _ as *mut _, targetRectangle, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaPlayer7, 1562231928, 17664, 17713, 179, 244, 119, 122, 113, 73, 31, 127);
RT_INTERFACE!{interface IMediaPlayer7(IMediaPlayer7Vtbl, IMediaPlayer7_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlayer7] {
    fn get_AudioStateMonitor(&self, out: *mut <super::audio::AudioStateMonitor as RtType>::Abi) -> HRESULT
}}
impl IMediaPlayer7 {
    #[inline] pub fn get_audio_state_monitor(&self) -> Result<Option<super::audio::AudioStateMonitor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioStateMonitor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::audio::AudioStateMonitor::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum MediaPlayerAudioCategory: i32 {
    Other = 0, Communications = 3, Alerts = 4, SoundEffects = 5, GameEffects = 6, GameMedia = 7, GameChat = 8, Speech = 9, Movie = 10, Media = 11,
}}
RT_ENUM! { enum MediaPlayerAudioDeviceType: i32 {
    Console = 0, Multimedia = 1, Communications = 2,
}}
DEFINE_IID!(IID_IMediaPlayerDataReceivedEventArgs, 3344602117, 51201, 16682, 131, 91, 131, 252, 14, 98, 42, 142);
RT_INTERFACE!{interface IMediaPlayerDataReceivedEventArgs(IMediaPlayerDataReceivedEventArgsVtbl, IMediaPlayerDataReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlayerDataReceivedEventArgs] {
    fn get_Data(&self, out: *mut <foundation::collections::ValueSet as RtType>::Abi) -> HRESULT
}}
impl IMediaPlayerDataReceivedEventArgs {
    #[inline] pub fn get_data(&self) -> Result<Option<foundation::collections::ValueSet>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Data)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::ValueSet::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlayerDataReceivedEventArgs: IMediaPlayerDataReceivedEventArgs}
DEFINE_IID!(IID_IMediaPlayerEffects, 2241978074, 51894, 19648, 139, 227, 96, 53, 244, 222, 37, 145);
RT_INTERFACE!{interface IMediaPlayerEffects(IMediaPlayerEffectsVtbl, IMediaPlayerEffects_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlayerEffects] {
    fn AddAudioEffect(&self, activatableClassId: HSTRING, effectOptional: bool, configuration: <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT,
    fn RemoveAllEffects(&self) -> HRESULT
}}
impl IMediaPlayerEffects {
    #[inline] pub fn add_audio_effect(&self, activatableClassId: &HStringArg, effectOptional: bool, configuration: &foundation::collections::IPropertySet) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AddAudioEffect)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get(), effectOptional, get_abi(configuration) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove_all_effects(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RemoveAllEffects)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaPlayerEffects2, 4198603385, 7102, 18117, 174, 31, 142, 230, 159, 179, 194, 199);
RT_INTERFACE!{interface IMediaPlayerEffects2(IMediaPlayerEffects2Vtbl, IMediaPlayerEffects2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlayerEffects2] {
    fn AddVideoEffect(&self, activatableClassId: HSTRING, effectOptional: bool, effectConfiguration: <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT
}}
impl IMediaPlayerEffects2 {
    #[inline] pub fn add_video_effect(&self, activatableClassId: &HStringArg, effectOptional: bool, effectConfiguration: &foundation::collections::IPropertySet) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AddVideoEffect)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get(), effectOptional, get_abi(effectConfiguration) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum MediaPlayerError: i32 {
    Unknown = 0, Aborted = 1, NetworkError = 2, DecodingError = 3, SourceNotSupported = 4,
}}
DEFINE_IID!(IID_IMediaPlayerFailedEventArgs, 658827705, 42979, 20246, 186, 196, 121, 20, 235, 192, 131, 1);
RT_INTERFACE!{interface IMediaPlayerFailedEventArgs(IMediaPlayerFailedEventArgsVtbl, IMediaPlayerFailedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlayerFailedEventArgs] {
    fn get_Error(&self, out: *mut MediaPlayerError) -> HRESULT,
    fn get_ExtendedErrorCode(&self, out: *mut foundation::HResult) -> HRESULT,
    fn get_ErrorMessage(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMediaPlayerFailedEventArgs {
    #[inline] pub fn get_error(&self) -> Result<MediaPlayerError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Error)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_error_code(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedErrorCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error_message(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ErrorMessage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlayerFailedEventArgs: IMediaPlayerFailedEventArgs}
DEFINE_IID!(IID_IMediaPlayerRateChangedEventArgs, 1080036696, 15201, 19378, 152, 159, 252, 101, 96, 139, 108, 171);
RT_INTERFACE!{interface IMediaPlayerRateChangedEventArgs(IMediaPlayerRateChangedEventArgsVtbl, IMediaPlayerRateChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlayerRateChangedEventArgs] {
    fn get_NewRate(&self, out: *mut f64) -> HRESULT
}}
impl IMediaPlayerRateChangedEventArgs {
    #[inline] pub fn get_new_rate(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_NewRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlayerRateChangedEventArgs: IMediaPlayerRateChangedEventArgs}
DEFINE_IID!(IID_IMediaPlayerSource, 3176106135, 5155, 19518, 130, 197, 15, 177, 175, 148, 247, 21);
RT_INTERFACE!{interface IMediaPlayerSource(IMediaPlayerSourceVtbl, IMediaPlayerSource_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlayerSource] {
    fn get_ProtectionManager(&self, out: *mut <super::protection::MediaProtectionManager as RtType>::Abi) -> HRESULT,
    fn put_ProtectionManager(&self, value: <super::protection::MediaProtectionManager as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn SetFileSource(&self, file: <super::super::storage::IStorageFile as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-storage")] fn SetStreamSource(&self, stream: <super::super::storage::streams::IRandomAccessStream as RtType>::Abi) -> HRESULT,
    fn SetMediaSource(&self, source: <super::core::IMediaSource as RtType>::Abi) -> HRESULT
}}
impl IMediaPlayerSource {
    #[inline] pub fn get_protection_manager(&self) -> Result<Option<super::protection::MediaProtectionManager>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtectionManager)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::protection::MediaProtectionManager::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_protection_manager(&self, value: &super::protection::MediaProtectionManager) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ProtectionManager)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_file_source(&self, file: &super::super::storage::IStorageFile) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetFileSource)(self.0.as_abi() as *const _ as *mut _, get_abi(file) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_stream_source(&self, stream: &super::super::storage::streams::IRandomAccessStream) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetStreamSource)(self.0.as_abi() as *const _ as *mut _, get_abi(stream) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_media_source(&self, source: &super::core::IMediaSource) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetMediaSource)(self.0.as_abi() as *const _ as *mut _, get_abi(source) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaPlayerSource2, 2185534367, 29474, 19467, 176, 59, 62, 105, 164, 130, 96, 197);
RT_INTERFACE!{interface IMediaPlayerSource2(IMediaPlayerSource2Vtbl, IMediaPlayerSource2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlayerSource2] {
    fn get_Source(&self, out: *mut <IMediaPlaybackSource as RtType>::Abi) -> HRESULT,
    fn put_Source(&self, value: <IMediaPlaybackSource as RtType>::Abi) -> HRESULT
}}
impl IMediaPlayerSource2 {
    #[inline] pub fn get_source(&self) -> Result<Option<IMediaPlaybackSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Source)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IMediaPlaybackSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_source(&self, value: &IMediaPlaybackSource) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Source)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum MediaPlayerState: i32 {
    Closed = 0, Opening = 1, Buffering = 2, Playing = 3, Paused = 4, Stopped = 5,
}}
DEFINE_IID!(IID_IMediaPlayerSurface, 248927164, 46902, 18883, 131, 11, 118, 74, 56, 69, 49, 58);
RT_INTERFACE!{interface IMediaPlayerSurface(IMediaPlayerSurfaceVtbl, IMediaPlayerSurface_Abi): IInspectable(IInspectableVtbl) [IID_IMediaPlayerSurface] {
    #[cfg(not(feature="windows-ui"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_CompositionSurface(&self, out: *mut <super::super::ui::composition::ICompositionSurface as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Compositor(&self, out: *mut <super::super::ui::composition::Compositor as RtType>::Abi) -> HRESULT,
    fn get_MediaPlayer(&self, out: *mut <MediaPlayer as RtType>::Abi) -> HRESULT
}}
impl IMediaPlayerSurface {
    #[cfg(feature="windows-ui")] #[inline] pub fn get_composition_surface(&self) -> Result<Option<super::super::ui::composition::ICompositionSurface>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CompositionSurface)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::ui::composition::ICompositionSurface::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_compositor(&self) -> Result<Option<super::super::ui::composition::Compositor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Compositor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::ui::composition::Compositor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_media_player(&self) -> Result<Option<MediaPlayer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaPlayer)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaPlayer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaPlayerSurface: IMediaPlayerSurface}
DEFINE_IID!(IID_IPlaybackMediaMarker, 3302109020, 15388, 17476, 182, 185, 119, 139, 4, 34, 212, 26);
RT_INTERFACE!{interface IPlaybackMediaMarker(IPlaybackMediaMarkerVtbl, IPlaybackMediaMarker_Abi): IInspectable(IInspectableVtbl) [IID_IPlaybackMediaMarker] {
    fn get_Time(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_MediaMarkerType(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPlaybackMediaMarker {
    #[inline] pub fn get_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Time)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_media_marker_type(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaMarkerType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Text)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PlaybackMediaMarker: IPlaybackMediaMarker}
impl RtActivatable<IPlaybackMediaMarkerFactory> for PlaybackMediaMarker {}
impl PlaybackMediaMarker {
    #[inline] pub fn create_from_time(value: foundation::TimeSpan) -> Result<PlaybackMediaMarker> {
        <Self as RtActivatable<IPlaybackMediaMarkerFactory>>::get_activation_factory().create_from_time(value)
    }
    #[inline] pub fn create(value: foundation::TimeSpan, mediaMarketType: &HStringArg, text: &HStringArg) -> Result<PlaybackMediaMarker> {
        <Self as RtActivatable<IPlaybackMediaMarkerFactory>>::get_activation_factory().create(value, mediaMarketType, text)
    }
}
DEFINE_CLSID!(PlaybackMediaMarker(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,108,97,121,98,97,99,107,46,80,108,97,121,98,97,99,107,77,101,100,105,97,77,97,114,107,101,114,0]) [CLSID_PlaybackMediaMarker]);
DEFINE_IID!(IID_IPlaybackMediaMarkerFactory, 2354252408, 57518, 19994, 168, 200, 226, 63, 152, 42, 147, 123);
RT_INTERFACE!{static interface IPlaybackMediaMarkerFactory(IPlaybackMediaMarkerFactoryVtbl, IPlaybackMediaMarkerFactory_Abi): IInspectable(IInspectableVtbl) [IID_IPlaybackMediaMarkerFactory] {
    fn CreateFromTime(&self, value: foundation::TimeSpan, out: *mut <PlaybackMediaMarker as RtType>::Abi) -> HRESULT,
    fn Create(&self, value: foundation::TimeSpan, mediaMarketType: HSTRING, text: HSTRING, out: *mut <PlaybackMediaMarker as RtType>::Abi) -> HRESULT
}}
impl IPlaybackMediaMarkerFactory {
    #[inline] pub fn create_from_time(&self, value: foundation::TimeSpan) -> Result<PlaybackMediaMarker> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromTime)(self.0.as_abi() as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(PlaybackMediaMarker::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create(&self, value: foundation::TimeSpan, mediaMarketType: &HStringArg, text: &HStringArg) -> Result<PlaybackMediaMarker> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, value, mediaMarketType.get(), text.get(), &mut out);
        if hr == S_OK { Ok(PlaybackMediaMarker::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPlaybackMediaMarkerReachedEventArgs, 1468846521, 37090, 20064, 171, 196, 135, 64, 176, 31, 97, 150);
RT_INTERFACE!{interface IPlaybackMediaMarkerReachedEventArgs(IPlaybackMediaMarkerReachedEventArgsVtbl, IPlaybackMediaMarkerReachedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPlaybackMediaMarkerReachedEventArgs] {
    fn get_PlaybackMediaMarker(&self, out: *mut <PlaybackMediaMarker as RtType>::Abi) -> HRESULT
}}
impl IPlaybackMediaMarkerReachedEventArgs {
    #[inline] pub fn get_playback_media_marker(&self) -> Result<Option<PlaybackMediaMarker>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlaybackMediaMarker)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PlaybackMediaMarker::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PlaybackMediaMarkerReachedEventArgs: IPlaybackMediaMarkerReachedEventArgs}
DEFINE_IID!(IID_IPlaybackMediaMarkerSequence, 4068543726, 25483, 18127, 136, 23, 29, 17, 31, 233, 216, 196);
RT_INTERFACE!{interface IPlaybackMediaMarkerSequence(IPlaybackMediaMarkerSequenceVtbl, IPlaybackMediaMarkerSequence_Abi): IInspectable(IInspectableVtbl) [IID_IPlaybackMediaMarkerSequence] {
    fn get_Size(&self, out: *mut u32) -> HRESULT,
    fn Insert(&self, value: <PlaybackMediaMarker as RtType>::Abi) -> HRESULT,
    fn Clear(&self) -> HRESULT
}}
impl IPlaybackMediaMarkerSequence {
    #[inline] pub fn get_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Size)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn insert(&self, value: &PlaybackMediaMarker) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Insert)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn clear(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Clear)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PlaybackMediaMarkerSequence: IPlaybackMediaMarkerSequence}
RT_ENUM! { enum SphericalVideoProjectionMode: i32 {
    Spherical = 0, Flat = 1,
}}
RT_ENUM! { enum StereoscopicVideoRenderMode: i32 {
    Mono = 0, Stereo = 1,
}}
DEFINE_IID!(IID_ITimedMetadataPresentationModeChangedEventArgs, 3512950937, 26079, 17838, 140, 239, 220, 11, 83, 253, 194, 187);
RT_INTERFACE!{interface ITimedMetadataPresentationModeChangedEventArgs(ITimedMetadataPresentationModeChangedEventArgsVtbl, ITimedMetadataPresentationModeChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ITimedMetadataPresentationModeChangedEventArgs] {
    fn get_Track(&self, out: *mut <super::core::TimedMetadataTrack as RtType>::Abi) -> HRESULT,
    fn get_OldPresentationMode(&self, out: *mut TimedMetadataTrackPresentationMode) -> HRESULT,
    fn get_NewPresentationMode(&self, out: *mut TimedMetadataTrackPresentationMode) -> HRESULT
}}
impl ITimedMetadataPresentationModeChangedEventArgs {
    #[inline] pub fn get_track(&self) -> Result<Option<super::core::TimedMetadataTrack>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Track)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::core::TimedMetadataTrack::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_old_presentation_mode(&self) -> Result<TimedMetadataTrackPresentationMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OldPresentationMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_new_presentation_mode(&self) -> Result<TimedMetadataTrackPresentationMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_NewPresentationMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class TimedMetadataPresentationModeChangedEventArgs: ITimedMetadataPresentationModeChangedEventArgs}
RT_ENUM! { enum TimedMetadataTrackPresentationMode: i32 {
    Disabled = 0, Hidden = 1, ApplicationPresented = 2, PlatformPresented = 3,
}}
} // Windows.Media.Playback
pub mod playlists { // Windows.Media.Playlists
use crate::prelude::*;
DEFINE_IID!(IID_IPlaylist, 2151102197, 53060, 19863, 131, 179, 122, 8, 158, 154, 182, 99);
RT_INTERFACE!{interface IPlaylist(IPlaylistVtbl, IPlaylist_Abi): IInspectable(IInspectableVtbl) [IID_IPlaylist] {
    #[cfg(feature="windows-storage")] fn get_Files(&self, out: *mut <foundation::collections::IVector<super::super::storage::StorageFile> as RtType>::Abi) -> HRESULT,
    fn SaveAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SaveAsAsync(&self, saveLocation: <super::super::storage::IStorageFolder as RtType>::Abi, desiredName: HSTRING, option: super::super::storage::NameCollisionOption, out: *mut <foundation::IAsyncOperation<super::super::storage::StorageFile> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SaveAsWithFormatAsync(&self, saveLocation: <super::super::storage::IStorageFolder as RtType>::Abi, desiredName: HSTRING, option: super::super::storage::NameCollisionOption, playlistFormat: PlaylistFormat, out: *mut <foundation::IAsyncOperation<super::super::storage::StorageFile> as RtType>::Abi) -> HRESULT
}}
impl IPlaylist {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_files(&self) -> Result<Option<foundation::collections::IVector<super::super::storage::StorageFile>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Files)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn save_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SaveAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn save_as_async(&self, saveLocation: &super::super::storage::IStorageFolder, desiredName: &HStringArg, option: super::super::storage::NameCollisionOption) -> Result<foundation::IAsyncOperation<super::super::storage::StorageFile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SaveAsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(saveLocation) as *const _ as *mut _, desiredName.get(), option, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn save_as_with_format_async(&self, saveLocation: &super::super::storage::IStorageFolder, desiredName: &HStringArg, option: super::super::storage::NameCollisionOption, playlistFormat: PlaylistFormat) -> Result<foundation::IAsyncOperation<super::super::storage::StorageFile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SaveAsWithFormatAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(saveLocation) as *const _ as *mut _, desiredName.get(), option, playlistFormat, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class Playlist: IPlaylist}
impl RtActivatable<IPlaylistStatics> for Playlist {}
impl RtActivatable<IActivationFactory> for Playlist {}
impl Playlist {
    #[cfg(feature="windows-storage")] #[inline] pub fn load_async(file: &super::super::storage::IStorageFile) -> Result<foundation::IAsyncOperation<Playlist>> {
        <Self as RtActivatable<IPlaylistStatics>>::get_activation_factory().load_async(file)
    }
}
DEFINE_CLSID!(Playlist(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,108,97,121,108,105,115,116,115,46,80,108,97,121,108,105,115,116,0]) [CLSID_Playlist]);
RT_ENUM! { enum PlaylistFormat: i32 {
    WindowsMedia = 0, Zune = 1, M3u = 2,
}}
DEFINE_IID!(IID_IPlaylistStatics, 3317903821, 33273, 20467, 149, 185, 112, 182, 255, 4, 107, 104);
RT_INTERFACE!{static interface IPlaylistStatics(IPlaylistStaticsVtbl, IPlaylistStatics_Abi): IInspectable(IInspectableVtbl) [IID_IPlaylistStatics] {
    #[cfg(feature="windows-storage")] fn LoadAsync(&self, file: <super::super::storage::IStorageFile as RtType>::Abi, out: *mut <foundation::IAsyncOperation<Playlist> as RtType>::Abi) -> HRESULT
}}
impl IPlaylistStatics {
    #[cfg(feature="windows-storage")] #[inline] pub fn load_async(&self, file: &super::super::storage::IStorageFile) -> Result<foundation::IAsyncOperation<Playlist>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).LoadAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(file) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
} // Windows.Media.Playlists
pub mod protection { // Windows.Media.Protection
use crate::prelude::*;
DEFINE_IID!(IID_IComponentLoadFailedEventArgs, 2509713043, 30534, 16766, 132, 149, 240, 49, 187, 197, 134, 44);
RT_INTERFACE!{interface IComponentLoadFailedEventArgs(IComponentLoadFailedEventArgsVtbl, IComponentLoadFailedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IComponentLoadFailedEventArgs] {
    fn get_Information(&self, out: *mut <RevocationAndRenewalInformation as RtType>::Abi) -> HRESULT,
    fn get_Completion(&self, out: *mut <MediaProtectionServiceCompletion as RtType>::Abi) -> HRESULT
}}
impl IComponentLoadFailedEventArgs {
    #[inline] pub fn get_information(&self) -> Result<Option<RevocationAndRenewalInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Information)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(RevocationAndRenewalInformation::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_completion(&self) -> Result<Option<MediaProtectionServiceCompletion>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Completion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaProtectionServiceCompletion::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ComponentLoadFailedEventArgs: IComponentLoadFailedEventArgs}
DEFINE_IID!(IID_ComponentLoadFailedEventHandler, 2514117692, 28089, 16971, 134, 202, 9, 26, 244, 50, 8, 28);
RT_DELEGATE!{delegate ComponentLoadFailedEventHandler(ComponentLoadFailedEventHandlerVtbl, ComponentLoadFailedEventHandler_Abi, ComponentLoadFailedEventHandlerImpl) [IID_ComponentLoadFailedEventHandler] {
    fn Invoke(&self, sender: <MediaProtectionManager as RtType>::Abi, e: <ComponentLoadFailedEventArgs as RtType>::Abi) -> HRESULT
}}
impl ComponentLoadFailedEventHandler {
    #[inline] pub fn invoke(&self, sender: &MediaProtectionManager, e: &ComponentLoadFailedEventArgs) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Invoke)(self.0.as_abi() as *const _ as *mut _, get_abi(sender) as *const _ as *mut _, get_abi(e) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{static class ComponentRenewal}
impl RtActivatable<IComponentRenewalStatics> for ComponentRenewal {}
impl ComponentRenewal {
    #[inline] pub fn renew_system_components_async(information: &RevocationAndRenewalInformation) -> Result<foundation::IAsyncOperationWithProgress<RenewalStatus, u32>> {
        <Self as RtActivatable<IComponentRenewalStatics>>::get_activation_factory().renew_system_components_async(information)
    }
}
DEFINE_CLSID!(ComponentRenewal(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,67,111,109,112,111,110,101,110,116,82,101,110,101,119,97,108,0]) [CLSID_ComponentRenewal]);
DEFINE_IID!(IID_IComponentRenewalStatics, 1878773095, 46997, 18629, 139, 123, 167, 196, 239, 226, 2, 227);
RT_INTERFACE!{static interface IComponentRenewalStatics(IComponentRenewalStaticsVtbl, IComponentRenewalStatics_Abi): IInspectable(IInspectableVtbl) [IID_IComponentRenewalStatics] {
    fn RenewSystemComponentsAsync(&self, information: <RevocationAndRenewalInformation as RtType>::Abi, out: *mut <foundation::IAsyncOperationWithProgress<RenewalStatus, u32> as RtType>::Abi) -> HRESULT
}}
impl IComponentRenewalStatics {
    #[inline] pub fn renew_system_components_async(&self, information: &RevocationAndRenewalInformation) -> Result<foundation::IAsyncOperationWithProgress<RenewalStatus, u32>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RenewSystemComponentsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(information) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperationWithProgress::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum GraphicsTrustStatus: i32 {
    TrustNotRequired = 0, TrustEstablished = 1, EnvironmentNotSupported = 2, DriverNotSupported = 3, DriverSigningFailure = 4, UnknownFailure = 5,
}}
RT_ENUM! { enum HdcpProtection: i32 {
    Off = 0, On = 1, OnWithTypeEnforcement = 2,
}}
DEFINE_IID!(IID_IHdcpSession, 1904756201, 25815, 17005, 128, 155, 27, 228, 97, 148, 26, 42);
RT_INTERFACE!{interface IHdcpSession(IHdcpSessionVtbl, IHdcpSession_Abi): IInspectable(IInspectableVtbl) [IID_IHdcpSession] {
    fn IsEffectiveProtectionAtLeast(&self, protection: HdcpProtection, out: *mut bool) -> HRESULT,
    fn GetEffectiveProtection(&self, out: *mut <foundation::IReference<HdcpProtection> as RtType>::Abi) -> HRESULT,
    fn SetDesiredMinProtectionAsync(&self, protection: HdcpProtection, out: *mut <foundation::IAsyncOperation<HdcpSetProtectionResult> as RtType>::Abi) -> HRESULT,
    fn add_ProtectionChanged(&self, handler: <foundation::TypedEventHandler<HdcpSession, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ProtectionChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IHdcpSession {
    #[inline] pub fn is_effective_protection_at_least(&self, protection: HdcpProtection) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsEffectiveProtectionAtLeast)(self.0.as_abi() as *const _ as *mut _, protection, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_effective_protection(&self) -> Result<Option<foundation::IReference<HdcpProtection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetEffectiveProtection)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_min_protection_async(&self, protection: HdcpProtection) -> Result<foundation::IAsyncOperation<HdcpSetProtectionResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetDesiredMinProtectionAsync)(self.0.as_abi() as *const _ as *mut _, protection, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_protection_changed(&self, handler: &foundation::TypedEventHandler<HdcpSession, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ProtectionChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_protection_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ProtectionChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class HdcpSession: IHdcpSession}
impl RtActivatable<IActivationFactory> for HdcpSession {}
DEFINE_CLSID!(HdcpSession(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,72,100,99,112,83,101,115,115,105,111,110,0]) [CLSID_HdcpSession]);
RT_ENUM! { enum HdcpSetProtectionResult: i32 {
    Success = 0, TimedOut = 1, NotSupported = 2, UnknownFailure = 3,
}}
DEFINE_IID!(IID_IMediaProtectionManager, 1164527943, 51009, 17227, 167, 158, 71, 76, 18, 217, 61, 47);
RT_INTERFACE!{interface IMediaProtectionManager(IMediaProtectionManagerVtbl, IMediaProtectionManager_Abi): IInspectable(IInspectableVtbl) [IID_IMediaProtectionManager] {
    fn add_ServiceRequested(&self, handler: <ServiceRequestedEventHandler as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ServiceRequested(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_RebootNeeded(&self, handler: <RebootNeededEventHandler as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RebootNeeded(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ComponentLoadFailed(&self, handler: <ComponentLoadFailedEventHandler as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ComponentLoadFailed(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT
}}
impl IMediaProtectionManager {
    #[inline] pub fn add_service_requested(&self, handler: &ServiceRequestedEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ServiceRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_service_requested(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ServiceRequested)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_reboot_needed(&self, handler: &RebootNeededEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_RebootNeeded)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reboot_needed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_RebootNeeded)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_component_load_failed(&self, handler: &ComponentLoadFailedEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ComponentLoadFailed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_component_load_failed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ComponentLoadFailed)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IPropertySet>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IPropertySet::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaProtectionManager: IMediaProtectionManager}
impl RtActivatable<IActivationFactory> for MediaProtectionManager {}
DEFINE_CLSID!(MediaProtectionManager(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,77,101,100,105,97,80,114,111,116,101,99,116,105,111,110,77,97,110,97,103,101,114,0]) [CLSID_MediaProtectionManager]);
DEFINE_IID!(IID_IMediaProtectionPMPServer, 202445350, 31526, 19761, 149, 187, 156, 27, 8, 239, 127, 192);
RT_INTERFACE!{interface IMediaProtectionPMPServer(IMediaProtectionPMPServerVtbl, IMediaProtectionPMPServer_Abi): IInspectable(IInspectableVtbl) [IID_IMediaProtectionPMPServer] {
    fn get_Properties(&self, out: *mut <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT
}}
impl IMediaProtectionPMPServer {
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IPropertySet>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IPropertySet::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaProtectionPMPServer: IMediaProtectionPMPServer}
impl RtActivatable<IMediaProtectionPMPServerFactory> for MediaProtectionPMPServer {}
impl MediaProtectionPMPServer {
    #[inline] pub fn create_pmp_server(pProperties: &foundation::collections::IPropertySet) -> Result<MediaProtectionPMPServer> {
        <Self as RtActivatable<IMediaProtectionPMPServerFactory>>::get_activation_factory().create_pmp_server(pProperties)
    }
}
DEFINE_CLSID!(MediaProtectionPMPServer(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,77,101,100,105,97,80,114,111,116,101,99,116,105,111,110,80,77,80,83,101,114,118,101,114,0]) [CLSID_MediaProtectionPMPServer]);
DEFINE_IID!(IID_IMediaProtectionPMPServerFactory, 1613532766, 63442, 18558, 175, 145, 219, 196, 37, 43, 33, 130);
RT_INTERFACE!{static interface IMediaProtectionPMPServerFactory(IMediaProtectionPMPServerFactoryVtbl, IMediaProtectionPMPServerFactory_Abi): IInspectable(IInspectableVtbl) [IID_IMediaProtectionPMPServerFactory] {
    fn CreatePMPServer(&self, pProperties: <foundation::collections::IPropertySet as RtType>::Abi, out: *mut <MediaProtectionPMPServer as RtType>::Abi) -> HRESULT
}}
impl IMediaProtectionPMPServerFactory {
    #[inline] pub fn create_pmp_server(&self, pProperties: &foundation::collections::IPropertySet) -> Result<MediaProtectionPMPServer> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreatePMPServer)(self.0.as_abi() as *const _ as *mut _, get_abi(pProperties) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaProtectionPMPServer::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMediaProtectionServiceCompletion, 2338114072, 53205, 17646, 162, 237, 223, 118, 1, 12, 20, 181);
RT_INTERFACE!{interface IMediaProtectionServiceCompletion(IMediaProtectionServiceCompletionVtbl, IMediaProtectionServiceCompletion_Abi): IInspectable(IInspectableVtbl) [IID_IMediaProtectionServiceCompletion] {
    fn Complete(&self, success: bool) -> HRESULT
}}
impl IMediaProtectionServiceCompletion {
    #[inline] pub fn complete(&self, success: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Complete)(self.0.as_abi() as *const _ as *mut _, success);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaProtectionServiceCompletion: IMediaProtectionServiceCompletion}
DEFINE_IID!(IID_IMediaProtectionServiceRequest, 2984119974, 8340, 18317, 135, 164, 139, 149, 32, 15, 133, 198);
RT_INTERFACE!{interface IMediaProtectionServiceRequest(IMediaProtectionServiceRequestVtbl, IMediaProtectionServiceRequest_Abi): IInspectable(IInspectableVtbl) [IID_IMediaProtectionServiceRequest] {
    fn get_ProtectionSystem(&self, out: *mut Guid) -> HRESULT,
    fn get_Type(&self, out: *mut Guid) -> HRESULT
}}
impl IMediaProtectionServiceRequest {
    #[inline] pub fn get_protection_system(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtectionSystem)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_type(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Type)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IProtectionCapabilities, 3349962110, 29824, 19753, 164, 100, 123, 205, 145, 61, 216, 228);
RT_INTERFACE!{interface IProtectionCapabilities(IProtectionCapabilitiesVtbl, IProtectionCapabilities_Abi): IInspectable(IInspectableVtbl) [IID_IProtectionCapabilities] {
    fn IsTypeSupported(&self, type_: HSTRING, keySystem: HSTRING, out: *mut ProtectionCapabilityResult) -> HRESULT
}}
impl IProtectionCapabilities {
    #[inline] pub fn is_type_supported(&self, type_: &HStringArg, keySystem: &HStringArg) -> Result<ProtectionCapabilityResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsTypeSupported)(self.0.as_abi() as *const _ as *mut _, type_.get(), keySystem.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ProtectionCapabilities: IProtectionCapabilities}
impl RtActivatable<IActivationFactory> for ProtectionCapabilities {}
DEFINE_CLSID!(ProtectionCapabilities(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,114,111,116,101,99,116,105,111,110,67,97,112,97,98,105,108,105,116,105,101,115,0]) [CLSID_ProtectionCapabilities]);
RT_ENUM! { enum ProtectionCapabilityResult: i32 {
    NotSupported = 0, Maybe = 1, Probably = 2,
}}
DEFINE_IID!(IID_RebootNeededEventHandler, 1692478021, 38715, 19002, 178, 96, 145, 137, 138, 73, 168, 44);
RT_DELEGATE!{delegate RebootNeededEventHandler(RebootNeededEventHandlerVtbl, RebootNeededEventHandler_Abi, RebootNeededEventHandlerImpl) [IID_RebootNeededEventHandler] {
    fn Invoke(&self, sender: <MediaProtectionManager as RtType>::Abi) -> HRESULT
}}
impl RebootNeededEventHandler {
    #[inline] pub fn invoke(&self, sender: &MediaProtectionManager) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Invoke)(self.0.as_abi() as *const _ as *mut _, get_abi(sender) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum RenewalStatus: i32 {
    NotStarted = 0, UpdatesInProgress = 1, UserCancelled = 2, AppComponentsMayNeedUpdating = 3, NoComponentsFound = 4,
}}
DEFINE_IID!(IID_IRevocationAndRenewalInformation, 4087452539, 9473, 17310, 166, 231, 111, 201, 94, 23, 95, 207);
RT_INTERFACE!{interface IRevocationAndRenewalInformation(IRevocationAndRenewalInformationVtbl, IRevocationAndRenewalInformation_Abi): IInspectable(IInspectableVtbl) [IID_IRevocationAndRenewalInformation] {
    fn get_Items(&self, out: *mut <foundation::collections::IVector<RevocationAndRenewalItem> as RtType>::Abi) -> HRESULT
}}
impl IRevocationAndRenewalInformation {
    #[inline] pub fn get_items(&self) -> Result<Option<foundation::collections::IVector<RevocationAndRenewalItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Items)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RevocationAndRenewalInformation: IRevocationAndRenewalInformation}
DEFINE_IID!(IID_IRevocationAndRenewalItem, 815383052, 15600, 18922, 144, 45, 202, 243, 45, 45, 222, 44);
RT_INTERFACE!{interface IRevocationAndRenewalItem(IRevocationAndRenewalItemVtbl, IRevocationAndRenewalItem_Abi): IInspectable(IInspectableVtbl) [IID_IRevocationAndRenewalItem] {
    fn get_Reasons(&self, out: *mut RevocationAndRenewalReasons) -> HRESULT,
    fn get_HeaderHash(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PublicKeyHash(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RenewalId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IRevocationAndRenewalItem {
    #[inline] pub fn get_reasons(&self) -> Result<RevocationAndRenewalReasons> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reasons)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_header_hash(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_HeaderHash)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_public_key_hash(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PublicKeyHash)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Name)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_renewal_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_RenewalId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RevocationAndRenewalItem: IRevocationAndRenewalItem}
RT_ENUM! { enum RevocationAndRenewalReasons: u32 {
    UserModeComponentLoad = 1, KernelModeComponentLoad = 2, AppComponent = 4, GlobalRevocationListLoadFailed = 16, InvalidGlobalRevocationListSignature = 32, GlobalRevocationListAbsent = 4096, ComponentRevoked = 8192, InvalidComponentCertificateExtendedKeyUse = 16384, ComponentCertificateRevoked = 32768, InvalidComponentCertificateRoot = 65536, ComponentHighSecurityCertificateRevoked = 131072, ComponentLowSecurityCertificateRevoked = 262144, BootDriverVerificationFailed = 1048576, ComponentSignedWithTestCertificate = 16777216, EncryptionFailure = 268435456,
}}
DEFINE_IID!(IID_IServiceRequestedEventArgs, 875051951, 43956, 20417, 189, 137, 147, 241, 6, 87, 58, 73);
RT_INTERFACE!{interface IServiceRequestedEventArgs(IServiceRequestedEventArgsVtbl, IServiceRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IServiceRequestedEventArgs] {
    fn get_Request(&self, out: *mut <IMediaProtectionServiceRequest as RtType>::Abi) -> HRESULT,
    fn get_Completion(&self, out: *mut <MediaProtectionServiceCompletion as RtType>::Abi) -> HRESULT
}}
impl IServiceRequestedEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<IMediaProtectionServiceRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Request)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IMediaProtectionServiceRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_completion(&self) -> Result<Option<MediaProtectionServiceCompletion>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Completion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MediaProtectionServiceCompletion::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ServiceRequestedEventArgs: IServiceRequestedEventArgs}
DEFINE_IID!(IID_IServiceRequestedEventArgs2, 1430022614, 64254, 16680, 141, 250, 19, 14, 57, 138, 19, 167);
RT_INTERFACE!{interface IServiceRequestedEventArgs2(IServiceRequestedEventArgs2Vtbl, IServiceRequestedEventArgs2_Abi): IInspectable(IInspectableVtbl) [IID_IServiceRequestedEventArgs2] {
    fn get_MediaPlaybackItem(&self, out: *mut <super::playback::MediaPlaybackItem as RtType>::Abi) -> HRESULT
}}
impl IServiceRequestedEventArgs2 {
    #[inline] pub fn get_media_playback_item(&self) -> Result<Option<super::playback::MediaPlaybackItem>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaPlaybackItem)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::playback::MediaPlaybackItem::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ServiceRequestedEventHandler, 3537277114, 51913, 18657, 149, 192, 211, 132, 149, 168, 64, 85);
RT_DELEGATE!{delegate ServiceRequestedEventHandler(ServiceRequestedEventHandlerVtbl, ServiceRequestedEventHandler_Abi, ServiceRequestedEventHandlerImpl) [IID_ServiceRequestedEventHandler] {
    fn Invoke(&self, sender: <MediaProtectionManager as RtType>::Abi, e: <ServiceRequestedEventArgs as RtType>::Abi) -> HRESULT
}}
impl ServiceRequestedEventHandler {
    #[inline] pub fn invoke(&self, sender: &MediaProtectionManager, e: &ServiceRequestedEventArgs) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Invoke)(self.0.as_abi() as *const _ as *mut _, get_abi(sender) as *const _ as *mut _, get_abi(e) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
pub mod playready { // Windows.Media.Protection.PlayReady
use crate::prelude::*;
RT_ENUM! { enum NDCertificateFeature: i32 {
    Transmitter = 1, Receiver = 2, SharedCertificate = 3, SecureClock = 4, AntiRollBackClock = 5, CRLS = 9, PlayReady3Features = 13,
}}
RT_ENUM! { enum NDCertificatePlatformID: i32 {
    Windows = 0, OSX = 1, WindowsOnARM = 2, WindowsMobile7 = 5, iOSOnARM = 6, XBoxOnPPC = 7, WindowsPhone8OnARM = 8, WindowsPhone8OnX86 = 9, XboxOne = 10, AndroidOnARM = 11, WindowsPhone81OnARM = 12, WindowsPhone81OnX86 = 13,
}}
RT_ENUM! { enum NDCertificateType: i32 {
    Unknown = 0, PC = 1, Device = 2, Domain = 3, Issuer = 4, CrlSigner = 5, Service = 6, Silverlight = 7, Application = 8, Metering = 9, KeyFileSigner = 10, Server = 11, LicenseSigner = 12,
}}
DEFINE_IID!(IID_INDClient, 1003911195, 25016, 18146, 153, 165, 138, 188, 182, 185, 247, 214);
RT_INTERFACE!{interface INDClient(INDClientVtbl, INDClient_Abi): IInspectable(IInspectableVtbl) [IID_INDClient] {
    fn add_RegistrationCompleted(&self, handler: <foundation::TypedEventHandler<NDClient, INDRegistrationCompletedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RegistrationCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ProximityDetectionCompleted(&self, handler: <foundation::TypedEventHandler<NDClient, INDProximityDetectionCompletedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ProximityDetectionCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_LicenseFetchCompleted(&self, handler: <foundation::TypedEventHandler<NDClient, INDLicenseFetchCompletedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LicenseFetchCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ReRegistrationNeeded(&self, handler: <foundation::TypedEventHandler<NDClient, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReRegistrationNeeded(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ClosedCaptionDataReceived(&self, handler: <foundation::TypedEventHandler<NDClient, INDClosedCaptionDataReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ClosedCaptionDataReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn StartAsync(&self, contentUrl: <foundation::Uri as RtType>::Abi, startAsyncOptions: u32, registrationCustomData: <INDCustomData as RtType>::Abi, licenseFetchDescriptor: <INDLicenseFetchDescriptor as RtType>::Abi, out: *mut <foundation::IAsyncOperation<INDStartResult> as RtType>::Abi) -> HRESULT,
    fn LicenseFetchAsync(&self, licenseFetchDescriptor: <INDLicenseFetchDescriptor as RtType>::Abi, out: *mut <foundation::IAsyncOperation<INDLicenseFetchResult> as RtType>::Abi) -> HRESULT,
    fn ReRegistrationAsync(&self, registrationCustomData: <INDCustomData as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn Close(&self) -> HRESULT
}}
impl INDClient {
    #[inline] pub fn add_registration_completed(&self, handler: &foundation::TypedEventHandler<NDClient, INDRegistrationCompletedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_RegistrationCompleted)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_registration_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_RegistrationCompleted)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_proximity_detection_completed(&self, handler: &foundation::TypedEventHandler<NDClient, INDProximityDetectionCompletedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ProximityDetectionCompleted)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_proximity_detection_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ProximityDetectionCompleted)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_license_fetch_completed(&self, handler: &foundation::TypedEventHandler<NDClient, INDLicenseFetchCompletedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_LicenseFetchCompleted)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_license_fetch_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_LicenseFetchCompleted)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_re_registration_needed(&self, handler: &foundation::TypedEventHandler<NDClient, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReRegistrationNeeded)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_re_registration_needed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReRegistrationNeeded)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_closed_caption_data_received(&self, handler: &foundation::TypedEventHandler<NDClient, INDClosedCaptionDataReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ClosedCaptionDataReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_closed_caption_data_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ClosedCaptionDataReceived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_async(&self, contentUrl: &foundation::Uri, startAsyncOptions: u32, registrationCustomData: &INDCustomData, licenseFetchDescriptor: &INDLicenseFetchDescriptor) -> Result<foundation::IAsyncOperation<INDStartResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StartAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(contentUrl) as *const _ as *mut _, startAsyncOptions, get_abi(registrationCustomData) as *const _ as *mut _, get_abi(licenseFetchDescriptor) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn license_fetch_async(&self, licenseFetchDescriptor: &INDLicenseFetchDescriptor) -> Result<foundation::IAsyncOperation<INDLicenseFetchResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).LicenseFetchAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(licenseFetchDescriptor) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn re_registration_async(&self, registrationCustomData: &INDCustomData) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReRegistrationAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(registrationCustomData) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn close(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Close)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class NDClient: INDClient}
impl RtActivatable<INDClientFactory> for NDClient {}
impl NDClient {
    #[inline] pub fn create_instance(downloadEngine: &INDDownloadEngine, streamParser: &INDStreamParser, pMessenger: &INDMessenger) -> Result<NDClient> {
        <Self as RtActivatable<INDClientFactory>>::get_activation_factory().create_instance(downloadEngine, streamParser, pMessenger)
    }
}
DEFINE_CLSID!(NDClient(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,78,68,67,108,105,101,110,116,0]) [CLSID_NDClient]);
DEFINE_IID!(IID_INDClientFactory, 1045683554, 65256, 17695, 176, 212, 247, 6, 204, 163, 224, 55);
RT_INTERFACE!{static interface INDClientFactory(INDClientFactoryVtbl, INDClientFactory_Abi): IInspectable(IInspectableVtbl) [IID_INDClientFactory] {
    fn CreateInstance(&self, downloadEngine: <INDDownloadEngine as RtType>::Abi, streamParser: <INDStreamParser as RtType>::Abi, pMessenger: <INDMessenger as RtType>::Abi, out: *mut <NDClient as RtType>::Abi) -> HRESULT
}}
impl INDClientFactory {
    #[inline] pub fn create_instance(&self, downloadEngine: &INDDownloadEngine, streamParser: &INDStreamParser, pMessenger: &INDMessenger) -> Result<NDClient> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstance)(self.0.as_abi() as *const _ as *mut _, get_abi(downloadEngine) as *const _ as *mut _, get_abi(streamParser) as *const _ as *mut _, get_abi(pMessenger) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(NDClient::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_INDClosedCaptionDataReceivedEventArgs, 1194906271, 49989, 17993, 132, 104, 184, 197, 252, 53, 113, 144);
RT_INTERFACE!{interface INDClosedCaptionDataReceivedEventArgs(INDClosedCaptionDataReceivedEventArgsVtbl, INDClosedCaptionDataReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_INDClosedCaptionDataReceivedEventArgs] {
    fn get_ClosedCaptionDataFormat(&self, out: *mut NDClosedCaptionFormat) -> HRESULT,
    fn get_PresentationTimestamp(&self, out: *mut i64) -> HRESULT,
    fn get_ClosedCaptionData(&self, outSize: *mut u32, out: *mut *mut u8) -> HRESULT
}}
impl INDClosedCaptionDataReceivedEventArgs {
    #[inline] pub fn get_closed_caption_data_format(&self) -> Result<NDClosedCaptionFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ClosedCaptionDataFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_presentation_timestamp(&self) -> Result<i64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PresentationTimestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_closed_caption_data(&self) -> Result<ComArray<u8>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ClosedCaptionData)(self.0.as_abi() as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum NDClosedCaptionFormat: i32 {
    ATSC = 0, SCTE20 = 1, Unknown = 2,
}}
RT_ENUM! { enum NDContentIDType: i32 {
    KeyID = 1, PlayReadyObject = 2, Custom = 3,
}}
DEFINE_IID!(IID_INDCustomData, 4123725788, 11529, 20249, 181, 225, 118, 160, 179, 238, 146, 103);
RT_INTERFACE!{interface INDCustomData(INDCustomDataVtbl, INDCustomData_Abi): IInspectable(IInspectableVtbl) [IID_INDCustomData] {
    fn get_CustomDataTypeID(&self, outSize: *mut u32, out: *mut *mut u8) -> HRESULT,
    fn get_CustomData(&self, outSize: *mut u32, out: *mut *mut u8) -> HRESULT
}}
impl INDCustomData {
    #[inline] pub fn get_custom_data_type_id(&self) -> Result<ComArray<u8>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CustomDataTypeID)(self.0.as_abi() as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
    #[inline] pub fn get_custom_data(&self) -> Result<ComArray<u8>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CustomData)(self.0.as_abi() as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
}
RT_CLASS!{class NDCustomData: INDCustomData}
impl RtActivatable<INDCustomDataFactory> for NDCustomData {}
impl NDCustomData {
    #[inline] pub fn create_instance(customDataTypeIDBytes: &[u8], customDataBytes: &[u8]) -> Result<NDCustomData> {
        <Self as RtActivatable<INDCustomDataFactory>>::get_activation_factory().create_instance(customDataTypeIDBytes, customDataBytes)
    }
}
DEFINE_CLSID!(NDCustomData(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,78,68,67,117,115,116,111,109,68,97,116,97,0]) [CLSID_NDCustomData]);
DEFINE_IID!(IID_INDCustomDataFactory, 3595830699, 13348, 18483, 140, 154, 175, 95, 222, 178, 40, 114);
RT_INTERFACE!{static interface INDCustomDataFactory(INDCustomDataFactoryVtbl, INDCustomDataFactory_Abi): IInspectable(IInspectableVtbl) [IID_INDCustomDataFactory] {
    fn CreateInstance(&self, customDataTypeIDBytesSize: u32, customDataTypeIDBytes: *mut u8, customDataBytesSize: u32, customDataBytes: *mut u8, out: *mut <NDCustomData as RtType>::Abi) -> HRESULT
}}
impl INDCustomDataFactory {
    #[inline] pub fn create_instance(&self, customDataTypeIDBytes: &[u8], customDataBytes: &[u8]) -> Result<NDCustomData> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstance)(self.0.as_abi() as *const _ as *mut _, customDataTypeIDBytes.len() as u32, customDataTypeIDBytes.as_ptr() as *mut _, customDataBytes.len() as u32, customDataBytes.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(NDCustomData::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_INDDownloadEngine, 757218661, 50358, 17464, 141, 70, 185, 110, 109, 15, 178, 31);
RT_INTERFACE!{interface INDDownloadEngine(INDDownloadEngineVtbl, INDDownloadEngine_Abi): IInspectable(IInspectableVtbl) [IID_INDDownloadEngine] {
    fn Open(&self, uri: <foundation::Uri as RtType>::Abi, sessionIDBytesSize: u32, sessionIDBytes: *mut u8) -> HRESULT,
    fn Pause(&self) -> HRESULT,
    fn Resume(&self) -> HRESULT,
    fn Close(&self) -> HRESULT,
    fn Seek(&self, startPosition: foundation::TimeSpan) -> HRESULT,
    fn get_CanSeek(&self, out: *mut bool) -> HRESULT,
    fn get_BufferFullMinThresholdInSamples(&self, out: *mut u32) -> HRESULT,
    fn get_BufferFullMaxThresholdInSamples(&self, out: *mut u32) -> HRESULT,
    fn get_Notifier(&self, out: *mut <NDDownloadEngineNotifier as RtType>::Abi) -> HRESULT
}}
impl INDDownloadEngine {
    #[inline] pub fn open(&self, uri: &foundation::Uri, sessionIDBytes: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Open)(self.0.as_abi() as *const _ as *mut _, get_abi(uri) as *const _ as *mut _, sessionIDBytes.len() as u32, sessionIDBytes.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn pause(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Pause)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn resume(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Resume)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn close(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Close)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn seek(&self, startPosition: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Seek)(self.0.as_abi() as *const _ as *mut _, startPosition);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_can_seek(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanSeek)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_buffer_full_min_threshold_in_samples(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BufferFullMinThresholdInSamples)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_buffer_full_max_threshold_in_samples(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BufferFullMaxThresholdInSamples)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_notifier(&self) -> Result<Option<NDDownloadEngineNotifier>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Notifier)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(NDDownloadEngineNotifier::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_INDDownloadEngineNotifier, 3609244884, 62648, 17712, 168, 9, 145, 147, 165, 113, 231, 252);
RT_INTERFACE!{interface INDDownloadEngineNotifier(INDDownloadEngineNotifierVtbl, INDDownloadEngineNotifier_Abi): IInspectable(IInspectableVtbl) [IID_INDDownloadEngineNotifier] {
    fn OnStreamOpened(&self) -> HRESULT,
    fn OnPlayReadyObjectReceived(&self, dataBytesSize: u32, dataBytes: *mut u8) -> HRESULT,
    fn OnContentIDReceived(&self, licenseFetchDescriptor: <INDLicenseFetchDescriptor as RtType>::Abi) -> HRESULT,
    fn OnDataReceived(&self, dataBytesSize: u32, dataBytes: *mut u8, bytesReceived: u32) -> HRESULT,
    fn OnEndOfStream(&self) -> HRESULT,
    fn OnNetworkError(&self) -> HRESULT
}}
impl INDDownloadEngineNotifier {
    #[inline] pub fn on_stream_opened(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).OnStreamOpened)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn on_play_ready_object_received(&self, dataBytes: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).OnPlayReadyObjectReceived)(self.0.as_abi() as *const _ as *mut _, dataBytes.len() as u32, dataBytes.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn on_content_id_received(&self, licenseFetchDescriptor: &INDLicenseFetchDescriptor) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).OnContentIDReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(licenseFetchDescriptor) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn on_data_received(&self, dataBytes: &[u8], bytesReceived: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).OnDataReceived)(self.0.as_abi() as *const _ as *mut _, dataBytes.len() as u32, dataBytes.as_ptr() as *mut _, bytesReceived);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn on_end_of_stream(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).OnEndOfStream)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn on_network_error(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).OnNetworkError)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class NDDownloadEngineNotifier: INDDownloadEngineNotifier}
impl RtActivatable<IActivationFactory> for NDDownloadEngineNotifier {}
DEFINE_CLSID!(NDDownloadEngineNotifier(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,78,68,68,111,119,110,108,111,97,100,69,110,103,105,110,101,78,111,116,105,102,105,101,114,0]) [CLSID_NDDownloadEngineNotifier]);
DEFINE_IID!(IID_INDLicenseFetchCompletedEventArgs, 518195738, 4530, 17752, 136, 101, 227, 165, 22, 146, 37, 23);
RT_INTERFACE!{interface INDLicenseFetchCompletedEventArgs(INDLicenseFetchCompletedEventArgsVtbl, INDLicenseFetchCompletedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_INDLicenseFetchCompletedEventArgs] {
    fn get_ResponseCustomData(&self, out: *mut <INDCustomData as RtType>::Abi) -> HRESULT
}}
impl INDLicenseFetchCompletedEventArgs {
    #[inline] pub fn get_response_custom_data(&self) -> Result<Option<INDCustomData>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResponseCustomData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(INDCustomData::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_INDLicenseFetchDescriptor, 1419301690, 59014, 18741, 165, 103, 124, 167, 122, 210, 15, 164);
RT_INTERFACE!{interface INDLicenseFetchDescriptor(INDLicenseFetchDescriptorVtbl, INDLicenseFetchDescriptor_Abi): IInspectable(IInspectableVtbl) [IID_INDLicenseFetchDescriptor] {
    fn get_ContentIDType(&self, out: *mut NDContentIDType) -> HRESULT,
    fn get_ContentID(&self, outSize: *mut u32, out: *mut *mut u8) -> HRESULT,
    fn get_LicenseFetchChallengeCustomData(&self, out: *mut <INDCustomData as RtType>::Abi) -> HRESULT,
    fn put_LicenseFetchChallengeCustomData(&self, licenseFetchChallengeCustomData: <INDCustomData as RtType>::Abi) -> HRESULT
}}
impl INDLicenseFetchDescriptor {
    #[inline] pub fn get_content_id_type(&self) -> Result<NDContentIDType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ContentIDType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_content_id(&self) -> Result<ComArray<u8>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ContentID)(self.0.as_abi() as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
    #[inline] pub fn get_license_fetch_challenge_custom_data(&self) -> Result<Option<INDCustomData>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_LicenseFetchChallengeCustomData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(INDCustomData::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_license_fetch_challenge_custom_data(&self, licenseFetchChallengeCustomData: &INDCustomData) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_LicenseFetchChallengeCustomData)(self.0.as_abi() as *const _ as *mut _, get_abi(licenseFetchChallengeCustomData) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class NDLicenseFetchDescriptor: INDLicenseFetchDescriptor}
impl RtActivatable<INDLicenseFetchDescriptorFactory> for NDLicenseFetchDescriptor {}
impl NDLicenseFetchDescriptor {
    #[inline] pub fn create_instance(contentIDType: NDContentIDType, contentIDBytes: &[u8], licenseFetchChallengeCustomData: &INDCustomData) -> Result<NDLicenseFetchDescriptor> {
        <Self as RtActivatable<INDLicenseFetchDescriptorFactory>>::get_activation_factory().create_instance(contentIDType, contentIDBytes, licenseFetchChallengeCustomData)
    }
}
DEFINE_CLSID!(NDLicenseFetchDescriptor(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,78,68,76,105,99,101,110,115,101,70,101,116,99,104,68,101,115,99,114,105,112,116,111,114,0]) [CLSID_NDLicenseFetchDescriptor]);
DEFINE_IID!(IID_INDLicenseFetchDescriptorFactory, 3489862146, 53164, 20224, 174, 106, 151, 175, 128, 184, 72, 242);
RT_INTERFACE!{static interface INDLicenseFetchDescriptorFactory(INDLicenseFetchDescriptorFactoryVtbl, INDLicenseFetchDescriptorFactory_Abi): IInspectable(IInspectableVtbl) [IID_INDLicenseFetchDescriptorFactory] {
    fn CreateInstance(&self, contentIDType: NDContentIDType, contentIDBytesSize: u32, contentIDBytes: *mut u8, licenseFetchChallengeCustomData: <INDCustomData as RtType>::Abi, out: *mut <NDLicenseFetchDescriptor as RtType>::Abi) -> HRESULT
}}
impl INDLicenseFetchDescriptorFactory {
    #[inline] pub fn create_instance(&self, contentIDType: NDContentIDType, contentIDBytes: &[u8], licenseFetchChallengeCustomData: &INDCustomData) -> Result<NDLicenseFetchDescriptor> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstance)(self.0.as_abi() as *const _ as *mut _, contentIDType, contentIDBytes.len() as u32, contentIDBytes.as_ptr() as *mut _, get_abi(licenseFetchChallengeCustomData) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(NDLicenseFetchDescriptor::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_INDLicenseFetchResult, 567514776, 43618, 17919, 165, 255, 128, 55, 229, 67, 56, 37);
RT_INTERFACE!{interface INDLicenseFetchResult(INDLicenseFetchResultVtbl, INDLicenseFetchResult_Abi): IInspectable(IInspectableVtbl) [IID_INDLicenseFetchResult] {
    fn get_ResponseCustomData(&self, out: *mut <INDCustomData as RtType>::Abi) -> HRESULT
}}
impl INDLicenseFetchResult {
    #[inline] pub fn get_response_custom_data(&self) -> Result<Option<INDCustomData>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResponseCustomData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(INDCustomData::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum NDMediaStreamType: i32 {
    Audio = 1, Video = 2,
}}
DEFINE_IID!(IID_INDMessenger, 3559782749, 42843, 18367, 130, 73, 188, 131, 130, 13, 163, 138);
RT_INTERFACE!{interface INDMessenger(INDMessengerVtbl, INDMessenger_Abi): IInspectable(IInspectableVtbl) [IID_INDMessenger] {
    fn SendRegistrationRequestAsync(&self, sessionIDBytesSize: u32, sessionIDBytes: *mut u8, challengeDataBytesSize: u32, challengeDataBytes: *mut u8, out: *mut <foundation::IAsyncOperation<INDSendResult> as RtType>::Abi) -> HRESULT,
    fn SendProximityDetectionStartAsync(&self, pdType: NDProximityDetectionType, transmitterChannelBytesSize: u32, transmitterChannelBytes: *mut u8, sessionIDBytesSize: u32, sessionIDBytes: *mut u8, challengeDataBytesSize: u32, challengeDataBytes: *mut u8, out: *mut <foundation::IAsyncOperation<INDSendResult> as RtType>::Abi) -> HRESULT,
    fn SendProximityDetectionResponseAsync(&self, pdType: NDProximityDetectionType, transmitterChannelBytesSize: u32, transmitterChannelBytes: *mut u8, sessionIDBytesSize: u32, sessionIDBytes: *mut u8, responseDataBytesSize: u32, responseDataBytes: *mut u8, out: *mut <foundation::IAsyncOperation<INDSendResult> as RtType>::Abi) -> HRESULT,
    fn SendLicenseFetchRequestAsync(&self, sessionIDBytesSize: u32, sessionIDBytes: *mut u8, challengeDataBytesSize: u32, challengeDataBytes: *mut u8, out: *mut <foundation::IAsyncOperation<INDSendResult> as RtType>::Abi) -> HRESULT
}}
impl INDMessenger {
    #[inline] pub fn send_registration_request_async(&self, sessionIDBytes: &[u8], challengeDataBytes: &[u8]) -> Result<foundation::IAsyncOperation<INDSendResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SendRegistrationRequestAsync)(self.0.as_abi() as *const _ as *mut _, sessionIDBytes.len() as u32, sessionIDBytes.as_ptr() as *mut _, challengeDataBytes.len() as u32, challengeDataBytes.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn send_proximity_detection_start_async(&self, pdType: NDProximityDetectionType, transmitterChannelBytes: &[u8], sessionIDBytes: &[u8], challengeDataBytes: &[u8]) -> Result<foundation::IAsyncOperation<INDSendResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SendProximityDetectionStartAsync)(self.0.as_abi() as *const _ as *mut _, pdType, transmitterChannelBytes.len() as u32, transmitterChannelBytes.as_ptr() as *mut _, sessionIDBytes.len() as u32, sessionIDBytes.as_ptr() as *mut _, challengeDataBytes.len() as u32, challengeDataBytes.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn send_proximity_detection_response_async(&self, pdType: NDProximityDetectionType, transmitterChannelBytes: &[u8], sessionIDBytes: &[u8], responseDataBytes: &[u8]) -> Result<foundation::IAsyncOperation<INDSendResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SendProximityDetectionResponseAsync)(self.0.as_abi() as *const _ as *mut _, pdType, transmitterChannelBytes.len() as u32, transmitterChannelBytes.as_ptr() as *mut _, sessionIDBytes.len() as u32, sessionIDBytes.as_ptr() as *mut _, responseDataBytes.len() as u32, responseDataBytes.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn send_license_fetch_request_async(&self, sessionIDBytes: &[u8], challengeDataBytes: &[u8]) -> Result<foundation::IAsyncOperation<INDSendResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SendLicenseFetchRequestAsync)(self.0.as_abi() as *const _ as *mut _, sessionIDBytes.len() as u32, sessionIDBytes.as_ptr() as *mut _, challengeDataBytes.len() as u32, challengeDataBytes.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_INDProximityDetectionCompletedEventArgs, 712008488, 55845, 20364, 158, 183, 93, 15, 195, 101, 139, 202);
RT_INTERFACE!{interface INDProximityDetectionCompletedEventArgs(INDProximityDetectionCompletedEventArgsVtbl, INDProximityDetectionCompletedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_INDProximityDetectionCompletedEventArgs] {
    fn get_ProximityDetectionRetryCount(&self, out: *mut u32) -> HRESULT
}}
impl INDProximityDetectionCompletedEventArgs {
    #[inline] pub fn get_proximity_detection_retry_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProximityDetectionRetryCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum NDProximityDetectionType: i32 {
    UDP = 1, TCP = 2, TransportAgnostic = 4,
}}
DEFINE_IID!(IID_INDRegistrationCompletedEventArgs, 2654582349, 43867, 18693, 172, 220, 120, 122, 119, 198, 55, 77);
RT_INTERFACE!{interface INDRegistrationCompletedEventArgs(INDRegistrationCompletedEventArgsVtbl, INDRegistrationCompletedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_INDRegistrationCompletedEventArgs] {
    fn get_ResponseCustomData(&self, out: *mut <INDCustomData as RtType>::Abi) -> HRESULT,
    fn get_TransmitterProperties(&self, out: *mut <INDTransmitterProperties as RtType>::Abi) -> HRESULT,
    fn get_TransmitterCertificateAccepted(&self, out: *mut bool) -> HRESULT,
    fn put_TransmitterCertificateAccepted(&self, accept: bool) -> HRESULT
}}
impl INDRegistrationCompletedEventArgs {
    #[inline] pub fn get_response_custom_data(&self) -> Result<Option<INDCustomData>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResponseCustomData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(INDCustomData::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_transmitter_properties(&self) -> Result<Option<INDTransmitterProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TransmitterProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(INDTransmitterProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_transmitter_certificate_accepted(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TransmitterCertificateAccepted)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_transmitter_certificate_accepted(&self, accept: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_TransmitterCertificateAccepted)(self.0.as_abi() as *const _ as *mut _, accept);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_INDSendResult, 3815265559, 42372, 18333, 144, 183, 214, 137, 199, 191, 124, 128);
RT_INTERFACE!{interface INDSendResult(INDSendResultVtbl, INDSendResult_Abi): IInspectable(IInspectableVtbl) [IID_INDSendResult] {
    fn get_Response(&self, outSize: *mut u32, out: *mut *mut u8) -> HRESULT
}}
impl INDSendResult {
    #[inline] pub fn get_response(&self) -> Result<ComArray<u8>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Response)(self.0.as_abi() as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum NDStartAsyncOptions: i32 {
    MutualAuthentication = 1, WaitForLicenseDescriptor = 2,
}}
DEFINE_IID!(IID_INDStartResult, 2046224750, 62735, 16405, 139, 164, 194, 188, 52, 78, 189, 78);
RT_INTERFACE!{interface INDStartResult(INDStartResultVtbl, INDStartResult_Abi): IInspectable(IInspectableVtbl) [IID_INDStartResult] {
    fn get_MediaStreamSource(&self, out: *mut <super::super::core::MediaStreamSource as RtType>::Abi) -> HRESULT
}}
impl INDStartResult {
    #[inline] pub fn get_media_stream_source(&self) -> Result<Option<super::super::core::MediaStreamSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaStreamSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::core::MediaStreamSource::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_INDStorageFileHelper, 3639656184, 37330, 19783, 163, 249, 234, 255, 78, 219, 114, 159);
RT_INTERFACE!{interface INDStorageFileHelper(INDStorageFileHelperVtbl, INDStorageFileHelper_Abi): IInspectable(IInspectableVtbl) [IID_INDStorageFileHelper] {
    #[cfg(feature="windows-storage")] fn GetFileURLs(&self, file: <crate::windows::storage::IStorageFile as RtType>::Abi, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT
}}
impl INDStorageFileHelper {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_file_urls(&self, file: &crate::windows::storage::IStorageFile) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetFileURLs)(self.0.as_abi() as *const _ as *mut _, get_abi(file) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class NDStorageFileHelper: INDStorageFileHelper}
impl RtActivatable<IActivationFactory> for NDStorageFileHelper {}
DEFINE_CLSID!(NDStorageFileHelper(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,78,68,83,116,111,114,97,103,101,70,105,108,101,72,101,108,112,101,114,0]) [CLSID_NDStorageFileHelper]);
DEFINE_IID!(IID_INDStreamParser, 3770327448, 38806, 16841, 134, 149, 89, 67, 126, 103, 230, 106);
RT_INTERFACE!{interface INDStreamParser(INDStreamParserVtbl, INDStreamParser_Abi): IInspectable(IInspectableVtbl) [IID_INDStreamParser] {
    fn ParseData(&self, dataBytesSize: u32, dataBytes: *mut u8) -> HRESULT,
    fn GetStreamInformation(&self, descriptor: <super::super::core::IMediaStreamDescriptor as RtType>::Abi, streamType: *mut NDMediaStreamType, out: *mut u32) -> HRESULT,
    fn BeginOfStream(&self) -> HRESULT,
    fn EndOfStream(&self) -> HRESULT,
    fn get_Notifier(&self, out: *mut <NDStreamParserNotifier as RtType>::Abi) -> HRESULT
}}
impl INDStreamParser {
    #[inline] pub fn parse_data(&self, dataBytes: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ParseData)(self.0.as_abi() as *const _ as *mut _, dataBytes.len() as u32, dataBytes.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_stream_information(&self, descriptor: &super::super::core::IMediaStreamDescriptor) -> Result<(NDMediaStreamType, u32)> { unsafe { 
        let mut streamType = zeroed(); let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).GetStreamInformation)(self.0.as_abi() as *const _ as *mut _, get_abi(descriptor) as *const _ as *mut _, &mut streamType, &mut out);
        if hr == S_OK { Ok((streamType, out)) } else { err(hr) }
    }}
    #[inline] pub fn begin_of_stream(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).BeginOfStream)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn end_of_stream(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).EndOfStream)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_notifier(&self) -> Result<Option<NDStreamParserNotifier>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Notifier)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(NDStreamParserNotifier::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_INDStreamParserNotifier, 3244797136, 11494, 17004, 172, 229, 94, 146, 117, 254, 167, 21);
RT_INTERFACE!{interface INDStreamParserNotifier(INDStreamParserNotifierVtbl, INDStreamParserNotifier_Abi): IInspectable(IInspectableVtbl) [IID_INDStreamParserNotifier] {
    fn OnContentIDReceived(&self, licenseFetchDescriptor: <INDLicenseFetchDescriptor as RtType>::Abi) -> HRESULT,
    fn OnMediaStreamDescriptorCreated(&self, audioStreamDescriptors: <foundation::collections::IVector<super::super::core::AudioStreamDescriptor> as RtType>::Abi, videoStreamDescriptors: <foundation::collections::IVector<super::super::core::VideoStreamDescriptor> as RtType>::Abi) -> HRESULT,
    fn OnSampleParsed(&self, streamID: u32, streamType: NDMediaStreamType, streamSample: <super::super::core::MediaStreamSample as RtType>::Abi, pts: i64, ccFormat: NDClosedCaptionFormat, ccDataBytesSize: u32, ccDataBytes: *mut u8) -> HRESULT,
    fn OnBeginSetupDecryptor(&self, descriptor: <super::super::core::IMediaStreamDescriptor as RtType>::Abi, keyID: Guid, proBytesSize: u32, proBytes: *mut u8) -> HRESULT
}}
impl INDStreamParserNotifier {
    #[inline] pub fn on_content_id_received(&self, licenseFetchDescriptor: &INDLicenseFetchDescriptor) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).OnContentIDReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(licenseFetchDescriptor) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn on_media_stream_descriptor_created(&self, audioStreamDescriptors: &foundation::collections::IVector<super::super::core::AudioStreamDescriptor>, videoStreamDescriptors: &foundation::collections::IVector<super::super::core::VideoStreamDescriptor>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).OnMediaStreamDescriptorCreated)(self.0.as_abi() as *const _ as *mut _, get_abi(audioStreamDescriptors) as *const _ as *mut _, get_abi(videoStreamDescriptors) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn on_sample_parsed(&self, streamID: u32, streamType: NDMediaStreamType, streamSample: &super::super::core::MediaStreamSample, pts: i64, ccFormat: NDClosedCaptionFormat, ccDataBytes: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).OnSampleParsed)(self.0.as_abi() as *const _ as *mut _, streamID, streamType, get_abi(streamSample) as *const _ as *mut _, pts, ccFormat, ccDataBytes.len() as u32, ccDataBytes.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn on_begin_setup_decryptor(&self, descriptor: &super::super::core::IMediaStreamDescriptor, keyID: Guid, proBytes: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).OnBeginSetupDecryptor)(self.0.as_abi() as *const _ as *mut _, get_abi(descriptor) as *const _ as *mut _, keyID, proBytes.len() as u32, proBytes.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class NDStreamParserNotifier: INDStreamParserNotifier}
impl RtActivatable<IActivationFactory> for NDStreamParserNotifier {}
DEFINE_CLSID!(NDStreamParserNotifier(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,78,68,83,116,114,101,97,109,80,97,114,115,101,114,78,111,116,105,102,105,101,114,0]) [CLSID_NDStreamParserNotifier]);
RT_CLASS!{class NDTCPMessenger: INDMessenger}
impl RtActivatable<INDTCPMessengerFactory> for NDTCPMessenger {}
impl NDTCPMessenger {
    #[inline] pub fn create_instance(remoteHostName: &HStringArg, remoteHostPort: u32) -> Result<NDTCPMessenger> {
        <Self as RtActivatable<INDTCPMessengerFactory>>::get_activation_factory().create_instance(remoteHostName, remoteHostPort)
    }
}
DEFINE_CLSID!(NDTCPMessenger(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,78,68,84,67,80,77,101,115,115,101,110,103,101,114,0]) [CLSID_NDTCPMessenger]);
DEFINE_IID!(IID_INDTCPMessengerFactory, 2111331582, 7065, 20328, 143, 130, 129, 119, 247, 206, 223, 43);
RT_INTERFACE!{static interface INDTCPMessengerFactory(INDTCPMessengerFactoryVtbl, INDTCPMessengerFactory_Abi): IInspectable(IInspectableVtbl) [IID_INDTCPMessengerFactory] {
    fn CreateInstance(&self, remoteHostName: HSTRING, remoteHostPort: u32, out: *mut <NDTCPMessenger as RtType>::Abi) -> HRESULT
}}
impl INDTCPMessengerFactory {
    #[inline] pub fn create_instance(&self, remoteHostName: &HStringArg, remoteHostPort: u32) -> Result<NDTCPMessenger> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstance)(self.0.as_abi() as *const _ as *mut _, remoteHostName.get(), remoteHostPort, &mut out);
        if hr == S_OK { Ok(NDTCPMessenger::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_INDTransmitterProperties, 3845566243, 44111, 19164, 140, 102, 79, 247, 194, 112, 45, 214);
RT_INTERFACE!{interface INDTransmitterProperties(INDTransmitterPropertiesVtbl, INDTransmitterProperties_Abi): IInspectable(IInspectableVtbl) [IID_INDTransmitterProperties] {
    fn get_CertificateType(&self, out: *mut NDCertificateType) -> HRESULT,
    fn get_PlatformIdentifier(&self, out: *mut NDCertificatePlatformID) -> HRESULT,
    fn get_SupportedFeatures(&self, outSize: *mut u32, out: *mut *mut NDCertificateFeature) -> HRESULT,
    fn get_SecurityLevel(&self, out: *mut u32) -> HRESULT,
    fn get_SecurityVersion(&self, out: *mut u32) -> HRESULT,
    fn get_ExpirationDate(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_ClientID(&self, outSize: *mut u32, out: *mut *mut u8) -> HRESULT,
    fn get_ModelDigest(&self, outSize: *mut u32, out: *mut *mut u8) -> HRESULT,
    fn get_ModelManufacturerName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ModelName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ModelNumber(&self, out: *mut HSTRING) -> HRESULT
}}
impl INDTransmitterProperties {
    #[inline] pub fn get_certificate_type(&self) -> Result<NDCertificateType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CertificateType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_platform_identifier(&self) -> Result<NDCertificatePlatformID> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlatformIdentifier)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_features(&self) -> Result<ComArray<NDCertificateFeature>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedFeatures)(self.0.as_abi() as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
    #[inline] pub fn get_security_level(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SecurityLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_security_version(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SecurityVersion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_expiration_date(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExpirationDate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_client_id(&self) -> Result<ComArray<u8>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ClientID)(self.0.as_abi() as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
    #[inline] pub fn get_model_digest(&self) -> Result<ComArray<u8>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ModelDigest)(self.0.as_abi() as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
    #[inline] pub fn get_model_manufacturer_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ModelManufacturerName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_model_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ModelName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_model_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ModelNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPlayReadyContentHeader, 2588117610, 32588, 17710, 136, 189, 1, 72, 198, 56, 122, 44);
RT_INTERFACE!{interface IPlayReadyContentHeader(IPlayReadyContentHeaderVtbl, IPlayReadyContentHeader_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyContentHeader] {
    fn get_KeyId(&self, out: *mut Guid) -> HRESULT,
    fn get_KeyIdString(&self, out: *mut HSTRING) -> HRESULT,
    fn get_LicenseAcquisitionUrl(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_LicenseAcquisitionUserInterfaceUrl(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_DomainServiceId(&self, out: *mut Guid) -> HRESULT,
    fn get_EncryptionType(&self, out: *mut PlayReadyEncryptionAlgorithm) -> HRESULT,
    fn get_CustomAttributes(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DecryptorSetup(&self, out: *mut PlayReadyDecryptorSetup) -> HRESULT,
    fn GetSerializedHeader(&self, outSize: *mut u32, out: *mut *mut u8) -> HRESULT,
    fn get_HeaderWithEmbeddedUpdates(&self, out: *mut <PlayReadyContentHeader as RtType>::Abi) -> HRESULT
}}
impl IPlayReadyContentHeader {
    #[inline] pub fn get_key_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_KeyId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_key_id_string(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_KeyIdString)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_license_acquisition_url(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_LicenseAcquisitionUrl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_license_acquisition_user_interface_url(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_LicenseAcquisitionUserInterfaceUrl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_domain_service_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DomainServiceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_encryption_type(&self) -> Result<PlayReadyEncryptionAlgorithm> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_EncryptionType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_custom_attributes(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CustomAttributes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_decryptor_setup(&self) -> Result<PlayReadyDecryptorSetup> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DecryptorSetup)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_serialized_header(&self) -> Result<ComArray<u8>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetSerializedHeader)(self.0.as_abi() as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
    #[inline] pub fn get_header_with_embedded_updates(&self) -> Result<Option<PlayReadyContentHeader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_HeaderWithEmbeddedUpdates)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PlayReadyContentHeader::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayReadyContentHeader: IPlayReadyContentHeader}
impl RtActivatable<IPlayReadyContentHeaderFactory> for PlayReadyContentHeader {}
impl RtActivatable<IPlayReadyContentHeaderFactory2> for PlayReadyContentHeader {}
impl PlayReadyContentHeader {
    #[inline] pub fn create_instance_from_windows_media_drm_header(headerBytes: &[u8], licenseAcquisitionUrl: &foundation::Uri, licenseAcquisitionUserInterfaceUrl: &foundation::Uri, customAttributes: &HStringArg, domainServiceId: Guid) -> Result<PlayReadyContentHeader> {
        <Self as RtActivatable<IPlayReadyContentHeaderFactory>>::get_activation_factory().create_instance_from_windows_media_drm_header(headerBytes, licenseAcquisitionUrl, licenseAcquisitionUserInterfaceUrl, customAttributes, domainServiceId)
    }
    #[inline] pub fn create_instance_from_components(contentKeyId: Guid, contentKeyIdString: &HStringArg, contentEncryptionAlgorithm: PlayReadyEncryptionAlgorithm, licenseAcquisitionUrl: &foundation::Uri, licenseAcquisitionUserInterfaceUrl: &foundation::Uri, customAttributes: &HStringArg, domainServiceId: Guid) -> Result<PlayReadyContentHeader> {
        <Self as RtActivatable<IPlayReadyContentHeaderFactory>>::get_activation_factory().create_instance_from_components(contentKeyId, contentKeyIdString, contentEncryptionAlgorithm, licenseAcquisitionUrl, licenseAcquisitionUserInterfaceUrl, customAttributes, domainServiceId)
    }
    #[inline] pub fn create_instance_from_play_ready_header(headerBytes: &[u8]) -> Result<PlayReadyContentHeader> {
        <Self as RtActivatable<IPlayReadyContentHeaderFactory>>::get_activation_factory().create_instance_from_play_ready_header(headerBytes)
    }
    #[inline] pub fn create_instance_from_components2(dwFlags: u32, contentKeyIds: &[Guid], contentKeyIdStrings: &[&HStringArg], contentEncryptionAlgorithm: PlayReadyEncryptionAlgorithm, licenseAcquisitionUrl: &foundation::Uri, licenseAcquisitionUserInterfaceUrl: &foundation::Uri, customAttributes: &HStringArg, domainServiceId: Guid) -> Result<PlayReadyContentHeader> {
        <Self as RtActivatable<IPlayReadyContentHeaderFactory2>>::get_activation_factory().create_instance_from_components2(dwFlags, contentKeyIds, contentKeyIdStrings, contentEncryptionAlgorithm, licenseAcquisitionUrl, licenseAcquisitionUserInterfaceUrl, customAttributes, domainServiceId)
    }
}
DEFINE_CLSID!(PlayReadyContentHeader(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,80,108,97,121,82,101,97,100,121,67,111,110,116,101,110,116,72,101,97,100,101,114,0]) [CLSID_PlayReadyContentHeader]);
DEFINE_IID!(IID_IPlayReadyContentHeader2, 899447284, 8576, 18828, 150, 91, 231, 84, 216, 117, 234, 178);
RT_INTERFACE!{interface IPlayReadyContentHeader2(IPlayReadyContentHeader2Vtbl, IPlayReadyContentHeader2_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyContentHeader2] {
    fn get_KeyIds(&self, outSize: *mut u32, out: *mut *mut Guid) -> HRESULT,
    fn get_KeyIdStrings(&self, outSize: *mut u32, out: *mut *mut HSTRING) -> HRESULT
}}
impl IPlayReadyContentHeader2 {
    #[inline] pub fn get_key_ids(&self) -> Result<ComArray<Guid>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_KeyIds)(self.0.as_abi() as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
    #[inline] pub fn get_key_id_strings(&self) -> Result<ComArray<HString>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_KeyIdStrings)(self.0.as_abi() as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPlayReadyContentHeaderFactory, 3415722239, 46936, 18294, 191, 1, 33, 122, 139, 81, 11, 44);
RT_INTERFACE!{static interface IPlayReadyContentHeaderFactory(IPlayReadyContentHeaderFactoryVtbl, IPlayReadyContentHeaderFactory_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyContentHeaderFactory] {
    fn CreateInstanceFromWindowsMediaDrmHeader(&self, headerBytesSize: u32, headerBytes: *mut u8, licenseAcquisitionUrl: <foundation::Uri as RtType>::Abi, licenseAcquisitionUserInterfaceUrl: <foundation::Uri as RtType>::Abi, customAttributes: HSTRING, domainServiceId: Guid, out: *mut <PlayReadyContentHeader as RtType>::Abi) -> HRESULT,
    fn CreateInstanceFromComponents(&self, contentKeyId: Guid, contentKeyIdString: HSTRING, contentEncryptionAlgorithm: PlayReadyEncryptionAlgorithm, licenseAcquisitionUrl: <foundation::Uri as RtType>::Abi, licenseAcquisitionUserInterfaceUrl: <foundation::Uri as RtType>::Abi, customAttributes: HSTRING, domainServiceId: Guid, out: *mut <PlayReadyContentHeader as RtType>::Abi) -> HRESULT,
    fn CreateInstanceFromPlayReadyHeader(&self, headerBytesSize: u32, headerBytes: *mut u8, out: *mut <PlayReadyContentHeader as RtType>::Abi) -> HRESULT
}}
impl IPlayReadyContentHeaderFactory {
    #[inline] pub fn create_instance_from_windows_media_drm_header(&self, headerBytes: &[u8], licenseAcquisitionUrl: &foundation::Uri, licenseAcquisitionUserInterfaceUrl: &foundation::Uri, customAttributes: &HStringArg, domainServiceId: Guid) -> Result<PlayReadyContentHeader> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstanceFromWindowsMediaDrmHeader)(self.0.as_abi() as *const _ as *mut _, headerBytes.len() as u32, headerBytes.as_ptr() as *mut _, get_abi(licenseAcquisitionUrl) as *const _ as *mut _, get_abi(licenseAcquisitionUserInterfaceUrl) as *const _ as *mut _, customAttributes.get(), domainServiceId, &mut out);
        if hr == S_OK { Ok(PlayReadyContentHeader::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_instance_from_components(&self, contentKeyId: Guid, contentKeyIdString: &HStringArg, contentEncryptionAlgorithm: PlayReadyEncryptionAlgorithm, licenseAcquisitionUrl: &foundation::Uri, licenseAcquisitionUserInterfaceUrl: &foundation::Uri, customAttributes: &HStringArg, domainServiceId: Guid) -> Result<PlayReadyContentHeader> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstanceFromComponents)(self.0.as_abi() as *const _ as *mut _, contentKeyId, contentKeyIdString.get(), contentEncryptionAlgorithm, get_abi(licenseAcquisitionUrl) as *const _ as *mut _, get_abi(licenseAcquisitionUserInterfaceUrl) as *const _ as *mut _, customAttributes.get(), domainServiceId, &mut out);
        if hr == S_OK { Ok(PlayReadyContentHeader::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_instance_from_play_ready_header(&self, headerBytes: &[u8]) -> Result<PlayReadyContentHeader> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstanceFromPlayReadyHeader)(self.0.as_abi() as *const _ as *mut _, headerBytes.len() as u32, headerBytes.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(PlayReadyContentHeader::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPlayReadyContentHeaderFactory2, 3508772085, 44653, 18296, 151, 253, 110, 58, 46, 234, 219, 235);
RT_INTERFACE!{static interface IPlayReadyContentHeaderFactory2(IPlayReadyContentHeaderFactory2Vtbl, IPlayReadyContentHeaderFactory2_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyContentHeaderFactory2] {
    fn CreateInstanceFromComponents2(&self, dwFlags: u32, contentKeyIdsSize: u32, contentKeyIds: *mut Guid, contentKeyIdStringsSize: u32, contentKeyIdStrings: *mut HSTRING, contentEncryptionAlgorithm: PlayReadyEncryptionAlgorithm, licenseAcquisitionUrl: <foundation::Uri as RtType>::Abi, licenseAcquisitionUserInterfaceUrl: <foundation::Uri as RtType>::Abi, customAttributes: HSTRING, domainServiceId: Guid, out: *mut <PlayReadyContentHeader as RtType>::Abi) -> HRESULT
}}
impl IPlayReadyContentHeaderFactory2 {
    #[inline] pub fn create_instance_from_components2(&self, dwFlags: u32, contentKeyIds: &[Guid], contentKeyIdStrings: &[&HStringArg], contentEncryptionAlgorithm: PlayReadyEncryptionAlgorithm, licenseAcquisitionUrl: &foundation::Uri, licenseAcquisitionUserInterfaceUrl: &foundation::Uri, customAttributes: &HStringArg, domainServiceId: Guid) -> Result<PlayReadyContentHeader> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstanceFromComponents2)(self.0.as_abi() as *const _ as *mut _, dwFlags, contentKeyIds.len() as u32, contentKeyIds.as_ptr() as *mut _, contentKeyIdStrings.len() as u32, contentKeyIdStrings.as_ptr() as *mut _, contentEncryptionAlgorithm, get_abi(licenseAcquisitionUrl) as *const _ as *mut _, get_abi(licenseAcquisitionUserInterfaceUrl) as *const _ as *mut _, customAttributes.get(), domainServiceId, &mut out);
        if hr == S_OK { Ok(PlayReadyContentHeader::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPlayReadyContentResolver, 4227671331, 36973, 18818, 166, 184, 104, 73, 86, 90, 124, 232);
RT_INTERFACE!{static interface IPlayReadyContentResolver(IPlayReadyContentResolverVtbl, IPlayReadyContentResolver_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyContentResolver] {
    fn ServiceRequest(&self, contentHeader: <PlayReadyContentHeader as RtType>::Abi, out: *mut <IPlayReadyServiceRequest as RtType>::Abi) -> HRESULT
}}
impl IPlayReadyContentResolver {
    #[inline] pub fn service_request(&self, contentHeader: &PlayReadyContentHeader) -> Result<Option<IPlayReadyServiceRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ServiceRequest)(self.0.as_abi() as *const _ as *mut _, get_abi(contentHeader) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IPlayReadyServiceRequest::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class PlayReadyContentResolver}
impl RtActivatable<IPlayReadyContentResolver> for PlayReadyContentResolver {}
impl PlayReadyContentResolver {
    #[inline] pub fn service_request(contentHeader: &PlayReadyContentHeader) -> Result<Option<IPlayReadyServiceRequest>> {
        <Self as RtActivatable<IPlayReadyContentResolver>>::get_activation_factory().service_request(contentHeader)
    }
}
DEFINE_CLSID!(PlayReadyContentResolver(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,80,108,97,121,82,101,97,100,121,67,111,110,116,101,110,116,82,101,115,111,108,118,101,114,0]) [CLSID_PlayReadyContentResolver]);
RT_ENUM! { enum PlayReadyDecryptorSetup: i32 {
    Uninitialized = 0, OnDemand = 1,
}}
DEFINE_IID!(IID_IPlayReadyDomain, 2915865516, 38886, 17391, 149, 228, 215, 134, 143, 59, 22, 169);
RT_INTERFACE!{interface IPlayReadyDomain(IPlayReadyDomainVtbl, IPlayReadyDomain_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyDomain] {
    fn get_AccountId(&self, out: *mut Guid) -> HRESULT,
    fn get_ServiceId(&self, out: *mut Guid) -> HRESULT,
    fn get_Revision(&self, out: *mut u32) -> HRESULT,
    fn get_FriendlyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DomainJoinUrl(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT
}}
impl IPlayReadyDomain {
    #[inline] pub fn get_account_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AccountId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_revision(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Revision)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_friendly_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FriendlyName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_domain_join_url(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DomainJoinUrl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayReadyDomain: IPlayReadyDomain}
RT_CLASS!{class PlayReadyDomainIterable: foundation::collections::IIterable<IPlayReadyDomain>}
impl RtActivatable<IPlayReadyDomainIterableFactory> for PlayReadyDomainIterable {}
impl PlayReadyDomainIterable {
    #[inline] pub fn create_instance(domainAccountId: Guid) -> Result<PlayReadyDomainIterable> {
        <Self as RtActivatable<IPlayReadyDomainIterableFactory>>::get_activation_factory().create_instance(domainAccountId)
    }
}
DEFINE_CLSID!(PlayReadyDomainIterable(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,80,108,97,121,82,101,97,100,121,68,111,109,97,105,110,73,116,101,114,97,98,108,101,0]) [CLSID_PlayReadyDomainIterable]);
DEFINE_IID!(IID_IPlayReadyDomainIterableFactory, 1307804910, 12577, 19955, 165, 232, 208, 194, 76, 5, 0, 252);
RT_INTERFACE!{static interface IPlayReadyDomainIterableFactory(IPlayReadyDomainIterableFactoryVtbl, IPlayReadyDomainIterableFactory_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyDomainIterableFactory] {
    fn CreateInstance(&self, domainAccountId: Guid, out: *mut <PlayReadyDomainIterable as RtType>::Abi) -> HRESULT
}}
impl IPlayReadyDomainIterableFactory {
    #[inline] pub fn create_instance(&self, domainAccountId: Guid) -> Result<PlayReadyDomainIterable> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstance)(self.0.as_abi() as *const _ as *mut _, domainAccountId, &mut out);
        if hr == S_OK { Ok(PlayReadyDomainIterable::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayReadyDomainIterator: foundation::collections::IIterator<IPlayReadyDomain>}
DEFINE_IID!(IID_IPlayReadyDomainJoinServiceRequest, 387664474, 16479, 18233, 176, 64, 103, 185, 240, 195, 135, 88);
RT_INTERFACE!{interface IPlayReadyDomainJoinServiceRequest(IPlayReadyDomainJoinServiceRequestVtbl, IPlayReadyDomainJoinServiceRequest_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyDomainJoinServiceRequest] {
    fn get_DomainAccountId(&self, out: *mut Guid) -> HRESULT,
    fn put_DomainAccountId(&self, value: Guid) -> HRESULT,
    fn get_DomainFriendlyName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DomainFriendlyName(&self, value: HSTRING) -> HRESULT,
    fn get_DomainServiceId(&self, out: *mut Guid) -> HRESULT,
    fn put_DomainServiceId(&self, value: Guid) -> HRESULT
}}
impl IPlayReadyDomainJoinServiceRequest {
    #[inline] pub fn get_domain_account_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DomainAccountId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_domain_account_id(&self, value: Guid) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DomainAccountId)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_domain_friendly_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DomainFriendlyName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_domain_friendly_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DomainFriendlyName)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_domain_service_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DomainServiceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_domain_service_id(&self, value: Guid) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DomainServiceId)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayReadyDomainJoinServiceRequest: IPlayReadyDomainJoinServiceRequest}
impl RtActivatable<IActivationFactory> for PlayReadyDomainJoinServiceRequest {}
DEFINE_CLSID!(PlayReadyDomainJoinServiceRequest(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,80,108,97,121,82,101,97,100,121,68,111,109,97,105,110,74,111,105,110,83,101,114,118,105,99,101,82,101,113,117,101,115,116,0]) [CLSID_PlayReadyDomainJoinServiceRequest]);
DEFINE_IID!(IID_IPlayReadyDomainLeaveServiceRequest, 103635134, 38829, 18711, 170, 3, 70, 212, 194, 82, 212, 100);
RT_INTERFACE!{interface IPlayReadyDomainLeaveServiceRequest(IPlayReadyDomainLeaveServiceRequestVtbl, IPlayReadyDomainLeaveServiceRequest_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyDomainLeaveServiceRequest] {
    fn get_DomainAccountId(&self, out: *mut Guid) -> HRESULT,
    fn put_DomainAccountId(&self, value: Guid) -> HRESULT,
    fn get_DomainServiceId(&self, out: *mut Guid) -> HRESULT,
    fn put_DomainServiceId(&self, value: Guid) -> HRESULT
}}
impl IPlayReadyDomainLeaveServiceRequest {
    #[inline] pub fn get_domain_account_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DomainAccountId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_domain_account_id(&self, value: Guid) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DomainAccountId)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_domain_service_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DomainServiceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_domain_service_id(&self, value: Guid) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DomainServiceId)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayReadyDomainLeaveServiceRequest: IPlayReadyDomainLeaveServiceRequest}
impl RtActivatable<IActivationFactory> for PlayReadyDomainLeaveServiceRequest {}
DEFINE_CLSID!(PlayReadyDomainLeaveServiceRequest(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,80,108,97,121,82,101,97,100,121,68,111,109,97,105,110,76,101,97,118,101,83,101,114,118,105,99,101,82,101,113,117,101,115,116,0]) [CLSID_PlayReadyDomainLeaveServiceRequest]);
RT_ENUM! { enum PlayReadyEncryptionAlgorithm: i32 {
    Unprotected = 0, Aes128Ctr = 1, Cocktail = 4, Aes128Cbc = 5, Unspecified = 65535, Uninitialized = 2147483647,
}}
RT_ENUM! { enum PlayReadyHardwareDRMFeatures: i32 {
    HardwareDRM = 1, HEVC = 2, Aes128Cbc = 3,
}}
DEFINE_IID!(IID_IPlayReadyIndividualizationServiceRequest, 569747563, 140, 17937, 171, 47, 170, 166, 198, 159, 14, 36);
RT_INTERFACE!{interface IPlayReadyIndividualizationServiceRequest(IPlayReadyIndividualizationServiceRequestVtbl, IPlayReadyIndividualizationServiceRequest_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyIndividualizationServiceRequest] {
    
}}
RT_CLASS!{class PlayReadyIndividualizationServiceRequest: IPlayReadyIndividualizationServiceRequest}
impl RtActivatable<IActivationFactory> for PlayReadyIndividualizationServiceRequest {}
DEFINE_CLSID!(PlayReadyIndividualizationServiceRequest(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,80,108,97,121,82,101,97,100,121,73,110,100,105,118,105,100,117,97,108,105,122,97,116,105,111,110,83,101,114,118,105,99,101,82,101,113,117,101,115,116,0]) [CLSID_PlayReadyIndividualizationServiceRequest]);
RT_ENUM! { enum PlayReadyITADataFormat: i32 {
    SerializedProperties = 0, SerializedProperties_WithContentProtectionWrapper = 1,
}}
DEFINE_IID!(IID_IPlayReadyITADataGenerator, 608463758, 4281, 17712, 178, 91, 144, 26, 128, 41, 169, 178);
RT_INTERFACE!{interface IPlayReadyITADataGenerator(IPlayReadyITADataGeneratorVtbl, IPlayReadyITADataGenerator_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyITADataGenerator] {
    fn GenerateData(&self, guidCPSystemId: Guid, countOfStreams: u32, configuration: <foundation::collections::IPropertySet as RtType>::Abi, format: PlayReadyITADataFormat, outSize: *mut u32, out: *mut *mut u8) -> HRESULT
}}
impl IPlayReadyITADataGenerator {
    #[inline] pub fn generate_data(&self, guidCPSystemId: Guid, countOfStreams: u32, configuration: &foundation::collections::IPropertySet, format: PlayReadyITADataFormat) -> Result<ComArray<u8>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GenerateData)(self.0.as_abi() as *const _ as *mut _, guidCPSystemId, countOfStreams, get_abi(configuration) as *const _ as *mut _, format, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayReadyITADataGenerator: IPlayReadyITADataGenerator}
impl RtActivatable<IActivationFactory> for PlayReadyITADataGenerator {}
DEFINE_CLSID!(PlayReadyITADataGenerator(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,80,108,97,121,82,101,97,100,121,73,84,65,68,97,116,97,71,101,110,101,114,97,116,111,114,0]) [CLSID_PlayReadyITADataGenerator]);
DEFINE_IID!(IID_IPlayReadyLicense, 3997649998, 64060, 16717, 169, 242, 63, 252, 30, 248, 50, 212);
RT_INTERFACE!{interface IPlayReadyLicense(IPlayReadyLicenseVtbl, IPlayReadyLicense_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyLicense] {
    fn get_FullyEvaluated(&self, out: *mut bool) -> HRESULT,
    fn get_UsableForPlay(&self, out: *mut bool) -> HRESULT,
    fn get_ExpirationDate(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_ExpireAfterFirstPlay(&self, out: *mut u32) -> HRESULT,
    fn get_DomainAccountID(&self, out: *mut Guid) -> HRESULT,
    fn get_ChainDepth(&self, out: *mut u32) -> HRESULT,
    fn GetKIDAtChainDepth(&self, chainDepth: u32, out: *mut Guid) -> HRESULT
}}
impl IPlayReadyLicense {
    #[inline] pub fn get_fully_evaluated(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FullyEvaluated)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usable_for_play(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsableForPlay)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_expiration_date(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExpirationDate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_expire_after_first_play(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExpireAfterFirstPlay)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_domain_account_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DomainAccountID)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_chain_depth(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ChainDepth)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_kid_at_chain_depth(&self, chainDepth: u32) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).GetKIDAtChainDepth)(self.0.as_abi() as *const _ as *mut _, chainDepth, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayReadyLicense: IPlayReadyLicense}
DEFINE_IID!(IID_IPlayReadyLicense2, 821356455, 55523, 18592, 188, 218, 255, 159, 64, 83, 4, 54);
RT_INTERFACE!{interface IPlayReadyLicense2(IPlayReadyLicense2Vtbl, IPlayReadyLicense2_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyLicense2] {
    fn get_SecureStopId(&self, out: *mut Guid) -> HRESULT,
    fn get_SecurityLevel(&self, out: *mut u32) -> HRESULT,
    fn get_InMemoryOnly(&self, out: *mut bool) -> HRESULT,
    fn get_ExpiresInRealTime(&self, out: *mut bool) -> HRESULT
}}
impl IPlayReadyLicense2 {
    #[inline] pub fn get_secure_stop_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SecureStopId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_security_level(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SecurityLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_in_memory_only(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InMemoryOnly)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_expires_in_real_time(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExpiresInRealTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPlayReadyLicenseAcquisitionServiceRequest, 1569062725, 16031, 20296, 147, 225, 149, 48, 200, 213, 140, 62);
RT_INTERFACE!{interface IPlayReadyLicenseAcquisitionServiceRequest(IPlayReadyLicenseAcquisitionServiceRequestVtbl, IPlayReadyLicenseAcquisitionServiceRequest_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyLicenseAcquisitionServiceRequest] {
    fn get_ContentHeader(&self, out: *mut <PlayReadyContentHeader as RtType>::Abi) -> HRESULT,
    fn put_ContentHeader(&self, value: <PlayReadyContentHeader as RtType>::Abi) -> HRESULT,
    fn get_DomainServiceId(&self, out: *mut Guid) -> HRESULT,
    fn put_DomainServiceId(&self, value: Guid) -> HRESULT
}}
impl IPlayReadyLicenseAcquisitionServiceRequest {
    #[inline] pub fn get_content_header(&self) -> Result<Option<PlayReadyContentHeader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ContentHeader)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PlayReadyContentHeader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_content_header(&self, value: &PlayReadyContentHeader) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ContentHeader)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_domain_service_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DomainServiceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_domain_service_id(&self, value: Guid) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DomainServiceId)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayReadyLicenseAcquisitionServiceRequest: IPlayReadyLicenseAcquisitionServiceRequest}
impl RtActivatable<IActivationFactory> for PlayReadyLicenseAcquisitionServiceRequest {}
DEFINE_CLSID!(PlayReadyLicenseAcquisitionServiceRequest(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,80,108,97,121,82,101,97,100,121,76,105,99,101,110,115,101,65,99,113,117,105,115,105,116,105,111,110,83,101,114,118,105,99,101,82,101,113,117,101,115,116,0]) [CLSID_PlayReadyLicenseAcquisitionServiceRequest]);
DEFINE_IID!(IID_IPlayReadyLicenseAcquisitionServiceRequest2, 3086638773, 65036, 45605, 188, 96, 90, 158, 221, 50, 206, 181);
RT_INTERFACE!{interface IPlayReadyLicenseAcquisitionServiceRequest2(IPlayReadyLicenseAcquisitionServiceRequest2Vtbl, IPlayReadyLicenseAcquisitionServiceRequest2_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyLicenseAcquisitionServiceRequest2] {
    fn get_SessionId(&self, out: *mut Guid) -> HRESULT
}}
impl IPlayReadyLicenseAcquisitionServiceRequest2 {
    #[inline] pub fn get_session_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SessionId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPlayReadyLicenseAcquisitionServiceRequest3, 961437517, 32629, 17165, 178, 231, 127, 117, 243, 75, 45, 117);
RT_INTERFACE!{interface IPlayReadyLicenseAcquisitionServiceRequest3(IPlayReadyLicenseAcquisitionServiceRequest3Vtbl, IPlayReadyLicenseAcquisitionServiceRequest3_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyLicenseAcquisitionServiceRequest3] {
    fn CreateLicenseIterable(&self, contentHeader: <PlayReadyContentHeader as RtType>::Abi, fullyEvaluated: bool, out: *mut <PlayReadyLicenseIterable as RtType>::Abi) -> HRESULT
}}
impl IPlayReadyLicenseAcquisitionServiceRequest3 {
    #[inline] pub fn create_license_iterable(&self, contentHeader: &PlayReadyContentHeader, fullyEvaluated: bool) -> Result<Option<PlayReadyLicenseIterable>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateLicenseIterable)(self.0.as_abi() as *const _ as *mut _, get_abi(contentHeader) as *const _ as *mut _, fullyEvaluated, &mut out);
        if hr == S_OK { Ok(PlayReadyLicenseIterable::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayReadyLicenseIterable: foundation::collections::IIterable<IPlayReadyLicense>}
impl RtActivatable<IPlayReadyLicenseIterableFactory> for PlayReadyLicenseIterable {}
impl RtActivatable<IActivationFactory> for PlayReadyLicenseIterable {}
impl PlayReadyLicenseIterable {
    #[inline] pub fn create_instance(contentHeader: &PlayReadyContentHeader, fullyEvaluated: bool) -> Result<PlayReadyLicenseIterable> {
        <Self as RtActivatable<IPlayReadyLicenseIterableFactory>>::get_activation_factory().create_instance(contentHeader, fullyEvaluated)
    }
}
DEFINE_CLSID!(PlayReadyLicenseIterable(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,80,108,97,121,82,101,97,100,121,76,105,99,101,110,115,101,73,116,101,114,97,98,108,101,0]) [CLSID_PlayReadyLicenseIterable]);
DEFINE_IID!(IID_IPlayReadyLicenseIterableFactory, 3558317832, 2103, 18808, 142, 104, 190, 66, 147, 200, 215, 166);
RT_INTERFACE!{static interface IPlayReadyLicenseIterableFactory(IPlayReadyLicenseIterableFactoryVtbl, IPlayReadyLicenseIterableFactory_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyLicenseIterableFactory] {
    fn CreateInstance(&self, contentHeader: <PlayReadyContentHeader as RtType>::Abi, fullyEvaluated: bool, out: *mut <PlayReadyLicenseIterable as RtType>::Abi) -> HRESULT
}}
impl IPlayReadyLicenseIterableFactory {
    #[inline] pub fn create_instance(&self, contentHeader: &PlayReadyContentHeader, fullyEvaluated: bool) -> Result<PlayReadyLicenseIterable> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstance)(self.0.as_abi() as *const _ as *mut _, get_abi(contentHeader) as *const _ as *mut _, fullyEvaluated, &mut out);
        if hr == S_OK { Ok(PlayReadyLicenseIterable::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayReadyLicenseIterator: foundation::collections::IIterator<IPlayReadyLicense>}
DEFINE_IID!(IID_IPlayReadyLicenseManagement, 2867536193, 2391, 17413, 184, 146, 139, 243, 236, 93, 173, 217);
RT_INTERFACE!{static interface IPlayReadyLicenseManagement(IPlayReadyLicenseManagementVtbl, IPlayReadyLicenseManagement_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyLicenseManagement] {
    fn DeleteLicenses(&self, contentHeader: <PlayReadyContentHeader as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IPlayReadyLicenseManagement {
    #[inline] pub fn delete_licenses(&self, contentHeader: &PlayReadyContentHeader) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).DeleteLicenses)(self.0.as_abi() as *const _ as *mut _, get_abi(contentHeader) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class PlayReadyLicenseManagement}
impl RtActivatable<IPlayReadyLicenseManagement> for PlayReadyLicenseManagement {}
impl PlayReadyLicenseManagement {
    #[inline] pub fn delete_licenses(contentHeader: &PlayReadyContentHeader) -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<IPlayReadyLicenseManagement>>::get_activation_factory().delete_licenses(contentHeader)
    }
}
DEFINE_CLSID!(PlayReadyLicenseManagement(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,80,108,97,121,82,101,97,100,121,76,105,99,101,110,115,101,77,97,110,97,103,101,109,101,110,116,0]) [CLSID_PlayReadyLicenseManagement]);
DEFINE_IID!(IID_IPlayReadyLicenseSession, 2708617785, 34810, 20445, 171, 187, 169, 114, 14, 132, 82, 89);
RT_INTERFACE!{interface IPlayReadyLicenseSession(IPlayReadyLicenseSessionVtbl, IPlayReadyLicenseSession_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyLicenseSession] {
    fn CreateLAServiceRequest(&self, out: *mut <IPlayReadyLicenseAcquisitionServiceRequest as RtType>::Abi) -> HRESULT,
    fn ConfigureMediaProtectionManager(&self, mpm: <super::MediaProtectionManager as RtType>::Abi) -> HRESULT
}}
impl IPlayReadyLicenseSession {
    #[inline] pub fn create_la_service_request(&self) -> Result<Option<IPlayReadyLicenseAcquisitionServiceRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateLAServiceRequest)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IPlayReadyLicenseAcquisitionServiceRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn configure_media_protection_manager(&self, mpm: &super::MediaProtectionManager) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ConfigureMediaProtectionManager)(self.0.as_abi() as *const _ as *mut _, get_abi(mpm) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayReadyLicenseSession: IPlayReadyLicenseSession}
impl RtActivatable<IPlayReadyLicenseSessionFactory> for PlayReadyLicenseSession {}
impl PlayReadyLicenseSession {
    #[inline] pub fn create_instance(configuration: &foundation::collections::IPropertySet) -> Result<PlayReadyLicenseSession> {
        <Self as RtActivatable<IPlayReadyLicenseSessionFactory>>::get_activation_factory().create_instance(configuration)
    }
}
DEFINE_CLSID!(PlayReadyLicenseSession(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,80,108,97,121,82,101,97,100,121,76,105,99,101,110,115,101,83,101,115,115,105,111,110,0]) [CLSID_PlayReadyLicenseSession]);
DEFINE_IID!(IID_IPlayReadyLicenseSession2, 1225375290, 15085, 18006, 138, 215, 238, 15, 215, 121, 149, 16);
RT_INTERFACE!{interface IPlayReadyLicenseSession2(IPlayReadyLicenseSession2Vtbl, IPlayReadyLicenseSession2_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyLicenseSession2] {
    fn CreateLicenseIterable(&self, contentHeader: <PlayReadyContentHeader as RtType>::Abi, fullyEvaluated: bool, out: *mut <PlayReadyLicenseIterable as RtType>::Abi) -> HRESULT
}}
impl IPlayReadyLicenseSession2 {
    #[inline] pub fn create_license_iterable(&self, contentHeader: &PlayReadyContentHeader, fullyEvaluated: bool) -> Result<Option<PlayReadyLicenseIterable>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateLicenseIterable)(self.0.as_abi() as *const _ as *mut _, get_abi(contentHeader) as *const _ as *mut _, fullyEvaluated, &mut out);
        if hr == S_OK { Ok(PlayReadyLicenseIterable::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPlayReadyLicenseSessionFactory, 1648961177, 25895, 17054, 152, 190, 72, 215, 152, 172, 39, 57);
RT_INTERFACE!{static interface IPlayReadyLicenseSessionFactory(IPlayReadyLicenseSessionFactoryVtbl, IPlayReadyLicenseSessionFactory_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyLicenseSessionFactory] {
    fn CreateInstance(&self, configuration: <foundation::collections::IPropertySet as RtType>::Abi, out: *mut <PlayReadyLicenseSession as RtType>::Abi) -> HRESULT
}}
impl IPlayReadyLicenseSessionFactory {
    #[inline] pub fn create_instance(&self, configuration: &foundation::collections::IPropertySet) -> Result<PlayReadyLicenseSession> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstance)(self.0.as_abi() as *const _ as *mut _, get_abi(configuration) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PlayReadyLicenseSession::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPlayReadyMeteringReportServiceRequest, 3240829724, 3789, 20241, 161, 133, 30, 36, 164, 166, 127, 183);
RT_INTERFACE!{interface IPlayReadyMeteringReportServiceRequest(IPlayReadyMeteringReportServiceRequestVtbl, IPlayReadyMeteringReportServiceRequest_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyMeteringReportServiceRequest] {
    fn get_MeteringCertificate(&self, outSize: *mut u32, out: *mut *mut u8) -> HRESULT,
    fn put_MeteringCertificate(&self, meteringCertBytesSize: u32, meteringCertBytes: *mut u8) -> HRESULT
}}
impl IPlayReadyMeteringReportServiceRequest {
    #[inline] pub fn get_metering_certificate(&self) -> Result<ComArray<u8>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MeteringCertificate)(self.0.as_abi() as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
    #[inline] pub fn set_metering_certificate(&self, meteringCertBytes: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MeteringCertificate)(self.0.as_abi() as *const _ as *mut _, meteringCertBytes.len() as u32, meteringCertBytes.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayReadyMeteringReportServiceRequest: IPlayReadyMeteringReportServiceRequest}
impl RtActivatable<IActivationFactory> for PlayReadyMeteringReportServiceRequest {}
DEFINE_CLSID!(PlayReadyMeteringReportServiceRequest(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,80,108,97,121,82,101,97,100,121,77,101,116,101,114,105,110,103,82,101,112,111,114,116,83,101,114,118,105,99,101,82,101,113,117,101,115,116,0]) [CLSID_PlayReadyMeteringReportServiceRequest]);
DEFINE_IID!(IID_IPlayReadyRevocationServiceRequest, 1413310124, 64240, 17760, 132, 165, 14, 74, 206, 201, 57, 228);
RT_INTERFACE!{interface IPlayReadyRevocationServiceRequest(IPlayReadyRevocationServiceRequestVtbl, IPlayReadyRevocationServiceRequest_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyRevocationServiceRequest] {
    
}}
RT_CLASS!{class PlayReadyRevocationServiceRequest: IPlayReadyRevocationServiceRequest}
impl RtActivatable<IActivationFactory> for PlayReadyRevocationServiceRequest {}
DEFINE_CLSID!(PlayReadyRevocationServiceRequest(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,80,108,97,121,82,101,97,100,121,82,101,118,111,99,97,116,105,111,110,83,101,114,118,105,99,101,82,101,113,117,101,115,116,0]) [CLSID_PlayReadyRevocationServiceRequest]);
RT_CLASS!{class PlayReadySecureStopIterable: foundation::collections::IIterable<IPlayReadySecureStopServiceRequest>}
impl RtActivatable<IPlayReadySecureStopIterableFactory> for PlayReadySecureStopIterable {}
impl PlayReadySecureStopIterable {
    #[inline] pub fn create_instance(publisherCertBytes: &[u8]) -> Result<PlayReadySecureStopIterable> {
        <Self as RtActivatable<IPlayReadySecureStopIterableFactory>>::get_activation_factory().create_instance(publisherCertBytes)
    }
}
DEFINE_CLSID!(PlayReadySecureStopIterable(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,80,108,97,121,82,101,97,100,121,83,101,99,117,114,101,83,116,111,112,73,116,101,114,97,98,108,101,0]) [CLSID_PlayReadySecureStopIterable]);
DEFINE_IID!(IID_IPlayReadySecureStopIterableFactory, 1595867493, 16916, 19870, 129, 235, 232, 159, 157, 41, 74, 238);
RT_INTERFACE!{static interface IPlayReadySecureStopIterableFactory(IPlayReadySecureStopIterableFactoryVtbl, IPlayReadySecureStopIterableFactory_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadySecureStopIterableFactory] {
    fn CreateInstance(&self, publisherCertBytesSize: u32, publisherCertBytes: *mut u8, out: *mut <PlayReadySecureStopIterable as RtType>::Abi) -> HRESULT
}}
impl IPlayReadySecureStopIterableFactory {
    #[inline] pub fn create_instance(&self, publisherCertBytes: &[u8]) -> Result<PlayReadySecureStopIterable> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstance)(self.0.as_abi() as *const _ as *mut _, publisherCertBytes.len() as u32, publisherCertBytes.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(PlayReadySecureStopIterable::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayReadySecureStopIterator: foundation::collections::IIterator<IPlayReadySecureStopServiceRequest>}
DEFINE_IID!(IID_IPlayReadySecureStopServiceRequest, 3041926885, 447, 17409, 150, 119, 5, 99, 10, 106, 76, 200);
RT_INTERFACE!{interface IPlayReadySecureStopServiceRequest(IPlayReadySecureStopServiceRequestVtbl, IPlayReadySecureStopServiceRequest_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadySecureStopServiceRequest] {
    fn get_SessionID(&self, out: *mut Guid) -> HRESULT,
    fn get_StartTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_UpdateTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_Stopped(&self, out: *mut bool) -> HRESULT,
    fn get_PublisherCertificate(&self, outSize: *mut u32, out: *mut *mut u8) -> HRESULT
}}
impl IPlayReadySecureStopServiceRequest {
    #[inline] pub fn get_session_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SessionID)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_start_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StartTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_update_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UpdateTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_stopped(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Stopped)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_publisher_certificate(&self) -> Result<ComArray<u8>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PublisherCertificate)(self.0.as_abi() as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayReadySecureStopServiceRequest: IPlayReadySecureStopServiceRequest}
impl RtActivatable<IPlayReadySecureStopServiceRequestFactory> for PlayReadySecureStopServiceRequest {}
impl PlayReadySecureStopServiceRequest {
    #[inline] pub fn create_instance(publisherCertBytes: &[u8]) -> Result<PlayReadySecureStopServiceRequest> {
        <Self as RtActivatable<IPlayReadySecureStopServiceRequestFactory>>::get_activation_factory().create_instance(publisherCertBytes)
    }
    #[inline] pub fn create_instance_from_session_id(sessionID: Guid, publisherCertBytes: &[u8]) -> Result<PlayReadySecureStopServiceRequest> {
        <Self as RtActivatable<IPlayReadySecureStopServiceRequestFactory>>::get_activation_factory().create_instance_from_session_id(sessionID, publisherCertBytes)
    }
}
DEFINE_CLSID!(PlayReadySecureStopServiceRequest(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,80,108,97,121,82,101,97,100,121,83,101,99,117,114,101,83,116,111,112,83,101,114,118,105,99,101,82,101,113,117,101,115,116,0]) [CLSID_PlayReadySecureStopServiceRequest]);
DEFINE_IID!(IID_IPlayReadySecureStopServiceRequestFactory, 239373001, 59006, 18766, 159, 73, 98, 133, 67, 140, 118, 207);
RT_INTERFACE!{static interface IPlayReadySecureStopServiceRequestFactory(IPlayReadySecureStopServiceRequestFactoryVtbl, IPlayReadySecureStopServiceRequestFactory_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadySecureStopServiceRequestFactory] {
    fn CreateInstance(&self, publisherCertBytesSize: u32, publisherCertBytes: *mut u8, out: *mut <PlayReadySecureStopServiceRequest as RtType>::Abi) -> HRESULT,
    fn CreateInstanceFromSessionID(&self, sessionID: Guid, publisherCertBytesSize: u32, publisherCertBytes: *mut u8, out: *mut <PlayReadySecureStopServiceRequest as RtType>::Abi) -> HRESULT
}}
impl IPlayReadySecureStopServiceRequestFactory {
    #[inline] pub fn create_instance(&self, publisherCertBytes: &[u8]) -> Result<PlayReadySecureStopServiceRequest> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstance)(self.0.as_abi() as *const _ as *mut _, publisherCertBytes.len() as u32, publisherCertBytes.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(PlayReadySecureStopServiceRequest::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_instance_from_session_id(&self, sessionID: Guid, publisherCertBytes: &[u8]) -> Result<PlayReadySecureStopServiceRequest> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstanceFromSessionID)(self.0.as_abi() as *const _ as *mut _, sessionID, publisherCertBytes.len() as u32, publisherCertBytes.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(PlayReadySecureStopServiceRequest::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPlayReadyServiceRequest, 2343381046, 42755, 17830, 161, 128, 118, 243, 86, 90, 167, 37);
RT_INTERFACE!{interface IPlayReadyServiceRequest(IPlayReadyServiceRequestVtbl, IPlayReadyServiceRequest_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyServiceRequest] {
    fn get_Uri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_Uri(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_ResponseCustomData(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ChallengeCustomData(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ChallengeCustomData(&self, value: HSTRING) -> HRESULT,
    fn BeginServiceRequest(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn NextServiceRequest(&self, out: *mut <IPlayReadyServiceRequest as RtType>::Abi) -> HRESULT,
    fn GenerateManualEnablingChallenge(&self, out: *mut <PlayReadySoapMessage as RtType>::Abi) -> HRESULT,
    fn ProcessManualEnablingResponse(&self, responseBytesSize: u32, responseBytes: *mut u8, out: *mut foundation::HResult) -> HRESULT
}}
impl IPlayReadyServiceRequest {
    #[inline] pub fn get_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Uri)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Uri)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_response_custom_data(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResponseCustomData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_challenge_custom_data(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ChallengeCustomData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_challenge_custom_data(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ChallengeCustomData)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn begin_service_request(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).BeginServiceRequest)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn next_service_request(&self) -> Result<Option<IPlayReadyServiceRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).NextServiceRequest)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IPlayReadyServiceRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn generate_manual_enabling_challenge(&self) -> Result<Option<PlayReadySoapMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GenerateManualEnablingChallenge)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PlayReadySoapMessage::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn process_manual_enabling_response(&self, responseBytes: &[u8]) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).ProcessManualEnablingResponse)(self.0.as_abi() as *const _ as *mut _, responseBytes.len() as u32, responseBytes.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPlayReadySoapMessage, 3059350709, 52801, 16826, 138, 13, 97, 223, 95, 255, 161, 57);
RT_INTERFACE!{interface IPlayReadySoapMessage(IPlayReadySoapMessageVtbl, IPlayReadySoapMessage_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadySoapMessage] {
    fn GetMessageBody(&self, outSize: *mut u32, out: *mut *mut u8) -> HRESULT,
    fn get_MessageHeaders(&self, out: *mut <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT,
    fn get_Uri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT
}}
impl IPlayReadySoapMessage {
    #[inline] pub fn get_message_body(&self) -> Result<ComArray<u8>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetMessageBody)(self.0.as_abi() as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_headers(&self) -> Result<Option<foundation::collections::IPropertySet>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MessageHeaders)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IPropertySet::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Uri)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PlayReadySoapMessage: IPlayReadySoapMessage}
DEFINE_IID!(IID_IPlayReadyStatics, 1583988749, 9340, 18074, 143, 49, 92, 26, 21, 113, 217, 198);
RT_INTERFACE!{static interface IPlayReadyStatics(IPlayReadyStaticsVtbl, IPlayReadyStatics_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyStatics] {
    fn get_DomainJoinServiceRequestType(&self, out: *mut Guid) -> HRESULT,
    fn get_DomainLeaveServiceRequestType(&self, out: *mut Guid) -> HRESULT,
    fn get_IndividualizationServiceRequestType(&self, out: *mut Guid) -> HRESULT,
    fn get_LicenseAcquirerServiceRequestType(&self, out: *mut Guid) -> HRESULT,
    fn get_MeteringReportServiceRequestType(&self, out: *mut Guid) -> HRESULT,
    fn get_RevocationServiceRequestType(&self, out: *mut Guid) -> HRESULT,
    fn get_MediaProtectionSystemId(&self, out: *mut Guid) -> HRESULT,
    fn get_PlayReadySecurityVersion(&self, out: *mut u32) -> HRESULT
}}
impl IPlayReadyStatics {
    #[inline] pub fn get_domain_join_service_request_type(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DomainJoinServiceRequestType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_domain_leave_service_request_type(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DomainLeaveServiceRequestType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_individualization_service_request_type(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IndividualizationServiceRequestType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_license_acquirer_service_request_type(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LicenseAcquirerServiceRequestType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_metering_report_service_request_type(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MeteringReportServiceRequestType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_revocation_service_request_type(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RevocationServiceRequestType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_media_protection_system_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaProtectionSystemId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_play_ready_security_version(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlayReadySecurityVersion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{static class PlayReadyStatics}
impl RtActivatable<IPlayReadyStatics> for PlayReadyStatics {}
impl RtActivatable<IPlayReadyStatics2> for PlayReadyStatics {}
impl RtActivatable<IPlayReadyStatics3> for PlayReadyStatics {}
impl RtActivatable<IPlayReadyStatics4> for PlayReadyStatics {}
impl RtActivatable<IPlayReadyStatics5> for PlayReadyStatics {}
impl PlayReadyStatics {
    #[inline] pub fn get_domain_join_service_request_type() -> Result<Guid> {
        <Self as RtActivatable<IPlayReadyStatics>>::get_activation_factory().get_domain_join_service_request_type()
    }
    #[inline] pub fn get_domain_leave_service_request_type() -> Result<Guid> {
        <Self as RtActivatable<IPlayReadyStatics>>::get_activation_factory().get_domain_leave_service_request_type()
    }
    #[inline] pub fn get_individualization_service_request_type() -> Result<Guid> {
        <Self as RtActivatable<IPlayReadyStatics>>::get_activation_factory().get_individualization_service_request_type()
    }
    #[inline] pub fn get_license_acquirer_service_request_type() -> Result<Guid> {
        <Self as RtActivatable<IPlayReadyStatics>>::get_activation_factory().get_license_acquirer_service_request_type()
    }
    #[inline] pub fn get_metering_report_service_request_type() -> Result<Guid> {
        <Self as RtActivatable<IPlayReadyStatics>>::get_activation_factory().get_metering_report_service_request_type()
    }
    #[inline] pub fn get_revocation_service_request_type() -> Result<Guid> {
        <Self as RtActivatable<IPlayReadyStatics>>::get_activation_factory().get_revocation_service_request_type()
    }
    #[inline] pub fn get_media_protection_system_id() -> Result<Guid> {
        <Self as RtActivatable<IPlayReadyStatics>>::get_activation_factory().get_media_protection_system_id()
    }
    #[inline] pub fn get_play_ready_security_version() -> Result<u32> {
        <Self as RtActivatable<IPlayReadyStatics>>::get_activation_factory().get_play_ready_security_version()
    }
    #[inline] pub fn get_play_ready_certificate_security_level() -> Result<u32> {
        <Self as RtActivatable<IPlayReadyStatics2>>::get_activation_factory().get_play_ready_certificate_security_level()
    }
    #[inline] pub fn get_secure_stop_service_request_type() -> Result<Guid> {
        <Self as RtActivatable<IPlayReadyStatics3>>::get_activation_factory().get_secure_stop_service_request_type()
    }
    #[inline] pub fn check_supported_hardware(hwdrmFeature: PlayReadyHardwareDRMFeatures) -> Result<bool> {
        <Self as RtActivatable<IPlayReadyStatics3>>::get_activation_factory().check_supported_hardware(hwdrmFeature)
    }
    #[inline] pub fn get_input_trust_authority_to_create() -> Result<HString> {
        <Self as RtActivatable<IPlayReadyStatics4>>::get_activation_factory().get_input_trust_authority_to_create()
    }
    #[inline] pub fn get_protection_system_id() -> Result<Guid> {
        <Self as RtActivatable<IPlayReadyStatics4>>::get_activation_factory().get_protection_system_id()
    }
    #[inline] pub fn get_hardware_drm_disabled_at_time() -> Result<Option<foundation::IReference<foundation::DateTime>>> {
        <Self as RtActivatable<IPlayReadyStatics5>>::get_activation_factory().get_hardware_drm_disabled_at_time()
    }
    #[inline] pub fn get_hardware_drm_disabled_until_time() -> Result<Option<foundation::IReference<foundation::DateTime>>> {
        <Self as RtActivatable<IPlayReadyStatics5>>::get_activation_factory().get_hardware_drm_disabled_until_time()
    }
    #[inline] pub fn reset_hardware_drm_disabled() -> Result<()> {
        <Self as RtActivatable<IPlayReadyStatics5>>::get_activation_factory().reset_hardware_drm_disabled()
    }
}
DEFINE_CLSID!(PlayReadyStatics(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,80,114,111,116,101,99,116,105,111,110,46,80,108,97,121,82,101,97,100,121,46,80,108,97,121,82,101,97,100,121,83,116,97,116,105,99,115,0]) [CLSID_PlayReadyStatics]);
DEFINE_IID!(IID_IPlayReadyStatics2, 529361554, 24474, 16958, 148, 102, 179, 57, 105, 175, 122, 61);
RT_INTERFACE!{static interface IPlayReadyStatics2(IPlayReadyStatics2Vtbl, IPlayReadyStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyStatics2] {
    fn get_PlayReadyCertificateSecurityLevel(&self, out: *mut u32) -> HRESULT
}}
impl IPlayReadyStatics2 {
    #[inline] pub fn get_play_ready_certificate_security_level(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PlayReadyCertificateSecurityLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPlayReadyStatics3, 1067663217, 11731, 19437, 174, 73, 247, 20, 142, 99, 231, 16);
RT_INTERFACE!{static interface IPlayReadyStatics3(IPlayReadyStatics3Vtbl, IPlayReadyStatics3_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyStatics3] {
    fn get_SecureStopServiceRequestType(&self, out: *mut Guid) -> HRESULT,
    fn CheckSupportedHardware(&self, hwdrmFeature: PlayReadyHardwareDRMFeatures, out: *mut bool) -> HRESULT
}}
impl IPlayReadyStatics3 {
    #[inline] pub fn get_secure_stop_service_request_type(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SecureStopServiceRequestType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn check_supported_hardware(&self, hwdrmFeature: PlayReadyHardwareDRMFeatures) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).CheckSupportedHardware)(self.0.as_abi() as *const _ as *mut _, hwdrmFeature, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPlayReadyStatics4, 1353257728, 55332, 16945, 157, 94, 120, 239, 136, 68, 199, 215);
RT_INTERFACE!{static interface IPlayReadyStatics4(IPlayReadyStatics4Vtbl, IPlayReadyStatics4_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyStatics4] {
    fn get_InputTrustAuthorityToCreate(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ProtectionSystemId(&self, out: *mut Guid) -> HRESULT
}}
impl IPlayReadyStatics4 {
    #[inline] pub fn get_input_trust_authority_to_create(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_InputTrustAuthorityToCreate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_protection_system_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtectionSystemId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPlayReadyStatics5, 587886709, 57248, 20366, 167, 121, 206, 254, 169, 198, 130, 75);
RT_INTERFACE!{static interface IPlayReadyStatics5(IPlayReadyStatics5Vtbl, IPlayReadyStatics5_Abi): IInspectable(IInspectableVtbl) [IID_IPlayReadyStatics5] {
    fn get_HardwareDRMDisabledAtTime(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_HardwareDRMDisabledUntilTime(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn ResetHardwareDRMDisabled(&self) -> HRESULT
}}
impl IPlayReadyStatics5 {
    #[inline] pub fn get_hardware_drm_disabled_at_time(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_HardwareDRMDisabledAtTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_hardware_drm_disabled_until_time(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_HardwareDRMDisabledUntilTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn reset_hardware_drm_disabled(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ResetHardwareDRMDisabled)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
} // Windows.Media.Protection.PlayReady
} // Windows.Media.Protection
pub mod render { // Windows.Media.Render
use crate::prelude::*;
RT_ENUM! { enum AudioRenderCategory: i32 {
    Other = 0, ForegroundOnlyMedia = 1, BackgroundCapableMedia = 2, Communications = 3, Alerts = 4, SoundEffects = 5, GameEffects = 6, GameMedia = 7, GameChat = 8, Speech = 9, Movie = 10, Media = 11,
}}
} // Windows.Media.Render
pub mod speechrecognition { // Windows.Media.SpeechRecognition
use crate::prelude::*;
DEFINE_IID!(IID_ISpeechContinuousRecognitionCompletedEventArgs, 3822086587, 58124, 24088, 66, 75, 127, 190, 129, 248, 251, 208);
RT_INTERFACE!{interface ISpeechContinuousRecognitionCompletedEventArgs(ISpeechContinuousRecognitionCompletedEventArgsVtbl, ISpeechContinuousRecognitionCompletedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechContinuousRecognitionCompletedEventArgs] {
    fn get_Status(&self, out: *mut SpeechRecognitionResultStatus) -> HRESULT
}}
impl ISpeechContinuousRecognitionCompletedEventArgs {
    #[inline] pub fn get_status(&self) -> Result<SpeechRecognitionResultStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SpeechContinuousRecognitionCompletedEventArgs: ISpeechContinuousRecognitionCompletedEventArgs}
RT_ENUM! { enum SpeechContinuousRecognitionMode: i32 {
    Default = 0, PauseOnRecognition = 1,
}}
DEFINE_IID!(IID_ISpeechContinuousRecognitionResultGeneratedEventArgs, 420027934, 28286, 23110, 64, 251, 118, 89, 79, 120, 101, 4);
RT_INTERFACE!{interface ISpeechContinuousRecognitionResultGeneratedEventArgs(ISpeechContinuousRecognitionResultGeneratedEventArgsVtbl, ISpeechContinuousRecognitionResultGeneratedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechContinuousRecognitionResultGeneratedEventArgs] {
    fn get_Result(&self, out: *mut <SpeechRecognitionResult as RtType>::Abi) -> HRESULT
}}
impl ISpeechContinuousRecognitionResultGeneratedEventArgs {
    #[inline] pub fn get_result(&self) -> Result<Option<SpeechRecognitionResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Result)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SpeechRecognitionResult::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpeechContinuousRecognitionResultGeneratedEventArgs: ISpeechContinuousRecognitionResultGeneratedEventArgs}
DEFINE_IID!(IID_ISpeechContinuousRecognitionSession, 1780562948, 26132, 18936, 153, 162, 181, 233, 179, 160, 133, 200);
RT_INTERFACE!{interface ISpeechContinuousRecognitionSession(ISpeechContinuousRecognitionSessionVtbl, ISpeechContinuousRecognitionSession_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechContinuousRecognitionSession] {
    fn get_AutoStopSilenceTimeout(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_AutoStopSilenceTimeout(&self, value: foundation::TimeSpan) -> HRESULT,
    fn StartAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn StartWithModeAsync(&self, mode: SpeechContinuousRecognitionMode, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn StopAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn CancelAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn PauseAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn Resume(&self) -> HRESULT,
    fn add_Completed(&self, value: <foundation::TypedEventHandler<SpeechContinuousRecognitionSession, SpeechContinuousRecognitionCompletedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Completed(&self, value: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ResultGenerated(&self, value: <foundation::TypedEventHandler<SpeechContinuousRecognitionSession, SpeechContinuousRecognitionResultGeneratedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ResultGenerated(&self, value: foundation::EventRegistrationToken) -> HRESULT
}}
impl ISpeechContinuousRecognitionSession {
    #[inline] pub fn get_auto_stop_silence_timeout(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutoStopSilenceTimeout)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto_stop_silence_timeout(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AutoStopSilenceTimeout)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StartAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn start_with_mode_async(&self, mode: SpeechContinuousRecognitionMode) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StartWithModeAsync)(self.0.as_abi() as *const _ as *mut _, mode, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn stop_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StopAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn cancel_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CancelAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn pause_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PauseAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn resume(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Resume)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_completed(&self, value: &foundation::TypedEventHandler<SpeechContinuousRecognitionSession, SpeechContinuousRecognitionCompletedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Completed)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_completed(&self, value: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Completed)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_result_generated(&self, value: &foundation::TypedEventHandler<SpeechContinuousRecognitionSession, SpeechContinuousRecognitionResultGeneratedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ResultGenerated)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_result_generated(&self, value: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ResultGenerated)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SpeechContinuousRecognitionSession: ISpeechContinuousRecognitionSession}
RT_ENUM! { enum SpeechRecognitionAudioProblem: i32 {
    None = 0, TooNoisy = 1, NoSignal = 2, TooLoud = 3, TooQuiet = 4, TooFast = 5, TooSlow = 6,
}}
DEFINE_IID!(IID_ISpeechRecognitionCompilationResult, 1082027101, 27335, 19876, 156, 193, 47, 206, 50, 207, 116, 137);
RT_INTERFACE!{interface ISpeechRecognitionCompilationResult(ISpeechRecognitionCompilationResultVtbl, ISpeechRecognitionCompilationResult_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognitionCompilationResult] {
    fn get_Status(&self, out: *mut SpeechRecognitionResultStatus) -> HRESULT
}}
impl ISpeechRecognitionCompilationResult {
    #[inline] pub fn get_status(&self) -> Result<SpeechRecognitionResultStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SpeechRecognitionCompilationResult: ISpeechRecognitionCompilationResult}
RT_ENUM! { enum SpeechRecognitionConfidence: i32 {
    High = 0, Medium = 1, Low = 2, Rejected = 3,
}}
DEFINE_IID!(IID_ISpeechRecognitionConstraint, 2041321000, 19816, 17348, 137, 17, 64, 220, 65, 1, 181, 91);
RT_INTERFACE!{interface ISpeechRecognitionConstraint(ISpeechRecognitionConstraintVtbl, ISpeechRecognitionConstraint_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognitionConstraint] {
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsEnabled(&self, value: bool) -> HRESULT,
    fn get_Tag(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Tag(&self, value: HSTRING) -> HRESULT,
    fn get_Type(&self, out: *mut SpeechRecognitionConstraintType) -> HRESULT,
    fn get_Probability(&self, out: *mut SpeechRecognitionConstraintProbability) -> HRESULT,
    fn put_Probability(&self, value: SpeechRecognitionConstraintProbability) -> HRESULT
}}
impl ISpeechRecognitionConstraint {
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_tag(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Tag)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_tag(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Tag)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_type(&self) -> Result<SpeechRecognitionConstraintType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Type)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_probability(&self) -> Result<SpeechRecognitionConstraintProbability> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Probability)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_probability(&self, value: SpeechRecognitionConstraintProbability) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Probability)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum SpeechRecognitionConstraintProbability: i32 {
    Default = 0, Min = 1, Max = 2,
}}
RT_ENUM! { enum SpeechRecognitionConstraintType: i32 {
    Topic = 0, List = 1, Grammar = 2, VoiceCommandDefinition = 3,
}}
DEFINE_IID!(IID_ISpeechRecognitionGrammarFileConstraint, 3036879503, 34250, 20388, 177, 26, 71, 79, 196, 27, 56, 53);
RT_INTERFACE!{interface ISpeechRecognitionGrammarFileConstraint(ISpeechRecognitionGrammarFileConstraintVtbl, ISpeechRecognitionGrammarFileConstraint_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognitionGrammarFileConstraint] {
    #[cfg(feature="windows-storage")] fn get_GrammarFile(&self, out: *mut <super::super::storage::StorageFile as RtType>::Abi) -> HRESULT
}}
impl ISpeechRecognitionGrammarFileConstraint {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_grammar_file(&self) -> Result<Option<super::super::storage::StorageFile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_GrammarFile)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::StorageFile::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpeechRecognitionGrammarFileConstraint: ISpeechRecognitionGrammarFileConstraint}
impl RtActivatable<ISpeechRecognitionGrammarFileConstraintFactory> for SpeechRecognitionGrammarFileConstraint {}
impl SpeechRecognitionGrammarFileConstraint {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(file: &super::super::storage::StorageFile) -> Result<SpeechRecognitionGrammarFileConstraint> {
        <Self as RtActivatable<ISpeechRecognitionGrammarFileConstraintFactory>>::get_activation_factory().create(file)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn create_with_tag(file: &super::super::storage::StorageFile, tag: &HStringArg) -> Result<SpeechRecognitionGrammarFileConstraint> {
        <Self as RtActivatable<ISpeechRecognitionGrammarFileConstraintFactory>>::get_activation_factory().create_with_tag(file, tag)
    }
}
DEFINE_CLSID!(SpeechRecognitionGrammarFileConstraint(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,83,112,101,101,99,104,82,101,99,111,103,110,105,116,105,111,110,46,83,112,101,101,99,104,82,101,99,111,103,110,105,116,105,111,110,71,114,97,109,109,97,114,70,105,108,101,67,111,110,115,116,114,97,105,110,116,0]) [CLSID_SpeechRecognitionGrammarFileConstraint]);
DEFINE_IID!(IID_ISpeechRecognitionGrammarFileConstraintFactory, 1034383595, 50297, 19495, 159, 25, 137, 151, 78, 243, 146, 209);
RT_INTERFACE!{static interface ISpeechRecognitionGrammarFileConstraintFactory(ISpeechRecognitionGrammarFileConstraintFactoryVtbl, ISpeechRecognitionGrammarFileConstraintFactory_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognitionGrammarFileConstraintFactory] {
    #[cfg(feature="windows-storage")] fn Create(&self, file: <super::super::storage::StorageFile as RtType>::Abi, out: *mut <SpeechRecognitionGrammarFileConstraint as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn CreateWithTag(&self, file: <super::super::storage::StorageFile as RtType>::Abi, tag: HSTRING, out: *mut <SpeechRecognitionGrammarFileConstraint as RtType>::Abi) -> HRESULT
}}
impl ISpeechRecognitionGrammarFileConstraintFactory {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(&self, file: &super::super::storage::StorageFile) -> Result<SpeechRecognitionGrammarFileConstraint> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(file) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SpeechRecognitionGrammarFileConstraint::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn create_with_tag(&self, file: &super::super::storage::StorageFile, tag: &HStringArg) -> Result<SpeechRecognitionGrammarFileConstraint> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithTag)(self.0.as_abi() as *const _ as *mut _, get_abi(file) as *const _ as *mut _, tag.get(), &mut out);
        if hr == S_OK { Ok(SpeechRecognitionGrammarFileConstraint::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpeechRecognitionHypothesis, 2054890928, 39365, 20349, 191, 132, 16, 170, 19, 2, 182, 52);
RT_INTERFACE!{interface ISpeechRecognitionHypothesis(ISpeechRecognitionHypothesisVtbl, ISpeechRecognitionHypothesis_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognitionHypothesis] {
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT
}}
impl ISpeechRecognitionHypothesis {
    #[inline] pub fn get_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Text)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpeechRecognitionHypothesis: ISpeechRecognitionHypothesis}
DEFINE_IID!(IID_ISpeechRecognitionHypothesisGeneratedEventArgs, 1427511930, 32803, 22630, 65, 29, 18, 19, 187, 39, 20, 118);
RT_INTERFACE!{interface ISpeechRecognitionHypothesisGeneratedEventArgs(ISpeechRecognitionHypothesisGeneratedEventArgsVtbl, ISpeechRecognitionHypothesisGeneratedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognitionHypothesisGeneratedEventArgs] {
    fn get_Hypothesis(&self, out: *mut <SpeechRecognitionHypothesis as RtType>::Abi) -> HRESULT
}}
impl ISpeechRecognitionHypothesisGeneratedEventArgs {
    #[inline] pub fn get_hypothesis(&self) -> Result<Option<SpeechRecognitionHypothesis>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Hypothesis)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SpeechRecognitionHypothesis::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpeechRecognitionHypothesisGeneratedEventArgs: ISpeechRecognitionHypothesisGeneratedEventArgs}
DEFINE_IID!(IID_ISpeechRecognitionListConstraint, 163874793, 58541, 17702, 129, 242, 73, 70, 251, 72, 29, 152);
RT_INTERFACE!{interface ISpeechRecognitionListConstraint(ISpeechRecognitionListConstraintVtbl, ISpeechRecognitionListConstraint_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognitionListConstraint] {
    fn get_Commands(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT
}}
impl ISpeechRecognitionListConstraint {
    #[inline] pub fn get_commands(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Commands)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpeechRecognitionListConstraint: ISpeechRecognitionListConstraint}
impl RtActivatable<ISpeechRecognitionListConstraintFactory> for SpeechRecognitionListConstraint {}
impl SpeechRecognitionListConstraint {
    #[inline] pub fn create(commands: &foundation::collections::IIterable<HString>) -> Result<SpeechRecognitionListConstraint> {
        <Self as RtActivatable<ISpeechRecognitionListConstraintFactory>>::get_activation_factory().create(commands)
    }
    #[inline] pub fn create_with_tag(commands: &foundation::collections::IIterable<HString>, tag: &HStringArg) -> Result<SpeechRecognitionListConstraint> {
        <Self as RtActivatable<ISpeechRecognitionListConstraintFactory>>::get_activation_factory().create_with_tag(commands, tag)
    }
}
DEFINE_CLSID!(SpeechRecognitionListConstraint(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,83,112,101,101,99,104,82,101,99,111,103,110,105,116,105,111,110,46,83,112,101,101,99,104,82,101,99,111,103,110,105,116,105,111,110,76,105,115,116,67,111,110,115,116,114,97,105,110,116,0]) [CLSID_SpeechRecognitionListConstraint]);
DEFINE_IID!(IID_ISpeechRecognitionListConstraintFactory, 1089719751, 22058, 17002, 159, 59, 59, 78, 40, 43, 225, 213);
RT_INTERFACE!{static interface ISpeechRecognitionListConstraintFactory(ISpeechRecognitionListConstraintFactoryVtbl, ISpeechRecognitionListConstraintFactory_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognitionListConstraintFactory] {
    fn Create(&self, commands: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <SpeechRecognitionListConstraint as RtType>::Abi) -> HRESULT,
    fn CreateWithTag(&self, commands: <foundation::collections::IIterable<HString> as RtType>::Abi, tag: HSTRING, out: *mut <SpeechRecognitionListConstraint as RtType>::Abi) -> HRESULT
}}
impl ISpeechRecognitionListConstraintFactory {
    #[inline] pub fn create(&self, commands: &foundation::collections::IIterable<HString>) -> Result<SpeechRecognitionListConstraint> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(commands) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SpeechRecognitionListConstraint::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_tag(&self, commands: &foundation::collections::IIterable<HString>, tag: &HStringArg) -> Result<SpeechRecognitionListConstraint> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithTag)(self.0.as_abi() as *const _ as *mut _, get_abi(commands) as *const _ as *mut _, tag.get(), &mut out);
        if hr == S_OK { Ok(SpeechRecognitionListConstraint::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpeechRecognitionQualityDegradingEventArgs, 1340227845, 35898, 19582, 141, 10, 91, 212, 245, 177, 74, 216);
RT_INTERFACE!{interface ISpeechRecognitionQualityDegradingEventArgs(ISpeechRecognitionQualityDegradingEventArgsVtbl, ISpeechRecognitionQualityDegradingEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognitionQualityDegradingEventArgs] {
    fn get_Problem(&self, out: *mut SpeechRecognitionAudioProblem) -> HRESULT
}}
impl ISpeechRecognitionQualityDegradingEventArgs {
    #[inline] pub fn get_problem(&self) -> Result<SpeechRecognitionAudioProblem> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Problem)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SpeechRecognitionQualityDegradingEventArgs: ISpeechRecognitionQualityDegradingEventArgs}
DEFINE_IID!(IID_ISpeechRecognitionResult, 1311781207, 846, 18002, 133, 126, 208, 69, 76, 196, 190, 236);
RT_INTERFACE!{interface ISpeechRecognitionResult(ISpeechRecognitionResultVtbl, ISpeechRecognitionResult_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognitionResult] {
    fn get_Status(&self, out: *mut SpeechRecognitionResultStatus) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Confidence(&self, out: *mut SpeechRecognitionConfidence) -> HRESULT,
    fn get_SemanticInterpretation(&self, out: *mut <SpeechRecognitionSemanticInterpretation as RtType>::Abi) -> HRESULT,
    fn GetAlternates(&self, maxAlternates: u32, out: *mut <foundation::collections::IVectorView<SpeechRecognitionResult> as RtType>::Abi) -> HRESULT,
    fn get_Constraint(&self, out: *mut <ISpeechRecognitionConstraint as RtType>::Abi) -> HRESULT,
    fn get_RulePath(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT,
    fn get_RawConfidence(&self, out: *mut f64) -> HRESULT
}}
impl ISpeechRecognitionResult {
    #[inline] pub fn get_status(&self) -> Result<SpeechRecognitionResultStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Text)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_confidence(&self) -> Result<SpeechRecognitionConfidence> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Confidence)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_semantic_interpretation(&self) -> Result<Option<SpeechRecognitionSemanticInterpretation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SemanticInterpretation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SpeechRecognitionSemanticInterpretation::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_alternates(&self, maxAlternates: u32) -> Result<Option<foundation::collections::IVectorView<SpeechRecognitionResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAlternates)(self.0.as_abi() as *const _ as *mut _, maxAlternates, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_constraint(&self) -> Result<Option<ISpeechRecognitionConstraint>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Constraint)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ISpeechRecognitionConstraint::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_rule_path(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_RulePath)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_raw_confidence(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RawConfidence)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SpeechRecognitionResult: ISpeechRecognitionResult}
DEFINE_IID!(IID_ISpeechRecognitionResult2, 2944324026, 17691, 16742, 160, 193, 31, 254, 132, 3, 45, 3);
RT_INTERFACE!{interface ISpeechRecognitionResult2(ISpeechRecognitionResult2Vtbl, ISpeechRecognitionResult2_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognitionResult2] {
    fn get_PhraseStartTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_PhraseDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT
}}
impl ISpeechRecognitionResult2 {
    #[inline] pub fn get_phrase_start_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhraseStartTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_phrase_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhraseDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum SpeechRecognitionResultStatus: i32 {
    Success = 0, TopicLanguageNotSupported = 1, GrammarLanguageMismatch = 2, GrammarCompilationFailure = 3, AudioQualityFailure = 4, UserCanceled = 5, Unknown = 6, TimeoutExceeded = 7, PauseLimitExceeded = 8, NetworkFailure = 9, MicrophoneUnavailable = 10,
}}
RT_ENUM! { enum SpeechRecognitionScenario: i32 {
    WebSearch = 0, Dictation = 1, FormFilling = 2,
}}
DEFINE_IID!(IID_ISpeechRecognitionSemanticInterpretation, 2866928283, 32306, 19487, 137, 254, 12, 101, 244, 134, 245, 46);
RT_INTERFACE!{interface ISpeechRecognitionSemanticInterpretation(ISpeechRecognitionSemanticInterpretationVtbl, ISpeechRecognitionSemanticInterpretation_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognitionSemanticInterpretation] {
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, foundation::collections::IVectorView<HString>> as RtType>::Abi) -> HRESULT
}}
impl ISpeechRecognitionSemanticInterpretation {
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, foundation::collections::IVectorView<HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpeechRecognitionSemanticInterpretation: ISpeechRecognitionSemanticInterpretation}
DEFINE_IID!(IID_ISpeechRecognitionTopicConstraint, 3211779865, 33373, 20073, 166, 129, 54, 228, 140, 241, 201, 62);
RT_INTERFACE!{interface ISpeechRecognitionTopicConstraint(ISpeechRecognitionTopicConstraintVtbl, ISpeechRecognitionTopicConstraint_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognitionTopicConstraint] {
    fn get_Scenario(&self, out: *mut SpeechRecognitionScenario) -> HRESULT,
    fn get_TopicHint(&self, out: *mut HSTRING) -> HRESULT
}}
impl ISpeechRecognitionTopicConstraint {
    #[inline] pub fn get_scenario(&self) -> Result<SpeechRecognitionScenario> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Scenario)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_topic_hint(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TopicHint)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpeechRecognitionTopicConstraint: ISpeechRecognitionTopicConstraint}
impl RtActivatable<ISpeechRecognitionTopicConstraintFactory> for SpeechRecognitionTopicConstraint {}
impl SpeechRecognitionTopicConstraint {
    #[inline] pub fn create(scenario: SpeechRecognitionScenario, topicHint: &HStringArg) -> Result<SpeechRecognitionTopicConstraint> {
        <Self as RtActivatable<ISpeechRecognitionTopicConstraintFactory>>::get_activation_factory().create(scenario, topicHint)
    }
    #[inline] pub fn create_with_tag(scenario: SpeechRecognitionScenario, topicHint: &HStringArg, tag: &HStringArg) -> Result<SpeechRecognitionTopicConstraint> {
        <Self as RtActivatable<ISpeechRecognitionTopicConstraintFactory>>::get_activation_factory().create_with_tag(scenario, topicHint, tag)
    }
}
DEFINE_CLSID!(SpeechRecognitionTopicConstraint(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,83,112,101,101,99,104,82,101,99,111,103,110,105,116,105,111,110,46,83,112,101,101,99,104,82,101,99,111,103,110,105,116,105,111,110,84,111,112,105,99,67,111,110,115,116,114,97,105,110,116,0]) [CLSID_SpeechRecognitionTopicConstraint]);
DEFINE_IID!(IID_ISpeechRecognitionTopicConstraintFactory, 1852335071, 60421, 18391, 165, 223, 86, 163, 67, 30, 88, 210);
RT_INTERFACE!{static interface ISpeechRecognitionTopicConstraintFactory(ISpeechRecognitionTopicConstraintFactoryVtbl, ISpeechRecognitionTopicConstraintFactory_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognitionTopicConstraintFactory] {
    fn Create(&self, scenario: SpeechRecognitionScenario, topicHint: HSTRING, out: *mut <SpeechRecognitionTopicConstraint as RtType>::Abi) -> HRESULT,
    fn CreateWithTag(&self, scenario: SpeechRecognitionScenario, topicHint: HSTRING, tag: HSTRING, out: *mut <SpeechRecognitionTopicConstraint as RtType>::Abi) -> HRESULT
}}
impl ISpeechRecognitionTopicConstraintFactory {
    #[inline] pub fn create(&self, scenario: SpeechRecognitionScenario, topicHint: &HStringArg) -> Result<SpeechRecognitionTopicConstraint> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, scenario, topicHint.get(), &mut out);
        if hr == S_OK { Ok(SpeechRecognitionTopicConstraint::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_tag(&self, scenario: SpeechRecognitionScenario, topicHint: &HStringArg, tag: &HStringArg) -> Result<SpeechRecognitionTopicConstraint> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithTag)(self.0.as_abi() as *const _ as *mut _, scenario, topicHint.get(), tag.get(), &mut out);
        if hr == S_OK { Ok(SpeechRecognitionTopicConstraint::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpeechRecognitionVoiceCommandDefinitionConstraint, 4068023339, 7924, 19175, 157, 119, 182, 255, 16, 184, 163, 194);
RT_INTERFACE!{interface ISpeechRecognitionVoiceCommandDefinitionConstraint(ISpeechRecognitionVoiceCommandDefinitionConstraintVtbl, ISpeechRecognitionVoiceCommandDefinitionConstraint_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognitionVoiceCommandDefinitionConstraint] {
    
}}
RT_CLASS!{class SpeechRecognitionVoiceCommandDefinitionConstraint: ISpeechRecognitionVoiceCommandDefinitionConstraint}
DEFINE_IID!(IID_ISpeechRecognizer, 197380555, 49770, 16626, 174, 181, 128, 150, 178, 228, 128, 115);
RT_INTERFACE!{interface ISpeechRecognizer(ISpeechRecognizerVtbl, ISpeechRecognizer_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognizer] {
    #[cfg(not(feature="windows-globalization"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-globalization")] fn get_CurrentLanguage(&self, out: *mut <super::super::globalization::Language as RtType>::Abi) -> HRESULT,
    fn get_Constraints(&self, out: *mut <foundation::collections::IVector<ISpeechRecognitionConstraint> as RtType>::Abi) -> HRESULT,
    fn get_Timeouts(&self, out: *mut <SpeechRecognizerTimeouts as RtType>::Abi) -> HRESULT,
    fn get_UIOptions(&self, out: *mut <SpeechRecognizerUIOptions as RtType>::Abi) -> HRESULT,
    fn CompileConstraintsAsync(&self, out: *mut <foundation::IAsyncOperation<SpeechRecognitionCompilationResult> as RtType>::Abi) -> HRESULT,
    fn RecognizeAsync(&self, out: *mut <foundation::IAsyncOperation<SpeechRecognitionResult> as RtType>::Abi) -> HRESULT,
    fn RecognizeWithUIAsync(&self, out: *mut <foundation::IAsyncOperation<SpeechRecognitionResult> as RtType>::Abi) -> HRESULT,
    fn add_RecognitionQualityDegrading(&self, speechRecognitionQualityDegradingHandler: <foundation::TypedEventHandler<SpeechRecognizer, SpeechRecognitionQualityDegradingEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RecognitionQualityDegrading(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_StateChanged(&self, stateChangedHandler: <foundation::TypedEventHandler<SpeechRecognizer, SpeechRecognizerStateChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StateChanged(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ISpeechRecognizer {
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_current_language(&self) -> Result<Option<super::super::globalization::Language>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CurrentLanguage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::globalization::Language::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_constraints(&self) -> Result<Option<foundation::collections::IVector<ISpeechRecognitionConstraint>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Constraints)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_timeouts(&self) -> Result<Option<SpeechRecognizerTimeouts>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timeouts)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SpeechRecognizerTimeouts::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_ui_options(&self) -> Result<Option<SpeechRecognizerUIOptions>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_UIOptions)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SpeechRecognizerUIOptions::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn compile_constraints_async(&self) -> Result<foundation::IAsyncOperation<SpeechRecognitionCompilationResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CompileConstraintsAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn recognize_async(&self) -> Result<foundation::IAsyncOperation<SpeechRecognitionResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RecognizeAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn recognize_with_ui_async(&self) -> Result<foundation::IAsyncOperation<SpeechRecognitionResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RecognizeWithUIAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_recognition_quality_degrading(&self, speechRecognitionQualityDegradingHandler: &foundation::TypedEventHandler<SpeechRecognizer, SpeechRecognitionQualityDegradingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_RecognitionQualityDegrading)(self.0.as_abi() as *const _ as *mut _, get_abi(speechRecognitionQualityDegradingHandler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_recognition_quality_degrading(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_RecognitionQualityDegrading)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_state_changed(&self, stateChangedHandler: &foundation::TypedEventHandler<SpeechRecognizer, SpeechRecognizerStateChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(stateChangedHandler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_state_changed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StateChanged)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SpeechRecognizer: ISpeechRecognizer}
impl RtActivatable<ISpeechRecognizerFactory> for SpeechRecognizer {}
impl RtActivatable<ISpeechRecognizerStatics> for SpeechRecognizer {}
impl RtActivatable<ISpeechRecognizerStatics2> for SpeechRecognizer {}
impl RtActivatable<IActivationFactory> for SpeechRecognizer {}
impl SpeechRecognizer {
    #[cfg(feature="windows-globalization")] #[inline] pub fn create(language: &super::super::globalization::Language) -> Result<SpeechRecognizer> {
        <Self as RtActivatable<ISpeechRecognizerFactory>>::get_activation_factory().create(language)
    }
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_system_speech_language() -> Result<Option<super::super::globalization::Language>> {
        <Self as RtActivatable<ISpeechRecognizerStatics>>::get_activation_factory().get_system_speech_language()
    }
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_supported_topic_languages() -> Result<Option<foundation::collections::IVectorView<super::super::globalization::Language>>> {
        <Self as RtActivatable<ISpeechRecognizerStatics>>::get_activation_factory().get_supported_topic_languages()
    }
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_supported_grammar_languages() -> Result<Option<foundation::collections::IVectorView<super::super::globalization::Language>>> {
        <Self as RtActivatable<ISpeechRecognizerStatics>>::get_activation_factory().get_supported_grammar_languages()
    }
    #[cfg(feature="windows-globalization")] #[inline] pub fn try_set_system_speech_language_async(speechLanguage: &super::super::globalization::Language) -> Result<foundation::IAsyncOperation<bool>> {
        <Self as RtActivatable<ISpeechRecognizerStatics2>>::get_activation_factory().try_set_system_speech_language_async(speechLanguage)
    }
}
DEFINE_CLSID!(SpeechRecognizer(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,83,112,101,101,99,104,82,101,99,111,103,110,105,116,105,111,110,46,83,112,101,101,99,104,82,101,99,111,103,110,105,122,101,114,0]) [CLSID_SpeechRecognizer]);
DEFINE_IID!(IID_ISpeechRecognizer2, 1674164977, 37347, 20132, 134, 161, 124, 56, 103, 208, 132, 166);
RT_INTERFACE!{interface ISpeechRecognizer2(ISpeechRecognizer2Vtbl, ISpeechRecognizer2_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognizer2] {
    fn get_ContinuousRecognitionSession(&self, out: *mut <SpeechContinuousRecognitionSession as RtType>::Abi) -> HRESULT,
    fn get_State(&self, out: *mut SpeechRecognizerState) -> HRESULT,
    fn StopRecognitionAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn add_HypothesisGenerated(&self, value: <foundation::TypedEventHandler<SpeechRecognizer, SpeechRecognitionHypothesisGeneratedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_HypothesisGenerated(&self, value: foundation::EventRegistrationToken) -> HRESULT
}}
impl ISpeechRecognizer2 {
    #[inline] pub fn get_continuous_recognition_session(&self) -> Result<Option<SpeechContinuousRecognitionSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ContinuousRecognitionSession)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SpeechContinuousRecognitionSession::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_state(&self) -> Result<SpeechRecognizerState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn stop_recognition_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StopRecognitionAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_hypothesis_generated(&self, value: &foundation::TypedEventHandler<SpeechRecognizer, SpeechRecognitionHypothesisGeneratedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_HypothesisGenerated)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_hypothesis_generated(&self, value: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_HypothesisGenerated)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpeechRecognizerFactory, 1623492829, 32696, 16435, 172, 112, 208, 70, 246, 72, 24, 225);
RT_INTERFACE!{static interface ISpeechRecognizerFactory(ISpeechRecognizerFactoryVtbl, ISpeechRecognizerFactory_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognizerFactory] {
    #[cfg(feature="windows-globalization")] fn Create(&self, language: <super::super::globalization::Language as RtType>::Abi, out: *mut <SpeechRecognizer as RtType>::Abi) -> HRESULT
}}
impl ISpeechRecognizerFactory {
    #[cfg(feature="windows-globalization")] #[inline] pub fn create(&self, language: &super::super::globalization::Language) -> Result<SpeechRecognizer> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(language) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SpeechRecognizer::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SpeechRecognizerState: i32 {
    Idle = 0, Capturing = 1, Processing = 2, SoundStarted = 3, SoundEnded = 4, SpeechDetected = 5, Paused = 6,
}}
DEFINE_IID!(IID_ISpeechRecognizerStateChangedEventArgs, 1446858505, 47619, 19373, 173, 129, 221, 198, 196, 218, 176, 195);
RT_INTERFACE!{interface ISpeechRecognizerStateChangedEventArgs(ISpeechRecognizerStateChangedEventArgsVtbl, ISpeechRecognizerStateChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognizerStateChangedEventArgs] {
    fn get_State(&self, out: *mut SpeechRecognizerState) -> HRESULT
}}
impl ISpeechRecognizerStateChangedEventArgs {
    #[inline] pub fn get_state(&self) -> Result<SpeechRecognizerState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SpeechRecognizerStateChangedEventArgs: ISpeechRecognizerStateChangedEventArgs}
DEFINE_IID!(IID_ISpeechRecognizerStatics, 2275630764, 42972, 19211, 188, 201, 36, 244, 124, 11, 126, 191);
RT_INTERFACE!{static interface ISpeechRecognizerStatics(ISpeechRecognizerStaticsVtbl, ISpeechRecognizerStatics_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognizerStatics] {
    #[cfg(feature="windows-globalization")] fn get_SystemSpeechLanguage(&self, out: *mut <super::super::globalization::Language as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-globalization")] fn get_SupportedTopicLanguages(&self, out: *mut <foundation::collections::IVectorView<super::super::globalization::Language> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-globalization")] fn get_SupportedGrammarLanguages(&self, out: *mut <foundation::collections::IVectorView<super::super::globalization::Language> as RtType>::Abi) -> HRESULT
}}
impl ISpeechRecognizerStatics {
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_system_speech_language(&self) -> Result<Option<super::super::globalization::Language>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SystemSpeechLanguage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::globalization::Language::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_supported_topic_languages(&self) -> Result<Option<foundation::collections::IVectorView<super::super::globalization::Language>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedTopicLanguages)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_supported_grammar_languages(&self) -> Result<Option<foundation::collections::IVectorView<super::super::globalization::Language>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedGrammarLanguages)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpeechRecognizerStatics2, 488312213, 30053, 20217, 162, 243, 186, 21, 22, 42, 150, 207);
RT_INTERFACE!{static interface ISpeechRecognizerStatics2(ISpeechRecognizerStatics2Vtbl, ISpeechRecognizerStatics2_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognizerStatics2] {
    #[cfg(feature="windows-globalization")] fn TrySetSystemSpeechLanguageAsync(&self, speechLanguage: <super::super::globalization::Language as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl ISpeechRecognizerStatics2 {
    #[cfg(feature="windows-globalization")] #[inline] pub fn try_set_system_speech_language_async(&self, speechLanguage: &super::super::globalization::Language) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TrySetSystemSpeechLanguageAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(speechLanguage) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpeechRecognizerTimeouts, 787967946, 27196, 19914, 161, 83, 223, 27, 200, 138, 121, 175);
RT_INTERFACE!{interface ISpeechRecognizerTimeouts(ISpeechRecognizerTimeoutsVtbl, ISpeechRecognizerTimeouts_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognizerTimeouts] {
    fn get_InitialSilenceTimeout(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_InitialSilenceTimeout(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_EndSilenceTimeout(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_EndSilenceTimeout(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_BabbleTimeout(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_BabbleTimeout(&self, value: foundation::TimeSpan) -> HRESULT
}}
impl ISpeechRecognizerTimeouts {
    #[inline] pub fn get_initial_silence_timeout(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InitialSilenceTimeout)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_initial_silence_timeout(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_InitialSilenceTimeout)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_end_silence_timeout(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_EndSilenceTimeout)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_end_silence_timeout(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_EndSilenceTimeout)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_babble_timeout(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BabbleTimeout)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_babble_timeout(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BabbleTimeout)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SpeechRecognizerTimeouts: ISpeechRecognizerTimeouts}
DEFINE_IID!(IID_ISpeechRecognizerUIOptions, 2022233665, 47403, 17594, 162, 95, 209, 134, 70, 48, 100, 31);
RT_INTERFACE!{interface ISpeechRecognizerUIOptions(ISpeechRecognizerUIOptionsVtbl, ISpeechRecognizerUIOptions_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechRecognizerUIOptions] {
    fn get_ExampleText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ExampleText(&self, value: HSTRING) -> HRESULT,
    fn get_AudiblePrompt(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AudiblePrompt(&self, value: HSTRING) -> HRESULT,
    fn get_IsReadBackEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsReadBackEnabled(&self, value: bool) -> HRESULT,
    fn get_ShowConfirmation(&self, out: *mut bool) -> HRESULT,
    fn put_ShowConfirmation(&self, value: bool) -> HRESULT
}}
impl ISpeechRecognizerUIOptions {
    #[inline] pub fn get_example_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExampleText)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_example_text(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ExampleText)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_audible_prompt(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudiblePrompt)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_audible_prompt(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AudiblePrompt)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_read_back_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsReadBackEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_read_back_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsReadBackEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_show_confirmation(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ShowConfirmation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_show_confirmation(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ShowConfirmation)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SpeechRecognizerUIOptions: ISpeechRecognizerUIOptions}
} // Windows.Media.SpeechRecognition
pub mod speechsynthesis { // Windows.Media.SpeechSynthesis
use crate::prelude::*;
DEFINE_IID!(IID_IInstalledVoicesStatic, 2102554316, 30003, 19519, 133, 190, 136, 140, 43, 174, 235, 220);
RT_INTERFACE!{static interface IInstalledVoicesStatic(IInstalledVoicesStaticVtbl, IInstalledVoicesStatic_Abi): IInspectable(IInspectableVtbl) [IID_IInstalledVoicesStatic] {
    fn get_AllVoices(&self, out: *mut <foundation::collections::IVectorView<VoiceInformation> as RtType>::Abi) -> HRESULT,
    fn get_DefaultVoice(&self, out: *mut <VoiceInformation as RtType>::Abi) -> HRESULT
}}
impl IInstalledVoicesStatic {
    #[inline] pub fn get_all_voices(&self) -> Result<Option<foundation::collections::IVectorView<VoiceInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AllVoices)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_voice(&self) -> Result<Option<VoiceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DefaultVoice)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VoiceInformation::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInstalledVoicesStatic2, 1680170798, 13709, 16472, 190, 154, 253, 63, 203, 66, 53, 48);
RT_INTERFACE!{static interface IInstalledVoicesStatic2(IInstalledVoicesStatic2Vtbl, IInstalledVoicesStatic2_Abi): IInspectable(IInspectableVtbl) [IID_IInstalledVoicesStatic2] {
    fn TrySetDefaultVoiceAsync(&self, voice: <VoiceInformation as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl IInstalledVoicesStatic2 {
    #[inline] pub fn try_set_default_voice_async(&self, voice: &VoiceInformation) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TrySetDefaultVoiceAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(voice) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SpeechAppendedSilence: i32 {
    Default = 0, Min = 1,
}}
RT_ENUM! { enum SpeechPunctuationSilence: i32 {
    Default = 0, Min = 1,
}}
DEFINE_IID!(IID_ISpeechSynthesisStream, 2212785811, 9292, 17954, 186, 11, 98, 41, 196, 208, 214, 93);
RT_INTERFACE!{interface ISpeechSynthesisStream(ISpeechSynthesisStreamVtbl, ISpeechSynthesisStream_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechSynthesisStream] {
    fn get_Markers(&self, out: *mut <foundation::collections::IVectorView<super::IMediaMarker> as RtType>::Abi) -> HRESULT
}}
impl ISpeechSynthesisStream {
    #[inline] pub fn get_markers(&self) -> Result<Option<foundation::collections::IVectorView<super::IMediaMarker>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Markers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpeechSynthesisStream: ISpeechSynthesisStream}
DEFINE_IID!(IID_ISpeechSynthesizer, 3466558582, 38900, 19693, 173, 104, 213, 28, 69, 142, 69, 198);
RT_INTERFACE!{interface ISpeechSynthesizer(ISpeechSynthesizerVtbl, ISpeechSynthesizer_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechSynthesizer] {
    fn SynthesizeTextToStreamAsync(&self, text: HSTRING, out: *mut <foundation::IAsyncOperation<SpeechSynthesisStream> as RtType>::Abi) -> HRESULT,
    fn SynthesizeSsmlToStreamAsync(&self, ssml: HSTRING, out: *mut <foundation::IAsyncOperation<SpeechSynthesisStream> as RtType>::Abi) -> HRESULT,
    fn put_Voice(&self, value: <VoiceInformation as RtType>::Abi) -> HRESULT,
    fn get_Voice(&self, out: *mut <VoiceInformation as RtType>::Abi) -> HRESULT
}}
impl ISpeechSynthesizer {
    #[inline] pub fn synthesize_text_to_stream_async(&self, text: &HStringArg) -> Result<foundation::IAsyncOperation<SpeechSynthesisStream>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SynthesizeTextToStreamAsync)(self.0.as_abi() as *const _ as *mut _, text.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn synthesize_ssml_to_stream_async(&self, ssml: &HStringArg) -> Result<foundation::IAsyncOperation<SpeechSynthesisStream>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SynthesizeSsmlToStreamAsync)(self.0.as_abi() as *const _ as *mut _, ssml.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_voice(&self, value: &VoiceInformation) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Voice)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_voice(&self) -> Result<Option<VoiceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Voice)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VoiceInformation::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpeechSynthesizer: ISpeechSynthesizer}
impl RtActivatable<IInstalledVoicesStatic> for SpeechSynthesizer {}
impl RtActivatable<IInstalledVoicesStatic2> for SpeechSynthesizer {}
impl RtActivatable<IActivationFactory> for SpeechSynthesizer {}
impl SpeechSynthesizer {
    #[inline] pub fn get_all_voices() -> Result<Option<foundation::collections::IVectorView<VoiceInformation>>> {
        <Self as RtActivatable<IInstalledVoicesStatic>>::get_activation_factory().get_all_voices()
    }
    #[inline] pub fn get_default_voice() -> Result<Option<VoiceInformation>> {
        <Self as RtActivatable<IInstalledVoicesStatic>>::get_activation_factory().get_default_voice()
    }
    #[inline] pub fn try_set_default_voice_async(voice: &VoiceInformation) -> Result<foundation::IAsyncOperation<bool>> {
        <Self as RtActivatable<IInstalledVoicesStatic2>>::get_activation_factory().try_set_default_voice_async(voice)
    }
}
DEFINE_CLSID!(SpeechSynthesizer(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,83,112,101,101,99,104,83,121,110,116,104,101,115,105,115,46,83,112,101,101,99,104,83,121,110,116,104,101,115,105,122,101,114,0]) [CLSID_SpeechSynthesizer]);
DEFINE_IID!(IID_ISpeechSynthesizer2, 2814766258, 17209, 19818, 187, 248, 199, 164, 241, 84, 76, 46);
RT_INTERFACE!{interface ISpeechSynthesizer2(ISpeechSynthesizer2Vtbl, ISpeechSynthesizer2_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechSynthesizer2] {
    fn get_Options(&self, out: *mut <SpeechSynthesizerOptions as RtType>::Abi) -> HRESULT
}}
impl ISpeechSynthesizer2 {
    #[inline] pub fn get_options(&self) -> Result<Option<SpeechSynthesizerOptions>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Options)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SpeechSynthesizerOptions::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpeechSynthesizerOptions, 2699180145, 52285, 17353, 145, 177, 238, 24, 83, 36, 216, 61);
RT_INTERFACE!{interface ISpeechSynthesizerOptions(ISpeechSynthesizerOptionsVtbl, ISpeechSynthesizerOptions_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechSynthesizerOptions] {
    fn get_IncludeWordBoundaryMetadata(&self, out: *mut bool) -> HRESULT,
    fn put_IncludeWordBoundaryMetadata(&self, value: bool) -> HRESULT,
    fn get_IncludeSentenceBoundaryMetadata(&self, out: *mut bool) -> HRESULT,
    fn put_IncludeSentenceBoundaryMetadata(&self, value: bool) -> HRESULT
}}
impl ISpeechSynthesizerOptions {
    #[inline] pub fn get_include_word_boundary_metadata(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IncludeWordBoundaryMetadata)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_include_word_boundary_metadata(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IncludeWordBoundaryMetadata)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_include_sentence_boundary_metadata(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IncludeSentenceBoundaryMetadata)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_include_sentence_boundary_metadata(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IncludeSentenceBoundaryMetadata)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SpeechSynthesizerOptions: ISpeechSynthesizerOptions}
DEFINE_IID!(IID_ISpeechSynthesizerOptions2, 482276878, 4508, 19437, 177, 24, 210, 80, 195, 162, 87, 147);
RT_INTERFACE!{interface ISpeechSynthesizerOptions2(ISpeechSynthesizerOptions2Vtbl, ISpeechSynthesizerOptions2_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechSynthesizerOptions2] {
    fn get_AudioVolume(&self, out: *mut f64) -> HRESULT,
    fn put_AudioVolume(&self, value: f64) -> HRESULT,
    fn get_SpeakingRate(&self, out: *mut f64) -> HRESULT,
    fn put_SpeakingRate(&self, value: f64) -> HRESULT,
    fn get_AudioPitch(&self, out: *mut f64) -> HRESULT,
    fn put_AudioPitch(&self, value: f64) -> HRESULT
}}
impl ISpeechSynthesizerOptions2 {
    #[inline] pub fn get_audio_volume(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioVolume)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_audio_volume(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AudioVolume)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_speaking_rate(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SpeakingRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_speaking_rate(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SpeakingRate)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_pitch(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioPitch)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_audio_pitch(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AudioPitch)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpeechSynthesizerOptions3, 1075763319, 36908, 18452, 165, 130, 165, 208, 192, 118, 159, 168);
RT_INTERFACE!{interface ISpeechSynthesizerOptions3(ISpeechSynthesizerOptions3Vtbl, ISpeechSynthesizerOptions3_Abi): IInspectable(IInspectableVtbl) [IID_ISpeechSynthesizerOptions3] {
    fn get_AppendedSilence(&self, out: *mut SpeechAppendedSilence) -> HRESULT,
    fn put_AppendedSilence(&self, value: SpeechAppendedSilence) -> HRESULT,
    fn get_PunctuationSilence(&self, out: *mut SpeechPunctuationSilence) -> HRESULT,
    fn put_PunctuationSilence(&self, value: SpeechPunctuationSilence) -> HRESULT
}}
impl ISpeechSynthesizerOptions3 {
    #[inline] pub fn get_appended_silence(&self) -> Result<SpeechAppendedSilence> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AppendedSilence)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_appended_silence(&self, value: SpeechAppendedSilence) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AppendedSilence)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_punctuation_silence(&self) -> Result<SpeechPunctuationSilence> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PunctuationSilence)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_punctuation_silence(&self, value: SpeechPunctuationSilence) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PunctuationSilence)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum VoiceGender: i32 {
    Male = 0, Female = 1,
}}
DEFINE_IID!(IID_IVoiceInformation, 2972178084, 4753, 17924, 170, 156, 131, 19, 64, 131, 53, 44);
RT_INTERFACE!{interface IVoiceInformation(IVoiceInformationVtbl, IVoiceInformation_Abi): IInspectable(IInspectableVtbl) [IID_IVoiceInformation] {
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Gender(&self, out: *mut VoiceGender) -> HRESULT
}}
impl IVoiceInformation {
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DisplayName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_language(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Language)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Description)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_gender(&self) -> Result<VoiceGender> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Gender)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class VoiceInformation: IVoiceInformation}
} // Windows.Media.SpeechSynthesis
pub mod streaming { // Windows.Media.Streaming
pub mod adaptive { // Windows.Media.Streaming.Adaptive
use crate::prelude::*;
DEFINE_IID!(IID_IAdaptiveMediaSource, 1282618095, 54175, 17302, 180, 217, 4, 57, 87, 167, 201, 100);
RT_INTERFACE!{interface IAdaptiveMediaSource(IAdaptiveMediaSourceVtbl, IAdaptiveMediaSource_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSource] {
    fn get_IsLive(&self, out: *mut bool) -> HRESULT,
    fn get_DesiredLiveOffset(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_DesiredLiveOffset(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_InitialBitrate(&self, out: *mut u32) -> HRESULT,
    fn put_InitialBitrate(&self, value: u32) -> HRESULT,
    fn get_CurrentDownloadBitrate(&self, out: *mut u32) -> HRESULT,
    fn get_CurrentPlaybackBitrate(&self, out: *mut u32) -> HRESULT,
    fn get_AvailableBitrates(&self, out: *mut <foundation::collections::IVectorView<u32> as RtType>::Abi) -> HRESULT,
    fn get_DesiredMinBitrate(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn put_DesiredMinBitrate(&self, value: <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_DesiredMaxBitrate(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn put_DesiredMaxBitrate(&self, value: <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_AudioOnlyPlayback(&self, out: *mut bool) -> HRESULT,
    fn get_InboundBitsPerSecond(&self, out: *mut u64) -> HRESULT,
    fn get_InboundBitsPerSecondWindow(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_InboundBitsPerSecondWindow(&self, value: foundation::TimeSpan) -> HRESULT,
    fn add_DownloadBitrateChanged(&self, handler: <foundation::TypedEventHandler<AdaptiveMediaSource, AdaptiveMediaSourceDownloadBitrateChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DownloadBitrateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PlaybackBitrateChanged(&self, handler: <foundation::TypedEventHandler<AdaptiveMediaSource, AdaptiveMediaSourcePlaybackBitrateChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PlaybackBitrateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_DownloadRequested(&self, handler: <foundation::TypedEventHandler<AdaptiveMediaSource, AdaptiveMediaSourceDownloadRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DownloadRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_DownloadCompleted(&self, handler: <foundation::TypedEventHandler<AdaptiveMediaSource, AdaptiveMediaSourceDownloadCompletedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DownloadCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_DownloadFailed(&self, handler: <foundation::TypedEventHandler<AdaptiveMediaSource, AdaptiveMediaSourceDownloadFailedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DownloadFailed(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAdaptiveMediaSource {
    #[inline] pub fn get_is_live(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsLive)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_desired_live_offset(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DesiredLiveOffset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_live_offset(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DesiredLiveOffset)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_initial_bitrate(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InitialBitrate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_initial_bitrate(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_InitialBitrate)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_current_download_bitrate(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CurrentDownloadBitrate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_current_playback_bitrate(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CurrentPlaybackBitrate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_available_bitrates(&self) -> Result<Option<foundation::collections::IVectorView<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AvailableBitrates)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_desired_min_bitrate(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DesiredMinBitrate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_min_bitrate(&self, value: &foundation::IReference<u32>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DesiredMinBitrate)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_desired_max_bitrate(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DesiredMaxBitrate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_max_bitrate(&self, value: &foundation::IReference<u32>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DesiredMaxBitrate)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_only_playback(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioOnlyPlayback)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_inbound_bits_per_second(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InboundBitsPerSecond)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_inbound_bits_per_second_window(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InboundBitsPerSecondWindow)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_inbound_bits_per_second_window(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_InboundBitsPerSecondWindow)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_download_bitrate_changed(&self, handler: &foundation::TypedEventHandler<AdaptiveMediaSource, AdaptiveMediaSourceDownloadBitrateChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_DownloadBitrateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_download_bitrate_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_DownloadBitrateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_playback_bitrate_changed(&self, handler: &foundation::TypedEventHandler<AdaptiveMediaSource, AdaptiveMediaSourcePlaybackBitrateChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PlaybackBitrateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_playback_bitrate_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PlaybackBitrateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_download_requested(&self, handler: &foundation::TypedEventHandler<AdaptiveMediaSource, AdaptiveMediaSourceDownloadRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_DownloadRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_download_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_DownloadRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_download_completed(&self, handler: &foundation::TypedEventHandler<AdaptiveMediaSource, AdaptiveMediaSourceDownloadCompletedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_DownloadCompleted)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_download_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_DownloadCompleted)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_download_failed(&self, handler: &foundation::TypedEventHandler<AdaptiveMediaSource, AdaptiveMediaSourceDownloadFailedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_DownloadFailed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_download_failed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_DownloadFailed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AdaptiveMediaSource: IAdaptiveMediaSource}
impl RtActivatable<IAdaptiveMediaSourceStatics> for AdaptiveMediaSource {}
impl AdaptiveMediaSource {
    #[inline] pub fn is_content_type_supported(contentType: &HStringArg) -> Result<bool> {
        <Self as RtActivatable<IAdaptiveMediaSourceStatics>>::get_activation_factory().is_content_type_supported(contentType)
    }
    #[inline] pub fn create_from_uri_async(uri: &foundation::Uri) -> Result<foundation::IAsyncOperation<AdaptiveMediaSourceCreationResult>> {
        <Self as RtActivatable<IAdaptiveMediaSourceStatics>>::get_activation_factory().create_from_uri_async(uri)
    }
    #[cfg(feature="windows-web")] #[inline] pub fn create_from_uri_with_downloader_async(uri: &foundation::Uri, httpClient: &crate::windows::web::http::HttpClient) -> Result<foundation::IAsyncOperation<AdaptiveMediaSourceCreationResult>> {
        <Self as RtActivatable<IAdaptiveMediaSourceStatics>>::get_activation_factory().create_from_uri_with_downloader_async(uri, httpClient)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_stream_async(stream: &crate::windows::storage::streams::IInputStream, uri: &foundation::Uri, contentType: &HStringArg) -> Result<foundation::IAsyncOperation<AdaptiveMediaSourceCreationResult>> {
        <Self as RtActivatable<IAdaptiveMediaSourceStatics>>::get_activation_factory().create_from_stream_async(stream, uri, contentType)
    }
    #[cfg(all(feature="windows-storage",feature="windows-web"))] #[inline] pub fn create_from_stream_with_downloader_async(stream: &crate::windows::storage::streams::IInputStream, uri: &foundation::Uri, contentType: &HStringArg, httpClient: &crate::windows::web::http::HttpClient) -> Result<foundation::IAsyncOperation<AdaptiveMediaSourceCreationResult>> {
        <Self as RtActivatable<IAdaptiveMediaSourceStatics>>::get_activation_factory().create_from_stream_with_downloader_async(stream, uri, contentType, httpClient)
    }
}
DEFINE_CLSID!(AdaptiveMediaSource(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,83,116,114,101,97,109,105,110,103,46,65,100,97,112,116,105,118,101,46,65,100,97,112,116,105,118,101,77,101,100,105,97,83,111,117,114,99,101,0]) [CLSID_AdaptiveMediaSource]);
DEFINE_IID!(IID_IAdaptiveMediaSource2, 394855234, 26464, 19385, 165, 138, 247, 170, 152, 176, 140, 14);
RT_INTERFACE!{interface IAdaptiveMediaSource2(IAdaptiveMediaSource2Vtbl, IAdaptiveMediaSource2_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSource2] {
    fn get_AdvancedSettings(&self, out: *mut <AdaptiveMediaSourceAdvancedSettings as RtType>::Abi) -> HRESULT
}}
impl IAdaptiveMediaSource2 {
    #[inline] pub fn get_advanced_settings(&self) -> Result<Option<AdaptiveMediaSourceAdvancedSettings>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AdvancedSettings)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AdaptiveMediaSourceAdvancedSettings::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAdaptiveMediaSource3, 3127911421, 49972, 17947, 163, 110, 201, 159, 84, 247, 23, 74);
RT_INTERFACE!{interface IAdaptiveMediaSource3(IAdaptiveMediaSource3Vtbl, IAdaptiveMediaSource3_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSource3] {
    fn get_MinLiveOffset(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_MaxSeekableWindowSize(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_DesiredSeekableWindowSize(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn put_DesiredSeekableWindowSize(&self, value: <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_Diagnostics(&self, out: *mut <AdaptiveMediaSourceDiagnostics as RtType>::Abi) -> HRESULT,
    fn GetCorrelatedTimes(&self, out: *mut <AdaptiveMediaSourceCorrelatedTimes as RtType>::Abi) -> HRESULT
}}
impl IAdaptiveMediaSource3 {
    #[inline] pub fn get_min_live_offset(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinLiveOffset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_max_seekable_window_size(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxSeekableWindowSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_desired_seekable_window_size(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DesiredSeekableWindowSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_seekable_window_size(&self, value: &foundation::IReference<foundation::TimeSpan>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DesiredSeekableWindowSize)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_diagnostics(&self) -> Result<Option<AdaptiveMediaSourceDiagnostics>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Diagnostics)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AdaptiveMediaSourceDiagnostics::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_correlated_times(&self) -> Result<Option<AdaptiveMediaSourceCorrelatedTimes>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCorrelatedTimes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AdaptiveMediaSourceCorrelatedTimes::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAdaptiveMediaSourceAdvancedSettings, 1440421504, 6891, 18396, 170, 8, 154, 17, 97, 11, 164, 90);
RT_INTERFACE!{interface IAdaptiveMediaSourceAdvancedSettings(IAdaptiveMediaSourceAdvancedSettingsVtbl, IAdaptiveMediaSourceAdvancedSettings_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceAdvancedSettings] {
    fn get_AllSegmentsIndependent(&self, out: *mut bool) -> HRESULT,
    fn put_AllSegmentsIndependent(&self, value: bool) -> HRESULT,
    fn get_DesiredBitrateHeadroomRatio(&self, out: *mut <foundation::IReference<f64> as RtType>::Abi) -> HRESULT,
    fn put_DesiredBitrateHeadroomRatio(&self, value: <foundation::IReference<f64> as RtType>::Abi) -> HRESULT,
    fn get_BitrateDowngradeTriggerRatio(&self, out: *mut <foundation::IReference<f64> as RtType>::Abi) -> HRESULT,
    fn put_BitrateDowngradeTriggerRatio(&self, value: <foundation::IReference<f64> as RtType>::Abi) -> HRESULT
}}
impl IAdaptiveMediaSourceAdvancedSettings {
    #[inline] pub fn get_all_segments_independent(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AllSegmentsIndependent)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_all_segments_independent(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AllSegmentsIndependent)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_desired_bitrate_headroom_ratio(&self) -> Result<Option<foundation::IReference<f64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DesiredBitrateHeadroomRatio)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_bitrate_headroom_ratio(&self, value: &foundation::IReference<f64>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DesiredBitrateHeadroomRatio)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_bitrate_downgrade_trigger_ratio(&self) -> Result<Option<foundation::IReference<f64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BitrateDowngradeTriggerRatio)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_bitrate_downgrade_trigger_ratio(&self, value: &foundation::IReference<f64>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BitrateDowngradeTriggerRatio)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AdaptiveMediaSourceAdvancedSettings: IAdaptiveMediaSourceAdvancedSettings}
DEFINE_IID!(IID_IAdaptiveMediaSourceCorrelatedTimes, 84969351, 57394, 18657, 171, 141, 0, 43, 11, 48, 81, 223);
RT_INTERFACE!{interface IAdaptiveMediaSourceCorrelatedTimes(IAdaptiveMediaSourceCorrelatedTimesVtbl, IAdaptiveMediaSourceCorrelatedTimes_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceCorrelatedTimes] {
    fn get_Position(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_PresentationTimeStamp(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_ProgramDateTime(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT
}}
impl IAdaptiveMediaSourceCorrelatedTimes {
    #[inline] pub fn get_position(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_presentation_time_stamp(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PresentationTimeStamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_program_date_time(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProgramDateTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AdaptiveMediaSourceCorrelatedTimes: IAdaptiveMediaSourceCorrelatedTimes}
DEFINE_IID!(IID_IAdaptiveMediaSourceCreationResult, 1183233714, 32783, 20017, 144, 147, 118, 212, 120, 32, 19, 231);
RT_INTERFACE!{interface IAdaptiveMediaSourceCreationResult(IAdaptiveMediaSourceCreationResultVtbl, IAdaptiveMediaSourceCreationResult_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceCreationResult] {
    fn get_Status(&self, out: *mut AdaptiveMediaSourceCreationStatus) -> HRESULT,
    fn get_MediaSource(&self, out: *mut <AdaptiveMediaSource as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-web")] fn get_HttpResponseMessage(&self, out: *mut <crate::windows::web::http::HttpResponseMessage as RtType>::Abi) -> HRESULT
}}
impl IAdaptiveMediaSourceCreationResult {
    #[inline] pub fn get_status(&self) -> Result<AdaptiveMediaSourceCreationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_media_source(&self) -> Result<Option<AdaptiveMediaSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AdaptiveMediaSource::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-web")] #[inline] pub fn get_http_response_message(&self) -> Result<Option<crate::windows::web::http::HttpResponseMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_HttpResponseMessage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::web::http::HttpResponseMessage::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AdaptiveMediaSourceCreationResult: IAdaptiveMediaSourceCreationResult}
DEFINE_IID!(IID_IAdaptiveMediaSourceCreationResult2, 473056191, 7236, 16459, 162, 1, 223, 69, 172, 120, 152, 232);
RT_INTERFACE!{interface IAdaptiveMediaSourceCreationResult2(IAdaptiveMediaSourceCreationResult2Vtbl, IAdaptiveMediaSourceCreationResult2_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceCreationResult2] {
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl IAdaptiveMediaSourceCreationResult2 {
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum AdaptiveMediaSourceCreationStatus: i32 {
    Success = 0, ManifestDownloadFailure = 1, ManifestParseFailure = 2, UnsupportedManifestContentType = 3, UnsupportedManifestVersion = 4, UnsupportedManifestProfile = 5, UnknownFailure = 6,
}}
DEFINE_IID!(IID_IAdaptiveMediaSourceDiagnosticAvailableEventArgs, 989220614, 28060, 18762, 183, 169, 179, 165, 222, 230, 173, 104);
RT_INTERFACE!{interface IAdaptiveMediaSourceDiagnosticAvailableEventArgs(IAdaptiveMediaSourceDiagnosticAvailableEventArgsVtbl, IAdaptiveMediaSourceDiagnosticAvailableEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceDiagnosticAvailableEventArgs] {
    fn get_DiagnosticType(&self, out: *mut AdaptiveMediaSourceDiagnosticType) -> HRESULT,
    fn get_RequestId(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_Position(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_SegmentId(&self, out: *mut <foundation::IReference<u64> as RtType>::Abi) -> HRESULT,
    fn get_ResourceType(&self, out: *mut <foundation::IReference<AdaptiveMediaSourceResourceType> as RtType>::Abi) -> HRESULT,
    fn get_ResourceUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_ResourceByteRangeOffset(&self, out: *mut <foundation::IReference<u64> as RtType>::Abi) -> HRESULT,
    fn get_ResourceByteRangeLength(&self, out: *mut <foundation::IReference<u64> as RtType>::Abi) -> HRESULT,
    fn get_Bitrate(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT
}}
impl IAdaptiveMediaSourceDiagnosticAvailableEventArgs {
    #[inline] pub fn get_diagnostic_type(&self) -> Result<AdaptiveMediaSourceDiagnosticType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DiagnosticType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_request_id(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_RequestId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_segment_id(&self) -> Result<Option<foundation::IReference<u64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SegmentId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_resource_type(&self) -> Result<Option<foundation::IReference<AdaptiveMediaSourceResourceType>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_resource_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceUri)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_resource_byte_range_offset(&self) -> Result<Option<foundation::IReference<u64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceByteRangeOffset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_resource_byte_range_length(&self) -> Result<Option<foundation::IReference<u64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceByteRangeLength)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_bitrate(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Bitrate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AdaptiveMediaSourceDiagnosticAvailableEventArgs: IAdaptiveMediaSourceDiagnosticAvailableEventArgs}
DEFINE_IID!(IID_IAdaptiveMediaSourceDiagnosticAvailableEventArgs2, 2356009047, 5797, 19871, 129, 14, 0, 189, 144, 27, 62, 249);
RT_INTERFACE!{interface IAdaptiveMediaSourceDiagnosticAvailableEventArgs2(IAdaptiveMediaSourceDiagnosticAvailableEventArgs2Vtbl, IAdaptiveMediaSourceDiagnosticAvailableEventArgs2_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceDiagnosticAvailableEventArgs2] {
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl IAdaptiveMediaSourceDiagnosticAvailableEventArgs2 {
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAdaptiveMediaSourceDiagnosticAvailableEventArgs3, 3278179541, 56043, 16643, 132, 218, 104, 118, 154, 213, 19, 255);
RT_INTERFACE!{interface IAdaptiveMediaSourceDiagnosticAvailableEventArgs3(IAdaptiveMediaSourceDiagnosticAvailableEventArgs3Vtbl, IAdaptiveMediaSourceDiagnosticAvailableEventArgs3_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceDiagnosticAvailableEventArgs3] {
    fn get_ResourceDuration(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_ResourceContentType(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAdaptiveMediaSourceDiagnosticAvailableEventArgs3 {
    #[inline] pub fn get_resource_duration(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_resource_content_type(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceContentType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAdaptiveMediaSourceDiagnostics, 2602888808, 38446, 17548, 174, 191, 178, 155, 86, 9, 142, 35);
RT_INTERFACE!{interface IAdaptiveMediaSourceDiagnostics(IAdaptiveMediaSourceDiagnosticsVtbl, IAdaptiveMediaSourceDiagnostics_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceDiagnostics] {
    fn add_DiagnosticAvailable(&self, handler: <foundation::TypedEventHandler<AdaptiveMediaSourceDiagnostics, AdaptiveMediaSourceDiagnosticAvailableEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DiagnosticAvailable(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAdaptiveMediaSourceDiagnostics {
    #[inline] pub fn add_diagnostic_available(&self, handler: &foundation::TypedEventHandler<AdaptiveMediaSourceDiagnostics, AdaptiveMediaSourceDiagnosticAvailableEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_DiagnosticAvailable)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_diagnostic_available(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_DiagnosticAvailable)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AdaptiveMediaSourceDiagnostics: IAdaptiveMediaSourceDiagnostics}
RT_ENUM! { enum AdaptiveMediaSourceDiagnosticType: i32 {
    ManifestUnchangedUponReload = 0, ManifestMismatchUponReload = 1, ManifestSignaledEndOfLiveEventUponReload = 2, MediaSegmentSkipped = 3, ResourceNotFound = 4, ResourceTimedOut = 5, ResourceParsingError = 6, BitrateDisabled = 7, FatalMediaSourceError = 8,
}}
DEFINE_IID!(IID_IAdaptiveMediaSourceDownloadBitrateChangedEventArgs, 1728842308, 57422, 20223, 129, 106, 23, 57, 159, 120, 244, 186);
RT_INTERFACE!{interface IAdaptiveMediaSourceDownloadBitrateChangedEventArgs(IAdaptiveMediaSourceDownloadBitrateChangedEventArgsVtbl, IAdaptiveMediaSourceDownloadBitrateChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceDownloadBitrateChangedEventArgs] {
    fn get_OldValue(&self, out: *mut u32) -> HRESULT,
    fn get_NewValue(&self, out: *mut u32) -> HRESULT
}}
impl IAdaptiveMediaSourceDownloadBitrateChangedEventArgs {
    #[inline] pub fn get_old_value(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OldValue)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_new_value(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_NewValue)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AdaptiveMediaSourceDownloadBitrateChangedEventArgs: IAdaptiveMediaSourceDownloadBitrateChangedEventArgs}
DEFINE_IID!(IID_IAdaptiveMediaSourceDownloadBitrateChangedEventArgs2, 4092720196, 38574, 19936, 181, 64, 43, 50, 70, 230, 150, 140);
RT_INTERFACE!{interface IAdaptiveMediaSourceDownloadBitrateChangedEventArgs2(IAdaptiveMediaSourceDownloadBitrateChangedEventArgs2Vtbl, IAdaptiveMediaSourceDownloadBitrateChangedEventArgs2_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceDownloadBitrateChangedEventArgs2] {
    fn get_Reason(&self, out: *mut AdaptiveMediaSourceDownloadBitrateChangedReason) -> HRESULT
}}
impl IAdaptiveMediaSourceDownloadBitrateChangedEventArgs2 {
    #[inline] pub fn get_reason(&self) -> Result<AdaptiveMediaSourceDownloadBitrateChangedReason> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reason)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum AdaptiveMediaSourceDownloadBitrateChangedReason: i32 {
    SufficientInboundBitsPerSecond = 0, InsufficientInboundBitsPerSecond = 1, LowBufferLevel = 2, PositionChanged = 3, TrackSelectionChanged = 4, DesiredBitratesChanged = 5, ErrorInPreviousBitrate = 6,
}}
DEFINE_IID!(IID_IAdaptiveMediaSourceDownloadCompletedEventArgs, 421793219, 23351, 18970, 137, 112, 214, 33, 203, 108, 168, 59);
RT_INTERFACE!{interface IAdaptiveMediaSourceDownloadCompletedEventArgs(IAdaptiveMediaSourceDownloadCompletedEventArgsVtbl, IAdaptiveMediaSourceDownloadCompletedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceDownloadCompletedEventArgs] {
    fn get_ResourceType(&self, out: *mut AdaptiveMediaSourceResourceType) -> HRESULT,
    fn get_ResourceUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_ResourceByteRangeOffset(&self, out: *mut <foundation::IReference<u64> as RtType>::Abi) -> HRESULT,
    fn get_ResourceByteRangeLength(&self, out: *mut <foundation::IReference<u64> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-web")] fn get_HttpResponseMessage(&self, out: *mut <crate::windows::web::http::HttpResponseMessage as RtType>::Abi) -> HRESULT
}}
impl IAdaptiveMediaSourceDownloadCompletedEventArgs {
    #[inline] pub fn get_resource_type(&self) -> Result<AdaptiveMediaSourceResourceType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_resource_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceUri)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_resource_byte_range_offset(&self) -> Result<Option<foundation::IReference<u64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceByteRangeOffset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_resource_byte_range_length(&self) -> Result<Option<foundation::IReference<u64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceByteRangeLength)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-web")] #[inline] pub fn get_http_response_message(&self) -> Result<Option<crate::windows::web::http::HttpResponseMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_HttpResponseMessage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::web::http::HttpResponseMessage::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AdaptiveMediaSourceDownloadCompletedEventArgs: IAdaptiveMediaSourceDownloadCompletedEventArgs}
DEFINE_IID!(IID_IAdaptiveMediaSourceDownloadCompletedEventArgs2, 1883718852, 38474, 16612, 175, 149, 145, 119, 221, 109, 250, 0);
RT_INTERFACE!{interface IAdaptiveMediaSourceDownloadCompletedEventArgs2(IAdaptiveMediaSourceDownloadCompletedEventArgs2Vtbl, IAdaptiveMediaSourceDownloadCompletedEventArgs2_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceDownloadCompletedEventArgs2] {
    fn get_RequestId(&self, out: *mut i32) -> HRESULT,
    fn get_Statistics(&self, out: *mut <AdaptiveMediaSourceDownloadStatistics as RtType>::Abi) -> HRESULT,
    fn get_Position(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT
}}
impl IAdaptiveMediaSourceDownloadCompletedEventArgs2 {
    #[inline] pub fn get_request_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RequestId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_statistics(&self) -> Result<Option<AdaptiveMediaSourceDownloadStatistics>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Statistics)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AdaptiveMediaSourceDownloadStatistics::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAdaptiveMediaSourceDownloadCompletedEventArgs3, 260738001, 37810, 18374, 186, 220, 139, 226, 200, 247, 246, 232);
RT_INTERFACE!{interface IAdaptiveMediaSourceDownloadCompletedEventArgs3(IAdaptiveMediaSourceDownloadCompletedEventArgs3Vtbl, IAdaptiveMediaSourceDownloadCompletedEventArgs3_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceDownloadCompletedEventArgs3] {
    fn get_ResourceDuration(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_ResourceContentType(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAdaptiveMediaSourceDownloadCompletedEventArgs3 {
    #[inline] pub fn get_resource_duration(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_resource_content_type(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceContentType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAdaptiveMediaSourceDownloadFailedEventArgs, 930320456, 62635, 16548, 177, 53, 198, 223, 216, 189, 127, 241);
RT_INTERFACE!{interface IAdaptiveMediaSourceDownloadFailedEventArgs(IAdaptiveMediaSourceDownloadFailedEventArgsVtbl, IAdaptiveMediaSourceDownloadFailedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceDownloadFailedEventArgs] {
    fn get_ResourceType(&self, out: *mut AdaptiveMediaSourceResourceType) -> HRESULT,
    fn get_ResourceUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_ResourceByteRangeOffset(&self, out: *mut <foundation::IReference<u64> as RtType>::Abi) -> HRESULT,
    fn get_ResourceByteRangeLength(&self, out: *mut <foundation::IReference<u64> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-web")] fn get_HttpResponseMessage(&self, out: *mut <crate::windows::web::http::HttpResponseMessage as RtType>::Abi) -> HRESULT
}}
impl IAdaptiveMediaSourceDownloadFailedEventArgs {
    #[inline] pub fn get_resource_type(&self) -> Result<AdaptiveMediaSourceResourceType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_resource_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceUri)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_resource_byte_range_offset(&self) -> Result<Option<foundation::IReference<u64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceByteRangeOffset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_resource_byte_range_length(&self) -> Result<Option<foundation::IReference<u64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceByteRangeLength)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-web")] #[inline] pub fn get_http_response_message(&self) -> Result<Option<crate::windows::web::http::HttpResponseMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_HttpResponseMessage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::web::http::HttpResponseMessage::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AdaptiveMediaSourceDownloadFailedEventArgs: IAdaptiveMediaSourceDownloadFailedEventArgs}
DEFINE_IID!(IID_IAdaptiveMediaSourceDownloadFailedEventArgs2, 1888589160, 38524, 18822, 144, 197, 198, 252, 75, 49, 226, 216);
RT_INTERFACE!{interface IAdaptiveMediaSourceDownloadFailedEventArgs2(IAdaptiveMediaSourceDownloadFailedEventArgs2Vtbl, IAdaptiveMediaSourceDownloadFailedEventArgs2_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceDownloadFailedEventArgs2] {
    fn get_RequestId(&self, out: *mut i32) -> HRESULT,
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT,
    fn get_Statistics(&self, out: *mut <AdaptiveMediaSourceDownloadStatistics as RtType>::Abi) -> HRESULT,
    fn get_Position(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT
}}
impl IAdaptiveMediaSourceDownloadFailedEventArgs2 {
    #[inline] pub fn get_request_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RequestId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_statistics(&self) -> Result<Option<AdaptiveMediaSourceDownloadStatistics>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Statistics)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AdaptiveMediaSourceDownloadStatistics::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAdaptiveMediaSourceDownloadFailedEventArgs3, 3493152073, 4402, 18960, 145, 90, 194, 33, 27, 91, 148, 9);
RT_INTERFACE!{interface IAdaptiveMediaSourceDownloadFailedEventArgs3(IAdaptiveMediaSourceDownloadFailedEventArgs3Vtbl, IAdaptiveMediaSourceDownloadFailedEventArgs3_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceDownloadFailedEventArgs3] {
    fn get_ResourceDuration(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_ResourceContentType(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAdaptiveMediaSourceDownloadFailedEventArgs3 {
    #[inline] pub fn get_resource_duration(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_resource_content_type(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceContentType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAdaptiveMediaSourceDownloadRequestedDeferral, 96898916, 64032, 19901, 152, 33, 75, 244, 201, 191, 119, 171);
RT_INTERFACE!{interface IAdaptiveMediaSourceDownloadRequestedDeferral(IAdaptiveMediaSourceDownloadRequestedDeferralVtbl, IAdaptiveMediaSourceDownloadRequestedDeferral_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceDownloadRequestedDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IAdaptiveMediaSourceDownloadRequestedDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Complete)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AdaptiveMediaSourceDownloadRequestedDeferral: IAdaptiveMediaSourceDownloadRequestedDeferral}
DEFINE_IID!(IID_IAdaptiveMediaSourceDownloadRequestedEventArgs, 3359629309, 17577, 18338, 191, 150, 3, 57, 139, 75, 250, 175);
RT_INTERFACE!{interface IAdaptiveMediaSourceDownloadRequestedEventArgs(IAdaptiveMediaSourceDownloadRequestedEventArgsVtbl, IAdaptiveMediaSourceDownloadRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceDownloadRequestedEventArgs] {
    fn get_ResourceType(&self, out: *mut AdaptiveMediaSourceResourceType) -> HRESULT,
    fn get_ResourceUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_ResourceByteRangeOffset(&self, out: *mut <foundation::IReference<u64> as RtType>::Abi) -> HRESULT,
    fn get_ResourceByteRangeLength(&self, out: *mut <foundation::IReference<u64> as RtType>::Abi) -> HRESULT,
    fn get_Result(&self, out: *mut <AdaptiveMediaSourceDownloadResult as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <AdaptiveMediaSourceDownloadRequestedDeferral as RtType>::Abi) -> HRESULT
}}
impl IAdaptiveMediaSourceDownloadRequestedEventArgs {
    #[inline] pub fn get_resource_type(&self) -> Result<AdaptiveMediaSourceResourceType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_resource_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceUri)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_resource_byte_range_offset(&self) -> Result<Option<foundation::IReference<u64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceByteRangeOffset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_resource_byte_range_length(&self) -> Result<Option<foundation::IReference<u64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceByteRangeLength)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_result(&self) -> Result<Option<AdaptiveMediaSourceDownloadResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Result)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AdaptiveMediaSourceDownloadResult::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<AdaptiveMediaSourceDownloadRequestedDeferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AdaptiveMediaSourceDownloadRequestedDeferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AdaptiveMediaSourceDownloadRequestedEventArgs: IAdaptiveMediaSourceDownloadRequestedEventArgs}
DEFINE_IID!(IID_IAdaptiveMediaSourceDownloadRequestedEventArgs2, 3011349502, 43588, 19842, 130, 91, 97, 29, 227, 188, 254, 203);
RT_INTERFACE!{interface IAdaptiveMediaSourceDownloadRequestedEventArgs2(IAdaptiveMediaSourceDownloadRequestedEventArgs2Vtbl, IAdaptiveMediaSourceDownloadRequestedEventArgs2_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceDownloadRequestedEventArgs2] {
    fn get_RequestId(&self, out: *mut i32) -> HRESULT,
    fn get_Position(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT
}}
impl IAdaptiveMediaSourceDownloadRequestedEventArgs2 {
    #[inline] pub fn get_request_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RequestId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAdaptiveMediaSourceDownloadRequestedEventArgs3, 859590909, 20322, 17537, 171, 68, 30, 71, 176, 87, 66, 37);
RT_INTERFACE!{interface IAdaptiveMediaSourceDownloadRequestedEventArgs3(IAdaptiveMediaSourceDownloadRequestedEventArgs3Vtbl, IAdaptiveMediaSourceDownloadRequestedEventArgs3_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceDownloadRequestedEventArgs3] {
    fn get_ResourceDuration(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_ResourceContentType(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAdaptiveMediaSourceDownloadRequestedEventArgs3 {
    #[inline] pub fn get_resource_duration(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_resource_content_type(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceContentType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAdaptiveMediaSourceDownloadResult, 4105165939, 48366, 19050, 159, 10, 254, 196, 30, 35, 57, 176);
RT_INTERFACE!{interface IAdaptiveMediaSourceDownloadResult(IAdaptiveMediaSourceDownloadResultVtbl, IAdaptiveMediaSourceDownloadResult_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceDownloadResult] {
    fn get_ResourceUri(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_ResourceUri(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_InputStream(&self, out: *mut <crate::windows::storage::streams::IInputStream as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_InputStream(&self, value: <crate::windows::storage::streams::IInputStream as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Buffer(&self, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Buffer(&self, value: <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_ContentType(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ContentType(&self, value: HSTRING) -> HRESULT,
    fn get_ExtendedStatus(&self, out: *mut u32) -> HRESULT,
    fn put_ExtendedStatus(&self, value: u32) -> HRESULT
}}
impl IAdaptiveMediaSourceDownloadResult {
    #[inline] pub fn get_resource_uri(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceUri)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_resource_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ResourceUri)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_input_stream(&self) -> Result<Option<crate::windows::storage::streams::IInputStream>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_InputStream)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IInputStream::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_input_stream(&self, value: &crate::windows::storage::streams::IInputStream) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_InputStream)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_buffer(&self) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Buffer)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_buffer(&self, value: &crate::windows::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Buffer)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_content_type(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ContentType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_content_type(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ContentType)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_status(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_extended_status(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ExtendedStatus)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AdaptiveMediaSourceDownloadResult: IAdaptiveMediaSourceDownloadResult}
DEFINE_IID!(IID_IAdaptiveMediaSourceDownloadResult2, 357903543, 31616, 19140, 134, 96, 164, 185, 127, 124, 112, 240);
RT_INTERFACE!{interface IAdaptiveMediaSourceDownloadResult2(IAdaptiveMediaSourceDownloadResult2Vtbl, IAdaptiveMediaSourceDownloadResult2_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceDownloadResult2] {
    fn get_ResourceByteRangeOffset(&self, out: *mut <foundation::IReference<u64> as RtType>::Abi) -> HRESULT,
    fn put_ResourceByteRangeOffset(&self, value: <foundation::IReference<u64> as RtType>::Abi) -> HRESULT,
    fn get_ResourceByteRangeLength(&self, out: *mut <foundation::IReference<u64> as RtType>::Abi) -> HRESULT,
    fn put_ResourceByteRangeLength(&self, value: <foundation::IReference<u64> as RtType>::Abi) -> HRESULT
}}
impl IAdaptiveMediaSourceDownloadResult2 {
    #[inline] pub fn get_resource_byte_range_offset(&self) -> Result<Option<foundation::IReference<u64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceByteRangeOffset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_resource_byte_range_offset(&self, value: &foundation::IReference<u64>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ResourceByteRangeOffset)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_resource_byte_range_length(&self) -> Result<Option<foundation::IReference<u64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResourceByteRangeLength)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_resource_byte_range_length(&self, value: &foundation::IReference<u64>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ResourceByteRangeLength)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAdaptiveMediaSourceDownloadStatistics, 2735132411, 59754, 19967, 169, 184, 26, 224, 140, 1, 174, 152);
RT_INTERFACE!{interface IAdaptiveMediaSourceDownloadStatistics(IAdaptiveMediaSourceDownloadStatisticsVtbl, IAdaptiveMediaSourceDownloadStatistics_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceDownloadStatistics] {
    fn get_ContentBytesReceivedCount(&self, out: *mut u64) -> HRESULT,
    fn get_TimeToHeadersReceived(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_TimeToFirstByteReceived(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_TimeToLastByteReceived(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT
}}
impl IAdaptiveMediaSourceDownloadStatistics {
    #[inline] pub fn get_content_bytes_received_count(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ContentBytesReceivedCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_time_to_headers_received(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TimeToHeadersReceived)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_time_to_first_byte_received(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TimeToFirstByteReceived)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_time_to_last_byte_received(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TimeToLastByteReceived)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AdaptiveMediaSourceDownloadStatistics: IAdaptiveMediaSourceDownloadStatistics}
DEFINE_IID!(IID_IAdaptiveMediaSourcePlaybackBitrateChangedEventArgs, 597860205, 32218, 19025, 135, 169, 111, 168, 197, 178, 146, 190);
RT_INTERFACE!{interface IAdaptiveMediaSourcePlaybackBitrateChangedEventArgs(IAdaptiveMediaSourcePlaybackBitrateChangedEventArgsVtbl, IAdaptiveMediaSourcePlaybackBitrateChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourcePlaybackBitrateChangedEventArgs] {
    fn get_OldValue(&self, out: *mut u32) -> HRESULT,
    fn get_NewValue(&self, out: *mut u32) -> HRESULT,
    fn get_AudioOnly(&self, out: *mut bool) -> HRESULT
}}
impl IAdaptiveMediaSourcePlaybackBitrateChangedEventArgs {
    #[inline] pub fn get_old_value(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OldValue)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_new_value(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_NewValue)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_audio_only(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioOnly)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AdaptiveMediaSourcePlaybackBitrateChangedEventArgs: IAdaptiveMediaSourcePlaybackBitrateChangedEventArgs}
RT_ENUM! { enum AdaptiveMediaSourceResourceType: i32 {
    Manifest = 0, InitializationSegment = 1, MediaSegment = 2, Key = 3, InitializationVector = 4, MediaSegmentIndex = 5,
}}
DEFINE_IID!(IID_IAdaptiveMediaSourceStatics, 1353104733, 26351, 19667, 149, 121, 158, 102, 5, 7, 220, 63);
RT_INTERFACE!{static interface IAdaptiveMediaSourceStatics(IAdaptiveMediaSourceStaticsVtbl, IAdaptiveMediaSourceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IAdaptiveMediaSourceStatics] {
    fn IsContentTypeSupported(&self, contentType: HSTRING, out: *mut bool) -> HRESULT,
    fn CreateFromUriAsync(&self, uri: <foundation::Uri as RtType>::Abi, out: *mut <foundation::IAsyncOperation<AdaptiveMediaSourceCreationResult> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-web"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-web")] fn CreateFromUriWithDownloaderAsync(&self, uri: <foundation::Uri as RtType>::Abi, httpClient: <crate::windows::web::http::HttpClient as RtType>::Abi, out: *mut <foundation::IAsyncOperation<AdaptiveMediaSourceCreationResult> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-storage")] fn CreateFromStreamAsync(&self, stream: <crate::windows::storage::streams::IInputStream as RtType>::Abi, uri: <foundation::Uri as RtType>::Abi, contentType: HSTRING, out: *mut <foundation::IAsyncOperation<AdaptiveMediaSourceCreationResult> as RtType>::Abi) -> HRESULT,
    #[cfg(all(feature="windows-storage",feature="windows-web"))] fn CreateFromStreamWithDownloaderAsync(&self, stream: <crate::windows::storage::streams::IInputStream as RtType>::Abi, uri: <foundation::Uri as RtType>::Abi, contentType: HSTRING, httpClient: <crate::windows::web::http::HttpClient as RtType>::Abi, out: *mut <foundation::IAsyncOperation<AdaptiveMediaSourceCreationResult> as RtType>::Abi) -> HRESULT
}}
impl IAdaptiveMediaSourceStatics {
    #[inline] pub fn is_content_type_supported(&self, contentType: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsContentTypeSupported)(self.0.as_abi() as *const _ as *mut _, contentType.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn create_from_uri_async(&self, uri: &foundation::Uri) -> Result<foundation::IAsyncOperation<AdaptiveMediaSourceCreationResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromUriAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(uri) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-web")] #[inline] pub fn create_from_uri_with_downloader_async(&self, uri: &foundation::Uri, httpClient: &crate::windows::web::http::HttpClient) -> Result<foundation::IAsyncOperation<AdaptiveMediaSourceCreationResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromUriWithDownloaderAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(uri) as *const _ as *mut _, get_abi(httpClient) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_stream_async(&self, stream: &crate::windows::storage::streams::IInputStream, uri: &foundation::Uri, contentType: &HStringArg) -> Result<foundation::IAsyncOperation<AdaptiveMediaSourceCreationResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromStreamAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(stream) as *const _ as *mut _, get_abi(uri) as *const _ as *mut _, contentType.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(all(feature="windows-storage",feature="windows-web"))] #[inline] pub fn create_from_stream_with_downloader_async(&self, stream: &crate::windows::storage::streams::IInputStream, uri: &foundation::Uri, contentType: &HStringArg, httpClient: &crate::windows::web::http::HttpClient) -> Result<foundation::IAsyncOperation<AdaptiveMediaSourceCreationResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromStreamWithDownloaderAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(stream) as *const _ as *mut _, get_abi(uri) as *const _ as *mut _, contentType.get(), get_abi(httpClient) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
} // Windows.Media.Streaming.Adaptive
} // Windows.Media.Streaming
pub mod transcoding { // Windows.Media.Transcoding
use crate::prelude::*;
DEFINE_IID!(IID_IMediaTranscoder, 420256210, 41130, 19764, 134, 188, 238, 209, 177, 44, 47, 91);
RT_INTERFACE!{interface IMediaTranscoder(IMediaTranscoderVtbl, IMediaTranscoder_Abi): IInspectable(IInspectableVtbl) [IID_IMediaTranscoder] {
    fn put_TrimStartTime(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_TrimStartTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_TrimStopTime(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_TrimStopTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_AlwaysReencode(&self, value: bool) -> HRESULT,
    fn get_AlwaysReencode(&self, out: *mut bool) -> HRESULT,
    fn put_HardwareAccelerationEnabled(&self, value: bool) -> HRESULT,
    fn get_HardwareAccelerationEnabled(&self, out: *mut bool) -> HRESULT,
    fn AddAudioEffect(&self, activatableClassId: HSTRING) -> HRESULT,
    fn AddAudioEffectWithSettings(&self, activatableClassId: HSTRING, effectRequired: bool, configuration: <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT,
    fn AddVideoEffect(&self, activatableClassId: HSTRING) -> HRESULT,
    fn AddVideoEffectWithSettings(&self, activatableClassId: HSTRING, effectRequired: bool, configuration: <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT,
    fn ClearEffects(&self) -> HRESULT,
    #[cfg(feature="windows-storage")] fn PrepareFileTranscodeAsync(&self, source: <super::super::storage::IStorageFile as RtType>::Abi, destination: <super::super::storage::IStorageFile as RtType>::Abi, profile: <super::mediaproperties::MediaEncodingProfile as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PrepareTranscodeResult> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn PrepareStreamTranscodeAsync(&self, source: <super::super::storage::streams::IRandomAccessStream as RtType>::Abi, destination: <super::super::storage::streams::IRandomAccessStream as RtType>::Abi, profile: <super::mediaproperties::MediaEncodingProfile as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PrepareTranscodeResult> as RtType>::Abi) -> HRESULT
}}
impl IMediaTranscoder {
    #[inline] pub fn set_trim_start_time(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_TrimStartTime)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_trim_start_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TrimStartTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_trim_stop_time(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_TrimStopTime)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_trim_stop_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TrimStopTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_always_reencode(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AlwaysReencode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_always_reencode(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AlwaysReencode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_hardware_acceleration_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_HardwareAccelerationEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_hardware_acceleration_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HardwareAccelerationEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_audio_effect(&self, activatableClassId: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AddAudioEffect)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_audio_effect_with_settings(&self, activatableClassId: &HStringArg, effectRequired: bool, configuration: &foundation::collections::IPropertySet) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AddAudioEffectWithSettings)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get(), effectRequired, get_abi(configuration) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_video_effect(&self, activatableClassId: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AddVideoEffect)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_video_effect_with_settings(&self, activatableClassId: &HStringArg, effectRequired: bool, configuration: &foundation::collections::IPropertySet) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AddVideoEffectWithSettings)(self.0.as_abi() as *const _ as *mut _, activatableClassId.get(), effectRequired, get_abi(configuration) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn clear_effects(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ClearEffects)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn prepare_file_transcode_async(&self, source: &super::super::storage::IStorageFile, destination: &super::super::storage::IStorageFile, profile: &super::mediaproperties::MediaEncodingProfile) -> Result<foundation::IAsyncOperation<PrepareTranscodeResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PrepareFileTranscodeAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(source) as *const _ as *mut _, get_abi(destination) as *const _ as *mut _, get_abi(profile) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn prepare_stream_transcode_async(&self, source: &super::super::storage::streams::IRandomAccessStream, destination: &super::super::storage::streams::IRandomAccessStream, profile: &super::mediaproperties::MediaEncodingProfile) -> Result<foundation::IAsyncOperation<PrepareTranscodeResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PrepareStreamTranscodeAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(source) as *const _ as *mut _, get_abi(destination) as *const _ as *mut _, get_abi(profile) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MediaTranscoder: IMediaTranscoder}
impl RtActivatable<IActivationFactory> for MediaTranscoder {}
DEFINE_CLSID!(MediaTranscoder(&[87,105,110,100,111,119,115,46,77,101,100,105,97,46,84,114,97,110,115,99,111,100,105,110,103,46,77,101,100,105,97,84,114,97,110,115,99,111,100,101,114,0]) [CLSID_MediaTranscoder]);
DEFINE_IID!(IID_IMediaTranscoder2, 1079188852, 13792, 20228, 133, 116, 202, 139, 196, 229, 160, 130);
RT_INTERFACE!{interface IMediaTranscoder2(IMediaTranscoder2Vtbl, IMediaTranscoder2_Abi): IInspectable(IInspectableVtbl) [IID_IMediaTranscoder2] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn PrepareMediaStreamSourceTranscodeAsync(&self, source: <super::core::IMediaSource as RtType>::Abi, destination: <super::super::storage::streams::IRandomAccessStream as RtType>::Abi, profile: <super::mediaproperties::MediaEncodingProfile as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PrepareTranscodeResult> as RtType>::Abi) -> HRESULT,
    fn put_VideoProcessingAlgorithm(&self, value: MediaVideoProcessingAlgorithm) -> HRESULT,
    fn get_VideoProcessingAlgorithm(&self, out: *mut MediaVideoProcessingAlgorithm) -> HRESULT
}}
impl IMediaTranscoder2 {
    #[cfg(feature="windows-storage")] #[inline] pub fn prepare_media_stream_source_transcode_async(&self, source: &super::core::IMediaSource, destination: &super::super::storage::streams::IRandomAccessStream, profile: &super::mediaproperties::MediaEncodingProfile) -> Result<foundation::IAsyncOperation<PrepareTranscodeResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PrepareMediaStreamSourceTranscodeAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(source) as *const _ as *mut _, get_abi(destination) as *const _ as *mut _, get_abi(profile) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_video_processing_algorithm(&self, value: MediaVideoProcessingAlgorithm) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_VideoProcessingAlgorithm)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_video_processing_algorithm(&self) -> Result<MediaVideoProcessingAlgorithm> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoProcessingAlgorithm)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum MediaVideoProcessingAlgorithm: i32 {
    Default = 0, MrfCrf444 = 1,
}}
DEFINE_IID!(IID_IPrepareTranscodeResult, 99769806, 39247, 18996, 157, 104, 151, 204, 206, 23, 48, 214);
RT_INTERFACE!{interface IPrepareTranscodeResult(IPrepareTranscodeResultVtbl, IPrepareTranscodeResult_Abi): IInspectable(IInspectableVtbl) [IID_IPrepareTranscodeResult] {
    fn get_CanTranscode(&self, out: *mut bool) -> HRESULT,
    fn get_FailureReason(&self, out: *mut TranscodeFailureReason) -> HRESULT,
    fn TranscodeAsync(&self, out: *mut <foundation::IAsyncActionWithProgress<f64> as RtType>::Abi) -> HRESULT
}}
impl IPrepareTranscodeResult {
    #[inline] pub fn get_can_transcode(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanTranscode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_failure_reason(&self) -> Result<TranscodeFailureReason> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FailureReason)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn transcode_async(&self) -> Result<foundation::IAsyncActionWithProgress<f64>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TranscodeAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncActionWithProgress::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PrepareTranscodeResult: IPrepareTranscodeResult}
RT_ENUM! { enum TranscodeFailureReason: i32 {
    None = 0, Unknown = 1, InvalidProfile = 2, CodecNotFound = 3,
}}
} // Windows.Media.Transcoding
