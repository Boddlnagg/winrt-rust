use ::prelude::*;
DEFINE_IID!(IID_IDataTemplateExtension, 1499370823, 52735, 19346, 183, 115, 171, 57, 104, 120, 243, 83);
RT_INTERFACE!{interface IDataTemplateExtension(IDataTemplateExtensionVtbl): IInspectable(IInspectableVtbl) [IID_IDataTemplateExtension] {
    fn ResetTemplate(&self) -> HRESULT,
    fn ProcessBinding(&self, phase: u32, out: *mut bool) -> HRESULT,
    fn ProcessBindings(&self, arg: *mut controls::ContainerContentChangingEventArgs, out: *mut i32) -> HRESULT
}}
impl IDataTemplateExtension {
    #[inline] pub unsafe fn reset_template(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ResetTemplate)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn process_binding(&self, phase: u32) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).ProcessBinding)(self as *const _ as *mut _, phase, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn process_bindings(&self, arg: &controls::ContainerContentChangingEventArgs) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).ProcessBindings)(self as *const _ as *mut _, arg as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDataTemplate, 2568007367, 35509, 16664, 155, 198, 9, 244, 90, 53, 7, 61);
RT_INTERFACE!{interface IDataTemplate(IDataTemplateVtbl): IInspectable(IInspectableVtbl) [IID_IDataTemplate] {
    fn LoadContent(&self, out: *mut *mut DependencyObject) -> HRESULT
}}
impl IDataTemplate {
    #[inline] pub unsafe fn load_content(&self) -> Result<ComPtr<DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).LoadContent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDataTemplateFactory, 1374526846, 11091, 18267, 156, 136, 12, 24, 50, 200, 53, 26);
RT_INTERFACE!{interface IDataTemplateFactory(IDataTemplateFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IDataTemplateFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut DataTemplate) -> HRESULT
}}
impl IDataTemplateFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<DataTemplate>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDataTemplateStatics2, 2331475315, 43521, 18206, 190, 221, 139, 173, 134, 33, 155, 119);
RT_INTERFACE!{static interface IDataTemplateStatics2(IDataTemplateStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IDataTemplateStatics2] {
    fn get_ExtensionInstanceProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn GetExtensionInstance(&self, element: *mut FrameworkElement, out: *mut *mut IDataTemplateExtension) -> HRESULT,
    fn SetExtensionInstance(&self, element: *mut FrameworkElement, value: *mut IDataTemplateExtension) -> HRESULT
}}
impl IDataTemplateStatics2 {
    #[inline] pub unsafe fn get_extension_instance_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExtensionInstanceProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_extension_instance(&self, element: &FrameworkElement) -> Result<ComPtr<IDataTemplateExtension>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetExtensionInstance)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_extension_instance(&self, element: &FrameworkElement, value: &IDataTemplateExtension) -> Result<()> {
        let hr = ((*self.lpVtbl).SetExtensionInstance)(self as *const _ as *mut _, element as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDispatcherTimer, 3512782406, 52514, 20319, 140, 151, 64, 230, 29, 163, 226, 220);
RT_INTERFACE!{interface IDispatcherTimer(IDispatcherTimerVtbl): IInspectable(IInspectableVtbl) [IID_IDispatcherTimer] {
    fn get_Interval(&self, out: *mut super::super::foundation::TimeSpan) -> HRESULT,
    fn put_Interval(&self, value: super::super::foundation::TimeSpan) -> HRESULT,
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn add_Tick(&self, value: *mut super::super::foundation::EventHandler<IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Tick(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT
}}
impl IDispatcherTimer {
    #[inline] pub unsafe fn get_interval(&self) -> Result<super::super::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Interval)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_interval(&self, value: super::super::foundation::TimeSpan) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Interval)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_tick(&self, value: &super::super::foundation::EventHandler<IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Tick)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_tick(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Tick)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn start(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Start)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn stop(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Stop)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDispatcherTimerFactory, 3918929518, 13862, 16442, 175, 224, 4, 13, 88, 22, 86, 50);
RT_INTERFACE!{interface IDispatcherTimerFactory(IDispatcherTimerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IDispatcherTimerFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut DispatcherTimer) -> HRESULT
}}
impl IDispatcherTimerFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<DispatcherTimer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class DispatcherTimer: IDispatcherTimer}
RT_ENUM! { enum DurationType: i32 {
    Automatic (DurationType_Automatic) = 0, TimeSpan (DurationType_TimeSpan) = 1, Forever (DurationType_Forever) = 2,
}}
RT_ENUM! { enum ElementHighContrastAdjustment: u32 {
    None (ElementHighContrastAdjustment_None) = 0, Application (ElementHighContrastAdjustment_Application) = 2147483648, Auto (ElementHighContrastAdjustment_Auto) = 4294967295,
}}
RT_ENUM! { enum ElementSoundKind: i32 {
    Focus (ElementSoundKind_Focus) = 0, Invoke (ElementSoundKind_Invoke) = 1, Show (ElementSoundKind_Show) = 2, Hide (ElementSoundKind_Hide) = 3, MovePrevious (ElementSoundKind_MovePrevious) = 4, MoveNext (ElementSoundKind_MoveNext) = 5, GoBack (ElementSoundKind_GoBack) = 6,
}}
RT_ENUM! { enum ElementSoundMode: i32 {
    Default (ElementSoundMode_Default) = 0, FocusOnly (ElementSoundMode_FocusOnly) = 1, Off (ElementSoundMode_Off) = 2,
}}
RT_ENUM! { enum ElementTheme: i32 {
    Default (ElementTheme_Default) = 0, Light (ElementTheme_Light) = 1, Dark (ElementTheme_Dark) = 2,
}}
RT_ENUM! { enum FlowDirection: i32 {
    LeftToRight (FlowDirection_LeftToRight) = 0, RightToLeft (FlowDirection_RightToLeft) = 1,
}}
RT_ENUM! { enum FocusState: i32 {
    Unfocused (FocusState_Unfocused) = 0, Pointer (FocusState_Pointer) = 1, Keyboard (FocusState_Keyboard) = 2, Programmatic (FocusState_Programmatic) = 3,
}}
RT_ENUM! { enum FocusVisualKind: i32 {
    DottedLine (FocusVisualKind_DottedLine) = 0, HighVisibility (FocusVisualKind_HighVisibility) = 1,
}}
RT_ENUM! { enum HorizontalAlignment: i32 {
    Left (HorizontalAlignment_Left) = 0, Center (HorizontalAlignment_Center) = 1, Right (HorizontalAlignment_Right) = 2, Stretch (HorizontalAlignment_Stretch) = 3,
}}
RT_ENUM! { enum VerticalAlignment: i32 {
    Top (VerticalAlignment_Top) = 0, Center (VerticalAlignment_Center) = 1, Bottom (VerticalAlignment_Bottom) = 2, Stretch (VerticalAlignment_Stretch) = 3,
}}
RT_ENUM! { enum Visibility: i32 {
    Visible (Visibility_Visible) = 0, Collapsed (Visibility_Collapsed) = 1,
}}
RT_STRUCT! { struct CornerRadius {
    TopLeft: f64, TopRight: f64, BottomRight: f64, BottomLeft: f64,
}}
DEFINE_IID!(IID_ICornerRadiusHelper, 4252754306, 7387, 17032, 184, 200, 133, 238, 121, 41, 123, 252);
RT_INTERFACE!{interface ICornerRadiusHelper(ICornerRadiusHelperVtbl): IInspectable(IInspectableVtbl) [IID_ICornerRadiusHelper] {
    
}}
DEFINE_IID!(IID_ICornerRadiusHelperStatics, 4104255065, 54484, 17695, 163, 135, 214, 191, 75, 36, 81, 212);
RT_INTERFACE!{static interface ICornerRadiusHelperStatics(ICornerRadiusHelperStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICornerRadiusHelperStatics] {
    fn FromRadii(&self, topLeft: f64, topRight: f64, bottomRight: f64, bottomLeft: f64, out: *mut CornerRadius) -> HRESULT,
    fn FromUniformRadius(&self, uniformRadius: f64, out: *mut CornerRadius) -> HRESULT
}}
impl ICornerRadiusHelperStatics {
    #[inline] pub unsafe fn from_radii(&self, topLeft: f64, topRight: f64, bottomRight: f64, bottomLeft: f64) -> Result<CornerRadius> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).FromRadii)(self as *const _ as *mut _, topLeft, topRight, bottomRight, bottomLeft, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn from_uniform_radius(&self, uniformRadius: f64) -> Result<CornerRadius> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).FromUniformRadius)(self as *const _ as *mut _, uniformRadius, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class CornerRadiusHelper: ICornerRadiusHelper}
impl RtActivatable<ICornerRadiusHelperStatics> for CornerRadiusHelper {}
impl CornerRadiusHelper {
    #[inline] pub fn from_radii(topLeft: f64, topRight: f64, bottomRight: f64, bottomLeft: f64) -> Result<CornerRadius> { unsafe {
        <Self as RtActivatable<ICornerRadiusHelperStatics>>::get_activation_factory().from_radii(topLeft, topRight, bottomRight, bottomLeft)
    }}
    #[inline] pub fn from_uniform_radius(uniformRadius: f64) -> Result<CornerRadius> { unsafe {
        <Self as RtActivatable<ICornerRadiusHelperStatics>>::get_activation_factory().from_uniform_radius(uniformRadius)
    }}
}
DEFINE_CLSID!(CornerRadiusHelper(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,114,110,101,114,82,97,100,105,117,115,72,101,108,112,101,114,0]) [CLSID_CornerRadiusHelper]);
RT_STRUCT! { struct Duration {
    TimeSpan: super::super::foundation::TimeSpan, Type: DurationType,
}}
DEFINE_IID!(IID_IDurationHelper, 633431455, 17559, 16693, 148, 15, 238, 150, 244, 214, 233, 52);
RT_INTERFACE!{interface IDurationHelper(IDurationHelperVtbl): IInspectable(IInspectableVtbl) [IID_IDurationHelper] {
    
}}
DEFINE_IID!(IID_IDurationHelperStatics, 3163031870, 13639, 20160, 181, 25, 255, 168, 249, 196, 131, 140);
RT_INTERFACE!{static interface IDurationHelperStatics(IDurationHelperStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDurationHelperStatics] {
    fn get_Automatic(&self, out: *mut Duration) -> HRESULT,
    fn get_Forever(&self, out: *mut Duration) -> HRESULT,
    fn Compare(&self, duration1: Duration, duration2: Duration, out: *mut i32) -> HRESULT,
    fn FromTimeSpan(&self, timeSpan: super::super::foundation::TimeSpan, out: *mut Duration) -> HRESULT,
    fn GetHasTimeSpan(&self, target: Duration, out: *mut bool) -> HRESULT,
    fn Add(&self, target: Duration, duration: Duration, out: *mut Duration) -> HRESULT,
    fn Equals(&self, target: Duration, value: Duration, out: *mut bool) -> HRESULT,
    fn Subtract(&self, target: Duration, duration: Duration, out: *mut Duration) -> HRESULT
}}
impl IDurationHelperStatics {
    #[inline] pub unsafe fn get_automatic(&self) -> Result<Duration> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Automatic)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_forever(&self) -> Result<Duration> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Forever)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn compare(&self, duration1: Duration, duration2: Duration) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Compare)(self as *const _ as *mut _, duration1, duration2, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn from_time_span(&self, timeSpan: super::super::foundation::TimeSpan) -> Result<Duration> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).FromTimeSpan)(self as *const _ as *mut _, timeSpan, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_has_time_span(&self, target: Duration) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetHasTimeSpan)(self as *const _ as *mut _, target, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn add(&self, target: Duration, duration: Duration) -> Result<Duration> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Add)(self as *const _ as *mut _, target, duration, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn equals(&self, target: Duration, value: Duration) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Equals)(self as *const _ as *mut _, target, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn subtract(&self, target: Duration, duration: Duration) -> Result<Duration> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Subtract)(self as *const _ as *mut _, target, duration, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class DurationHelper: IDurationHelper}
impl RtActivatable<IDurationHelperStatics> for DurationHelper {}
impl DurationHelper {
    #[inline] pub fn get_automatic() -> Result<Duration> { unsafe {
        <Self as RtActivatable<IDurationHelperStatics>>::get_activation_factory().get_automatic()
    }}
    #[inline] pub fn get_forever() -> Result<Duration> { unsafe {
        <Self as RtActivatable<IDurationHelperStatics>>::get_activation_factory().get_forever()
    }}
    #[inline] pub fn compare(duration1: Duration, duration2: Duration) -> Result<i32> { unsafe {
        <Self as RtActivatable<IDurationHelperStatics>>::get_activation_factory().compare(duration1, duration2)
    }}
    #[inline] pub fn from_time_span(timeSpan: super::super::foundation::TimeSpan) -> Result<Duration> { unsafe {
        <Self as RtActivatable<IDurationHelperStatics>>::get_activation_factory().from_time_span(timeSpan)
    }}
    #[inline] pub fn get_has_time_span(target: Duration) -> Result<bool> { unsafe {
        <Self as RtActivatable<IDurationHelperStatics>>::get_activation_factory().get_has_time_span(target)
    }}
    #[inline] pub fn add(target: Duration, duration: Duration) -> Result<Duration> { unsafe {
        <Self as RtActivatable<IDurationHelperStatics>>::get_activation_factory().add(target, duration)
    }}
    #[inline] pub fn equals(target: Duration, value: Duration) -> Result<bool> { unsafe {
        <Self as RtActivatable<IDurationHelperStatics>>::get_activation_factory().equals(target, value)
    }}
    #[inline] pub fn subtract(target: Duration, duration: Duration) -> Result<Duration> { unsafe {
        <Self as RtActivatable<IDurationHelperStatics>>::get_activation_factory().subtract(target, duration)
    }}
}
DEFINE_CLSID!(DurationHelper(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,68,117,114,97,116,105,111,110,72,101,108,112,101,114,0]) [CLSID_DurationHelper]);
RT_STRUCT! { struct Thickness {
    Left: f64, Top: f64, Right: f64, Bottom: f64,
}}
DEFINE_IID!(IID_IThicknessHelper, 2825629259, 7823, 20203, 144, 19, 11, 40, 56, 169, 123, 52);
RT_INTERFACE!{interface IThicknessHelper(IThicknessHelperVtbl): IInspectable(IInspectableVtbl) [IID_IThicknessHelper] {
    
}}
DEFINE_IID!(IID_IThicknessHelperStatics, 3231259260, 1804, 19878, 135, 132, 1, 202, 128, 14, 183, 58);
RT_INTERFACE!{static interface IThicknessHelperStatics(IThicknessHelperStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IThicknessHelperStatics] {
    fn FromLengths(&self, left: f64, top: f64, right: f64, bottom: f64, out: *mut Thickness) -> HRESULT,
    fn FromUniformLength(&self, uniformLength: f64, out: *mut Thickness) -> HRESULT
}}
impl IThicknessHelperStatics {
    #[inline] pub unsafe fn from_lengths(&self, left: f64, top: f64, right: f64, bottom: f64) -> Result<Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).FromLengths)(self as *const _ as *mut _, left, top, right, bottom, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn from_uniform_length(&self, uniformLength: f64) -> Result<Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).FromUniformLength)(self as *const _ as *mut _, uniformLength, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class ThicknessHelper: IThicknessHelper}
impl RtActivatable<IThicknessHelperStatics> for ThicknessHelper {}
impl ThicknessHelper {
    #[inline] pub fn from_lengths(left: f64, top: f64, right: f64, bottom: f64) -> Result<Thickness> { unsafe {
        <Self as RtActivatable<IThicknessHelperStatics>>::get_activation_factory().from_lengths(left, top, right, bottom)
    }}
    #[inline] pub fn from_uniform_length(uniformLength: f64) -> Result<Thickness> { unsafe {
        <Self as RtActivatable<IThicknessHelperStatics>>::get_activation_factory().from_uniform_length(uniformLength)
    }}
}
DEFINE_CLSID!(ThicknessHelper(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,84,104,105,99,107,110,101,115,115,72,101,108,112,101,114,0]) [CLSID_ThicknessHelper]);
DEFINE_IID!(IID_ApplicationInitializationCallback, 3056933973, 49796, 18148, 131, 16, 251, 9, 103, 250, 183, 111);
RT_DELEGATE!{delegate ApplicationInitializationCallback(ApplicationInitializationCallbackVtbl, ApplicationInitializationCallbackImpl) [IID_ApplicationInitializationCallback] {
    fn Invoke(&self, p: *mut ApplicationInitializationCallbackParams) -> HRESULT
}}
impl ApplicationInitializationCallback {
    #[inline] pub unsafe fn invoke(&self, p: &ApplicationInitializationCallbackParams) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, p as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ApplicationInitializationCallbackParams: IApplicationInitializationCallbackParams}
DEFINE_IID!(IID_CreateDefaultValueCallback, 3605836076, 5557, 20168, 185, 92, 205, 210, 8, 240, 129, 83);
RT_DELEGATE!{delegate CreateDefaultValueCallback(CreateDefaultValueCallbackVtbl, CreateDefaultValueCallbackImpl) [IID_CreateDefaultValueCallback] {
    fn Invoke(&self, out: *mut *mut IInspectable) -> HRESULT
}}
impl CreateDefaultValueCallback {
    #[inline] pub unsafe fn invoke(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_DependencyPropertyChangedCallback, 1166556438, 10175, 19393, 172, 38, 148, 193, 96, 31, 58, 73);
RT_DELEGATE!{delegate DependencyPropertyChangedCallback(DependencyPropertyChangedCallbackVtbl, DependencyPropertyChangedCallbackImpl) [IID_DependencyPropertyChangedCallback] {
    fn Invoke(&self, sender: *mut DependencyObject, dp: *mut DependencyProperty) -> HRESULT
}}
impl DependencyPropertyChangedCallback {
    #[inline] pub unsafe fn invoke(&self, sender: &DependencyObject, dp: &DependencyProperty) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, dp as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class DependencyObject: IDependencyObject}
RT_CLASS!{class DependencyProperty: IDependencyProperty}
impl RtActivatable<IDependencyPropertyStatics> for DependencyProperty {}
impl DependencyProperty {
    #[inline] pub fn get_unset_value() -> Result<ComPtr<IInspectable>> { unsafe {
        <Self as RtActivatable<IDependencyPropertyStatics>>::get_activation_factory().get_unset_value()
    }}
    #[inline] pub fn register(name: &HStringArg, propertyType: interop::TypeName, ownerType: interop::TypeName, typeMetadata: &PropertyMetadata) -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDependencyPropertyStatics>>::get_activation_factory().register(name, propertyType, ownerType, typeMetadata)
    }}
    #[inline] pub fn register_attached(name: &HStringArg, propertyType: interop::TypeName, ownerType: interop::TypeName, defaultMetadata: &PropertyMetadata) -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDependencyPropertyStatics>>::get_activation_factory().register_attached(name, propertyType, ownerType, defaultMetadata)
    }}
}
DEFINE_CLSID!(DependencyProperty(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,68,101,112,101,110,100,101,110,99,121,80,114,111,112,101,114,116,121,0]) [CLSID_DependencyProperty]);
DEFINE_IID!(IID_DependencyPropertyChangedEventHandler, 153239130, 30142, 17561, 129, 128, 29, 220, 0, 84, 33, 192);
RT_DELEGATE!{delegate DependencyPropertyChangedEventHandler(DependencyPropertyChangedEventHandlerVtbl, DependencyPropertyChangedEventHandlerImpl) [IID_DependencyPropertyChangedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut DependencyPropertyChangedEventArgs) -> HRESULT
}}
impl DependencyPropertyChangedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &DependencyPropertyChangedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class DependencyPropertyChangedEventArgs: IDependencyPropertyChangedEventArgs}
DEFINE_IID!(IID_DragEventHandler, 716284421, 7795, 19407, 170, 188, 87, 185, 126, 33, 150, 29);
RT_DELEGATE!{delegate DragEventHandler(DragEventHandlerVtbl, DragEventHandlerImpl) [IID_DragEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut DragEventArgs) -> HRESULT
}}
impl DragEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &DragEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_EnteredBackgroundEventHandler, 2477348526, 7551, 17291, 183, 184, 34, 125, 150, 182, 9, 192);
RT_DELEGATE!{delegate EnteredBackgroundEventHandler(EnteredBackgroundEventHandlerVtbl, EnteredBackgroundEventHandlerImpl) [IID_EnteredBackgroundEventHandler] {
    #[cfg(feature="windows-applicationmodel")] fn Invoke(&self, sender: *mut IInspectable, e: *mut super::super::applicationmodel::EnteredBackgroundEventArgs) -> HRESULT
}}
impl EnteredBackgroundEventHandler {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &super::super::applicationmodel::EnteredBackgroundEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ExceptionRoutedEventHandler, 1759569936, 63210, 17084, 133, 91, 93, 155, 103, 230, 162, 98);
RT_DELEGATE!{delegate ExceptionRoutedEventHandler(ExceptionRoutedEventHandlerVtbl, ExceptionRoutedEventHandlerImpl) [IID_ExceptionRoutedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut ExceptionRoutedEventArgs) -> HRESULT
}}
impl ExceptionRoutedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &ExceptionRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_LeavingBackgroundEventHandler, 2863488429, 20422, 19108, 183, 207, 135, 126, 54, 173, 164, 246);
RT_DELEGATE!{delegate LeavingBackgroundEventHandler(LeavingBackgroundEventHandlerVtbl, LeavingBackgroundEventHandlerImpl) [IID_LeavingBackgroundEventHandler] {
    #[cfg(feature="windows-applicationmodel")] fn Invoke(&self, sender: *mut IInspectable, e: *mut super::super::applicationmodel::LeavingBackgroundEventArgs) -> HRESULT
}}
impl LeavingBackgroundEventHandler {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &super::super::applicationmodel::LeavingBackgroundEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_PropertyChangedCallback, 1520405029, 53570, 17572, 130, 49, 253, 103, 103, 36, 242, 155);
RT_DELEGATE!{delegate PropertyChangedCallback(PropertyChangedCallbackVtbl, PropertyChangedCallbackImpl) [IID_PropertyChangedCallback] {
    fn Invoke(&self, d: *mut DependencyObject, e: *mut DependencyPropertyChangedEventArgs) -> HRESULT
}}
impl PropertyChangedCallback {
    #[inline] pub unsafe fn invoke(&self, d: &DependencyObject, e: &DependencyPropertyChangedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, d as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_RoutedEventHandler, 2824267380, 45238, 19395, 187, 168, 27, 160, 110, 64, 212, 181);
RT_DELEGATE!{delegate RoutedEventHandler(RoutedEventHandlerVtbl, RoutedEventHandlerImpl) [IID_RoutedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut RoutedEventArgs) -> HRESULT
}}
impl RoutedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &RoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class RoutedEventArgs: IRoutedEventArgs}
DEFINE_IID!(IID_SizeChangedEventHandler, 286634300, 9682, 18443, 137, 220, 235, 61, 203, 214, 183, 250);
RT_DELEGATE!{delegate SizeChangedEventHandler(SizeChangedEventHandlerVtbl, SizeChangedEventHandlerImpl) [IID_SizeChangedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut SizeChangedEventArgs) -> HRESULT
}}
impl SizeChangedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &SizeChangedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_SuspendingEventHandler, 591565925, 58218, 16610, 177, 57, 164, 112, 70, 2, 166, 225);
RT_DELEGATE!{delegate SuspendingEventHandler(SuspendingEventHandlerVtbl, SuspendingEventHandlerImpl) [IID_SuspendingEventHandler] {
    #[cfg(feature="windows-applicationmodel")] fn Invoke(&self, sender: *mut IInspectable, e: *mut super::super::applicationmodel::SuspendingEventArgs) -> HRESULT
}}
impl SuspendingEventHandler {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &super::super::applicationmodel::SuspendingEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_UnhandledExceptionEventHandler, 2457134781, 18849, 18776, 190, 238, 208, 225, 149, 135, 182, 227);
RT_DELEGATE!{delegate UnhandledExceptionEventHandler(UnhandledExceptionEventHandlerVtbl, UnhandledExceptionEventHandlerImpl) [IID_UnhandledExceptionEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut UnhandledExceptionEventArgs) -> HRESULT
}}
impl UnhandledExceptionEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &UnhandledExceptionEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class UnhandledExceptionEventArgs: IUnhandledExceptionEventArgs}
DEFINE_IID!(IID_VisualStateChangedEventHandler, 3872766933, 57385, 17318, 179, 109, 132, 168, 16, 66, 215, 116);
RT_DELEGATE!{delegate VisualStateChangedEventHandler(VisualStateChangedEventHandlerVtbl, VisualStateChangedEventHandlerImpl) [IID_VisualStateChangedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut VisualStateChangedEventArgs) -> HRESULT
}}
impl VisualStateChangedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &VisualStateChangedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class VisualStateChangedEventArgs: IVisualStateChangedEventArgs}
impl RtActivatable<IActivationFactory> for VisualStateChangedEventArgs {}
DEFINE_CLSID!(VisualStateChangedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,86,105,115,117,97,108,83,116,97,116,101,67,104,97,110,103,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_VisualStateChangedEventArgs]);
DEFINE_IID!(IID_WindowActivatedEventHandler, 402809672, 34329, 19579, 181, 52, 206, 212, 93, 157, 226, 25);
RT_DELEGATE!{delegate WindowActivatedEventHandler(WindowActivatedEventHandlerVtbl, WindowActivatedEventHandlerImpl) [IID_WindowActivatedEventHandler] {
    #[cfg(feature="windows-ui")] fn Invoke(&self, sender: *mut IInspectable, e: *mut super::core::WindowActivatedEventArgs) -> HRESULT
}}
impl WindowActivatedEventHandler {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &super::core::WindowActivatedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_WindowClosedEventHandler, 230199649, 8407, 17887, 145, 34, 186, 137, 87, 103, 3, 186);
RT_DELEGATE!{delegate WindowClosedEventHandler(WindowClosedEventHandlerVtbl, WindowClosedEventHandlerImpl) [IID_WindowClosedEventHandler] {
    #[cfg(feature="windows-ui")] fn Invoke(&self, sender: *mut IInspectable, e: *mut super::core::CoreWindowEventArgs) -> HRESULT
}}
impl WindowClosedEventHandler {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &super::core::CoreWindowEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_WindowSizeChangedEventHandler, 1545717570, 11501, 20441, 186, 56, 113, 24, 212, 14, 150, 107);
RT_DELEGATE!{delegate WindowSizeChangedEventHandler(WindowSizeChangedEventHandlerVtbl, WindowSizeChangedEventHandlerImpl) [IID_WindowSizeChangedEventHandler] {
    #[cfg(feature="windows-ui")] fn Invoke(&self, sender: *mut IInspectable, e: *mut super::core::WindowSizeChangedEventArgs) -> HRESULT
}}
impl WindowSizeChangedEventHandler {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &super::core::WindowSizeChangedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_WindowVisibilityChangedEventHandler, 272657110, 45200, 19018, 178, 173, 214, 130, 223, 39, 19, 15);
RT_DELEGATE!{delegate WindowVisibilityChangedEventHandler(WindowVisibilityChangedEventHandlerVtbl, WindowVisibilityChangedEventHandlerImpl) [IID_WindowVisibilityChangedEventHandler] {
    #[cfg(feature="windows-ui")] fn Invoke(&self, sender: *mut IInspectable, e: *mut super::core::VisibilityChangedEventArgs) -> HRESULT
}}
impl WindowVisibilityChangedEventHandler {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &super::core::VisibilityChangedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IApplicationInitializationCallbackParams, 1964734766, 22386, 17544, 139, 135, 245, 71, 250, 166, 68, 116);
RT_INTERFACE!{interface IApplicationInitializationCallbackParams(IApplicationInitializationCallbackParamsVtbl): IInspectable(IInspectableVtbl) [IID_IApplicationInitializationCallbackParams] {
    
}}
DEFINE_IID!(IID_IBringIntoViewOptions, 431870389, 51147, 18137, 164, 221, 161, 187, 232, 62, 242, 251);
RT_INTERFACE!{interface IBringIntoViewOptions(IBringIntoViewOptionsVtbl): IInspectable(IInspectableVtbl) [IID_IBringIntoViewOptions] {
    fn get_AnimationDesired(&self, out: *mut bool) -> HRESULT,
    fn put_AnimationDesired(&self, value: bool) -> HRESULT,
    fn get_TargetRect(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::Rect>) -> HRESULT,
    fn put_TargetRect(&self, value: *mut super::super::foundation::IReference<super::super::foundation::Rect>) -> HRESULT
}}
impl IBringIntoViewOptions {
    #[inline] pub unsafe fn get_animation_desired(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AnimationDesired)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_animation_desired(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AnimationDesired)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_target_rect(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::Rect>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetRect)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_rect(&self, value: &super::super::foundation::IReference<super::super::foundation::Rect>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetRect)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class BringIntoViewOptions: IBringIntoViewOptions}
impl RtActivatable<IActivationFactory> for BringIntoViewOptions {}
DEFINE_CLSID!(BringIntoViewOptions(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,66,114,105,110,103,73,110,116,111,86,105,101,119,79,112,116,105,111,110,115,0]) [CLSID_BringIntoViewOptions]);
DEFINE_IID!(IID_IDataContextChangedEventArgs, 2108067361, 2959, 20383, 161, 67, 248, 231, 120, 1, 54, 162);
RT_INTERFACE!{interface IDataContextChangedEventArgs(IDataContextChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDataContextChangedEventArgs] {
    fn get_NewValue(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT
}}
impl IDataContextChangedEventArgs {
    #[inline] pub unsafe fn get_new_value(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NewValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class DataContextChangedEventArgs: IDataContextChangedEventArgs}
DEFINE_IID!(IID_IDataTemplateKey, 2268818472, 52459, 19297, 134, 250, 178, 206, 195, 156, 194, 250);
RT_INTERFACE!{interface IDataTemplateKey(IDataTemplateKeyVtbl): IInspectable(IInspectableVtbl) [IID_IDataTemplateKey] {
    fn get_DataType(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_DataType(&self, value: *mut IInspectable) -> HRESULT
}}
impl IDataTemplateKey {
    #[inline] pub unsafe fn get_data_type(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DataType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_data_type(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DataType)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDataTemplateKeyFactory, 3916114265, 55682, 16722, 145, 203, 222, 14, 77, 253, 118, 147);
RT_INTERFACE!{interface IDataTemplateKeyFactory(IDataTemplateKeyFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IDataTemplateKeyFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut DataTemplateKey) -> HRESULT,
    fn CreateInstanceWithType(&self, dataType: *mut IInspectable, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut DataTemplateKey) -> HRESULT
}}
impl IDataTemplateKeyFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<DataTemplateKey>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_instance_with_type(&self, dataType: &IInspectable, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<DataTemplateKey>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithType)(self as *const _ as *mut _, dataType as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class DataTemplateKey: IDataTemplateKey}
DEFINE_IID!(IID_IDependencyObject, 1548904037, 62990, 18706, 175, 89, 95, 224, 104, 15, 8, 157);
RT_INTERFACE!{interface IDependencyObject(IDependencyObjectVtbl): IInspectable(IInspectableVtbl) [IID_IDependencyObject] {
    fn GetValue(&self, dp: *mut DependencyProperty, out: *mut *mut IInspectable) -> HRESULT,
    fn SetValue(&self, dp: *mut DependencyProperty, value: *mut IInspectable) -> HRESULT,
    fn ClearValue(&self, dp: *mut DependencyProperty) -> HRESULT,
    fn ReadLocalValue(&self, dp: *mut DependencyProperty, out: *mut *mut IInspectable) -> HRESULT,
    fn GetAnimationBaseValue(&self, dp: *mut DependencyProperty, out: *mut *mut IInspectable) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_Dispatcher(&self, out: *mut *mut super::core::CoreDispatcher) -> HRESULT
}}
impl IDependencyObject {
    #[inline] pub unsafe fn get_value(&self, dp: &DependencyProperty) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetValue)(self as *const _ as *mut _, dp as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_value(&self, dp: &DependencyProperty, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).SetValue)(self as *const _ as *mut _, dp as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn clear_value(&self, dp: &DependencyProperty) -> Result<()> {
        let hr = ((*self.lpVtbl).ClearValue)(self as *const _ as *mut _, dp as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn read_local_value(&self, dp: &DependencyProperty) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReadLocalValue)(self as *const _ as *mut _, dp as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_animation_base_value(&self, dp: &DependencyProperty) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAnimationBaseValue)(self as *const _ as *mut _, dp as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_dispatcher(&self) -> Result<ComPtr<super::core::CoreDispatcher>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Dispatcher)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDependencyObjectFactory, 2583932818, 32138, 18743, 136, 79, 236, 243, 79, 224, 42, 203);
RT_INTERFACE!{interface IDependencyObjectFactory(IDependencyObjectFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IDependencyObjectFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut DependencyObject) -> HRESULT
}}
impl IDependencyObjectFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<DependencyObject>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDependencyObject2, 704567389, 15650, 17313, 173, 208, 23, 2, 124, 8, 178, 18);
RT_INTERFACE!{interface IDependencyObject2(IDependencyObject2Vtbl): IInspectable(IInspectableVtbl) [IID_IDependencyObject2] {
    fn RegisterPropertyChangedCallback(&self, dp: *mut DependencyProperty, callback: *mut DependencyPropertyChangedCallback, out: *mut i64) -> HRESULT,
    fn UnregisterPropertyChangedCallback(&self, dp: *mut DependencyProperty, token: i64) -> HRESULT
}}
impl IDependencyObject2 {
    #[inline] pub unsafe fn register_property_changed_callback(&self, dp: &DependencyProperty, callback: &DependencyPropertyChangedCallback) -> Result<i64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).RegisterPropertyChangedCallback)(self as *const _ as *mut _, dp as *const _ as *mut _, callback as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn unregister_property_changed_callback(&self, dp: &DependencyProperty, token: i64) -> Result<()> {
        let hr = ((*self.lpVtbl).UnregisterPropertyChangedCallback)(self as *const _ as *mut _, dp as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDependencyProperty, 2242984304, 39876, 20118, 172, 241, 48, 200, 253, 61, 85, 200);
RT_INTERFACE!{interface IDependencyProperty(IDependencyPropertyVtbl): IInspectable(IInspectableVtbl) [IID_IDependencyProperty] {
    fn GetMetadata(&self, forType: interop::TypeName, out: *mut *mut PropertyMetadata) -> HRESULT
}}
impl IDependencyProperty {
    #[inline] pub unsafe fn get_metadata(&self, forType: interop::TypeName) -> Result<ComPtr<PropertyMetadata>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMetadata)(self as *const _ as *mut _, forType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PropertyMetadata: IPropertyMetadata}
impl RtActivatable<IPropertyMetadataStatics> for PropertyMetadata {}
impl PropertyMetadata {
    #[inline] pub fn create_with_default_value(defaultValue: &IInspectable) -> Result<ComPtr<PropertyMetadata>> { unsafe {
        <Self as RtActivatable<IPropertyMetadataStatics>>::get_activation_factory().create_with_default_value(defaultValue)
    }}
    #[inline] pub fn create_with_default_value_and_callback(defaultValue: &IInspectable, propertyChangedCallback: &PropertyChangedCallback) -> Result<ComPtr<PropertyMetadata>> { unsafe {
        <Self as RtActivatable<IPropertyMetadataStatics>>::get_activation_factory().create_with_default_value_and_callback(defaultValue, propertyChangedCallback)
    }}
    #[inline] pub fn create_with_factory(createDefaultValueCallback: &CreateDefaultValueCallback) -> Result<ComPtr<PropertyMetadata>> { unsafe {
        <Self as RtActivatable<IPropertyMetadataStatics>>::get_activation_factory().create_with_factory(createDefaultValueCallback)
    }}
    #[inline] pub fn create_with_factory_and_callback(createDefaultValueCallback: &CreateDefaultValueCallback, propertyChangedCallback: &PropertyChangedCallback) -> Result<ComPtr<PropertyMetadata>> { unsafe {
        <Self as RtActivatable<IPropertyMetadataStatics>>::get_activation_factory().create_with_factory_and_callback(createDefaultValueCallback, propertyChangedCallback)
    }}
}
DEFINE_CLSID!(PropertyMetadata(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,80,114,111,112,101,114,116,121,77,101,116,97,100,97,116,97,0]) [CLSID_PropertyMetadata]);
DEFINE_IID!(IID_IDependencyPropertyStatics, 1239806607, 33369, 19804, 170, 224, 131, 213, 109, 187, 104, 217);
RT_INTERFACE!{static interface IDependencyPropertyStatics(IDependencyPropertyStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDependencyPropertyStatics] {
    fn get_UnsetValue(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn Register(&self, name: HSTRING, propertyType: interop::TypeName, ownerType: interop::TypeName, typeMetadata: *mut PropertyMetadata, out: *mut *mut DependencyProperty) -> HRESULT,
    fn RegisterAttached(&self, name: HSTRING, propertyType: interop::TypeName, ownerType: interop::TypeName, defaultMetadata: *mut PropertyMetadata, out: *mut *mut DependencyProperty) -> HRESULT
}}
impl IDependencyPropertyStatics {
    #[inline] pub unsafe fn get_unset_value(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UnsetValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn register(&self, name: &HStringArg, propertyType: interop::TypeName, ownerType: interop::TypeName, typeMetadata: &PropertyMetadata) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Register)(self as *const _ as *mut _, name.get(), propertyType, ownerType, typeMetadata as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn register_attached(&self, name: &HStringArg, propertyType: interop::TypeName, ownerType: interop::TypeName, defaultMetadata: &PropertyMetadata) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RegisterAttached)(self as *const _ as *mut _, name.get(), propertyType, ownerType, defaultMetadata as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDependencyPropertyChangedEventArgs, 2166434859, 9424, 18775, 171, 195, 34, 68, 112, 169, 58, 78);
RT_INTERFACE!{interface IDependencyPropertyChangedEventArgs(IDependencyPropertyChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDependencyPropertyChangedEventArgs] {
    fn get_Property(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_OldValue(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn get_NewValue(&self, out: *mut *mut IInspectable) -> HRESULT
}}
impl IDependencyPropertyChangedEventArgs {
    #[inline] pub unsafe fn get_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_old_value(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OldValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_new_value(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NewValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDragOperationDeferral, 3128159418, 7027, 16518, 179, 211, 194, 35, 190, 234, 22, 51);
RT_INTERFACE!{interface IDragOperationDeferral(IDragOperationDeferralVtbl): IInspectable(IInspectableVtbl) [IID_IDragOperationDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IDragOperationDeferral {
    #[inline] pub unsafe fn complete(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class DragOperationDeferral: IDragOperationDeferral}
DEFINE_IID!(IID_IDragUI, 765188152, 31840, 18498, 145, 112, 52, 111, 225, 10, 34, 106);
RT_INTERFACE!{interface IDragUI(IDragUIVtbl): IInspectable(IInspectableVtbl) [IID_IDragUI] {
    fn SetContentFromBitmapImage(&self, bitmapImage: *mut media::imaging::BitmapImage) -> HRESULT,
    fn SetContentFromBitmapImageWithAnchorPoint(&self, bitmapImage: *mut media::imaging::BitmapImage, anchorPoint: super::super::foundation::Point) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-graphics")] fn SetContentFromSoftwareBitmap(&self, softwareBitmap: *mut super::super::graphics::imaging::SoftwareBitmap) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-graphics")] fn SetContentFromSoftwareBitmapWithAnchorPoint(&self, softwareBitmap: *mut super::super::graphics::imaging::SoftwareBitmap, anchorPoint: super::super::foundation::Point) -> HRESULT,
    fn SetContentFromDataPackage(&self) -> HRESULT
}}
impl IDragUI {
    #[inline] pub unsafe fn set_content_from_bitmap_image(&self, bitmapImage: &media::imaging::BitmapImage) -> Result<()> {
        let hr = ((*self.lpVtbl).SetContentFromBitmapImage)(self as *const _ as *mut _, bitmapImage as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_from_bitmap_image_with_anchor_point(&self, bitmapImage: &media::imaging::BitmapImage, anchorPoint: super::super::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).SetContentFromBitmapImageWithAnchorPoint)(self as *const _ as *mut _, bitmapImage as *const _ as *mut _, anchorPoint);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-graphics")] #[inline] pub unsafe fn set_content_from_software_bitmap(&self, softwareBitmap: &super::super::graphics::imaging::SoftwareBitmap) -> Result<()> {
        let hr = ((*self.lpVtbl).SetContentFromSoftwareBitmap)(self as *const _ as *mut _, softwareBitmap as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-graphics")] #[inline] pub unsafe fn set_content_from_software_bitmap_with_anchor_point(&self, softwareBitmap: &super::super::graphics::imaging::SoftwareBitmap, anchorPoint: super::super::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).SetContentFromSoftwareBitmapWithAnchorPoint)(self as *const _ as *mut _, softwareBitmap as *const _ as *mut _, anchorPoint);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_from_data_package(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).SetContentFromDataPackage)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class DragUI: IDragUI}
DEFINE_IID!(IID_IDragUIOverride, 3178012154, 51553, 18529, 183, 165, 191, 79, 228, 168, 166, 239);
RT_INTERFACE!{interface IDragUIOverride(IDragUIOverrideVtbl): IInspectable(IInspectableVtbl) [IID_IDragUIOverride] {
    fn get_Caption(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Caption(&self, value: HSTRING) -> HRESULT,
    fn get_IsContentVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsContentVisible(&self, value: bool) -> HRESULT,
    fn get_IsCaptionVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsCaptionVisible(&self, value: bool) -> HRESULT,
    fn get_IsGlyphVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsGlyphVisible(&self, value: bool) -> HRESULT,
    fn Clear(&self) -> HRESULT,
    fn SetContentFromBitmapImage(&self, bitmapImage: *mut media::imaging::BitmapImage) -> HRESULT,
    fn SetContentFromBitmapImageWithAnchorPoint(&self, bitmapImage: *mut media::imaging::BitmapImage, anchorPoint: super::super::foundation::Point) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn SetContentFromSoftwareBitmap(&self, softwareBitmap: *mut super::super::graphics::imaging::SoftwareBitmap) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn SetContentFromSoftwareBitmapWithAnchorPoint(&self, softwareBitmap: *mut super::super::graphics::imaging::SoftwareBitmap, anchorPoint: super::super::foundation::Point) -> HRESULT
}}
impl IDragUIOverride {
    #[inline] pub unsafe fn get_caption(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Caption)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_caption(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Caption)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_content_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsContentVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_content_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsContentVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_caption_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCaptionVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_caption_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsCaptionVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_glyph_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsGlyphVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_glyph_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsGlyphVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn clear(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Clear)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_from_bitmap_image(&self, bitmapImage: &media::imaging::BitmapImage) -> Result<()> {
        let hr = ((*self.lpVtbl).SetContentFromBitmapImage)(self as *const _ as *mut _, bitmapImage as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_from_bitmap_image_with_anchor_point(&self, bitmapImage: &media::imaging::BitmapImage, anchorPoint: super::super::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).SetContentFromBitmapImageWithAnchorPoint)(self as *const _ as *mut _, bitmapImage as *const _ as *mut _, anchorPoint);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-graphics")] #[inline] pub unsafe fn set_content_from_software_bitmap(&self, softwareBitmap: &super::super::graphics::imaging::SoftwareBitmap) -> Result<()> {
        let hr = ((*self.lpVtbl).SetContentFromSoftwareBitmap)(self as *const _ as *mut _, softwareBitmap as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-graphics")] #[inline] pub unsafe fn set_content_from_software_bitmap_with_anchor_point(&self, softwareBitmap: &super::super::graphics::imaging::SoftwareBitmap, anchorPoint: super::super::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).SetContentFromSoftwareBitmapWithAnchorPoint)(self as *const _ as *mut _, softwareBitmap as *const _ as *mut _, anchorPoint);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class DragUIOverride: IDragUIOverride}
DEFINE_IID!(IID_IFrameworkView, 3719980619, 46595, 18346, 148, 45, 56, 51, 23, 79, 13, 128);
RT_INTERFACE!{interface IFrameworkView(IFrameworkViewVtbl): IInspectable(IInspectableVtbl) [IID_IFrameworkView] {
    
}}
RT_CLASS!{class FrameworkView: IFrameworkView}
impl RtActivatable<IActivationFactory> for FrameworkView {}
DEFINE_CLSID!(FrameworkView(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,70,114,97,109,101,119,111,114,107,86,105,101,119,0]) [CLSID_FrameworkView]);
DEFINE_IID!(IID_IPropertyMetadata, 2169434893, 36120, 17546, 134, 68, 242, 203, 81, 231, 3, 128);
RT_INTERFACE!{interface IPropertyMetadata(IPropertyMetadataVtbl): IInspectable(IInspectableVtbl) [IID_IPropertyMetadata] {
    fn get_DefaultValue(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn get_CreateDefaultValueCallback(&self, out: *mut *mut CreateDefaultValueCallback) -> HRESULT
}}
impl IPropertyMetadata {
    #[inline] pub unsafe fn get_default_value(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DefaultValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_create_default_value_callback(&self) -> Result<ComPtr<CreateDefaultValueCallback>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CreateDefaultValueCallback)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPropertyMetadataStatics, 989923194, 28166, 17897, 139, 92, 175, 36, 52, 88, 192, 98);
RT_INTERFACE!{static interface IPropertyMetadataStatics(IPropertyMetadataStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPropertyMetadataStatics] {
    fn CreateWithDefaultValue(&self, defaultValue: *mut IInspectable, out: *mut *mut PropertyMetadata) -> HRESULT,
    fn CreateWithDefaultValueAndCallback(&self, defaultValue: *mut IInspectable, propertyChangedCallback: *mut PropertyChangedCallback, out: *mut *mut PropertyMetadata) -> HRESULT,
    fn CreateWithFactory(&self, createDefaultValueCallback: *mut CreateDefaultValueCallback, out: *mut *mut PropertyMetadata) -> HRESULT,
    fn CreateWithFactoryAndCallback(&self, createDefaultValueCallback: *mut CreateDefaultValueCallback, propertyChangedCallback: *mut PropertyChangedCallback, out: *mut *mut PropertyMetadata) -> HRESULT
}}
impl IPropertyMetadataStatics {
    #[inline] pub unsafe fn create_with_default_value(&self, defaultValue: &IInspectable) -> Result<ComPtr<PropertyMetadata>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithDefaultValue)(self as *const _ as *mut _, defaultValue as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_with_default_value_and_callback(&self, defaultValue: &IInspectable, propertyChangedCallback: &PropertyChangedCallback) -> Result<ComPtr<PropertyMetadata>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithDefaultValueAndCallback)(self as *const _ as *mut _, defaultValue as *const _ as *mut _, propertyChangedCallback as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_with_factory(&self, createDefaultValueCallback: &CreateDefaultValueCallback) -> Result<ComPtr<PropertyMetadata>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithFactory)(self as *const _ as *mut _, createDefaultValueCallback as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_with_factory_and_callback(&self, createDefaultValueCallback: &CreateDefaultValueCallback, propertyChangedCallback: &PropertyChangedCallback) -> Result<ComPtr<PropertyMetadata>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithFactoryAndCallback)(self as *const _ as *mut _, createDefaultValueCallback as *const _ as *mut _, propertyChangedCallback as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPropertyMetadataFactory, 3250068672, 22477, 20271, 176, 169, 225, 128, 27, 40, 247, 107);
RT_INTERFACE!{interface IPropertyMetadataFactory(IPropertyMetadataFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPropertyMetadataFactory] {
    fn CreateInstanceWithDefaultValue(&self, defaultValue: *mut IInspectable, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut PropertyMetadata) -> HRESULT,
    fn CreateInstanceWithDefaultValueAndCallback(&self, defaultValue: *mut IInspectable, propertyChangedCallback: *mut PropertyChangedCallback, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut PropertyMetadata) -> HRESULT
}}
impl IPropertyMetadataFactory {
    #[inline] pub unsafe fn create_instance_with_default_value(&self, defaultValue: &IInspectable, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<PropertyMetadata>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithDefaultValue)(self as *const _ as *mut _, defaultValue as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_instance_with_default_value_and_callback(&self, defaultValue: &IInspectable, propertyChangedCallback: &PropertyChangedCallback, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<PropertyMetadata>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithDefaultValueAndCallback)(self as *const _ as *mut _, defaultValue as *const _ as *mut _, propertyChangedCallback as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRoutedEvent, 2796705816, 17345, 19568, 134, 92, 123, 221, 90, 50, 227, 39);
RT_INTERFACE!{interface IRoutedEvent(IRoutedEventVtbl): IInspectable(IInspectableVtbl) [IID_IRoutedEvent] {
    
}}
RT_CLASS!{class RoutedEvent: IRoutedEvent}
DEFINE_IID!(IID_IRoutedEventArgs, 1553488582, 55298, 19256, 162, 35, 191, 7, 12, 67, 254, 223);
RT_INTERFACE!{interface IRoutedEventArgs(IRoutedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IRoutedEventArgs] {
    fn get_OriginalSource(&self, out: *mut *mut IInspectable) -> HRESULT
}}
impl IRoutedEventArgs {
    #[inline] pub unsafe fn get_original_source(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OriginalSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRoutedEventArgsFactory, 3055308167, 28901, 16686, 181, 32, 26, 65, 238, 118, 187, 244);
RT_INTERFACE!{interface IRoutedEventArgsFactory(IRoutedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IRoutedEventArgsFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut RoutedEventArgs) -> HRESULT
}}
impl IRoutedEventArgsFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<RoutedEventArgs>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISetterBaseCollection, 63179944, 37022, 16663, 129, 28, 164, 82, 148, 150, 189, 241);
RT_INTERFACE!{interface ISetterBaseCollection(ISetterBaseCollectionVtbl): IInspectable(IInspectableVtbl) [IID_ISetterBaseCollection] {
    fn get_IsSealed(&self, out: *mut bool) -> HRESULT
}}
impl ISetterBaseCollection {
    #[inline] pub unsafe fn get_is_sealed(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSealed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class SetterBaseCollection: ISetterBaseCollection}
impl RtActivatable<IActivationFactory> for SetterBaseCollection {}
DEFINE_CLSID!(SetterBaseCollection(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,83,101,116,116,101,114,66,97,115,101,67,111,108,108,101,99,116,105,111,110,0]) [CLSID_SetterBaseCollection]);
DEFINE_IID!(IID_ITargetPropertyPath, 1081347982, 2143, 19693, 190, 112, 111, 71, 172, 241, 90, 208);
RT_INTERFACE!{interface ITargetPropertyPath(ITargetPropertyPathVtbl): IInspectable(IInspectableVtbl) [IID_ITargetPropertyPath] {
    fn get_Path(&self, out: *mut *mut PropertyPath) -> HRESULT,
    fn put_Path(&self, value: *mut PropertyPath) -> HRESULT,
    fn get_Target(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Target(&self, value: *mut IInspectable) -> HRESULT
}}
impl ITargetPropertyPath {
    #[inline] pub unsafe fn get_path(&self) -> Result<ComPtr<PropertyPath>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Path)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_path(&self, value: &PropertyPath) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Path)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_target(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Target)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Target)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITargetPropertyPathFactory, 2297351368, 39394, 19012, 153, 7, 180, 75, 200, 110, 43, 190);
RT_INTERFACE!{static interface ITargetPropertyPathFactory(ITargetPropertyPathFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ITargetPropertyPathFactory] {
    fn CreateInstance(&self, targetProperty: *mut DependencyProperty, out: *mut *mut TargetPropertyPath) -> HRESULT
}}
impl ITargetPropertyPathFactory {
    #[inline] pub unsafe fn create_instance(&self, targetProperty: &DependencyProperty) -> Result<ComPtr<TargetPropertyPath>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, targetProperty as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class TargetPropertyPath: ITargetPropertyPath}
impl RtActivatable<ITargetPropertyPathFactory> for TargetPropertyPath {}
impl RtActivatable<IActivationFactory> for TargetPropertyPath {}
impl TargetPropertyPath {
    #[inline] pub fn create_instance(targetProperty: &DependencyProperty) -> Result<ComPtr<TargetPropertyPath>> { unsafe {
        <Self as RtActivatable<ITargetPropertyPathFactory>>::get_activation_factory().create_instance(targetProperty)
    }}
}
DEFINE_CLSID!(TargetPropertyPath(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,84,97,114,103,101,116,80,114,111,112,101,114,116,121,80,97,116,104,0]) [CLSID_TargetPropertyPath]);
RT_CLASS!{class TriggerActionCollection: super::super::foundation::collections::IVector<TriggerAction>}
impl RtActivatable<IActivationFactory> for TriggerActionCollection {}
DEFINE_CLSID!(TriggerActionCollection(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,84,114,105,103,103,101,114,65,99,116,105,111,110,67,111,108,108,101,99,116,105,111,110,0]) [CLSID_TriggerActionCollection]);
RT_CLASS!{class TriggerCollection: super::super::foundation::collections::IVector<TriggerBase>}
DEFINE_IID!(IID_IUnhandledExceptionEventArgs, 1915758236, 1358, 19699, 134, 197, 190, 144, 235, 104, 99, 213);
RT_INTERFACE!{interface IUnhandledExceptionEventArgs(IUnhandledExceptionEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IUnhandledExceptionEventArgs] {
    fn get_Exception(&self, out: *mut super::super::foundation::HResult) -> HRESULT,
    fn get_Message(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT
}}
impl IUnhandledExceptionEventArgs {
    #[inline] pub unsafe fn get_exception(&self) -> Result<super::super::foundation::HResult> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Exception)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Message)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVisualStateChangedEventArgs, 4263602865, 62239, 18321, 137, 137, 199, 14, 29, 155, 89, 255);
RT_INTERFACE!{interface IVisualStateChangedEventArgs(IVisualStateChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IVisualStateChangedEventArgs] {
    fn get_OldState(&self, out: *mut *mut VisualState) -> HRESULT,
    fn put_OldState(&self, value: *mut VisualState) -> HRESULT,
    fn get_NewState(&self, out: *mut *mut VisualState) -> HRESULT,
    fn put_NewState(&self, value: *mut VisualState) -> HRESULT,
    fn get_Control(&self, out: *mut *mut controls::Control) -> HRESULT,
    fn put_Control(&self, value: *mut controls::Control) -> HRESULT
}}
impl IVisualStateChangedEventArgs {
    #[inline] pub unsafe fn get_old_state(&self) -> Result<ComPtr<VisualState>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OldState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_old_state(&self, value: &VisualState) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OldState)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_new_state(&self) -> Result<ComPtr<VisualState>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NewState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_new_state(&self, value: &VisualState) -> Result<()> {
        let hr = ((*self.lpVtbl).put_NewState)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_control(&self) -> Result<ComPtr<controls::Control>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Control)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_control(&self, value: &controls::Control) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Control)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDependencyObjectCollectionFactory, 85883391, 45992, 18926, 181, 175, 172, 143, 104, 182, 73, 228);
RT_INTERFACE!{interface IDependencyObjectCollectionFactory(IDependencyObjectCollectionFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IDependencyObjectCollectionFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut DependencyObjectCollection) -> HRESULT
}}
impl IDependencyObjectCollectionFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<DependencyObjectCollection>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class DependencyObjectCollection: super::super::foundation::collections::IObservableVector<DependencyObject>}
DEFINE_IID!(IID_IDragEventArgs, 3024144323, 692, 18816, 147, 66, 37, 218, 225, 192, 241, 136);
RT_INTERFACE!{interface IDragEventArgs(IDragEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDragEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    #[cfg(not(feature="windows-applicationmodel"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-applicationmodel")] fn get_Data(&self, out: *mut *mut super::super::applicationmodel::datatransfer::DataPackage) -> HRESULT,
    #[cfg(not(feature="windows-applicationmodel"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-applicationmodel")] fn put_Data(&self, value: *mut super::super::applicationmodel::datatransfer::DataPackage) -> HRESULT,
    fn GetPosition(&self, relativeTo: *mut UIElement, out: *mut super::super::foundation::Point) -> HRESULT
}}
impl IDragEventArgs {
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn get_data(&self) -> Result<ComPtr<super::super::applicationmodel::datatransfer::DataPackage>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Data)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn set_data(&self, value: &super::super::applicationmodel::datatransfer::DataPackage) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Data)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_position(&self, relativeTo: &UIElement) -> Result<super::super::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetPosition)(self as *const _ as *mut _, relativeTo as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDragEventArgs2, 640902744, 10519, 16669, 191, 195, 47, 34, 71, 28, 187, 231);
RT_INTERFACE!{interface IDragEventArgs2(IDragEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IDragEventArgs2] {
    #[cfg(not(feature="windows-applicationmodel"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-applicationmodel")] fn get_DataView(&self, out: *mut *mut super::super::applicationmodel::datatransfer::DataPackageView) -> HRESULT,
    fn get_DragUIOverride(&self, out: *mut *mut DragUIOverride) -> HRESULT,
    #[cfg(not(feature="windows-applicationmodel"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-applicationmodel")] fn get_Modifiers(&self, out: *mut super::super::applicationmodel::datatransfer::dragdrop::DragDropModifiers) -> HRESULT,
    #[cfg(not(feature="windows-applicationmodel"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-applicationmodel")] fn get_AcceptedOperation(&self, out: *mut super::super::applicationmodel::datatransfer::DataPackageOperation) -> HRESULT,
    #[cfg(not(feature="windows-applicationmodel"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-applicationmodel")] fn put_AcceptedOperation(&self, value: super::super::applicationmodel::datatransfer::DataPackageOperation) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut DragOperationDeferral) -> HRESULT
}}
impl IDragEventArgs2 {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn get_data_view(&self) -> Result<ComPtr<super::super::applicationmodel::datatransfer::DataPackageView>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DataView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drag_uioverride(&self) -> Result<ComPtr<DragUIOverride>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DragUIOverride)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn get_modifiers(&self) -> Result<super::super::applicationmodel::datatransfer::dragdrop::DragDropModifiers> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Modifiers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn get_accepted_operation(&self) -> Result<super::super::applicationmodel::datatransfer::DataPackageOperation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AcceptedOperation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn set_accepted_operation(&self, value: super::super::applicationmodel::datatransfer::DataPackageOperation) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AcceptedOperation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<DragOperationDeferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDragEventArgs3, 3494888390, 33049, 17018, 129, 82, 95, 149, 80, 204, 4, 22);
RT_INTERFACE!{interface IDragEventArgs3(IDragEventArgs3Vtbl): IInspectable(IInspectableVtbl) [IID_IDragEventArgs3] {
    #[cfg(feature="windows-applicationmodel")] fn get_AllowedOperations(&self, out: *mut super::super::applicationmodel::datatransfer::DataPackageOperation) -> HRESULT
}}
impl IDragEventArgs3 {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn get_allowed_operations(&self) -> Result<super::super::applicationmodel::datatransfer::DataPackageOperation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AllowedOperations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class DragEventArgs: IDragEventArgs}
DEFINE_IID!(IID_IDragStartingEventArgs, 1744884730, 37048, 18169, 142, 48, 90, 194, 95, 115, 240, 249);
RT_INTERFACE!{interface IDragStartingEventArgs(IDragStartingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDragStartingEventArgs] {
    fn get_Cancel(&self, out: *mut bool) -> HRESULT,
    fn put_Cancel(&self, value: bool) -> HRESULT,
    #[cfg(not(feature="windows-applicationmodel"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-applicationmodel")] fn get_Data(&self, out: *mut *mut super::super::applicationmodel::datatransfer::DataPackage) -> HRESULT,
    fn get_DragUI(&self, out: *mut *mut DragUI) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut DragOperationDeferral) -> HRESULT,
    fn GetPosition(&self, relativeTo: *mut UIElement, out: *mut super::super::foundation::Point) -> HRESULT
}}
impl IDragStartingEventArgs {
    #[inline] pub unsafe fn get_cancel(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cancel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_cancel(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Cancel)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn get_data(&self) -> Result<ComPtr<super::super::applicationmodel::datatransfer::DataPackage>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Data)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drag_ui(&self) -> Result<ComPtr<DragUI>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DragUI)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<DragOperationDeferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_position(&self, relativeTo: &UIElement) -> Result<super::super::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetPosition)(self as *const _ as *mut _, relativeTo as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDragStartingEventArgs2, 3629506702, 17590, 16913, 189, 11, 127, 221, 187, 110, 130, 49);
RT_INTERFACE!{interface IDragStartingEventArgs2(IDragStartingEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IDragStartingEventArgs2] {
    #[cfg(feature="windows-applicationmodel")] fn get_AllowedOperations(&self, out: *mut super::super::applicationmodel::datatransfer::DataPackageOperation) -> HRESULT,
    #[cfg(feature="windows-applicationmodel")] fn put_AllowedOperations(&self, value: super::super::applicationmodel::datatransfer::DataPackageOperation) -> HRESULT
}}
impl IDragStartingEventArgs2 {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn get_allowed_operations(&self) -> Result<super::super::applicationmodel::datatransfer::DataPackageOperation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AllowedOperations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn set_allowed_operations(&self, value: super::super::applicationmodel::datatransfer::DataPackageOperation) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AllowedOperations)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class DragStartingEventArgs: IDragStartingEventArgs}
DEFINE_IID!(IID_IDropCompletedEventArgs, 1817166216, 38332, 16993, 158, 197, 33, 202, 182, 119, 183, 52);
RT_INTERFACE!{interface IDropCompletedEventArgs(IDropCompletedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDropCompletedEventArgs] {
    #[cfg(feature="windows-applicationmodel")] fn get_DropResult(&self, out: *mut super::super::applicationmodel::datatransfer::DataPackageOperation) -> HRESULT
}}
impl IDropCompletedEventArgs {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn get_drop_result(&self) -> Result<super::super::applicationmodel::datatransfer::DataPackageOperation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DropResult)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class DropCompletedEventArgs: IDropCompletedEventArgs}
DEFINE_IID!(IID_IExceptionRoutedEventArgs, 3718246762, 19298, 19052, 164, 157, 6, 113, 239, 97, 54, 190);
RT_INTERFACE!{interface IExceptionRoutedEventArgs(IExceptionRoutedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IExceptionRoutedEventArgs] {
    fn get_ErrorMessage(&self, out: *mut HSTRING) -> HRESULT
}}
impl IExceptionRoutedEventArgs {
    #[inline] pub unsafe fn get_error_message(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ErrorMessage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ExceptionRoutedEventArgs: IExceptionRoutedEventArgs}
DEFINE_IID!(IID_IExceptionRoutedEventArgsFactory, 3148448365, 23930, 17639, 184, 147, 178, 174, 13, 210, 66, 115);
RT_INTERFACE!{interface IExceptionRoutedEventArgsFactory(IExceptionRoutedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IExceptionRoutedEventArgsFactory] {
    
}}
DEFINE_IID!(IID_IFrameworkTemplate, 2715964632, 42054, 18983, 154, 157, 160, 245, 158, 18, 88, 165);
RT_INTERFACE!{interface IFrameworkTemplate(IFrameworkTemplateVtbl): IInspectable(IInspectableVtbl) [IID_IFrameworkTemplate] {
    
}}
DEFINE_IID!(IID_IFrameworkTemplateFactory, 444113061, 37757, 18132, 131, 43, 148, 255, 20, 218, 176, 97);
RT_INTERFACE!{interface IFrameworkTemplateFactory(IFrameworkTemplateFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IFrameworkTemplateFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut FrameworkTemplate) -> HRESULT
}}
impl IFrameworkTemplateFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<FrameworkTemplate>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class FrameworkTemplate: IFrameworkTemplate}
RT_CLASS!{class DataTemplate: IDataTemplate}
impl RtActivatable<IDataTemplateStatics2> for DataTemplate {}
impl DataTemplate {
    #[inline] pub fn get_extension_instance_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDataTemplateStatics2>>::get_activation_factory().get_extension_instance_property()
    }}
    #[inline] pub fn get_extension_instance(element: &FrameworkElement) -> Result<ComPtr<IDataTemplateExtension>> { unsafe {
        <Self as RtActivatable<IDataTemplateStatics2>>::get_activation_factory().get_extension_instance(element)
    }}
    #[inline] pub fn set_extension_instance(element: &FrameworkElement, value: &IDataTemplateExtension) -> Result<()> { unsafe {
        <Self as RtActivatable<IDataTemplateStatics2>>::get_activation_factory().set_extension_instance(element, value)
    }}
}
DEFINE_CLSID!(DataTemplate(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,68,97,116,97,84,101,109,112,108,97,116,101,0]) [CLSID_DataTemplate]);
DEFINE_IID!(IID_IPropertyPath, 806247818, 8179, 19756, 149, 236, 39, 248, 29, 235, 172, 184);
RT_INTERFACE!{interface IPropertyPath(IPropertyPathVtbl): IInspectable(IInspectableVtbl) [IID_IPropertyPath] {
    fn get_Path(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPropertyPath {
    #[inline] pub unsafe fn get_path(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Path)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PropertyPath: IPropertyPath}
impl RtActivatable<IPropertyPathFactory> for PropertyPath {}
impl PropertyPath {
    #[inline] pub fn create_instance(path: &HStringArg) -> Result<ComPtr<PropertyPath>> { unsafe {
        <Self as RtActivatable<IPropertyPathFactory>>::get_activation_factory().create_instance(path)
    }}
}
DEFINE_CLSID!(PropertyPath(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,80,114,111,112,101,114,116,121,80,97,116,104,0]) [CLSID_PropertyPath]);
DEFINE_IID!(IID_IPropertyPathFactory, 1313660825, 38950, 20054, 132, 124, 202, 5, 95, 22, 41, 5);
RT_INTERFACE!{static interface IPropertyPathFactory(IPropertyPathFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPropertyPathFactory] {
    fn CreateInstance(&self, path: HSTRING, out: *mut *mut PropertyPath) -> HRESULT
}}
impl IPropertyPathFactory {
    #[inline] pub unsafe fn create_instance(&self, path: &HStringArg) -> Result<ComPtr<PropertyPath>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, path.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IResourceDictionary, 3253358372, 55006, 16785, 142, 58, 244, 134, 1, 247, 72, 156);
RT_INTERFACE!{interface IResourceDictionary(IResourceDictionaryVtbl): IInspectable(IInspectableVtbl) [IID_IResourceDictionary] {
    fn get_Source(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn put_Source(&self, value: *mut super::super::foundation::Uri) -> HRESULT,
    fn get_MergedDictionaries(&self, out: *mut *mut super::super::foundation::collections::IVector<ResourceDictionary>) -> HRESULT,
    fn get_ThemeDictionaries(&self, out: *mut *mut super::super::foundation::collections::IMap<IInspectable, IInspectable>) -> HRESULT
}}
impl IResourceDictionary {
    #[inline] pub unsafe fn get_source(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Source)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_source(&self, value: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Source)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_merged_dictionaries(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<ResourceDictionary>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MergedDictionaries)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_theme_dictionaries(&self) -> Result<ComPtr<super::super::foundation::collections::IMap<IInspectable, IInspectable>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ThemeDictionaries)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ResourceDictionary: IResourceDictionary}
DEFINE_IID!(IID_IResourceDictionaryFactory, 3929422261, 12727, 17009, 146, 201, 124, 149, 132, 169, 28, 34);
RT_INTERFACE!{interface IResourceDictionaryFactory(IResourceDictionaryFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IResourceDictionaryFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ResourceDictionary) -> HRESULT
}}
impl IResourceDictionaryFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ResourceDictionary>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISetterBase, 1099686524, 10948, 20258, 128, 151, 222, 163, 174, 235, 47, 179);
RT_INTERFACE!{interface ISetterBase(ISetterBaseVtbl): IInspectable(IInspectableVtbl) [IID_ISetterBase] {
    fn get_IsSealed(&self, out: *mut bool) -> HRESULT
}}
impl ISetterBase {
    #[inline] pub unsafe fn get_is_sealed(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSealed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class SetterBase: ISetterBase}
DEFINE_IID!(IID_ISetterBaseFactory, 2180558176, 7400, 18077, 166, 103, 22, 227, 124, 239, 139, 169);
RT_INTERFACE!{interface ISetterBaseFactory(ISetterBaseFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISetterBaseFactory] {
    
}}
DEFINE_IID!(IID_ISizeChangedEventArgs, 3576770144, 23745, 17057, 146, 12, 26, 244, 107, 226, 249, 134);
RT_INTERFACE!{interface ISizeChangedEventArgs(ISizeChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISizeChangedEventArgs] {
    fn get_PreviousSize(&self, out: *mut super::super::foundation::Size) -> HRESULT,
    fn get_NewSize(&self, out: *mut super::super::foundation::Size) -> HRESULT
}}
impl ISizeChangedEventArgs {
    #[inline] pub unsafe fn get_previous_size(&self) -> Result<super::super::foundation::Size> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PreviousSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_new_size(&self) -> Result<super::super::foundation::Size> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NewSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class SizeChangedEventArgs: ISizeChangedEventArgs}
DEFINE_IID!(IID_IStateTriggerBase, 1219626648, 44806, 18028, 128, 82, 147, 102, 109, 222, 14, 73);
RT_INTERFACE!{interface IStateTriggerBase(IStateTriggerBaseVtbl): IInspectable(IInspectableVtbl) [IID_IStateTriggerBase] {
    
}}
DEFINE_IID!(IID_IStateTriggerBaseProtected, 1010950739, 36116, 16918, 153, 76, 249, 147, 4, 41, 246, 229);
RT_INTERFACE!{interface IStateTriggerBaseProtected(IStateTriggerBaseProtectedVtbl): IInspectable(IInspectableVtbl) [IID_IStateTriggerBaseProtected] {
    fn SetActive(&self, isActive: bool) -> HRESULT
}}
impl IStateTriggerBaseProtected {
    #[inline] pub unsafe fn set_active(&self, isActive: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetActive)(self as *const _ as *mut _, isActive);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IStateTriggerBaseFactory, 2534288459, 49071, 18352, 190, 66, 193, 215, 17, 187, 46, 159);
RT_INTERFACE!{interface IStateTriggerBaseFactory(IStateTriggerBaseFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IStateTriggerBaseFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut StateTriggerBase) -> HRESULT
}}
impl IStateTriggerBaseFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<StateTriggerBase>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class StateTriggerBase: IStateTriggerBase}
DEFINE_IID!(IID_IStyle, 3299471909, 40375, 19069, 182, 209, 247, 78, 219, 146, 147, 194);
RT_INTERFACE!{interface IStyle(IStyleVtbl): IInspectable(IInspectableVtbl) [IID_IStyle] {
    fn get_IsSealed(&self, out: *mut bool) -> HRESULT,
    fn get_Setters(&self, out: *mut *mut SetterBaseCollection) -> HRESULT,
    fn get_TargetType(&self, out: *mut interop::TypeName) -> HRESULT,
    fn put_TargetType(&self, value: interop::TypeName) -> HRESULT,
    fn get_BasedOn(&self, out: *mut *mut Style) -> HRESULT,
    fn put_BasedOn(&self, value: *mut Style) -> HRESULT,
    fn Seal(&self) -> HRESULT
}}
impl IStyle {
    #[inline] pub unsafe fn get_is_sealed(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSealed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_setters(&self) -> Result<ComPtr<SetterBaseCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Setters)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_target_type(&self) -> Result<interop::TypeName> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TargetType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_type(&self, value: interop::TypeName) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetType)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_based_on(&self) -> Result<ComPtr<Style>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BasedOn)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_based_on(&self, value: &Style) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BasedOn)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn seal(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Seal)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class Style: IStyle}
impl RtActivatable<IStyleFactory> for Style {}
impl RtActivatable<IActivationFactory> for Style {}
impl Style {
    #[inline] pub fn create_instance(targetType: interop::TypeName) -> Result<ComPtr<Style>> { unsafe {
        <Self as RtActivatable<IStyleFactory>>::get_activation_factory().create_instance(targetType)
    }}
}
DEFINE_CLSID!(Style(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,83,116,121,108,101,0]) [CLSID_Style]);
DEFINE_IID!(IID_IStyleFactory, 2741511395, 15745, 19685, 170, 81, 139, 65, 15, 96, 47, 205);
RT_INTERFACE!{static interface IStyleFactory(IStyleFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IStyleFactory] {
    fn CreateInstance(&self, targetType: interop::TypeName, out: *mut *mut Style) -> HRESULT
}}
impl IStyleFactory {
    #[inline] pub unsafe fn create_instance(&self, targetType: interop::TypeName) -> Result<ComPtr<Style>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, targetType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITriggerAction, 2730548994, 25557, 19270, 155, 131, 8, 104, 211, 7, 150, 33);
RT_INTERFACE!{interface ITriggerAction(ITriggerActionVtbl): IInspectable(IInspectableVtbl) [IID_ITriggerAction] {
    
}}
DEFINE_IID!(IID_ITriggerActionFactory, 1758642361, 12937, 16719, 143, 110, 198, 185, 122, 237, 218, 3);
RT_INTERFACE!{interface ITriggerActionFactory(ITriggerActionFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ITriggerActionFactory] {
    
}}
RT_CLASS!{class TriggerAction: ITriggerAction}
DEFINE_IID!(IID_ITriggerBase, 3890881071, 57062, 17299, 168, 178, 137, 35, 214, 65, 243, 149);
RT_INTERFACE!{interface ITriggerBase(ITriggerBaseVtbl): IInspectable(IInspectableVtbl) [IID_ITriggerBase] {
    
}}
DEFINE_IID!(IID_ITriggerBaseFactory, 1782292055, 64605, 17104, 140, 185, 202, 80, 102, 122, 247, 70);
RT_INTERFACE!{interface ITriggerBaseFactory(ITriggerBaseFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ITriggerBaseFactory] {
    
}}
RT_CLASS!{class TriggerBase: ITriggerBase}
DEFINE_IID!(IID_IUIElement, 1735199721, 46684, 16838, 186, 64, 88, 207, 135, 242, 1, 193);
RT_INTERFACE!{interface IUIElement(IUIElementVtbl): IInspectable(IInspectableVtbl) [IID_IUIElement] {
    fn get_DesiredSize(&self, out: *mut super::super::foundation::Size) -> HRESULT,
    fn get_AllowDrop(&self, out: *mut bool) -> HRESULT,
    fn put_AllowDrop(&self, value: bool) -> HRESULT,
    fn get_Opacity(&self, out: *mut f64) -> HRESULT,
    fn put_Opacity(&self, value: f64) -> HRESULT,
    fn get_Clip(&self, out: *mut *mut media::RectangleGeometry) -> HRESULT,
    fn put_Clip(&self, value: *mut media::RectangleGeometry) -> HRESULT,
    fn get_RenderTransform(&self, out: *mut *mut media::Transform) -> HRESULT,
    fn put_RenderTransform(&self, value: *mut media::Transform) -> HRESULT,
    fn get_Projection(&self, out: *mut *mut media::Projection) -> HRESULT,
    fn put_Projection(&self, value: *mut media::Projection) -> HRESULT,
    fn get_RenderTransformOrigin(&self, out: *mut super::super::foundation::Point) -> HRESULT,
    fn put_RenderTransformOrigin(&self, value: super::super::foundation::Point) -> HRESULT,
    fn get_IsHitTestVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsHitTestVisible(&self, value: bool) -> HRESULT,
    fn get_Visibility(&self, out: *mut Visibility) -> HRESULT,
    fn put_Visibility(&self, value: Visibility) -> HRESULT,
    fn get_RenderSize(&self, out: *mut super::super::foundation::Size) -> HRESULT,
    fn get_UseLayoutRounding(&self, out: *mut bool) -> HRESULT,
    fn put_UseLayoutRounding(&self, value: bool) -> HRESULT,
    fn get_Transitions(&self, out: *mut *mut media::animation::TransitionCollection) -> HRESULT,
    fn put_Transitions(&self, value: *mut media::animation::TransitionCollection) -> HRESULT,
    fn get_CacheMode(&self, out: *mut *mut media::CacheMode) -> HRESULT,
    fn put_CacheMode(&self, value: *mut media::CacheMode) -> HRESULT,
    fn get_IsTapEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsTapEnabled(&self, value: bool) -> HRESULT,
    fn get_IsDoubleTapEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsDoubleTapEnabled(&self, value: bool) -> HRESULT,
    fn get_IsRightTapEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsRightTapEnabled(&self, value: bool) -> HRESULT,
    fn get_IsHoldingEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsHoldingEnabled(&self, value: bool) -> HRESULT,
    fn get_ManipulationMode(&self, out: *mut input::ManipulationModes) -> HRESULT,
    fn put_ManipulationMode(&self, value: input::ManipulationModes) -> HRESULT,
    fn get_PointerCaptures(&self, out: *mut *mut super::super::foundation::collections::IVectorView<input::Pointer>) -> HRESULT,
    fn add_KeyUp(&self, value: *mut input::KeyEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_KeyUp(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_KeyDown(&self, value: *mut input::KeyEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_KeyDown(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_GotFocus(&self, value: *mut RoutedEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_GotFocus(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_LostFocus(&self, value: *mut RoutedEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LostFocus(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_DragEnter(&self, value: *mut DragEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DragEnter(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_DragLeave(&self, value: *mut DragEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DragLeave(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_DragOver(&self, value: *mut DragEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DragOver(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Drop(&self, value: *mut DragEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Drop(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerPressed(&self, value: *mut input::PointerEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerPressed(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerMoved(&self, value: *mut input::PointerEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerMoved(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerReleased(&self, value: *mut input::PointerEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerReleased(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerEntered(&self, value: *mut input::PointerEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerEntered(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerExited(&self, value: *mut input::PointerEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerExited(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerCaptureLost(&self, value: *mut input::PointerEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerCaptureLost(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerCanceled(&self, value: *mut input::PointerEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerCanceled(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerWheelChanged(&self, value: *mut input::PointerEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerWheelChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Tapped(&self, value: *mut input::TappedEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Tapped(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_DoubleTapped(&self, value: *mut input::DoubleTappedEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DoubleTapped(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Holding(&self, value: *mut input::HoldingEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Holding(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_RightTapped(&self, value: *mut input::RightTappedEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RightTapped(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ManipulationStarting(&self, value: *mut input::ManipulationStartingEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ManipulationStarting(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ManipulationInertiaStarting(&self, value: *mut input::ManipulationInertiaStartingEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ManipulationInertiaStarting(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ManipulationStarted(&self, value: *mut input::ManipulationStartedEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ManipulationStarted(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ManipulationDelta(&self, value: *mut input::ManipulationDeltaEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ManipulationDelta(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ManipulationCompleted(&self, value: *mut input::ManipulationCompletedEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ManipulationCompleted(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn Measure(&self, availableSize: super::super::foundation::Size) -> HRESULT,
    fn Arrange(&self, finalRect: super::super::foundation::Rect) -> HRESULT,
    fn CapturePointer(&self, value: *mut input::Pointer, out: *mut bool) -> HRESULT,
    fn ReleasePointerCapture(&self, value: *mut input::Pointer) -> HRESULT,
    fn ReleasePointerCaptures(&self) -> HRESULT,
    fn AddHandler(&self, routedEvent: *mut RoutedEvent, handler: *mut IInspectable, handledEventsToo: bool) -> HRESULT,
    fn RemoveHandler(&self, routedEvent: *mut RoutedEvent, handler: *mut IInspectable) -> HRESULT,
    fn TransformToVisual(&self, visual: *mut UIElement, out: *mut *mut media::GeneralTransform) -> HRESULT,
    fn InvalidateMeasure(&self) -> HRESULT,
    fn InvalidateArrange(&self) -> HRESULT,
    fn UpdateLayout(&self) -> HRESULT
}}
impl IUIElement {
    #[inline] pub unsafe fn get_desired_size(&self) -> Result<super::super::foundation::Size> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DesiredSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_allow_drop(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AllowDrop)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_allow_drop(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AllowDrop)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_opacity(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Opacity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_opacity(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Opacity)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_clip(&self) -> Result<ComPtr<media::RectangleGeometry>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Clip)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_clip(&self, value: &media::RectangleGeometry) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Clip)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_render_transform(&self) -> Result<ComPtr<media::Transform>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RenderTransform)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_render_transform(&self, value: &media::Transform) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RenderTransform)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_projection(&self) -> Result<ComPtr<media::Projection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Projection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_projection(&self, value: &media::Projection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Projection)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_render_transform_origin(&self) -> Result<super::super::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RenderTransformOrigin)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_render_transform_origin(&self, value: super::super::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RenderTransformOrigin)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_hit_test_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsHitTestVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_hit_test_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsHitTestVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_visibility(&self) -> Result<Visibility> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Visibility)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_visibility(&self, value: Visibility) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Visibility)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_render_size(&self) -> Result<super::super::foundation::Size> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RenderSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_use_layout_rounding(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_UseLayoutRounding)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_use_layout_rounding(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_UseLayoutRounding)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transitions(&self) -> Result<ComPtr<media::animation::TransitionCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Transitions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_transitions(&self, value: &media::animation::TransitionCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Transitions)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_cache_mode(&self) -> Result<ComPtr<media::CacheMode>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CacheMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_cache_mode(&self, value: &media::CacheMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CacheMode)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_tap_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTapEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_tap_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsTapEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_double_tap_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsDoubleTapEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_double_tap_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsDoubleTapEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_right_tap_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsRightTapEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_right_tap_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsRightTapEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_holding_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsHoldingEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_holding_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsHoldingEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_manipulation_mode(&self) -> Result<input::ManipulationModes> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ManipulationMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_manipulation_mode(&self, value: input::ManipulationModes) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ManipulationMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pointer_captures(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<input::Pointer>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointerCaptures)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_key_up(&self, value: &input::KeyEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_KeyUp)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_key_up(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_KeyUp)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_key_down(&self, value: &input::KeyEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_KeyDown)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_key_down(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_KeyDown)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_got_focus(&self, value: &RoutedEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_GotFocus)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_got_focus(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_GotFocus)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_lost_focus(&self, value: &RoutedEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_LostFocus)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_lost_focus(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_LostFocus)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_drag_enter(&self, value: &DragEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DragEnter)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_drag_enter(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DragEnter)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_drag_leave(&self, value: &DragEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DragLeave)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_drag_leave(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DragLeave)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_drag_over(&self, value: &DragEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DragOver)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_drag_over(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DragOver)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_drop(&self, value: &DragEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Drop)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_drop(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Drop)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_pointer_pressed(&self, value: &input::PointerEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerPressed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_pointer_pressed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PointerPressed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_pointer_moved(&self, value: &input::PointerEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerMoved)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_pointer_moved(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PointerMoved)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_pointer_released(&self, value: &input::PointerEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerReleased)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_pointer_released(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PointerReleased)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_pointer_entered(&self, value: &input::PointerEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerEntered)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_pointer_entered(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PointerEntered)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_pointer_exited(&self, value: &input::PointerEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerExited)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_pointer_exited(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PointerExited)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_pointer_capture_lost(&self, value: &input::PointerEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerCaptureLost)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_pointer_capture_lost(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PointerCaptureLost)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_pointer_canceled(&self, value: &input::PointerEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerCanceled)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_pointer_canceled(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PointerCanceled)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_pointer_wheel_changed(&self, value: &input::PointerEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerWheelChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_pointer_wheel_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PointerWheelChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_tapped(&self, value: &input::TappedEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Tapped)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_tapped(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Tapped)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_double_tapped(&self, value: &input::DoubleTappedEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DoubleTapped)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_double_tapped(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DoubleTapped)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_holding(&self, value: &input::HoldingEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Holding)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_holding(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Holding)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_right_tapped(&self, value: &input::RightTappedEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_RightTapped)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_right_tapped(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_RightTapped)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_manipulation_starting(&self, value: &input::ManipulationStartingEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ManipulationStarting)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_manipulation_starting(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ManipulationStarting)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_manipulation_inertia_starting(&self, value: &input::ManipulationInertiaStartingEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ManipulationInertiaStarting)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_manipulation_inertia_starting(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ManipulationInertiaStarting)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_manipulation_started(&self, value: &input::ManipulationStartedEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ManipulationStarted)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_manipulation_started(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ManipulationStarted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_manipulation_delta(&self, value: &input::ManipulationDeltaEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ManipulationDelta)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_manipulation_delta(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ManipulationDelta)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_manipulation_completed(&self, value: &input::ManipulationCompletedEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ManipulationCompleted)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_manipulation_completed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ManipulationCompleted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn measure(&self, availableSize: super::super::foundation::Size) -> Result<()> {
        let hr = ((*self.lpVtbl).Measure)(self as *const _ as *mut _, availableSize);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn arrange(&self, finalRect: super::super::foundation::Rect) -> Result<()> {
        let hr = ((*self.lpVtbl).Arrange)(self as *const _ as *mut _, finalRect);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn capture_pointer(&self, value: &input::Pointer) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).CapturePointer)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn release_pointer_capture(&self, value: &input::Pointer) -> Result<()> {
        let hr = ((*self.lpVtbl).ReleasePointerCapture)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn release_pointer_captures(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ReleasePointerCaptures)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_handler(&self, routedEvent: &RoutedEvent, handler: &IInspectable, handledEventsToo: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).AddHandler)(self as *const _ as *mut _, routedEvent as *const _ as *mut _, handler as *const _ as *mut _, handledEventsToo);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_handler(&self, routedEvent: &RoutedEvent, handler: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).RemoveHandler)(self as *const _ as *mut _, routedEvent as *const _ as *mut _, handler as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn transform_to_visual(&self, visual: &UIElement) -> Result<ComPtr<media::GeneralTransform>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TransformToVisual)(self as *const _ as *mut _, visual as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn invalidate_measure(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).InvalidateMeasure)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn invalidate_arrange(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).InvalidateArrange)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn update_layout(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).UpdateLayout)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IUIElementOverrides, 1619865373, 30808, 19179, 137, 228, 181, 78, 44, 126, 211, 211);
RT_INTERFACE!{interface IUIElementOverrides(IUIElementOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IUIElementOverrides] {
    fn OnCreateAutomationPeer(&self, out: *mut *mut automation::peers::AutomationPeer) -> HRESULT,
    fn OnDisconnectVisualChildren(&self) -> HRESULT,
    fn FindSubElementsForTouchTargeting(&self, point: super::super::foundation::Point, boundingRect: super::super::foundation::Rect, out: *mut *mut super::super::foundation::collections::IIterable<super::super::foundation::collections::IIterable<super::super::foundation::Point>>) -> HRESULT
}}
impl IUIElementOverrides {
    #[inline] pub unsafe fn on_create_automation_peer(&self) -> Result<ComPtr<automation::peers::AutomationPeer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).OnCreateAutomationPeer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_disconnect_visual_children(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).OnDisconnectVisualChildren)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_sub_elements_for_touch_targeting(&self, point: super::super::foundation::Point, boundingRect: super::super::foundation::Rect) -> Result<ComPtr<super::super::foundation::collections::IIterable<super::super::foundation::collections::IIterable<super::super::foundation::Point>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindSubElementsForTouchTargeting)(self as *const _ as *mut _, point, boundingRect, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IUIElementStatics, 1490245435, 62764, 17854, 152, 139, 165, 134, 149, 100, 135, 60);
RT_INTERFACE!{static interface IUIElementStatics(IUIElementStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IUIElementStatics] {
    fn get_KeyDownEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_KeyUpEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_PointerEnteredEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_PointerPressedEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_PointerMovedEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_PointerReleasedEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_PointerExitedEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_PointerCaptureLostEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_PointerCanceledEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_PointerWheelChangedEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_TappedEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_DoubleTappedEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_HoldingEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_RightTappedEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_ManipulationStartingEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_ManipulationInertiaStartingEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_ManipulationStartedEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_ManipulationDeltaEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_ManipulationCompletedEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_DragEnterEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_DragLeaveEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_DragOverEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_DropEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_AllowDropProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_OpacityProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_ClipProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_RenderTransformProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_ProjectionProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_RenderTransformOriginProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_IsHitTestVisibleProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_VisibilityProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_UseLayoutRoundingProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_TransitionsProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_CacheModeProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_IsTapEnabledProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_IsDoubleTapEnabledProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_IsRightTapEnabledProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_IsHoldingEnabledProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_ManipulationModeProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_PointerCapturesProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT
}}
impl IUIElementStatics {
    #[inline] pub unsafe fn get_key_down_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeyDownEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_key_up_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeyUpEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pointer_entered_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointerEnteredEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pointer_pressed_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointerPressedEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pointer_moved_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointerMovedEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pointer_released_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointerReleasedEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pointer_exited_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointerExitedEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pointer_capture_lost_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointerCaptureLostEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pointer_canceled_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointerCanceledEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pointer_wheel_changed_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointerWheelChangedEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tapped_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TappedEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_double_tapped_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DoubleTappedEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_holding_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HoldingEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_right_tapped_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RightTappedEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_manipulation_starting_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ManipulationStartingEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_manipulation_inertia_starting_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ManipulationInertiaStartingEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_manipulation_started_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ManipulationStartedEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_manipulation_delta_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ManipulationDeltaEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_manipulation_completed_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ManipulationCompletedEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drag_enter_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DragEnterEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drag_leave_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DragLeaveEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drag_over_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DragOverEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drop_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DropEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_allow_drop_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AllowDropProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_opacity_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OpacityProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_clip_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ClipProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_render_transform_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RenderTransformProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_projection_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProjectionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_render_transform_origin_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RenderTransformOriginProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_hit_test_visible_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsHitTestVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_visibility_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VisibilityProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_use_layout_rounding_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UseLayoutRoundingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transitions_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransitionsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_cache_mode_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CacheModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_tap_enabled_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsTapEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_double_tap_enabled_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsDoubleTapEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_right_tap_enabled_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsRightTapEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_holding_enabled_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsHoldingEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_manipulation_mode_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ManipulationModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pointer_captures_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointerCapturesProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IUIElementFactory, 3119420414, 41784, 16799, 172, 50, 145, 220, 170, 223, 93, 8);
RT_INTERFACE!{interface IUIElementFactory(IUIElementFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IUIElementFactory] {
    
}}
DEFINE_IID!(IID_IUIElement2, 1735199737, 46700, 16854, 186, 80, 88, 207, 135, 242, 1, 209);
RT_INTERFACE!{interface IUIElement2(IUIElement2Vtbl): IInspectable(IInspectableVtbl) [IID_IUIElement2] {
    fn get_CompositeMode(&self, out: *mut media::ElementCompositeMode) -> HRESULT,
    fn put_CompositeMode(&self, value: media::ElementCompositeMode) -> HRESULT,
    fn CancelDirectManipulations(&self, out: *mut bool) -> HRESULT
}}
impl IUIElement2 {
    #[inline] pub unsafe fn get_composite_mode(&self) -> Result<media::ElementCompositeMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CompositeMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_composite_mode(&self, value: media::ElementCompositeMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CompositeMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn cancel_direct_manipulations(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).CancelDirectManipulations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IUIElementStatics2, 1490245451, 62780, 17854, 152, 155, 165, 134, 149, 100, 135, 76);
RT_INTERFACE!{static interface IUIElementStatics2(IUIElementStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IUIElementStatics2] {
    fn get_CompositeModeProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT
}}
impl IUIElementStatics2 {
    #[inline] pub unsafe fn get_composite_mode_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CompositeModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IUIElement3, 3156945137, 9970, 19115, 178, 86, 59, 83, 80, 136, 30, 55);
RT_INTERFACE!{interface IUIElement3(IUIElement3Vtbl): IInspectable(IInspectableVtbl) [IID_IUIElement3] {
    fn get_Transform3D(&self, out: *mut *mut media::media3d::Transform3D) -> HRESULT,
    fn put_Transform3D(&self, value: *mut media::media3d::Transform3D) -> HRESULT,
    fn get_CanDrag(&self, out: *mut bool) -> HRESULT,
    fn put_CanDrag(&self, value: bool) -> HRESULT,
    fn add_DragStarting(&self, value: *mut super::super::foundation::TypedEventHandler<UIElement, DragStartingEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DragStarting(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_DropCompleted(&self, value: *mut super::super::foundation::TypedEventHandler<UIElement, DropCompletedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DropCompleted(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    #[cfg(all(feature="windows-applicationmodel",feature="windows-ui"))] fn StartDragAsync(&self, pointerPoint: *mut super::input::PointerPoint, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::applicationmodel::datatransfer::DataPackageOperation>) -> HRESULT
}}
impl IUIElement3 {
    #[inline] pub unsafe fn get_transform3_d(&self) -> Result<ComPtr<media::media3d::Transform3D>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Transform3D)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_transform3_d(&self, value: &media::media3d::Transform3D) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Transform3D)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_drag(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanDrag)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_drag(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanDrag)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_drag_starting(&self, value: &super::super::foundation::TypedEventHandler<UIElement, DragStartingEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DragStarting)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_drag_starting(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DragStarting)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_drop_completed(&self, value: &super::super::foundation::TypedEventHandler<UIElement, DropCompletedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DropCompleted)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_drop_completed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DropCompleted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(all(feature="windows-applicationmodel",feature="windows-ui"))] #[inline] pub unsafe fn start_drag_async(&self, pointerPoint: &super::input::PointerPoint) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::applicationmodel::datatransfer::DataPackageOperation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).StartDragAsync)(self as *const _ as *mut _, pointerPoint as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IUIElementStatics3, 3522722526, 60577, 17761, 163, 43, 100, 96, 27, 78, 5, 151);
RT_INTERFACE!{static interface IUIElementStatics3(IUIElementStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IUIElementStatics3] {
    fn get_Transform3DProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_CanDragProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn TryStartDirectManipulation(&self, value: *mut input::Pointer, out: *mut bool) -> HRESULT
}}
impl IUIElementStatics3 {
    #[inline] pub unsafe fn get_transform3_dproperty(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Transform3DProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_drag_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CanDragProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_start_direct_manipulation(&self, value: &input::Pointer) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryStartDirectManipulation)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IUIElement4, 1762942164, 6554, 18007, 158, 87, 233, 158, 143, 19, 103, 18);
RT_INTERFACE!{interface IUIElement4(IUIElement4Vtbl): IInspectable(IInspectableVtbl) [IID_IUIElement4] {
    fn get_ContextFlyout(&self, out: *mut *mut controls::primitives::FlyoutBase) -> HRESULT,
    fn put_ContextFlyout(&self, value: *mut controls::primitives::FlyoutBase) -> HRESULT,
    fn get_ExitDisplayModeOnAccessKeyInvoked(&self, out: *mut bool) -> HRESULT,
    fn put_ExitDisplayModeOnAccessKeyInvoked(&self, value: bool) -> HRESULT,
    fn get_IsAccessKeyScope(&self, out: *mut bool) -> HRESULT,
    fn put_IsAccessKeyScope(&self, value: bool) -> HRESULT,
    fn get_AccessKeyScopeOwner(&self, out: *mut *mut DependencyObject) -> HRESULT,
    fn put_AccessKeyScopeOwner(&self, value: *mut DependencyObject) -> HRESULT,
    fn get_AccessKey(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AccessKey(&self, value: HSTRING) -> HRESULT,
    fn add_ContextRequested(&self, value: *mut super::super::foundation::TypedEventHandler<UIElement, input::ContextRequestedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ContextRequested(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ContextCanceled(&self, value: *mut super::super::foundation::TypedEventHandler<UIElement, RoutedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ContextCanceled(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_AccessKeyDisplayRequested(&self, value: *mut super::super::foundation::TypedEventHandler<UIElement, input::AccessKeyDisplayRequestedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AccessKeyDisplayRequested(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_AccessKeyDisplayDismissed(&self, value: *mut super::super::foundation::TypedEventHandler<UIElement, input::AccessKeyDisplayDismissedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AccessKeyDisplayDismissed(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_AccessKeyInvoked(&self, value: *mut super::super::foundation::TypedEventHandler<UIElement, input::AccessKeyInvokedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AccessKeyInvoked(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IUIElement4 {
    #[inline] pub unsafe fn get_context_flyout(&self) -> Result<ComPtr<controls::primitives::FlyoutBase>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContextFlyout)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_context_flyout(&self, value: &controls::primitives::FlyoutBase) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContextFlyout)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_exit_display_mode_on_access_key_invoked(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExitDisplayModeOnAccessKeyInvoked)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_exit_display_mode_on_access_key_invoked(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ExitDisplayModeOnAccessKeyInvoked)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_access_key_scope(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsAccessKeyScope)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_access_key_scope(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsAccessKeyScope)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_access_key_scope_owner(&self) -> Result<ComPtr<DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AccessKeyScopeOwner)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_access_key_scope_owner(&self, value: &DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AccessKeyScopeOwner)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_access_key(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AccessKey)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_access_key(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AccessKey)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_context_requested(&self, value: &super::super::foundation::TypedEventHandler<UIElement, input::ContextRequestedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ContextRequested)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_context_requested(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ContextRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_context_canceled(&self, value: &super::super::foundation::TypedEventHandler<UIElement, RoutedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ContextCanceled)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_context_canceled(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ContextCanceled)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_access_key_display_requested(&self, value: &super::super::foundation::TypedEventHandler<UIElement, input::AccessKeyDisplayRequestedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_AccessKeyDisplayRequested)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_access_key_display_requested(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_AccessKeyDisplayRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_access_key_display_dismissed(&self, value: &super::super::foundation::TypedEventHandler<UIElement, input::AccessKeyDisplayDismissedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_AccessKeyDisplayDismissed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_access_key_display_dismissed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_AccessKeyDisplayDismissed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_access_key_invoked(&self, value: &super::super::foundation::TypedEventHandler<UIElement, input::AccessKeyInvokedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_AccessKeyInvoked)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_access_key_invoked(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_AccessKeyInvoked)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IUIElementStatics4, 487947617, 5807, 16671, 183, 116, 39, 35, 117, 164, 172, 44);
RT_INTERFACE!{static interface IUIElementStatics4(IUIElementStatics4Vtbl): IInspectable(IInspectableVtbl) [IID_IUIElementStatics4] {
    fn get_ContextFlyoutProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_ExitDisplayModeOnAccessKeyInvokedProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_IsAccessKeyScopeProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_AccessKeyScopeOwnerProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_AccessKeyProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT
}}
impl IUIElementStatics4 {
    #[inline] pub unsafe fn get_context_flyout_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContextFlyoutProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_exit_display_mode_on_access_key_invoked_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExitDisplayModeOnAccessKeyInvokedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_access_key_scope_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsAccessKeyScopeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_access_key_scope_owner_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AccessKeyScopeOwnerProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_access_key_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AccessKeyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IUIElement5, 2397936578, 42380, 17491, 175, 15, 169, 46, 224, 109, 3, 23);
RT_INTERFACE!{interface IUIElement5(IUIElement5Vtbl): IInspectable(IInspectableVtbl) [IID_IUIElement5] {
    fn get_Lights(&self, out: *mut *mut super::super::foundation::collections::IVector<media::XamlLight>) -> HRESULT,
    fn get_KeyTipPlacementMode(&self, out: *mut input::KeyTipPlacementMode) -> HRESULT,
    fn put_KeyTipPlacementMode(&self, value: input::KeyTipPlacementMode) -> HRESULT,
    fn get_KeyTipHorizontalOffset(&self, out: *mut f64) -> HRESULT,
    fn put_KeyTipHorizontalOffset(&self, value: f64) -> HRESULT,
    fn get_KeyTipVerticalOffset(&self, out: *mut f64) -> HRESULT,
    fn put_KeyTipVerticalOffset(&self, value: f64) -> HRESULT,
    fn get_XYFocusKeyboardNavigation(&self, out: *mut input::XYFocusKeyboardNavigationMode) -> HRESULT,
    fn put_XYFocusKeyboardNavigation(&self, value: input::XYFocusKeyboardNavigationMode) -> HRESULT,
    fn get_XYFocusUpNavigationStrategy(&self, out: *mut input::XYFocusNavigationStrategy) -> HRESULT,
    fn put_XYFocusUpNavigationStrategy(&self, value: input::XYFocusNavigationStrategy) -> HRESULT,
    fn get_XYFocusDownNavigationStrategy(&self, out: *mut input::XYFocusNavigationStrategy) -> HRESULT,
    fn put_XYFocusDownNavigationStrategy(&self, value: input::XYFocusNavigationStrategy) -> HRESULT,
    fn get_XYFocusLeftNavigationStrategy(&self, out: *mut input::XYFocusNavigationStrategy) -> HRESULT,
    fn put_XYFocusLeftNavigationStrategy(&self, value: input::XYFocusNavigationStrategy) -> HRESULT,
    fn get_XYFocusRightNavigationStrategy(&self, out: *mut input::XYFocusNavigationStrategy) -> HRESULT,
    fn put_XYFocusRightNavigationStrategy(&self, value: input::XYFocusNavigationStrategy) -> HRESULT,
    fn get_HighContrastAdjustment(&self, out: *mut ElementHighContrastAdjustment) -> HRESULT,
    fn put_HighContrastAdjustment(&self, value: ElementHighContrastAdjustment) -> HRESULT,
    fn get_TabFocusNavigation(&self, out: *mut input::KeyboardNavigationMode) -> HRESULT,
    fn put_TabFocusNavigation(&self, value: input::KeyboardNavigationMode) -> HRESULT,
    fn add_GettingFocus(&self, value: *mut super::super::foundation::TypedEventHandler<UIElement, input::GettingFocusEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_GettingFocus(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_LosingFocus(&self, value: *mut super::super::foundation::TypedEventHandler<UIElement, input::LosingFocusEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LosingFocus(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_NoFocusCandidateFound(&self, value: *mut super::super::foundation::TypedEventHandler<UIElement, input::NoFocusCandidateFoundEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NoFocusCandidateFound(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn StartBringIntoView(&self) -> HRESULT,
    fn StartBringIntoViewWithOptions(&self, options: *mut BringIntoViewOptions) -> HRESULT
}}
impl IUIElement5 {
    #[inline] pub unsafe fn get_lights(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<media::XamlLight>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Lights)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_key_tip_placement_mode(&self) -> Result<input::KeyTipPlacementMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeyTipPlacementMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_key_tip_placement_mode(&self, value: input::KeyTipPlacementMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_KeyTipPlacementMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_key_tip_horizontal_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeyTipHorizontalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_key_tip_horizontal_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_KeyTipHorizontalOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_key_tip_vertical_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeyTipVerticalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_key_tip_vertical_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_KeyTipVerticalOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_keyboard_navigation(&self) -> Result<input::XYFocusKeyboardNavigationMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_XYFocusKeyboardNavigation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_xyfocus_keyboard_navigation(&self, value: input::XYFocusKeyboardNavigationMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_XYFocusKeyboardNavigation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_up_navigation_strategy(&self) -> Result<input::XYFocusNavigationStrategy> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_XYFocusUpNavigationStrategy)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_xyfocus_up_navigation_strategy(&self, value: input::XYFocusNavigationStrategy) -> Result<()> {
        let hr = ((*self.lpVtbl).put_XYFocusUpNavigationStrategy)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_down_navigation_strategy(&self) -> Result<input::XYFocusNavigationStrategy> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_XYFocusDownNavigationStrategy)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_xyfocus_down_navigation_strategy(&self, value: input::XYFocusNavigationStrategy) -> Result<()> {
        let hr = ((*self.lpVtbl).put_XYFocusDownNavigationStrategy)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_left_navigation_strategy(&self) -> Result<input::XYFocusNavigationStrategy> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_XYFocusLeftNavigationStrategy)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_xyfocus_left_navigation_strategy(&self, value: input::XYFocusNavigationStrategy) -> Result<()> {
        let hr = ((*self.lpVtbl).put_XYFocusLeftNavigationStrategy)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_right_navigation_strategy(&self) -> Result<input::XYFocusNavigationStrategy> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_XYFocusRightNavigationStrategy)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_xyfocus_right_navigation_strategy(&self, value: input::XYFocusNavigationStrategy) -> Result<()> {
        let hr = ((*self.lpVtbl).put_XYFocusRightNavigationStrategy)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_high_contrast_adjustment(&self) -> Result<ElementHighContrastAdjustment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HighContrastAdjustment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_high_contrast_adjustment(&self, value: ElementHighContrastAdjustment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HighContrastAdjustment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tab_focus_navigation(&self) -> Result<input::KeyboardNavigationMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TabFocusNavigation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_tab_focus_navigation(&self, value: input::KeyboardNavigationMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TabFocusNavigation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_getting_focus(&self, value: &super::super::foundation::TypedEventHandler<UIElement, input::GettingFocusEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_GettingFocus)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_getting_focus(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_GettingFocus)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_losing_focus(&self, value: &super::super::foundation::TypedEventHandler<UIElement, input::LosingFocusEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_LosingFocus)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_losing_focus(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_LosingFocus)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_no_focus_candidate_found(&self, value: &super::super::foundation::TypedEventHandler<UIElement, input::NoFocusCandidateFoundEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_NoFocusCandidateFound)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_no_focus_candidate_found(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_NoFocusCandidateFound)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn start_bring_into_view(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).StartBringIntoView)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn start_bring_into_view_with_options(&self, options: &BringIntoViewOptions) -> Result<()> {
        let hr = ((*self.lpVtbl).StartBringIntoViewWithOptions)(self as *const _ as *mut _, options as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class UIElement: IUIElement}
impl RtActivatable<IUIElementStatics2> for UIElement {}
impl RtActivatable<IUIElementStatics3> for UIElement {}
impl RtActivatable<IUIElementStatics5> for UIElement {}
impl RtActivatable<IUIElementStatics> for UIElement {}
impl RtActivatable<IUIElementStatics6> for UIElement {}
impl RtActivatable<IUIElementStatics4> for UIElement {}
impl UIElement {
    #[inline] pub fn get_composite_mode_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics2>>::get_activation_factory().get_composite_mode_property()
    }}
    #[inline] pub fn get_transform3_dproperty() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics3>>::get_activation_factory().get_transform3_dproperty()
    }}
    #[inline] pub fn get_can_drag_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics3>>::get_activation_factory().get_can_drag_property()
    }}
    #[inline] pub fn try_start_direct_manipulation(value: &input::Pointer) -> Result<bool> { unsafe {
        <Self as RtActivatable<IUIElementStatics3>>::get_activation_factory().try_start_direct_manipulation(value)
    }}
    #[inline] pub fn get_lights_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics5>>::get_activation_factory().get_lights_property()
    }}
    #[inline] pub fn get_key_tip_placement_mode_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics5>>::get_activation_factory().get_key_tip_placement_mode_property()
    }}
    #[inline] pub fn get_key_tip_horizontal_offset_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics5>>::get_activation_factory().get_key_tip_horizontal_offset_property()
    }}
    #[inline] pub fn get_key_tip_vertical_offset_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics5>>::get_activation_factory().get_key_tip_vertical_offset_property()
    }}
    #[inline] pub fn get_xyfocus_keyboard_navigation_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics5>>::get_activation_factory().get_xyfocus_keyboard_navigation_property()
    }}
    #[inline] pub fn get_xyfocus_up_navigation_strategy_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics5>>::get_activation_factory().get_xyfocus_up_navigation_strategy_property()
    }}
    #[inline] pub fn get_xyfocus_down_navigation_strategy_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics5>>::get_activation_factory().get_xyfocus_down_navigation_strategy_property()
    }}
    #[inline] pub fn get_xyfocus_left_navigation_strategy_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics5>>::get_activation_factory().get_xyfocus_left_navigation_strategy_property()
    }}
    #[inline] pub fn get_xyfocus_right_navigation_strategy_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics5>>::get_activation_factory().get_xyfocus_right_navigation_strategy_property()
    }}
    #[inline] pub fn get_high_contrast_adjustment_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics5>>::get_activation_factory().get_high_contrast_adjustment_property()
    }}
    #[inline] pub fn get_tab_focus_navigation_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics5>>::get_activation_factory().get_tab_focus_navigation_property()
    }}
    #[inline] pub fn get_key_down_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_key_down_event()
    }}
    #[inline] pub fn get_key_up_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_key_up_event()
    }}
    #[inline] pub fn get_pointer_entered_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_pointer_entered_event()
    }}
    #[inline] pub fn get_pointer_pressed_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_pointer_pressed_event()
    }}
    #[inline] pub fn get_pointer_moved_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_pointer_moved_event()
    }}
    #[inline] pub fn get_pointer_released_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_pointer_released_event()
    }}
    #[inline] pub fn get_pointer_exited_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_pointer_exited_event()
    }}
    #[inline] pub fn get_pointer_capture_lost_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_pointer_capture_lost_event()
    }}
    #[inline] pub fn get_pointer_canceled_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_pointer_canceled_event()
    }}
    #[inline] pub fn get_pointer_wheel_changed_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_pointer_wheel_changed_event()
    }}
    #[inline] pub fn get_tapped_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_tapped_event()
    }}
    #[inline] pub fn get_double_tapped_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_double_tapped_event()
    }}
    #[inline] pub fn get_holding_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_holding_event()
    }}
    #[inline] pub fn get_right_tapped_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_right_tapped_event()
    }}
    #[inline] pub fn get_manipulation_starting_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_manipulation_starting_event()
    }}
    #[inline] pub fn get_manipulation_inertia_starting_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_manipulation_inertia_starting_event()
    }}
    #[inline] pub fn get_manipulation_started_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_manipulation_started_event()
    }}
    #[inline] pub fn get_manipulation_delta_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_manipulation_delta_event()
    }}
    #[inline] pub fn get_manipulation_completed_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_manipulation_completed_event()
    }}
    #[inline] pub fn get_drag_enter_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_drag_enter_event()
    }}
    #[inline] pub fn get_drag_leave_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_drag_leave_event()
    }}
    #[inline] pub fn get_drag_over_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_drag_over_event()
    }}
    #[inline] pub fn get_drop_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_drop_event()
    }}
    #[inline] pub fn get_allow_drop_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_allow_drop_property()
    }}
    #[inline] pub fn get_opacity_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_opacity_property()
    }}
    #[inline] pub fn get_clip_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_clip_property()
    }}
    #[inline] pub fn get_render_transform_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_render_transform_property()
    }}
    #[inline] pub fn get_projection_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_projection_property()
    }}
    #[inline] pub fn get_render_transform_origin_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_render_transform_origin_property()
    }}
    #[inline] pub fn get_is_hit_test_visible_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_is_hit_test_visible_property()
    }}
    #[inline] pub fn get_visibility_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_visibility_property()
    }}
    #[inline] pub fn get_use_layout_rounding_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_use_layout_rounding_property()
    }}
    #[inline] pub fn get_transitions_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_transitions_property()
    }}
    #[inline] pub fn get_cache_mode_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_cache_mode_property()
    }}
    #[inline] pub fn get_is_tap_enabled_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_is_tap_enabled_property()
    }}
    #[inline] pub fn get_is_double_tap_enabled_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_is_double_tap_enabled_property()
    }}
    #[inline] pub fn get_is_right_tap_enabled_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_is_right_tap_enabled_property()
    }}
    #[inline] pub fn get_is_holding_enabled_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_is_holding_enabled_property()
    }}
    #[inline] pub fn get_manipulation_mode_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_manipulation_mode_property()
    }}
    #[inline] pub fn get_pointer_captures_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics>>::get_activation_factory().get_pointer_captures_property()
    }}
    #[inline] pub fn get_getting_focus_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics6>>::get_activation_factory().get_getting_focus_event()
    }}
    #[inline] pub fn get_losing_focus_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics6>>::get_activation_factory().get_losing_focus_event()
    }}
    #[inline] pub fn get_no_focus_candidate_found_event() -> Result<ComPtr<RoutedEvent>> { unsafe {
        <Self as RtActivatable<IUIElementStatics6>>::get_activation_factory().get_no_focus_candidate_found_event()
    }}
    #[inline] pub fn get_context_flyout_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics4>>::get_activation_factory().get_context_flyout_property()
    }}
    #[inline] pub fn get_exit_display_mode_on_access_key_invoked_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics4>>::get_activation_factory().get_exit_display_mode_on_access_key_invoked_property()
    }}
    #[inline] pub fn get_is_access_key_scope_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics4>>::get_activation_factory().get_is_access_key_scope_property()
    }}
    #[inline] pub fn get_access_key_scope_owner_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics4>>::get_activation_factory().get_access_key_scope_owner_property()
    }}
    #[inline] pub fn get_access_key_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUIElementStatics4>>::get_activation_factory().get_access_key_property()
    }}
}
DEFINE_CLSID!(UIElement(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,85,73,69,108,101,109,101,110,116,0]) [CLSID_UIElement]);
DEFINE_IID!(IID_IUIElementStatics5, 1505590673, 36771, 19557, 186, 27, 64, 223, 56, 85, 108, 187);
RT_INTERFACE!{static interface IUIElementStatics5(IUIElementStatics5Vtbl): IInspectable(IInspectableVtbl) [IID_IUIElementStatics5] {
    fn get_LightsProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_KeyTipPlacementModeProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_KeyTipHorizontalOffsetProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_KeyTipVerticalOffsetProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_XYFocusKeyboardNavigationProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_XYFocusUpNavigationStrategyProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_XYFocusDownNavigationStrategyProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_XYFocusLeftNavigationStrategyProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_XYFocusRightNavigationStrategyProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_HighContrastAdjustmentProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_TabFocusNavigationProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT
}}
impl IUIElementStatics5 {
    #[inline] pub unsafe fn get_lights_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LightsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_key_tip_placement_mode_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeyTipPlacementModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_key_tip_horizontal_offset_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeyTipHorizontalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_key_tip_vertical_offset_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeyTipVerticalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_keyboard_navigation_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusKeyboardNavigationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_up_navigation_strategy_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusUpNavigationStrategyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_down_navigation_strategy_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusDownNavigationStrategyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_left_navigation_strategy_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusLeftNavigationStrategyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_right_navigation_strategy_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusRightNavigationStrategyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_high_contrast_adjustment_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HighContrastAdjustmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tab_focus_navigation_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TabFocusNavigationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IUIElementStatics6, 1685980087, 874, 19946, 149, 64, 29, 215, 253, 18, 102, 241);
RT_INTERFACE!{static interface IUIElementStatics6(IUIElementStatics6Vtbl): IInspectable(IInspectableVtbl) [IID_IUIElementStatics6] {
    fn get_GettingFocusEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_LosingFocusEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn get_NoFocusCandidateFoundEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT
}}
impl IUIElementStatics6 {
    #[inline] pub unsafe fn get_getting_focus_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GettingFocusEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_losing_focus_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LosingFocusEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_no_focus_candidate_found_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NoFocusCandidateFoundEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVisualState, 1663086588, 49946, 17488, 175, 222, 246, 234, 123, 209, 245, 134);
RT_INTERFACE!{interface IVisualState(IVisualStateVtbl): IInspectable(IInspectableVtbl) [IID_IVisualState] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Storyboard(&self, out: *mut *mut media::animation::Storyboard) -> HRESULT,
    fn put_Storyboard(&self, value: *mut media::animation::Storyboard) -> HRESULT
}}
impl IVisualState {
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_storyboard(&self) -> Result<ComPtr<media::animation::Storyboard>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Storyboard)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_storyboard(&self, value: &media::animation::Storyboard) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Storyboard)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVisualState2, 262207638, 25792, 17915, 141, 36, 251, 131, 41, 140, 13, 147);
RT_INTERFACE!{interface IVisualState2(IVisualState2Vtbl): IInspectable(IInspectableVtbl) [IID_IVisualState2] {
    fn get_Setters(&self, out: *mut *mut SetterBaseCollection) -> HRESULT,
    fn get_StateTriggers(&self, out: *mut *mut super::super::foundation::collections::IVector<StateTriggerBase>) -> HRESULT
}}
impl IVisualState2 {
    #[inline] pub unsafe fn get_setters(&self) -> Result<ComPtr<SetterBaseCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Setters)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_state_triggers(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<StateTriggerBase>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StateTriggers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class VisualState: IVisualState}
impl RtActivatable<IActivationFactory> for VisualState {}
DEFINE_CLSID!(VisualState(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,86,105,115,117,97,108,83,116,97,116,101,0]) [CLSID_VisualState]);
DEFINE_IID!(IID_IVisualStateGroup, 3841579428, 57384, 17630, 155, 21, 73, 41, 174, 10, 38, 194);
RT_INTERFACE!{interface IVisualStateGroup(IVisualStateGroupVtbl): IInspectable(IInspectableVtbl) [IID_IVisualStateGroup] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Transitions(&self, out: *mut *mut super::super::foundation::collections::IVector<VisualTransition>) -> HRESULT,
    fn get_States(&self, out: *mut *mut super::super::foundation::collections::IVector<VisualState>) -> HRESULT,
    fn get_CurrentState(&self, out: *mut *mut VisualState) -> HRESULT,
    fn add_CurrentStateChanged(&self, value: *mut VisualStateChangedEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CurrentStateChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_CurrentStateChanging(&self, value: *mut VisualStateChangedEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CurrentStateChanging(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IVisualStateGroup {
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transitions(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<VisualTransition>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Transitions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_states(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<VisualState>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_States)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_current_state(&self) -> Result<ComPtr<VisualState>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CurrentState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_current_state_changed(&self, value: &VisualStateChangedEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CurrentStateChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_current_state_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_CurrentStateChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_current_state_changing(&self, value: &VisualStateChangedEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CurrentStateChanging)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_current_state_changing(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_CurrentStateChanging)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class VisualStateGroup: IVisualStateGroup}
impl RtActivatable<IActivationFactory> for VisualStateGroup {}
DEFINE_CLSID!(VisualStateGroup(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,86,105,115,117,97,108,83,116,97,116,101,71,114,111,117,112,0]) [CLSID_VisualStateGroup]);
DEFINE_IID!(IID_IVisualTransition, 1439010910, 11207, 16397, 170, 164, 26, 41, 129, 73, 30, 224);
RT_INTERFACE!{interface IVisualTransition(IVisualTransitionVtbl): IInspectable(IInspectableVtbl) [IID_IVisualTransition] {
    fn get_GeneratedDuration(&self, out: *mut Duration) -> HRESULT,
    fn put_GeneratedDuration(&self, value: Duration) -> HRESULT,
    fn get_GeneratedEasingFunction(&self, out: *mut *mut media::animation::EasingFunctionBase) -> HRESULT,
    fn put_GeneratedEasingFunction(&self, value: *mut media::animation::EasingFunctionBase) -> HRESULT,
    fn get_To(&self, out: *mut HSTRING) -> HRESULT,
    fn put_To(&self, value: HSTRING) -> HRESULT,
    fn get_From(&self, out: *mut HSTRING) -> HRESULT,
    fn put_From(&self, value: HSTRING) -> HRESULT,
    fn get_Storyboard(&self, out: *mut *mut media::animation::Storyboard) -> HRESULT,
    fn put_Storyboard(&self, value: *mut media::animation::Storyboard) -> HRESULT
}}
impl IVisualTransition {
    #[inline] pub unsafe fn get_generated_duration(&self) -> Result<Duration> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_GeneratedDuration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_generated_duration(&self, value: Duration) -> Result<()> {
        let hr = ((*self.lpVtbl).put_GeneratedDuration)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_generated_easing_function(&self) -> Result<ComPtr<media::animation::EasingFunctionBase>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GeneratedEasingFunction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_generated_easing_function(&self, value: &media::animation::EasingFunctionBase) -> Result<()> {
        let hr = ((*self.lpVtbl).put_GeneratedEasingFunction)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_to(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_To)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_to(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_To)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_from(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_From)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_from(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_From)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_storyboard(&self) -> Result<ComPtr<media::animation::Storyboard>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Storyboard)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_storyboard(&self, value: &media::animation::Storyboard) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Storyboard)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class VisualTransition: IVisualTransition}
DEFINE_IID!(IID_IVisualTransitionFactory, 3933570639, 53728, 19886, 180, 41, 137, 252, 50, 39, 36, 244);
RT_INTERFACE!{interface IVisualTransitionFactory(IVisualTransitionFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IVisualTransitionFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut VisualTransition) -> HRESULT
}}
impl IVisualTransitionFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<VisualTransition>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAdaptiveTrigger, 2783985945, 3289, 18929, 162, 63, 68, 229, 71, 171, 159, 26);
RT_INTERFACE!{interface IAdaptiveTrigger(IAdaptiveTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IAdaptiveTrigger] {
    fn get_MinWindowWidth(&self, out: *mut f64) -> HRESULT,
    fn put_MinWindowWidth(&self, value: f64) -> HRESULT,
    fn get_MinWindowHeight(&self, out: *mut f64) -> HRESULT,
    fn put_MinWindowHeight(&self, value: f64) -> HRESULT
}}
impl IAdaptiveTrigger {
    #[inline] pub unsafe fn get_min_window_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinWindowWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_min_window_width(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MinWindowWidth)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_window_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinWindowHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_min_window_height(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MinWindowHeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAdaptiveTriggerStatics, 3106810346, 5653, 17232, 156, 59, 146, 178, 152, 107, 244, 68);
RT_INTERFACE!{static interface IAdaptiveTriggerStatics(IAdaptiveTriggerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAdaptiveTriggerStatics] {
    fn get_MinWindowWidthProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_MinWindowHeightProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT
}}
impl IAdaptiveTriggerStatics {
    #[inline] pub unsafe fn get_min_window_width_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MinWindowWidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_window_height_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MinWindowHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAdaptiveTriggerFactory, 3378959490, 23275, 18497, 146, 71, 193, 160, 189, 214, 245, 159);
RT_INTERFACE!{interface IAdaptiveTriggerFactory(IAdaptiveTriggerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAdaptiveTriggerFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut AdaptiveTrigger) -> HRESULT
}}
impl IAdaptiveTriggerFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<AdaptiveTrigger>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class AdaptiveTrigger: IAdaptiveTrigger}
impl RtActivatable<IAdaptiveTriggerStatics> for AdaptiveTrigger {}
impl AdaptiveTrigger {
    #[inline] pub fn get_min_window_width_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAdaptiveTriggerStatics>>::get_activation_factory().get_min_window_width_property()
    }}
    #[inline] pub fn get_min_window_height_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAdaptiveTriggerStatics>>::get_activation_factory().get_min_window_height_property()
    }}
}
DEFINE_CLSID!(AdaptiveTrigger(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,100,97,112,116,105,118,101,84,114,105,103,103,101,114,0]) [CLSID_AdaptiveTrigger]);
DEFINE_IID!(IID_IEventTrigger, 3740858453, 2889, 16519, 177, 169, 184, 179, 132, 136, 247, 134);
RT_INTERFACE!{interface IEventTrigger(IEventTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IEventTrigger] {
    fn get_RoutedEvent(&self, out: *mut *mut RoutedEvent) -> HRESULT,
    fn put_RoutedEvent(&self, value: *mut RoutedEvent) -> HRESULT,
    fn get_Actions(&self, out: *mut *mut TriggerActionCollection) -> HRESULT
}}
impl IEventTrigger {
    #[inline] pub unsafe fn get_routed_event(&self) -> Result<ComPtr<RoutedEvent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RoutedEvent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_routed_event(&self, value: &RoutedEvent) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RoutedEvent)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_actions(&self) -> Result<ComPtr<TriggerActionCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Actions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EventTrigger: IEventTrigger}
impl RtActivatable<IActivationFactory> for EventTrigger {}
DEFINE_CLSID!(EventTrigger(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,69,118,101,110,116,84,114,105,103,103,101,114,0]) [CLSID_EventTrigger]);
DEFINE_IID!(IID_IFrameworkElement, 2744242331, 19097, 19324, 157, 141, 111, 165, 208, 31, 111, 191);
RT_INTERFACE!{interface IFrameworkElement(IFrameworkElementVtbl): IInspectable(IInspectableVtbl) [IID_IFrameworkElement] {
    fn get_Triggers(&self, out: *mut *mut TriggerCollection) -> HRESULT,
    fn get_Resources(&self, out: *mut *mut ResourceDictionary) -> HRESULT,
    fn put_Resources(&self, value: *mut ResourceDictionary) -> HRESULT,
    fn get_Tag(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Tag(&self, value: *mut IInspectable) -> HRESULT,
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Language(&self, value: HSTRING) -> HRESULT,
    fn get_ActualWidth(&self, out: *mut f64) -> HRESULT,
    fn get_ActualHeight(&self, out: *mut f64) -> HRESULT,
    fn get_Width(&self, out: *mut f64) -> HRESULT,
    fn put_Width(&self, value: f64) -> HRESULT,
    fn get_Height(&self, out: *mut f64) -> HRESULT,
    fn put_Height(&self, value: f64) -> HRESULT,
    fn get_MinWidth(&self, out: *mut f64) -> HRESULT,
    fn put_MinWidth(&self, value: f64) -> HRESULT,
    fn get_MaxWidth(&self, out: *mut f64) -> HRESULT,
    fn put_MaxWidth(&self, value: f64) -> HRESULT,
    fn get_MinHeight(&self, out: *mut f64) -> HRESULT,
    fn put_MinHeight(&self, value: f64) -> HRESULT,
    fn get_MaxHeight(&self, out: *mut f64) -> HRESULT,
    fn put_MaxHeight(&self, value: f64) -> HRESULT,
    fn get_HorizontalAlignment(&self, out: *mut HorizontalAlignment) -> HRESULT,
    fn put_HorizontalAlignment(&self, value: HorizontalAlignment) -> HRESULT,
    fn get_VerticalAlignment(&self, out: *mut VerticalAlignment) -> HRESULT,
    fn put_VerticalAlignment(&self, value: VerticalAlignment) -> HRESULT,
    fn get_Margin(&self, out: *mut Thickness) -> HRESULT,
    fn put_Margin(&self, value: Thickness) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT,
    fn get_BaseUri(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn get_DataContext(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_DataContext(&self, value: *mut IInspectable) -> HRESULT,
    fn get_Style(&self, out: *mut *mut Style) -> HRESULT,
    fn put_Style(&self, value: *mut Style) -> HRESULT,
    fn get_Parent(&self, out: *mut *mut DependencyObject) -> HRESULT,
    fn get_FlowDirection(&self, out: *mut FlowDirection) -> HRESULT,
    fn put_FlowDirection(&self, value: FlowDirection) -> HRESULT,
    fn add_Loaded(&self, value: *mut RoutedEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Loaded(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Unloaded(&self, value: *mut RoutedEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Unloaded(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_SizeChanged(&self, value: *mut SizeChangedEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SizeChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_LayoutUpdated(&self, value: *mut super::super::foundation::EventHandler<IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LayoutUpdated(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn FindName(&self, name: HSTRING, out: *mut *mut IInspectable) -> HRESULT,
    fn SetBinding(&self, dp: *mut DependencyProperty, binding: *mut data::BindingBase) -> HRESULT
}}
impl IFrameworkElement {
    #[inline] pub unsafe fn get_triggers(&self) -> Result<ComPtr<TriggerCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Triggers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_resources(&self) -> Result<ComPtr<ResourceDictionary>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Resources)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_resources(&self, value: &ResourceDictionary) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Resources)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tag(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Tag)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_tag(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Tag)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_language(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Language)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_language(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Language)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_actual_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ActualWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_actual_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ActualHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Width)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_width(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Width)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Height)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_height(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Height)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_min_width(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MinWidth)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_width(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxWidth)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_min_height(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MinHeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_height(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxHeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_alignment(&self) -> Result<HorizontalAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_horizontal_alignment(&self, value: HorizontalAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HorizontalAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_alignment(&self) -> Result<VerticalAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_vertical_alignment(&self, value: VerticalAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_VerticalAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_margin(&self) -> Result<Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Margin)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_margin(&self, value: Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Margin)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Name)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_base_uri(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BaseUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_data_context(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DataContext)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_data_context(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DataContext)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_style(&self) -> Result<ComPtr<Style>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Style)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_style(&self, value: &Style) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Style)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_parent(&self) -> Result<ComPtr<DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Parent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_flow_direction(&self) -> Result<FlowDirection> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FlowDirection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_flow_direction(&self, value: FlowDirection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FlowDirection)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_loaded(&self, value: &RoutedEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Loaded)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_loaded(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Loaded)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_unloaded(&self, value: &RoutedEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Unloaded)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_unloaded(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Unloaded)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_size_changed(&self, value: &SizeChangedEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SizeChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_size_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SizeChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_layout_updated(&self, value: &super::super::foundation::EventHandler<IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_LayoutUpdated)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_layout_updated(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_LayoutUpdated)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_name(&self, name: &HStringArg) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindName)(self as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_binding(&self, dp: &DependencyProperty, binding: &data::BindingBase) -> Result<()> {
        let hr = ((*self.lpVtbl).SetBinding)(self as *const _ as *mut _, dp as *const _ as *mut _, binding as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFrameworkElementOverrides, 3657465428, 46018, 19354, 170, 142, 211, 240, 113, 38, 43, 151);
RT_INTERFACE!{interface IFrameworkElementOverrides(IFrameworkElementOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IFrameworkElementOverrides] {
    fn MeasureOverride(&self, availableSize: super::super::foundation::Size, out: *mut super::super::foundation::Size) -> HRESULT,
    fn ArrangeOverride(&self, finalSize: super::super::foundation::Size, out: *mut super::super::foundation::Size) -> HRESULT,
    fn OnApplyTemplate(&self) -> HRESULT
}}
impl IFrameworkElementOverrides {
    #[inline] pub unsafe fn measure_override(&self, availableSize: super::super::foundation::Size) -> Result<super::super::foundation::Size> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).MeasureOverride)(self as *const _ as *mut _, availableSize, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn arrange_override(&self, finalSize: super::super::foundation::Size) -> Result<super::super::foundation::Size> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).ArrangeOverride)(self as *const _ as *mut _, finalSize, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_apply_template(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).OnApplyTemplate)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFrameworkElementStatics, 1211641906, 64491, 20362, 174, 210, 238, 33, 251, 39, 165, 123);
RT_INTERFACE!{static interface IFrameworkElementStatics(IFrameworkElementStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IFrameworkElementStatics] {
    fn get_TagProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_LanguageProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_ActualWidthProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_ActualHeightProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_WidthProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_HeightProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_MinWidthProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_MaxWidthProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_MinHeightProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_MaxHeightProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_HorizontalAlignmentProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_VerticalAlignmentProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_MarginProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_NameProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_DataContextProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_StyleProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_FlowDirectionProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT
}}
impl IFrameworkElementStatics {
    #[inline] pub unsafe fn get_tag_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TagProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_language_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LanguageProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_actual_width_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ActualWidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_actual_height_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ActualHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_width_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_WidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_height_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_width_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MinWidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_width_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxWidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_height_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MinHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_height_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_alignment_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HorizontalAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_alignment_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VerticalAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_margin_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MarginProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_name_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_data_context_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DataContextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_style_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_flow_direction_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FlowDirectionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFrameworkElementFactory, 3736002854, 970, 18790, 181, 118, 96, 76, 206, 147, 181, 232);
RT_INTERFACE!{interface IFrameworkElementFactory(IFrameworkElementFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IFrameworkElementFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut FrameworkElement) -> HRESULT
}}
impl IFrameworkElementFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<FrameworkElement>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFrameworkElement2, 4052812990, 16938, 18692, 165, 47, 238, 114, 1, 4, 41, 229);
RT_INTERFACE!{interface IFrameworkElement2(IFrameworkElement2Vtbl): IInspectable(IInspectableVtbl) [IID_IFrameworkElement2] {
    fn get_RequestedTheme(&self, out: *mut ElementTheme) -> HRESULT,
    fn put_RequestedTheme(&self, value: ElementTheme) -> HRESULT,
    fn add_DataContextChanged(&self, value: *mut super::super::foundation::TypedEventHandler<FrameworkElement, DataContextChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DataContextChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn GetBindingExpression(&self, dp: *mut DependencyProperty, out: *mut *mut data::BindingExpression) -> HRESULT
}}
impl IFrameworkElement2 {
    #[inline] pub unsafe fn get_requested_theme(&self) -> Result<ElementTheme> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RequestedTheme)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_requested_theme(&self, value: ElementTheme) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RequestedTheme)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_data_context_changed(&self, value: &super::super::foundation::TypedEventHandler<FrameworkElement, DataContextChangedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DataContextChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_data_context_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DataContextChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_binding_expression(&self, dp: &DependencyProperty) -> Result<ComPtr<data::BindingExpression>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetBindingExpression)(self as *const _ as *mut _, dp as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFrameworkElementOverrides2, 3411858105, 58292, 17804, 182, 78, 20, 52, 253, 27, 216, 138);
RT_INTERFACE!{interface IFrameworkElementOverrides2(IFrameworkElementOverrides2Vtbl): IInspectable(IInspectableVtbl) [IID_IFrameworkElementOverrides2] {
    fn GoToElementStateCore(&self, stateName: HSTRING, useTransitions: bool, out: *mut bool) -> HRESULT
}}
impl IFrameworkElementOverrides2 {
    #[inline] pub unsafe fn go_to_element_state_core(&self, stateName: &HStringArg, useTransitions: bool) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GoToElementStateCore)(self as *const _ as *mut _, stateName.get(), useTransitions, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFrameworkElementStatics2, 2526403330, 49368, 20386, 177, 0, 63, 162, 223, 139, 149, 56);
RT_INTERFACE!{static interface IFrameworkElementStatics2(IFrameworkElementStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IFrameworkElementStatics2] {
    fn get_RequestedThemeProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT
}}
impl IFrameworkElementStatics2 {
    #[inline] pub unsafe fn get_requested_theme_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RequestedThemeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFrameworkElement3, 3357288224, 23634, 19390, 161, 153, 43, 30, 52, 240, 15, 112);
RT_INTERFACE!{interface IFrameworkElement3(IFrameworkElement3Vtbl): IInspectable(IInspectableVtbl) [IID_IFrameworkElement3] {
    fn add_Loading(&self, value: *mut super::super::foundation::TypedEventHandler<FrameworkElement, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Loading(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IFrameworkElement3 {
    #[inline] pub unsafe fn add_loading(&self, value: &super::super::foundation::TypedEventHandler<FrameworkElement, IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Loading)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_loading(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Loading)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFrameworkElement4, 1802918835, 64419, 17412, 189, 238, 26, 69, 209, 202, 95, 33);
RT_INTERFACE!{interface IFrameworkElement4(IFrameworkElement4Vtbl): IInspectable(IInspectableVtbl) [IID_IFrameworkElement4] {
    fn get_AllowFocusOnInteraction(&self, out: *mut bool) -> HRESULT,
    fn put_AllowFocusOnInteraction(&self, value: bool) -> HRESULT,
    fn get_FocusVisualMargin(&self, out: *mut Thickness) -> HRESULT,
    fn put_FocusVisualMargin(&self, value: Thickness) -> HRESULT,
    fn get_FocusVisualSecondaryThickness(&self, out: *mut Thickness) -> HRESULT,
    fn put_FocusVisualSecondaryThickness(&self, value: Thickness) -> HRESULT,
    fn get_FocusVisualPrimaryThickness(&self, out: *mut Thickness) -> HRESULT,
    fn put_FocusVisualPrimaryThickness(&self, value: Thickness) -> HRESULT,
    fn get_FocusVisualSecondaryBrush(&self, out: *mut *mut media::Brush) -> HRESULT,
    fn put_FocusVisualSecondaryBrush(&self, value: *mut media::Brush) -> HRESULT,
    fn get_FocusVisualPrimaryBrush(&self, out: *mut *mut media::Brush) -> HRESULT,
    fn put_FocusVisualPrimaryBrush(&self, value: *mut media::Brush) -> HRESULT,
    fn get_AllowFocusWhenDisabled(&self, out: *mut bool) -> HRESULT,
    fn put_AllowFocusWhenDisabled(&self, value: bool) -> HRESULT
}}
impl IFrameworkElement4 {
    #[inline] pub unsafe fn get_allow_focus_on_interaction(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AllowFocusOnInteraction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_allow_focus_on_interaction(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AllowFocusOnInteraction)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_visual_margin(&self) -> Result<Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FocusVisualMargin)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_focus_visual_margin(&self, value: Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FocusVisualMargin)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_visual_secondary_thickness(&self) -> Result<Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FocusVisualSecondaryThickness)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_focus_visual_secondary_thickness(&self, value: Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FocusVisualSecondaryThickness)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_visual_primary_thickness(&self) -> Result<Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FocusVisualPrimaryThickness)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_focus_visual_primary_thickness(&self, value: Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FocusVisualPrimaryThickness)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_visual_secondary_brush(&self) -> Result<ComPtr<media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FocusVisualSecondaryBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_focus_visual_secondary_brush(&self, value: &media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FocusVisualSecondaryBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_visual_primary_brush(&self) -> Result<ComPtr<media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FocusVisualPrimaryBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_focus_visual_primary_brush(&self, value: &media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FocusVisualPrimaryBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_allow_focus_when_disabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AllowFocusWhenDisabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_allow_focus_when_disabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AllowFocusWhenDisabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class FrameworkElement: IFrameworkElement}
impl RtActivatable<IFrameworkElementStatics4> for FrameworkElement {}
impl RtActivatable<IFrameworkElementStatics5> for FrameworkElement {}
impl RtActivatable<IFrameworkElementStatics> for FrameworkElement {}
impl RtActivatable<IFrameworkElementStatics2> for FrameworkElement {}
impl FrameworkElement {
    #[inline] pub fn get_allow_focus_on_interaction_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics4>>::get_activation_factory().get_allow_focus_on_interaction_property()
    }}
    #[inline] pub fn get_focus_visual_margin_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics4>>::get_activation_factory().get_focus_visual_margin_property()
    }}
    #[inline] pub fn get_focus_visual_secondary_thickness_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics4>>::get_activation_factory().get_focus_visual_secondary_thickness_property()
    }}
    #[inline] pub fn get_focus_visual_primary_thickness_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics4>>::get_activation_factory().get_focus_visual_primary_thickness_property()
    }}
    #[inline] pub fn get_focus_visual_secondary_brush_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics4>>::get_activation_factory().get_focus_visual_secondary_brush_property()
    }}
    #[inline] pub fn get_focus_visual_primary_brush_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics4>>::get_activation_factory().get_focus_visual_primary_brush_property()
    }}
    #[inline] pub fn get_allow_focus_when_disabled_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics4>>::get_activation_factory().get_allow_focus_when_disabled_property()
    }}
    #[inline] pub fn defer_tree(element: &DependencyObject) -> Result<()> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics5>>::get_activation_factory().defer_tree(element)
    }}
    #[inline] pub fn get_tag_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics>>::get_activation_factory().get_tag_property()
    }}
    #[inline] pub fn get_language_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics>>::get_activation_factory().get_language_property()
    }}
    #[inline] pub fn get_actual_width_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics>>::get_activation_factory().get_actual_width_property()
    }}
    #[inline] pub fn get_actual_height_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics>>::get_activation_factory().get_actual_height_property()
    }}
    #[inline] pub fn get_width_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics>>::get_activation_factory().get_width_property()
    }}
    #[inline] pub fn get_height_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics>>::get_activation_factory().get_height_property()
    }}
    #[inline] pub fn get_min_width_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics>>::get_activation_factory().get_min_width_property()
    }}
    #[inline] pub fn get_max_width_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics>>::get_activation_factory().get_max_width_property()
    }}
    #[inline] pub fn get_min_height_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics>>::get_activation_factory().get_min_height_property()
    }}
    #[inline] pub fn get_max_height_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics>>::get_activation_factory().get_max_height_property()
    }}
    #[inline] pub fn get_horizontal_alignment_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics>>::get_activation_factory().get_horizontal_alignment_property()
    }}
    #[inline] pub fn get_vertical_alignment_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics>>::get_activation_factory().get_vertical_alignment_property()
    }}
    #[inline] pub fn get_margin_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics>>::get_activation_factory().get_margin_property()
    }}
    #[inline] pub fn get_name_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics>>::get_activation_factory().get_name_property()
    }}
    #[inline] pub fn get_data_context_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics>>::get_activation_factory().get_data_context_property()
    }}
    #[inline] pub fn get_style_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics>>::get_activation_factory().get_style_property()
    }}
    #[inline] pub fn get_flow_direction_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics>>::get_activation_factory().get_flow_direction_property()
    }}
    #[inline] pub fn get_requested_theme_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameworkElementStatics2>>::get_activation_factory().get_requested_theme_property()
    }}
}
DEFINE_CLSID!(FrameworkElement(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,70,114,97,109,101,119,111,114,107,69,108,101,109,101,110,116,0]) [CLSID_FrameworkElement]);
DEFINE_IID!(IID_IFrameworkElementStatics4, 2621550933, 50648, 18019, 191, 242, 216, 213, 79, 181, 219, 179);
RT_INTERFACE!{static interface IFrameworkElementStatics4(IFrameworkElementStatics4Vtbl): IInspectable(IInspectableVtbl) [IID_IFrameworkElementStatics4] {
    fn get_AllowFocusOnInteractionProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_FocusVisualMarginProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_FocusVisualSecondaryThicknessProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_FocusVisualPrimaryThicknessProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_FocusVisualSecondaryBrushProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_FocusVisualPrimaryBrushProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn get_AllowFocusWhenDisabledProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT
}}
impl IFrameworkElementStatics4 {
    #[inline] pub unsafe fn get_allow_focus_on_interaction_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AllowFocusOnInteractionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_visual_margin_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FocusVisualMarginProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_visual_secondary_thickness_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FocusVisualSecondaryThicknessProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_visual_primary_thickness_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FocusVisualPrimaryThicknessProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_visual_secondary_brush_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FocusVisualSecondaryBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_visual_primary_brush_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FocusVisualPrimaryBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_allow_focus_when_disabled_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AllowFocusWhenDisabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFrameworkElementStatics5, 1381841217, 2876, 19430, 153, 120, 25, 168, 2, 92, 9, 216);
RT_INTERFACE!{static interface IFrameworkElementStatics5(IFrameworkElementStatics5Vtbl): IInspectable(IInspectableVtbl) [IID_IFrameworkElementStatics5] {
    fn DeferTree(&self, element: *mut DependencyObject) -> HRESULT
}}
impl IFrameworkElementStatics5 {
    #[inline] pub unsafe fn defer_tree(&self, element: &DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).DeferTree)(self as *const _ as *mut _, element as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMediaFailedRoutedEventArgs, 1188166285, 20809, 16723, 186, 60, 176, 62, 100, 238, 83, 30);
RT_INTERFACE!{interface IMediaFailedRoutedEventArgs(IMediaFailedRoutedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMediaFailedRoutedEventArgs] {
    fn get_ErrorTrace(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMediaFailedRoutedEventArgs {
    #[inline] pub unsafe fn get_error_trace(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ErrorTrace)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class MediaFailedRoutedEventArgs: IMediaFailedRoutedEventArgs}
DEFINE_IID!(IID_ISetter, 2805853481, 46254, 19073, 190, 133, 230, 144, 186, 13, 59, 110);
RT_INTERFACE!{interface ISetter(ISetterVtbl): IInspectable(IInspectableVtbl) [IID_ISetter] {
    fn get_Property(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn put_Property(&self, value: *mut DependencyProperty) -> HRESULT,
    fn get_Value(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Value(&self, value: *mut IInspectable) -> HRESULT
}}
impl ISetter {
    #[inline] pub unsafe fn get_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_property(&self, value: &DependencyProperty) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Property)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_value(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Value)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_value(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Value)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISetterFactory, 3553246530, 2481, 18901, 136, 145, 231, 181, 100, 142, 2, 162);
RT_INTERFACE!{static interface ISetterFactory(ISetterFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISetterFactory] {
    fn CreateInstance(&self, targetProperty: *mut DependencyProperty, value: *mut IInspectable, out: *mut *mut Setter) -> HRESULT
}}
impl ISetterFactory {
    #[inline] pub unsafe fn create_instance(&self, targetProperty: &DependencyProperty, value: &IInspectable) -> Result<ComPtr<Setter>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, targetProperty as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISetter2, 1880528225, 1457, 20387, 157, 83, 142, 12, 140, 116, 122, 252);
RT_INTERFACE!{interface ISetter2(ISetter2Vtbl): IInspectable(IInspectableVtbl) [IID_ISetter2] {
    fn get_Target(&self, out: *mut *mut TargetPropertyPath) -> HRESULT,
    fn put_Target(&self, value: *mut TargetPropertyPath) -> HRESULT
}}
impl ISetter2 {
    #[inline] pub unsafe fn get_target(&self) -> Result<ComPtr<TargetPropertyPath>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Target)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target(&self, value: &TargetPropertyPath) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Target)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class Setter: ISetter}
impl RtActivatable<ISetterFactory> for Setter {}
impl RtActivatable<IActivationFactory> for Setter {}
impl Setter {
    #[inline] pub fn create_instance(targetProperty: &DependencyProperty, value: &IInspectable) -> Result<ComPtr<Setter>> { unsafe {
        <Self as RtActivatable<ISetterFactory>>::get_activation_factory().create_instance(targetProperty, value)
    }}
}
DEFINE_CLSID!(Setter(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,83,101,116,116,101,114,0]) [CLSID_Setter]);
DEFINE_IID!(IID_IStateTrigger, 1739452206, 55513, 18935, 161, 253, 46, 53, 238, 221, 35, 205);
RT_INTERFACE!{interface IStateTrigger(IStateTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IStateTrigger] {
    fn get_IsActive(&self, out: *mut bool) -> HRESULT,
    fn put_IsActive(&self, value: bool) -> HRESULT
}}
impl IStateTrigger {
    #[inline] pub unsafe fn get_is_active(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsActive)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_active(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsActive)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IStateTriggerStatics, 1911118992, 46078, 19923, 168, 168, 68, 162, 206, 37, 224, 184);
RT_INTERFACE!{static interface IStateTriggerStatics(IStateTriggerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IStateTriggerStatics] {
    fn get_IsActiveProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT
}}
impl IStateTriggerStatics {
    #[inline] pub unsafe fn get_is_active_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsActiveProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class StateTrigger: IStateTrigger}
impl RtActivatable<IStateTriggerStatics> for StateTrigger {}
impl RtActivatable<IActivationFactory> for StateTrigger {}
impl StateTrigger {
    #[inline] pub fn get_is_active_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IStateTriggerStatics>>::get_activation_factory().get_is_active_property()
    }}
}
DEFINE_CLSID!(StateTrigger(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,83,116,97,116,101,84,114,105,103,103,101,114,0]) [CLSID_StateTrigger]);
RT_ENUM! { enum ApplicationHighContrastAdjustment: u32 {
    None (ApplicationHighContrastAdjustment_None) = 0, Auto (ApplicationHighContrastAdjustment_Auto) = 4294967295,
}}
RT_ENUM! { enum ApplicationRequiresPointerMode: i32 {
    Auto (ApplicationRequiresPointerMode_Auto) = 0, WhenRequested (ApplicationRequiresPointerMode_WhenRequested) = 1,
}}
RT_ENUM! { enum ApplicationTheme: i32 {
    Light (ApplicationTheme_Light) = 0, Dark (ApplicationTheme_Dark) = 1,
}}
RT_ENUM! { enum AutomationTextAttributesEnum: i32 {
    AnimationStyleAttribute (AutomationTextAttributesEnum_AnimationStyleAttribute) = 40000, BackgroundColorAttribute (AutomationTextAttributesEnum_BackgroundColorAttribute) = 40001, BulletStyleAttribute (AutomationTextAttributesEnum_BulletStyleAttribute) = 40002, CapStyleAttribute (AutomationTextAttributesEnum_CapStyleAttribute) = 40003, CultureAttribute (AutomationTextAttributesEnum_CultureAttribute) = 40004, FontNameAttribute (AutomationTextAttributesEnum_FontNameAttribute) = 40005, FontSizeAttribute (AutomationTextAttributesEnum_FontSizeAttribute) = 40006, FontWeightAttribute (AutomationTextAttributesEnum_FontWeightAttribute) = 40007, ForegroundColorAttribute (AutomationTextAttributesEnum_ForegroundColorAttribute) = 40008, HorizontalTextAlignmentAttribute (AutomationTextAttributesEnum_HorizontalTextAlignmentAttribute) = 40009, IndentationFirstLineAttribute (AutomationTextAttributesEnum_IndentationFirstLineAttribute) = 40010, IndentationLeadingAttribute (AutomationTextAttributesEnum_IndentationLeadingAttribute) = 40011, IndentationTrailingAttribute (AutomationTextAttributesEnum_IndentationTrailingAttribute) = 40012, IsHiddenAttribute (AutomationTextAttributesEnum_IsHiddenAttribute) = 40013, IsItalicAttribute (AutomationTextAttributesEnum_IsItalicAttribute) = 40014, IsReadOnlyAttribute (AutomationTextAttributesEnum_IsReadOnlyAttribute) = 40015, IsSubscriptAttribute (AutomationTextAttributesEnum_IsSubscriptAttribute) = 40016, IsSuperscriptAttribute (AutomationTextAttributesEnum_IsSuperscriptAttribute) = 40017, MarginBottomAttribute (AutomationTextAttributesEnum_MarginBottomAttribute) = 40018, MarginLeadingAttribute (AutomationTextAttributesEnum_MarginLeadingAttribute) = 40019, MarginTopAttribute (AutomationTextAttributesEnum_MarginTopAttribute) = 40020, MarginTrailingAttribute (AutomationTextAttributesEnum_MarginTrailingAttribute) = 40021, OutlineStylesAttribute (AutomationTextAttributesEnum_OutlineStylesAttribute) = 40022, OverlineColorAttribute (AutomationTextAttributesEnum_OverlineColorAttribute) = 40023, OverlineStyleAttribute (AutomationTextAttributesEnum_OverlineStyleAttribute) = 40024, StrikethroughColorAttribute (AutomationTextAttributesEnum_StrikethroughColorAttribute) = 40025, StrikethroughStyleAttribute (AutomationTextAttributesEnum_StrikethroughStyleAttribute) = 40026, TabsAttribute (AutomationTextAttributesEnum_TabsAttribute) = 40027, TextFlowDirectionsAttribute (AutomationTextAttributesEnum_TextFlowDirectionsAttribute) = 40028, UnderlineColorAttribute (AutomationTextAttributesEnum_UnderlineColorAttribute) = 40029, UnderlineStyleAttribute (AutomationTextAttributesEnum_UnderlineStyleAttribute) = 40030, AnnotationTypesAttribute (AutomationTextAttributesEnum_AnnotationTypesAttribute) = 40031, AnnotationObjectsAttribute (AutomationTextAttributesEnum_AnnotationObjectsAttribute) = 40032, StyleNameAttribute (AutomationTextAttributesEnum_StyleNameAttribute) = 40033, StyleIdAttribute (AutomationTextAttributesEnum_StyleIdAttribute) = 40034, LinkAttribute (AutomationTextAttributesEnum_LinkAttribute) = 40035, IsActiveAttribute (AutomationTextAttributesEnum_IsActiveAttribute) = 40036, SelectionActiveEndAttribute (AutomationTextAttributesEnum_SelectionActiveEndAttribute) = 40037, CaretPositionAttribute (AutomationTextAttributesEnum_CaretPositionAttribute) = 40038, CaretBidiModeAttribute (AutomationTextAttributesEnum_CaretBidiModeAttribute) = 40039,
}}
RT_ENUM! { enum ElementSoundPlayerState: i32 {
    Auto (ElementSoundPlayerState_Auto) = 0, Off (ElementSoundPlayerState_Off) = 1, On (ElementSoundPlayerState_On) = 2,
}}
RT_ENUM! { enum FontCapitals: i32 {
    Normal (FontCapitals_Normal) = 0, AllSmallCaps (FontCapitals_AllSmallCaps) = 1, SmallCaps (FontCapitals_SmallCaps) = 2, AllPetiteCaps (FontCapitals_AllPetiteCaps) = 3, PetiteCaps (FontCapitals_PetiteCaps) = 4, Unicase (FontCapitals_Unicase) = 5, Titling (FontCapitals_Titling) = 6,
}}
RT_ENUM! { enum FontEastAsianLanguage: i32 {
    Normal (FontEastAsianLanguage_Normal) = 0, HojoKanji (FontEastAsianLanguage_HojoKanji) = 1, Jis04 (FontEastAsianLanguage_Jis04) = 2, Jis78 (FontEastAsianLanguage_Jis78) = 3, Jis83 (FontEastAsianLanguage_Jis83) = 4, Jis90 (FontEastAsianLanguage_Jis90) = 5, NlcKanji (FontEastAsianLanguage_NlcKanji) = 6, Simplified (FontEastAsianLanguage_Simplified) = 7, Traditional (FontEastAsianLanguage_Traditional) = 8, TraditionalNames (FontEastAsianLanguage_TraditionalNames) = 9,
}}
RT_ENUM! { enum FontEastAsianWidths: i32 {
    Normal (FontEastAsianWidths_Normal) = 0, Full (FontEastAsianWidths_Full) = 1, Half (FontEastAsianWidths_Half) = 2, Proportional (FontEastAsianWidths_Proportional) = 3, Quarter (FontEastAsianWidths_Quarter) = 4, Third (FontEastAsianWidths_Third) = 5,
}}
RT_ENUM! { enum FontFraction: i32 {
    Normal (FontFraction_Normal) = 0, Stacked (FontFraction_Stacked) = 1, Slashed (FontFraction_Slashed) = 2,
}}
RT_ENUM! { enum FontNumeralAlignment: i32 {
    Normal (FontNumeralAlignment_Normal) = 0, Proportional (FontNumeralAlignment_Proportional) = 1, Tabular (FontNumeralAlignment_Tabular) = 2,
}}
RT_ENUM! { enum FontNumeralStyle: i32 {
    Normal (FontNumeralStyle_Normal) = 0, Lining (FontNumeralStyle_Lining) = 1, OldStyle (FontNumeralStyle_OldStyle) = 2,
}}
RT_ENUM! { enum FontVariants: i32 {
    Normal (FontVariants_Normal) = 0, Superscript (FontVariants_Superscript) = 1, Subscript (FontVariants_Subscript) = 2, Ordinal (FontVariants_Ordinal) = 3, Inferior (FontVariants_Inferior) = 4, Ruby (FontVariants_Ruby) = 5,
}}
RT_ENUM! { enum GridUnitType: i32 {
    Auto (GridUnitType_Auto) = 0, Pixel (GridUnitType_Pixel) = 1, Star (GridUnitType_Star) = 2,
}}
RT_ENUM! { enum LineStackingStrategy: i32 {
    MaxHeight (LineStackingStrategy_MaxHeight) = 0, BlockLineHeight (LineStackingStrategy_BlockLineHeight) = 1, BaselineToBaseline (LineStackingStrategy_BaselineToBaseline) = 2,
}}
RT_ENUM! { enum OpticalMarginAlignment: i32 {
    None (OpticalMarginAlignment_None) = 0, TrimSideBearings (OpticalMarginAlignment_TrimSideBearings) = 1,
}}
RT_ENUM! { enum TextAlignment: i32 {
    Center (TextAlignment_Center) = 0, Left (TextAlignment_Left) = 1, Right (TextAlignment_Right) = 2, Justify (TextAlignment_Justify) = 3, DetectFromContent (TextAlignment_DetectFromContent) = 4,
}}
RT_ENUM! { enum TextLineBounds: i32 {
    Full (TextLineBounds_Full) = 0, TrimToCapHeight (TextLineBounds_TrimToCapHeight) = 1, TrimToBaseline (TextLineBounds_TrimToBaseline) = 2, Tight (TextLineBounds_Tight) = 3,
}}
RT_ENUM! { enum TextReadingOrder: i32 {
    Default (TextReadingOrder_Default) = 0, UseFlowDirection (TextReadingOrder_UseFlowDirection) = 0, DetectFromContent (TextReadingOrder_DetectFromContent) = 1,
}}
RT_ENUM! { enum TextTrimming: i32 {
    None (TextTrimming_None) = 0, CharacterEllipsis (TextTrimming_CharacterEllipsis) = 1, WordEllipsis (TextTrimming_WordEllipsis) = 2, Clip (TextTrimming_Clip) = 3,
}}
RT_ENUM! { enum TextWrapping: i32 {
    NoWrap (TextWrapping_NoWrap) = 1, Wrap (TextWrapping_Wrap) = 2, WrapWholeWords (TextWrapping_WrapWholeWords) = 3,
}}
RT_STRUCT! { struct GridLength {
    Value: f64, GridUnitType: GridUnitType,
}}
DEFINE_IID!(IID_IGridLengthHelper, 2055367905, 1952, 16515, 182, 209, 177, 217, 23, 185, 118, 172);
RT_INTERFACE!{interface IGridLengthHelper(IGridLengthHelperVtbl): IInspectable(IInspectableVtbl) [IID_IGridLengthHelper] {
    
}}
DEFINE_IID!(IID_IGridLengthHelperStatics, 2638576539, 415, 16998, 136, 114, 33, 95, 25, 143, 106, 157);
RT_INTERFACE!{static interface IGridLengthHelperStatics(IGridLengthHelperStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGridLengthHelperStatics] {
    fn get_Auto(&self, out: *mut GridLength) -> HRESULT,
    fn FromPixels(&self, pixels: f64, out: *mut GridLength) -> HRESULT,
    fn FromValueAndType(&self, value: f64, type_: GridUnitType, out: *mut GridLength) -> HRESULT,
    fn GetIsAbsolute(&self, target: GridLength, out: *mut bool) -> HRESULT,
    fn GetIsAuto(&self, target: GridLength, out: *mut bool) -> HRESULT,
    fn GetIsStar(&self, target: GridLength, out: *mut bool) -> HRESULT,
    fn Equals(&self, target: GridLength, value: GridLength, out: *mut bool) -> HRESULT
}}
impl IGridLengthHelperStatics {
    #[inline] pub unsafe fn get_auto(&self) -> Result<GridLength> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Auto)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn from_pixels(&self, pixels: f64) -> Result<GridLength> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).FromPixels)(self as *const _ as *mut _, pixels, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn from_value_and_type(&self, value: f64, type_: GridUnitType) -> Result<GridLength> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).FromValueAndType)(self as *const _ as *mut _, value, type_, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_absolute(&self, target: GridLength) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsAbsolute)(self as *const _ as *mut _, target, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_auto(&self, target: GridLength) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsAuto)(self as *const _ as *mut _, target, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_star(&self, target: GridLength) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsStar)(self as *const _ as *mut _, target, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn equals(&self, target: GridLength, value: GridLength) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Equals)(self as *const _ as *mut _, target, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class GridLengthHelper: IGridLengthHelper}
impl RtActivatable<IGridLengthHelperStatics> for GridLengthHelper {}
impl GridLengthHelper {
    #[inline] pub fn get_auto() -> Result<GridLength> { unsafe {
        <Self as RtActivatable<IGridLengthHelperStatics>>::get_activation_factory().get_auto()
    }}
    #[inline] pub fn from_pixels(pixels: f64) -> Result<GridLength> { unsafe {
        <Self as RtActivatable<IGridLengthHelperStatics>>::get_activation_factory().from_pixels(pixels)
    }}
    #[inline] pub fn from_value_and_type(value: f64, type_: GridUnitType) -> Result<GridLength> { unsafe {
        <Self as RtActivatable<IGridLengthHelperStatics>>::get_activation_factory().from_value_and_type(value, type_)
    }}
    #[inline] pub fn get_is_absolute(target: GridLength) -> Result<bool> { unsafe {
        <Self as RtActivatable<IGridLengthHelperStatics>>::get_activation_factory().get_is_absolute(target)
    }}
    #[inline] pub fn get_is_auto(target: GridLength) -> Result<bool> { unsafe {
        <Self as RtActivatable<IGridLengthHelperStatics>>::get_activation_factory().get_is_auto(target)
    }}
    #[inline] pub fn get_is_star(target: GridLength) -> Result<bool> { unsafe {
        <Self as RtActivatable<IGridLengthHelperStatics>>::get_activation_factory().get_is_star(target)
    }}
    #[inline] pub fn equals(target: GridLength, value: GridLength) -> Result<bool> { unsafe {
        <Self as RtActivatable<IGridLengthHelperStatics>>::get_activation_factory().equals(target, value)
    }}
}
DEFINE_CLSID!(GridLengthHelper(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,71,114,105,100,76,101,110,103,116,104,72,101,108,112,101,114,0]) [CLSID_GridLengthHelper]);
DEFINE_IID!(IID_BindingFailedEventHandler, 325785474, 21690, 16909, 161, 170, 130, 130, 135, 33, 205, 230);
RT_DELEGATE!{delegate BindingFailedEventHandler(BindingFailedEventHandlerVtbl, BindingFailedEventHandlerImpl) [IID_BindingFailedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut BindingFailedEventArgs) -> HRESULT
}}
impl BindingFailedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &BindingFailedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class BindingFailedEventArgs: IBindingFailedEventArgs}
DEFINE_IID!(IID_IBindingFailedEventArgs, 851562515, 19901, 17517, 187, 184, 13, 227, 80, 72, 164, 73);
RT_INTERFACE!{interface IBindingFailedEventArgs(IBindingFailedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBindingFailedEventArgs] {
    fn get_Message(&self, out: *mut HSTRING) -> HRESULT
}}
impl IBindingFailedEventArgs {
    #[inline] pub unsafe fn get_message(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Message)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDebugSettings, 1027940248, 50855, 19735, 131, 152, 216, 58, 6, 113, 131, 216);
RT_INTERFACE!{interface IDebugSettings(IDebugSettingsVtbl): IInspectable(IInspectableVtbl) [IID_IDebugSettings] {
    fn get_EnableFrameRateCounter(&self, out: *mut bool) -> HRESULT,
    fn put_EnableFrameRateCounter(&self, value: bool) -> HRESULT,
    fn get_IsBindingTracingEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsBindingTracingEnabled(&self, value: bool) -> HRESULT,
    fn get_IsOverdrawHeatMapEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsOverdrawHeatMapEnabled(&self, value: bool) -> HRESULT,
    fn add_BindingFailed(&self, value: *mut BindingFailedEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BindingFailed(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IDebugSettings {
    #[inline] pub unsafe fn get_enable_frame_rate_counter(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EnableFrameRateCounter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_enable_frame_rate_counter(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EnableFrameRateCounter)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_binding_tracing_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsBindingTracingEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_binding_tracing_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsBindingTracingEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_overdraw_heat_map_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsOverdrawHeatMapEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_overdraw_heat_map_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsOverdrawHeatMapEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_binding_failed(&self, value: &BindingFailedEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_BindingFailed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_binding_failed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_BindingFailed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDebugSettings2, 1221817733, 57766, 18075, 131, 200, 48, 130, 80, 55, 17, 158);
RT_INTERFACE!{interface IDebugSettings2(IDebugSettings2Vtbl): IInspectable(IInspectableVtbl) [IID_IDebugSettings2] {
    fn get_EnableRedrawRegions(&self, out: *mut bool) -> HRESULT,
    fn put_EnableRedrawRegions(&self, value: bool) -> HRESULT
}}
impl IDebugSettings2 {
    #[inline] pub unsafe fn get_enable_redraw_regions(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EnableRedrawRegions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_enable_redraw_regions(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EnableRedrawRegions)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDebugSettings3, 3871035426, 1573, 18335, 142, 50, 75, 88, 61, 115, 183, 172);
RT_INTERFACE!{interface IDebugSettings3(IDebugSettings3Vtbl): IInspectable(IInspectableVtbl) [IID_IDebugSettings3] {
    fn get_IsTextPerformanceVisualizationEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsTextPerformanceVisualizationEnabled(&self, value: bool) -> HRESULT
}}
impl IDebugSettings3 {
    #[inline] pub unsafe fn get_is_text_performance_visualization_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTextPerformanceVisualizationEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_text_performance_visualization_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsTextPerformanceVisualizationEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class DebugSettings: IDebugSettings}
DEFINE_IID!(IID_IElementSoundPlayer, 947352485, 61494, 17932, 155, 129, 243, 214, 234, 67, 246, 242);
RT_INTERFACE!{interface IElementSoundPlayer(IElementSoundPlayerVtbl): IInspectable(IInspectableVtbl) [IID_IElementSoundPlayer] {
    
}}
DEFINE_IID!(IID_IElementSoundPlayerStatics, 561680388, 38941, 16841, 177, 82, 173, 169, 17, 164, 177, 58);
RT_INTERFACE!{static interface IElementSoundPlayerStatics(IElementSoundPlayerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IElementSoundPlayerStatics] {
    fn get_Volume(&self, out: *mut f64) -> HRESULT,
    fn put_Volume(&self, value: f64) -> HRESULT,
    fn get_State(&self, out: *mut ElementSoundPlayerState) -> HRESULT,
    fn put_State(&self, value: ElementSoundPlayerState) -> HRESULT,
    fn Play(&self, sound: ElementSoundKind) -> HRESULT
}}
impl IElementSoundPlayerStatics {
    #[inline] pub unsafe fn get_volume(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Volume)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_volume(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Volume)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_state(&self) -> Result<ElementSoundPlayerState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_State)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_state(&self, value: ElementSoundPlayerState) -> Result<()> {
        let hr = ((*self.lpVtbl).put_State)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn play(&self, sound: ElementSoundKind) -> Result<()> {
        let hr = ((*self.lpVtbl).Play)(self as *const _ as *mut _, sound);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ElementSoundPlayer: IElementSoundPlayer}
impl RtActivatable<IElementSoundPlayerStatics> for ElementSoundPlayer {}
impl ElementSoundPlayer {
    #[inline] pub fn get_volume() -> Result<f64> { unsafe {
        <Self as RtActivatable<IElementSoundPlayerStatics>>::get_activation_factory().get_volume()
    }}
    #[inline] pub fn set_volume(value: f64) -> Result<()> { unsafe {
        <Self as RtActivatable<IElementSoundPlayerStatics>>::get_activation_factory().set_volume(value)
    }}
    #[inline] pub fn get_state() -> Result<ElementSoundPlayerState> { unsafe {
        <Self as RtActivatable<IElementSoundPlayerStatics>>::get_activation_factory().get_state()
    }}
    #[inline] pub fn set_state(value: ElementSoundPlayerState) -> Result<()> { unsafe {
        <Self as RtActivatable<IElementSoundPlayerStatics>>::get_activation_factory().set_state(value)
    }}
    #[inline] pub fn play(sound: ElementSoundKind) -> Result<()> { unsafe {
        <Self as RtActivatable<IElementSoundPlayerStatics>>::get_activation_factory().play(sound)
    }}
}
DEFINE_CLSID!(ElementSoundPlayer(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,69,108,101,109,101,110,116,83,111,117,110,100,80,108,97,121,101,114,0]) [CLSID_ElementSoundPlayer]);
DEFINE_IID!(IID_IApplication, 1958240673, 29831, 18089, 154, 110, 199, 139, 81, 39, 38, 197);
RT_INTERFACE!{interface IApplication(IApplicationVtbl): IInspectable(IInspectableVtbl) [IID_IApplication] {
    fn get_Resources(&self, out: *mut *mut ResourceDictionary) -> HRESULT,
    fn put_Resources(&self, value: *mut ResourceDictionary) -> HRESULT,
    fn get_DebugSettings(&self, out: *mut *mut DebugSettings) -> HRESULT,
    fn get_RequestedTheme(&self, out: *mut ApplicationTheme) -> HRESULT,
    fn put_RequestedTheme(&self, value: ApplicationTheme) -> HRESULT,
    fn add_UnhandledException(&self, value: *mut UnhandledExceptionEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_UnhandledException(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Suspending(&self, value: *mut SuspendingEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Suspending(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Resuming(&self, value: *mut super::super::foundation::EventHandler<IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Resuming(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn Exit(&self) -> HRESULT
}}
impl IApplication {
    #[inline] pub unsafe fn get_resources(&self) -> Result<ComPtr<ResourceDictionary>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Resources)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_resources(&self, value: &ResourceDictionary) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Resources)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_debug_settings(&self) -> Result<ComPtr<DebugSettings>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DebugSettings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_requested_theme(&self) -> Result<ApplicationTheme> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RequestedTheme)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_requested_theme(&self, value: ApplicationTheme) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RequestedTheme)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_unhandled_exception(&self, value: &UnhandledExceptionEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_UnhandledException)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_unhandled_exception(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_UnhandledException)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_suspending(&self, value: &SuspendingEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Suspending)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_suspending(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Suspending)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_resuming(&self, value: &super::super::foundation::EventHandler<IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Resuming)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_resuming(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Resuming)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn exit(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Exit)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IApplicationOverrides, 637116407, 37703, 17818, 159, 172, 178, 208, 225, 28, 26, 15);
RT_INTERFACE!{interface IApplicationOverrides(IApplicationOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IApplicationOverrides] {
    #[cfg(not(feature="windows-applicationmodel"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-applicationmodel")] fn OnActivated(&self, args: *mut super::super::applicationmodel::activation::IActivatedEventArgs) -> HRESULT,
    #[cfg(not(feature="windows-applicationmodel"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-applicationmodel")] fn OnLaunched(&self, args: *mut super::super::applicationmodel::activation::LaunchActivatedEventArgs) -> HRESULT,
    #[cfg(not(feature="windows-applicationmodel"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-applicationmodel")] fn OnFileActivated(&self, args: *mut super::super::applicationmodel::activation::FileActivatedEventArgs) -> HRESULT,
    #[cfg(not(feature="windows-applicationmodel"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-applicationmodel")] fn OnSearchActivated(&self, args: *mut super::super::applicationmodel::activation::SearchActivatedEventArgs) -> HRESULT,
    #[cfg(not(feature="windows-applicationmodel"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-applicationmodel")] fn OnShareTargetActivated(&self, args: *mut super::super::applicationmodel::activation::ShareTargetActivatedEventArgs) -> HRESULT,
    #[cfg(not(feature="windows-applicationmodel"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-applicationmodel")] fn OnFileOpenPickerActivated(&self, args: *mut super::super::applicationmodel::activation::FileOpenPickerActivatedEventArgs) -> HRESULT,
    #[cfg(not(feature="windows-applicationmodel"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-applicationmodel")] fn OnFileSavePickerActivated(&self, args: *mut super::super::applicationmodel::activation::FileSavePickerActivatedEventArgs) -> HRESULT,
    #[cfg(not(feature="windows-applicationmodel"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-applicationmodel")] fn OnCachedFileUpdaterActivated(&self, args: *mut super::super::applicationmodel::activation::CachedFileUpdaterActivatedEventArgs) -> HRESULT,
    fn OnWindowCreated(&self, args: *mut WindowCreatedEventArgs) -> HRESULT
}}
impl IApplicationOverrides {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn on_activated(&self, args: &super::super::applicationmodel::activation::IActivatedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnActivated)(self as *const _ as *mut _, args as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn on_launched(&self, args: &super::super::applicationmodel::activation::LaunchActivatedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnLaunched)(self as *const _ as *mut _, args as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn on_file_activated(&self, args: &super::super::applicationmodel::activation::FileActivatedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnFileActivated)(self as *const _ as *mut _, args as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn on_search_activated(&self, args: &super::super::applicationmodel::activation::SearchActivatedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnSearchActivated)(self as *const _ as *mut _, args as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn on_share_target_activated(&self, args: &super::super::applicationmodel::activation::ShareTargetActivatedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnShareTargetActivated)(self as *const _ as *mut _, args as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn on_file_open_picker_activated(&self, args: &super::super::applicationmodel::activation::FileOpenPickerActivatedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnFileOpenPickerActivated)(self as *const _ as *mut _, args as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn on_file_save_picker_activated(&self, args: &super::super::applicationmodel::activation::FileSavePickerActivatedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnFileSavePickerActivated)(self as *const _ as *mut _, args as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn on_cached_file_updater_activated(&self, args: &super::super::applicationmodel::activation::CachedFileUpdaterActivatedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnCachedFileUpdaterActivated)(self as *const _ as *mut _, args as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_window_created(&self, args: &WindowCreatedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnWindowCreated)(self as *const _ as *mut _, args as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class WindowCreatedEventArgs: IWindowCreatedEventArgs}
DEFINE_IID!(IID_IApplicationStatics, 105486743, 63412, 17918, 183, 99, 117, 119, 209, 211, 203, 74);
RT_INTERFACE!{static interface IApplicationStatics(IApplicationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IApplicationStatics] {
    fn get_Current(&self, out: *mut *mut Application) -> HRESULT,
    fn Start(&self, callback: *mut ApplicationInitializationCallback) -> HRESULT,
    fn LoadComponent(&self, component: *mut IInspectable, resourceLocator: *mut super::super::foundation::Uri) -> HRESULT,
    fn LoadComponentWithResourceLocation(&self, component: *mut IInspectable, resourceLocator: *mut super::super::foundation::Uri, componentResourceLocation: controls::primitives::ComponentResourceLocation) -> HRESULT
}}
impl IApplicationStatics {
    #[inline] pub unsafe fn get_current(&self) -> Result<ComPtr<Application>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Current)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn start(&self, callback: &ApplicationInitializationCallback) -> Result<()> {
        let hr = ((*self.lpVtbl).Start)(self as *const _ as *mut _, callback as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn load_component(&self, component: &IInspectable, resourceLocator: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).LoadComponent)(self as *const _ as *mut _, component as *const _ as *mut _, resourceLocator as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn load_component_with_resource_location(&self, component: &IInspectable, resourceLocator: &super::super::foundation::Uri, componentResourceLocation: controls::primitives::ComponentResourceLocation) -> Result<()> {
        let hr = ((*self.lpVtbl).LoadComponentWithResourceLocation)(self as *const _ as *mut _, component as *const _ as *mut _, resourceLocator as *const _ as *mut _, componentResourceLocation);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class Application: IApplication}
impl RtActivatable<IApplicationStatics> for Application {}
impl Application {
    #[inline] pub fn get_current() -> Result<ComPtr<Application>> { unsafe {
        <Self as RtActivatable<IApplicationStatics>>::get_activation_factory().get_current()
    }}
    #[inline] pub fn start(callback: &ApplicationInitializationCallback) -> Result<()> { unsafe {
        <Self as RtActivatable<IApplicationStatics>>::get_activation_factory().start(callback)
    }}
    #[inline] pub fn load_component(component: &IInspectable, resourceLocator: &super::super::foundation::Uri) -> Result<()> { unsafe {
        <Self as RtActivatable<IApplicationStatics>>::get_activation_factory().load_component(component, resourceLocator)
    }}
    #[inline] pub fn load_component_with_resource_location(component: &IInspectable, resourceLocator: &super::super::foundation::Uri, componentResourceLocation: controls::primitives::ComponentResourceLocation) -> Result<()> { unsafe {
        <Self as RtActivatable<IApplicationStatics>>::get_activation_factory().load_component_with_resource_location(component, resourceLocator, componentResourceLocation)
    }}
}
DEFINE_CLSID!(Application(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,112,112,108,105,99,97,116,105,111,110,0]) [CLSID_Application]);
DEFINE_IID!(IID_IApplicationFactory, 2478564193, 48730, 20195, 180, 163, 149, 17, 141, 201, 122, 137);
RT_INTERFACE!{interface IApplicationFactory(IApplicationFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IApplicationFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut Application) -> HRESULT
}}
impl IApplicationFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<Application>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IApplication2, 26281150, 21034, 22788, 245, 47, 222, 114, 1, 4, 41, 224);
RT_INTERFACE!{interface IApplication2(IApplication2Vtbl): IInspectable(IInspectableVtbl) [IID_IApplication2] {
    fn get_FocusVisualKind(&self, out: *mut FocusVisualKind) -> HRESULT,
    fn put_FocusVisualKind(&self, value: FocusVisualKind) -> HRESULT,
    fn get_RequiresPointerMode(&self, out: *mut ApplicationRequiresPointerMode) -> HRESULT,
    fn put_RequiresPointerMode(&self, value: ApplicationRequiresPointerMode) -> HRESULT,
    fn add_LeavingBackground(&self, value: *mut LeavingBackgroundEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LeavingBackground(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_EnteredBackground(&self, value: *mut EnteredBackgroundEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EnteredBackground(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IApplication2 {
    #[inline] pub unsafe fn get_focus_visual_kind(&self) -> Result<FocusVisualKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FocusVisualKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_focus_visual_kind(&self, value: FocusVisualKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FocusVisualKind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_requires_pointer_mode(&self) -> Result<ApplicationRequiresPointerMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RequiresPointerMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_requires_pointer_mode(&self, value: ApplicationRequiresPointerMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RequiresPointerMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_leaving_background(&self, value: &LeavingBackgroundEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_LeavingBackground)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_leaving_background(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_LeavingBackground)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_entered_background(&self, value: &EnteredBackgroundEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_EnteredBackground)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_entered_background(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_EnteredBackground)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IApplicationOverrides2, 3680293561, 54196, 21900, 198, 78, 4, 52, 253, 27, 216, 137);
RT_INTERFACE!{interface IApplicationOverrides2(IApplicationOverrides2Vtbl): IInspectable(IInspectableVtbl) [IID_IApplicationOverrides2] {
    #[cfg(feature="windows-applicationmodel")] fn OnBackgroundActivated(&self, args: *mut super::super::applicationmodel::activation::BackgroundActivatedEventArgs) -> HRESULT
}}
impl IApplicationOverrides2 {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn on_background_activated(&self, args: &super::super::applicationmodel::activation::BackgroundActivatedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnBackgroundActivated)(self as *const _ as *mut _, args as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IApplication3, 3077942652, 6328, 17866, 161, 176, 220, 72, 62, 75, 16, 40);
RT_INTERFACE!{interface IApplication3(IApplication3Vtbl): IInspectable(IInspectableVtbl) [IID_IApplication3] {
    fn get_HighContrastAdjustment(&self, out: *mut ApplicationHighContrastAdjustment) -> HRESULT,
    fn put_HighContrastAdjustment(&self, value: ApplicationHighContrastAdjustment) -> HRESULT
}}
impl IApplication3 {
    #[inline] pub unsafe fn get_high_contrast_adjustment(&self) -> Result<ApplicationHighContrastAdjustment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HighContrastAdjustment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_high_contrast_adjustment(&self, value: ApplicationHighContrastAdjustment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HighContrastAdjustment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFrameworkViewSource, 3819993050, 13741, 19209, 181, 178, 39, 66, 0, 65, 186, 159);
RT_INTERFACE!{interface IFrameworkViewSource(IFrameworkViewSourceVtbl): IInspectable(IInspectableVtbl) [IID_IFrameworkViewSource] {
    
}}
RT_CLASS!{class FrameworkViewSource: IFrameworkViewSource}
impl RtActivatable<IActivationFactory> for FrameworkViewSource {}
DEFINE_CLSID!(FrameworkViewSource(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,70,114,97,109,101,119,111,114,107,86,105,101,119,83,111,117,114,99,101,0]) [CLSID_FrameworkViewSource]);
DEFINE_IID!(IID_IPointHelper, 1920720274, 25776, 18895, 163, 33, 169, 121, 62, 115, 226, 231);
RT_INTERFACE!{interface IPointHelper(IPointHelperVtbl): IInspectable(IInspectableVtbl) [IID_IPointHelper] {
    
}}
DEFINE_IID!(IID_IPointHelperStatics, 22727285, 30424, 19326, 138, 51, 125, 121, 32, 70, 145, 238);
RT_INTERFACE!{static interface IPointHelperStatics(IPointHelperStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPointHelperStatics] {
    fn FromCoordinates(&self, x: f32, y: f32, out: *mut super::super::foundation::Point) -> HRESULT
}}
impl IPointHelperStatics {
    #[inline] pub unsafe fn from_coordinates(&self, x: f32, y: f32) -> Result<super::super::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).FromCoordinates)(self as *const _ as *mut _, x, y, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class PointHelper: IPointHelper}
impl RtActivatable<IPointHelperStatics> for PointHelper {}
impl PointHelper {
    #[inline] pub fn from_coordinates(x: f32, y: f32) -> Result<super::super::foundation::Point> { unsafe {
        <Self as RtActivatable<IPointHelperStatics>>::get_activation_factory().from_coordinates(x, y)
    }}
}
DEFINE_CLSID!(PointHelper(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,80,111,105,110,116,72,101,108,112,101,114,0]) [CLSID_PointHelper]);
DEFINE_IID!(IID_IRectHelper, 2743566818, 19451, 20194, 175, 229, 137, 243, 27, 55, 71, 141);
RT_INTERFACE!{interface IRectHelper(IRectHelperVtbl): IInspectable(IInspectableVtbl) [IID_IRectHelper] {
    
}}
DEFINE_IID!(IID_IRectHelperStatics, 1591829476, 49534, 18767, 181, 128, 47, 5, 116, 252, 58, 21);
RT_INTERFACE!{static interface IRectHelperStatics(IRectHelperStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRectHelperStatics] {
    fn get_Empty(&self, out: *mut super::super::foundation::Rect) -> HRESULT,
    fn FromCoordinatesAndDimensions(&self, x: f32, y: f32, width: f32, height: f32, out: *mut super::super::foundation::Rect) -> HRESULT,
    fn FromPoints(&self, point1: super::super::foundation::Point, point2: super::super::foundation::Point, out: *mut super::super::foundation::Rect) -> HRESULT,
    fn FromLocationAndSize(&self, location: super::super::foundation::Point, size: super::super::foundation::Size, out: *mut super::super::foundation::Rect) -> HRESULT,
    fn GetIsEmpty(&self, target: super::super::foundation::Rect, out: *mut bool) -> HRESULT,
    fn GetBottom(&self, target: super::super::foundation::Rect, out: *mut f32) -> HRESULT,
    fn GetLeft(&self, target: super::super::foundation::Rect, out: *mut f32) -> HRESULT,
    fn GetRight(&self, target: super::super::foundation::Rect, out: *mut f32) -> HRESULT,
    fn GetTop(&self, target: super::super::foundation::Rect, out: *mut f32) -> HRESULT,
    fn Contains(&self, target: super::super::foundation::Rect, point: super::super::foundation::Point, out: *mut bool) -> HRESULT,
    fn Equals(&self, target: super::super::foundation::Rect, value: super::super::foundation::Rect, out: *mut bool) -> HRESULT,
    fn Intersect(&self, target: super::super::foundation::Rect, rect: super::super::foundation::Rect, out: *mut super::super::foundation::Rect) -> HRESULT,
    fn UnionWithPoint(&self, target: super::super::foundation::Rect, point: super::super::foundation::Point, out: *mut super::super::foundation::Rect) -> HRESULT,
    fn UnionWithRect(&self, target: super::super::foundation::Rect, rect: super::super::foundation::Rect, out: *mut super::super::foundation::Rect) -> HRESULT
}}
impl IRectHelperStatics {
    #[inline] pub unsafe fn get_empty(&self) -> Result<super::super::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Empty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn from_coordinates_and_dimensions(&self, x: f32, y: f32, width: f32, height: f32) -> Result<super::super::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).FromCoordinatesAndDimensions)(self as *const _ as *mut _, x, y, width, height, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn from_points(&self, point1: super::super::foundation::Point, point2: super::super::foundation::Point) -> Result<super::super::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).FromPoints)(self as *const _ as *mut _, point1, point2, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn from_location_and_size(&self, location: super::super::foundation::Point, size: super::super::foundation::Size) -> Result<super::super::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).FromLocationAndSize)(self as *const _ as *mut _, location, size, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_empty(&self, target: super::super::foundation::Rect) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsEmpty)(self as *const _ as *mut _, target, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_bottom(&self, target: super::super::foundation::Rect) -> Result<f32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetBottom)(self as *const _ as *mut _, target, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_left(&self, target: super::super::foundation::Rect) -> Result<f32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetLeft)(self as *const _ as *mut _, target, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_right(&self, target: super::super::foundation::Rect) -> Result<f32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetRight)(self as *const _ as *mut _, target, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_top(&self, target: super::super::foundation::Rect) -> Result<f32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetTop)(self as *const _ as *mut _, target, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn contains(&self, target: super::super::foundation::Rect, point: super::super::foundation::Point) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Contains)(self as *const _ as *mut _, target, point, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn equals(&self, target: super::super::foundation::Rect, value: super::super::foundation::Rect) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Equals)(self as *const _ as *mut _, target, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn intersect(&self, target: super::super::foundation::Rect, rect: super::super::foundation::Rect) -> Result<super::super::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Intersect)(self as *const _ as *mut _, target, rect, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn union_with_point(&self, target: super::super::foundation::Rect, point: super::super::foundation::Point) -> Result<super::super::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).UnionWithPoint)(self as *const _ as *mut _, target, point, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn union_with_rect(&self, target: super::super::foundation::Rect, rect: super::super::foundation::Rect) -> Result<super::super::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).UnionWithRect)(self as *const _ as *mut _, target, rect, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class RectHelper: IRectHelper}
impl RtActivatable<IRectHelperStatics> for RectHelper {}
impl RectHelper {
    #[inline] pub fn get_empty() -> Result<super::super::foundation::Rect> { unsafe {
        <Self as RtActivatable<IRectHelperStatics>>::get_activation_factory().get_empty()
    }}
    #[inline] pub fn from_coordinates_and_dimensions(x: f32, y: f32, width: f32, height: f32) -> Result<super::super::foundation::Rect> { unsafe {
        <Self as RtActivatable<IRectHelperStatics>>::get_activation_factory().from_coordinates_and_dimensions(x, y, width, height)
    }}
    #[inline] pub fn from_points(point1: super::super::foundation::Point, point2: super::super::foundation::Point) -> Result<super::super::foundation::Rect> { unsafe {
        <Self as RtActivatable<IRectHelperStatics>>::get_activation_factory().from_points(point1, point2)
    }}
    #[inline] pub fn from_location_and_size(location: super::super::foundation::Point, size: super::super::foundation::Size) -> Result<super::super::foundation::Rect> { unsafe {
        <Self as RtActivatable<IRectHelperStatics>>::get_activation_factory().from_location_and_size(location, size)
    }}
    #[inline] pub fn get_is_empty(target: super::super::foundation::Rect) -> Result<bool> { unsafe {
        <Self as RtActivatable<IRectHelperStatics>>::get_activation_factory().get_is_empty(target)
    }}
    #[inline] pub fn get_bottom(target: super::super::foundation::Rect) -> Result<f32> { unsafe {
        <Self as RtActivatable<IRectHelperStatics>>::get_activation_factory().get_bottom(target)
    }}
    #[inline] pub fn get_left(target: super::super::foundation::Rect) -> Result<f32> { unsafe {
        <Self as RtActivatable<IRectHelperStatics>>::get_activation_factory().get_left(target)
    }}
    #[inline] pub fn get_right(target: super::super::foundation::Rect) -> Result<f32> { unsafe {
        <Self as RtActivatable<IRectHelperStatics>>::get_activation_factory().get_right(target)
    }}
    #[inline] pub fn get_top(target: super::super::foundation::Rect) -> Result<f32> { unsafe {
        <Self as RtActivatable<IRectHelperStatics>>::get_activation_factory().get_top(target)
    }}
    #[inline] pub fn contains(target: super::super::foundation::Rect, point: super::super::foundation::Point) -> Result<bool> { unsafe {
        <Self as RtActivatable<IRectHelperStatics>>::get_activation_factory().contains(target, point)
    }}
    #[inline] pub fn equals(target: super::super::foundation::Rect, value: super::super::foundation::Rect) -> Result<bool> { unsafe {
        <Self as RtActivatable<IRectHelperStatics>>::get_activation_factory().equals(target, value)
    }}
    #[inline] pub fn intersect(target: super::super::foundation::Rect, rect: super::super::foundation::Rect) -> Result<super::super::foundation::Rect> { unsafe {
        <Self as RtActivatable<IRectHelperStatics>>::get_activation_factory().intersect(target, rect)
    }}
    #[inline] pub fn union_with_point(target: super::super::foundation::Rect, point: super::super::foundation::Point) -> Result<super::super::foundation::Rect> { unsafe {
        <Self as RtActivatable<IRectHelperStatics>>::get_activation_factory().union_with_point(target, point)
    }}
    #[inline] pub fn union_with_rect(target: super::super::foundation::Rect, rect: super::super::foundation::Rect) -> Result<super::super::foundation::Rect> { unsafe {
        <Self as RtActivatable<IRectHelperStatics>>::get_activation_factory().union_with_rect(target, rect)
    }}
}
DEFINE_CLSID!(RectHelper(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,82,101,99,116,72,101,108,112,101,114,0]) [CLSID_RectHelper]);
DEFINE_IID!(IID_ISizeHelper, 3877788308, 23811, 18947, 186, 148, 150, 127, 198, 143, 206, 254);
RT_INTERFACE!{interface ISizeHelper(ISizeHelperVtbl): IInspectable(IInspectableVtbl) [IID_ISizeHelper] {
    
}}
DEFINE_IID!(IID_ISizeHelperStatics, 1652999602, 53112, 18709, 170, 64, 118, 0, 74, 22, 95, 94);
RT_INTERFACE!{static interface ISizeHelperStatics(ISizeHelperStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISizeHelperStatics] {
    fn get_Empty(&self, out: *mut super::super::foundation::Size) -> HRESULT,
    fn FromDimensions(&self, width: f32, height: f32, out: *mut super::super::foundation::Size) -> HRESULT,
    fn GetIsEmpty(&self, target: super::super::foundation::Size, out: *mut bool) -> HRESULT,
    fn Equals(&self, target: super::super::foundation::Size, value: super::super::foundation::Size, out: *mut bool) -> HRESULT
}}
impl ISizeHelperStatics {
    #[inline] pub unsafe fn get_empty(&self) -> Result<super::super::foundation::Size> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Empty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn from_dimensions(&self, width: f32, height: f32) -> Result<super::super::foundation::Size> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).FromDimensions)(self as *const _ as *mut _, width, height, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_empty(&self, target: super::super::foundation::Size) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsEmpty)(self as *const _ as *mut _, target, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn equals(&self, target: super::super::foundation::Size, value: super::super::foundation::Size) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Equals)(self as *const _ as *mut _, target, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class SizeHelper: ISizeHelper}
impl RtActivatable<ISizeHelperStatics> for SizeHelper {}
impl SizeHelper {
    #[inline] pub fn get_empty() -> Result<super::super::foundation::Size> { unsafe {
        <Self as RtActivatable<ISizeHelperStatics>>::get_activation_factory().get_empty()
    }}
    #[inline] pub fn from_dimensions(width: f32, height: f32) -> Result<super::super::foundation::Size> { unsafe {
        <Self as RtActivatable<ISizeHelperStatics>>::get_activation_factory().from_dimensions(width, height)
    }}
    #[inline] pub fn get_is_empty(target: super::super::foundation::Size) -> Result<bool> { unsafe {
        <Self as RtActivatable<ISizeHelperStatics>>::get_activation_factory().get_is_empty(target)
    }}
    #[inline] pub fn equals(target: super::super::foundation::Size, value: super::super::foundation::Size) -> Result<bool> { unsafe {
        <Self as RtActivatable<ISizeHelperStatics>>::get_activation_factory().equals(target, value)
    }}
}
DEFINE_CLSID!(SizeHelper(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,83,105,122,101,72,101,108,112,101,114,0]) [CLSID_SizeHelper]);
DEFINE_IID!(IID_IWindow, 846599805, 51702, 17965, 157, 226, 174, 76, 31, 216, 194, 229);
RT_INTERFACE!{interface IWindow(IWindowVtbl): IInspectable(IInspectableVtbl) [IID_IWindow] {
    fn get_Bounds(&self, out: *mut super::super::foundation::Rect) -> HRESULT,
    fn get_Visible(&self, out: *mut bool) -> HRESULT,
    fn get_Content(&self, out: *mut *mut UIElement) -> HRESULT,
    fn put_Content(&self, value: *mut UIElement) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_CoreWindow(&self, out: *mut *mut super::core::CoreWindow) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Dispatcher(&self, out: *mut *mut super::core::CoreDispatcher) -> HRESULT,
    fn add_Activated(&self, value: *mut WindowActivatedEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Activated(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Closed(&self, value: *mut WindowClosedEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_SizeChanged(&self, value: *mut WindowSizeChangedEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SizeChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_VisibilityChanged(&self, value: *mut WindowVisibilityChangedEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VisibilityChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn Activate(&self) -> HRESULT,
    fn Close(&self) -> HRESULT
}}
impl IWindow {
    #[inline] pub unsafe fn get_bounds(&self) -> Result<super::super::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Bounds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Visible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content(&self) -> Result<ComPtr<UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Content)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content(&self, value: &UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Content)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_core_window(&self) -> Result<ComPtr<super::core::CoreWindow>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CoreWindow)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_dispatcher(&self) -> Result<ComPtr<super::core::CoreDispatcher>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Dispatcher)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_activated(&self, value: &WindowActivatedEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Activated)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_activated(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Activated)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_closed(&self, value: &WindowClosedEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Closed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_closed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Closed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_size_changed(&self, value: &WindowSizeChangedEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SizeChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_size_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SizeChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_visibility_changed(&self, value: &WindowVisibilityChangedEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_VisibilityChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_visibility_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_VisibilityChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn activate(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Activate)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn close(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Close)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWindowStatics, 2469561353, 20129, 19194, 131, 220, 12, 78, 115, 232, 139, 177);
RT_INTERFACE!{static interface IWindowStatics(IWindowStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IWindowStatics] {
    fn get_Current(&self, out: *mut *mut Window) -> HRESULT
}}
impl IWindowStatics {
    #[inline] pub unsafe fn get_current(&self) -> Result<ComPtr<Window>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Current)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class Window: IWindow}
impl RtActivatable<IWindowStatics> for Window {}
impl Window {
    #[inline] pub fn get_current() -> Result<ComPtr<Window>> { unsafe {
        <Self as RtActivatable<IWindowStatics>>::get_activation_factory().get_current()
    }}
}
DEFINE_CLSID!(Window(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,87,105,110,100,111,119,0]) [CLSID_Window]);
DEFINE_IID!(IID_IWindow2, 3548673439, 13558, 17538, 132, 53, 245, 82, 249, 178, 76, 200);
RT_INTERFACE!{interface IWindow2(IWindow2Vtbl): IInspectable(IInspectableVtbl) [IID_IWindow2] {
    fn SetTitleBar(&self, value: *mut UIElement) -> HRESULT
}}
impl IWindow2 {
    #[inline] pub unsafe fn set_title_bar(&self, value: &UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).SetTitleBar)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWindow3, 3071007901, 7221, 17962, 155, 151, 128, 141, 90, 249, 242, 142);
RT_INTERFACE!{interface IWindow3(IWindow3Vtbl): IInspectable(IInspectableVtbl) [IID_IWindow3] {
    #[cfg(feature="windows-ui")] fn get_Compositor(&self, out: *mut *mut super::composition::Compositor) -> HRESULT
}}
impl IWindow3 {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_compositor(&self) -> Result<ComPtr<super::composition::Compositor>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Compositor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWindowCreatedEventArgs, 834081904, 65279, 18004, 175, 72, 155, 57, 138, 181, 119, 43);
RT_INTERFACE!{interface IWindowCreatedEventArgs(IWindowCreatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWindowCreatedEventArgs] {
    fn get_Window(&self, out: *mut *mut Window) -> HRESULT
}}
impl IWindowCreatedEventArgs {
    #[inline] pub unsafe fn get_window(&self) -> Result<ComPtr<Window>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Window)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVisualStateManager, 1876598682, 28587, 16658, 146, 88, 16, 6, 163, 195, 71, 110);
RT_INTERFACE!{interface IVisualStateManager(IVisualStateManagerVtbl): IInspectable(IInspectableVtbl) [IID_IVisualStateManager] {
    
}}
DEFINE_IID!(IID_IVisualStateManagerOverrides, 1248235790, 31097, 17352, 143, 244, 236, 97, 34, 117, 0, 6);
RT_INTERFACE!{interface IVisualStateManagerOverrides(IVisualStateManagerOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IVisualStateManagerOverrides] {
    fn GoToStateCore(&self, control: *mut controls::Control, templateRoot: *mut FrameworkElement, stateName: HSTRING, group: *mut VisualStateGroup, state: *mut VisualState, useTransitions: bool, out: *mut bool) -> HRESULT
}}
impl IVisualStateManagerOverrides {
    #[inline] pub unsafe fn go_to_state_core(&self, control: &controls::Control, templateRoot: &FrameworkElement, stateName: &HStringArg, group: &VisualStateGroup, state: &VisualState, useTransitions: bool) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GoToStateCore)(self as *const _ as *mut _, control as *const _ as *mut _, templateRoot as *const _ as *mut _, stateName.get(), group as *const _ as *mut _, state as *const _ as *mut _, useTransitions, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVisualStateManagerProtected, 1262192192, 45239, 16460, 158, 244, 217, 73, 100, 14, 36, 93);
RT_INTERFACE!{interface IVisualStateManagerProtected(IVisualStateManagerProtectedVtbl): IInspectable(IInspectableVtbl) [IID_IVisualStateManagerProtected] {
    fn RaiseCurrentStateChanging(&self, stateGroup: *mut VisualStateGroup, oldState: *mut VisualState, newState: *mut VisualState, control: *mut controls::Control) -> HRESULT,
    fn RaiseCurrentStateChanged(&self, stateGroup: *mut VisualStateGroup, oldState: *mut VisualState, newState: *mut VisualState, control: *mut controls::Control) -> HRESULT
}}
impl IVisualStateManagerProtected {
    #[inline] pub unsafe fn raise_current_state_changing(&self, stateGroup: &VisualStateGroup, oldState: &VisualState, newState: &VisualState, control: &controls::Control) -> Result<()> {
        let hr = ((*self.lpVtbl).RaiseCurrentStateChanging)(self as *const _ as *mut _, stateGroup as *const _ as *mut _, oldState as *const _ as *mut _, newState as *const _ as *mut _, control as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn raise_current_state_changed(&self, stateGroup: &VisualStateGroup, oldState: &VisualState, newState: &VisualState, control: &controls::Control) -> Result<()> {
        let hr = ((*self.lpVtbl).RaiseCurrentStateChanged)(self as *const _ as *mut _, stateGroup as *const _ as *mut _, oldState as *const _ as *mut _, newState as *const _ as *mut _, control as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVisualStateManagerStatics, 30468576, 55059, 16718, 167, 78, 230, 62, 199, 172, 140, 61);
RT_INTERFACE!{static interface IVisualStateManagerStatics(IVisualStateManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IVisualStateManagerStatics] {
    fn GetVisualStateGroups(&self, obj: *mut FrameworkElement, out: *mut *mut super::super::foundation::collections::IVector<VisualStateGroup>) -> HRESULT,
    fn get_CustomVisualStateManagerProperty(&self, out: *mut *mut DependencyProperty) -> HRESULT,
    fn GetCustomVisualStateManager(&self, obj: *mut FrameworkElement, out: *mut *mut VisualStateManager) -> HRESULT,
    fn SetCustomVisualStateManager(&self, obj: *mut FrameworkElement, value: *mut VisualStateManager) -> HRESULT,
    fn GoToState(&self, control: *mut controls::Control, stateName: HSTRING, useTransitions: bool, out: *mut bool) -> HRESULT
}}
impl IVisualStateManagerStatics {
    #[inline] pub unsafe fn get_visual_state_groups(&self, obj: &FrameworkElement) -> Result<ComPtr<super::super::foundation::collections::IVector<VisualStateGroup>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetVisualStateGroups)(self as *const _ as *mut _, obj as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_custom_visual_state_manager_property(&self) -> Result<ComPtr<DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CustomVisualStateManagerProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_custom_visual_state_manager(&self, obj: &FrameworkElement) -> Result<ComPtr<VisualStateManager>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetCustomVisualStateManager)(self as *const _ as *mut _, obj as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_custom_visual_state_manager(&self, obj: &FrameworkElement, value: &VisualStateManager) -> Result<()> {
        let hr = ((*self.lpVtbl).SetCustomVisualStateManager)(self as *const _ as *mut _, obj as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn go_to_state(&self, control: &controls::Control, stateName: &HStringArg, useTransitions: bool) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GoToState)(self as *const _ as *mut _, control as *const _ as *mut _, stateName.get(), useTransitions, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class VisualStateManager: IVisualStateManager}
impl RtActivatable<IVisualStateManagerStatics> for VisualStateManager {}
impl VisualStateManager {
    #[inline] pub fn get_visual_state_groups(obj: &FrameworkElement) -> Result<ComPtr<super::super::foundation::collections::IVector<VisualStateGroup>>> { unsafe {
        <Self as RtActivatable<IVisualStateManagerStatics>>::get_activation_factory().get_visual_state_groups(obj)
    }}
    #[inline] pub fn get_custom_visual_state_manager_property() -> Result<ComPtr<DependencyProperty>> { unsafe {
        <Self as RtActivatable<IVisualStateManagerStatics>>::get_activation_factory().get_custom_visual_state_manager_property()
    }}
    #[inline] pub fn get_custom_visual_state_manager(obj: &FrameworkElement) -> Result<ComPtr<VisualStateManager>> { unsafe {
        <Self as RtActivatable<IVisualStateManagerStatics>>::get_activation_factory().get_custom_visual_state_manager(obj)
    }}
    #[inline] pub fn set_custom_visual_state_manager(obj: &FrameworkElement, value: &VisualStateManager) -> Result<()> { unsafe {
        <Self as RtActivatable<IVisualStateManagerStatics>>::get_activation_factory().set_custom_visual_state_manager(obj, value)
    }}
    #[inline] pub fn go_to_state(control: &controls::Control, stateName: &HStringArg, useTransitions: bool) -> Result<bool> { unsafe {
        <Self as RtActivatable<IVisualStateManagerStatics>>::get_activation_factory().go_to_state(control, stateName, useTransitions)
    }}
}
DEFINE_CLSID!(VisualStateManager(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,86,105,115,117,97,108,83,116,97,116,101,77,97,110,97,103,101,114,0]) [CLSID_VisualStateManager]);
DEFINE_IID!(IID_IVisualStateManagerFactory, 2246416637, 42357, 18358, 158, 48, 56, 60, 208, 133, 133, 242);
RT_INTERFACE!{interface IVisualStateManagerFactory(IVisualStateManagerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IVisualStateManagerFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut VisualStateManager) -> HRESULT
}}
impl IVisualStateManagerFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<VisualStateManager>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
pub mod documents { // Windows.UI.Xaml.Documents
use ::prelude::*;
RT_ENUM! { enum LogicalDirection: i32 {
    Backward (LogicalDirection_Backward) = 0, Forward (LogicalDirection_Forward) = 1,
}}
RT_ENUM! { enum UnderlineStyle: i32 {
    None (UnderlineStyle_None) = 0, Single (UnderlineStyle_Single) = 1,
}}
RT_CLASS!{class BlockCollection: ::rt::gen::windows::foundation::collections::IVector<Block>}
RT_CLASS!{class InlineCollection: ::rt::gen::windows::foundation::collections::IVector<Inline>}
DEFINE_IID!(IID_ITextPointer, 2892528289, 27201, 17407, 133, 30, 69, 52, 138, 162, 207, 123);
RT_INTERFACE!{interface ITextPointer(ITextPointerVtbl): IInspectable(IInspectableVtbl) [IID_ITextPointer] {
    fn get_Parent(&self, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn get_VisualParent(&self, out: *mut *mut super::FrameworkElement) -> HRESULT,
    fn get_LogicalDirection(&self, out: *mut LogicalDirection) -> HRESULT,
    fn get_Offset(&self, out: *mut i32) -> HRESULT,
    fn GetCharacterRect(&self, direction: LogicalDirection, out: *mut ::rt::gen::windows::foundation::Rect) -> HRESULT,
    fn GetPositionAtOffset(&self, offset: i32, direction: LogicalDirection, out: *mut *mut TextPointer) -> HRESULT
}}
impl ITextPointer {
    #[inline] pub unsafe fn get_parent(&self) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Parent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_visual_parent(&self) -> Result<ComPtr<super::FrameworkElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VisualParent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_logical_direction(&self) -> Result<LogicalDirection> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LogicalDirection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_offset(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Offset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_character_rect(&self, direction: LogicalDirection) -> Result<::rt::gen::windows::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetCharacterRect)(self as *const _ as *mut _, direction, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_position_at_offset(&self, offset: i32, direction: LogicalDirection) -> Result<ComPtr<TextPointer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetPositionAtOffset)(self as *const _ as *mut _, offset, direction, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class TextPointer: ITextPointer}
DEFINE_IID!(IID_ITypography, 2255447509, 60055, 17067, 146, 136, 156, 1, 174, 188, 122, 151);
RT_INTERFACE!{interface ITypography(ITypographyVtbl): IInspectable(IInspectableVtbl) [IID_ITypography] {
    
}}
DEFINE_IID!(IID_ITypographyStatics, 1740237960, 27735, 19680, 149, 241, 212, 185, 237, 99, 47, 180);
RT_INTERFACE!{static interface ITypographyStatics(ITypographyStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ITypographyStatics] {
    fn get_AnnotationAlternatesProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetAnnotationAlternates(&self, element: *mut super::DependencyObject, out: *mut i32) -> HRESULT,
    fn SetAnnotationAlternates(&self, element: *mut super::DependencyObject, value: i32) -> HRESULT,
    fn get_EastAsianExpertFormsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetEastAsianExpertForms(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetEastAsianExpertForms(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_EastAsianLanguageProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetEastAsianLanguage(&self, element: *mut super::DependencyObject, out: *mut super::FontEastAsianLanguage) -> HRESULT,
    fn SetEastAsianLanguage(&self, element: *mut super::DependencyObject, value: super::FontEastAsianLanguage) -> HRESULT,
    fn get_EastAsianWidthsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetEastAsianWidths(&self, element: *mut super::DependencyObject, out: *mut super::FontEastAsianWidths) -> HRESULT,
    fn SetEastAsianWidths(&self, element: *mut super::DependencyObject, value: super::FontEastAsianWidths) -> HRESULT,
    fn get_StandardLigaturesProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStandardLigatures(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetStandardLigatures(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_ContextualLigaturesProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetContextualLigatures(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetContextualLigatures(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_DiscretionaryLigaturesProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetDiscretionaryLigatures(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetDiscretionaryLigatures(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_HistoricalLigaturesProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetHistoricalLigatures(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetHistoricalLigatures(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_StandardSwashesProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStandardSwashes(&self, element: *mut super::DependencyObject, out: *mut i32) -> HRESULT,
    fn SetStandardSwashes(&self, element: *mut super::DependencyObject, value: i32) -> HRESULT,
    fn get_ContextualSwashesProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetContextualSwashes(&self, element: *mut super::DependencyObject, out: *mut i32) -> HRESULT,
    fn SetContextualSwashes(&self, element: *mut super::DependencyObject, value: i32) -> HRESULT,
    fn get_ContextualAlternatesProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetContextualAlternates(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetContextualAlternates(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_StylisticAlternatesProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStylisticAlternates(&self, element: *mut super::DependencyObject, out: *mut i32) -> HRESULT,
    fn SetStylisticAlternates(&self, element: *mut super::DependencyObject, value: i32) -> HRESULT,
    fn get_StylisticSet1Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStylisticSet1(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetStylisticSet1(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_StylisticSet2Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStylisticSet2(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetStylisticSet2(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_StylisticSet3Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStylisticSet3(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetStylisticSet3(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_StylisticSet4Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStylisticSet4(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetStylisticSet4(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_StylisticSet5Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStylisticSet5(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetStylisticSet5(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_StylisticSet6Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStylisticSet6(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetStylisticSet6(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_StylisticSet7Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStylisticSet7(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetStylisticSet7(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_StylisticSet8Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStylisticSet8(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetStylisticSet8(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_StylisticSet9Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStylisticSet9(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetStylisticSet9(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_StylisticSet10Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStylisticSet10(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetStylisticSet10(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_StylisticSet11Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStylisticSet11(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetStylisticSet11(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_StylisticSet12Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStylisticSet12(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetStylisticSet12(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_StylisticSet13Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStylisticSet13(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetStylisticSet13(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_StylisticSet14Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStylisticSet14(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetStylisticSet14(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_StylisticSet15Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStylisticSet15(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetStylisticSet15(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_StylisticSet16Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStylisticSet16(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetStylisticSet16(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_StylisticSet17Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStylisticSet17(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetStylisticSet17(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_StylisticSet18Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStylisticSet18(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetStylisticSet18(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_StylisticSet19Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStylisticSet19(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetStylisticSet19(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_StylisticSet20Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetStylisticSet20(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetStylisticSet20(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_CapitalsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetCapitals(&self, element: *mut super::DependencyObject, out: *mut super::FontCapitals) -> HRESULT,
    fn SetCapitals(&self, element: *mut super::DependencyObject, value: super::FontCapitals) -> HRESULT,
    fn get_CapitalSpacingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetCapitalSpacing(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetCapitalSpacing(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_KerningProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetKerning(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetKerning(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_CaseSensitiveFormsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetCaseSensitiveForms(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetCaseSensitiveForms(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_HistoricalFormsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetHistoricalForms(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetHistoricalForms(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_FractionProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetFraction(&self, element: *mut super::DependencyObject, out: *mut super::FontFraction) -> HRESULT,
    fn SetFraction(&self, element: *mut super::DependencyObject, value: super::FontFraction) -> HRESULT,
    fn get_NumeralStyleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetNumeralStyle(&self, element: *mut super::DependencyObject, out: *mut super::FontNumeralStyle) -> HRESULT,
    fn SetNumeralStyle(&self, element: *mut super::DependencyObject, value: super::FontNumeralStyle) -> HRESULT,
    fn get_NumeralAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetNumeralAlignment(&self, element: *mut super::DependencyObject, out: *mut super::FontNumeralAlignment) -> HRESULT,
    fn SetNumeralAlignment(&self, element: *mut super::DependencyObject, value: super::FontNumeralAlignment) -> HRESULT,
    fn get_SlashedZeroProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetSlashedZero(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetSlashedZero(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_MathematicalGreekProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetMathematicalGreek(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetMathematicalGreek(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_VariantsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetVariants(&self, element: *mut super::DependencyObject, out: *mut super::FontVariants) -> HRESULT,
    fn SetVariants(&self, element: *mut super::DependencyObject, value: super::FontVariants) -> HRESULT
}}
impl ITypographyStatics {
    #[inline] pub unsafe fn get_annotation_alternates_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AnnotationAlternatesProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_annotation_alternates(&self, element: &super::DependencyObject) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetAnnotationAlternates)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_annotation_alternates(&self, element: &super::DependencyObject, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetAnnotationAlternates)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_east_asian_expert_forms_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EastAsianExpertFormsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_east_asian_expert_forms(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetEastAsianExpertForms)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_east_asian_expert_forms(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetEastAsianExpertForms)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_east_asian_language_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EastAsianLanguageProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_east_asian_language(&self, element: &super::DependencyObject) -> Result<super::FontEastAsianLanguage> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetEastAsianLanguage)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_east_asian_language(&self, element: &super::DependencyObject, value: super::FontEastAsianLanguage) -> Result<()> {
        let hr = ((*self.lpVtbl).SetEastAsianLanguage)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_east_asian_widths_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EastAsianWidthsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_east_asian_widths(&self, element: &super::DependencyObject) -> Result<super::FontEastAsianWidths> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetEastAsianWidths)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_east_asian_widths(&self, element: &super::DependencyObject, value: super::FontEastAsianWidths) -> Result<()> {
        let hr = ((*self.lpVtbl).SetEastAsianWidths)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_standard_ligatures_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StandardLigaturesProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_standard_ligatures(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStandardLigatures)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_standard_ligatures(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStandardLigatures)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contextual_ligatures_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContextualLigaturesProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contextual_ligatures(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetContextualLigatures)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_contextual_ligatures(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetContextualLigatures)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_discretionary_ligatures_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DiscretionaryLigaturesProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_discretionary_ligatures(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetDiscretionaryLigatures)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_discretionary_ligatures(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetDiscretionaryLigatures)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_historical_ligatures_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HistoricalLigaturesProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_historical_ligatures(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetHistoricalLigatures)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_historical_ligatures(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetHistoricalLigatures)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_standard_swashes_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StandardSwashesProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_standard_swashes(&self, element: &super::DependencyObject) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStandardSwashes)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_standard_swashes(&self, element: &super::DependencyObject, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStandardSwashes)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contextual_swashes_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContextualSwashesProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contextual_swashes(&self, element: &super::DependencyObject) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetContextualSwashes)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_contextual_swashes(&self, element: &super::DependencyObject, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetContextualSwashes)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contextual_alternates_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContextualAlternatesProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contextual_alternates(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetContextualAlternates)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_contextual_alternates(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetContextualAlternates)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_alternates_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StylisticAlternatesProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_alternates(&self, element: &super::DependencyObject) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStylisticAlternates)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stylistic_alternates(&self, element: &super::DependencyObject, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStylisticAlternates)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set1_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StylisticSet1Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set1(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStylisticSet1)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stylistic_set1(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStylisticSet1)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set2_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StylisticSet2Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set2(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStylisticSet2)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stylistic_set2(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStylisticSet2)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set3_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StylisticSet3Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set3(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStylisticSet3)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stylistic_set3(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStylisticSet3)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set4_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StylisticSet4Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set4(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStylisticSet4)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stylistic_set4(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStylisticSet4)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set5_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StylisticSet5Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set5(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStylisticSet5)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stylistic_set5(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStylisticSet5)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set6_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StylisticSet6Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set6(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStylisticSet6)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stylistic_set6(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStylisticSet6)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set7_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StylisticSet7Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set7(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStylisticSet7)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stylistic_set7(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStylisticSet7)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set8_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StylisticSet8Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set8(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStylisticSet8)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stylistic_set8(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStylisticSet8)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set9_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StylisticSet9Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set9(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStylisticSet9)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stylistic_set9(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStylisticSet9)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set10_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StylisticSet10Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set10(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStylisticSet10)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stylistic_set10(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStylisticSet10)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set11_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StylisticSet11Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set11(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStylisticSet11)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stylistic_set11(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStylisticSet11)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set12_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StylisticSet12Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set12(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStylisticSet12)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stylistic_set12(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStylisticSet12)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set13_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StylisticSet13Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set13(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStylisticSet13)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stylistic_set13(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStylisticSet13)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set14_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StylisticSet14Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set14(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStylisticSet14)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stylistic_set14(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStylisticSet14)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set15_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StylisticSet15Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set15(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStylisticSet15)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stylistic_set15(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStylisticSet15)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set16_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StylisticSet16Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set16(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStylisticSet16)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stylistic_set16(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStylisticSet16)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set17_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StylisticSet17Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set17(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStylisticSet17)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stylistic_set17(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStylisticSet17)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set18_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StylisticSet18Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set18(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStylisticSet18)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stylistic_set18(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStylisticSet18)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set19_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StylisticSet19Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set19(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStylisticSet19)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stylistic_set19(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStylisticSet19)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set20_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StylisticSet20Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stylistic_set20(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetStylisticSet20)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stylistic_set20(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStylisticSet20)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_capitals_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CapitalsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_capitals(&self, element: &super::DependencyObject) -> Result<super::FontCapitals> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetCapitals)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_capitals(&self, element: &super::DependencyObject, value: super::FontCapitals) -> Result<()> {
        let hr = ((*self.lpVtbl).SetCapitals)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_capital_spacing_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CapitalSpacingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_capital_spacing(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetCapitalSpacing)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_capital_spacing(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetCapitalSpacing)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_kerning_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KerningProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_kerning(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetKerning)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_kerning(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetKerning)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_case_sensitive_forms_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CaseSensitiveFormsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_case_sensitive_forms(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetCaseSensitiveForms)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_case_sensitive_forms(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetCaseSensitiveForms)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_historical_forms_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HistoricalFormsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_historical_forms(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetHistoricalForms)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_historical_forms(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetHistoricalForms)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_fraction_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FractionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_fraction(&self, element: &super::DependencyObject) -> Result<super::FontFraction> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetFraction)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_fraction(&self, element: &super::DependencyObject, value: super::FontFraction) -> Result<()> {
        let hr = ((*self.lpVtbl).SetFraction)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_numeral_style_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NumeralStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_numeral_style(&self, element: &super::DependencyObject) -> Result<super::FontNumeralStyle> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetNumeralStyle)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_numeral_style(&self, element: &super::DependencyObject, value: super::FontNumeralStyle) -> Result<()> {
        let hr = ((*self.lpVtbl).SetNumeralStyle)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_numeral_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NumeralAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_numeral_alignment(&self, element: &super::DependencyObject) -> Result<super::FontNumeralAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetNumeralAlignment)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_numeral_alignment(&self, element: &super::DependencyObject, value: super::FontNumeralAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).SetNumeralAlignment)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_slashed_zero_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SlashedZeroProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_slashed_zero(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetSlashedZero)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_slashed_zero(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetSlashedZero)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_mathematical_greek_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MathematicalGreekProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_mathematical_greek(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetMathematicalGreek)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_mathematical_greek(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetMathematicalGreek)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_variants_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VariantsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_variants(&self, element: &super::DependencyObject) -> Result<super::FontVariants> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetVariants)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_variants(&self, element: &super::DependencyObject, value: super::FontVariants) -> Result<()> {
        let hr = ((*self.lpVtbl).SetVariants)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class Typography: ITypography}
impl RtActivatable<ITypographyStatics> for Typography {}
impl Typography {
    #[inline] pub fn get_annotation_alternates_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_annotation_alternates_property()
    }}
    #[inline] pub fn get_annotation_alternates(element: &super::DependencyObject) -> Result<i32> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_annotation_alternates(element)
    }}
    #[inline] pub fn set_annotation_alternates(element: &super::DependencyObject, value: i32) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_annotation_alternates(element, value)
    }}
    #[inline] pub fn get_east_asian_expert_forms_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_east_asian_expert_forms_property()
    }}
    #[inline] pub fn get_east_asian_expert_forms(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_east_asian_expert_forms(element)
    }}
    #[inline] pub fn set_east_asian_expert_forms(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_east_asian_expert_forms(element, value)
    }}
    #[inline] pub fn get_east_asian_language_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_east_asian_language_property()
    }}
    #[inline] pub fn get_east_asian_language(element: &super::DependencyObject) -> Result<super::FontEastAsianLanguage> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_east_asian_language(element)
    }}
    #[inline] pub fn set_east_asian_language(element: &super::DependencyObject, value: super::FontEastAsianLanguage) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_east_asian_language(element, value)
    }}
    #[inline] pub fn get_east_asian_widths_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_east_asian_widths_property()
    }}
    #[inline] pub fn get_east_asian_widths(element: &super::DependencyObject) -> Result<super::FontEastAsianWidths> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_east_asian_widths(element)
    }}
    #[inline] pub fn set_east_asian_widths(element: &super::DependencyObject, value: super::FontEastAsianWidths) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_east_asian_widths(element, value)
    }}
    #[inline] pub fn get_standard_ligatures_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_standard_ligatures_property()
    }}
    #[inline] pub fn get_standard_ligatures(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_standard_ligatures(element)
    }}
    #[inline] pub fn set_standard_ligatures(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_standard_ligatures(element, value)
    }}
    #[inline] pub fn get_contextual_ligatures_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_contextual_ligatures_property()
    }}
    #[inline] pub fn get_contextual_ligatures(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_contextual_ligatures(element)
    }}
    #[inline] pub fn set_contextual_ligatures(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_contextual_ligatures(element, value)
    }}
    #[inline] pub fn get_discretionary_ligatures_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_discretionary_ligatures_property()
    }}
    #[inline] pub fn get_discretionary_ligatures(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_discretionary_ligatures(element)
    }}
    #[inline] pub fn set_discretionary_ligatures(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_discretionary_ligatures(element, value)
    }}
    #[inline] pub fn get_historical_ligatures_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_historical_ligatures_property()
    }}
    #[inline] pub fn get_historical_ligatures(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_historical_ligatures(element)
    }}
    #[inline] pub fn set_historical_ligatures(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_historical_ligatures(element, value)
    }}
    #[inline] pub fn get_standard_swashes_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_standard_swashes_property()
    }}
    #[inline] pub fn get_standard_swashes(element: &super::DependencyObject) -> Result<i32> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_standard_swashes(element)
    }}
    #[inline] pub fn set_standard_swashes(element: &super::DependencyObject, value: i32) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_standard_swashes(element, value)
    }}
    #[inline] pub fn get_contextual_swashes_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_contextual_swashes_property()
    }}
    #[inline] pub fn get_contextual_swashes(element: &super::DependencyObject) -> Result<i32> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_contextual_swashes(element)
    }}
    #[inline] pub fn set_contextual_swashes(element: &super::DependencyObject, value: i32) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_contextual_swashes(element, value)
    }}
    #[inline] pub fn get_contextual_alternates_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_contextual_alternates_property()
    }}
    #[inline] pub fn get_contextual_alternates(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_contextual_alternates(element)
    }}
    #[inline] pub fn set_contextual_alternates(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_contextual_alternates(element, value)
    }}
    #[inline] pub fn get_stylistic_alternates_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_alternates_property()
    }}
    #[inline] pub fn get_stylistic_alternates(element: &super::DependencyObject) -> Result<i32> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_alternates(element)
    }}
    #[inline] pub fn set_stylistic_alternates(element: &super::DependencyObject, value: i32) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_stylistic_alternates(element, value)
    }}
    #[inline] pub fn get_stylistic_set1_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set1_property()
    }}
    #[inline] pub fn get_stylistic_set1(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set1(element)
    }}
    #[inline] pub fn set_stylistic_set1(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_stylistic_set1(element, value)
    }}
    #[inline] pub fn get_stylistic_set2_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set2_property()
    }}
    #[inline] pub fn get_stylistic_set2(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set2(element)
    }}
    #[inline] pub fn set_stylistic_set2(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_stylistic_set2(element, value)
    }}
    #[inline] pub fn get_stylistic_set3_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set3_property()
    }}
    #[inline] pub fn get_stylistic_set3(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set3(element)
    }}
    #[inline] pub fn set_stylistic_set3(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_stylistic_set3(element, value)
    }}
    #[inline] pub fn get_stylistic_set4_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set4_property()
    }}
    #[inline] pub fn get_stylistic_set4(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set4(element)
    }}
    #[inline] pub fn set_stylistic_set4(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_stylistic_set4(element, value)
    }}
    #[inline] pub fn get_stylistic_set5_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set5_property()
    }}
    #[inline] pub fn get_stylistic_set5(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set5(element)
    }}
    #[inline] pub fn set_stylistic_set5(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_stylistic_set5(element, value)
    }}
    #[inline] pub fn get_stylistic_set6_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set6_property()
    }}
    #[inline] pub fn get_stylistic_set6(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set6(element)
    }}
    #[inline] pub fn set_stylistic_set6(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_stylistic_set6(element, value)
    }}
    #[inline] pub fn get_stylistic_set7_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set7_property()
    }}
    #[inline] pub fn get_stylistic_set7(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set7(element)
    }}
    #[inline] pub fn set_stylistic_set7(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_stylistic_set7(element, value)
    }}
    #[inline] pub fn get_stylistic_set8_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set8_property()
    }}
    #[inline] pub fn get_stylistic_set8(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set8(element)
    }}
    #[inline] pub fn set_stylistic_set8(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_stylistic_set8(element, value)
    }}
    #[inline] pub fn get_stylistic_set9_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set9_property()
    }}
    #[inline] pub fn get_stylistic_set9(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set9(element)
    }}
    #[inline] pub fn set_stylistic_set9(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_stylistic_set9(element, value)
    }}
    #[inline] pub fn get_stylistic_set10_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set10_property()
    }}
    #[inline] pub fn get_stylistic_set10(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set10(element)
    }}
    #[inline] pub fn set_stylistic_set10(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_stylistic_set10(element, value)
    }}
    #[inline] pub fn get_stylistic_set11_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set11_property()
    }}
    #[inline] pub fn get_stylistic_set11(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set11(element)
    }}
    #[inline] pub fn set_stylistic_set11(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_stylistic_set11(element, value)
    }}
    #[inline] pub fn get_stylistic_set12_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set12_property()
    }}
    #[inline] pub fn get_stylistic_set12(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set12(element)
    }}
    #[inline] pub fn set_stylistic_set12(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_stylistic_set12(element, value)
    }}
    #[inline] pub fn get_stylistic_set13_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set13_property()
    }}
    #[inline] pub fn get_stylistic_set13(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set13(element)
    }}
    #[inline] pub fn set_stylistic_set13(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_stylistic_set13(element, value)
    }}
    #[inline] pub fn get_stylistic_set14_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set14_property()
    }}
    #[inline] pub fn get_stylistic_set14(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set14(element)
    }}
    #[inline] pub fn set_stylistic_set14(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_stylistic_set14(element, value)
    }}
    #[inline] pub fn get_stylistic_set15_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set15_property()
    }}
    #[inline] pub fn get_stylistic_set15(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set15(element)
    }}
    #[inline] pub fn set_stylistic_set15(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_stylistic_set15(element, value)
    }}
    #[inline] pub fn get_stylistic_set16_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set16_property()
    }}
    #[inline] pub fn get_stylistic_set16(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set16(element)
    }}
    #[inline] pub fn set_stylistic_set16(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_stylistic_set16(element, value)
    }}
    #[inline] pub fn get_stylistic_set17_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set17_property()
    }}
    #[inline] pub fn get_stylistic_set17(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set17(element)
    }}
    #[inline] pub fn set_stylistic_set17(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_stylistic_set17(element, value)
    }}
    #[inline] pub fn get_stylistic_set18_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set18_property()
    }}
    #[inline] pub fn get_stylistic_set18(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set18(element)
    }}
    #[inline] pub fn set_stylistic_set18(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_stylistic_set18(element, value)
    }}
    #[inline] pub fn get_stylistic_set19_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set19_property()
    }}
    #[inline] pub fn get_stylistic_set19(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set19(element)
    }}
    #[inline] pub fn set_stylistic_set19(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_stylistic_set19(element, value)
    }}
    #[inline] pub fn get_stylistic_set20_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set20_property()
    }}
    #[inline] pub fn get_stylistic_set20(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_stylistic_set20(element)
    }}
    #[inline] pub fn set_stylistic_set20(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_stylistic_set20(element, value)
    }}
    #[inline] pub fn get_capitals_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_capitals_property()
    }}
    #[inline] pub fn get_capitals(element: &super::DependencyObject) -> Result<super::FontCapitals> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_capitals(element)
    }}
    #[inline] pub fn set_capitals(element: &super::DependencyObject, value: super::FontCapitals) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_capitals(element, value)
    }}
    #[inline] pub fn get_capital_spacing_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_capital_spacing_property()
    }}
    #[inline] pub fn get_capital_spacing(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_capital_spacing(element)
    }}
    #[inline] pub fn set_capital_spacing(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_capital_spacing(element, value)
    }}
    #[inline] pub fn get_kerning_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_kerning_property()
    }}
    #[inline] pub fn get_kerning(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_kerning(element)
    }}
    #[inline] pub fn set_kerning(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_kerning(element, value)
    }}
    #[inline] pub fn get_case_sensitive_forms_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_case_sensitive_forms_property()
    }}
    #[inline] pub fn get_case_sensitive_forms(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_case_sensitive_forms(element)
    }}
    #[inline] pub fn set_case_sensitive_forms(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_case_sensitive_forms(element, value)
    }}
    #[inline] pub fn get_historical_forms_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_historical_forms_property()
    }}
    #[inline] pub fn get_historical_forms(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_historical_forms(element)
    }}
    #[inline] pub fn set_historical_forms(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_historical_forms(element, value)
    }}
    #[inline] pub fn get_fraction_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_fraction_property()
    }}
    #[inline] pub fn get_fraction(element: &super::DependencyObject) -> Result<super::FontFraction> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_fraction(element)
    }}
    #[inline] pub fn set_fraction(element: &super::DependencyObject, value: super::FontFraction) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_fraction(element, value)
    }}
    #[inline] pub fn get_numeral_style_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_numeral_style_property()
    }}
    #[inline] pub fn get_numeral_style(element: &super::DependencyObject) -> Result<super::FontNumeralStyle> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_numeral_style(element)
    }}
    #[inline] pub fn set_numeral_style(element: &super::DependencyObject, value: super::FontNumeralStyle) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_numeral_style(element, value)
    }}
    #[inline] pub fn get_numeral_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_numeral_alignment_property()
    }}
    #[inline] pub fn get_numeral_alignment(element: &super::DependencyObject) -> Result<super::FontNumeralAlignment> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_numeral_alignment(element)
    }}
    #[inline] pub fn set_numeral_alignment(element: &super::DependencyObject, value: super::FontNumeralAlignment) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_numeral_alignment(element, value)
    }}
    #[inline] pub fn get_slashed_zero_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_slashed_zero_property()
    }}
    #[inline] pub fn get_slashed_zero(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_slashed_zero(element)
    }}
    #[inline] pub fn set_slashed_zero(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_slashed_zero(element, value)
    }}
    #[inline] pub fn get_mathematical_greek_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_mathematical_greek_property()
    }}
    #[inline] pub fn get_mathematical_greek(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_mathematical_greek(element)
    }}
    #[inline] pub fn set_mathematical_greek(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_mathematical_greek(element, value)
    }}
    #[inline] pub fn get_variants_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_variants_property()
    }}
    #[inline] pub fn get_variants(element: &super::DependencyObject) -> Result<super::FontVariants> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().get_variants(element)
    }}
    #[inline] pub fn set_variants(element: &super::DependencyObject, value: super::FontVariants) -> Result<()> { unsafe {
        <Self as RtActivatable<ITypographyStatics>>::get_activation_factory().set_variants(element, value)
    }}
}
DEFINE_CLSID!(Typography(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,68,111,99,117,109,101,110,116,115,46,84,121,112,111,103,114,97,112,104,121,0]) [CLSID_Typography]);
DEFINE_IID!(IID_ITextElement, 3896180834, 55158, 20370, 186, 234, 64, 231, 125, 71, 145, 213);
RT_INTERFACE!{interface ITextElement(ITextElementVtbl): IInspectable(IInspectableVtbl) [IID_ITextElement] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FontSize(&self, out: *mut f64) -> HRESULT,
    fn put_FontSize(&self, value: f64) -> HRESULT,
    fn get_FontFamily(&self, out: *mut *mut super::media::FontFamily) -> HRESULT,
    fn put_FontFamily(&self, value: *mut super::media::FontFamily) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FontWeight(&self, out: *mut super::super::text::FontWeight) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_FontWeight(&self, value: super::super::text::FontWeight) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FontStyle(&self, out: *mut super::super::text::FontStyle) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_FontStyle(&self, value: super::super::text::FontStyle) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy9(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FontStretch(&self, out: *mut super::super::text::FontStretch) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy10(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_FontStretch(&self, value: super::super::text::FontStretch) -> HRESULT,
    fn get_CharacterSpacing(&self, out: *mut i32) -> HRESULT,
    fn put_CharacterSpacing(&self, value: i32) -> HRESULT,
    fn get_Foreground(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_Foreground(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Language(&self, value: HSTRING) -> HRESULT,
    fn get_ContentStart(&self, out: *mut *mut TextPointer) -> HRESULT,
    fn get_ContentEnd(&self, out: *mut *mut TextPointer) -> HRESULT,
    fn get_ElementStart(&self, out: *mut *mut TextPointer) -> HRESULT,
    fn get_ElementEnd(&self, out: *mut *mut TextPointer) -> HRESULT,
    fn FindName(&self, name: HSTRING, out: *mut *mut IInspectable) -> HRESULT
}}
impl ITextElement {
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_size(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_font_size(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontSize)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_family(&self) -> Result<ComPtr<super::media::FontFamily>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontFamily)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_font_family(&self, value: &super::media::FontFamily) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontFamily)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_font_weight(&self) -> Result<super::super::text::FontWeight> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontWeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_font_weight(&self, value: super::super::text::FontWeight) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontWeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_font_style(&self) -> Result<super::super::text::FontStyle> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_font_style(&self, value: super::super::text::FontStyle) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontStyle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_font_stretch(&self) -> Result<super::super::text::FontStretch> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontStretch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_font_stretch(&self, value: super::super::text::FontStretch) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontStretch)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_character_spacing(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CharacterSpacing)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_character_spacing(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CharacterSpacing)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_foreground(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Foreground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_foreground(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Foreground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_language(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Language)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_language(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Language)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_start(&self) -> Result<ComPtr<TextPointer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentStart)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_end(&self) -> Result<ComPtr<TextPointer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentEnd)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_element_start(&self) -> Result<ComPtr<TextPointer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ElementStart)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_element_end(&self) -> Result<ComPtr<TextPointer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ElementEnd)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_name(&self, name: &HStringArg) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindName)(self as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextElementOverrides, 216145639, 20342, 19929, 191, 145, 22, 59, 236, 207, 132, 188);
RT_INTERFACE!{interface ITextElementOverrides(ITextElementOverridesVtbl): IInspectable(IInspectableVtbl) [IID_ITextElementOverrides] {
    fn OnDisconnectVisualChildren(&self) -> HRESULT
}}
impl ITextElementOverrides {
    #[inline] pub unsafe fn on_disconnect_visual_children(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).OnDisconnectVisualChildren)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextElementStatics, 170892184, 27651, 17520, 167, 155, 50, 152, 161, 4, 130, 206);
RT_INTERFACE!{static interface ITextElementStatics(ITextElementStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ITextElementStatics] {
    fn get_FontSizeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontFamilyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontWeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontStyleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontStretchProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CharacterSpacingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ForegroundProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_LanguageProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ITextElementStatics {
    #[inline] pub unsafe fn get_font_size_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontSizeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_family_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontFamilyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_weight_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontWeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_style_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_stretch_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontStretchProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_character_spacing_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CharacterSpacingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_foreground_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ForegroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_language_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LanguageProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextElementFactory, 889221765, 53063, 19454, 177, 188, 57, 201, 58, 244, 174, 128);
RT_INTERFACE!{interface ITextElementFactory(ITextElementFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ITextElementFactory] {
    
}}
DEFINE_IID!(IID_ITextElement2, 2819058344, 63634, 18934, 140, 210, 137, 173, 218, 240, 109, 45);
RT_INTERFACE!{interface ITextElement2(ITextElement2Vtbl): IInspectable(IInspectableVtbl) [IID_ITextElement2] {
    fn get_IsTextScaleFactorEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsTextScaleFactorEnabled(&self, value: bool) -> HRESULT
}}
impl ITextElement2 {
    #[inline] pub unsafe fn get_is_text_scale_factor_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTextScaleFactorEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_text_scale_factor_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsTextScaleFactorEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextElementStatics2, 373462962, 38955, 18913, 140, 3, 202, 67, 188, 77, 91, 109);
RT_INTERFACE!{static interface ITextElementStatics2(ITextElementStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_ITextElementStatics2] {
    fn get_IsTextScaleFactorEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ITextElementStatics2 {
    #[inline] pub unsafe fn get_is_text_scale_factor_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsTextScaleFactorEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextElement3, 3520803855, 7108, 19624, 188, 247, 119, 11, 255, 155, 39, 171);
RT_INTERFACE!{interface ITextElement3(ITextElement3Vtbl): IInspectable(IInspectableVtbl) [IID_ITextElement3] {
    fn get_AllowFocusOnInteraction(&self, out: *mut bool) -> HRESULT,
    fn put_AllowFocusOnInteraction(&self, value: bool) -> HRESULT,
    fn get_AccessKey(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AccessKey(&self, value: HSTRING) -> HRESULT,
    fn get_ExitDisplayModeOnAccessKeyInvoked(&self, out: *mut bool) -> HRESULT,
    fn put_ExitDisplayModeOnAccessKeyInvoked(&self, value: bool) -> HRESULT
}}
impl ITextElement3 {
    #[inline] pub unsafe fn get_allow_focus_on_interaction(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AllowFocusOnInteraction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_allow_focus_on_interaction(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AllowFocusOnInteraction)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_access_key(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AccessKey)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_access_key(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AccessKey)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_exit_display_mode_on_access_key_invoked(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExitDisplayModeOnAccessKeyInvoked)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_exit_display_mode_on_access_key_invoked(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ExitDisplayModeOnAccessKeyInvoked)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextElementStatics3, 3488599983, 4001, 17900, 154, 78, 155, 51, 102, 77, 200, 177);
RT_INTERFACE!{static interface ITextElementStatics3(ITextElementStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_ITextElementStatics3] {
    fn get_AllowFocusOnInteractionProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_AccessKeyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ExitDisplayModeOnAccessKeyInvokedProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ITextElementStatics3 {
    #[inline] pub unsafe fn get_allow_focus_on_interaction_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AllowFocusOnInteractionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_access_key_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AccessKeyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_exit_display_mode_on_access_key_invoked_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExitDisplayModeOnAccessKeyInvokedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextElement4, 2979455522, 51726, 18601, 131, 188, 54, 206, 80, 86, 106, 199);
RT_INTERFACE!{interface ITextElement4(ITextElement4Vtbl): IInspectable(IInspectableVtbl) [IID_ITextElement4] {
    #[cfg(not(feature="windows-ui"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_TextDecorations(&self, out: *mut super::super::text::TextDecorations) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_TextDecorations(&self, value: super::super::text::TextDecorations) -> HRESULT,
    fn get_IsAccessKeyScope(&self, out: *mut bool) -> HRESULT,
    fn put_IsAccessKeyScope(&self, value: bool) -> HRESULT,
    fn get_AccessKeyScopeOwner(&self, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn put_AccessKeyScopeOwner(&self, value: *mut super::DependencyObject) -> HRESULT,
    fn get_KeyTipPlacementMode(&self, out: *mut super::input::KeyTipPlacementMode) -> HRESULT,
    fn put_KeyTipPlacementMode(&self, value: super::input::KeyTipPlacementMode) -> HRESULT,
    fn get_KeyTipHorizontalOffset(&self, out: *mut f64) -> HRESULT,
    fn put_KeyTipHorizontalOffset(&self, value: f64) -> HRESULT,
    fn get_KeyTipVerticalOffset(&self, out: *mut f64) -> HRESULT,
    fn put_KeyTipVerticalOffset(&self, value: f64) -> HRESULT,
    fn add_AccessKeyDisplayRequested(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<TextElement, super::input::AccessKeyDisplayRequestedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AccessKeyDisplayRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_AccessKeyDisplayDismissed(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<TextElement, super::input::AccessKeyDisplayDismissedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AccessKeyDisplayDismissed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_AccessKeyInvoked(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<TextElement, super::input::AccessKeyInvokedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AccessKeyInvoked(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl ITextElement4 {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_text_decorations(&self) -> Result<super::super::text::TextDecorations> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextDecorations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_text_decorations(&self, value: super::super::text::TextDecorations) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextDecorations)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_access_key_scope(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsAccessKeyScope)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_access_key_scope(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsAccessKeyScope)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_access_key_scope_owner(&self) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AccessKeyScopeOwner)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_access_key_scope_owner(&self, value: &super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AccessKeyScopeOwner)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_key_tip_placement_mode(&self) -> Result<super::input::KeyTipPlacementMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeyTipPlacementMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_key_tip_placement_mode(&self, value: super::input::KeyTipPlacementMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_KeyTipPlacementMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_key_tip_horizontal_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeyTipHorizontalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_key_tip_horizontal_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_KeyTipHorizontalOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_key_tip_vertical_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeyTipVerticalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_key_tip_vertical_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_KeyTipVerticalOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_access_key_display_requested(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<TextElement, super::input::AccessKeyDisplayRequestedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_AccessKeyDisplayRequested)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_access_key_display_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_AccessKeyDisplayRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_access_key_display_dismissed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<TextElement, super::input::AccessKeyDisplayDismissedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_AccessKeyDisplayDismissed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_access_key_display_dismissed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_AccessKeyDisplayDismissed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_access_key_invoked(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<TextElement, super::input::AccessKeyInvokedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_AccessKeyInvoked)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_access_key_invoked(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_AccessKeyInvoked)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextElementStatics4, 4254032926, 27410, 16597, 182, 239, 209, 189, 18, 172, 144, 102);
RT_INTERFACE!{static interface ITextElementStatics4(ITextElementStatics4Vtbl): IInspectable(IInspectableVtbl) [IID_ITextElementStatics4] {
    fn get_TextDecorationsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsAccessKeyScopeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_AccessKeyScopeOwnerProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_KeyTipPlacementModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_KeyTipHorizontalOffsetProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_KeyTipVerticalOffsetProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ITextElementStatics4 {
    #[inline] pub unsafe fn get_text_decorations_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextDecorationsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_access_key_scope_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsAccessKeyScopeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_access_key_scope_owner_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AccessKeyScopeOwnerProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_key_tip_placement_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeyTipPlacementModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_key_tip_horizontal_offset_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeyTipHorizontalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_key_tip_vertical_offset_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeyTipVerticalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBlock, 1271791638, 56647, 17232, 140, 176, 225, 113, 96, 10, 200, 150);
RT_INTERFACE!{interface IBlock(IBlockVtbl): IInspectable(IInspectableVtbl) [IID_IBlock] {
    fn get_TextAlignment(&self, out: *mut super::TextAlignment) -> HRESULT,
    fn put_TextAlignment(&self, value: super::TextAlignment) -> HRESULT,
    fn get_LineHeight(&self, out: *mut f64) -> HRESULT,
    fn put_LineHeight(&self, value: f64) -> HRESULT,
    fn get_LineStackingStrategy(&self, out: *mut super::LineStackingStrategy) -> HRESULT,
    fn put_LineStackingStrategy(&self, value: super::LineStackingStrategy) -> HRESULT,
    fn get_Margin(&self, out: *mut super::Thickness) -> HRESULT,
    fn put_Margin(&self, value: super::Thickness) -> HRESULT
}}
impl IBlock {
    #[inline] pub unsafe fn get_text_alignment(&self) -> Result<super::TextAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_alignment(&self, value: super::TextAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_line_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LineHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_line_height(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LineHeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_line_stacking_strategy(&self) -> Result<super::LineStackingStrategy> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LineStackingStrategy)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_line_stacking_strategy(&self, value: super::LineStackingStrategy) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LineStackingStrategy)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_margin(&self) -> Result<super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Margin)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_margin(&self, value: super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Margin)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBlockStatics, 4167732276, 36120, 19539, 174, 189, 145, 230, 16, 165, 224, 16);
RT_INTERFACE!{static interface IBlockStatics(IBlockStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBlockStatics] {
    fn get_TextAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_LineHeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_LineStackingStrategyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MarginProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IBlockStatics {
    #[inline] pub unsafe fn get_text_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_line_height_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LineHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_line_stacking_strategy_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LineStackingStrategyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_margin_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MarginProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBlockFactory, 118555954, 20313, 20283, 156, 229, 37, 120, 76, 67, 5, 7);
RT_INTERFACE!{interface IBlockFactory(IBlockFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IBlockFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut Block) -> HRESULT
}}
impl IBlockFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<Block>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInline, 210923821, 7113, 18737, 140, 177, 26, 234, 223, 28, 198, 133);
RT_INTERFACE!{interface IInline(IInlineVtbl): IInspectable(IInspectableVtbl) [IID_IInline] {
    
}}
DEFINE_IID!(IID_IInlineFactory, 1079553233, 12176, 19343, 153, 221, 66, 24, 239, 95, 3, 222);
RT_INTERFACE!{interface IInlineFactory(IInlineFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInlineFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut Inline) -> HRESULT
}}
impl IInlineFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<Inline>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInlineUIContainer, 337038977, 10478, 17710, 177, 33, 95, 196, 246, 11, 134, 166);
RT_INTERFACE!{interface IInlineUIContainer(IInlineUIContainerVtbl): IInspectable(IInspectableVtbl) [IID_IInlineUIContainer] {
    fn get_Child(&self, out: *mut *mut super::UIElement) -> HRESULT,
    fn put_Child(&self, value: *mut super::UIElement) -> HRESULT
}}
impl IInlineUIContainer {
    #[inline] pub unsafe fn get_child(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Child)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_child(&self, value: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Child)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ILineBreak, 1683327428, 63337, 16877, 137, 91, 138, 27, 47, 179, 21, 98);
RT_INTERFACE!{interface ILineBreak(ILineBreakVtbl): IInspectable(IInspectableVtbl) [IID_ILineBreak] {
    
}}
DEFINE_IID!(IID_IParagraph, 4164875674, 64097, 19439, 174, 51, 11, 10, 215, 86, 168, 77);
RT_INTERFACE!{interface IParagraph(IParagraphVtbl): IInspectable(IInspectableVtbl) [IID_IParagraph] {
    fn get_Inlines(&self, out: *mut *mut InlineCollection) -> HRESULT,
    fn get_TextIndent(&self, out: *mut f64) -> HRESULT,
    fn put_TextIndent(&self, value: f64) -> HRESULT
}}
impl IParagraph {
    #[inline] pub unsafe fn get_inlines(&self) -> Result<ComPtr<InlineCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Inlines)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_indent(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextIndent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_indent(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextIndent)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IParagraphStatics, 4010313882, 21339, 20044, 141, 132, 40, 59, 51, 233, 138, 55);
RT_INTERFACE!{static interface IParagraphStatics(IParagraphStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IParagraphStatics] {
    fn get_TextIndentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IParagraphStatics {
    #[inline] pub unsafe fn get_text_indent_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextIndentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRun, 1498758275, 3604, 18877, 184, 75, 197, 38, 243, 3, 67, 73);
RT_INTERFACE!{interface IRun(IRunVtbl): IInspectable(IInspectableVtbl) [IID_IRun] {
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Text(&self, value: HSTRING) -> HRESULT,
    fn get_FlowDirection(&self, out: *mut super::FlowDirection) -> HRESULT,
    fn put_FlowDirection(&self, value: super::FlowDirection) -> HRESULT
}}
impl IRun {
    #[inline] pub unsafe fn get_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Text)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Text)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_flow_direction(&self) -> Result<super::FlowDirection> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FlowDirection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_flow_direction(&self, value: super::FlowDirection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FlowDirection)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRunStatics, 3912252655, 26016, 19341, 167, 247, 143, 219, 40, 123, 70, 243);
RT_INTERFACE!{static interface IRunStatics(IRunStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRunStatics] {
    fn get_FlowDirectionProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IRunStatics {
    #[inline] pub unsafe fn get_flow_direction_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FlowDirectionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISpan, 2553926825, 687, 18449, 170, 21, 107, 239, 58, 202, 201, 122);
RT_INTERFACE!{interface ISpan(ISpanVtbl): IInspectable(IInspectableVtbl) [IID_ISpan] {
    fn get_Inlines(&self, out: *mut *mut InlineCollection) -> HRESULT,
    fn put_Inlines(&self, value: *mut InlineCollection) -> HRESULT
}}
impl ISpan {
    #[inline] pub unsafe fn get_inlines(&self) -> Result<ComPtr<InlineCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Inlines)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_inlines(&self, value: &InlineCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Inlines)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISpanFactory, 1536257884, 52525, 16576, 149, 106, 56, 100, 72, 50, 47, 121);
RT_INTERFACE!{interface ISpanFactory(ISpanFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISpanFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut Span) -> HRESULT
}}
impl ISpanFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<Span>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBold, 2917611396, 7001, 19876, 187, 35, 15, 32, 232, 133, 180, 191);
RT_INTERFACE!{interface IBold(IBoldVtbl): IInspectable(IInspectableVtbl) [IID_IBold] {
    
}}
DEFINE_IID!(IID_IItalic, 2448712092, 64699, 16727, 128, 44, 118, 246, 59, 95, 182, 87);
RT_INTERFACE!{interface IItalic(IItalicVtbl): IInspectable(IInspectableVtbl) [IID_IItalic] {
    
}}
DEFINE_IID!(IID_IUnderline, 2784657922, 25024, 18391, 147, 239, 188, 11, 87, 124, 95, 38);
RT_INTERFACE!{interface IUnderline(IUnderlineVtbl): IInspectable(IInspectableVtbl) [IID_IUnderline] {
    
}}
DEFINE_IID!(IID_IHyperlinkClickEventArgs, 3344273771, 31708, 19431, 179, 115, 146, 64, 165, 3, 216, 112);
RT_INTERFACE!{interface IHyperlinkClickEventArgs(IHyperlinkClickEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IHyperlinkClickEventArgs] {
    
}}
DEFINE_IID!(IID_IGlyphs, 3497609611, 62129, 17025, 153, 162, 228, 208, 89, 50, 178, 181);
RT_INTERFACE!{interface IGlyphs(IGlyphsVtbl): IInspectable(IInspectableVtbl) [IID_IGlyphs] {
    fn get_UnicodeString(&self, out: *mut HSTRING) -> HRESULT,
    fn put_UnicodeString(&self, value: HSTRING) -> HRESULT,
    fn get_Indices(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Indices(&self, value: HSTRING) -> HRESULT,
    fn get_FontUri(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn put_FontUri(&self, value: *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn get_StyleSimulations(&self, out: *mut super::media::StyleSimulations) -> HRESULT,
    fn put_StyleSimulations(&self, value: super::media::StyleSimulations) -> HRESULT,
    fn get_FontRenderingEmSize(&self, out: *mut f64) -> HRESULT,
    fn put_FontRenderingEmSize(&self, value: f64) -> HRESULT,
    fn get_OriginX(&self, out: *mut f64) -> HRESULT,
    fn put_OriginX(&self, value: f64) -> HRESULT,
    fn get_OriginY(&self, out: *mut f64) -> HRESULT,
    fn put_OriginY(&self, value: f64) -> HRESULT,
    fn get_Fill(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_Fill(&self, value: *mut super::media::Brush) -> HRESULT
}}
impl IGlyphs {
    #[inline] pub unsafe fn get_unicode_string(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UnicodeString)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_unicode_string(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_UnicodeString)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_indices(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Indices)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_indices(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Indices)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_font_uri(&self, value: &::rt::gen::windows::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontUri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_style_simulations(&self) -> Result<super::media::StyleSimulations> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StyleSimulations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_style_simulations(&self, value: super::media::StyleSimulations) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StyleSimulations)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_rendering_em_size(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontRenderingEmSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_font_rendering_em_size(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontRenderingEmSize)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_origin_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OriginX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_origin_x(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OriginX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_origin_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OriginY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_origin_y(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OriginY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_fill(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Fill)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_fill(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Fill)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGlyphsStatics, 576517317, 65009, 17389, 149, 143, 65, 78, 134, 241, 3, 242);
RT_INTERFACE!{static interface IGlyphsStatics(IGlyphsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGlyphsStatics] {
    fn get_UnicodeStringProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IndicesProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontUriProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_StyleSimulationsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontRenderingEmSizeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OriginXProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OriginYProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FillProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IGlyphsStatics {
    #[inline] pub unsafe fn get_unicode_string_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UnicodeStringProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_indices_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IndicesProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_uri_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontUriProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_style_simulations_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StyleSimulationsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_rendering_em_size_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontRenderingEmSizeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_origin_xproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OriginXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_origin_yproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OriginYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_fill_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FillProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGlyphs2, 2861301340, 14164, 19438, 187, 225, 68, 3, 238, 155, 134, 240);
RT_INTERFACE!{interface IGlyphs2(IGlyphs2Vtbl): IInspectable(IInspectableVtbl) [IID_IGlyphs2] {
    fn get_IsColorFontEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsColorFontEnabled(&self, value: bool) -> HRESULT,
    fn get_ColorFontPaletteIndex(&self, out: *mut i32) -> HRESULT,
    fn put_ColorFontPaletteIndex(&self, value: i32) -> HRESULT
}}
impl IGlyphs2 {
    #[inline] pub unsafe fn get_is_color_font_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsColorFontEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_color_font_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsColorFontEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_color_font_palette_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ColorFontPaletteIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_color_font_palette_index(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ColorFontPaletteIndex)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGlyphsStatics2, 273193639, 5653, 18995, 170, 2, 215, 239, 42, 239, 199, 57);
RT_INTERFACE!{static interface IGlyphsStatics2(IGlyphsStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IGlyphsStatics2] {
    fn get_IsColorFontEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ColorFontPaletteIndexProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IGlyphsStatics2 {
    #[inline] pub unsafe fn get_is_color_font_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsColorFontEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_color_font_palette_index_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ColorFontPaletteIndexProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IHyperlink, 266483259, 5353, 16722, 158, 88, 90, 234, 91, 33, 240, 141);
RT_INTERFACE!{interface IHyperlink(IHyperlinkVtbl): IInspectable(IInspectableVtbl) [IID_IHyperlink] {
    fn get_NavigateUri(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn put_NavigateUri(&self, value: *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn add_Click(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<Hyperlink, HyperlinkClickEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Click(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IHyperlink {
    #[inline] pub unsafe fn get_navigate_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NavigateUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_navigate_uri(&self, value: &::rt::gen::windows::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_NavigateUri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_click(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<Hyperlink, HyperlinkClickEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Click)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_click(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Click)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IHyperlinkStatics, 977589204, 64833, 16859, 140, 114, 59, 121, 10, 205, 159, 211);
RT_INTERFACE!{static interface IHyperlinkStatics(IHyperlinkStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IHyperlinkStatics] {
    fn get_NavigateUriProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IHyperlinkStatics {
    #[inline] pub unsafe fn get_navigate_uri_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NavigateUriProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IHyperlink2, 1290394207, 31999, 17041, 183, 143, 223, 236, 114, 73, 5, 118);
RT_INTERFACE!{interface IHyperlink2(IHyperlink2Vtbl): IInspectable(IInspectableVtbl) [IID_IHyperlink2] {
    fn get_UnderlineStyle(&self, out: *mut UnderlineStyle) -> HRESULT,
    fn put_UnderlineStyle(&self, value: UnderlineStyle) -> HRESULT
}}
impl IHyperlink2 {
    #[inline] pub unsafe fn get_underline_style(&self) -> Result<UnderlineStyle> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_UnderlineStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_underline_style(&self, value: UnderlineStyle) -> Result<()> {
        let hr = ((*self.lpVtbl).put_UnderlineStyle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IHyperlinkStatics2, 1344854199, 31455, 17390, 164, 174, 156, 146, 95, 117, 87, 22);
RT_INTERFACE!{static interface IHyperlinkStatics2(IHyperlinkStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IHyperlinkStatics2] {
    fn get_UnderlineStyleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IHyperlinkStatics2 {
    #[inline] pub unsafe fn get_underline_style_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UnderlineStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IHyperlink3, 3287373785, 58835, 20407, 135, 2, 79, 109, 133, 221, 158, 10);
RT_INTERFACE!{interface IHyperlink3(IHyperlink3Vtbl): IInspectable(IInspectableVtbl) [IID_IHyperlink3] {
    fn get_XYFocusLeft(&self, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn put_XYFocusLeft(&self, value: *mut super::DependencyObject) -> HRESULT,
    fn get_XYFocusRight(&self, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn put_XYFocusRight(&self, value: *mut super::DependencyObject) -> HRESULT,
    fn get_XYFocusUp(&self, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn put_XYFocusUp(&self, value: *mut super::DependencyObject) -> HRESULT,
    fn get_XYFocusDown(&self, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn put_XYFocusDown(&self, value: *mut super::DependencyObject) -> HRESULT,
    fn get_ElementSoundMode(&self, out: *mut super::ElementSoundMode) -> HRESULT,
    fn put_ElementSoundMode(&self, value: super::ElementSoundMode) -> HRESULT
}}
impl IHyperlink3 {
    #[inline] pub unsafe fn get_xyfocus_left(&self) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusLeft)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_xyfocus_left(&self, value: &super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_XYFocusLeft)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_right(&self) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusRight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_xyfocus_right(&self, value: &super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_XYFocusRight)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_up(&self) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusUp)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_xyfocus_up(&self, value: &super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_XYFocusUp)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_down(&self) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusDown)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_xyfocus_down(&self, value: &super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_XYFocusDown)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_element_sound_mode(&self) -> Result<super::ElementSoundMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ElementSoundMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_element_sound_mode(&self, value: super::ElementSoundMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ElementSoundMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IHyperlinkStatics3, 1041620640, 8286, 18759, 153, 165, 116, 231, 87, 232, 225, 180);
RT_INTERFACE!{static interface IHyperlinkStatics3(IHyperlinkStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IHyperlinkStatics3] {
    fn get_XYFocusLeftProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_XYFocusRightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_XYFocusUpProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_XYFocusDownProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ElementSoundModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IHyperlinkStatics3 {
    #[inline] pub unsafe fn get_xyfocus_left_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusLeftProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_right_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusRightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_up_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusUpProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_down_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusDownProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_element_sound_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ElementSoundModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IHyperlink4, 4157614425, 33531, 16394, 164, 7, 90, 78, 230, 119, 152, 138);
RT_INTERFACE!{interface IHyperlink4(IHyperlink4Vtbl): IInspectable(IInspectableVtbl) [IID_IHyperlink4] {
    fn get_FocusState(&self, out: *mut super::FocusState) -> HRESULT,
    fn get_XYFocusUpNavigationStrategy(&self, out: *mut super::input::XYFocusNavigationStrategy) -> HRESULT,
    fn put_XYFocusUpNavigationStrategy(&self, value: super::input::XYFocusNavigationStrategy) -> HRESULT,
    fn get_XYFocusDownNavigationStrategy(&self, out: *mut super::input::XYFocusNavigationStrategy) -> HRESULT,
    fn put_XYFocusDownNavigationStrategy(&self, value: super::input::XYFocusNavigationStrategy) -> HRESULT,
    fn get_XYFocusLeftNavigationStrategy(&self, out: *mut super::input::XYFocusNavigationStrategy) -> HRESULT,
    fn put_XYFocusLeftNavigationStrategy(&self, value: super::input::XYFocusNavigationStrategy) -> HRESULT,
    fn get_XYFocusRightNavigationStrategy(&self, out: *mut super::input::XYFocusNavigationStrategy) -> HRESULT,
    fn put_XYFocusRightNavigationStrategy(&self, value: super::input::XYFocusNavigationStrategy) -> HRESULT,
    fn add_GotFocus(&self, value: *mut super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_GotFocus(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_LostFocus(&self, value: *mut super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LostFocus(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn Focus(&self, value: super::FocusState, out: *mut bool) -> HRESULT
}}
impl IHyperlink4 {
    #[inline] pub unsafe fn get_focus_state(&self) -> Result<super::FocusState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FocusState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_up_navigation_strategy(&self) -> Result<super::input::XYFocusNavigationStrategy> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_XYFocusUpNavigationStrategy)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_xyfocus_up_navigation_strategy(&self, value: super::input::XYFocusNavigationStrategy) -> Result<()> {
        let hr = ((*self.lpVtbl).put_XYFocusUpNavigationStrategy)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_down_navigation_strategy(&self) -> Result<super::input::XYFocusNavigationStrategy> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_XYFocusDownNavigationStrategy)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_xyfocus_down_navigation_strategy(&self, value: super::input::XYFocusNavigationStrategy) -> Result<()> {
        let hr = ((*self.lpVtbl).put_XYFocusDownNavigationStrategy)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_left_navigation_strategy(&self) -> Result<super::input::XYFocusNavigationStrategy> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_XYFocusLeftNavigationStrategy)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_xyfocus_left_navigation_strategy(&self, value: super::input::XYFocusNavigationStrategy) -> Result<()> {
        let hr = ((*self.lpVtbl).put_XYFocusLeftNavigationStrategy)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_right_navigation_strategy(&self) -> Result<super::input::XYFocusNavigationStrategy> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_XYFocusRightNavigationStrategy)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_xyfocus_right_navigation_strategy(&self, value: super::input::XYFocusNavigationStrategy) -> Result<()> {
        let hr = ((*self.lpVtbl).put_XYFocusRightNavigationStrategy)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_got_focus(&self, value: &super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_GotFocus)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_got_focus(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_GotFocus)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_lost_focus(&self, value: &super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_LostFocus)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_lost_focus(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_LostFocus)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn focus(&self, value: super::FocusState) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Focus)(self as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IHyperlinkStatics4, 74888056, 36778, 20004, 179, 182, 233, 222, 77, 60, 112, 140);
RT_INTERFACE!{static interface IHyperlinkStatics4(IHyperlinkStatics4Vtbl): IInspectable(IInspectableVtbl) [IID_IHyperlinkStatics4] {
    fn get_FocusStateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_XYFocusUpNavigationStrategyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_XYFocusDownNavigationStrategyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_XYFocusLeftNavigationStrategyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_XYFocusRightNavigationStrategyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IHyperlinkStatics4 {
    #[inline] pub unsafe fn get_focus_state_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FocusStateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_up_navigation_strategy_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusUpNavigationStrategyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_down_navigation_strategy_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusDownNavigationStrategyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_left_navigation_strategy_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusLeftNavigationStrategyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_right_navigation_strategy_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusRightNavigationStrategyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class TextElement: ITextElement}
impl RtActivatable<ITextElementStatics2> for TextElement {}
impl RtActivatable<ITextElementStatics4> for TextElement {}
impl RtActivatable<ITextElementStatics3> for TextElement {}
impl RtActivatable<ITextElementStatics> for TextElement {}
impl TextElement {
    #[inline] pub fn get_is_text_scale_factor_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextElementStatics2>>::get_activation_factory().get_is_text_scale_factor_enabled_property()
    }}
    #[inline] pub fn get_text_decorations_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextElementStatics4>>::get_activation_factory().get_text_decorations_property()
    }}
    #[inline] pub fn get_is_access_key_scope_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextElementStatics4>>::get_activation_factory().get_is_access_key_scope_property()
    }}
    #[inline] pub fn get_access_key_scope_owner_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextElementStatics4>>::get_activation_factory().get_access_key_scope_owner_property()
    }}
    #[inline] pub fn get_key_tip_placement_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextElementStatics4>>::get_activation_factory().get_key_tip_placement_mode_property()
    }}
    #[inline] pub fn get_key_tip_horizontal_offset_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextElementStatics4>>::get_activation_factory().get_key_tip_horizontal_offset_property()
    }}
    #[inline] pub fn get_key_tip_vertical_offset_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextElementStatics4>>::get_activation_factory().get_key_tip_vertical_offset_property()
    }}
    #[inline] pub fn get_allow_focus_on_interaction_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextElementStatics3>>::get_activation_factory().get_allow_focus_on_interaction_property()
    }}
    #[inline] pub fn get_access_key_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextElementStatics3>>::get_activation_factory().get_access_key_property()
    }}
    #[inline] pub fn get_exit_display_mode_on_access_key_invoked_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextElementStatics3>>::get_activation_factory().get_exit_display_mode_on_access_key_invoked_property()
    }}
    #[inline] pub fn get_font_size_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextElementStatics>>::get_activation_factory().get_font_size_property()
    }}
    #[inline] pub fn get_font_family_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextElementStatics>>::get_activation_factory().get_font_family_property()
    }}
    #[inline] pub fn get_font_weight_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextElementStatics>>::get_activation_factory().get_font_weight_property()
    }}
    #[inline] pub fn get_font_style_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextElementStatics>>::get_activation_factory().get_font_style_property()
    }}
    #[inline] pub fn get_font_stretch_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextElementStatics>>::get_activation_factory().get_font_stretch_property()
    }}
    #[inline] pub fn get_character_spacing_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextElementStatics>>::get_activation_factory().get_character_spacing_property()
    }}
    #[inline] pub fn get_foreground_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextElementStatics>>::get_activation_factory().get_foreground_property()
    }}
    #[inline] pub fn get_language_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextElementStatics>>::get_activation_factory().get_language_property()
    }}
}
DEFINE_CLSID!(TextElement(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,68,111,99,117,109,101,110,116,115,46,84,101,120,116,69,108,101,109,101,110,116,0]) [CLSID_TextElement]);
RT_CLASS!{class Block: IBlock}
impl RtActivatable<IBlockStatics> for Block {}
impl Block {
    #[inline] pub fn get_text_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBlockStatics>>::get_activation_factory().get_text_alignment_property()
    }}
    #[inline] pub fn get_line_height_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBlockStatics>>::get_activation_factory().get_line_height_property()
    }}
    #[inline] pub fn get_line_stacking_strategy_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBlockStatics>>::get_activation_factory().get_line_stacking_strategy_property()
    }}
    #[inline] pub fn get_margin_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBlockStatics>>::get_activation_factory().get_margin_property()
    }}
}
DEFINE_CLSID!(Block(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,68,111,99,117,109,101,110,116,115,46,66,108,111,99,107,0]) [CLSID_Block]);
RT_CLASS!{class Inline: IInline}
RT_CLASS!{class InlineUIContainer: IInlineUIContainer}
impl RtActivatable<IActivationFactory> for InlineUIContainer {}
DEFINE_CLSID!(InlineUIContainer(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,68,111,99,117,109,101,110,116,115,46,73,110,108,105,110,101,85,73,67,111,110,116,97,105,110,101,114,0]) [CLSID_InlineUIContainer]);
RT_CLASS!{class LineBreak: ILineBreak}
impl RtActivatable<IActivationFactory> for LineBreak {}
DEFINE_CLSID!(LineBreak(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,68,111,99,117,109,101,110,116,115,46,76,105,110,101,66,114,101,97,107,0]) [CLSID_LineBreak]);
RT_CLASS!{class Paragraph: IParagraph}
impl RtActivatable<IParagraphStatics> for Paragraph {}
impl RtActivatable<IActivationFactory> for Paragraph {}
impl Paragraph {
    #[inline] pub fn get_text_indent_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IParagraphStatics>>::get_activation_factory().get_text_indent_property()
    }}
}
DEFINE_CLSID!(Paragraph(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,68,111,99,117,109,101,110,116,115,46,80,97,114,97,103,114,97,112,104,0]) [CLSID_Paragraph]);
RT_CLASS!{class Run: IRun}
impl RtActivatable<IRunStatics> for Run {}
impl RtActivatable<IActivationFactory> for Run {}
impl Run {
    #[inline] pub fn get_flow_direction_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRunStatics>>::get_activation_factory().get_flow_direction_property()
    }}
}
DEFINE_CLSID!(Run(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,68,111,99,117,109,101,110,116,115,46,82,117,110,0]) [CLSID_Run]);
RT_CLASS!{class Span: ISpan}
RT_CLASS!{class Bold: IBold}
impl RtActivatable<IActivationFactory> for Bold {}
DEFINE_CLSID!(Bold(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,68,111,99,117,109,101,110,116,115,46,66,111,108,100,0]) [CLSID_Bold]);
RT_CLASS!{class Italic: IItalic}
impl RtActivatable<IActivationFactory> for Italic {}
DEFINE_CLSID!(Italic(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,68,111,99,117,109,101,110,116,115,46,73,116,97,108,105,99,0]) [CLSID_Italic]);
RT_CLASS!{class Underline: IUnderline}
impl RtActivatable<IActivationFactory> for Underline {}
DEFINE_CLSID!(Underline(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,68,111,99,117,109,101,110,116,115,46,85,110,100,101,114,108,105,110,101,0]) [CLSID_Underline]);
RT_CLASS!{class Hyperlink: IHyperlink}
impl RtActivatable<IHyperlinkStatics3> for Hyperlink {}
impl RtActivatable<IHyperlinkStatics2> for Hyperlink {}
impl RtActivatable<IHyperlinkStatics> for Hyperlink {}
impl RtActivatable<IHyperlinkStatics4> for Hyperlink {}
impl RtActivatable<IActivationFactory> for Hyperlink {}
impl Hyperlink {
    #[inline] pub fn get_xyfocus_left_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHyperlinkStatics3>>::get_activation_factory().get_xyfocus_left_property()
    }}
    #[inline] pub fn get_xyfocus_right_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHyperlinkStatics3>>::get_activation_factory().get_xyfocus_right_property()
    }}
    #[inline] pub fn get_xyfocus_up_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHyperlinkStatics3>>::get_activation_factory().get_xyfocus_up_property()
    }}
    #[inline] pub fn get_xyfocus_down_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHyperlinkStatics3>>::get_activation_factory().get_xyfocus_down_property()
    }}
    #[inline] pub fn get_element_sound_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHyperlinkStatics3>>::get_activation_factory().get_element_sound_mode_property()
    }}
    #[inline] pub fn get_underline_style_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHyperlinkStatics2>>::get_activation_factory().get_underline_style_property()
    }}
    #[inline] pub fn get_navigate_uri_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHyperlinkStatics>>::get_activation_factory().get_navigate_uri_property()
    }}
    #[inline] pub fn get_focus_state_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHyperlinkStatics4>>::get_activation_factory().get_focus_state_property()
    }}
    #[inline] pub fn get_xyfocus_up_navigation_strategy_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHyperlinkStatics4>>::get_activation_factory().get_xyfocus_up_navigation_strategy_property()
    }}
    #[inline] pub fn get_xyfocus_down_navigation_strategy_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHyperlinkStatics4>>::get_activation_factory().get_xyfocus_down_navigation_strategy_property()
    }}
    #[inline] pub fn get_xyfocus_left_navigation_strategy_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHyperlinkStatics4>>::get_activation_factory().get_xyfocus_left_navigation_strategy_property()
    }}
    #[inline] pub fn get_xyfocus_right_navigation_strategy_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHyperlinkStatics4>>::get_activation_factory().get_xyfocus_right_navigation_strategy_property()
    }}
}
DEFINE_CLSID!(Hyperlink(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,68,111,99,117,109,101,110,116,115,46,72,121,112,101,114,108,105,110,107,0]) [CLSID_Hyperlink]);
RT_CLASS!{class HyperlinkClickEventArgs: IHyperlinkClickEventArgs}
RT_CLASS!{class Glyphs: IGlyphs}
impl RtActivatable<IGlyphsStatics2> for Glyphs {}
impl RtActivatable<IGlyphsStatics> for Glyphs {}
impl RtActivatable<IActivationFactory> for Glyphs {}
impl Glyphs {
    #[inline] pub fn get_is_color_font_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGlyphsStatics2>>::get_activation_factory().get_is_color_font_enabled_property()
    }}
    #[inline] pub fn get_color_font_palette_index_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGlyphsStatics2>>::get_activation_factory().get_color_font_palette_index_property()
    }}
    #[inline] pub fn get_unicode_string_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGlyphsStatics>>::get_activation_factory().get_unicode_string_property()
    }}
    #[inline] pub fn get_indices_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGlyphsStatics>>::get_activation_factory().get_indices_property()
    }}
    #[inline] pub fn get_font_uri_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGlyphsStatics>>::get_activation_factory().get_font_uri_property()
    }}
    #[inline] pub fn get_style_simulations_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGlyphsStatics>>::get_activation_factory().get_style_simulations_property()
    }}
    #[inline] pub fn get_font_rendering_em_size_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGlyphsStatics>>::get_activation_factory().get_font_rendering_em_size_property()
    }}
    #[inline] pub fn get_origin_xproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGlyphsStatics>>::get_activation_factory().get_origin_xproperty()
    }}
    #[inline] pub fn get_origin_yproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGlyphsStatics>>::get_activation_factory().get_origin_yproperty()
    }}
    #[inline] pub fn get_fill_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGlyphsStatics>>::get_activation_factory().get_fill_property()
    }}
}
DEFINE_CLSID!(Glyphs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,68,111,99,117,109,101,110,116,115,46,71,108,121,112,104,115,0]) [CLSID_Glyphs]);
} // Windows.UI.Xaml.Documents
pub mod controls { // Windows.UI.Xaml.Controls
use ::prelude::*;
RT_ENUM! { enum CandidateWindowAlignment: i32 {
    Default (CandidateWindowAlignment_Default) = 0, BottomEdge (CandidateWindowAlignment_BottomEdge) = 1,
}}
RT_ENUM! { enum ClickMode: i32 {
    Release (ClickMode_Release) = 0, Press (ClickMode_Press) = 1, Hover (ClickMode_Hover) = 2,
}}
RT_ENUM! { enum ComboBoxSelectionChangedTrigger: i32 {
    Committed (ComboBoxSelectionChangedTrigger_Committed) = 0, Always (ComboBoxSelectionChangedTrigger_Always) = 1,
}}
RT_ENUM! { enum IncrementalLoadingTrigger: i32 {
    None (IncrementalLoadingTrigger_None) = 0, Edge (IncrementalLoadingTrigger_Edge) = 1,
}}
RT_ENUM! { enum ItemsUpdatingScrollMode: i32 {
    KeepItemsInView (ItemsUpdatingScrollMode_KeepItemsInView) = 0, KeepScrollOffset (ItemsUpdatingScrollMode_KeepScrollOffset) = 1, KeepLastItemInView (ItemsUpdatingScrollMode_KeepLastItemInView) = 2,
}}
RT_ENUM! { enum ListViewReorderMode: i32 {
    Disabled (ListViewReorderMode_Disabled) = 0, Enabled (ListViewReorderMode_Enabled) = 1,
}}
RT_ENUM! { enum ListViewSelectionMode: i32 {
    None (ListViewSelectionMode_None) = 0, Single (ListViewSelectionMode_Single) = 1, Multiple (ListViewSelectionMode_Multiple) = 2, Extended (ListViewSelectionMode_Extended) = 3,
}}
RT_ENUM! { enum Orientation: i32 {
    Vertical (Orientation_Vertical) = 0, Horizontal (Orientation_Horizontal) = 1,
}}
RT_ENUM! { enum PanelScrollingDirection: i32 {
    None (PanelScrollingDirection_None) = 0, Forward (PanelScrollingDirection_Forward) = 1, Backward (PanelScrollingDirection_Backward) = 2,
}}
RT_ENUM! { enum PasswordRevealMode: i32 {
    Peek (PasswordRevealMode_Peek) = 0, Hidden (PasswordRevealMode_Hidden) = 1, Visible (PasswordRevealMode_Visible) = 2,
}}
RT_ENUM! { enum RichEditClipboardFormat: i32 {
    AllFormats (RichEditClipboardFormat_AllFormats) = 0, PlainText (RichEditClipboardFormat_PlainText) = 1,
}}
RT_ENUM! { enum ScrollBarVisibility: i32 {
    Disabled (ScrollBarVisibility_Disabled) = 0, Auto (ScrollBarVisibility_Auto) = 1, Hidden (ScrollBarVisibility_Hidden) = 2, Visible (ScrollBarVisibility_Visible) = 3,
}}
RT_ENUM! { enum ScrollIntoViewAlignment: i32 {
    Default (ScrollIntoViewAlignment_Default) = 0, Leading (ScrollIntoViewAlignment_Leading) = 1,
}}
RT_ENUM! { enum ScrollMode: i32 {
    Disabled (ScrollMode_Disabled) = 0, Enabled (ScrollMode_Enabled) = 1, Auto (ScrollMode_Auto) = 2,
}}
RT_ENUM! { enum SelectionMode: i32 {
    Single (SelectionMode_Single) = 0, Multiple (SelectionMode_Multiple) = 1, Extended (SelectionMode_Extended) = 2,
}}
RT_ENUM! { enum SnapPointsType: i32 {
    None (SnapPointsType_None) = 0, Optional (SnapPointsType_Optional) = 1, Mandatory (SnapPointsType_Mandatory) = 2, OptionalSingle (SnapPointsType_OptionalSingle) = 3, MandatorySingle (SnapPointsType_MandatorySingle) = 4,
}}
RT_ENUM! { enum StretchDirection: i32 {
    UpOnly (StretchDirection_UpOnly) = 0, DownOnly (StretchDirection_DownOnly) = 1, Both (StretchDirection_Both) = 2,
}}
RT_ENUM! { enum VirtualizationMode: i32 {
    Standard (VirtualizationMode_Standard) = 0, Recycling (VirtualizationMode_Recycling) = 1,
}}
RT_ENUM! { enum ZoomMode: i32 {
    Disabled (ZoomMode_Disabled) = 0, Enabled (ZoomMode_Enabled) = 1,
}}
DEFINE_IID!(IID_BackClickEventHandler, 4204511775, 39058, 18478, 171, 246, 235, 45, 96, 125, 50, 222);
RT_DELEGATE!{delegate BackClickEventHandler(BackClickEventHandlerVtbl, BackClickEventHandlerImpl) [IID_BackClickEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut BackClickEventArgs) -> HRESULT
}}
impl BackClickEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &BackClickEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class BackClickEventArgs: IBackClickEventArgs}
impl RtActivatable<IActivationFactory> for BackClickEventArgs {}
DEFINE_CLSID!(BackClickEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,66,97,99,107,67,108,105,99,107,69,118,101,110,116,65,114,103,115,0]) [CLSID_BackClickEventArgs]);
DEFINE_IID!(IID_CleanUpVirtualizedItemEventHandler, 3402289366, 3853, 18544, 136, 77, 242, 222, 223, 103, 66, 136);
RT_DELEGATE!{delegate CleanUpVirtualizedItemEventHandler(CleanUpVirtualizedItemEventHandlerVtbl, CleanUpVirtualizedItemEventHandlerImpl) [IID_CleanUpVirtualizedItemEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut CleanUpVirtualizedItemEventArgs) -> HRESULT
}}
impl CleanUpVirtualizedItemEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &CleanUpVirtualizedItemEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ContextMenuOpeningEventHandler, 3751039313, 29788, 17478, 178, 252, 33, 109, 118, 88, 71, 160);
RT_DELEGATE!{delegate ContextMenuOpeningEventHandler(ContextMenuOpeningEventHandlerVtbl, ContextMenuOpeningEventHandlerImpl) [IID_ContextMenuOpeningEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut ContextMenuEventArgs) -> HRESULT
}}
impl ContextMenuOpeningEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &ContextMenuEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_DragItemsStartingEventHandler, 984525644, 5323, 17460, 190, 204, 136, 168, 88, 92, 47, 137);
RT_DELEGATE!{delegate DragItemsStartingEventHandler(DragItemsStartingEventHandlerVtbl, DragItemsStartingEventHandlerImpl) [IID_DragItemsStartingEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut DragItemsStartingEventArgs) -> HRESULT
}}
impl DragItemsStartingEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &DragItemsStartingEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class DragItemsStartingEventArgs: IDragItemsStartingEventArgs}
impl RtActivatable<IActivationFactory> for DragItemsStartingEventArgs {}
DEFINE_CLSID!(DragItemsStartingEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,68,114,97,103,73,116,101,109,115,83,116,97,114,116,105,110,103,69,118,101,110,116,65,114,103,115,0]) [CLSID_DragItemsStartingEventArgs]);
DEFINE_IID!(IID_ItemClickEventHandler, 1039585614, 57738, 19061, 147, 149, 98, 124, 95, 60, 212, 137);
RT_DELEGATE!{delegate ItemClickEventHandler(ItemClickEventHandlerVtbl, ItemClickEventHandlerImpl) [IID_ItemClickEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut ItemClickEventArgs) -> HRESULT
}}
impl ItemClickEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &ItemClickEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_NotifyEventHandler, 3271414264, 28933, 19060, 161, 9, 222, 41, 223, 245, 107, 152);
RT_DELEGATE!{delegate NotifyEventHandler(NotifyEventHandlerVtbl, NotifyEventHandlerImpl) [IID_NotifyEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut NotifyEventArgs) -> HRESULT
}}
impl NotifyEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &NotifyEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class NotifyEventArgs: INotifyEventArgs}
DEFINE_IID!(IID_SelectionChangedEventHandler, 3785380690, 23200, 17098, 156, 217, 6, 138, 20, 219, 110, 104);
RT_DELEGATE!{delegate SelectionChangedEventHandler(SelectionChangedEventHandlerVtbl, SelectionChangedEventHandlerImpl) [IID_SelectionChangedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut SelectionChangedEventArgs) -> HRESULT
}}
impl SelectionChangedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &SelectionChangedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_SemanticZoomViewChangedEventHandler, 531174941, 23923, 17659, 129, 172, 209, 201, 56, 73, 25, 212);
RT_DELEGATE!{delegate SemanticZoomViewChangedEventHandler(SemanticZoomViewChangedEventHandlerVtbl, SemanticZoomViewChangedEventHandlerImpl) [IID_SemanticZoomViewChangedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut SemanticZoomViewChangedEventArgs) -> HRESULT
}}
impl SemanticZoomViewChangedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &SemanticZoomViewChangedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class SemanticZoomViewChangedEventArgs: ISemanticZoomViewChangedEventArgs}
impl RtActivatable<IActivationFactory> for SemanticZoomViewChangedEventArgs {}
DEFINE_CLSID!(SemanticZoomViewChangedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,83,101,109,97,110,116,105,99,90,111,111,109,86,105,101,119,67,104,97,110,103,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_SemanticZoomViewChangedEventArgs]);
DEFINE_IID!(IID_TextChangedEventHandler, 2394119063, 44423, 16616, 129, 139, 119, 219, 36, 117, 149, 102);
RT_DELEGATE!{delegate TextChangedEventHandler(TextChangedEventHandlerVtbl, TextChangedEventHandlerImpl) [IID_TextChangedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut TextChangedEventArgs) -> HRESULT
}}
impl TextChangedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &TextChangedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_TextControlPasteEventHandler, 3580736345, 28535, 17046, 171, 156, 121, 73, 57, 68, 67, 101);
RT_DELEGATE!{delegate TextControlPasteEventHandler(TextControlPasteEventHandlerVtbl, TextControlPasteEventHandlerImpl) [IID_TextControlPasteEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut TextControlPasteEventArgs) -> HRESULT
}}
impl TextControlPasteEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &TextControlPasteEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class TextControlPasteEventArgs: ITextControlPasteEventArgs}
RT_CLASS!{class ContainerContentChangingEventArgs: IContainerContentChangingEventArgs}
impl RtActivatable<IActivationFactory> for ContainerContentChangingEventArgs {}
DEFINE_CLSID!(ContainerContentChangingEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,67,111,110,116,97,105,110,101,114,67,111,110,116,101,110,116,67,104,97,110,103,105,110,103,69,118,101,110,116,65,114,103,115,0]) [CLSID_ContainerContentChangingEventArgs]);
DEFINE_IID!(IID_IInsertionPanel, 1804460175, 25895, 19769, 188, 191, 88, 176, 29, 169, 35, 215);
RT_INTERFACE!{interface IInsertionPanel(IInsertionPanelVtbl): IInspectable(IInspectableVtbl) [IID_IInsertionPanel] {
    fn GetInsertionIndexes(&self, position: ::rt::gen::windows::foundation::Point, first: *mut i32, second: *mut i32) -> HRESULT
}}
impl IInsertionPanel {
    #[inline] pub unsafe fn get_insertion_indexes(&self, position: ::rt::gen::windows::foundation::Point) -> Result<(i32, i32)> {
        let mut first = zeroed(); let mut second = zeroed();
        let hr = ((*self.lpVtbl).GetInsertionIndexes)(self as *const _ as *mut _, position, &mut first, &mut second);
        if hr == S_OK { Ok((first, second)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemContainerMapping, 1405743674, 62045, 17514, 153, 184, 199, 174, 184, 57, 5, 15);
RT_INTERFACE!{interface IItemContainerMapping(IItemContainerMappingVtbl): IInspectable(IInspectableVtbl) [IID_IItemContainerMapping] {
    fn ItemFromContainer(&self, container: *mut super::DependencyObject, out: *mut *mut IInspectable) -> HRESULT,
    fn ContainerFromItem(&self, item: *mut IInspectable, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn IndexFromContainer(&self, container: *mut super::DependencyObject, out: *mut i32) -> HRESULT,
    fn ContainerFromIndex(&self, index: i32, out: *mut *mut super::DependencyObject) -> HRESULT
}}
impl IItemContainerMapping {
    #[inline] pub unsafe fn item_from_container(&self, container: &super::DependencyObject) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ItemFromContainer)(self as *const _ as *mut _, container as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn container_from_item(&self, item: &IInspectable) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ContainerFromItem)(self as *const _ as *mut _, item as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn index_from_container(&self, container: &super::DependencyObject) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IndexFromContainer)(self as *const _ as *mut _, container as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn container_from_index(&self, index: i32) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ContainerFromIndex)(self as *const _ as *mut _, index, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_INavigate, 3206649257, 62698, 17206, 151, 124, 248, 252, 247, 139, 13, 158);
RT_INTERFACE!{interface INavigate(INavigateVtbl): IInspectable(IInspectableVtbl) [IID_INavigate] {
    fn Navigate(&self, sourcePageType: super::interop::TypeName, out: *mut bool) -> HRESULT
}}
impl INavigate {
    #[inline] pub unsafe fn navigate(&self, sourcePageType: super::interop::TypeName) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Navigate)(self as *const _ as *mut _, sourcePageType, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISemanticZoomInformation, 2808757091, 8859, 19909, 170, 17, 157, 146, 47, 191, 138, 152);
RT_INTERFACE!{interface ISemanticZoomInformation(ISemanticZoomInformationVtbl): IInspectable(IInspectableVtbl) [IID_ISemanticZoomInformation] {
    fn get_SemanticZoomOwner(&self, out: *mut *mut SemanticZoom) -> HRESULT,
    fn put_SemanticZoomOwner(&self, value: *mut SemanticZoom) -> HRESULT,
    fn get_IsActiveView(&self, out: *mut bool) -> HRESULT,
    fn put_IsActiveView(&self, value: bool) -> HRESULT,
    fn get_IsZoomedInView(&self, out: *mut bool) -> HRESULT,
    fn put_IsZoomedInView(&self, value: bool) -> HRESULT,
    fn InitializeViewChange(&self) -> HRESULT,
    fn CompleteViewChange(&self) -> HRESULT,
    fn MakeVisible(&self, item: *mut SemanticZoomLocation) -> HRESULT,
    fn StartViewChangeFrom(&self, source: *mut SemanticZoomLocation, destination: *mut SemanticZoomLocation) -> HRESULT,
    fn StartViewChangeTo(&self, source: *mut SemanticZoomLocation, destination: *mut SemanticZoomLocation) -> HRESULT,
    fn CompleteViewChangeFrom(&self, source: *mut SemanticZoomLocation, destination: *mut SemanticZoomLocation) -> HRESULT,
    fn CompleteViewChangeTo(&self, source: *mut SemanticZoomLocation, destination: *mut SemanticZoomLocation) -> HRESULT
}}
impl ISemanticZoomInformation {
    #[inline] pub unsafe fn get_semantic_zoom_owner(&self) -> Result<ComPtr<SemanticZoom>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SemanticZoomOwner)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_semantic_zoom_owner(&self, value: &SemanticZoom) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SemanticZoomOwner)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_active_view(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsActiveView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_active_view(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsActiveView)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_zoomed_in_view(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsZoomedInView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_zoomed_in_view(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsZoomedInView)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn initialize_view_change(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).InitializeViewChange)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn complete_view_change(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).CompleteViewChange)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn make_visible(&self, item: &SemanticZoomLocation) -> Result<()> {
        let hr = ((*self.lpVtbl).MakeVisible)(self as *const _ as *mut _, item as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn start_view_change_from(&self, source: &SemanticZoomLocation, destination: &SemanticZoomLocation) -> Result<()> {
        let hr = ((*self.lpVtbl).StartViewChangeFrom)(self as *const _ as *mut _, source as *const _ as *mut _, destination as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn start_view_change_to(&self, source: &SemanticZoomLocation, destination: &SemanticZoomLocation) -> Result<()> {
        let hr = ((*self.lpVtbl).StartViewChangeTo)(self as *const _ as *mut _, source as *const _ as *mut _, destination as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn complete_view_change_from(&self, source: &SemanticZoomLocation, destination: &SemanticZoomLocation) -> Result<()> {
        let hr = ((*self.lpVtbl).CompleteViewChangeFrom)(self as *const _ as *mut _, source as *const _ as *mut _, destination as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn complete_view_change_to(&self, source: &SemanticZoomLocation, destination: &SemanticZoomLocation) -> Result<()> {
        let hr = ((*self.lpVtbl).CompleteViewChangeTo)(self as *const _ as *mut _, source as *const _ as *mut _, destination as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class SemanticZoomLocation: ISemanticZoomLocation}
impl RtActivatable<IActivationFactory> for SemanticZoomLocation {}
DEFINE_CLSID!(SemanticZoomLocation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,83,101,109,97,110,116,105,99,90,111,111,109,76,111,99,97,116,105,111,110,0]) [CLSID_SemanticZoomLocation]);
DEFINE_IID!(IID_IBackClickEventArgs, 719721580, 18302, 18633, 136, 48, 44, 70, 75, 124, 113, 4);
RT_INTERFACE!{interface IBackClickEventArgs(IBackClickEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBackClickEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT
}}
impl IBackClickEventArgs {
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICandidateWindowBoundsChangedEventArgs, 2324980824, 33712, 19506, 148, 80, 81, 105, 165, 131, 139, 85);
RT_INTERFACE!{interface ICandidateWindowBoundsChangedEventArgs(ICandidateWindowBoundsChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICandidateWindowBoundsChangedEventArgs] {
    fn get_Bounds(&self, out: *mut ::rt::gen::windows::foundation::Rect) -> HRESULT
}}
impl ICandidateWindowBoundsChangedEventArgs {
    #[inline] pub unsafe fn get_bounds(&self) -> Result<::rt::gen::windows::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Bounds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class CandidateWindowBoundsChangedEventArgs: ICandidateWindowBoundsChangedEventArgs}
DEFINE_IID!(IID_IChoosingGroupHeaderContainerEventArgs, 1742423254, 53761, 19826, 190, 172, 94, 142, 88, 175, 216, 199);
RT_INTERFACE!{interface IChoosingGroupHeaderContainerEventArgs(IChoosingGroupHeaderContainerEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IChoosingGroupHeaderContainerEventArgs] {
    fn get_GroupHeaderContainer(&self, out: *mut *mut ListViewBaseHeaderItem) -> HRESULT,
    fn put_GroupHeaderContainer(&self, value: *mut ListViewBaseHeaderItem) -> HRESULT,
    fn get_GroupIndex(&self, out: *mut i32) -> HRESULT,
    fn get_Group(&self, out: *mut *mut IInspectable) -> HRESULT
}}
impl IChoosingGroupHeaderContainerEventArgs {
    #[inline] pub unsafe fn get_group_header_container(&self) -> Result<ComPtr<ListViewBaseHeaderItem>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GroupHeaderContainer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_group_header_container(&self, value: &ListViewBaseHeaderItem) -> Result<()> {
        let hr = ((*self.lpVtbl).put_GroupHeaderContainer)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_group_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_GroupIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_group(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Group)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ChoosingGroupHeaderContainerEventArgs: IChoosingGroupHeaderContainerEventArgs}
impl RtActivatable<IActivationFactory> for ChoosingGroupHeaderContainerEventArgs {}
DEFINE_CLSID!(ChoosingGroupHeaderContainerEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,67,104,111,111,115,105,110,103,71,114,111,117,112,72,101,97,100,101,114,67,111,110,116,97,105,110,101,114,69,118,101,110,116,65,114,103,115,0]) [CLSID_ChoosingGroupHeaderContainerEventArgs]);
DEFINE_IID!(IID_IChoosingItemContainerEventArgs, 2612280270, 44647, 19072, 131, 99, 227, 254, 27, 36, 79, 44);
RT_INTERFACE!{interface IChoosingItemContainerEventArgs(IChoosingItemContainerEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IChoosingItemContainerEventArgs] {
    fn get_ItemIndex(&self, out: *mut i32) -> HRESULT,
    fn get_Item(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn get_ItemContainer(&self, out: *mut *mut primitives::SelectorItem) -> HRESULT,
    fn put_ItemContainer(&self, value: *mut primitives::SelectorItem) -> HRESULT,
    fn get_IsContainerPrepared(&self, out: *mut bool) -> HRESULT,
    fn put_IsContainerPrepared(&self, value: bool) -> HRESULT
}}
impl IChoosingItemContainerEventArgs {
    #[inline] pub unsafe fn get_item_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ItemIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Item)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_container(&self) -> Result<ComPtr<primitives::SelectorItem>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemContainer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_item_container(&self, value: &primitives::SelectorItem) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemContainer)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_container_prepared(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsContainerPrepared)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_container_prepared(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsContainerPrepared)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ChoosingItemContainerEventArgs: IChoosingItemContainerEventArgs}
impl RtActivatable<IActivationFactory> for ChoosingItemContainerEventArgs {}
DEFINE_CLSID!(ChoosingItemContainerEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,67,104,111,111,115,105,110,103,73,116,101,109,67,111,110,116,97,105,110,101,114,69,118,101,110,116,65,114,103,115,0]) [CLSID_ChoosingItemContainerEventArgs]);
RT_CLASS!{class ColumnDefinitionCollection: ::rt::gen::windows::foundation::collections::IVector<ColumnDefinition>}
DEFINE_IID!(IID_IContainerContentChangingEventArgs, 132049575, 399, 19930, 179, 153, 253, 78, 19, 163, 27, 234);
RT_INTERFACE!{interface IContainerContentChangingEventArgs(IContainerContentChangingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContainerContentChangingEventArgs] {
    fn get_ItemContainer(&self, out: *mut *mut primitives::SelectorItem) -> HRESULT,
    fn get_InRecycleQueue(&self, out: *mut bool) -> HRESULT,
    fn get_ItemIndex(&self, out: *mut i32) -> HRESULT,
    fn get_Item(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn get_Phase(&self, out: *mut u32) -> HRESULT,
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn RegisterUpdateCallback(&self, callback: *mut ::rt::gen::windows::foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs>) -> HRESULT,
    fn RegisterUpdateCallbackWithPhase(&self, callbackPhase: u32, callback: *mut ::rt::gen::windows::foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs>) -> HRESULT
}}
impl IContainerContentChangingEventArgs {
    #[inline] pub unsafe fn get_item_container(&self) -> Result<ComPtr<primitives::SelectorItem>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemContainer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_in_recycle_queue(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InRecycleQueue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ItemIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Item)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_phase(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Phase)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn register_update_callback(&self, callback: &::rt::gen::windows::foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs>) -> Result<()> {
        let hr = ((*self.lpVtbl).RegisterUpdateCallback)(self as *const _ as *mut _, callback as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn register_update_callback_with_phase(&self, callbackPhase: u32, callback: &::rt::gen::windows::foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs>) -> Result<()> {
        let hr = ((*self.lpVtbl).RegisterUpdateCallbackWithPhase)(self as *const _ as *mut _, callbackPhase, callback as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDataTemplateSelector, 2835862678, 18080, 19671, 141, 190, 249, 165, 129, 223, 96, 177);
RT_INTERFACE!{interface IDataTemplateSelector(IDataTemplateSelectorVtbl): IInspectable(IInspectableVtbl) [IID_IDataTemplateSelector] {
    fn SelectTemplate(&self, item: *mut IInspectable, container: *mut super::DependencyObject, out: *mut *mut super::DataTemplate) -> HRESULT
}}
impl IDataTemplateSelector {
    #[inline] pub unsafe fn select_template(&self, item: &IInspectable, container: &super::DependencyObject) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SelectTemplate)(self as *const _ as *mut _, item as *const _ as *mut _, container as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDataTemplateSelectorOverrides, 756427045, 22886, 19450, 134, 56, 77, 52, 86, 137, 246, 207);
RT_INTERFACE!{interface IDataTemplateSelectorOverrides(IDataTemplateSelectorOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IDataTemplateSelectorOverrides] {
    fn SelectTemplateCore(&self, item: *mut IInspectable, container: *mut super::DependencyObject, out: *mut *mut super::DataTemplate) -> HRESULT
}}
impl IDataTemplateSelectorOverrides {
    #[inline] pub unsafe fn select_template_core(&self, item: &IInspectable, container: &super::DependencyObject) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SelectTemplateCore)(self as *const _ as *mut _, item as *const _ as *mut _, container as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDataTemplateSelectorFactory, 1360767696, 8458, 17789, 149, 33, 67, 61, 43, 17, 183, 210);
RT_INTERFACE!{interface IDataTemplateSelectorFactory(IDataTemplateSelectorFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IDataTemplateSelectorFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut DataTemplateSelector) -> HRESULT
}}
impl IDataTemplateSelectorFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<DataTemplateSelector>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class DataTemplateSelector: IDataTemplateSelector}
DEFINE_IID!(IID_IDataTemplateSelector2, 932363335, 35915, 16983, 165, 174, 204, 63, 142, 215, 134, 235);
RT_INTERFACE!{interface IDataTemplateSelector2(IDataTemplateSelector2Vtbl): IInspectable(IInspectableVtbl) [IID_IDataTemplateSelector2] {
    fn SelectTemplateForItem(&self, item: *mut IInspectable, out: *mut *mut super::DataTemplate) -> HRESULT
}}
impl IDataTemplateSelector2 {
    #[inline] pub unsafe fn select_template_for_item(&self, item: &IInspectable) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SelectTemplateForItem)(self as *const _ as *mut _, item as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDataTemplateSelectorOverrides2, 1816114684, 36484, 19601, 172, 21, 4, 161, 216, 133, 80, 15);
RT_INTERFACE!{interface IDataTemplateSelectorOverrides2(IDataTemplateSelectorOverrides2Vtbl): IInspectable(IInspectableVtbl) [IID_IDataTemplateSelectorOverrides2] {
    fn SelectTemplateForItemCore(&self, item: *mut IInspectable, out: *mut *mut super::DataTemplate) -> HRESULT
}}
impl IDataTemplateSelectorOverrides2 {
    #[inline] pub unsafe fn select_template_for_item_core(&self, item: &IInspectable) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SelectTemplateForItemCore)(self as *const _ as *mut _, item as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDragItemsCompletedEventArgs, 2936402479, 40568, 19233, 154, 142, 65, 194, 209, 54, 122, 42);
RT_INTERFACE!{interface IDragItemsCompletedEventArgs(IDragItemsCompletedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDragItemsCompletedEventArgs] {
    fn get_Items(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<IInspectable>) -> HRESULT,
    #[cfg(feature="windows-applicationmodel")] fn get_DropResult(&self, out: *mut ::rt::gen::windows::applicationmodel::datatransfer::DataPackageOperation) -> HRESULT
}}
impl IDragItemsCompletedEventArgs {
    #[inline] pub unsafe fn get_items(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<IInspectable>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Items)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn get_drop_result(&self) -> Result<::rt::gen::windows::applicationmodel::datatransfer::DataPackageOperation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DropResult)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class DragItemsCompletedEventArgs: IDragItemsCompletedEventArgs}
DEFINE_IID!(IID_IDragItemsStartingEventArgs, 1909399900, 56045, 18307, 170, 17, 220, 87, 77, 39, 19, 233);
RT_INTERFACE!{interface IDragItemsStartingEventArgs(IDragItemsStartingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDragItemsStartingEventArgs] {
    fn get_Cancel(&self, out: *mut bool) -> HRESULT,
    fn put_Cancel(&self, value: bool) -> HRESULT,
    fn get_Items(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<IInspectable>) -> HRESULT,
    #[cfg(feature="windows-applicationmodel")] fn get_Data(&self, out: *mut *mut ::rt::gen::windows::applicationmodel::datatransfer::DataPackage) -> HRESULT
}}
impl IDragItemsStartingEventArgs {
    #[inline] pub unsafe fn get_cancel(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cancel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_cancel(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Cancel)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_items(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<IInspectable>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Items)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn get_data(&self) -> Result<ComPtr<::rt::gen::windows::applicationmodel::datatransfer::DataPackage>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Data)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGroupStyle, 1909075979, 47262, 16772, 176, 223, 169, 233, 84, 71, 222, 141);
RT_INTERFACE!{interface IGroupStyle(IGroupStyleVtbl): IInspectable(IInspectableVtbl) [IID_IGroupStyle] {
    fn get_Panel(&self, out: *mut *mut ItemsPanelTemplate) -> HRESULT,
    fn put_Panel(&self, value: *mut ItemsPanelTemplate) -> HRESULT,
    fn get_ContainerStyle(&self, out: *mut *mut super::Style) -> HRESULT,
    fn put_ContainerStyle(&self, value: *mut super::Style) -> HRESULT,
    fn get_ContainerStyleSelector(&self, out: *mut *mut StyleSelector) -> HRESULT,
    fn put_ContainerStyleSelector(&self, value: *mut StyleSelector) -> HRESULT,
    fn get_HeaderTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_HeaderTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_HeaderTemplateSelector(&self, out: *mut *mut DataTemplateSelector) -> HRESULT,
    fn put_HeaderTemplateSelector(&self, value: *mut DataTemplateSelector) -> HRESULT,
    fn get_HidesIfEmpty(&self, out: *mut bool) -> HRESULT,
    fn put_HidesIfEmpty(&self, value: bool) -> HRESULT
}}
impl IGroupStyle {
    #[inline] pub unsafe fn get_panel(&self) -> Result<ComPtr<ItemsPanelTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Panel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_panel(&self, value: &ItemsPanelTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Panel)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_container_style(&self) -> Result<ComPtr<super::Style>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContainerStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_container_style(&self, value: &super::Style) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContainerStyle)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_container_style_selector(&self) -> Result<ComPtr<StyleSelector>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContainerStyleSelector)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_container_style_selector(&self, value: &StyleSelector) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContainerStyleSelector)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template_selector(&self) -> Result<ComPtr<DataTemplateSelector>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplateSelector)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_template_selector(&self, value: &DataTemplateSelector) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderTemplateSelector)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_hides_if_empty(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HidesIfEmpty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_hides_if_empty(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HidesIfEmpty)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class StyleSelector: IStyleSelector}
DEFINE_IID!(IID_IGroupStyleFactory, 1459578447, 58071, 20297, 128, 61, 199, 39, 205, 249, 55, 45);
RT_INTERFACE!{interface IGroupStyleFactory(IGroupStyleFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGroupStyleFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut GroupStyle) -> HRESULT
}}
impl IGroupStyleFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<GroupStyle>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class GroupStyle: IGroupStyle}
DEFINE_IID!(IID_IGroupStyle2, 1777927801, 14865, 20455, 180, 223, 42, 1, 57, 212, 1, 139);
RT_INTERFACE!{interface IGroupStyle2(IGroupStyle2Vtbl): IInspectable(IInspectableVtbl) [IID_IGroupStyle2] {
    fn get_HeaderContainerStyle(&self, out: *mut *mut super::Style) -> HRESULT,
    fn put_HeaderContainerStyle(&self, value: *mut super::Style) -> HRESULT
}}
impl IGroupStyle2 {
    #[inline] pub unsafe fn get_header_container_style(&self) -> Result<ComPtr<super::Style>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderContainerStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_container_style(&self, value: &super::Style) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderContainerStyle)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGroupStyleSelector, 1843007902, 39540, 18319, 163, 57, 91, 181, 45, 230, 197, 30);
RT_INTERFACE!{interface IGroupStyleSelector(IGroupStyleSelectorVtbl): IInspectable(IInspectableVtbl) [IID_IGroupStyleSelector] {
    fn SelectGroupStyle(&self, group: *mut IInspectable, level: u32, out: *mut *mut GroupStyle) -> HRESULT
}}
impl IGroupStyleSelector {
    #[inline] pub unsafe fn select_group_style(&self, group: &IInspectable, level: u32) -> Result<ComPtr<GroupStyle>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SelectGroupStyle)(self as *const _ as *mut _, group as *const _ as *mut _, level, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGroupStyleSelectorOverrides, 4136749746, 30637, 19773, 165, 28, 142, 249, 195, 131, 100, 86);
RT_INTERFACE!{interface IGroupStyleSelectorOverrides(IGroupStyleSelectorOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IGroupStyleSelectorOverrides] {
    fn SelectGroupStyleCore(&self, group: *mut IInspectable, level: u32, out: *mut *mut GroupStyle) -> HRESULT
}}
impl IGroupStyleSelectorOverrides {
    #[inline] pub unsafe fn select_group_style_core(&self, group: &IInspectable, level: u32) -> Result<ComPtr<GroupStyle>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SelectGroupStyleCore)(self as *const _ as *mut _, group as *const _ as *mut _, level, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGroupStyleSelectorFactory, 3210153267, 45814, 18463, 164, 80, 200, 12, 41, 31, 178, 45);
RT_INTERFACE!{interface IGroupStyleSelectorFactory(IGroupStyleSelectorFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGroupStyleSelectorFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut GroupStyleSelector) -> HRESULT
}}
impl IGroupStyleSelectorFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<GroupStyleSelector>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class GroupStyleSelector: IGroupStyleSelector}
RT_CLASS!{class ItemCollection: ::rt::gen::windows::foundation::collections::IObservableVector<IInspectable>}
DEFINE_IID!(IID_IItemContainerGenerator, 1081499392, 33776, 19839, 177, 184, 241, 157, 228, 241, 213, 218);
RT_INTERFACE!{interface IItemContainerGenerator(IItemContainerGeneratorVtbl): IInspectable(IInspectableVtbl) [IID_IItemContainerGenerator] {
    fn add_ItemsChanged(&self, value: *mut primitives::ItemsChangedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ItemsChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn ItemFromContainer(&self, container: *mut super::DependencyObject, out: *mut *mut IInspectable) -> HRESULT,
    fn ContainerFromItem(&self, item: *mut IInspectable, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn IndexFromContainer(&self, container: *mut super::DependencyObject, out: *mut i32) -> HRESULT,
    fn ContainerFromIndex(&self, index: i32, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn GetItemContainerGeneratorForPanel(&self, panel: *mut Panel, out: *mut *mut ItemContainerGenerator) -> HRESULT,
    fn StartAt(&self, position: primitives::GeneratorPosition, direction: primitives::GeneratorDirection, allowStartAtRealizedItem: bool) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn GenerateNext(&self, isNewlyRealized: *mut bool, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn PrepareItemContainer(&self, container: *mut super::DependencyObject) -> HRESULT,
    fn RemoveAll(&self) -> HRESULT,
    fn Remove(&self, position: primitives::GeneratorPosition, count: i32) -> HRESULT,
    fn GeneratorPositionFromIndex(&self, itemIndex: i32, out: *mut primitives::GeneratorPosition) -> HRESULT,
    fn IndexFromGeneratorPosition(&self, position: primitives::GeneratorPosition, out: *mut i32) -> HRESULT,
    fn Recycle(&self, position: primitives::GeneratorPosition, count: i32) -> HRESULT
}}
impl IItemContainerGenerator {
    #[inline] pub unsafe fn add_items_changed(&self, value: &primitives::ItemsChangedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ItemsChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_items_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ItemsChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn item_from_container(&self, container: &super::DependencyObject) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ItemFromContainer)(self as *const _ as *mut _, container as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn container_from_item(&self, item: &IInspectable) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ContainerFromItem)(self as *const _ as *mut _, item as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn index_from_container(&self, container: &super::DependencyObject) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IndexFromContainer)(self as *const _ as *mut _, container as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn container_from_index(&self, index: i32) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ContainerFromIndex)(self as *const _ as *mut _, index, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_container_generator_for_panel(&self, panel: &Panel) -> Result<ComPtr<ItemContainerGenerator>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetItemContainerGeneratorForPanel)(self as *const _ as *mut _, panel as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn start_at(&self, position: primitives::GeneratorPosition, direction: primitives::GeneratorDirection, allowStartAtRealizedItem: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).StartAt)(self as *const _ as *mut _, position, direction, allowStartAtRealizedItem);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn stop(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Stop)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn generate_next(&self) -> Result<(bool, ComPtr<super::DependencyObject>)> {
        let mut isNewlyRealized = zeroed(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).GenerateNext)(self as *const _ as *mut _, &mut isNewlyRealized, &mut out);
        if hr == S_OK { Ok((isNewlyRealized, ComPtr::wrap(out))) } else { err(hr) }
    }
    #[inline] pub unsafe fn prepare_item_container(&self, container: &super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).PrepareItemContainer)(self as *const _ as *mut _, container as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_all(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).RemoveAll)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove(&self, position: primitives::GeneratorPosition, count: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).Remove)(self as *const _ as *mut _, position, count);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn generator_position_from_index(&self, itemIndex: i32) -> Result<primitives::GeneratorPosition> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GeneratorPositionFromIndex)(self as *const _ as *mut _, itemIndex, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn index_from_generator_position(&self, position: primitives::GeneratorPosition) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IndexFromGeneratorPosition)(self as *const _ as *mut _, position, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn recycle(&self, position: primitives::GeneratorPosition, count: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).Recycle)(self as *const _ as *mut _, position, count);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ItemContainerGenerator: IItemContainerGenerator}
DEFINE_IID!(IID_IMediaTransportControlsHelper, 1027724553, 65348, 17440, 128, 126, 143, 122, 46, 44, 66, 81);
RT_INTERFACE!{interface IMediaTransportControlsHelper(IMediaTransportControlsHelperVtbl): IInspectable(IInspectableVtbl) [IID_IMediaTransportControlsHelper] {
    
}}
DEFINE_IID!(IID_IMediaTransportControlsHelperStatics, 1517756487, 43425, 17957, 146, 112, 127, 73, 135, 93, 67, 148);
RT_INTERFACE!{static interface IMediaTransportControlsHelperStatics(IMediaTransportControlsHelperStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMediaTransportControlsHelperStatics] {
    fn get_DropoutOrderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetDropoutOrder(&self, element: *mut super::UIElement, out: *mut *mut ::rt::gen::windows::foundation::IReference<i32>) -> HRESULT,
    fn SetDropoutOrder(&self, element: *mut super::UIElement, value: *mut ::rt::gen::windows::foundation::IReference<i32>) -> HRESULT
}}
impl IMediaTransportControlsHelperStatics {
    #[inline] pub unsafe fn get_dropout_order_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DropoutOrderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_dropout_order(&self, element: &super::UIElement) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDropoutOrder)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_dropout_order(&self, element: &super::UIElement, value: &::rt::gen::windows::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).SetDropoutOrder)(self as *const _ as *mut _, element as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class MediaTransportControlsHelper: IMediaTransportControlsHelper}
impl RtActivatable<IMediaTransportControlsHelperStatics> for MediaTransportControlsHelper {}
impl MediaTransportControlsHelper {
    #[inline] pub fn get_dropout_order_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsHelperStatics>>::get_activation_factory().get_dropout_order_property()
    }}
    #[inline] pub fn get_dropout_order(element: &super::UIElement) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<i32>>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsHelperStatics>>::get_activation_factory().get_dropout_order(element)
    }}
    #[inline] pub fn set_dropout_order(element: &super::UIElement, value: &::rt::gen::windows::foundation::IReference<i32>) -> Result<()> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsHelperStatics>>::get_activation_factory().set_dropout_order(element, value)
    }}
}
DEFINE_CLSID!(MediaTransportControlsHelper(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,101,100,105,97,84,114,97,110,115,112,111,114,116,67,111,110,116,114,111,108,115,72,101,108,112,101,114,0]) [CLSID_MediaTransportControlsHelper]);
DEFINE_IID!(IID_INotifyEventArgs, 2936931831, 50359, 17605, 176, 157, 92, 183, 5, 43, 58, 151);
RT_INTERFACE!{interface INotifyEventArgs(INotifyEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_INotifyEventArgs] {
    fn get_Value(&self, out: *mut HSTRING) -> HRESULT
}}
impl INotifyEventArgs {
    #[inline] pub unsafe fn get_value(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Value)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_INotifyEventArgs2, 219418454, 7630, 20429, 133, 188, 90, 85, 114, 39, 59, 156);
RT_INTERFACE!{interface INotifyEventArgs2(INotifyEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_INotifyEventArgs2] {
    fn get_CallingUri(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT
}}
impl INotifyEventArgs2 {
    #[inline] pub unsafe fn get_calling_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CallingUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class RowDefinitionCollection: ::rt::gen::windows::foundation::collections::IVector<RowDefinition>}
DEFINE_IID!(IID_ISemanticZoomLocation, 1107367734, 58306, 18795, 188, 78, 215, 80, 212, 55, 91, 154);
RT_INTERFACE!{interface ISemanticZoomLocation(ISemanticZoomLocationVtbl): IInspectable(IInspectableVtbl) [IID_ISemanticZoomLocation] {
    fn get_Item(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Item(&self, value: *mut IInspectable) -> HRESULT,
    fn get_Bounds(&self, out: *mut ::rt::gen::windows::foundation::Rect) -> HRESULT,
    fn put_Bounds(&self, value: ::rt::gen::windows::foundation::Rect) -> HRESULT
}}
impl ISemanticZoomLocation {
    #[inline] pub unsafe fn get_item(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Item)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_item(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Item)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_bounds(&self) -> Result<::rt::gen::windows::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Bounds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_bounds(&self, value: ::rt::gen::windows::foundation::Rect) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Bounds)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISemanticZoomViewChangedEventArgs, 1205846120, 46441, 19225, 132, 45, 142, 108, 249, 9, 137, 175);
RT_INTERFACE!{interface ISemanticZoomViewChangedEventArgs(ISemanticZoomViewChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISemanticZoomViewChangedEventArgs] {
    fn get_IsSourceZoomedInView(&self, out: *mut bool) -> HRESULT,
    fn put_IsSourceZoomedInView(&self, value: bool) -> HRESULT,
    fn get_SourceItem(&self, out: *mut *mut SemanticZoomLocation) -> HRESULT,
    fn put_SourceItem(&self, value: *mut SemanticZoomLocation) -> HRESULT,
    fn get_DestinationItem(&self, out: *mut *mut SemanticZoomLocation) -> HRESULT,
    fn put_DestinationItem(&self, value: *mut SemanticZoomLocation) -> HRESULT
}}
impl ISemanticZoomViewChangedEventArgs {
    #[inline] pub unsafe fn get_is_source_zoomed_in_view(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSourceZoomedInView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_source_zoomed_in_view(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSourceZoomedInView)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_source_item(&self) -> Result<ComPtr<SemanticZoomLocation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourceItem)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_source_item(&self, value: &SemanticZoomLocation) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SourceItem)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_destination_item(&self) -> Result<ComPtr<SemanticZoomLocation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DestinationItem)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_destination_item(&self, value: &SemanticZoomLocation) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DestinationItem)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IStyleSelector, 3507568487, 55489, 19172, 152, 240, 216, 80, 69, 2, 240, 139);
RT_INTERFACE!{interface IStyleSelector(IStyleSelectorVtbl): IInspectable(IInspectableVtbl) [IID_IStyleSelector] {
    fn SelectStyle(&self, item: *mut IInspectable, container: *mut super::DependencyObject, out: *mut *mut super::Style) -> HRESULT
}}
impl IStyleSelector {
    #[inline] pub unsafe fn select_style(&self, item: &IInspectable, container: &super::DependencyObject) -> Result<ComPtr<super::Style>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SelectStyle)(self as *const _ as *mut _, item as *const _ as *mut _, container as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IStyleSelectorOverrides, 145610349, 3630, 17312, 174, 202, 143, 170, 148, 185, 208, 23);
RT_INTERFACE!{interface IStyleSelectorOverrides(IStyleSelectorOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IStyleSelectorOverrides] {
    fn SelectStyleCore(&self, item: *mut IInspectable, container: *mut super::DependencyObject, out: *mut *mut super::Style) -> HRESULT
}}
impl IStyleSelectorOverrides {
    #[inline] pub unsafe fn select_style_core(&self, item: &IInspectable, container: &super::DependencyObject) -> Result<ComPtr<super::Style>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SelectStyleCore)(self as *const _ as *mut _, item as *const _ as *mut _, container as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IStyleSelectorFactory, 2660510439, 14177, 17535, 143, 151, 41, 227, 157, 94, 179, 16);
RT_INTERFACE!{interface IStyleSelectorFactory(IStyleSelectorFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IStyleSelectorFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut StyleSelector) -> HRESULT
}}
impl IStyleSelectorFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<StyleSelector>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextBoxTextChangingEventArgs, 1315588981, 17373, 20019, 172, 190, 45, 135, 150, 161, 121, 39);
RT_INTERFACE!{interface ITextBoxTextChangingEventArgs(ITextBoxTextChangingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ITextBoxTextChangingEventArgs] {
    
}}
DEFINE_IID!(IID_ITextBoxTextChangingEventArgs2, 3228712260, 21414, 16735, 169, 129, 80, 223, 175, 27, 236, 190);
RT_INTERFACE!{interface ITextBoxTextChangingEventArgs2(ITextBoxTextChangingEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_ITextBoxTextChangingEventArgs2] {
    fn get_IsContentChanging(&self, out: *mut bool) -> HRESULT
}}
impl ITextBoxTextChangingEventArgs2 {
    #[inline] pub unsafe fn get_is_content_changing(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsContentChanging)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class TextBoxTextChangingEventArgs: ITextBoxTextChangingEventArgs}
DEFINE_IID!(IID_ITextCompositionChangedEventArgs, 3116884210, 20663, 17437, 153, 12, 104, 85, 62, 46, 5, 107);
RT_INTERFACE!{interface ITextCompositionChangedEventArgs(ITextCompositionChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ITextCompositionChangedEventArgs] {
    fn get_StartIndex(&self, out: *mut i32) -> HRESULT,
    fn get_Length(&self, out: *mut i32) -> HRESULT
}}
impl ITextCompositionChangedEventArgs {
    #[inline] pub unsafe fn get_start_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StartIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_length(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Length)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class TextCompositionChangedEventArgs: ITextCompositionChangedEventArgs}
DEFINE_IID!(IID_ITextCompositionEndedEventArgs, 1189301682, 30656, 16405, 142, 180, 146, 238, 253, 252, 89, 20);
RT_INTERFACE!{interface ITextCompositionEndedEventArgs(ITextCompositionEndedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ITextCompositionEndedEventArgs] {
    fn get_StartIndex(&self, out: *mut i32) -> HRESULT,
    fn get_Length(&self, out: *mut i32) -> HRESULT
}}
impl ITextCompositionEndedEventArgs {
    #[inline] pub unsafe fn get_start_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StartIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_length(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Length)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class TextCompositionEndedEventArgs: ITextCompositionEndedEventArgs}
DEFINE_IID!(IID_ITextCompositionStartedEventArgs, 3743591346, 4303, 18718, 145, 232, 211, 205, 114, 216, 160, 211);
RT_INTERFACE!{interface ITextCompositionStartedEventArgs(ITextCompositionStartedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ITextCompositionStartedEventArgs] {
    fn get_StartIndex(&self, out: *mut i32) -> HRESULT,
    fn get_Length(&self, out: *mut i32) -> HRESULT
}}
impl ITextCompositionStartedEventArgs {
    #[inline] pub unsafe fn get_start_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StartIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_length(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Length)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class TextCompositionStartedEventArgs: ITextCompositionStartedEventArgs}
DEFINE_IID!(IID_ITextControlPasteEventArgs, 1272043045, 8730, 18302, 187, 44, 173, 12, 30, 209, 37, 231);
RT_INTERFACE!{interface ITextControlPasteEventArgs(ITextControlPasteEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ITextControlPasteEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT
}}
impl ITextControlPasteEventArgs {
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IToolTipService, 61169543, 49100, 18974, 143, 234, 152, 246, 16, 131, 44, 234);
RT_INTERFACE!{interface IToolTipService(IToolTipServiceVtbl): IInspectable(IInspectableVtbl) [IID_IToolTipService] {
    
}}
DEFINE_IID!(IID_IToolTipServiceStatics, 2263239160, 57925, 18602, 168, 200, 209, 7, 62, 215, 99, 25);
RT_INTERFACE!{static interface IToolTipServiceStatics(IToolTipServiceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IToolTipServiceStatics] {
    fn get_PlacementProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetPlacement(&self, element: *mut super::DependencyObject, out: *mut primitives::PlacementMode) -> HRESULT,
    fn SetPlacement(&self, element: *mut super::DependencyObject, value: primitives::PlacementMode) -> HRESULT,
    fn get_PlacementTargetProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetPlacementTarget(&self, element: *mut super::DependencyObject, out: *mut *mut super::UIElement) -> HRESULT,
    fn SetPlacementTarget(&self, element: *mut super::DependencyObject, value: *mut super::UIElement) -> HRESULT,
    fn get_ToolTipProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetToolTip(&self, element: *mut super::DependencyObject, out: *mut *mut IInspectable) -> HRESULT,
    fn SetToolTip(&self, element: *mut super::DependencyObject, value: *mut IInspectable) -> HRESULT
}}
impl IToolTipServiceStatics {
    #[inline] pub unsafe fn get_placement_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlacementProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placement(&self, element: &super::DependencyObject) -> Result<primitives::PlacementMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetPlacement)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_placement(&self, element: &super::DependencyObject, value: primitives::PlacementMode) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPlacement)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placement_target_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlacementTargetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placement_target(&self, element: &super::DependencyObject) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetPlacementTarget)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_placement_target(&self, element: &super::DependencyObject, value: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPlacementTarget)(self as *const _ as *mut _, element as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tool_tip_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ToolTipProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tool_tip(&self, element: &super::DependencyObject) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetToolTip)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_tool_tip(&self, element: &super::DependencyObject, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).SetToolTip)(self as *const _ as *mut _, element as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ToolTipService: IToolTipService}
impl RtActivatable<IToolTipServiceStatics> for ToolTipService {}
impl ToolTipService {
    #[inline] pub fn get_placement_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IToolTipServiceStatics>>::get_activation_factory().get_placement_property()
    }}
    #[inline] pub fn get_placement(element: &super::DependencyObject) -> Result<primitives::PlacementMode> { unsafe {
        <Self as RtActivatable<IToolTipServiceStatics>>::get_activation_factory().get_placement(element)
    }}
    #[inline] pub fn set_placement(element: &super::DependencyObject, value: primitives::PlacementMode) -> Result<()> { unsafe {
        <Self as RtActivatable<IToolTipServiceStatics>>::get_activation_factory().set_placement(element, value)
    }}
    #[inline] pub fn get_placement_target_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IToolTipServiceStatics>>::get_activation_factory().get_placement_target_property()
    }}
    #[inline] pub fn get_placement_target(element: &super::DependencyObject) -> Result<ComPtr<super::UIElement>> { unsafe {
        <Self as RtActivatable<IToolTipServiceStatics>>::get_activation_factory().get_placement_target(element)
    }}
    #[inline] pub fn set_placement_target(element: &super::DependencyObject, value: &super::UIElement) -> Result<()> { unsafe {
        <Self as RtActivatable<IToolTipServiceStatics>>::get_activation_factory().set_placement_target(element, value)
    }}
    #[inline] pub fn get_tool_tip_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IToolTipServiceStatics>>::get_activation_factory().get_tool_tip_property()
    }}
    #[inline] pub fn get_tool_tip(element: &super::DependencyObject) -> Result<ComPtr<IInspectable>> { unsafe {
        <Self as RtActivatable<IToolTipServiceStatics>>::get_activation_factory().get_tool_tip(element)
    }}
    #[inline] pub fn set_tool_tip(element: &super::DependencyObject, value: &IInspectable) -> Result<()> { unsafe {
        <Self as RtActivatable<IToolTipServiceStatics>>::get_activation_factory().set_tool_tip(element, value)
    }}
}
DEFINE_CLSID!(ToolTipService(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,84,111,111,108,84,105,112,83,101,114,118,105,99,101,0]) [CLSID_ToolTipService]);
DEFINE_IID!(IID_IUIElementCollection, 3596627284, 35062, 17398, 133, 216, 169, 217, 20, 166, 221, 59);
RT_INTERFACE!{interface IUIElementCollection(IUIElementCollectionVtbl): IInspectable(IInspectableVtbl) [IID_IUIElementCollection] {
    fn Move(&self, oldIndex: u32, newIndex: u32) -> HRESULT
}}
impl IUIElementCollection {
    #[inline] pub unsafe fn move_(&self, oldIndex: u32, newIndex: u32) -> Result<()> {
        let hr = ((*self.lpVtbl).Move)(self as *const _ as *mut _, oldIndex, newIndex);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class UIElementCollection: ::rt::gen::windows::foundation::collections::IVector<super::UIElement>}
DEFINE_IID!(IID_ICleanUpVirtualizedItemEventArgs, 3926248681, 37756, 16672, 132, 6, 121, 33, 133, 120, 67, 56);
RT_INTERFACE!{interface ICleanUpVirtualizedItemEventArgs(ICleanUpVirtualizedItemEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICleanUpVirtualizedItemEventArgs] {
    fn get_Value(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn get_UIElement(&self, out: *mut *mut super::UIElement) -> HRESULT,
    fn get_Cancel(&self, out: *mut bool) -> HRESULT,
    fn put_Cancel(&self, value: bool) -> HRESULT
}}
impl ICleanUpVirtualizedItemEventArgs {
    #[inline] pub unsafe fn get_value(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Value)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_uielement(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UIElement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_cancel(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cancel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_cancel(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Cancel)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IColumnDefinition, 4159812137, 61476, 18047, 151, 10, 126, 112, 86, 21, 219, 123);
RT_INTERFACE!{interface IColumnDefinition(IColumnDefinitionVtbl): IInspectable(IInspectableVtbl) [IID_IColumnDefinition] {
    fn get_Width(&self, out: *mut super::GridLength) -> HRESULT,
    fn put_Width(&self, value: super::GridLength) -> HRESULT,
    fn get_MaxWidth(&self, out: *mut f64) -> HRESULT,
    fn put_MaxWidth(&self, value: f64) -> HRESULT,
    fn get_MinWidth(&self, out: *mut f64) -> HRESULT,
    fn put_MinWidth(&self, value: f64) -> HRESULT,
    fn get_ActualWidth(&self, out: *mut f64) -> HRESULT
}}
impl IColumnDefinition {
    #[inline] pub unsafe fn get_width(&self) -> Result<super::GridLength> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Width)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_width(&self, value: super::GridLength) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Width)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_width(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxWidth)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_min_width(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MinWidth)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_actual_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ActualWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IColumnDefinitionStatics, 112252712, 53316, 16582, 148, 46, 174, 96, 234, 199, 72, 81);
RT_INTERFACE!{static interface IColumnDefinitionStatics(IColumnDefinitionStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IColumnDefinitionStatics] {
    fn get_WidthProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MaxWidthProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MinWidthProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IColumnDefinitionStatics {
    #[inline] pub unsafe fn get_width_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_WidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_width_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxWidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_width_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MinWidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContextMenuEventArgs, 528347747, 49483, 17704, 182, 240, 99, 121, 153, 216, 60, 198);
RT_INTERFACE!{interface IContextMenuEventArgs(IContextMenuEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContextMenuEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn get_CursorLeft(&self, out: *mut f64) -> HRESULT,
    fn get_CursorTop(&self, out: *mut f64) -> HRESULT
}}
impl IContextMenuEventArgs {
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_cursor_left(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CursorLeft)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_cursor_top(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CursorTop)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemClickEventArgs, 2620473922, 62106, 18765, 163, 165, 212, 199, 178, 164, 104, 82);
RT_INTERFACE!{interface IItemClickEventArgs(IItemClickEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IItemClickEventArgs] {
    fn get_ClickedItem(&self, out: *mut *mut IInspectable) -> HRESULT
}}
impl IItemClickEventArgs {
    #[inline] pub unsafe fn get_clicked_item(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ClickedItem)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRowDefinition, 1253763113, 55308, 19038, 164, 140, 248, 179, 211, 182, 83, 61);
RT_INTERFACE!{interface IRowDefinition(IRowDefinitionVtbl): IInspectable(IInspectableVtbl) [IID_IRowDefinition] {
    fn get_Height(&self, out: *mut super::GridLength) -> HRESULT,
    fn put_Height(&self, value: super::GridLength) -> HRESULT,
    fn get_MaxHeight(&self, out: *mut f64) -> HRESULT,
    fn put_MaxHeight(&self, value: f64) -> HRESULT,
    fn get_MinHeight(&self, out: *mut f64) -> HRESULT,
    fn put_MinHeight(&self, value: f64) -> HRESULT,
    fn get_ActualHeight(&self, out: *mut f64) -> HRESULT
}}
impl IRowDefinition {
    #[inline] pub unsafe fn get_height(&self) -> Result<super::GridLength> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Height)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_height(&self, value: super::GridLength) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Height)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_height(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxHeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_min_height(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MinHeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_actual_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ActualHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRowDefinitionStatics, 1524580325, 8278, 18212, 148, 214, 228, 129, 43, 2, 46, 200);
RT_INTERFACE!{static interface IRowDefinitionStatics(IRowDefinitionStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRowDefinitionStatics] {
    fn get_HeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MaxHeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MinHeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IRowDefinitionStatics {
    #[inline] pub unsafe fn get_height_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_height_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_height_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MinHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISelectionChangedEventArgs, 3379745500, 46601, 18264, 133, 30, 167, 153, 194, 29, 233, 125);
RT_INTERFACE!{interface ISelectionChangedEventArgs(ISelectionChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISelectionChangedEventArgs] {
    fn get_AddedItems(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<IInspectable>) -> HRESULT,
    fn get_RemovedItems(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<IInspectable>) -> HRESULT
}}
impl ISelectionChangedEventArgs {
    #[inline] pub unsafe fn get_added_items(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<IInspectable>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AddedItems)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_removed_items(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<IInspectable>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RemovedItems)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISelectionChangedEventArgsFactory, 296269493, 10288, 17687, 132, 205, 85, 36, 200, 184, 139, 69);
RT_INTERFACE!{interface ISelectionChangedEventArgsFactory(ISelectionChangedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISelectionChangedEventArgsFactory] {
    fn CreateInstanceWithRemovedItemsAndAddedItems(&self, removedItems: *mut ::rt::gen::windows::foundation::collections::IVector<IInspectable>, addedItems: *mut ::rt::gen::windows::foundation::collections::IVector<IInspectable>, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut SelectionChangedEventArgs) -> HRESULT
}}
impl ISelectionChangedEventArgsFactory {
    #[inline] pub unsafe fn create_instance_with_removed_items_and_added_items(&self, removedItems: &::rt::gen::windows::foundation::collections::IVector<IInspectable>, addedItems: &::rt::gen::windows::foundation::collections::IVector<IInspectable>, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<SelectionChangedEventArgs>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithRemovedItemsAndAddedItems)(self as *const _ as *mut _, removedItems as *const _ as *mut _, addedItems as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextChangedEventArgs, 1305497469, 31249, 19246, 153, 51, 87, 125, 243, 146, 82, 182);
RT_INTERFACE!{interface ITextChangedEventArgs(ITextChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ITextChangedEventArgs] {
    
}}
DEFINE_IID!(IID_IItemsPanelTemplate, 350934888, 13490, 19351, 191, 60, 232, 215, 50, 48, 162, 170);
RT_INTERFACE!{interface IItemsPanelTemplate(IItemsPanelTemplateVtbl): IInspectable(IInspectableVtbl) [IID_IItemsPanelTemplate] {
    
}}
DEFINE_IID!(IID_IBorder, 2038187321, 17853, 17971, 160, 68, 191, 176, 46, 245, 23, 15);
RT_INTERFACE!{interface IBorder(IBorderVtbl): IInspectable(IInspectableVtbl) [IID_IBorder] {
    fn get_BorderBrush(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_BorderBrush(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_BorderThickness(&self, out: *mut super::Thickness) -> HRESULT,
    fn put_BorderThickness(&self, value: super::Thickness) -> HRESULT,
    fn get_Background(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_Background(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_CornerRadius(&self, out: *mut super::CornerRadius) -> HRESULT,
    fn put_CornerRadius(&self, value: super::CornerRadius) -> HRESULT,
    fn get_Padding(&self, out: *mut super::Thickness) -> HRESULT,
    fn put_Padding(&self, value: super::Thickness) -> HRESULT,
    fn get_Child(&self, out: *mut *mut super::UIElement) -> HRESULT,
    fn put_Child(&self, value: *mut super::UIElement) -> HRESULT,
    fn get_ChildTransitions(&self, out: *mut *mut super::media::animation::TransitionCollection) -> HRESULT,
    fn put_ChildTransitions(&self, value: *mut super::media::animation::TransitionCollection) -> HRESULT
}}
impl IBorder {
    #[inline] pub unsafe fn get_border_brush(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BorderBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_border_brush(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BorderBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_border_thickness(&self) -> Result<super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BorderThickness)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_border_thickness(&self, value: super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BorderThickness)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_background(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Background)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_background(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Background)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_corner_radius(&self) -> Result<super::CornerRadius> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CornerRadius)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_corner_radius(&self, value: super::CornerRadius) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CornerRadius)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_padding(&self) -> Result<super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Padding)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_padding(&self, value: super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Padding)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_child(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Child)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_child(&self, value: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Child)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_child_transitions(&self) -> Result<ComPtr<super::media::animation::TransitionCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ChildTransitions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_child_transitions(&self, value: &super::media::animation::TransitionCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ChildTransitions)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBorderStatics, 3088913977, 59665, 20439, 164, 196, 185, 199, 240, 8, 183, 252);
RT_INTERFACE!{static interface IBorderStatics(IBorderStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBorderStatics] {
    fn get_BorderBrushProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_BorderThicknessProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_BackgroundProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CornerRadiusProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PaddingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ChildTransitionsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IBorderStatics {
    #[inline] pub unsafe fn get_border_brush_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BorderBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_border_thickness_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BorderThicknessProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_background_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BackgroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_corner_radius_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CornerRadiusProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_padding_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PaddingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_child_transitions_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ChildTransitionsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICaptureElement, 832946407, 62215, 19786, 182, 38, 233, 120, 134, 63, 91, 116);
RT_INTERFACE!{interface ICaptureElement(ICaptureElementVtbl): IInspectable(IInspectableVtbl) [IID_ICaptureElement] {
    #[cfg(not(feature="windows-media"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-media")] fn get_Source(&self, out: *mut *mut ::rt::gen::windows::media::capture::MediaCapture) -> HRESULT,
    #[cfg(not(feature="windows-media"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-media")] fn put_Source(&self, value: *mut ::rt::gen::windows::media::capture::MediaCapture) -> HRESULT,
    fn get_Stretch(&self, out: *mut super::media::Stretch) -> HRESULT,
    fn put_Stretch(&self, value: super::media::Stretch) -> HRESULT
}}
impl ICaptureElement {
    #[cfg(feature="windows-media")] #[inline] pub unsafe fn get_source(&self) -> Result<ComPtr<::rt::gen::windows::media::capture::MediaCapture>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Source)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-media")] #[inline] pub unsafe fn set_source(&self, value: &::rt::gen::windows::media::capture::MediaCapture) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Source)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stretch(&self) -> Result<super::media::Stretch> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Stretch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stretch(&self, value: super::media::Stretch) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Stretch)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICaptureElementStatics, 507743725, 32166, 16542, 128, 110, 48, 90, 228, 173, 155, 63);
RT_INTERFACE!{static interface ICaptureElementStatics(ICaptureElementStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICaptureElementStatics] {
    fn get_SourceProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_StretchProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ICaptureElementStatics {
    #[inline] pub unsafe fn get_source_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourceProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stretch_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StretchProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContentPresenter, 2046682548, 52535, 18716, 136, 69, 218, 244, 114, 222, 255, 246);
RT_INTERFACE!{interface IContentPresenter(IContentPresenterVtbl): IInspectable(IInspectableVtbl) [IID_IContentPresenter] {
    fn get_Content(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Content(&self, value: *mut IInspectable) -> HRESULT,
    fn get_ContentTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_ContentTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_ContentTemplateSelector(&self, out: *mut *mut DataTemplateSelector) -> HRESULT,
    fn put_ContentTemplateSelector(&self, value: *mut DataTemplateSelector) -> HRESULT,
    fn get_ContentTransitions(&self, out: *mut *mut super::media::animation::TransitionCollection) -> HRESULT,
    fn put_ContentTransitions(&self, value: *mut super::media::animation::TransitionCollection) -> HRESULT,
    fn get_FontSize(&self, out: *mut f64) -> HRESULT,
    fn put_FontSize(&self, value: f64) -> HRESULT,
    fn get_FontFamily(&self, out: *mut *mut super::media::FontFamily) -> HRESULT,
    fn put_FontFamily(&self, value: *mut super::media::FontFamily) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy12(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FontWeight(&self, out: *mut super::super::text::FontWeight) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy13(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_FontWeight(&self, value: super::super::text::FontWeight) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy14(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FontStyle(&self, out: *mut super::super::text::FontStyle) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy15(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_FontStyle(&self, value: super::super::text::FontStyle) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy16(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FontStretch(&self, out: *mut super::super::text::FontStretch) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy17(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_FontStretch(&self, value: super::super::text::FontStretch) -> HRESULT,
    fn get_CharacterSpacing(&self, out: *mut i32) -> HRESULT,
    fn put_CharacterSpacing(&self, value: i32) -> HRESULT,
    fn get_Foreground(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_Foreground(&self, value: *mut super::media::Brush) -> HRESULT
}}
impl IContentPresenter {
    #[inline] pub unsafe fn get_content(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Content)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Content)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_template_selector(&self) -> Result<ComPtr<DataTemplateSelector>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTemplateSelector)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_template_selector(&self, value: &DataTemplateSelector) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentTemplateSelector)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_transitions(&self) -> Result<ComPtr<super::media::animation::TransitionCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTransitions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_transitions(&self, value: &super::media::animation::TransitionCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentTransitions)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_size(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_font_size(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontSize)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_family(&self) -> Result<ComPtr<super::media::FontFamily>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontFamily)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_font_family(&self, value: &super::media::FontFamily) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontFamily)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_font_weight(&self) -> Result<super::super::text::FontWeight> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontWeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_font_weight(&self, value: super::super::text::FontWeight) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontWeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_font_style(&self) -> Result<super::super::text::FontStyle> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_font_style(&self, value: super::super::text::FontStyle) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontStyle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_font_stretch(&self) -> Result<super::super::text::FontStretch> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontStretch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_font_stretch(&self, value: super::super::text::FontStretch) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontStretch)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_character_spacing(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CharacterSpacing)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_character_spacing(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CharacterSpacing)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_foreground(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Foreground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_foreground(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Foreground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContentPresenterOverrides, 2808297965, 13055, 17291, 170, 213, 29, 104, 250, 233, 52, 38);
RT_INTERFACE!{interface IContentPresenterOverrides(IContentPresenterOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IContentPresenterOverrides] {
    fn OnContentTemplateChanged(&self, oldContentTemplate: *mut super::DataTemplate, newContentTemplate: *mut super::DataTemplate) -> HRESULT,
    fn OnContentTemplateSelectorChanged(&self, oldContentTemplateSelector: *mut DataTemplateSelector, newContentTemplateSelector: *mut DataTemplateSelector) -> HRESULT
}}
impl IContentPresenterOverrides {
    #[inline] pub unsafe fn on_content_template_changed(&self, oldContentTemplate: &super::DataTemplate, newContentTemplate: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).OnContentTemplateChanged)(self as *const _ as *mut _, oldContentTemplate as *const _ as *mut _, newContentTemplate as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_content_template_selector_changed(&self, oldContentTemplateSelector: &DataTemplateSelector, newContentTemplateSelector: &DataTemplateSelector) -> Result<()> {
        let hr = ((*self.lpVtbl).OnContentTemplateSelectorChanged)(self as *const _ as *mut _, oldContentTemplateSelector as *const _ as *mut _, newContentTemplateSelector as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContentPresenterStatics, 415402299, 55854, 17446, 184, 90, 44, 126, 33, 113, 190, 223);
RT_INTERFACE!{static interface IContentPresenterStatics(IContentPresenterStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IContentPresenterStatics] {
    fn get_ContentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ContentTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ContentTemplateSelectorProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ContentTransitionsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontSizeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontFamilyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontWeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontStyleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontStretchProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CharacterSpacingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ForegroundProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IContentPresenterStatics {
    #[inline] pub unsafe fn get_content_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_template_selector_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTemplateSelectorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_transitions_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTransitionsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_size_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontSizeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_family_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontFamilyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_weight_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontWeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_style_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_stretch_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontStretchProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_character_spacing_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CharacterSpacingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_foreground_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ForegroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContentPresenterFactory, 859428087, 18453, 17604, 159, 118, 104, 200, 56, 128, 239, 16);
RT_INTERFACE!{interface IContentPresenterFactory(IContentPresenterFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IContentPresenterFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ContentPresenter) -> HRESULT
}}
impl IContentPresenterFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ContentPresenter>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContentPresenter2, 1362684248, 13149, 16912, 139, 187, 10, 162, 180, 181, 194, 158);
RT_INTERFACE!{interface IContentPresenter2(IContentPresenter2Vtbl): IInspectable(IInspectableVtbl) [IID_IContentPresenter2] {
    fn get_OpticalMarginAlignment(&self, out: *mut super::OpticalMarginAlignment) -> HRESULT,
    fn put_OpticalMarginAlignment(&self, value: super::OpticalMarginAlignment) -> HRESULT,
    fn get_TextLineBounds(&self, out: *mut super::TextLineBounds) -> HRESULT,
    fn put_TextLineBounds(&self, value: super::TextLineBounds) -> HRESULT
}}
impl IContentPresenter2 {
    #[inline] pub unsafe fn get_optical_margin_alignment(&self) -> Result<super::OpticalMarginAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OpticalMarginAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_optical_margin_alignment(&self, value: super::OpticalMarginAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OpticalMarginAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_line_bounds(&self) -> Result<super::TextLineBounds> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextLineBounds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_line_bounds(&self, value: super::TextLineBounds) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextLineBounds)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContentPresenterStatics2, 3352862169, 1766, 18110, 168, 160, 156, 17, 125, 48, 36, 163);
RT_INTERFACE!{static interface IContentPresenterStatics2(IContentPresenterStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IContentPresenterStatics2] {
    fn get_OpticalMarginAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextLineBoundsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IContentPresenterStatics2 {
    #[inline] pub unsafe fn get_optical_margin_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OpticalMarginAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_line_bounds_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextLineBoundsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContentPresenter3, 2956494698, 40013, 17410, 172, 86, 162, 35, 72, 125, 198, 200);
RT_INTERFACE!{interface IContentPresenter3(IContentPresenter3Vtbl): IInspectable(IInspectableVtbl) [IID_IContentPresenter3] {
    fn get_IsTextScaleFactorEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsTextScaleFactorEnabled(&self, value: bool) -> HRESULT
}}
impl IContentPresenter3 {
    #[inline] pub unsafe fn get_is_text_scale_factor_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTextScaleFactorEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_text_scale_factor_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsTextScaleFactorEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContentPresenterStatics3, 3420901211, 14513, 19805, 176, 152, 188, 148, 179, 92, 141, 223);
RT_INTERFACE!{static interface IContentPresenterStatics3(IContentPresenterStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IContentPresenterStatics3] {
    fn get_IsTextScaleFactorEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IContentPresenterStatics3 {
    #[inline] pub unsafe fn get_is_text_scale_factor_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsTextScaleFactorEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContentPresenter4, 2574981911, 15352, 17195, 143, 217, 104, 199, 186, 178, 31, 157);
RT_INTERFACE!{interface IContentPresenter4(IContentPresenter4Vtbl): IInspectable(IInspectableVtbl) [IID_IContentPresenter4] {
    fn get_TextWrapping(&self, out: *mut super::TextWrapping) -> HRESULT,
    fn put_TextWrapping(&self, value: super::TextWrapping) -> HRESULT,
    fn get_MaxLines(&self, out: *mut i32) -> HRESULT,
    fn put_MaxLines(&self, value: i32) -> HRESULT,
    fn get_LineStackingStrategy(&self, out: *mut super::LineStackingStrategy) -> HRESULT,
    fn put_LineStackingStrategy(&self, value: super::LineStackingStrategy) -> HRESULT,
    fn get_LineHeight(&self, out: *mut f64) -> HRESULT,
    fn put_LineHeight(&self, value: f64) -> HRESULT,
    fn get_BorderBrush(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_BorderBrush(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_BorderThickness(&self, out: *mut super::Thickness) -> HRESULT,
    fn put_BorderThickness(&self, value: super::Thickness) -> HRESULT,
    fn get_CornerRadius(&self, out: *mut super::CornerRadius) -> HRESULT,
    fn put_CornerRadius(&self, value: super::CornerRadius) -> HRESULT,
    fn get_Padding(&self, out: *mut super::Thickness) -> HRESULT,
    fn put_Padding(&self, value: super::Thickness) -> HRESULT,
    fn get_Background(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_Background(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_HorizontalContentAlignment(&self, out: *mut super::HorizontalAlignment) -> HRESULT,
    fn put_HorizontalContentAlignment(&self, value: super::HorizontalAlignment) -> HRESULT,
    fn get_VerticalContentAlignment(&self, out: *mut super::VerticalAlignment) -> HRESULT,
    fn put_VerticalContentAlignment(&self, value: super::VerticalAlignment) -> HRESULT
}}
impl IContentPresenter4 {
    #[inline] pub unsafe fn get_text_wrapping(&self) -> Result<super::TextWrapping> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextWrapping)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_wrapping(&self, value: super::TextWrapping) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextWrapping)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_lines(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxLines)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_lines(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxLines)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_line_stacking_strategy(&self) -> Result<super::LineStackingStrategy> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LineStackingStrategy)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_line_stacking_strategy(&self, value: super::LineStackingStrategy) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LineStackingStrategy)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_line_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LineHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_line_height(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LineHeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_border_brush(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BorderBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_border_brush(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BorderBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_border_thickness(&self) -> Result<super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BorderThickness)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_border_thickness(&self, value: super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BorderThickness)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_corner_radius(&self) -> Result<super::CornerRadius> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CornerRadius)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_corner_radius(&self, value: super::CornerRadius) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CornerRadius)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_padding(&self) -> Result<super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Padding)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_padding(&self, value: super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Padding)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_background(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Background)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_background(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Background)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_content_alignment(&self) -> Result<super::HorizontalAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalContentAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_horizontal_content_alignment(&self, value: super::HorizontalAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HorizontalContentAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_content_alignment(&self) -> Result<super::VerticalAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalContentAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_vertical_content_alignment(&self, value: super::VerticalAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_VerticalContentAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContentPresenterStatics4, 4287357586, 44840, 18411, 165, 195, 220, 68, 206, 212, 15, 210);
RT_INTERFACE!{static interface IContentPresenterStatics4(IContentPresenterStatics4Vtbl): IInspectable(IInspectableVtbl) [IID_IContentPresenterStatics4] {
    fn get_TextWrappingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MaxLinesProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_LineStackingStrategyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_LineHeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_BorderBrushProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_BorderThicknessProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CornerRadiusProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PaddingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_BackgroundProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HorizontalContentAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_VerticalContentAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IContentPresenterStatics4 {
    #[inline] pub unsafe fn get_text_wrapping_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextWrappingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_lines_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxLinesProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_line_stacking_strategy_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LineStackingStrategyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_line_height_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LineHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_border_brush_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BorderBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_border_thickness_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BorderThicknessProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_corner_radius_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CornerRadiusProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_padding_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PaddingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_background_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BackgroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_content_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HorizontalContentAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_content_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VerticalContentAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IImage, 1230730242, 39667, 20048, 170, 144, 3, 56, 143, 48, 134, 210);
RT_INTERFACE!{interface IImage(IImageVtbl): IInspectable(IInspectableVtbl) [IID_IImage] {
    fn get_Source(&self, out: *mut *mut super::media::ImageSource) -> HRESULT,
    fn put_Source(&self, value: *mut super::media::ImageSource) -> HRESULT,
    fn get_Stretch(&self, out: *mut super::media::Stretch) -> HRESULT,
    fn put_Stretch(&self, value: super::media::Stretch) -> HRESULT,
    fn get_NineGrid(&self, out: *mut super::Thickness) -> HRESULT,
    fn put_NineGrid(&self, value: super::Thickness) -> HRESULT,
    #[cfg(not(feature="windows-media"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-media")] fn get_PlayToSource(&self, out: *mut *mut ::rt::gen::windows::media::playto::PlayToSource) -> HRESULT,
    fn add_ImageFailed(&self, value: *mut super::ExceptionRoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ImageFailed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ImageOpened(&self, value: *mut super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ImageOpened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IImage {
    #[inline] pub unsafe fn get_source(&self) -> Result<ComPtr<super::media::ImageSource>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Source)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_source(&self, value: &super::media::ImageSource) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Source)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stretch(&self) -> Result<super::media::Stretch> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Stretch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stretch(&self, value: super::media::Stretch) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Stretch)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_nine_grid(&self) -> Result<super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NineGrid)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_nine_grid(&self, value: super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_NineGrid)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-media")] #[inline] pub unsafe fn get_play_to_source(&self) -> Result<ComPtr<::rt::gen::windows::media::playto::PlayToSource>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlayToSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_image_failed(&self, value: &super::ExceptionRoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ImageFailed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_image_failed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ImageFailed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_image_opened(&self, value: &super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ImageOpened)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_image_opened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ImageOpened)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IImageStatics, 2307929970, 49974, 17361, 157, 81, 195, 187, 213, 213, 214, 145);
RT_INTERFACE!{static interface IImageStatics(IImageStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IImageStatics] {
    fn get_SourceProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_StretchProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_NineGridProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PlayToSourceProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IImageStatics {
    #[inline] pub unsafe fn get_source_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourceProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stretch_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StretchProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_nine_grid_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NineGridProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_play_to_source_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlayToSourceProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IImage2, 4098167198, 34847, 18619, 135, 58, 100, 65, 124, 164, 240, 2);
RT_INTERFACE!{interface IImage2(IImage2Vtbl): IInspectable(IInspectableVtbl) [IID_IImage2] {
    #[cfg(feature="windows-media")] fn GetAsCastingSource(&self, out: *mut *mut ::rt::gen::windows::media::casting::CastingSource) -> HRESULT
}}
impl IImage2 {
    #[cfg(feature="windows-media")] #[inline] pub unsafe fn get_as_casting_source(&self) -> Result<ComPtr<::rt::gen::windows::media::casting::CastingSource>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAsCastingSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IImage3, 116123538, 18370, 19858, 164, 136, 140, 214, 133, 208, 106, 202);
RT_INTERFACE!{interface IImage3(IImage3Vtbl): IInspectable(IInspectableVtbl) [IID_IImage3] {
    #[cfg(feature="windows-ui")] fn GetAlphaMask(&self, out: *mut *mut super::super::composition::CompositionBrush) -> HRESULT
}}
impl IImage3 {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_alpha_mask(&self) -> Result<ComPtr<super::super::composition::CompositionBrush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAlphaMask)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemsPresenter, 3262207643, 28106, 20011, 142, 20, 197, 81, 54, 176, 42, 113);
RT_INTERFACE!{interface IItemsPresenter(IItemsPresenterVtbl): IInspectable(IInspectableVtbl) [IID_IItemsPresenter] {
    fn get_Header(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Header(&self, value: *mut IInspectable) -> HRESULT,
    fn get_HeaderTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_HeaderTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_HeaderTransitions(&self, out: *mut *mut super::media::animation::TransitionCollection) -> HRESULT,
    fn put_HeaderTransitions(&self, value: *mut super::media::animation::TransitionCollection) -> HRESULT,
    fn get_Padding(&self, out: *mut super::Thickness) -> HRESULT,
    fn put_Padding(&self, value: super::Thickness) -> HRESULT
}}
impl IItemsPresenter {
    #[inline] pub unsafe fn get_header(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Header)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Header)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_transitions(&self) -> Result<ComPtr<super::media::animation::TransitionCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTransitions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_transitions(&self, value: &super::media::animation::TransitionCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderTransitions)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_padding(&self) -> Result<super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Padding)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_padding(&self, value: super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Padding)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemsPresenterStatics, 417228493, 19052, 19246, 170, 134, 203, 18, 108, 154, 41, 32);
RT_INTERFACE!{static interface IItemsPresenterStatics(IItemsPresenterStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IItemsPresenterStatics] {
    fn get_HeaderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HeaderTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HeaderTransitionsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PaddingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IItemsPresenterStatics {
    #[inline] pub unsafe fn get_header_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_transitions_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTransitionsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_padding_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PaddingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemsPresenter2, 1543809587, 7667, 18225, 164, 201, 218, 129, 131, 120, 214, 61);
RT_INTERFACE!{interface IItemsPresenter2(IItemsPresenter2Vtbl): IInspectable(IInspectableVtbl) [IID_IItemsPresenter2] {
    fn get_Footer(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Footer(&self, value: *mut IInspectable) -> HRESULT,
    fn get_FooterTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_FooterTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_FooterTransitions(&self, out: *mut *mut super::media::animation::TransitionCollection) -> HRESULT,
    fn put_FooterTransitions(&self, value: *mut super::media::animation::TransitionCollection) -> HRESULT
}}
impl IItemsPresenter2 {
    #[inline] pub unsafe fn get_footer(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Footer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_footer(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Footer)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_footer_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FooterTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_footer_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FooterTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_footer_transitions(&self) -> Result<ComPtr<super::media::animation::TransitionCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FooterTransitions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_footer_transitions(&self, value: &super::media::animation::TransitionCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FooterTransitions)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemsPresenterStatics2, 2305909550, 30823, 19814, 150, 48, 41, 241, 197, 247, 64, 63);
RT_INTERFACE!{static interface IItemsPresenterStatics2(IItemsPresenterStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IItemsPresenterStatics2] {
    fn get_FooterProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FooterTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FooterTransitionsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IItemsPresenterStatics2 {
    #[inline] pub unsafe fn get_footer_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FooterProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_footer_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FooterTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_footer_transitions_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FooterTransitionsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPanel, 2768915389, 33633, 18076, 144, 218, 233, 164, 12, 116, 116, 223);
RT_INTERFACE!{interface IPanel(IPanelVtbl): IInspectable(IInspectableVtbl) [IID_IPanel] {
    fn get_Children(&self, out: *mut *mut UIElementCollection) -> HRESULT,
    fn get_Background(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_Background(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_IsItemsHost(&self, out: *mut bool) -> HRESULT,
    fn get_ChildrenTransitions(&self, out: *mut *mut super::media::animation::TransitionCollection) -> HRESULT,
    fn put_ChildrenTransitions(&self, value: *mut super::media::animation::TransitionCollection) -> HRESULT
}}
impl IPanel {
    #[inline] pub unsafe fn get_children(&self) -> Result<ComPtr<UIElementCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Children)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_background(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Background)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_background(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Background)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_items_host(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsItemsHost)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_children_transitions(&self) -> Result<ComPtr<super::media::animation::TransitionCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ChildrenTransitions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_children_transitions(&self, value: &super::media::animation::TransitionCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ChildrenTransitions)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPanelStatics, 4064111453, 33584, 18342, 160, 70, 37, 245, 9, 178, 82, 50);
RT_INTERFACE!{static interface IPanelStatics(IPanelStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPanelStatics] {
    fn get_BackgroundProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsItemsHostProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ChildrenTransitionsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IPanelStatics {
    #[inline] pub unsafe fn get_background_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BackgroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_items_host_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsItemsHostProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_children_transitions_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ChildrenTransitionsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPanelFactory, 4008083729, 51148, 17215, 149, 205, 214, 48, 195, 67, 2, 221);
RT_INTERFACE!{interface IPanelFactory(IPanelFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPanelFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut Panel) -> HRESULT
}}
impl IPanelFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<Panel>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichTextBlock, 3858758114, 47464, 18919, 151, 212, 140, 202, 42, 195, 174, 124);
RT_INTERFACE!{interface IRichTextBlock(IRichTextBlockVtbl): IInspectable(IInspectableVtbl) [IID_IRichTextBlock] {
    fn get_FontSize(&self, out: *mut f64) -> HRESULT,
    fn put_FontSize(&self, value: f64) -> HRESULT,
    fn get_FontFamily(&self, out: *mut *mut super::media::FontFamily) -> HRESULT,
    fn put_FontFamily(&self, value: *mut super::media::FontFamily) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FontWeight(&self, out: *mut super::super::text::FontWeight) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_FontWeight(&self, value: super::super::text::FontWeight) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FontStyle(&self, out: *mut super::super::text::FontStyle) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_FontStyle(&self, value: super::super::text::FontStyle) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FontStretch(&self, out: *mut super::super::text::FontStretch) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy9(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_FontStretch(&self, value: super::super::text::FontStretch) -> HRESULT,
    fn get_Foreground(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_Foreground(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_TextWrapping(&self, out: *mut super::TextWrapping) -> HRESULT,
    fn put_TextWrapping(&self, value: super::TextWrapping) -> HRESULT,
    fn get_TextTrimming(&self, out: *mut super::TextTrimming) -> HRESULT,
    fn put_TextTrimming(&self, value: super::TextTrimming) -> HRESULT,
    fn get_TextAlignment(&self, out: *mut super::TextAlignment) -> HRESULT,
    fn put_TextAlignment(&self, value: super::TextAlignment) -> HRESULT,
    fn get_Blocks(&self, out: *mut *mut super::documents::BlockCollection) -> HRESULT,
    fn get_Padding(&self, out: *mut super::Thickness) -> HRESULT,
    fn put_Padding(&self, value: super::Thickness) -> HRESULT,
    fn get_LineHeight(&self, out: *mut f64) -> HRESULT,
    fn put_LineHeight(&self, value: f64) -> HRESULT,
    fn get_LineStackingStrategy(&self, out: *mut super::LineStackingStrategy) -> HRESULT,
    fn put_LineStackingStrategy(&self, value: super::LineStackingStrategy) -> HRESULT,
    fn get_CharacterSpacing(&self, out: *mut i32) -> HRESULT,
    fn put_CharacterSpacing(&self, value: i32) -> HRESULT,
    fn get_OverflowContentTarget(&self, out: *mut *mut RichTextBlockOverflow) -> HRESULT,
    fn put_OverflowContentTarget(&self, value: *mut RichTextBlockOverflow) -> HRESULT,
    fn get_IsTextSelectionEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsTextSelectionEnabled(&self, value: bool) -> HRESULT,
    fn get_HasOverflowContent(&self, out: *mut bool) -> HRESULT,
    fn get_SelectedText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ContentStart(&self, out: *mut *mut super::documents::TextPointer) -> HRESULT,
    fn get_ContentEnd(&self, out: *mut *mut super::documents::TextPointer) -> HRESULT,
    fn get_SelectionStart(&self, out: *mut *mut super::documents::TextPointer) -> HRESULT,
    fn get_SelectionEnd(&self, out: *mut *mut super::documents::TextPointer) -> HRESULT,
    fn get_BaselineOffset(&self, out: *mut f64) -> HRESULT,
    fn add_SelectionChanged(&self, value: *mut super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SelectionChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ContextMenuOpening(&self, value: *mut ContextMenuOpeningEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ContextMenuOpening(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn SelectAll(&self) -> HRESULT,
    fn Select(&self, start: *mut super::documents::TextPointer, end: *mut super::documents::TextPointer) -> HRESULT,
    fn GetPositionFromPoint(&self, point: ::rt::gen::windows::foundation::Point, out: *mut *mut super::documents::TextPointer) -> HRESULT,
    fn Focus(&self, value: super::FocusState, out: *mut bool) -> HRESULT,
    fn get_TextIndent(&self, out: *mut f64) -> HRESULT,
    fn put_TextIndent(&self, value: f64) -> HRESULT
}}
impl IRichTextBlock {
    #[inline] pub unsafe fn get_font_size(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_font_size(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontSize)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_family(&self) -> Result<ComPtr<super::media::FontFamily>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontFamily)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_font_family(&self, value: &super::media::FontFamily) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontFamily)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_font_weight(&self) -> Result<super::super::text::FontWeight> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontWeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_font_weight(&self, value: super::super::text::FontWeight) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontWeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_font_style(&self) -> Result<super::super::text::FontStyle> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_font_style(&self, value: super::super::text::FontStyle) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontStyle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_font_stretch(&self) -> Result<super::super::text::FontStretch> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontStretch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_font_stretch(&self, value: super::super::text::FontStretch) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontStretch)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_foreground(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Foreground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_foreground(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Foreground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_wrapping(&self) -> Result<super::TextWrapping> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextWrapping)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_wrapping(&self, value: super::TextWrapping) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextWrapping)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_trimming(&self) -> Result<super::TextTrimming> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextTrimming)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_trimming(&self, value: super::TextTrimming) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextTrimming)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_alignment(&self) -> Result<super::TextAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_alignment(&self, value: super::TextAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_blocks(&self) -> Result<ComPtr<super::documents::BlockCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Blocks)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_padding(&self) -> Result<super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Padding)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_padding(&self, value: super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Padding)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_line_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LineHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_line_height(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LineHeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_line_stacking_strategy(&self) -> Result<super::LineStackingStrategy> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LineStackingStrategy)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_line_stacking_strategy(&self, value: super::LineStackingStrategy) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LineStackingStrategy)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_character_spacing(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CharacterSpacing)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_character_spacing(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CharacterSpacing)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_overflow_content_target(&self) -> Result<ComPtr<RichTextBlockOverflow>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OverflowContentTarget)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_overflow_content_target(&self, value: &RichTextBlockOverflow) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OverflowContentTarget)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_text_selection_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTextSelectionEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_text_selection_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsTextSelectionEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_has_overflow_content(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HasOverflowContent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_start(&self) -> Result<ComPtr<super::documents::TextPointer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentStart)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_end(&self) -> Result<ComPtr<super::documents::TextPointer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentEnd)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_start(&self) -> Result<ComPtr<super::documents::TextPointer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionStart)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_end(&self) -> Result<ComPtr<super::documents::TextPointer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionEnd)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_baseline_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BaselineOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_selection_changed(&self, value: &super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SelectionChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_selection_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SelectionChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_context_menu_opening(&self, value: &ContextMenuOpeningEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ContextMenuOpening)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_context_menu_opening(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ContextMenuOpening)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn select_all(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).SelectAll)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn select(&self, start: &super::documents::TextPointer, end: &super::documents::TextPointer) -> Result<()> {
        let hr = ((*self.lpVtbl).Select)(self as *const _ as *mut _, start as *const _ as *mut _, end as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_position_from_point(&self, point: ::rt::gen::windows::foundation::Point) -> Result<ComPtr<super::documents::TextPointer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetPositionFromPoint)(self as *const _ as *mut _, point, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn focus(&self, value: super::FocusState) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Focus)(self as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_indent(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextIndent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_indent(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextIndent)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichTextBlockStatics, 1227720764, 44522, 17212, 190, 28, 32, 138, 22, 66, 98, 190);
RT_INTERFACE!{static interface IRichTextBlockStatics(IRichTextBlockStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRichTextBlockStatics] {
    fn get_FontSizeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontFamilyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontWeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontStyleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontStretchProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ForegroundProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextWrappingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextTrimmingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PaddingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_LineHeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_LineStackingStrategyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CharacterSpacingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OverflowContentTargetProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsTextSelectionEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HasOverflowContentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectedTextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextIndentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IRichTextBlockStatics {
    #[inline] pub unsafe fn get_font_size_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontSizeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_family_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontFamilyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_weight_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontWeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_style_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_stretch_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontStretchProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_foreground_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ForegroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_wrapping_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextWrappingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_trimming_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextTrimmingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_padding_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PaddingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_line_height_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LineHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_line_stacking_strategy_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LineStackingStrategyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_character_spacing_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CharacterSpacingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_overflow_content_target_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OverflowContentTargetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_text_selection_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsTextSelectionEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_has_overflow_content_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HasOverflowContentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_text_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedTextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_indent_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextIndentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichTextBlock2, 1059098643, 999, 17672, 150, 74, 145, 174, 218, 179, 209, 30);
RT_INTERFACE!{interface IRichTextBlock2(IRichTextBlock2Vtbl): IInspectable(IInspectableVtbl) [IID_IRichTextBlock2] {
    fn get_MaxLines(&self, out: *mut i32) -> HRESULT,
    fn put_MaxLines(&self, value: i32) -> HRESULT,
    fn get_TextLineBounds(&self, out: *mut super::TextLineBounds) -> HRESULT,
    fn put_TextLineBounds(&self, value: super::TextLineBounds) -> HRESULT,
    fn get_SelectionHighlightColor(&self, out: *mut *mut super::media::SolidColorBrush) -> HRESULT,
    fn put_SelectionHighlightColor(&self, value: *mut super::media::SolidColorBrush) -> HRESULT,
    fn get_OpticalMarginAlignment(&self, out: *mut super::OpticalMarginAlignment) -> HRESULT,
    fn put_OpticalMarginAlignment(&self, value: super::OpticalMarginAlignment) -> HRESULT,
    fn get_IsColorFontEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsColorFontEnabled(&self, value: bool) -> HRESULT,
    fn get_TextReadingOrder(&self, out: *mut super::TextReadingOrder) -> HRESULT,
    fn put_TextReadingOrder(&self, value: super::TextReadingOrder) -> HRESULT
}}
impl IRichTextBlock2 {
    #[inline] pub unsafe fn get_max_lines(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxLines)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_lines(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxLines)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_line_bounds(&self) -> Result<super::TextLineBounds> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextLineBounds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_line_bounds(&self, value: super::TextLineBounds) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextLineBounds)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_highlight_color(&self) -> Result<ComPtr<super::media::SolidColorBrush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionHighlightColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selection_highlight_color(&self, value: &super::media::SolidColorBrush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectionHighlightColor)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_optical_margin_alignment(&self) -> Result<super::OpticalMarginAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OpticalMarginAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_optical_margin_alignment(&self, value: super::OpticalMarginAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OpticalMarginAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_color_font_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsColorFontEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_color_font_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsColorFontEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_reading_order(&self) -> Result<super::TextReadingOrder> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextReadingOrder)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_reading_order(&self, value: super::TextReadingOrder) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextReadingOrder)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichTextBlockStatics2, 224473569, 44841, 18638, 138, 175, 116, 236, 194, 139, 251, 176);
RT_INTERFACE!{static interface IRichTextBlockStatics2(IRichTextBlockStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IRichTextBlockStatics2] {
    fn get_MaxLinesProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextLineBoundsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectionHighlightColorProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OpticalMarginAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsColorFontEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextReadingOrderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IRichTextBlockStatics2 {
    #[inline] pub unsafe fn get_max_lines_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxLinesProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_line_bounds_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextLineBoundsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_highlight_color_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionHighlightColorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_optical_margin_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OpticalMarginAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_color_font_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsColorFontEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_reading_order_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextReadingOrderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichTextBlock3, 2100932227, 35096, 17939, 176, 7, 124, 137, 139, 162, 149, 14);
RT_INTERFACE!{interface IRichTextBlock3(IRichTextBlock3Vtbl): IInspectable(IInspectableVtbl) [IID_IRichTextBlock3] {
    fn get_IsTextScaleFactorEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsTextScaleFactorEnabled(&self, value: bool) -> HRESULT
}}
impl IRichTextBlock3 {
    #[inline] pub unsafe fn get_is_text_scale_factor_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTextScaleFactorEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_text_scale_factor_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsTextScaleFactorEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichTextBlockStatics3, 121601780, 51755, 19273, 165, 154, 49, 216, 250, 116, 51, 50);
RT_INTERFACE!{static interface IRichTextBlockStatics3(IRichTextBlockStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IRichTextBlockStatics3] {
    fn get_IsTextScaleFactorEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IRichTextBlockStatics3 {
    #[inline] pub unsafe fn get_is_text_scale_factor_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsTextScaleFactorEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichTextBlock4, 897040874, 9469, 20304, 187, 228, 63, 182, 84, 234, 88, 197);
RT_INTERFACE!{interface IRichTextBlock4(IRichTextBlock4Vtbl): IInspectable(IInspectableVtbl) [IID_IRichTextBlock4] {
    #[cfg(feature="windows-ui")] fn get_TextDecorations(&self, out: *mut super::super::text::TextDecorations) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_TextDecorations(&self, value: super::super::text::TextDecorations) -> HRESULT
}}
impl IRichTextBlock4 {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_text_decorations(&self) -> Result<super::super::text::TextDecorations> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextDecorations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_text_decorations(&self, value: super::super::text::TextDecorations) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextDecorations)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichTextBlockStatics4, 2148883396, 28054, 19208, 173, 87, 19, 219, 15, 4, 100, 18);
RT_INTERFACE!{static interface IRichTextBlockStatics4(IRichTextBlockStatics4Vtbl): IInspectable(IInspectableVtbl) [IID_IRichTextBlockStatics4] {
    fn get_TextDecorationsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IRichTextBlockStatics4 {
    #[inline] pub unsafe fn get_text_decorations_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextDecorationsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichTextBlockOverflow, 1335063707, 56003, 19010, 156, 187, 153, 240, 222, 55, 192, 113);
RT_INTERFACE!{interface IRichTextBlockOverflow(IRichTextBlockOverflowVtbl): IInspectable(IInspectableVtbl) [IID_IRichTextBlockOverflow] {
    fn get_OverflowContentTarget(&self, out: *mut *mut RichTextBlockOverflow) -> HRESULT,
    fn put_OverflowContentTarget(&self, value: *mut RichTextBlockOverflow) -> HRESULT,
    fn get_Padding(&self, out: *mut super::Thickness) -> HRESULT,
    fn put_Padding(&self, value: super::Thickness) -> HRESULT,
    fn get_ContentSource(&self, out: *mut *mut RichTextBlock) -> HRESULT,
    fn get_HasOverflowContent(&self, out: *mut bool) -> HRESULT,
    fn get_ContentStart(&self, out: *mut *mut super::documents::TextPointer) -> HRESULT,
    fn get_ContentEnd(&self, out: *mut *mut super::documents::TextPointer) -> HRESULT,
    fn get_BaselineOffset(&self, out: *mut f64) -> HRESULT,
    fn GetPositionFromPoint(&self, point: ::rt::gen::windows::foundation::Point, out: *mut *mut super::documents::TextPointer) -> HRESULT,
    fn Focus(&self, value: super::FocusState, out: *mut bool) -> HRESULT
}}
impl IRichTextBlockOverflow {
    #[inline] pub unsafe fn get_overflow_content_target(&self) -> Result<ComPtr<RichTextBlockOverflow>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OverflowContentTarget)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_overflow_content_target(&self, value: &RichTextBlockOverflow) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OverflowContentTarget)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_padding(&self) -> Result<super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Padding)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_padding(&self, value: super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Padding)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_source(&self) -> Result<ComPtr<RichTextBlock>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_has_overflow_content(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HasOverflowContent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_start(&self) -> Result<ComPtr<super::documents::TextPointer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentStart)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_end(&self) -> Result<ComPtr<super::documents::TextPointer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentEnd)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_baseline_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BaselineOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_position_from_point(&self, point: ::rt::gen::windows::foundation::Point) -> Result<ComPtr<super::documents::TextPointer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetPositionFromPoint)(self as *const _ as *mut _, point, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn focus(&self, value: super::FocusState) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Focus)(self as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichTextBlockOverflowStatics, 68862711, 20267, 17347, 161, 34, 63, 234, 156, 169, 220, 135);
RT_INTERFACE!{static interface IRichTextBlockOverflowStatics(IRichTextBlockOverflowStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRichTextBlockOverflowStatics] {
    fn get_OverflowContentTargetProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PaddingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HasOverflowContentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IRichTextBlockOverflowStatics {
    #[inline] pub unsafe fn get_overflow_content_target_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OverflowContentTargetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_padding_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PaddingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_has_overflow_content_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HasOverflowContentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichTextBlockOverflow2, 2269274702, 43138, 18470, 185, 41, 77, 92, 57, 5, 185, 161);
RT_INTERFACE!{interface IRichTextBlockOverflow2(IRichTextBlockOverflow2Vtbl): IInspectable(IInspectableVtbl) [IID_IRichTextBlockOverflow2] {
    fn get_MaxLines(&self, out: *mut i32) -> HRESULT,
    fn put_MaxLines(&self, value: i32) -> HRESULT
}}
impl IRichTextBlockOverflow2 {
    #[inline] pub unsafe fn get_max_lines(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxLines)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_lines(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxLines)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichTextBlockOverflowStatics2, 3052137804, 63684, 19002, 144, 127, 229, 62, 120, 39, 159, 163);
RT_INTERFACE!{static interface IRichTextBlockOverflowStatics2(IRichTextBlockOverflowStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IRichTextBlockOverflowStatics2] {
    fn get_MaxLinesProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IRichTextBlockOverflowStatics2 {
    #[inline] pub unsafe fn get_max_lines_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxLinesProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextBlock, 2922222193, 15178, 17916, 132, 104, 247, 148, 149, 72, 244, 213);
RT_INTERFACE!{interface ITextBlock(ITextBlockVtbl): IInspectable(IInspectableVtbl) [IID_ITextBlock] {
    fn get_FontSize(&self, out: *mut f64) -> HRESULT,
    fn put_FontSize(&self, value: f64) -> HRESULT,
    fn get_FontFamily(&self, out: *mut *mut super::media::FontFamily) -> HRESULT,
    fn put_FontFamily(&self, value: *mut super::media::FontFamily) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FontWeight(&self, out: *mut super::super::text::FontWeight) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_FontWeight(&self, value: super::super::text::FontWeight) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FontStyle(&self, out: *mut super::super::text::FontStyle) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_FontStyle(&self, value: super::super::text::FontStyle) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FontStretch(&self, out: *mut super::super::text::FontStretch) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy9(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_FontStretch(&self, value: super::super::text::FontStretch) -> HRESULT,
    fn get_CharacterSpacing(&self, out: *mut i32) -> HRESULT,
    fn put_CharacterSpacing(&self, value: i32) -> HRESULT,
    fn get_Foreground(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_Foreground(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_TextWrapping(&self, out: *mut super::TextWrapping) -> HRESULT,
    fn put_TextWrapping(&self, value: super::TextWrapping) -> HRESULT,
    fn get_TextTrimming(&self, out: *mut super::TextTrimming) -> HRESULT,
    fn put_TextTrimming(&self, value: super::TextTrimming) -> HRESULT,
    fn get_TextAlignment(&self, out: *mut super::TextAlignment) -> HRESULT,
    fn put_TextAlignment(&self, value: super::TextAlignment) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Text(&self, value: HSTRING) -> HRESULT,
    fn get_Inlines(&self, out: *mut *mut super::documents::InlineCollection) -> HRESULT,
    fn get_Padding(&self, out: *mut super::Thickness) -> HRESULT,
    fn put_Padding(&self, value: super::Thickness) -> HRESULT,
    fn get_LineHeight(&self, out: *mut f64) -> HRESULT,
    fn put_LineHeight(&self, value: f64) -> HRESULT,
    fn get_LineStackingStrategy(&self, out: *mut super::LineStackingStrategy) -> HRESULT,
    fn put_LineStackingStrategy(&self, value: super::LineStackingStrategy) -> HRESULT,
    fn get_IsTextSelectionEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsTextSelectionEnabled(&self, value: bool) -> HRESULT,
    fn get_SelectedText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ContentStart(&self, out: *mut *mut super::documents::TextPointer) -> HRESULT,
    fn get_ContentEnd(&self, out: *mut *mut super::documents::TextPointer) -> HRESULT,
    fn get_SelectionStart(&self, out: *mut *mut super::documents::TextPointer) -> HRESULT,
    fn get_SelectionEnd(&self, out: *mut *mut super::documents::TextPointer) -> HRESULT,
    fn get_BaselineOffset(&self, out: *mut f64) -> HRESULT,
    fn add_SelectionChanged(&self, value: *mut super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SelectionChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ContextMenuOpening(&self, value: *mut ContextMenuOpeningEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ContextMenuOpening(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn SelectAll(&self) -> HRESULT,
    fn Select(&self, start: *mut super::documents::TextPointer, end: *mut super::documents::TextPointer) -> HRESULT,
    fn Focus(&self, value: super::FocusState, out: *mut bool) -> HRESULT
}}
impl ITextBlock {
    #[inline] pub unsafe fn get_font_size(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_font_size(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontSize)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_family(&self) -> Result<ComPtr<super::media::FontFamily>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontFamily)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_font_family(&self, value: &super::media::FontFamily) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontFamily)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_font_weight(&self) -> Result<super::super::text::FontWeight> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontWeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_font_weight(&self, value: super::super::text::FontWeight) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontWeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_font_style(&self) -> Result<super::super::text::FontStyle> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_font_style(&self, value: super::super::text::FontStyle) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontStyle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_font_stretch(&self) -> Result<super::super::text::FontStretch> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontStretch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_font_stretch(&self, value: super::super::text::FontStretch) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontStretch)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_character_spacing(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CharacterSpacing)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_character_spacing(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CharacterSpacing)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_foreground(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Foreground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_foreground(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Foreground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_wrapping(&self) -> Result<super::TextWrapping> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextWrapping)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_wrapping(&self, value: super::TextWrapping) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextWrapping)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_trimming(&self) -> Result<super::TextTrimming> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextTrimming)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_trimming(&self, value: super::TextTrimming) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextTrimming)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_alignment(&self) -> Result<super::TextAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_alignment(&self, value: super::TextAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Text)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Text)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_inlines(&self) -> Result<ComPtr<super::documents::InlineCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Inlines)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_padding(&self) -> Result<super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Padding)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_padding(&self, value: super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Padding)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_line_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LineHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_line_height(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LineHeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_line_stacking_strategy(&self) -> Result<super::LineStackingStrategy> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LineStackingStrategy)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_line_stacking_strategy(&self, value: super::LineStackingStrategy) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LineStackingStrategy)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_text_selection_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTextSelectionEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_text_selection_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsTextSelectionEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_start(&self) -> Result<ComPtr<super::documents::TextPointer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentStart)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_end(&self) -> Result<ComPtr<super::documents::TextPointer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentEnd)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_start(&self) -> Result<ComPtr<super::documents::TextPointer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionStart)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_end(&self) -> Result<ComPtr<super::documents::TextPointer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionEnd)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_baseline_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BaselineOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_selection_changed(&self, value: &super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SelectionChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_selection_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SelectionChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_context_menu_opening(&self, value: &ContextMenuOpeningEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ContextMenuOpening)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_context_menu_opening(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ContextMenuOpening)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn select_all(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).SelectAll)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn select(&self, start: &super::documents::TextPointer, end: &super::documents::TextPointer) -> Result<()> {
        let hr = ((*self.lpVtbl).Select)(self as *const _ as *mut _, start as *const _ as *mut _, end as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn focus(&self, value: super::FocusState) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Focus)(self as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextBlockStatics, 423542850, 43079, 17746, 180, 232, 219, 54, 101, 91, 132, 10);
RT_INTERFACE!{static interface ITextBlockStatics(ITextBlockStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ITextBlockStatics] {
    fn get_FontSizeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontFamilyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontWeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontStyleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontStretchProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CharacterSpacingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ForegroundProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextWrappingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextTrimmingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PaddingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_LineHeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_LineStackingStrategyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsTextSelectionEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectedTextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ITextBlockStatics {
    #[inline] pub unsafe fn get_font_size_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontSizeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_family_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontFamilyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_weight_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontWeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_style_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_stretch_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontStretchProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_character_spacing_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CharacterSpacingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_foreground_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ForegroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_wrapping_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextWrappingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_trimming_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextTrimmingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_padding_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PaddingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_line_height_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LineHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_line_stacking_strategy_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LineStackingStrategyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_text_selection_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsTextSelectionEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_text_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedTextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextBlock2, 1159752268, 2638, 20415, 174, 233, 51, 93, 90, 32, 95, 110);
RT_INTERFACE!{interface ITextBlock2(ITextBlock2Vtbl): IInspectable(IInspectableVtbl) [IID_ITextBlock2] {
    fn get_SelectionHighlightColor(&self, out: *mut *mut super::media::SolidColorBrush) -> HRESULT,
    fn put_SelectionHighlightColor(&self, value: *mut super::media::SolidColorBrush) -> HRESULT,
    fn get_MaxLines(&self, out: *mut i32) -> HRESULT,
    fn put_MaxLines(&self, value: i32) -> HRESULT,
    fn get_TextLineBounds(&self, out: *mut super::TextLineBounds) -> HRESULT,
    fn put_TextLineBounds(&self, value: super::TextLineBounds) -> HRESULT,
    fn get_OpticalMarginAlignment(&self, out: *mut super::OpticalMarginAlignment) -> HRESULT,
    fn put_OpticalMarginAlignment(&self, value: super::OpticalMarginAlignment) -> HRESULT,
    fn get_IsColorFontEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsColorFontEnabled(&self, value: bool) -> HRESULT,
    fn get_TextReadingOrder(&self, out: *mut super::TextReadingOrder) -> HRESULT,
    fn put_TextReadingOrder(&self, value: super::TextReadingOrder) -> HRESULT
}}
impl ITextBlock2 {
    #[inline] pub unsafe fn get_selection_highlight_color(&self) -> Result<ComPtr<super::media::SolidColorBrush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionHighlightColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selection_highlight_color(&self, value: &super::media::SolidColorBrush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectionHighlightColor)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_lines(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxLines)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_lines(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxLines)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_line_bounds(&self) -> Result<super::TextLineBounds> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextLineBounds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_line_bounds(&self, value: super::TextLineBounds) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextLineBounds)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_optical_margin_alignment(&self) -> Result<super::OpticalMarginAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OpticalMarginAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_optical_margin_alignment(&self, value: super::OpticalMarginAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OpticalMarginAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_color_font_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsColorFontEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_color_font_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsColorFontEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_reading_order(&self) -> Result<super::TextReadingOrder> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextReadingOrder)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_reading_order(&self, value: super::TextReadingOrder) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextReadingOrder)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextBlockStatics2, 2282752795, 65316, 19347, 160, 230, 240, 41, 201, 72, 113, 241);
RT_INTERFACE!{static interface ITextBlockStatics2(ITextBlockStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_ITextBlockStatics2] {
    fn get_SelectionHighlightColorProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MaxLinesProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextLineBoundsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OpticalMarginAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsColorFontEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextReadingOrderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ITextBlockStatics2 {
    #[inline] pub unsafe fn get_selection_highlight_color_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionHighlightColorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_lines_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxLinesProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_line_bounds_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextLineBoundsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_optical_margin_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OpticalMarginAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_color_font_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsColorFontEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_reading_order_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextReadingOrderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextBlock3, 3058818394, 16971, 18627, 155, 103, 72, 111, 78, 19, 152, 153);
RT_INTERFACE!{interface ITextBlock3(ITextBlock3Vtbl): IInspectable(IInspectableVtbl) [IID_ITextBlock3] {
    fn get_IsTextScaleFactorEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsTextScaleFactorEnabled(&self, value: bool) -> HRESULT
}}
impl ITextBlock3 {
    #[inline] pub unsafe fn get_is_text_scale_factor_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTextScaleFactorEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_text_scale_factor_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsTextScaleFactorEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextBlockStatics3, 2367076843, 8353, 20139, 187, 242, 29, 107, 220, 188, 215, 5);
RT_INTERFACE!{static interface ITextBlockStatics3(ITextBlockStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_ITextBlockStatics3] {
    fn get_IsTextScaleFactorEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ITextBlockStatics3 {
    #[inline] pub unsafe fn get_is_text_scale_factor_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsTextScaleFactorEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextBlock4, 2954162800, 38920, 19164, 180, 82, 96, 205, 165, 65, 0, 193);
RT_INTERFACE!{interface ITextBlock4(ITextBlock4Vtbl): IInspectable(IInspectableVtbl) [IID_ITextBlock4] {
    #[cfg(feature="windows-ui")] fn GetAlphaMask(&self, out: *mut *mut super::super::composition::CompositionBrush) -> HRESULT
}}
impl ITextBlock4 {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_alpha_mask(&self) -> Result<ComPtr<super::super::composition::CompositionBrush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAlphaMask)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextBlock5, 1649028408, 60861, 19034, 182, 120, 228, 159, 30, 7, 175, 189);
RT_INTERFACE!{interface ITextBlock5(ITextBlock5Vtbl): IInspectable(IInspectableVtbl) [IID_ITextBlock5] {
    #[cfg(feature="windows-ui")] fn get_TextDecorations(&self, out: *mut super::super::text::TextDecorations) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_TextDecorations(&self, value: super::super::text::TextDecorations) -> HRESULT
}}
impl ITextBlock5 {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_text_decorations(&self) -> Result<super::super::text::TextDecorations> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextDecorations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_text_decorations(&self, value: super::super::text::TextDecorations) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextDecorations)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextBlockStatics5, 2387450992, 3406, 18655, 174, 127, 187, 122, 154, 246, 133, 46);
RT_INTERFACE!{static interface ITextBlockStatics5(ITextBlockStatics5Vtbl): IInspectable(IInspectableVtbl) [IID_ITextBlockStatics5] {
    fn get_TextDecorationsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ITextBlockStatics5 {
    #[inline] pub unsafe fn get_text_decorations_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextDecorationsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IViewbox, 86322264, 47773, 18441, 158, 195, 250, 13, 22, 113, 11, 161);
RT_INTERFACE!{interface IViewbox(IViewboxVtbl): IInspectable(IInspectableVtbl) [IID_IViewbox] {
    fn get_Child(&self, out: *mut *mut super::UIElement) -> HRESULT,
    fn put_Child(&self, value: *mut super::UIElement) -> HRESULT,
    fn get_Stretch(&self, out: *mut super::media::Stretch) -> HRESULT,
    fn put_Stretch(&self, value: super::media::Stretch) -> HRESULT,
    fn get_StretchDirection(&self, out: *mut StretchDirection) -> HRESULT,
    fn put_StretchDirection(&self, value: StretchDirection) -> HRESULT
}}
impl IViewbox {
    #[inline] pub unsafe fn get_child(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Child)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_child(&self, value: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Child)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stretch(&self) -> Result<super::media::Stretch> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Stretch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stretch(&self, value: super::media::Stretch) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Stretch)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stretch_direction(&self) -> Result<StretchDirection> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StretchDirection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stretch_direction(&self, value: StretchDirection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StretchDirection)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IViewboxStatics, 1557260077, 59603, 18533, 143, 8, 182, 178, 214, 137, 173, 241);
RT_INTERFACE!{static interface IViewboxStatics(IViewboxStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IViewboxStatics] {
    fn get_StretchProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_StretchDirectionProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IViewboxStatics {
    #[inline] pub unsafe fn get_stretch_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StretchProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stretch_direction_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StretchDirectionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICanvas, 2031685145, 52536, 18467, 174, 174, 100, 167, 113, 50, 245, 25);
RT_INTERFACE!{interface ICanvas(ICanvasVtbl): IInspectable(IInspectableVtbl) [IID_ICanvas] {
    
}}
DEFINE_IID!(IID_ICanvasStatics, 1087265862, 10594, 17519, 170, 251, 76, 220, 72, 105, 57, 201);
RT_INTERFACE!{static interface ICanvasStatics(ICanvasStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICanvasStatics] {
    fn get_LeftProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetLeft(&self, element: *mut super::UIElement, out: *mut f64) -> HRESULT,
    fn SetLeft(&self, element: *mut super::UIElement, length: f64) -> HRESULT,
    fn get_TopProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetTop(&self, element: *mut super::UIElement, out: *mut f64) -> HRESULT,
    fn SetTop(&self, element: *mut super::UIElement, length: f64) -> HRESULT,
    fn get_ZIndexProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetZIndex(&self, element: *mut super::UIElement, out: *mut i32) -> HRESULT,
    fn SetZIndex(&self, element: *mut super::UIElement, value: i32) -> HRESULT
}}
impl ICanvasStatics {
    #[inline] pub unsafe fn get_left_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LeftProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_left(&self, element: &super::UIElement) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetLeft)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_left(&self, element: &super::UIElement, length: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).SetLeft)(self as *const _ as *mut _, element as *const _ as *mut _, length);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_top_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TopProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_top(&self, element: &super::UIElement) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetTop)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_top(&self, element: &super::UIElement, length: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).SetTop)(self as *const _ as *mut _, element as *const _ as *mut _, length);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zindex_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ZIndexProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zindex(&self, element: &super::UIElement) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetZIndex)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_zindex(&self, element: &super::UIElement, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetZIndex)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICanvasFactory, 456297425, 46080, 19086, 148, 59, 90, 210, 196, 91, 224, 223);
RT_INTERFACE!{interface ICanvasFactory(ICanvasFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICanvasFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut Canvas) -> HRESULT
}}
impl ICanvasFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<Canvas>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContentControl, 2725106140, 52548, 17244, 190, 148, 1, 214, 36, 28, 35, 28);
RT_INTERFACE!{interface IContentControl(IContentControlVtbl): IInspectable(IInspectableVtbl) [IID_IContentControl] {
    fn get_Content(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Content(&self, value: *mut IInspectable) -> HRESULT,
    fn get_ContentTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_ContentTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_ContentTemplateSelector(&self, out: *mut *mut DataTemplateSelector) -> HRESULT,
    fn put_ContentTemplateSelector(&self, value: *mut DataTemplateSelector) -> HRESULT,
    fn get_ContentTransitions(&self, out: *mut *mut super::media::animation::TransitionCollection) -> HRESULT,
    fn put_ContentTransitions(&self, value: *mut super::media::animation::TransitionCollection) -> HRESULT
}}
impl IContentControl {
    #[inline] pub unsafe fn get_content(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Content)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Content)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_template_selector(&self) -> Result<ComPtr<DataTemplateSelector>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTemplateSelector)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_template_selector(&self, value: &DataTemplateSelector) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentTemplateSelector)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_transitions(&self) -> Result<ComPtr<super::media::animation::TransitionCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTransitions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_transitions(&self, value: &super::media::animation::TransitionCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentTransitions)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContentControlOverrides, 1598819088, 58254, 19293, 190, 26, 94, 208, 66, 70, 166, 53);
RT_INTERFACE!{interface IContentControlOverrides(IContentControlOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IContentControlOverrides] {
    fn OnContentChanged(&self, oldContent: *mut IInspectable, newContent: *mut IInspectable) -> HRESULT,
    fn OnContentTemplateChanged(&self, oldContentTemplate: *mut super::DataTemplate, newContentTemplate: *mut super::DataTemplate) -> HRESULT,
    fn OnContentTemplateSelectorChanged(&self, oldContentTemplateSelector: *mut DataTemplateSelector, newContentTemplateSelector: *mut DataTemplateSelector) -> HRESULT
}}
impl IContentControlOverrides {
    #[inline] pub unsafe fn on_content_changed(&self, oldContent: &IInspectable, newContent: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).OnContentChanged)(self as *const _ as *mut _, oldContent as *const _ as *mut _, newContent as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_content_template_changed(&self, oldContentTemplate: &super::DataTemplate, newContentTemplate: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).OnContentTemplateChanged)(self as *const _ as *mut _, oldContentTemplate as *const _ as *mut _, newContentTemplate as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_content_template_selector_changed(&self, oldContentTemplateSelector: &DataTemplateSelector, newContentTemplateSelector: &DataTemplateSelector) -> Result<()> {
        let hr = ((*self.lpVtbl).OnContentTemplateSelectorChanged)(self as *const _ as *mut _, oldContentTemplateSelector as *const _ as *mut _, newContentTemplateSelector as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContentControlStatics, 292127396, 23797, 19461, 165, 63, 21, 228, 135, 108, 133, 236);
RT_INTERFACE!{static interface IContentControlStatics(IContentControlStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IContentControlStatics] {
    fn get_ContentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ContentTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ContentTemplateSelectorProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ContentTransitionsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IContentControlStatics {
    #[inline] pub unsafe fn get_content_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_template_selector_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTemplateSelectorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_transitions_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTransitionsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContentControlFactory, 2869000985, 6510, 20181, 162, 127, 85, 197, 143, 177, 103, 63);
RT_INTERFACE!{interface IContentControlFactory(IContentControlFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IContentControlFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ContentControl) -> HRESULT
}}
impl IContentControlFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ContentControl>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContentControl2, 1697390732, 36047, 17305, 189, 62, 90, 1, 90, 161, 188, 3);
RT_INTERFACE!{interface IContentControl2(IContentControl2Vtbl): IInspectable(IInspectableVtbl) [IID_IContentControl2] {
    fn get_ContentTemplateRoot(&self, out: *mut *mut super::UIElement) -> HRESULT
}}
impl IContentControl2 {
    #[inline] pub unsafe fn get_content_template_root(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTemplateRoot)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGrid, 4245701728, 11797, 19363, 139, 143, 250, 105, 58, 65, 97, 233);
RT_INTERFACE!{interface IGrid(IGridVtbl): IInspectable(IInspectableVtbl) [IID_IGrid] {
    fn get_RowDefinitions(&self, out: *mut *mut RowDefinitionCollection) -> HRESULT,
    fn get_ColumnDefinitions(&self, out: *mut *mut ColumnDefinitionCollection) -> HRESULT
}}
impl IGrid {
    #[inline] pub unsafe fn get_row_definitions(&self) -> Result<ComPtr<RowDefinitionCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RowDefinitions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_column_definitions(&self) -> Result<ComPtr<ColumnDefinitionCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ColumnDefinitions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGridStatics, 1694379679, 63825, 17078, 169, 206, 187, 23, 154, 241, 21, 149);
RT_INTERFACE!{static interface IGridStatics(IGridStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGridStatics] {
    fn get_RowProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetRow(&self, element: *mut super::FrameworkElement, out: *mut i32) -> HRESULT,
    fn SetRow(&self, element: *mut super::FrameworkElement, value: i32) -> HRESULT,
    fn get_ColumnProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetColumn(&self, element: *mut super::FrameworkElement, out: *mut i32) -> HRESULT,
    fn SetColumn(&self, element: *mut super::FrameworkElement, value: i32) -> HRESULT,
    fn get_RowSpanProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetRowSpan(&self, element: *mut super::FrameworkElement, out: *mut i32) -> HRESULT,
    fn SetRowSpan(&self, element: *mut super::FrameworkElement, value: i32) -> HRESULT,
    fn get_ColumnSpanProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetColumnSpan(&self, element: *mut super::FrameworkElement, out: *mut i32) -> HRESULT,
    fn SetColumnSpan(&self, element: *mut super::FrameworkElement, value: i32) -> HRESULT
}}
impl IGridStatics {
    #[inline] pub unsafe fn get_row_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RowProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_row(&self, element: &super::FrameworkElement) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetRow)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_row(&self, element: &super::FrameworkElement, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetRow)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_column_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ColumnProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_column(&self, element: &super::FrameworkElement) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetColumn)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_column(&self, element: &super::FrameworkElement, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetColumn)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_row_span_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RowSpanProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_row_span(&self, element: &super::FrameworkElement) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetRowSpan)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_row_span(&self, element: &super::FrameworkElement, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetRowSpan)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_column_span_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ColumnSpanProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_column_span(&self, element: &super::FrameworkElement) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetColumnSpan)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_column_span(&self, element: &super::FrameworkElement, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetColumnSpan)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGridFactory, 2927706177, 50481, 17332, 191, 153, 18, 245, 6, 247, 176, 28);
RT_INTERFACE!{interface IGridFactory(IGridFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGridFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut Grid) -> HRESULT
}}
impl IGridFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<Grid>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGrid2, 4151245377, 14350, 17883, 190, 135, 158, 19, 38, 186, 75, 87);
RT_INTERFACE!{interface IGrid2(IGrid2Vtbl): IInspectable(IInspectableVtbl) [IID_IGrid2] {
    fn get_BorderBrush(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_BorderBrush(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_BorderThickness(&self, out: *mut super::Thickness) -> HRESULT,
    fn put_BorderThickness(&self, value: super::Thickness) -> HRESULT,
    fn get_CornerRadius(&self, out: *mut super::CornerRadius) -> HRESULT,
    fn put_CornerRadius(&self, value: super::CornerRadius) -> HRESULT,
    fn get_Padding(&self, out: *mut super::Thickness) -> HRESULT,
    fn put_Padding(&self, value: super::Thickness) -> HRESULT
}}
impl IGrid2 {
    #[inline] pub unsafe fn get_border_brush(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BorderBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_border_brush(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BorderBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_border_thickness(&self) -> Result<super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BorderThickness)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_border_thickness(&self, value: super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BorderThickness)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_corner_radius(&self) -> Result<super::CornerRadius> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CornerRadius)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_corner_radius(&self, value: super::CornerRadius) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CornerRadius)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_padding(&self) -> Result<super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Padding)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_padding(&self, value: super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Padding)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGridStatics2, 761685592, 22710, 18971, 132, 27, 135, 91, 169, 59, 93, 106);
RT_INTERFACE!{static interface IGridStatics2(IGridStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IGridStatics2] {
    fn get_BorderBrushProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_BorderThicknessProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CornerRadiusProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PaddingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IGridStatics2 {
    #[inline] pub unsafe fn get_border_brush_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BorderBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_border_thickness_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BorderThicknessProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_corner_radius_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CornerRadiusProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_padding_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PaddingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemsControl, 4104723928, 55673, 17281, 134, 82, 189, 160, 52, 42, 118, 94);
RT_INTERFACE!{interface IItemsControl(IItemsControlVtbl): IInspectable(IInspectableVtbl) [IID_IItemsControl] {
    fn get_ItemsSource(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_ItemsSource(&self, value: *mut IInspectable) -> HRESULT,
    fn get_Items(&self, out: *mut *mut ItemCollection) -> HRESULT,
    fn get_ItemTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_ItemTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_ItemTemplateSelector(&self, out: *mut *mut DataTemplateSelector) -> HRESULT,
    fn put_ItemTemplateSelector(&self, value: *mut DataTemplateSelector) -> HRESULT,
    fn get_ItemsPanel(&self, out: *mut *mut ItemsPanelTemplate) -> HRESULT,
    fn put_ItemsPanel(&self, value: *mut ItemsPanelTemplate) -> HRESULT,
    fn get_DisplayMemberPath(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayMemberPath(&self, value: HSTRING) -> HRESULT,
    fn get_ItemContainerStyle(&self, out: *mut *mut super::Style) -> HRESULT,
    fn put_ItemContainerStyle(&self, value: *mut super::Style) -> HRESULT,
    fn get_ItemContainerStyleSelector(&self, out: *mut *mut StyleSelector) -> HRESULT,
    fn put_ItemContainerStyleSelector(&self, value: *mut StyleSelector) -> HRESULT,
    fn get_ItemContainerGenerator(&self, out: *mut *mut ItemContainerGenerator) -> HRESULT,
    fn get_ItemContainerTransitions(&self, out: *mut *mut super::media::animation::TransitionCollection) -> HRESULT,
    fn put_ItemContainerTransitions(&self, value: *mut super::media::animation::TransitionCollection) -> HRESULT,
    fn get_GroupStyle(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IObservableVector<GroupStyle>) -> HRESULT,
    fn get_GroupStyleSelector(&self, out: *mut *mut GroupStyleSelector) -> HRESULT,
    fn put_GroupStyleSelector(&self, value: *mut GroupStyleSelector) -> HRESULT,
    fn get_IsGrouping(&self, out: *mut bool) -> HRESULT
}}
impl IItemsControl {
    #[inline] pub unsafe fn get_items_source(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemsSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_items_source(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemsSource)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_items(&self) -> Result<ComPtr<ItemCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Items)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_item_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_template_selector(&self) -> Result<ComPtr<DataTemplateSelector>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemTemplateSelector)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_item_template_selector(&self, value: &DataTemplateSelector) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemTemplateSelector)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_items_panel(&self) -> Result<ComPtr<ItemsPanelTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemsPanel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_items_panel(&self, value: &ItemsPanelTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemsPanel)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_member_path(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayMemberPath)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_member_path(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayMemberPath)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_container_style(&self) -> Result<ComPtr<super::Style>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemContainerStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_item_container_style(&self, value: &super::Style) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemContainerStyle)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_container_style_selector(&self) -> Result<ComPtr<StyleSelector>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemContainerStyleSelector)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_item_container_style_selector(&self, value: &StyleSelector) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemContainerStyleSelector)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_container_generator(&self) -> Result<ComPtr<ItemContainerGenerator>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemContainerGenerator)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_container_transitions(&self) -> Result<ComPtr<super::media::animation::TransitionCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemContainerTransitions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_item_container_transitions(&self, value: &super::media::animation::TransitionCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemContainerTransitions)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_group_style(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IObservableVector<GroupStyle>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GroupStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_group_style_selector(&self) -> Result<ComPtr<GroupStyleSelector>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GroupStyleSelector)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_group_style_selector(&self, value: &GroupStyleSelector) -> Result<()> {
        let hr = ((*self.lpVtbl).put_GroupStyleSelector)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_grouping(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsGrouping)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemsControlOverrides, 3348870171, 41092, 17153, 164, 150, 114, 151, 31, 54, 78, 209);
RT_INTERFACE!{interface IItemsControlOverrides(IItemsControlOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IItemsControlOverrides] {
    fn IsItemItsOwnContainerOverride(&self, item: *mut IInspectable, out: *mut bool) -> HRESULT,
    fn GetContainerForItemOverride(&self, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn ClearContainerForItemOverride(&self, element: *mut super::DependencyObject, item: *mut IInspectable) -> HRESULT,
    fn PrepareContainerForItemOverride(&self, element: *mut super::DependencyObject, item: *mut IInspectable) -> HRESULT,
    fn OnItemsChanged(&self, e: *mut IInspectable) -> HRESULT,
    fn OnItemContainerStyleChanged(&self, oldItemContainerStyle: *mut super::Style, newItemContainerStyle: *mut super::Style) -> HRESULT,
    fn OnItemContainerStyleSelectorChanged(&self, oldItemContainerStyleSelector: *mut StyleSelector, newItemContainerStyleSelector: *mut StyleSelector) -> HRESULT,
    fn OnItemTemplateChanged(&self, oldItemTemplate: *mut super::DataTemplate, newItemTemplate: *mut super::DataTemplate) -> HRESULT,
    fn OnItemTemplateSelectorChanged(&self, oldItemTemplateSelector: *mut DataTemplateSelector, newItemTemplateSelector: *mut DataTemplateSelector) -> HRESULT,
    fn OnGroupStyleSelectorChanged(&self, oldGroupStyleSelector: *mut GroupStyleSelector, newGroupStyleSelector: *mut GroupStyleSelector) -> HRESULT
}}
impl IItemsControlOverrides {
    #[inline] pub unsafe fn is_item_its_own_container_override(&self, item: &IInspectable) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsItemItsOwnContainerOverride)(self as *const _ as *mut _, item as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_container_for_item_override(&self) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetContainerForItemOverride)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn clear_container_for_item_override(&self, element: &super::DependencyObject, item: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).ClearContainerForItemOverride)(self as *const _ as *mut _, element as *const _ as *mut _, item as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn prepare_container_for_item_override(&self, element: &super::DependencyObject, item: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).PrepareContainerForItemOverride)(self as *const _ as *mut _, element as *const _ as *mut _, item as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_items_changed(&self, e: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).OnItemsChanged)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_item_container_style_changed(&self, oldItemContainerStyle: &super::Style, newItemContainerStyle: &super::Style) -> Result<()> {
        let hr = ((*self.lpVtbl).OnItemContainerStyleChanged)(self as *const _ as *mut _, oldItemContainerStyle as *const _ as *mut _, newItemContainerStyle as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_item_container_style_selector_changed(&self, oldItemContainerStyleSelector: &StyleSelector, newItemContainerStyleSelector: &StyleSelector) -> Result<()> {
        let hr = ((*self.lpVtbl).OnItemContainerStyleSelectorChanged)(self as *const _ as *mut _, oldItemContainerStyleSelector as *const _ as *mut _, newItemContainerStyleSelector as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_item_template_changed(&self, oldItemTemplate: &super::DataTemplate, newItemTemplate: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).OnItemTemplateChanged)(self as *const _ as *mut _, oldItemTemplate as *const _ as *mut _, newItemTemplate as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_item_template_selector_changed(&self, oldItemTemplateSelector: &DataTemplateSelector, newItemTemplateSelector: &DataTemplateSelector) -> Result<()> {
        let hr = ((*self.lpVtbl).OnItemTemplateSelectorChanged)(self as *const _ as *mut _, oldItemTemplateSelector as *const _ as *mut _, newItemTemplateSelector as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_group_style_selector_changed(&self, oldGroupStyleSelector: &GroupStyleSelector, newGroupStyleSelector: &GroupStyleSelector) -> Result<()> {
        let hr = ((*self.lpVtbl).OnGroupStyleSelectorChanged)(self as *const _ as *mut _, oldGroupStyleSelector as *const _ as *mut _, newGroupStyleSelector as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemsControlStatics, 937082249, 56571, 17848, 154, 254, 135, 77, 240, 151, 144, 94);
RT_INTERFACE!{static interface IItemsControlStatics(IItemsControlStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IItemsControlStatics] {
    fn get_ItemsSourceProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ItemTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ItemTemplateSelectorProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ItemsPanelProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DisplayMemberPathProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ItemContainerStyleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ItemContainerStyleSelectorProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ItemContainerTransitionsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_GroupStyleSelectorProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsGroupingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetItemsOwner(&self, element: *mut super::DependencyObject, out: *mut *mut ItemsControl) -> HRESULT,
    fn ItemsControlFromItemContainer(&self, container: *mut super::DependencyObject, out: *mut *mut ItemsControl) -> HRESULT
}}
impl IItemsControlStatics {
    #[inline] pub unsafe fn get_items_source_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemsSourceProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_template_selector_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemTemplateSelectorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_items_panel_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemsPanelProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_member_path_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayMemberPathProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_container_style_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemContainerStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_container_style_selector_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemContainerStyleSelectorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_container_transitions_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemContainerTransitionsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_group_style_selector_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GroupStyleSelectorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_grouping_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsGroupingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_items_owner(&self, element: &super::DependencyObject) -> Result<ComPtr<ItemsControl>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetItemsOwner)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn items_control_from_item_container(&self, container: &super::DependencyObject) -> Result<ComPtr<ItemsControl>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ItemsControlFromItemContainer)(self as *const _ as *mut _, container as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemsControlFactory, 4156277593, 63741, 18204, 188, 178, 44, 116, 190, 142, 191, 140);
RT_INTERFACE!{interface IItemsControlFactory(IItemsControlFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IItemsControlFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ItemsControl) -> HRESULT
}}
impl IItemsControlFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ItemsControl>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemsControl2, 1967927910, 1321, 17891, 135, 72, 191, 116, 125, 21, 131, 87);
RT_INTERFACE!{interface IItemsControl2(IItemsControl2Vtbl): IInspectable(IInspectableVtbl) [IID_IItemsControl2] {
    fn get_ItemsPanelRoot(&self, out: *mut *mut Panel) -> HRESULT
}}
impl IItemsControl2 {
    #[inline] pub unsafe fn get_items_panel_root(&self) -> Result<ComPtr<Panel>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemsPanelRoot)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemsControl3, 1345025161, 44772, 19939, 162, 171, 25, 90, 194, 12, 66, 18);
RT_INTERFACE!{interface IItemsControl3(IItemsControl3Vtbl): IInspectable(IInspectableVtbl) [IID_IItemsControl3] {
    fn GroupHeaderContainerFromItemContainer(&self, itemContainer: *mut super::DependencyObject, out: *mut *mut super::DependencyObject) -> HRESULT
}}
impl IItemsControl3 {
    #[inline] pub unsafe fn group_header_container_from_item_container(&self, itemContainer: &super::DependencyObject) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GroupHeaderContainerFromItemContainer)(self as *const _ as *mut _, itemContainer as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMediaTransportControls, 3606486653, 2085, 18857, 159, 206, 85, 134, 216, 105, 79, 12);
RT_INTERFACE!{interface IMediaTransportControls(IMediaTransportControlsVtbl): IInspectable(IInspectableVtbl) [IID_IMediaTransportControls] {
    fn get_IsFullWindowButtonVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsFullWindowButtonVisible(&self, value: bool) -> HRESULT,
    fn get_IsFullWindowEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsFullWindowEnabled(&self, value: bool) -> HRESULT,
    fn get_IsZoomButtonVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsZoomButtonVisible(&self, value: bool) -> HRESULT,
    fn get_IsZoomEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsZoomEnabled(&self, value: bool) -> HRESULT,
    fn get_IsFastForwardButtonVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsFastForwardButtonVisible(&self, value: bool) -> HRESULT,
    fn get_IsFastForwardEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsFastForwardEnabled(&self, value: bool) -> HRESULT,
    fn get_IsFastRewindButtonVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsFastRewindButtonVisible(&self, value: bool) -> HRESULT,
    fn get_IsFastRewindEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsFastRewindEnabled(&self, value: bool) -> HRESULT,
    fn get_IsStopButtonVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsStopButtonVisible(&self, value: bool) -> HRESULT,
    fn get_IsStopEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsStopEnabled(&self, value: bool) -> HRESULT,
    fn get_IsVolumeButtonVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsVolumeButtonVisible(&self, value: bool) -> HRESULT,
    fn get_IsVolumeEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsVolumeEnabled(&self, value: bool) -> HRESULT,
    fn get_IsPlaybackRateButtonVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsPlaybackRateButtonVisible(&self, value: bool) -> HRESULT,
    fn get_IsPlaybackRateEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsPlaybackRateEnabled(&self, value: bool) -> HRESULT,
    fn get_IsSeekBarVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsSeekBarVisible(&self, value: bool) -> HRESULT,
    fn get_IsSeekEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsSeekEnabled(&self, value: bool) -> HRESULT,
    fn get_IsCompact(&self, out: *mut bool) -> HRESULT,
    fn put_IsCompact(&self, value: bool) -> HRESULT
}}
impl IMediaTransportControls {
    #[inline] pub unsafe fn get_is_full_window_button_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsFullWindowButtonVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_full_window_button_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsFullWindowButtonVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_full_window_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsFullWindowEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_full_window_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsFullWindowEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_zoom_button_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsZoomButtonVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_zoom_button_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsZoomButtonVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_zoom_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsZoomEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_zoom_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsZoomEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_fast_forward_button_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsFastForwardButtonVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_fast_forward_button_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsFastForwardButtonVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_fast_forward_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsFastForwardEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_fast_forward_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsFastForwardEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_fast_rewind_button_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsFastRewindButtonVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_fast_rewind_button_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsFastRewindButtonVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_fast_rewind_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsFastRewindEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_fast_rewind_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsFastRewindEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_stop_button_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsStopButtonVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_stop_button_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsStopButtonVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_stop_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsStopEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_stop_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsStopEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_volume_button_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsVolumeButtonVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_volume_button_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsVolumeButtonVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_volume_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsVolumeEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_volume_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsVolumeEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_playback_rate_button_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsPlaybackRateButtonVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_playback_rate_button_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsPlaybackRateButtonVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_playback_rate_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsPlaybackRateEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_playback_rate_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsPlaybackRateEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_seek_bar_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSeekBarVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_seek_bar_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSeekBarVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_seek_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSeekEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_seek_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSeekEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_compact(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCompact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_compact(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsCompact)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMediaTransportControlsStatics, 1494132999, 53999, 19482, 148, 41, 180, 177, 93, 100, 253, 86);
RT_INTERFACE!{static interface IMediaTransportControlsStatics(IMediaTransportControlsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMediaTransportControlsStatics] {
    fn get_IsFullWindowButtonVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsFullWindowEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsZoomButtonVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsZoomEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsFastForwardButtonVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsFastForwardEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsFastRewindButtonVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsFastRewindEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsStopButtonVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsStopEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsVolumeButtonVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsVolumeEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsPlaybackRateButtonVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsPlaybackRateEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsSeekBarVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsSeekEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsCompactProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IMediaTransportControlsStatics {
    #[inline] pub unsafe fn get_is_full_window_button_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsFullWindowButtonVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_full_window_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsFullWindowEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_zoom_button_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsZoomButtonVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_zoom_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsZoomEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_fast_forward_button_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsFastForwardButtonVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_fast_forward_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsFastForwardEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_fast_rewind_button_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsFastRewindButtonVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_fast_rewind_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsFastRewindEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_stop_button_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsStopButtonVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_stop_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsStopEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_volume_button_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsVolumeButtonVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_volume_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsVolumeEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_playback_rate_button_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsPlaybackRateButtonVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_playback_rate_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsPlaybackRateEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_seek_bar_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsSeekBarVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_seek_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsSeekEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_compact_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsCompactProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMediaTransportControlsFactory, 497156442, 43236, 19483, 136, 201, 11, 24, 62, 204, 98, 227);
RT_INTERFACE!{interface IMediaTransportControlsFactory(IMediaTransportControlsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMediaTransportControlsFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut MediaTransportControls) -> HRESULT
}}
impl IMediaTransportControlsFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<MediaTransportControls>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMediaTransportControls2, 730460140, 7146, 17694, 139, 205, 207, 226, 217, 66, 50, 98);
RT_INTERFACE!{interface IMediaTransportControls2(IMediaTransportControls2Vtbl): IInspectable(IInspectableVtbl) [IID_IMediaTransportControls2] {
    fn get_IsSkipForwardButtonVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsSkipForwardButtonVisible(&self, value: bool) -> HRESULT,
    fn get_IsSkipForwardEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsSkipForwardEnabled(&self, value: bool) -> HRESULT,
    fn get_IsSkipBackwardButtonVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsSkipBackwardButtonVisible(&self, value: bool) -> HRESULT,
    fn get_IsSkipBackwardEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsSkipBackwardEnabled(&self, value: bool) -> HRESULT,
    fn get_IsNextTrackButtonVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsNextTrackButtonVisible(&self, value: bool) -> HRESULT,
    fn get_IsPreviousTrackButtonVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsPreviousTrackButtonVisible(&self, value: bool) -> HRESULT,
    fn get_FastPlayFallbackBehaviour(&self, out: *mut super::media::FastPlayFallbackBehaviour) -> HRESULT,
    fn put_FastPlayFallbackBehaviour(&self, value: super::media::FastPlayFallbackBehaviour) -> HRESULT,
    fn add_ThumbnailRequested(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MediaTransportControls, super::media::MediaTransportControlsThumbnailRequestedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ThumbnailRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IMediaTransportControls2 {
    #[inline] pub unsafe fn get_is_skip_forward_button_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSkipForwardButtonVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_skip_forward_button_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSkipForwardButtonVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_skip_forward_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSkipForwardEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_skip_forward_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSkipForwardEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_skip_backward_button_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSkipBackwardButtonVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_skip_backward_button_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSkipBackwardButtonVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_skip_backward_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSkipBackwardEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_skip_backward_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSkipBackwardEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_next_track_button_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsNextTrackButtonVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_next_track_button_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsNextTrackButtonVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_previous_track_button_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsPreviousTrackButtonVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_previous_track_button_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsPreviousTrackButtonVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_fast_play_fallback_behaviour(&self) -> Result<super::media::FastPlayFallbackBehaviour> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FastPlayFallbackBehaviour)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_fast_play_fallback_behaviour(&self, value: super::media::FastPlayFallbackBehaviour) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FastPlayFallbackBehaviour)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_thumbnail_requested(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MediaTransportControls, super::media::MediaTransportControlsThumbnailRequestedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ThumbnailRequested)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_thumbnail_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ThumbnailRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMediaTransportControlsStatics2, 388550620, 22047, 17286, 167, 248, 9, 13, 149, 246, 141, 150);
RT_INTERFACE!{static interface IMediaTransportControlsStatics2(IMediaTransportControlsStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IMediaTransportControlsStatics2] {
    fn get_IsSkipForwardButtonVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsSkipForwardEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsSkipBackwardButtonVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsSkipBackwardEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsNextTrackButtonVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsPreviousTrackButtonVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FastPlayFallbackBehaviourProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IMediaTransportControlsStatics2 {
    #[inline] pub unsafe fn get_is_skip_forward_button_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsSkipForwardButtonVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_skip_forward_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsSkipForwardEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_skip_backward_button_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsSkipBackwardButtonVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_skip_backward_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsSkipBackwardEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_next_track_button_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsNextTrackButtonVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_previous_track_button_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsPreviousTrackButtonVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_fast_play_fallback_behaviour_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FastPlayFallbackBehaviourProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPasswordBox, 45722129, 2887, 20093, 173, 145, 58, 65, 104, 237, 35, 13);
RT_INTERFACE!{interface IPasswordBox(IPasswordBoxVtbl): IInspectable(IInspectableVtbl) [IID_IPasswordBox] {
    fn get_Password(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Password(&self, value: HSTRING) -> HRESULT,
    fn get_PasswordChar(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PasswordChar(&self, value: HSTRING) -> HRESULT,
    fn get_IsPasswordRevealButtonEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsPasswordRevealButtonEnabled(&self, value: bool) -> HRESULT,
    fn get_MaxLength(&self, out: *mut i32) -> HRESULT,
    fn put_MaxLength(&self, value: i32) -> HRESULT,
    fn add_PasswordChanged(&self, value: *mut super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PasswordChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ContextMenuOpening(&self, value: *mut ContextMenuOpeningEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ContextMenuOpening(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn SelectAll(&self) -> HRESULT
}}
impl IPasswordBox {
    #[inline] pub unsafe fn get_password(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Password)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_password(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Password)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_password_char(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PasswordChar)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_password_char(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PasswordChar)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_password_reveal_button_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsPasswordRevealButtonEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_password_reveal_button_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsPasswordRevealButtonEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_length(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxLength)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_length(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxLength)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_password_changed(&self, value: &super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PasswordChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_password_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PasswordChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_context_menu_opening(&self, value: &ContextMenuOpeningEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ContextMenuOpening)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_context_menu_opening(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ContextMenuOpening)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn select_all(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).SelectAll)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPasswordBoxStatics, 1592161635, 11636, 19150, 189, 121, 252, 171, 97, 167, 215, 123);
RT_INTERFACE!{static interface IPasswordBoxStatics(IPasswordBoxStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPasswordBoxStatics] {
    fn get_PasswordProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PasswordCharProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsPasswordRevealButtonEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MaxLengthProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IPasswordBoxStatics {
    #[inline] pub unsafe fn get_password_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PasswordProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_password_char_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PasswordCharProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_password_reveal_button_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsPasswordRevealButtonEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_length_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxLengthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPasswordBox2, 1591163103, 8495, 19179, 181, 184, 44, 33, 154, 236, 60, 12);
RT_INTERFACE!{interface IPasswordBox2(IPasswordBox2Vtbl): IInspectable(IInspectableVtbl) [IID_IPasswordBox2] {
    fn get_Header(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Header(&self, value: *mut IInspectable) -> HRESULT,
    fn get_HeaderTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_HeaderTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_PlaceholderText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PlaceholderText(&self, value: HSTRING) -> HRESULT,
    fn get_SelectionHighlightColor(&self, out: *mut *mut super::media::SolidColorBrush) -> HRESULT,
    fn put_SelectionHighlightColor(&self, value: *mut super::media::SolidColorBrush) -> HRESULT,
    fn get_PreventKeyboardDisplayOnProgrammaticFocus(&self, out: *mut bool) -> HRESULT,
    fn put_PreventKeyboardDisplayOnProgrammaticFocus(&self, value: bool) -> HRESULT,
    fn add_Paste(&self, value: *mut TextControlPasteEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Paste(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IPasswordBox2 {
    #[inline] pub unsafe fn get_header(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Header)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Header)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placeholder_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlaceholderText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_placeholder_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PlaceholderText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_highlight_color(&self) -> Result<ComPtr<super::media::SolidColorBrush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionHighlightColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selection_highlight_color(&self, value: &super::media::SolidColorBrush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectionHighlightColor)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_prevent_keyboard_display_on_programmatic_focus(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PreventKeyboardDisplayOnProgrammaticFocus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_prevent_keyboard_display_on_programmatic_focus(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PreventKeyboardDisplayOnProgrammaticFocus)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_paste(&self, value: &TextControlPasteEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Paste)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_paste(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Paste)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPasswordBoxStatics2, 4233597791, 39162, 16486, 183, 133, 250, 114, 94, 205, 226, 50);
RT_INTERFACE!{static interface IPasswordBoxStatics2(IPasswordBoxStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IPasswordBoxStatics2] {
    fn get_HeaderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HeaderTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PlaceholderTextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectionHighlightColorProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PreventKeyboardDisplayOnProgrammaticFocusProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IPasswordBoxStatics2 {
    #[inline] pub unsafe fn get_header_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placeholder_text_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlaceholderTextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_highlight_color_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionHighlightColorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_prevent_keyboard_display_on_programmatic_focus_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PreventKeyboardDisplayOnProgrammaticFocusProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPasswordBox3, 1613027793, 22199, 16880, 149, 88, 57, 52, 193, 66, 68, 214);
RT_INTERFACE!{interface IPasswordBox3(IPasswordBox3Vtbl): IInspectable(IInspectableVtbl) [IID_IPasswordBox3] {
    fn get_PasswordRevealMode(&self, out: *mut PasswordRevealMode) -> HRESULT,
    fn put_PasswordRevealMode(&self, value: PasswordRevealMode) -> HRESULT,
    fn get_TextReadingOrder(&self, out: *mut super::TextReadingOrder) -> HRESULT,
    fn put_TextReadingOrder(&self, value: super::TextReadingOrder) -> HRESULT,
    fn get_InputScope(&self, out: *mut *mut super::input::InputScope) -> HRESULT,
    fn put_InputScope(&self, value: *mut super::input::InputScope) -> HRESULT
}}
impl IPasswordBox3 {
    #[inline] pub unsafe fn get_password_reveal_mode(&self) -> Result<PasswordRevealMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PasswordRevealMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_password_reveal_mode(&self, value: PasswordRevealMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PasswordRevealMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_reading_order(&self) -> Result<super::TextReadingOrder> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextReadingOrder)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_reading_order(&self, value: super::TextReadingOrder) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextReadingOrder)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_input_scope(&self) -> Result<ComPtr<super::input::InputScope>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InputScope)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_input_scope(&self, value: &super::input::InputScope) -> Result<()> {
        let hr = ((*self.lpVtbl).put_InputScope)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPasswordBoxStatics3, 2731397913, 44394, 17234, 181, 144, 246, 150, 255, 203, 142, 63);
RT_INTERFACE!{static interface IPasswordBoxStatics3(IPasswordBoxStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IPasswordBoxStatics3] {
    fn get_PasswordRevealModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextReadingOrderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_InputScopeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IPasswordBoxStatics3 {
    #[inline] pub unsafe fn get_password_reveal_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PasswordRevealModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_reading_order_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextReadingOrderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_input_scope_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InputScopeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IProgressRing, 1839588510, 28317, 16988, 189, 124, 2, 23, 62, 57, 118, 63);
RT_INTERFACE!{interface IProgressRing(IProgressRingVtbl): IInspectable(IInspectableVtbl) [IID_IProgressRing] {
    fn get_IsActive(&self, out: *mut bool) -> HRESULT,
    fn put_IsActive(&self, value: bool) -> HRESULT,
    fn get_TemplateSettings(&self, out: *mut *mut primitives::ProgressRingTemplateSettings) -> HRESULT
}}
impl IProgressRing {
    #[inline] pub unsafe fn get_is_active(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsActive)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_active(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsActive)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_template_settings(&self) -> Result<ComPtr<primitives::ProgressRingTemplateSettings>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TemplateSettings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IProgressRingStatics, 3904251143, 20012, 18389, 165, 74, 198, 196, 138, 94, 105, 137);
RT_INTERFACE!{static interface IProgressRingStatics(IProgressRingStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IProgressRingStatics] {
    fn get_IsActiveProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IProgressRingStatics {
    #[inline] pub unsafe fn get_is_active_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsActiveProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRelativePanel, 783022827, 45914, 16437, 172, 234, 60, 74, 55, 48, 104, 63);
RT_INTERFACE!{interface IRelativePanel(IRelativePanelVtbl): IInspectable(IInspectableVtbl) [IID_IRelativePanel] {
    fn get_BorderBrush(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_BorderBrush(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_BorderThickness(&self, out: *mut super::Thickness) -> HRESULT,
    fn put_BorderThickness(&self, value: super::Thickness) -> HRESULT,
    fn get_CornerRadius(&self, out: *mut super::CornerRadius) -> HRESULT,
    fn put_CornerRadius(&self, value: super::CornerRadius) -> HRESULT,
    fn get_Padding(&self, out: *mut super::Thickness) -> HRESULT,
    fn put_Padding(&self, value: super::Thickness) -> HRESULT
}}
impl IRelativePanel {
    #[inline] pub unsafe fn get_border_brush(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BorderBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_border_brush(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BorderBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_border_thickness(&self) -> Result<super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BorderThickness)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_border_thickness(&self, value: super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BorderThickness)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_corner_radius(&self) -> Result<super::CornerRadius> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CornerRadius)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_corner_radius(&self, value: super::CornerRadius) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CornerRadius)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_padding(&self) -> Result<super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Padding)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_padding(&self, value: super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Padding)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRelativePanelStatics, 361774119, 61836, 19509, 142, 25, 106, 116, 89, 217, 7, 182);
RT_INTERFACE!{static interface IRelativePanelStatics(IRelativePanelStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRelativePanelStatics] {
    fn get_LeftOfProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetLeftOf(&self, element: *mut super::UIElement, out: *mut *mut IInspectable) -> HRESULT,
    fn SetLeftOf(&self, element: *mut super::UIElement, value: *mut IInspectable) -> HRESULT,
    fn get_AboveProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetAbove(&self, element: *mut super::UIElement, out: *mut *mut IInspectable) -> HRESULT,
    fn SetAbove(&self, element: *mut super::UIElement, value: *mut IInspectable) -> HRESULT,
    fn get_RightOfProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetRightOf(&self, element: *mut super::UIElement, out: *mut *mut IInspectable) -> HRESULT,
    fn SetRightOf(&self, element: *mut super::UIElement, value: *mut IInspectable) -> HRESULT,
    fn get_BelowProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetBelow(&self, element: *mut super::UIElement, out: *mut *mut IInspectable) -> HRESULT,
    fn SetBelow(&self, element: *mut super::UIElement, value: *mut IInspectable) -> HRESULT,
    fn get_AlignHorizontalCenterWithProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetAlignHorizontalCenterWith(&self, element: *mut super::UIElement, out: *mut *mut IInspectable) -> HRESULT,
    fn SetAlignHorizontalCenterWith(&self, element: *mut super::UIElement, value: *mut IInspectable) -> HRESULT,
    fn get_AlignVerticalCenterWithProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetAlignVerticalCenterWith(&self, element: *mut super::UIElement, out: *mut *mut IInspectable) -> HRESULT,
    fn SetAlignVerticalCenterWith(&self, element: *mut super::UIElement, value: *mut IInspectable) -> HRESULT,
    fn get_AlignLeftWithProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetAlignLeftWith(&self, element: *mut super::UIElement, out: *mut *mut IInspectable) -> HRESULT,
    fn SetAlignLeftWith(&self, element: *mut super::UIElement, value: *mut IInspectable) -> HRESULT,
    fn get_AlignTopWithProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetAlignTopWith(&self, element: *mut super::UIElement, out: *mut *mut IInspectable) -> HRESULT,
    fn SetAlignTopWith(&self, element: *mut super::UIElement, value: *mut IInspectable) -> HRESULT,
    fn get_AlignRightWithProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetAlignRightWith(&self, element: *mut super::UIElement, out: *mut *mut IInspectable) -> HRESULT,
    fn SetAlignRightWith(&self, element: *mut super::UIElement, value: *mut IInspectable) -> HRESULT,
    fn get_AlignBottomWithProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetAlignBottomWith(&self, element: *mut super::UIElement, out: *mut *mut IInspectable) -> HRESULT,
    fn SetAlignBottomWith(&self, element: *mut super::UIElement, value: *mut IInspectable) -> HRESULT,
    fn get_AlignLeftWithPanelProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetAlignLeftWithPanel(&self, element: *mut super::UIElement, out: *mut bool) -> HRESULT,
    fn SetAlignLeftWithPanel(&self, element: *mut super::UIElement, value: bool) -> HRESULT,
    fn get_AlignTopWithPanelProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetAlignTopWithPanel(&self, element: *mut super::UIElement, out: *mut bool) -> HRESULT,
    fn SetAlignTopWithPanel(&self, element: *mut super::UIElement, value: bool) -> HRESULT,
    fn get_AlignRightWithPanelProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetAlignRightWithPanel(&self, element: *mut super::UIElement, out: *mut bool) -> HRESULT,
    fn SetAlignRightWithPanel(&self, element: *mut super::UIElement, value: bool) -> HRESULT,
    fn get_AlignBottomWithPanelProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetAlignBottomWithPanel(&self, element: *mut super::UIElement, out: *mut bool) -> HRESULT,
    fn SetAlignBottomWithPanel(&self, element: *mut super::UIElement, value: bool) -> HRESULT,
    fn get_AlignHorizontalCenterWithPanelProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetAlignHorizontalCenterWithPanel(&self, element: *mut super::UIElement, out: *mut bool) -> HRESULT,
    fn SetAlignHorizontalCenterWithPanel(&self, element: *mut super::UIElement, value: bool) -> HRESULT,
    fn get_AlignVerticalCenterWithPanelProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetAlignVerticalCenterWithPanel(&self, element: *mut super::UIElement, out: *mut bool) -> HRESULT,
    fn SetAlignVerticalCenterWithPanel(&self, element: *mut super::UIElement, value: bool) -> HRESULT,
    fn get_BorderBrushProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_BorderThicknessProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CornerRadiusProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PaddingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IRelativePanelStatics {
    #[inline] pub unsafe fn get_left_of_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LeftOfProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_left_of(&self, element: &super::UIElement) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetLeftOf)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_left_of(&self, element: &super::UIElement, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).SetLeftOf)(self as *const _ as *mut _, element as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_above_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AboveProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_above(&self, element: &super::UIElement) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAbove)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_above(&self, element: &super::UIElement, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).SetAbove)(self as *const _ as *mut _, element as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_right_of_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RightOfProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_right_of(&self, element: &super::UIElement) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetRightOf)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_right_of(&self, element: &super::UIElement, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).SetRightOf)(self as *const _ as *mut _, element as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_below_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BelowProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_below(&self, element: &super::UIElement) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetBelow)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_below(&self, element: &super::UIElement, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).SetBelow)(self as *const _ as *mut _, element as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_horizontal_center_with_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AlignHorizontalCenterWithProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_horizontal_center_with(&self, element: &super::UIElement) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAlignHorizontalCenterWith)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_align_horizontal_center_with(&self, element: &super::UIElement, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).SetAlignHorizontalCenterWith)(self as *const _ as *mut _, element as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_vertical_center_with_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AlignVerticalCenterWithProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_vertical_center_with(&self, element: &super::UIElement) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAlignVerticalCenterWith)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_align_vertical_center_with(&self, element: &super::UIElement, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).SetAlignVerticalCenterWith)(self as *const _ as *mut _, element as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_left_with_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AlignLeftWithProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_left_with(&self, element: &super::UIElement) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAlignLeftWith)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_align_left_with(&self, element: &super::UIElement, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).SetAlignLeftWith)(self as *const _ as *mut _, element as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_top_with_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AlignTopWithProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_top_with(&self, element: &super::UIElement) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAlignTopWith)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_align_top_with(&self, element: &super::UIElement, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).SetAlignTopWith)(self as *const _ as *mut _, element as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_right_with_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AlignRightWithProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_right_with(&self, element: &super::UIElement) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAlignRightWith)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_align_right_with(&self, element: &super::UIElement, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).SetAlignRightWith)(self as *const _ as *mut _, element as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_bottom_with_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AlignBottomWithProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_bottom_with(&self, element: &super::UIElement) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAlignBottomWith)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_align_bottom_with(&self, element: &super::UIElement, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).SetAlignBottomWith)(self as *const _ as *mut _, element as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_left_with_panel_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AlignLeftWithPanelProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_left_with_panel(&self, element: &super::UIElement) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetAlignLeftWithPanel)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_align_left_with_panel(&self, element: &super::UIElement, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetAlignLeftWithPanel)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_top_with_panel_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AlignTopWithPanelProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_top_with_panel(&self, element: &super::UIElement) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetAlignTopWithPanel)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_align_top_with_panel(&self, element: &super::UIElement, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetAlignTopWithPanel)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_right_with_panel_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AlignRightWithPanelProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_right_with_panel(&self, element: &super::UIElement) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetAlignRightWithPanel)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_align_right_with_panel(&self, element: &super::UIElement, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetAlignRightWithPanel)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_bottom_with_panel_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AlignBottomWithPanelProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_bottom_with_panel(&self, element: &super::UIElement) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetAlignBottomWithPanel)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_align_bottom_with_panel(&self, element: &super::UIElement, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetAlignBottomWithPanel)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_horizontal_center_with_panel_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AlignHorizontalCenterWithPanelProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_horizontal_center_with_panel(&self, element: &super::UIElement) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetAlignHorizontalCenterWithPanel)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_align_horizontal_center_with_panel(&self, element: &super::UIElement, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetAlignHorizontalCenterWithPanel)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_vertical_center_with_panel_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AlignVerticalCenterWithPanelProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_align_vertical_center_with_panel(&self, element: &super::UIElement) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetAlignVerticalCenterWithPanel)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_align_vertical_center_with_panel(&self, element: &super::UIElement, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetAlignVerticalCenterWithPanel)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_border_brush_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BorderBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_border_thickness_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BorderThicknessProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_corner_radius_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CornerRadiusProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_padding_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PaddingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRelativePanelFactory, 2220890428, 13851, 17594, 161, 126, 184, 76, 157, 205, 199, 114);
RT_INTERFACE!{interface IRelativePanelFactory(IRelativePanelFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IRelativePanelFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut RelativePanel) -> HRESULT
}}
impl IRelativePanelFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<RelativePanel>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISemanticZoom, 27262753, 60646, 20412, 191, 64, 137, 56, 212, 129, 62, 39);
RT_INTERFACE!{interface ISemanticZoom(ISemanticZoomVtbl): IInspectable(IInspectableVtbl) [IID_ISemanticZoom] {
    fn get_ZoomedInView(&self, out: *mut *mut ISemanticZoomInformation) -> HRESULT,
    fn put_ZoomedInView(&self, value: *mut ISemanticZoomInformation) -> HRESULT,
    fn get_ZoomedOutView(&self, out: *mut *mut ISemanticZoomInformation) -> HRESULT,
    fn put_ZoomedOutView(&self, value: *mut ISemanticZoomInformation) -> HRESULT,
    fn get_IsZoomedInViewActive(&self, out: *mut bool) -> HRESULT,
    fn put_IsZoomedInViewActive(&self, value: bool) -> HRESULT,
    fn get_CanChangeViews(&self, out: *mut bool) -> HRESULT,
    fn put_CanChangeViews(&self, value: bool) -> HRESULT,
    fn add_ViewChangeStarted(&self, value: *mut SemanticZoomViewChangedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ViewChangeStarted(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ViewChangeCompleted(&self, value: *mut SemanticZoomViewChangedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ViewChangeCompleted(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn ToggleActiveView(&self) -> HRESULT,
    fn get_IsZoomOutButtonEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsZoomOutButtonEnabled(&self, value: bool) -> HRESULT
}}
impl ISemanticZoom {
    #[inline] pub unsafe fn get_zoomed_in_view(&self) -> Result<ComPtr<ISemanticZoomInformation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ZoomedInView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_zoomed_in_view(&self, value: &ISemanticZoomInformation) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ZoomedInView)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoomed_out_view(&self) -> Result<ComPtr<ISemanticZoomInformation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ZoomedOutView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_zoomed_out_view(&self, value: &ISemanticZoomInformation) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ZoomedOutView)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_zoomed_in_view_active(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsZoomedInViewActive)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_zoomed_in_view_active(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsZoomedInViewActive)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_change_views(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanChangeViews)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_change_views(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanChangeViews)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_view_change_started(&self, value: &SemanticZoomViewChangedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ViewChangeStarted)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_view_change_started(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ViewChangeStarted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_view_change_completed(&self, value: &SemanticZoomViewChangedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ViewChangeCompleted)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_view_change_completed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ViewChangeCompleted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn toggle_active_view(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ToggleActiveView)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_zoom_out_button_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsZoomOutButtonEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_zoom_out_button_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsZoomOutButtonEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISemanticZoomStatics, 2398191346, 39064, 18022, 178, 133, 62, 211, 138, 7, 145, 14);
RT_INTERFACE!{static interface ISemanticZoomStatics(ISemanticZoomStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISemanticZoomStatics] {
    fn get_ZoomedInViewProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ZoomedOutViewProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsZoomedInViewActiveProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CanChangeViewsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsZoomOutButtonEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ISemanticZoomStatics {
    #[inline] pub unsafe fn get_zoomed_in_view_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ZoomedInViewProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoomed_out_view_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ZoomedOutViewProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_zoomed_in_view_active_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsZoomedInViewActiveProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_change_views_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CanChangeViewsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_zoom_out_button_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsZoomOutButtonEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IStackPanel, 3098447842, 54849, 20439, 128, 180, 116, 57, 32, 125, 39, 152);
RT_INTERFACE!{interface IStackPanel(IStackPanelVtbl): IInspectable(IInspectableVtbl) [IID_IStackPanel] {
    fn get_AreScrollSnapPointsRegular(&self, out: *mut bool) -> HRESULT,
    fn put_AreScrollSnapPointsRegular(&self, value: bool) -> HRESULT,
    fn get_Orientation(&self, out: *mut Orientation) -> HRESULT,
    fn put_Orientation(&self, value: Orientation) -> HRESULT
}}
impl IStackPanel {
    #[inline] pub unsafe fn get_are_scroll_snap_points_regular(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AreScrollSnapPointsRegular)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_are_scroll_snap_points_regular(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AreScrollSnapPointsRegular)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation(&self) -> Result<Orientation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Orientation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_orientation(&self, value: Orientation) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Orientation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IStackPanelStatics, 4040215955, 19900, 18599, 153, 20, 149, 73, 36, 101, 119, 113);
RT_INTERFACE!{static interface IStackPanelStatics(IStackPanelStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IStackPanelStatics] {
    fn get_AreScrollSnapPointsRegularProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OrientationProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IStackPanelStatics {
    #[inline] pub unsafe fn get_are_scroll_snap_points_regular_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AreScrollSnapPointsRegularProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OrientationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IStackPanelFactory, 1675109514, 35636, 17498, 128, 143, 182, 236, 214, 42, 39, 217);
RT_INTERFACE!{interface IStackPanelFactory(IStackPanelFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IStackPanelFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut StackPanel) -> HRESULT
}}
impl IStackPanelFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<StackPanel>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IStackPanel2, 921842521, 1038, 18679, 154, 152, 242, 102, 69, 145, 149, 156);
RT_INTERFACE!{interface IStackPanel2(IStackPanel2Vtbl): IInspectable(IInspectableVtbl) [IID_IStackPanel2] {
    fn get_BorderBrush(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_BorderBrush(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_BorderThickness(&self, out: *mut super::Thickness) -> HRESULT,
    fn put_BorderThickness(&self, value: super::Thickness) -> HRESULT,
    fn get_CornerRadius(&self, out: *mut super::CornerRadius) -> HRESULT,
    fn put_CornerRadius(&self, value: super::CornerRadius) -> HRESULT,
    fn get_Padding(&self, out: *mut super::Thickness) -> HRESULT,
    fn put_Padding(&self, value: super::Thickness) -> HRESULT
}}
impl IStackPanel2 {
    #[inline] pub unsafe fn get_border_brush(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BorderBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_border_brush(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BorderBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_border_thickness(&self) -> Result<super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BorderThickness)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_border_thickness(&self, value: super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BorderThickness)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_corner_radius(&self) -> Result<super::CornerRadius> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CornerRadius)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_corner_radius(&self, value: super::CornerRadius) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CornerRadius)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_padding(&self) -> Result<super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Padding)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_padding(&self, value: super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Padding)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IStackPanelStatics2, 3648938583, 2061, 16686, 169, 26, 206, 110, 93, 2, 170, 211);
RT_INTERFACE!{static interface IStackPanelStatics2(IStackPanelStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IStackPanelStatics2] {
    fn get_BorderBrushProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_BorderThicknessProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CornerRadiusProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PaddingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IStackPanelStatics2 {
    #[inline] pub unsafe fn get_border_brush_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BorderBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_border_thickness_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BorderThicknessProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_corner_radius_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CornerRadiusProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_padding_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PaddingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextBox, 3834600075, 7679, 17234, 161, 244, 229, 22, 81, 78, 200, 130);
RT_INTERFACE!{interface ITextBox(ITextBoxVtbl): IInspectable(IInspectableVtbl) [IID_ITextBox] {
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Text(&self, value: HSTRING) -> HRESULT,
    fn get_SelectedText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SelectedText(&self, value: HSTRING) -> HRESULT,
    fn get_SelectionLength(&self, out: *mut i32) -> HRESULT,
    fn put_SelectionLength(&self, value: i32) -> HRESULT,
    fn get_SelectionStart(&self, out: *mut i32) -> HRESULT,
    fn put_SelectionStart(&self, value: i32) -> HRESULT,
    fn get_MaxLength(&self, out: *mut i32) -> HRESULT,
    fn put_MaxLength(&self, value: i32) -> HRESULT,
    fn get_IsReadOnly(&self, out: *mut bool) -> HRESULT,
    fn put_IsReadOnly(&self, value: bool) -> HRESULT,
    fn get_AcceptsReturn(&self, out: *mut bool) -> HRESULT,
    fn put_AcceptsReturn(&self, value: bool) -> HRESULT,
    fn get_TextAlignment(&self, out: *mut super::TextAlignment) -> HRESULT,
    fn put_TextAlignment(&self, value: super::TextAlignment) -> HRESULT,
    fn get_TextWrapping(&self, out: *mut super::TextWrapping) -> HRESULT,
    fn put_TextWrapping(&self, value: super::TextWrapping) -> HRESULT,
    fn get_IsSpellCheckEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsSpellCheckEnabled(&self, value: bool) -> HRESULT,
    fn get_IsTextPredictionEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsTextPredictionEnabled(&self, value: bool) -> HRESULT,
    fn get_InputScope(&self, out: *mut *mut super::input::InputScope) -> HRESULT,
    fn put_InputScope(&self, value: *mut super::input::InputScope) -> HRESULT,
    fn add_TextChanged(&self, value: *mut TextChangedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TextChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_SelectionChanged(&self, value: *mut super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SelectionChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ContextMenuOpening(&self, value: *mut ContextMenuOpeningEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ContextMenuOpening(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn Select(&self, start: i32, length: i32) -> HRESULT,
    fn SelectAll(&self) -> HRESULT,
    fn GetRectFromCharacterIndex(&self, charIndex: i32, trailingEdge: bool, out: *mut ::rt::gen::windows::foundation::Rect) -> HRESULT
}}
impl ITextBox {
    #[inline] pub unsafe fn get_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Text)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Text)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_length(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SelectionLength)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selection_length(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectionLength)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_start(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SelectionStart)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selection_start(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectionStart)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_length(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxLength)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_length(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxLength)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_read_only(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsReadOnly)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_read_only(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsReadOnly)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_accepts_return(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AcceptsReturn)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_accepts_return(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AcceptsReturn)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_alignment(&self) -> Result<super::TextAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_alignment(&self, value: super::TextAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_wrapping(&self) -> Result<super::TextWrapping> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextWrapping)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_wrapping(&self, value: super::TextWrapping) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextWrapping)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_spell_check_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSpellCheckEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_spell_check_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSpellCheckEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_text_prediction_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTextPredictionEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_text_prediction_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsTextPredictionEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_input_scope(&self) -> Result<ComPtr<super::input::InputScope>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InputScope)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_input_scope(&self, value: &super::input::InputScope) -> Result<()> {
        let hr = ((*self.lpVtbl).put_InputScope)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_text_changed(&self, value: &TextChangedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TextChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_text_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_TextChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_selection_changed(&self, value: &super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SelectionChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_selection_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SelectionChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_context_menu_opening(&self, value: &ContextMenuOpeningEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ContextMenuOpening)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_context_menu_opening(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ContextMenuOpening)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn select(&self, start: i32, length: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).Select)(self as *const _ as *mut _, start, length);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn select_all(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).SelectAll)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rect_from_character_index(&self, charIndex: i32, trailingEdge: bool) -> Result<::rt::gen::windows::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetRectFromCharacterIndex)(self as *const _ as *mut _, charIndex, trailingEdge, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextBoxStatics, 2117596411, 42172, 17957, 136, 56, 142, 178, 169, 9, 18, 131);
RT_INTERFACE!{static interface ITextBoxStatics(ITextBoxStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ITextBoxStatics] {
    fn get_TextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MaxLengthProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsReadOnlyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_AcceptsReturnProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextWrappingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsSpellCheckEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsTextPredictionEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_InputScopeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ITextBoxStatics {
    #[inline] pub unsafe fn get_text_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_length_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxLengthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_read_only_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsReadOnlyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_accepts_return_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AcceptsReturnProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_wrapping_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextWrappingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_spell_check_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsSpellCheckEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_text_prediction_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsTextPredictionEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_input_scope_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InputScopeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextBoxFactory, 1896759928, 34089, 18387, 141, 142, 48, 126, 52, 207, 240, 129);
RT_INTERFACE!{interface ITextBoxFactory(ITextBoxFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ITextBoxFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut TextBox) -> HRESULT
}}
impl ITextBoxFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<TextBox>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextBox2, 4145449984, 5170, 17962, 148, 5, 56, 243, 133, 191, 195, 124);
RT_INTERFACE!{interface ITextBox2(ITextBox2Vtbl): IInspectable(IInspectableVtbl) [IID_ITextBox2] {
    fn get_Header(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Header(&self, value: *mut IInspectable) -> HRESULT,
    fn get_HeaderTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_HeaderTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_PlaceholderText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PlaceholderText(&self, value: HSTRING) -> HRESULT,
    fn get_SelectionHighlightColor(&self, out: *mut *mut super::media::SolidColorBrush) -> HRESULT,
    fn put_SelectionHighlightColor(&self, value: *mut super::media::SolidColorBrush) -> HRESULT,
    fn get_PreventKeyboardDisplayOnProgrammaticFocus(&self, out: *mut bool) -> HRESULT,
    fn put_PreventKeyboardDisplayOnProgrammaticFocus(&self, value: bool) -> HRESULT,
    fn get_IsColorFontEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsColorFontEnabled(&self, value: bool) -> HRESULT,
    fn add_Paste(&self, value: *mut TextControlPasteEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Paste(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl ITextBox2 {
    #[inline] pub unsafe fn get_header(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Header)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Header)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placeholder_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlaceholderText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_placeholder_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PlaceholderText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_highlight_color(&self) -> Result<ComPtr<super::media::SolidColorBrush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionHighlightColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selection_highlight_color(&self, value: &super::media::SolidColorBrush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectionHighlightColor)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_prevent_keyboard_display_on_programmatic_focus(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PreventKeyboardDisplayOnProgrammaticFocus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_prevent_keyboard_display_on_programmatic_focus(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PreventKeyboardDisplayOnProgrammaticFocus)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_color_font_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsColorFontEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_color_font_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsColorFontEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_paste(&self, value: &TextControlPasteEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Paste)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_paste(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Paste)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextBoxStatics2, 1972564861, 20086, 20196, 142, 15, 125, 110, 26, 35, 50, 107);
RT_INTERFACE!{static interface ITextBoxStatics2(ITextBoxStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_ITextBoxStatics2] {
    fn get_HeaderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HeaderTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PlaceholderTextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectionHighlightColorProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PreventKeyboardDisplayOnProgrammaticFocusProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsColorFontEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ITextBoxStatics2 {
    #[inline] pub unsafe fn get_header_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placeholder_text_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlaceholderTextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_highlight_color_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionHighlightColorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_prevent_keyboard_display_on_programmatic_focus_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PreventKeyboardDisplayOnProgrammaticFocusProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_color_font_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsColorFontEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextBox3, 2112982076, 10278, 16990, 154, 148, 0, 183, 247, 63, 55, 86);
RT_INTERFACE!{interface ITextBox3(ITextBox3Vtbl): IInspectable(IInspectableVtbl) [IID_ITextBox3] {
    fn add_TextCompositionStarted(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<TextBox, TextCompositionStartedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TextCompositionStarted(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_TextCompositionChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<TextBox, TextCompositionChangedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TextCompositionChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_TextCompositionEnded(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<TextBox, TextCompositionEndedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TextCompositionEnded(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn get_TextReadingOrder(&self, out: *mut super::TextReadingOrder) -> HRESULT,
    fn put_TextReadingOrder(&self, value: super::TextReadingOrder) -> HRESULT,
    fn get_DesiredCandidateWindowAlignment(&self, out: *mut CandidateWindowAlignment) -> HRESULT,
    fn put_DesiredCandidateWindowAlignment(&self, value: CandidateWindowAlignment) -> HRESULT,
    fn add_CandidateWindowBoundsChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<TextBox, CandidateWindowBoundsChangedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CandidateWindowBoundsChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_TextChanging(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<TextBox, TextBoxTextChangingEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TextChanging(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl ITextBox3 {
    #[inline] pub unsafe fn add_text_composition_started(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<TextBox, TextCompositionStartedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TextCompositionStarted)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_text_composition_started(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_TextCompositionStarted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_text_composition_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<TextBox, TextCompositionChangedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TextCompositionChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_text_composition_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_TextCompositionChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_text_composition_ended(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<TextBox, TextCompositionEndedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TextCompositionEnded)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_text_composition_ended(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_TextCompositionEnded)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_reading_order(&self) -> Result<super::TextReadingOrder> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextReadingOrder)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_reading_order(&self, value: super::TextReadingOrder) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextReadingOrder)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_desired_candidate_window_alignment(&self) -> Result<CandidateWindowAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DesiredCandidateWindowAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_desired_candidate_window_alignment(&self, value: CandidateWindowAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DesiredCandidateWindowAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_candidate_window_bounds_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<TextBox, CandidateWindowBoundsChangedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CandidateWindowBoundsChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_candidate_window_bounds_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_CandidateWindowBoundsChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_text_changing(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<TextBox, TextBoxTextChangingEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TextChanging)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_text_changing(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_TextChanging)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextBoxStatics3, 235931072, 4277, 16630, 146, 194, 206, 19, 75, 13, 52, 87);
RT_INTERFACE!{static interface ITextBoxStatics3(ITextBoxStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_ITextBoxStatics3] {
    fn get_DesiredCandidateWindowAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextReadingOrderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ITextBoxStatics3 {
    #[inline] pub unsafe fn get_desired_candidate_window_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DesiredCandidateWindowAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_reading_order_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextReadingOrderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextBox4, 3052512885, 52449, 17839, 174, 249, 196, 120, 123, 187, 94, 48);
RT_INTERFACE!{interface ITextBox4(ITextBox4Vtbl): IInspectable(IInspectableVtbl) [IID_ITextBox4] {
    fn GetLinguisticAlternativesAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<HString>>) -> HRESULT
}}
impl ITextBox4 {
    #[inline] pub unsafe fn get_linguistic_alternatives_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<HString>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetLinguisticAlternativesAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextBox5, 905564097, 16758, 17652, 183, 86, 233, 204, 196, 57, 152, 5);
RT_INTERFACE!{interface ITextBox5(ITextBox5Vtbl): IInspectable(IInspectableVtbl) [IID_ITextBox5] {
    fn get_SelectionHighlightColorWhenNotFocused(&self, out: *mut *mut super::media::SolidColorBrush) -> HRESULT,
    fn put_SelectionHighlightColorWhenNotFocused(&self, value: *mut super::media::SolidColorBrush) -> HRESULT
}}
impl ITextBox5 {
    #[inline] pub unsafe fn get_selection_highlight_color_when_not_focused(&self) -> Result<ComPtr<super::media::SolidColorBrush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionHighlightColorWhenNotFocused)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selection_highlight_color_when_not_focused(&self, value: &super::media::SolidColorBrush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectionHighlightColorWhenNotFocused)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextBoxStatics5, 131091269, 6959, 17959, 130, 253, 104, 63, 25, 126, 90, 117);
RT_INTERFACE!{static interface ITextBoxStatics5(ITextBoxStatics5Vtbl): IInspectable(IInspectableVtbl) [IID_ITextBoxStatics5] {
    fn get_SelectionHighlightColorWhenNotFocusedProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ITextBoxStatics5 {
    #[inline] pub unsafe fn get_selection_highlight_color_when_not_focused_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionHighlightColorWhenNotFocusedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IToggleSwitch, 857575168, 50681, 18085, 182, 200, 237, 229, 57, 48, 69, 103);
RT_INTERFACE!{interface IToggleSwitch(IToggleSwitchVtbl): IInspectable(IInspectableVtbl) [IID_IToggleSwitch] {
    fn get_IsOn(&self, out: *mut bool) -> HRESULT,
    fn put_IsOn(&self, value: bool) -> HRESULT,
    fn get_Header(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Header(&self, value: *mut IInspectable) -> HRESULT,
    fn get_HeaderTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_HeaderTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_OnContent(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_OnContent(&self, value: *mut IInspectable) -> HRESULT,
    fn get_OnContentTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_OnContentTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_OffContent(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_OffContent(&self, value: *mut IInspectable) -> HRESULT,
    fn get_OffContentTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_OffContentTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_TemplateSettings(&self, out: *mut *mut primitives::ToggleSwitchTemplateSettings) -> HRESULT,
    fn add_Toggled(&self, value: *mut super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Toggled(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IToggleSwitch {
    #[inline] pub unsafe fn get_is_on(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsOn)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_on(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsOn)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Header)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Header)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_on_content(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OnContent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_on_content(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OnContent)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_on_content_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OnContentTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_on_content_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OnContentTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_off_content(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OffContent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_off_content(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OffContent)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_off_content_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OffContentTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_off_content_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OffContentTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_template_settings(&self) -> Result<ComPtr<primitives::ToggleSwitchTemplateSettings>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TemplateSettings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_toggled(&self, value: &super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Toggled)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_toggled(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Toggled)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IToggleSwitchOverrides, 3218112339, 63690, 20039, 148, 158, 158, 128, 66, 155, 61, 22);
RT_INTERFACE!{interface IToggleSwitchOverrides(IToggleSwitchOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IToggleSwitchOverrides] {
    fn OnToggled(&self) -> HRESULT,
    fn OnOnContentChanged(&self, oldContent: *mut IInspectable, newContent: *mut IInspectable) -> HRESULT,
    fn OnOffContentChanged(&self, oldContent: *mut IInspectable, newContent: *mut IInspectable) -> HRESULT,
    fn OnHeaderChanged(&self, oldContent: *mut IInspectable, newContent: *mut IInspectable) -> HRESULT
}}
impl IToggleSwitchOverrides {
    #[inline] pub unsafe fn on_toggled(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).OnToggled)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_on_content_changed(&self, oldContent: &IInspectable, newContent: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).OnOnContentChanged)(self as *const _ as *mut _, oldContent as *const _ as *mut _, newContent as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_off_content_changed(&self, oldContent: &IInspectable, newContent: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).OnOffContentChanged)(self as *const _ as *mut _, oldContent as *const _ as *mut _, newContent as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_header_changed(&self, oldContent: &IInspectable, newContent: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).OnHeaderChanged)(self as *const _ as *mut _, oldContent as *const _ as *mut _, newContent as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IToggleSwitchStatics, 490148991, 38879, 16934, 146, 202, 221, 244, 83, 215, 253, 90);
RT_INTERFACE!{static interface IToggleSwitchStatics(IToggleSwitchStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IToggleSwitchStatics] {
    fn get_IsOnProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HeaderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HeaderTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OnContentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OnContentTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OffContentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OffContentTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IToggleSwitchStatics {
    #[inline] pub unsafe fn get_is_on_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsOnProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_on_content_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OnContentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_on_content_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OnContentTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_off_content_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OffContentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_off_content_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OffContentTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IUserControl, 2812714697, 59957, 18041, 191, 41, 244, 240, 146, 134, 211, 20);
RT_INTERFACE!{interface IUserControl(IUserControlVtbl): IInspectable(IInspectableVtbl) [IID_IUserControl] {
    fn get_Content(&self, out: *mut *mut super::UIElement) -> HRESULT,
    fn put_Content(&self, value: *mut super::UIElement) -> HRESULT
}}
impl IUserControl {
    #[inline] pub unsafe fn get_content(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Content)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content(&self, value: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Content)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IUserControlStatics, 3901258102, 11356, 16847, 190, 106, 158, 68, 190, 253, 246, 85);
RT_INTERFACE!{static interface IUserControlStatics(IUserControlStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IUserControlStatics] {
    fn get_ContentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IUserControlStatics {
    #[inline] pub unsafe fn get_content_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IUserControlFactory, 951184786, 41610, 18802, 147, 223, 244, 247, 89, 184, 175, 210);
RT_INTERFACE!{interface IUserControlFactory(IUserControlFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IUserControlFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut UserControl) -> HRESULT
}}
impl IUserControlFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<UserControl>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVariableSizedWrapGrid, 2628061127, 9161, 20225, 184, 15, 190, 92, 33, 238, 244, 116);
RT_INTERFACE!{interface IVariableSizedWrapGrid(IVariableSizedWrapGridVtbl): IInspectable(IInspectableVtbl) [IID_IVariableSizedWrapGrid] {
    fn get_ItemHeight(&self, out: *mut f64) -> HRESULT,
    fn put_ItemHeight(&self, value: f64) -> HRESULT,
    fn get_ItemWidth(&self, out: *mut f64) -> HRESULT,
    fn put_ItemWidth(&self, value: f64) -> HRESULT,
    fn get_Orientation(&self, out: *mut Orientation) -> HRESULT,
    fn put_Orientation(&self, value: Orientation) -> HRESULT,
    fn get_HorizontalChildrenAlignment(&self, out: *mut super::HorizontalAlignment) -> HRESULT,
    fn put_HorizontalChildrenAlignment(&self, value: super::HorizontalAlignment) -> HRESULT,
    fn get_VerticalChildrenAlignment(&self, out: *mut super::VerticalAlignment) -> HRESULT,
    fn put_VerticalChildrenAlignment(&self, value: super::VerticalAlignment) -> HRESULT,
    fn get_MaximumRowsOrColumns(&self, out: *mut i32) -> HRESULT,
    fn put_MaximumRowsOrColumns(&self, value: i32) -> HRESULT
}}
impl IVariableSizedWrapGrid {
    #[inline] pub unsafe fn get_item_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ItemHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_item_height(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemHeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ItemWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_item_width(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemWidth)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation(&self) -> Result<Orientation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Orientation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_orientation(&self, value: Orientation) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Orientation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_children_alignment(&self) -> Result<super::HorizontalAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalChildrenAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_horizontal_children_alignment(&self, value: super::HorizontalAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HorizontalChildrenAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_children_alignment(&self) -> Result<super::VerticalAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalChildrenAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_vertical_children_alignment(&self, value: super::VerticalAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_VerticalChildrenAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_maximum_rows_or_columns(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaximumRowsOrColumns)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_maximum_rows_or_columns(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaximumRowsOrColumns)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVariableSizedWrapGridStatics, 4271749209, 33063, 19183, 183, 162, 148, 152, 71, 72, 110, 150);
RT_INTERFACE!{static interface IVariableSizedWrapGridStatics(IVariableSizedWrapGridStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IVariableSizedWrapGridStatics] {
    fn get_ItemHeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ItemWidthProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OrientationProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HorizontalChildrenAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_VerticalChildrenAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MaximumRowsOrColumnsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_RowSpanProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetRowSpan(&self, element: *mut super::UIElement, out: *mut i32) -> HRESULT,
    fn SetRowSpan(&self, element: *mut super::UIElement, value: i32) -> HRESULT,
    fn get_ColumnSpanProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetColumnSpan(&self, element: *mut super::UIElement, out: *mut i32) -> HRESULT,
    fn SetColumnSpan(&self, element: *mut super::UIElement, value: i32) -> HRESULT
}}
impl IVariableSizedWrapGridStatics {
    #[inline] pub unsafe fn get_item_height_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_width_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemWidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OrientationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_children_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HorizontalChildrenAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_children_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VerticalChildrenAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_maximum_rows_or_columns_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaximumRowsOrColumnsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_row_span_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RowSpanProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_row_span(&self, element: &super::UIElement) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetRowSpan)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_row_span(&self, element: &super::UIElement, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetRowSpan)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_column_span_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ColumnSpanProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_column_span(&self, element: &super::UIElement) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetColumnSpan)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_column_span(&self, element: &super::UIElement, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetColumnSpan)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVirtualizingPanel, 950719756, 4815, 19742, 168, 132, 201, 223, 133, 240, 124, 217);
RT_INTERFACE!{interface IVirtualizingPanel(IVirtualizingPanelVtbl): IInspectable(IInspectableVtbl) [IID_IVirtualizingPanel] {
    fn get_ItemContainerGenerator(&self, out: *mut *mut ItemContainerGenerator) -> HRESULT
}}
impl IVirtualizingPanel {
    #[inline] pub unsafe fn get_item_container_generator(&self) -> Result<ComPtr<ItemContainerGenerator>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemContainerGenerator)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVirtualizingPanelOverrides, 1593228669, 26495, 16525, 169, 108, 177, 149, 7, 117, 4, 102);
RT_INTERFACE!{interface IVirtualizingPanelOverrides(IVirtualizingPanelOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IVirtualizingPanelOverrides] {
    fn OnItemsChanged(&self, sender: *mut IInspectable, args: *mut primitives::ItemsChangedEventArgs) -> HRESULT,
    fn OnClearChildren(&self) -> HRESULT,
    fn BringIndexIntoView(&self, index: i32) -> HRESULT
}}
impl IVirtualizingPanelOverrides {
    #[inline] pub unsafe fn on_items_changed(&self, sender: &IInspectable, args: &primitives::ItemsChangedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnItemsChanged)(self as *const _ as *mut _, sender as *const _ as *mut _, args as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_clear_children(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).OnClearChildren)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn bring_index_into_view(&self, index: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).BringIndexIntoView)(self as *const _ as *mut _, index);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVirtualizingPanelProtected, 3385436994, 49714, 18333, 167, 201, 94, 118, 17, 25, 106, 69);
RT_INTERFACE!{interface IVirtualizingPanelProtected(IVirtualizingPanelProtectedVtbl): IInspectable(IInspectableVtbl) [IID_IVirtualizingPanelProtected] {
    fn AddInternalChild(&self, child: *mut super::UIElement) -> HRESULT,
    fn InsertInternalChild(&self, index: i32, child: *mut super::UIElement) -> HRESULT,
    fn RemoveInternalChildRange(&self, index: i32, range: i32) -> HRESULT
}}
impl IVirtualizingPanelProtected {
    #[inline] pub unsafe fn add_internal_child(&self, child: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).AddInternalChild)(self as *const _ as *mut _, child as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn insert_internal_child(&self, index: i32, child: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).InsertInternalChild)(self as *const _ as *mut _, index, child as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_internal_child_range(&self, index: i32, range: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).RemoveInternalChildRange)(self as *const _ as *mut _, index, range);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVirtualizingPanelFactory, 3189372985, 52176, 17385, 165, 208, 11, 219, 160, 255, 189, 56);
RT_INTERFACE!{interface IVirtualizingPanelFactory(IVirtualizingPanelFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IVirtualizingPanelFactory] {
    
}}
DEFINE_IID!(IID_IGroupItem, 1256773073, 29224, 18966, 166, 31, 136, 192, 232, 244, 92, 118);
RT_INTERFACE!{interface IGroupItem(IGroupItemVtbl): IInspectable(IInspectableVtbl) [IID_IGroupItem] {
    
}}
DEFINE_IID!(IID_IGroupItemFactory, 3651261758, 45536, 17177, 152, 8, 122, 158, 136, 126, 19, 176);
RT_INTERFACE!{interface IGroupItemFactory(IGroupItemFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGroupItemFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut GroupItem) -> HRESULT
}}
impl IGroupItemFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<GroupItem>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewBaseHeaderItem, 1829629223, 3353, 16529, 137, 23, 206, 124, 133, 193, 230, 48);
RT_INTERFACE!{interface IListViewBaseHeaderItem(IListViewBaseHeaderItemVtbl): IInspectable(IInspectableVtbl) [IID_IListViewBaseHeaderItem] {
    
}}
DEFINE_IID!(IID_IListViewBaseHeaderItemFactory, 947037857, 59929, 17759, 157, 247, 20, 124, 196, 29, 50, 156);
RT_INTERFACE!{interface IListViewBaseHeaderItemFactory(IListViewBaseHeaderItemFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IListViewBaseHeaderItemFactory] {
    
}}
DEFINE_IID!(IID_IProgressBar, 2926914697, 103, 18787, 191, 76, 41, 219, 12, 74, 80, 126);
RT_INTERFACE!{interface IProgressBar(IProgressBarVtbl): IInspectable(IInspectableVtbl) [IID_IProgressBar] {
    fn get_IsIndeterminate(&self, out: *mut bool) -> HRESULT,
    fn put_IsIndeterminate(&self, value: bool) -> HRESULT,
    fn get_ShowError(&self, out: *mut bool) -> HRESULT,
    fn put_ShowError(&self, value: bool) -> HRESULT,
    fn get_ShowPaused(&self, out: *mut bool) -> HRESULT,
    fn put_ShowPaused(&self, value: bool) -> HRESULT,
    fn get_TemplateSettings(&self, out: *mut *mut primitives::ProgressBarTemplateSettings) -> HRESULT
}}
impl IProgressBar {
    #[inline] pub unsafe fn get_is_indeterminate(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsIndeterminate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_indeterminate(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsIndeterminate)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_show_error(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ShowError)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_show_error(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ShowError)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_show_paused(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ShowPaused)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_show_paused(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ShowPaused)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_template_settings(&self) -> Result<ComPtr<primitives::ProgressBarTemplateSettings>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TemplateSettings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IProgressBarStatics, 2048040922, 22583, 20006, 179, 180, 225, 192, 146, 206, 187, 236);
RT_INTERFACE!{static interface IProgressBarStatics(IProgressBarStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IProgressBarStatics] {
    fn get_IsIndeterminateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ShowErrorProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ShowPausedProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IProgressBarStatics {
    #[inline] pub unsafe fn get_is_indeterminate_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsIndeterminateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_show_error_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ShowErrorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_show_paused_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ShowPausedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IProgressBarFactory, 3667561489, 5521, 16395, 169, 147, 15, 28, 92, 193, 47, 59);
RT_INTERFACE!{interface IProgressBarFactory(IProgressBarFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IProgressBarFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ProgressBar) -> HRESULT
}}
impl IProgressBarFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ProgressBar>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISettingsFlyout, 2198579243, 50523, 20018, 165, 28, 87, 145, 224, 36, 200, 175);
RT_INTERFACE!{interface ISettingsFlyout(ISettingsFlyoutVtbl): IInspectable(IInspectableVtbl) [IID_ISettingsFlyout] {
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    fn get_HeaderBackground(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_HeaderBackground(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_HeaderForeground(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_HeaderForeground(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_IconSource(&self, out: *mut *mut super::media::ImageSource) -> HRESULT,
    fn put_IconSource(&self, value: *mut super::media::ImageSource) -> HRESULT,
    fn get_TemplateSettings(&self, out: *mut *mut primitives::SettingsFlyoutTemplateSettings) -> HRESULT,
    fn add_BackClick(&self, value: *mut BackClickEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BackClick(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn Show(&self) -> HRESULT,
    fn ShowIndependent(&self) -> HRESULT,
    fn Hide(&self) -> HRESULT
}}
impl ISettingsFlyout {
    #[inline] pub unsafe fn get_title(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Title)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_title(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Title)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_background(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderBackground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_background(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderBackground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_foreground(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderForeground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_foreground(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderForeground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_icon_source(&self) -> Result<ComPtr<super::media::ImageSource>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IconSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_icon_source(&self, value: &super::media::ImageSource) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IconSource)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_template_settings(&self) -> Result<ComPtr<primitives::SettingsFlyoutTemplateSettings>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TemplateSettings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_back_click(&self, value: &BackClickEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_BackClick)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_back_click(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_BackClick)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn show(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Show)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_independent(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ShowIndependent)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn hide(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Hide)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISettingsFlyoutStatics, 3504583989, 37207, 19428, 164, 42, 245, 145, 105, 136, 70, 172);
RT_INTERFACE!{static interface ISettingsFlyoutStatics(ISettingsFlyoutStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISettingsFlyoutStatics] {
    fn get_TitleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HeaderBackgroundProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HeaderForegroundProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IconSourceProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ISettingsFlyoutStatics {
    #[inline] pub unsafe fn get_title_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TitleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_background_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderBackgroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_foreground_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderForegroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_icon_source_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IconSourceProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISettingsFlyoutFactory, 1208774673, 22442, 19894, 182, 253, 236, 103, 111, 109, 65, 78);
RT_INTERFACE!{interface ISettingsFlyoutFactory(ISettingsFlyoutFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISettingsFlyoutFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut SettingsFlyout) -> HRESULT
}}
impl ISettingsFlyoutFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<SettingsFlyout>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISlider, 2304188455, 19528, 18176, 128, 118, 73, 123, 167, 61, 156, 24);
RT_INTERFACE!{interface ISlider(ISliderVtbl): IInspectable(IInspectableVtbl) [IID_ISlider] {
    fn get_IntermediateValue(&self, out: *mut f64) -> HRESULT,
    fn put_IntermediateValue(&self, value: f64) -> HRESULT,
    fn get_StepFrequency(&self, out: *mut f64) -> HRESULT,
    fn put_StepFrequency(&self, value: f64) -> HRESULT,
    fn get_SnapsTo(&self, out: *mut primitives::SliderSnapsTo) -> HRESULT,
    fn put_SnapsTo(&self, value: primitives::SliderSnapsTo) -> HRESULT,
    fn get_TickFrequency(&self, out: *mut f64) -> HRESULT,
    fn put_TickFrequency(&self, value: f64) -> HRESULT,
    fn get_TickPlacement(&self, out: *mut primitives::TickPlacement) -> HRESULT,
    fn put_TickPlacement(&self, value: primitives::TickPlacement) -> HRESULT,
    fn get_Orientation(&self, out: *mut Orientation) -> HRESULT,
    fn put_Orientation(&self, value: Orientation) -> HRESULT,
    fn get_IsDirectionReversed(&self, out: *mut bool) -> HRESULT,
    fn put_IsDirectionReversed(&self, value: bool) -> HRESULT,
    fn get_IsThumbToolTipEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsThumbToolTipEnabled(&self, value: bool) -> HRESULT,
    fn get_ThumbToolTipValueConverter(&self, out: *mut *mut super::data::IValueConverter) -> HRESULT,
    fn put_ThumbToolTipValueConverter(&self, value: *mut super::data::IValueConverter) -> HRESULT
}}
impl ISlider {
    #[inline] pub unsafe fn get_intermediate_value(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IntermediateValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_intermediate_value(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IntermediateValue)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_step_frequency(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StepFrequency)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_step_frequency(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StepFrequency)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_snaps_to(&self) -> Result<primitives::SliderSnapsTo> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SnapsTo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_snaps_to(&self, value: primitives::SliderSnapsTo) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SnapsTo)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tick_frequency(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TickFrequency)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_tick_frequency(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TickFrequency)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tick_placement(&self) -> Result<primitives::TickPlacement> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TickPlacement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_tick_placement(&self, value: primitives::TickPlacement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TickPlacement)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation(&self) -> Result<Orientation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Orientation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_orientation(&self, value: Orientation) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Orientation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_direction_reversed(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsDirectionReversed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_direction_reversed(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsDirectionReversed)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_thumb_tool_tip_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsThumbToolTipEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_thumb_tool_tip_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsThumbToolTipEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_thumb_tool_tip_value_converter(&self) -> Result<ComPtr<super::data::IValueConverter>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ThumbToolTipValueConverter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_thumb_tool_tip_value_converter(&self, value: &super::data::IValueConverter) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ThumbToolTipValueConverter)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISliderStatics, 2319672279, 32735, 19760, 152, 254, 206, 120, 192, 91, 49, 207);
RT_INTERFACE!{static interface ISliderStatics(ISliderStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISliderStatics] {
    fn get_IntermediateValueProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_StepFrequencyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SnapsToProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TickFrequencyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TickPlacementProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OrientationProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsDirectionReversedProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsThumbToolTipEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ThumbToolTipValueConverterProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ISliderStatics {
    #[inline] pub unsafe fn get_intermediate_value_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IntermediateValueProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_step_frequency_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StepFrequencyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_snaps_to_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SnapsToProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tick_frequency_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TickFrequencyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tick_placement_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TickPlacementProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OrientationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_direction_reversed_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsDirectionReversedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_thumb_tool_tip_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsThumbToolTipEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_thumb_tool_tip_value_converter_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ThumbToolTipValueConverterProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISliderFactory, 61242167, 51135, 17276, 132, 143, 140, 181, 183, 83, 234, 180);
RT_INTERFACE!{interface ISliderFactory(ISliderFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISliderFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut Slider) -> HRESULT
}}
impl ISliderFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<Slider>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISlider2, 1084474638, 34774, 19759, 177, 207, 178, 121, 204, 153, 111, 38);
RT_INTERFACE!{interface ISlider2(ISlider2Vtbl): IInspectable(IInspectableVtbl) [IID_ISlider2] {
    fn get_Header(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Header(&self, value: *mut IInspectable) -> HRESULT,
    fn get_HeaderTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_HeaderTemplate(&self, value: *mut super::DataTemplate) -> HRESULT
}}
impl ISlider2 {
    #[inline] pub unsafe fn get_header(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Header)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Header)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISliderStatics2, 15176541, 31141, 18265, 150, 166, 41, 224, 169, 74, 221, 51);
RT_INTERFACE!{static interface ISliderStatics2(ISliderStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_ISliderStatics2] {
    fn get_HeaderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HeaderTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ISliderStatics2 {
    #[inline] pub unsafe fn get_header_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IToolTip, 2112214879, 17429, 17055, 181, 35, 105, 155, 219, 140, 48, 219);
RT_INTERFACE!{interface IToolTip(IToolTipVtbl): IInspectable(IInspectableVtbl) [IID_IToolTip] {
    fn get_HorizontalOffset(&self, out: *mut f64) -> HRESULT,
    fn put_HorizontalOffset(&self, value: f64) -> HRESULT,
    fn get_IsOpen(&self, out: *mut bool) -> HRESULT,
    fn put_IsOpen(&self, value: bool) -> HRESULT,
    fn get_Placement(&self, out: *mut primitives::PlacementMode) -> HRESULT,
    fn put_Placement(&self, value: primitives::PlacementMode) -> HRESULT,
    fn get_PlacementTarget(&self, out: *mut *mut super::UIElement) -> HRESULT,
    fn put_PlacementTarget(&self, value: *mut super::UIElement) -> HRESULT,
    fn get_VerticalOffset(&self, out: *mut f64) -> HRESULT,
    fn put_VerticalOffset(&self, value: f64) -> HRESULT,
    fn get_TemplateSettings(&self, out: *mut *mut primitives::ToolTipTemplateSettings) -> HRESULT,
    fn add_Closed(&self, value: *mut super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Opened(&self, value: *mut super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Opened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IToolTip {
    #[inline] pub unsafe fn get_horizontal_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_horizontal_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HorizontalOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_open(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsOpen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_open(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsOpen)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placement(&self) -> Result<primitives::PlacementMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Placement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_placement(&self, value: primitives::PlacementMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Placement)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placement_target(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlacementTarget)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_placement_target(&self, value: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PlacementTarget)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_vertical_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_VerticalOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_template_settings(&self) -> Result<ComPtr<primitives::ToolTipTemplateSettings>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TemplateSettings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_closed(&self, value: &super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Closed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_closed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Closed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_opened(&self, value: &super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Opened)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_opened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Opened)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IToolTipStatics, 4026697144, 19369, 20303, 134, 167, 134, 0, 56, 19, 206, 179);
RT_INTERFACE!{static interface IToolTipStatics(IToolTipStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IToolTipStatics] {
    fn get_HorizontalOffsetProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsOpenProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PlacementProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PlacementTargetProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_VerticalOffsetProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IToolTipStatics {
    #[inline] pub unsafe fn get_horizontal_offset_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HorizontalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_open_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsOpenProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placement_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlacementProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placement_target_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlacementTargetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_offset_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VerticalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IToolTipFactory, 2307101699, 46392, 18915, 164, 48, 58, 192, 55, 220, 111, 224);
RT_INTERFACE!{interface IToolTipFactory(IToolTipFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IToolTipFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ToolTip) -> HRESULT
}}
impl IToolTipFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ToolTip>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IButton, 671298990, 21872, 18119, 142, 11, 96, 43, 231, 18, 41, 162);
RT_INTERFACE!{interface IButton(IButtonVtbl): IInspectable(IInspectableVtbl) [IID_IButton] {
    
}}
DEFINE_IID!(IID_IButtonFactory, 2158050329, 33850, 17692, 140, 245, 68, 199, 1, 176, 226, 22);
RT_INTERFACE!{interface IButtonFactory(IButtonFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IButtonFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut Button) -> HRESULT
}}
impl IButtonFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<Button>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IButtonWithFlyout, 152080263, 57196, 16768, 155, 58, 230, 8, 69, 130, 88, 17);
RT_INTERFACE!{interface IButtonWithFlyout(IButtonWithFlyoutVtbl): IInspectable(IInspectableVtbl) [IID_IButtonWithFlyout] {
    fn get_Flyout(&self, out: *mut *mut primitives::FlyoutBase) -> HRESULT,
    fn put_Flyout(&self, value: *mut primitives::FlyoutBase) -> HRESULT
}}
impl IButtonWithFlyout {
    #[inline] pub unsafe fn get_flyout(&self) -> Result<ComPtr<primitives::FlyoutBase>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Flyout)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_flyout(&self, value: &primitives::FlyoutBase) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Flyout)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IButtonStaticsWithFlyout, 2417244312, 41324, 18265, 178, 240, 165, 247, 230, 37, 22, 158);
RT_INTERFACE!{static interface IButtonStaticsWithFlyout(IButtonStaticsWithFlyoutVtbl): IInspectable(IInspectableVtbl) [IID_IButtonStaticsWithFlyout] {
    fn get_FlyoutProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IButtonStaticsWithFlyout {
    #[inline] pub unsafe fn get_flyout_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FlyoutProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IComboBox, 3114848348, 44183, 18417, 165, 244, 63, 159, 77, 75, 17, 108);
RT_INTERFACE!{interface IComboBox(IComboBoxVtbl): IInspectable(IInspectableVtbl) [IID_IComboBox] {
    fn get_IsDropDownOpen(&self, out: *mut bool) -> HRESULT,
    fn put_IsDropDownOpen(&self, value: bool) -> HRESULT,
    fn get_IsEditable(&self, out: *mut bool) -> HRESULT,
    fn get_IsSelectionBoxHighlighted(&self, out: *mut bool) -> HRESULT,
    fn get_MaxDropDownHeight(&self, out: *mut f64) -> HRESULT,
    fn put_MaxDropDownHeight(&self, value: f64) -> HRESULT,
    fn get_SelectionBoxItem(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn get_SelectionBoxItemTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn get_TemplateSettings(&self, out: *mut *mut primitives::ComboBoxTemplateSettings) -> HRESULT,
    fn add_DropDownClosed(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DropDownClosed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_DropDownOpened(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DropDownOpened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IComboBox {
    #[inline] pub unsafe fn get_is_drop_down_open(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsDropDownOpen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_drop_down_open(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsDropDownOpen)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_editable(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsEditable)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_selection_box_highlighted(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSelectionBoxHighlighted)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_drop_down_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxDropDownHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_drop_down_height(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxDropDownHeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_box_item(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionBoxItem)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_box_item_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionBoxItemTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_template_settings(&self) -> Result<ComPtr<primitives::ComboBoxTemplateSettings>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TemplateSettings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_drop_down_closed(&self, value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DropDownClosed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_drop_down_closed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DropDownClosed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_drop_down_opened(&self, value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DropDownOpened)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_drop_down_opened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DropDownOpened)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IComboBoxOverrides, 1325491521, 48382, 18978, 137, 50, 201, 20, 152, 28, 34, 64);
RT_INTERFACE!{interface IComboBoxOverrides(IComboBoxOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IComboBoxOverrides] {
    fn OnDropDownClosed(&self, e: *mut IInspectable) -> HRESULT,
    fn OnDropDownOpened(&self, e: *mut IInspectable) -> HRESULT
}}
impl IComboBoxOverrides {
    #[inline] pub unsafe fn on_drop_down_closed(&self, e: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).OnDropDownClosed)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_drop_down_opened(&self, e: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).OnDropDownOpened)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IComboBoxStatics, 1041549745, 53595, 19913, 129, 16, 207, 58, 17, 123, 150, 231);
RT_INTERFACE!{static interface IComboBoxStatics(IComboBoxStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IComboBoxStatics] {
    fn get_IsDropDownOpenProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MaxDropDownHeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IComboBoxStatics {
    #[inline] pub unsafe fn get_is_drop_down_open_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsDropDownOpenProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_drop_down_height_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxDropDownHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IComboBoxFactory, 2886534212, 42587, 19133, 134, 223, 48, 22, 4, 158, 254, 220);
RT_INTERFACE!{interface IComboBoxFactory(IComboBoxFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IComboBoxFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ComboBox) -> HRESULT
}}
impl IComboBoxFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ComboBox>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IComboBox2, 3926704017, 51766, 20397, 151, 42, 46, 83, 166, 113, 139, 159);
RT_INTERFACE!{interface IComboBox2(IComboBox2Vtbl): IInspectable(IInspectableVtbl) [IID_IComboBox2] {
    fn get_Header(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Header(&self, value: *mut IInspectable) -> HRESULT,
    fn get_HeaderTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_HeaderTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_PlaceholderText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PlaceholderText(&self, value: HSTRING) -> HRESULT
}}
impl IComboBox2 {
    #[inline] pub unsafe fn get_header(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Header)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Header)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placeholder_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlaceholderText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_placeholder_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PlaceholderText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IComboBoxStatics2, 2476247569, 16428, 19219, 150, 209, 114, 32, 38, 107, 146, 32);
RT_INTERFACE!{static interface IComboBoxStatics2(IComboBoxStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IComboBoxStatics2] {
    fn get_HeaderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HeaderTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PlaceholderTextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IComboBoxStatics2 {
    #[inline] pub unsafe fn get_header_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placeholder_text_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlaceholderTextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IComboBox3, 1379928675, 18284, 19382, 183, 129, 1, 147, 36, 211, 254, 217);
RT_INTERFACE!{interface IComboBox3(IComboBox3Vtbl): IInspectable(IInspectableVtbl) [IID_IComboBox3] {
    fn get_LightDismissOverlayMode(&self, out: *mut LightDismissOverlayMode) -> HRESULT,
    fn put_LightDismissOverlayMode(&self, value: LightDismissOverlayMode) -> HRESULT,
    fn get_IsTextSearchEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsTextSearchEnabled(&self, value: bool) -> HRESULT
}}
impl IComboBox3 {
    #[inline] pub unsafe fn get_light_dismiss_overlay_mode(&self) -> Result<LightDismissOverlayMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LightDismissOverlayMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_light_dismiss_overlay_mode(&self, value: LightDismissOverlayMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LightDismissOverlayMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_text_search_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTextSearchEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_text_search_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsTextSearchEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IComboBoxStatics3, 2493387791, 52863, 20033, 189, 197, 209, 211, 56, 138, 208, 166);
RT_INTERFACE!{static interface IComboBoxStatics3(IComboBoxStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IComboBoxStatics3] {
    fn get_LightDismissOverlayModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsTextSearchEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IComboBoxStatics3 {
    #[inline] pub unsafe fn get_light_dismiss_overlay_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LightDismissOverlayModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_text_search_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsTextSearchEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IComboBox4, 3080146761, 45148, 18425, 154, 175, 214, 249, 24, 123, 229, 253);
RT_INTERFACE!{interface IComboBox4(IComboBox4Vtbl): IInspectable(IInspectableVtbl) [IID_IComboBox4] {
    fn get_SelectionChangedTrigger(&self, out: *mut ComboBoxSelectionChangedTrigger) -> HRESULT,
    fn put_SelectionChangedTrigger(&self, value: ComboBoxSelectionChangedTrigger) -> HRESULT
}}
impl IComboBox4 {
    #[inline] pub unsafe fn get_selection_changed_trigger(&self) -> Result<ComboBoxSelectionChangedTrigger> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SelectionChangedTrigger)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selection_changed_trigger(&self, value: ComboBoxSelectionChangedTrigger) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectionChangedTrigger)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IComboBoxStatics4, 3656745816, 63408, 18126, 128, 97, 173, 131, 236, 47, 45, 212);
RT_INTERFACE!{static interface IComboBoxStatics4(IComboBoxStatics4Vtbl): IInspectable(IInspectableVtbl) [IID_IComboBoxStatics4] {
    fn get_SelectionChangedTriggerProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IComboBoxStatics4 {
    #[inline] pub unsafe fn get_selection_changed_trigger_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionChangedTriggerProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IComboBoxItem, 2571097810, 10926, 20283, 180, 77, 86, 72, 244, 208, 97, 20);
RT_INTERFACE!{interface IComboBoxItem(IComboBoxItemVtbl): IInspectable(IInspectableVtbl) [IID_IComboBoxItem] {
    
}}
DEFINE_IID!(IID_IComboBoxItemFactory, 2415913063, 55628, 20103, 143, 196, 110, 188, 214, 60, 90, 194);
RT_INTERFACE!{interface IComboBoxItemFactory(IComboBoxItemFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IComboBoxItemFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ComboBoxItem) -> HRESULT
}}
impl IComboBoxItemFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ComboBoxItem>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFlipView, 2706911080, 15741, 19771, 183, 29, 72, 142, 237, 30, 52, 147);
RT_INTERFACE!{interface IFlipView(IFlipViewVtbl): IInspectable(IInspectableVtbl) [IID_IFlipView] {
    
}}
DEFINE_IID!(IID_IFlipViewFactory, 4057901502, 39656, 19787, 171, 67, 22, 211, 30, 5, 244, 243);
RT_INTERFACE!{interface IFlipViewFactory(IFlipViewFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IFlipViewFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut FlipView) -> HRESULT
}}
impl IFlipViewFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<FlipView>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFlipView2, 3305022717, 31475, 18770, 159, 217, 158, 9, 135, 252, 79, 41);
RT_INTERFACE!{interface IFlipView2(IFlipView2Vtbl): IInspectable(IInspectableVtbl) [IID_IFlipView2] {
    fn get_UseTouchAnimationsForAllNavigation(&self, out: *mut bool) -> HRESULT,
    fn put_UseTouchAnimationsForAllNavigation(&self, value: bool) -> HRESULT
}}
impl IFlipView2 {
    #[inline] pub unsafe fn get_use_touch_animations_for_all_navigation(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_UseTouchAnimationsForAllNavigation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_use_touch_animations_for_all_navigation(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_UseTouchAnimationsForAllNavigation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFlipViewStatics2, 1893980479, 17160, 19362, 187, 206, 226, 203, 14, 211, 68, 118);
RT_INTERFACE!{static interface IFlipViewStatics2(IFlipViewStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IFlipViewStatics2] {
    fn get_UseTouchAnimationsForAllNavigationProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IFlipViewStatics2 {
    #[inline] pub unsafe fn get_use_touch_animations_for_all_navigation_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UseTouchAnimationsForAllNavigationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFlipViewItem, 1444504933, 52779, 19418, 163, 107, 130, 162, 184, 176, 212, 192);
RT_INTERFACE!{interface IFlipViewItem(IFlipViewItemVtbl): IInspectable(IInspectableVtbl) [IID_IFlipViewItem] {
    
}}
DEFINE_IID!(IID_IFlipViewItemFactory, 4062024190, 8864, 17426, 168, 83, 157, 106, 110, 143, 42, 175);
RT_INTERFACE!{interface IFlipViewItemFactory(IFlipViewItemFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IFlipViewItemFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut FlipViewItem) -> HRESULT
}}
impl IFlipViewItemFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<FlipViewItem>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IHyperlinkButton, 3437997219, 15196, 20300, 155, 253, 134, 136, 123, 199, 151, 114);
RT_INTERFACE!{interface IHyperlinkButton(IHyperlinkButtonVtbl): IInspectable(IInspectableVtbl) [IID_IHyperlinkButton] {
    fn get_NavigateUri(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn put_NavigateUri(&self, value: *mut ::rt::gen::windows::foundation::Uri) -> HRESULT
}}
impl IHyperlinkButton {
    #[inline] pub unsafe fn get_navigate_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NavigateUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_navigate_uri(&self, value: &::rt::gen::windows::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_NavigateUri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IHyperlinkButtonStatics, 4222531015, 52663, 16995, 183, 214, 60, 13, 41, 4, 237, 152);
RT_INTERFACE!{static interface IHyperlinkButtonStatics(IHyperlinkButtonStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IHyperlinkButtonStatics] {
    fn get_NavigateUriProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IHyperlinkButtonStatics {
    #[inline] pub unsafe fn get_navigate_uri_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NavigateUriProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IHyperlinkButtonFactory, 1129454509, 20119, 19881, 166, 77, 147, 93, 253, 140, 237, 242);
RT_INTERFACE!{interface IHyperlinkButtonFactory(IHyperlinkButtonFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IHyperlinkButtonFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut HyperlinkButton) -> HRESULT
}}
impl IHyperlinkButtonFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<HyperlinkButton>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListBox, 3925064191, 36497, 20175, 167, 7, 201, 39, 246, 148, 248, 129);
RT_INTERFACE!{interface IListBox(IListBoxVtbl): IInspectable(IInspectableVtbl) [IID_IListBox] {
    fn get_SelectedItems(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<IInspectable>) -> HRESULT,
    fn get_SelectionMode(&self, out: *mut SelectionMode) -> HRESULT,
    fn put_SelectionMode(&self, value: SelectionMode) -> HRESULT,
    fn ScrollIntoView(&self, item: *mut IInspectable) -> HRESULT,
    fn SelectAll(&self) -> HRESULT
}}
impl IListBox {
    #[inline] pub unsafe fn get_selected_items(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<IInspectable>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedItems)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_mode(&self) -> Result<SelectionMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SelectionMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selection_mode(&self, value: SelectionMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectionMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn scroll_into_view(&self, item: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).ScrollIntoView)(self as *const _ as *mut _, item as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn select_all(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).SelectAll)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListBoxStatics, 1832877939, 28778, 20051, 169, 170, 201, 165, 60, 156, 221, 112);
RT_INTERFACE!{static interface IListBoxStatics(IListBoxStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IListBoxStatics] {
    fn get_SelectionModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IListBoxStatics {
    #[inline] pub unsafe fn get_selection_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListBoxFactory, 1624112546, 12100, 17483, 156, 148, 184, 201, 253, 164, 111, 89);
RT_INTERFACE!{interface IListBoxFactory(IListBoxFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IListBoxFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ListBox) -> HRESULT
}}
impl IListBoxFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ListBox>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListBox2, 1884760762, 35537, 16517, 147, 80, 222, 238, 53, 146, 148, 227);
RT_INTERFACE!{interface IListBox2(IListBox2Vtbl): IInspectable(IInspectableVtbl) [IID_IListBox2] {
    fn get_SingleSelectionFollowsFocus(&self, out: *mut bool) -> HRESULT,
    fn put_SingleSelectionFollowsFocus(&self, value: bool) -> HRESULT
}}
impl IListBox2 {
    #[inline] pub unsafe fn get_single_selection_follows_focus(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SingleSelectionFollowsFocus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_single_selection_follows_focus(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SingleSelectionFollowsFocus)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListBoxStatics2, 9022955, 46857, 19597, 177, 237, 74, 125, 151, 238, 119, 22);
RT_INTERFACE!{static interface IListBoxStatics2(IListBoxStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IListBoxStatics2] {
    fn get_SingleSelectionFollowsFocusProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IListBoxStatics2 {
    #[inline] pub unsafe fn get_single_selection_follows_focus_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SingleSelectionFollowsFocusProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListBoxItem, 1136735011, 28383, 20043, 182, 178, 58, 147, 238, 196, 29, 149);
RT_INTERFACE!{interface IListBoxItem(IListBoxItemVtbl): IInspectable(IInspectableVtbl) [IID_IListBoxItem] {
    
}}
DEFINE_IID!(IID_IListBoxItemFactory, 1134082260, 41950, 16428, 178, 61, 25, 3, 132, 178, 124, 168);
RT_INTERFACE!{interface IListBoxItemFactory(IListBoxItemFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IListBoxItemFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ListBoxItem) -> HRESULT
}}
impl IListBoxItemFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ListBoxItem>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewBase, 1023939514, 26768, 17719, 191, 229, 121, 109, 148, 88, 237, 214);
RT_INTERFACE!{interface IListViewBase(IListViewBaseVtbl): IInspectable(IInspectableVtbl) [IID_IListViewBase] {
    fn get_SelectedItems(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<IInspectable>) -> HRESULT,
    fn get_SelectionMode(&self, out: *mut ListViewSelectionMode) -> HRESULT,
    fn put_SelectionMode(&self, value: ListViewSelectionMode) -> HRESULT,
    fn get_IsSwipeEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsSwipeEnabled(&self, value: bool) -> HRESULT,
    fn get_CanDragItems(&self, out: *mut bool) -> HRESULT,
    fn put_CanDragItems(&self, value: bool) -> HRESULT,
    fn get_CanReorderItems(&self, out: *mut bool) -> HRESULT,
    fn put_CanReorderItems(&self, value: bool) -> HRESULT,
    fn get_IsItemClickEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsItemClickEnabled(&self, value: bool) -> HRESULT,
    fn get_DataFetchSize(&self, out: *mut f64) -> HRESULT,
    fn put_DataFetchSize(&self, value: f64) -> HRESULT,
    fn get_IncrementalLoadingThreshold(&self, out: *mut f64) -> HRESULT,
    fn put_IncrementalLoadingThreshold(&self, value: f64) -> HRESULT,
    fn get_IncrementalLoadingTrigger(&self, out: *mut IncrementalLoadingTrigger) -> HRESULT,
    fn put_IncrementalLoadingTrigger(&self, value: IncrementalLoadingTrigger) -> HRESULT,
    fn add_ItemClick(&self, value: *mut ItemClickEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ItemClick(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_DragItemsStarting(&self, value: *mut DragItemsStartingEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DragItemsStarting(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn ScrollIntoView(&self, item: *mut IInspectable) -> HRESULT,
    fn SelectAll(&self) -> HRESULT,
    fn LoadMoreItemsAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<super::data::LoadMoreItemsResult>) -> HRESULT,
    fn ScrollIntoViewWithAlignment(&self, item: *mut IInspectable, alignment: ScrollIntoViewAlignment) -> HRESULT,
    fn get_Header(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Header(&self, value: *mut IInspectable) -> HRESULT,
    fn get_HeaderTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_HeaderTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_HeaderTransitions(&self, out: *mut *mut super::media::animation::TransitionCollection) -> HRESULT,
    fn put_HeaderTransitions(&self, value: *mut super::media::animation::TransitionCollection) -> HRESULT
}}
impl IListViewBase {
    #[inline] pub unsafe fn get_selected_items(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<IInspectable>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedItems)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_mode(&self) -> Result<ListViewSelectionMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SelectionMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selection_mode(&self, value: ListViewSelectionMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectionMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_swipe_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSwipeEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_swipe_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSwipeEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_drag_items(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanDragItems)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_drag_items(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanDragItems)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_reorder_items(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanReorderItems)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_reorder_items(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanReorderItems)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_item_click_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsItemClickEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_item_click_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsItemClickEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_data_fetch_size(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DataFetchSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_data_fetch_size(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DataFetchSize)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_incremental_loading_threshold(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IncrementalLoadingThreshold)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_incremental_loading_threshold(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IncrementalLoadingThreshold)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_incremental_loading_trigger(&self) -> Result<IncrementalLoadingTrigger> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IncrementalLoadingTrigger)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_incremental_loading_trigger(&self, value: IncrementalLoadingTrigger) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IncrementalLoadingTrigger)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_item_click(&self, value: &ItemClickEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ItemClick)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_item_click(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ItemClick)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_drag_items_starting(&self, value: &DragItemsStartingEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DragItemsStarting)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_drag_items_starting(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DragItemsStarting)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn scroll_into_view(&self, item: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).ScrollIntoView)(self as *const _ as *mut _, item as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn select_all(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).SelectAll)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn load_more_items_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<super::data::LoadMoreItemsResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).LoadMoreItemsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn scroll_into_view_with_alignment(&self, item: &IInspectable, alignment: ScrollIntoViewAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).ScrollIntoViewWithAlignment)(self as *const _ as *mut _, item as *const _ as *mut _, alignment);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Header)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Header)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_transitions(&self) -> Result<ComPtr<super::media::animation::TransitionCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTransitions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_transitions(&self, value: &super::media::animation::TransitionCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderTransitions)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewBaseStatics, 2234693879, 15894, 17755, 137, 168, 193, 52, 98, 35, 246, 211);
RT_INTERFACE!{static interface IListViewBaseStatics(IListViewBaseStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IListViewBaseStatics] {
    fn get_SelectionModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsSwipeEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CanDragItemsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CanReorderItemsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsItemClickEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DataFetchSizeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IncrementalLoadingThresholdProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IncrementalLoadingTriggerProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SemanticZoomOwnerProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsActiveViewProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsZoomedInViewProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HeaderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HeaderTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HeaderTransitionsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IListViewBaseStatics {
    #[inline] pub unsafe fn get_selection_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_swipe_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsSwipeEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_drag_items_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CanDragItemsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_reorder_items_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CanReorderItemsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_item_click_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsItemClickEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_data_fetch_size_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DataFetchSizeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_incremental_loading_threshold_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IncrementalLoadingThresholdProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_incremental_loading_trigger_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IncrementalLoadingTriggerProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_semantic_zoom_owner_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SemanticZoomOwnerProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_active_view_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsActiveViewProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_zoomed_in_view_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsZoomedInViewProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_transitions_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTransitionsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewBaseFactory, 3867044991, 5391, 18128, 166, 172, 197, 0, 43, 217, 202, 83);
RT_INTERFACE!{interface IListViewBaseFactory(IListViewBaseFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IListViewBaseFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ListViewBase) -> HRESULT
}}
impl IListViewBaseFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ListViewBase>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewBase2, 3519194359, 30883, 17553, 134, 224, 45, 222, 188, 0, 122, 197);
RT_INTERFACE!{interface IListViewBase2(IListViewBase2Vtbl): IInspectable(IInspectableVtbl) [IID_IListViewBase2] {
    fn get_ShowsScrollingPlaceholders(&self, out: *mut bool) -> HRESULT,
    fn put_ShowsScrollingPlaceholders(&self, value: bool) -> HRESULT,
    fn add_ContainerContentChanging(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ContainerContentChanging(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn SetDesiredContainerUpdateDuration(&self, duration: ::rt::gen::windows::foundation::TimeSpan) -> HRESULT,
    fn get_Footer(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Footer(&self, value: *mut IInspectable) -> HRESULT,
    fn get_FooterTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_FooterTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_FooterTransitions(&self, out: *mut *mut super::media::animation::TransitionCollection) -> HRESULT,
    fn put_FooterTransitions(&self, value: *mut super::media::animation::TransitionCollection) -> HRESULT
}}
impl IListViewBase2 {
    #[inline] pub unsafe fn get_shows_scrolling_placeholders(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ShowsScrollingPlaceholders)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_shows_scrolling_placeholders(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ShowsScrollingPlaceholders)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_container_content_changing(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ContainerContentChanging)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_container_content_changing(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ContainerContentChanging)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_desired_container_update_duration(&self, duration: ::rt::gen::windows::foundation::TimeSpan) -> Result<()> {
        let hr = ((*self.lpVtbl).SetDesiredContainerUpdateDuration)(self as *const _ as *mut _, duration);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_footer(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Footer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_footer(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Footer)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_footer_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FooterTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_footer_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FooterTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_footer_transitions(&self) -> Result<ComPtr<super::media::animation::TransitionCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FooterTransitions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_footer_transitions(&self, value: &super::media::animation::TransitionCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FooterTransitions)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewBaseStatics2, 2182873288, 30924, 16671, 159, 46, 165, 87, 88, 34, 127, 62);
RT_INTERFACE!{static interface IListViewBaseStatics2(IListViewBaseStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IListViewBaseStatics2] {
    fn get_ShowsScrollingPlaceholdersProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FooterProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FooterTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FooterTransitionsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IListViewBaseStatics2 {
    #[inline] pub unsafe fn get_shows_scrolling_placeholders_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ShowsScrollingPlaceholdersProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_footer_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FooterProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_footer_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FooterTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_footer_transitions_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FooterTransitionsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewBase3, 3009724469, 2579, 16495, 163, 251, 243, 14, 125, 220, 169, 76);
RT_INTERFACE!{interface IListViewBase3(IListViewBase3Vtbl): IInspectable(IInspectableVtbl) [IID_IListViewBase3] {
    fn get_ReorderMode(&self, out: *mut ListViewReorderMode) -> HRESULT,
    fn put_ReorderMode(&self, value: ListViewReorderMode) -> HRESULT
}}
impl IListViewBase3 {
    #[inline] pub unsafe fn get_reorder_mode(&self) -> Result<ListViewReorderMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ReorderMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_reorder_mode(&self, value: ListViewReorderMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ReorderMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewBaseStatics3, 995332241, 12742, 19724, 144, 175, 93, 193, 214, 174, 156, 5);
RT_INTERFACE!{static interface IListViewBaseStatics3(IListViewBaseStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IListViewBaseStatics3] {
    fn get_ReorderModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IListViewBaseStatics3 {
    #[inline] pub unsafe fn get_reorder_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ReorderModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewBase4, 414677291, 4572, 20150, 167, 188, 116, 26, 219, 62, 235, 121);
RT_INTERFACE!{interface IListViewBase4(IListViewBase4Vtbl): IInspectable(IInspectableVtbl) [IID_IListViewBase4] {
    fn get_SelectedRanges(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<super::data::ItemIndexRange>) -> HRESULT,
    fn get_IsMultiSelectCheckBoxEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsMultiSelectCheckBoxEnabled(&self, value: bool) -> HRESULT,
    fn add_DragItemsCompleted(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<ListViewBase, DragItemsCompletedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DragItemsCompleted(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ChoosingItemContainer(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<ListViewBase, ChoosingItemContainerEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ChoosingItemContainer(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ChoosingGroupHeaderContainer(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<ListViewBase, ChoosingGroupHeaderContainerEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ChoosingGroupHeaderContainer(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn SelectRange(&self, itemIndexRange: *mut super::data::ItemIndexRange) -> HRESULT,
    fn DeselectRange(&self, itemIndexRange: *mut super::data::ItemIndexRange) -> HRESULT
}}
impl IListViewBase4 {
    #[inline] pub unsafe fn get_selected_ranges(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<super::data::ItemIndexRange>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedRanges)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_multi_select_check_box_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsMultiSelectCheckBoxEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_multi_select_check_box_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsMultiSelectCheckBoxEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_drag_items_completed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<ListViewBase, DragItemsCompletedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DragItemsCompleted)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_drag_items_completed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DragItemsCompleted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_choosing_item_container(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<ListViewBase, ChoosingItemContainerEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ChoosingItemContainer)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_choosing_item_container(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ChoosingItemContainer)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_choosing_group_header_container(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<ListViewBase, ChoosingGroupHeaderContainerEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ChoosingGroupHeaderContainer)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_choosing_group_header_container(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ChoosingGroupHeaderContainer)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn select_range(&self, itemIndexRange: &super::data::ItemIndexRange) -> Result<()> {
        let hr = ((*self.lpVtbl).SelectRange)(self as *const _ as *mut _, itemIndexRange as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn deselect_range(&self, itemIndexRange: &super::data::ItemIndexRange) -> Result<()> {
        let hr = ((*self.lpVtbl).DeselectRange)(self as *const _ as *mut _, itemIndexRange as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewBaseStatics4, 2903713163, 64464, 20248, 139, 248, 155, 134, 19, 149, 28, 34);
RT_INTERFACE!{static interface IListViewBaseStatics4(IListViewBaseStatics4Vtbl): IInspectable(IInspectableVtbl) [IID_IListViewBaseStatics4] {
    fn get_IsMultiSelectCheckBoxEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IListViewBaseStatics4 {
    #[inline] pub unsafe fn get_is_multi_select_check_box_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsMultiSelectCheckBoxEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewBase5, 446459545, 5913, 19328, 179, 53, 98, 131, 49, 160, 112, 25);
RT_INTERFACE!{interface IListViewBase5(IListViewBase5Vtbl): IInspectable(IInspectableVtbl) [IID_IListViewBase5] {
    fn get_SingleSelectionFollowsFocus(&self, out: *mut bool) -> HRESULT,
    fn put_SingleSelectionFollowsFocus(&self, value: bool) -> HRESULT,
    fn IsDragSource(&self, out: *mut bool) -> HRESULT
}}
impl IListViewBase5 {
    #[inline] pub unsafe fn get_single_selection_follows_focus(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SingleSelectionFollowsFocus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_single_selection_follows_focus(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SingleSelectionFollowsFocus)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_drag_source(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsDragSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewBaseStatics5, 1077178319, 1142, 16985, 137, 95, 166, 86, 151, 56, 98, 15);
RT_INTERFACE!{static interface IListViewBaseStatics5(IListViewBaseStatics5Vtbl): IInspectable(IInspectableVtbl) [IID_IListViewBaseStatics5] {
    fn get_SingleSelectionFollowsFocusProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IListViewBaseStatics5 {
    #[inline] pub unsafe fn get_single_selection_follows_focus_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SingleSelectionFollowsFocusProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewBase6, 4171507255, 38491, 18491, 148, 229, 229, 201, 254, 240, 227, 82);
RT_INTERFACE!{interface IListViewBase6(IListViewBase6Vtbl): IInspectable(IInspectableVtbl) [IID_IListViewBase6] {
    fn TryStartConnectedAnimationAsync(&self, animation: *mut super::media::animation::ConnectedAnimation, item: *mut IInspectable, elementName: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn PrepareConnectedAnimation(&self, key: HSTRING, item: *mut IInspectable, elementName: HSTRING, out: *mut *mut super::media::animation::ConnectedAnimation) -> HRESULT
}}
impl IListViewBase6 {
    #[inline] pub unsafe fn try_start_connected_animation_async(&self, animation: &super::media::animation::ConnectedAnimation, item: &IInspectable, elementName: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryStartConnectedAnimationAsync)(self as *const _ as *mut _, animation as *const _ as *mut _, item as *const _ as *mut _, elementName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn prepare_connected_animation(&self, key: &HStringArg, item: &IInspectable, elementName: &HStringArg) -> Result<ComPtr<super::media::animation::ConnectedAnimation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).PrepareConnectedAnimation)(self as *const _ as *mut _, key.get(), item as *const _ as *mut _, elementName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVirtualizingStackPanel, 1969737114, 41908, 19946, 187, 17, 84, 158, 44, 47, 145, 157);
RT_INTERFACE!{interface IVirtualizingStackPanel(IVirtualizingStackPanelVtbl): IInspectable(IInspectableVtbl) [IID_IVirtualizingStackPanel] {
    fn get_AreScrollSnapPointsRegular(&self, out: *mut bool) -> HRESULT,
    fn put_AreScrollSnapPointsRegular(&self, value: bool) -> HRESULT,
    fn get_Orientation(&self, out: *mut Orientation) -> HRESULT,
    fn put_Orientation(&self, value: Orientation) -> HRESULT,
    fn add_CleanUpVirtualizedItemEvent(&self, value: *mut CleanUpVirtualizedItemEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CleanUpVirtualizedItemEvent(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IVirtualizingStackPanel {
    #[inline] pub unsafe fn get_are_scroll_snap_points_regular(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AreScrollSnapPointsRegular)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_are_scroll_snap_points_regular(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AreScrollSnapPointsRegular)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation(&self) -> Result<Orientation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Orientation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_orientation(&self, value: Orientation) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Orientation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_clean_up_virtualized_item_event(&self, value: &CleanUpVirtualizedItemEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CleanUpVirtualizedItemEvent)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_clean_up_virtualized_item_event(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_CleanUpVirtualizedItemEvent)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVirtualizingStackPanelOverrides, 3420911404, 10386, 18129, 152, 127, 88, 202, 16, 129, 240, 64);
RT_INTERFACE!{interface IVirtualizingStackPanelOverrides(IVirtualizingStackPanelOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IVirtualizingStackPanelOverrides] {
    fn OnCleanUpVirtualizedItem(&self, e: *mut CleanUpVirtualizedItemEventArgs) -> HRESULT
}}
impl IVirtualizingStackPanelOverrides {
    #[inline] pub unsafe fn on_clean_up_virtualized_item(&self, e: &CleanUpVirtualizedItemEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnCleanUpVirtualizedItem)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVirtualizingStackPanelStatics, 2199185272, 37331, 19798, 172, 9, 34, 58, 220, 210, 189, 63);
RT_INTERFACE!{static interface IVirtualizingStackPanelStatics(IVirtualizingStackPanelStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IVirtualizingStackPanelStatics] {
    fn get_AreScrollSnapPointsRegularProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OrientationProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_VirtualizationModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetVirtualizationMode(&self, element: *mut super::DependencyObject, out: *mut VirtualizationMode) -> HRESULT,
    fn SetVirtualizationMode(&self, element: *mut super::DependencyObject, value: VirtualizationMode) -> HRESULT,
    fn get_IsVirtualizingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetIsVirtualizing(&self, o: *mut super::DependencyObject, out: *mut bool) -> HRESULT
}}
impl IVirtualizingStackPanelStatics {
    #[inline] pub unsafe fn get_are_scroll_snap_points_regular_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AreScrollSnapPointsRegularProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OrientationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_virtualization_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VirtualizationModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_virtualization_mode(&self, element: &super::DependencyObject) -> Result<VirtualizationMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetVirtualizationMode)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_virtualization_mode(&self, element: &super::DependencyObject, value: VirtualizationMode) -> Result<()> {
        let hr = ((*self.lpVtbl).SetVirtualizationMode)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_virtualizing_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsVirtualizingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_virtualizing(&self, o: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsVirtualizing)(self as *const _ as *mut _, o as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICheckBox, 580176020, 32298, 19312, 176, 136, 143, 93, 129, 72, 117, 186);
RT_INTERFACE!{interface ICheckBox(ICheckBoxVtbl): IInspectable(IInspectableVtbl) [IID_ICheckBox] {
    
}}
DEFINE_IID!(IID_ICheckBoxFactory, 1336322747, 16203, 17153, 190, 7, 17, 114, 234, 97, 238, 251);
RT_INTERFACE!{interface ICheckBoxFactory(ICheckBoxFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICheckBoxFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut CheckBox) -> HRESULT
}}
impl ICheckBoxFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<CheckBox>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRadioButton, 844907744, 39427, 19443, 171, 214, 111, 187, 70, 201, 164, 134);
RT_INTERFACE!{interface IRadioButton(IRadioButtonVtbl): IInspectable(IInspectableVtbl) [IID_IRadioButton] {
    fn get_GroupName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_GroupName(&self, value: HSTRING) -> HRESULT
}}
impl IRadioButton {
    #[inline] pub unsafe fn get_group_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GroupName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_group_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_GroupName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRadioButtonStatics, 1796510355, 62735, 19416, 176, 172, 92, 22, 47, 51, 162, 8);
RT_INTERFACE!{static interface IRadioButtonStatics(IRadioButtonStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRadioButtonStatics] {
    fn get_GroupNameProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IRadioButtonStatics {
    #[inline] pub unsafe fn get_group_name_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GroupNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRadioButtonFactory, 4056959283, 13537, 19036, 178, 174, 202, 59, 28, 11, 32, 222);
RT_INTERFACE!{interface IRadioButtonFactory(IRadioButtonFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IRadioButtonFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut RadioButton) -> HRESULT
}}
impl IRadioButtonFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<RadioButton>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_ENUM! { enum AppBarClosedDisplayMode: i32 {
    Compact (AppBarClosedDisplayMode_Compact) = 0, Minimal (AppBarClosedDisplayMode_Minimal) = 1, Hidden (AppBarClosedDisplayMode_Hidden) = 2,
}}
RT_ENUM! { enum AutoSuggestionBoxTextChangeReason: i32 {
    UserInput (AutoSuggestionBoxTextChangeReason_UserInput) = 0, ProgrammaticChange (AutoSuggestionBoxTextChangeReason_ProgrammaticChange) = 1, SuggestionChosen (AutoSuggestionBoxTextChangeReason_SuggestionChosen) = 2,
}}
RT_ENUM! { enum CalendarViewDisplayMode: i32 {
    Month (CalendarViewDisplayMode_Month) = 0, Year (CalendarViewDisplayMode_Year) = 1, Decade (CalendarViewDisplayMode_Decade) = 2,
}}
RT_ENUM! { enum CalendarViewSelectionMode: i32 {
    None (CalendarViewSelectionMode_None) = 0, Single (CalendarViewSelectionMode_Single) = 1, Multiple (CalendarViewSelectionMode_Multiple) = 2,
}}
RT_ENUM! { enum CommandBarDefaultLabelPosition: i32 {
    Bottom (CommandBarDefaultLabelPosition_Bottom) = 0, Right (CommandBarDefaultLabelPosition_Right) = 1, Collapsed (CommandBarDefaultLabelPosition_Collapsed) = 2,
}}
RT_ENUM! { enum CommandBarDynamicOverflowAction: i32 {
    AddingToOverflow (CommandBarDynamicOverflowAction_AddingToOverflow) = 0, RemovingFromOverflow (CommandBarDynamicOverflowAction_RemovingFromOverflow) = 1,
}}
RT_ENUM! { enum CommandBarLabelPosition: i32 {
    Default (CommandBarLabelPosition_Default) = 0, Collapsed (CommandBarLabelPosition_Collapsed) = 1,
}}
RT_ENUM! { enum CommandBarOverflowButtonVisibility: i32 {
    Auto (CommandBarOverflowButtonVisibility_Auto) = 0, Visible (CommandBarOverflowButtonVisibility_Visible) = 1, Collapsed (CommandBarOverflowButtonVisibility_Collapsed) = 2,
}}
RT_ENUM! { enum ContentDialogButton: i32 {
    None (ContentDialogButton_None) = 0, Primary (ContentDialogButton_Primary) = 1, Secondary (ContentDialogButton_Secondary) = 2, Close (ContentDialogButton_Close) = 3,
}}
RT_ENUM! { enum ContentDialogResult: i32 {
    None (ContentDialogResult_None) = 0, Primary (ContentDialogResult_Primary) = 1, Secondary (ContentDialogResult_Secondary) = 2,
}}
RT_ENUM! { enum SplitViewDisplayMode: i32 {
    Overlay (SplitViewDisplayMode_Overlay) = 0, Inline (SplitViewDisplayMode_Inline) = 1, CompactOverlay (SplitViewDisplayMode_CompactOverlay) = 2, CompactInline (SplitViewDisplayMode_CompactInline) = 3,
}}
RT_ENUM! { enum SplitViewPanePlacement: i32 {
    Left (SplitViewPanePlacement_Left) = 0, Right (SplitViewPanePlacement_Right) = 1,
}}
RT_ENUM! { enum Symbol: i32 {
    Previous (Symbol_Previous) = 57600, Next (Symbol_Next) = 57601, Play (Symbol_Play) = 57602, Pause (Symbol_Pause) = 57603, Edit (Symbol_Edit) = 57604, Save (Symbol_Save) = 57605, Clear (Symbol_Clear) = 57606, Delete (Symbol_Delete) = 57607, Remove (Symbol_Remove) = 57608, Add (Symbol_Add) = 57609, Cancel (Symbol_Cancel) = 57610, Accept (Symbol_Accept) = 57611, More (Symbol_More) = 57612, Redo (Symbol_Redo) = 57613, Undo (Symbol_Undo) = 57614, Home (Symbol_Home) = 57615, Up (Symbol_Up) = 57616, Forward (Symbol_Forward) = 57617, Back (Symbol_Back) = 57618, Favorite (Symbol_Favorite) = 57619, Camera (Symbol_Camera) = 57620, Setting (Symbol_Setting) = 57621, Video (Symbol_Video) = 57622, Sync (Symbol_Sync) = 57623, Download (Symbol_Download) = 57624, Mail (Symbol_Mail) = 57625, Find (Symbol_Find) = 57626, Help (Symbol_Help) = 57627, Upload (Symbol_Upload) = 57628, Emoji (Symbol_Emoji) = 57629, TwoPage (Symbol_TwoPage) = 57630, LeaveChat (Symbol_LeaveChat) = 57631, MailForward (Symbol_MailForward) = 57632, Clock (Symbol_Clock) = 57633, Send (Symbol_Send) = 57634, Crop (Symbol_Crop) = 57635, RotateCamera (Symbol_RotateCamera) = 57636, People (Symbol_People) = 57637, OpenPane (Symbol_OpenPane) = 57638, ClosePane (Symbol_ClosePane) = 57639, World (Symbol_World) = 57640, Flag (Symbol_Flag) = 57641, PreviewLink (Symbol_PreviewLink) = 57642, Globe (Symbol_Globe) = 57643, Trim (Symbol_Trim) = 57644, AttachCamera (Symbol_AttachCamera) = 57645, ZoomIn (Symbol_ZoomIn) = 57646, Bookmarks (Symbol_Bookmarks) = 57647, Document (Symbol_Document) = 57648, ProtectedDocument (Symbol_ProtectedDocument) = 57649, Page (Symbol_Page) = 57650, Bullets (Symbol_Bullets) = 57651, Comment (Symbol_Comment) = 57652, MailFilled (Symbol_MailFilled) = 57653, ContactInfo (Symbol_ContactInfo) = 57654, HangUp (Symbol_HangUp) = 57655, ViewAll (Symbol_ViewAll) = 57656, MapPin (Symbol_MapPin) = 57657, Phone (Symbol_Phone) = 57658, VideoChat (Symbol_VideoChat) = 57659, Switch (Symbol_Switch) = 57660, Contact (Symbol_Contact) = 57661, Rename (Symbol_Rename) = 57662, Pin (Symbol_Pin) = 57665, MusicInfo (Symbol_MusicInfo) = 57666, Go (Symbol_Go) = 57667, Keyboard (Symbol_Keyboard) = 57668, DockLeft (Symbol_DockLeft) = 57669, DockRight (Symbol_DockRight) = 57670, DockBottom (Symbol_DockBottom) = 57671, Remote (Symbol_Remote) = 57672, Refresh (Symbol_Refresh) = 57673, Rotate (Symbol_Rotate) = 57674, Shuffle (Symbol_Shuffle) = 57675, List (Symbol_List) = 57676, Shop (Symbol_Shop) = 57677, SelectAll (Symbol_SelectAll) = 57678, Orientation (Symbol_Orientation) = 57679, Import (Symbol_Import) = 57680, ImportAll (Symbol_ImportAll) = 57681, BrowsePhotos (Symbol_BrowsePhotos) = 57685, WebCam (Symbol_WebCam) = 57686, Pictures (Symbol_Pictures) = 57688, SaveLocal (Symbol_SaveLocal) = 57689, Caption (Symbol_Caption) = 57690, Stop (Symbol_Stop) = 57691, ShowResults (Symbol_ShowResults) = 57692, Volume (Symbol_Volume) = 57693, Repair (Symbol_Repair) = 57694, Message (Symbol_Message) = 57695, Page2 (Symbol_Page2) = 57696, CalendarDay (Symbol_CalendarDay) = 57697, CalendarWeek (Symbol_CalendarWeek) = 57698, Calendar (Symbol_Calendar) = 57699, Character (Symbol_Character) = 57700, MailReplyAll (Symbol_MailReplyAll) = 57701, Read (Symbol_Read) = 57702, Link (Symbol_Link) = 57703, Account (Symbol_Account) = 57704, ShowBcc (Symbol_ShowBcc) = 57705, HideBcc (Symbol_HideBcc) = 57706, Cut (Symbol_Cut) = 57707, Attach (Symbol_Attach) = 57708, Paste (Symbol_Paste) = 57709, Filter (Symbol_Filter) = 57710, Copy (Symbol_Copy) = 57711, Emoji2 (Symbol_Emoji2) = 57712, Important (Symbol_Important) = 57713, MailReply (Symbol_MailReply) = 57714, SlideShow (Symbol_SlideShow) = 57715, Sort (Symbol_Sort) = 57716, Manage (Symbol_Manage) = 57720, AllApps (Symbol_AllApps) = 57721, DisconnectDrive (Symbol_DisconnectDrive) = 57722, MapDrive (Symbol_MapDrive) = 57723, NewWindow (Symbol_NewWindow) = 57724, OpenWith (Symbol_OpenWith) = 57725, ContactPresence (Symbol_ContactPresence) = 57729, Priority (Symbol_Priority) = 57730, GoToToday (Symbol_GoToToday) = 57732, Font (Symbol_Font) = 57733, FontColor (Symbol_FontColor) = 57734, Contact2 (Symbol_Contact2) = 57735, Folder (Symbol_Folder) = 57736, Audio (Symbol_Audio) = 57737, Placeholder (Symbol_Placeholder) = 57738, View (Symbol_View) = 57739, SetLockScreen (Symbol_SetLockScreen) = 57740, SetTile (Symbol_SetTile) = 57741, ClosedCaption (Symbol_ClosedCaption) = 57744, StopSlideShow (Symbol_StopSlideShow) = 57745, Permissions (Symbol_Permissions) = 57746, Highlight (Symbol_Highlight) = 57747, DisableUpdates (Symbol_DisableUpdates) = 57748, UnFavorite (Symbol_UnFavorite) = 57749, UnPin (Symbol_UnPin) = 57750, OpenLocal (Symbol_OpenLocal) = 57751, Mute (Symbol_Mute) = 57752, Italic (Symbol_Italic) = 57753, Underline (Symbol_Underline) = 57754, Bold (Symbol_Bold) = 57755, MoveToFolder (Symbol_MoveToFolder) = 57756, LikeDislike (Symbol_LikeDislike) = 57757, Dislike (Symbol_Dislike) = 57758, Like (Symbol_Like) = 57759, AlignRight (Symbol_AlignRight) = 57760, AlignCenter (Symbol_AlignCenter) = 57761, AlignLeft (Symbol_AlignLeft) = 57762, Zoom (Symbol_Zoom) = 57763, ZoomOut (Symbol_ZoomOut) = 57764, OpenFile (Symbol_OpenFile) = 57765, OtherUser (Symbol_OtherUser) = 57766, Admin (Symbol_Admin) = 57767, Street (Symbol_Street) = 57795, Map (Symbol_Map) = 57796, ClearSelection (Symbol_ClearSelection) = 57797, FontDecrease (Symbol_FontDecrease) = 57798, FontIncrease (Symbol_FontIncrease) = 57799, FontSize (Symbol_FontSize) = 57800, CellPhone (Symbol_CellPhone) = 57801, ReShare (Symbol_ReShare) = 57802, Tag (Symbol_Tag) = 57803, RepeatOne (Symbol_RepeatOne) = 57804, RepeatAll (Symbol_RepeatAll) = 57805, OutlineStar (Symbol_OutlineStar) = 57806, SolidStar (Symbol_SolidStar) = 57807, Calculator (Symbol_Calculator) = 57808, Directions (Symbol_Directions) = 57809, Target (Symbol_Target) = 57810, Library (Symbol_Library) = 57811, PhoneBook (Symbol_PhoneBook) = 57812, Memo (Symbol_Memo) = 57813, Microphone (Symbol_Microphone) = 57814, PostUpdate (Symbol_PostUpdate) = 57815, BackToWindow (Symbol_BackToWindow) = 57816, FullScreen (Symbol_FullScreen) = 57817, NewFolder (Symbol_NewFolder) = 57818, CalendarReply (Symbol_CalendarReply) = 57819, UnSyncFolder (Symbol_UnSyncFolder) = 57821, ReportHacked (Symbol_ReportHacked) = 57822, SyncFolder (Symbol_SyncFolder) = 57823, BlockContact (Symbol_BlockContact) = 57824, SwitchApps (Symbol_SwitchApps) = 57825, AddFriend (Symbol_AddFriend) = 57826, TouchPointer (Symbol_TouchPointer) = 57827, GoToStart (Symbol_GoToStart) = 57828, ZeroBars (Symbol_ZeroBars) = 57829, OneBar (Symbol_OneBar) = 57830, TwoBars (Symbol_TwoBars) = 57831, ThreeBars (Symbol_ThreeBars) = 57832, FourBars (Symbol_FourBars) = 57833, Scan (Symbol_Scan) = 58004, Preview (Symbol_Preview) = 58005,
}}
RT_ENUM! { enum WebViewExecutionMode: i32 {
    SameThread (WebViewExecutionMode_SameThread) = 0, SeparateThread (WebViewExecutionMode_SeparateThread) = 1,
}}
RT_ENUM! { enum WebViewPermissionState: i32 {
    Unknown (WebViewPermissionState_Unknown) = 0, Defer (WebViewPermissionState_Defer) = 1, Allow (WebViewPermissionState_Allow) = 2, Deny (WebViewPermissionState_Deny) = 3,
}}
RT_ENUM! { enum WebViewPermissionType: i32 {
    Geolocation (WebViewPermissionType_Geolocation) = 0, UnlimitedIndexedDBQuota (WebViewPermissionType_UnlimitedIndexedDBQuota) = 1, Media (WebViewPermissionType_Media) = 2, PointerLock (WebViewPermissionType_PointerLock) = 3, WebNotifications (WebViewPermissionType_WebNotifications) = 4,
}}
DEFINE_IID!(IID_CalendarViewDayItemChangingEventHandler, 2373212305, 19939, 18891, 151, 75, 8, 56, 113, 163, 175, 230);
RT_DELEGATE!{delegate CalendarViewDayItemChangingEventHandler(CalendarViewDayItemChangingEventHandlerVtbl, CalendarViewDayItemChangingEventHandlerImpl) [IID_CalendarViewDayItemChangingEventHandler] {
    fn Invoke(&self, sender: *mut CalendarView, e: *mut CalendarViewDayItemChangingEventArgs) -> HRESULT
}}
impl CalendarViewDayItemChangingEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &CalendarView, e: &CalendarViewDayItemChangingEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class CalendarViewDayItemChangingEventArgs: ICalendarViewDayItemChangingEventArgs}
DEFINE_IID!(IID_HubSectionHeaderClickEventHandler, 2950790043, 40035, 17795, 136, 228, 197, 144, 25, 183, 244, 157);
RT_DELEGATE!{delegate HubSectionHeaderClickEventHandler(HubSectionHeaderClickEventHandlerVtbl, HubSectionHeaderClickEventHandlerImpl) [IID_HubSectionHeaderClickEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut HubSectionHeaderClickEventArgs) -> HRESULT
}}
impl HubSectionHeaderClickEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &HubSectionHeaderClickEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class HubSectionHeaderClickEventArgs: IHubSectionHeaderClickEventArgs}
impl RtActivatable<IActivationFactory> for HubSectionHeaderClickEventArgs {}
DEFINE_CLSID!(HubSectionHeaderClickEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,72,117,98,83,101,99,116,105,111,110,72,101,97,100,101,114,67,108,105,99,107,69,118,101,110,116,65,114,103,115,0]) [CLSID_HubSectionHeaderClickEventArgs]);
DEFINE_IID!(IID_ListViewItemToKeyHandler, 1794497142, 32395, 19089, 154, 86, 70, 12, 180, 125, 82, 63);
RT_DELEGATE!{delegate ListViewItemToKeyHandler(ListViewItemToKeyHandlerVtbl, ListViewItemToKeyHandlerImpl) [IID_ListViewItemToKeyHandler] {
    fn Invoke(&self, item: *mut IInspectable, out: *mut HSTRING) -> HRESULT
}}
impl ListViewItemToKeyHandler {
    #[inline] pub unsafe fn invoke(&self, item: &IInspectable) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, item as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ListViewKeyToItemHandler, 654137429, 46384, 18056, 185, 240, 66, 130, 73, 23, 142, 248);
RT_DELEGATE!{delegate ListViewKeyToItemHandler(ListViewKeyToItemHandlerVtbl, ListViewKeyToItemHandlerImpl) [IID_ListViewKeyToItemHandler] {
    fn Invoke(&self, key: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<IInspectable>) -> HRESULT
}}
impl ListViewKeyToItemHandler {
    #[inline] pub unsafe fn invoke(&self, key: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<IInspectable>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, key.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_SectionsInViewChangedEventHandler, 1810672234, 25592, 18431, 182, 172, 118, 231, 218, 36, 125, 103);
RT_DELEGATE!{delegate SectionsInViewChangedEventHandler(SectionsInViewChangedEventHandlerVtbl, SectionsInViewChangedEventHandlerImpl) [IID_SectionsInViewChangedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut SectionsInViewChangedEventArgs) -> HRESULT
}}
impl SectionsInViewChangedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &SectionsInViewChangedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class SectionsInViewChangedEventArgs: ISectionsInViewChangedEventArgs}
DEFINE_IID!(IID_WebViewNavigationFailedEventHandler, 2736697313, 16860, 18424, 174, 34, 151, 6, 200, 241, 67, 212);
RT_DELEGATE!{delegate WebViewNavigationFailedEventHandler(WebViewNavigationFailedEventHandlerVtbl, WebViewNavigationFailedEventHandlerImpl) [IID_WebViewNavigationFailedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut WebViewNavigationFailedEventArgs) -> HRESULT
}}
impl WebViewNavigationFailedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &WebViewNavigationFailedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class WebViewNavigationFailedEventArgs: IWebViewNavigationFailedEventArgs}
DEFINE_IID!(IID_ICommandBarElement, 1737592347, 62165, 17617, 139, 132, 146, 184, 127, 128, 163, 80);
RT_INTERFACE!{interface ICommandBarElement(ICommandBarElementVtbl): IInspectable(IInspectableVtbl) [IID_ICommandBarElement] {
    fn get_IsCompact(&self, out: *mut bool) -> HRESULT,
    fn put_IsCompact(&self, value: bool) -> HRESULT
}}
impl ICommandBarElement {
    #[inline] pub unsafe fn get_is_compact(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCompact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_compact(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsCompact)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICommandBarElement2, 2847871542, 17410, 18056, 185, 135, 157, 43, 155, 123, 242, 189);
RT_INTERFACE!{interface ICommandBarElement2(ICommandBarElement2Vtbl): IInspectable(IInspectableVtbl) [IID_ICommandBarElement2] {
    fn get_IsInOverflow(&self, out: *mut bool) -> HRESULT,
    fn get_DynamicOverflowOrder(&self, out: *mut i32) -> HRESULT,
    fn put_DynamicOverflowOrder(&self, value: i32) -> HRESULT
}}
impl ICommandBarElement2 {
    #[inline] pub unsafe fn get_is_in_overflow(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsInOverflow)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_dynamic_overflow_order(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DynamicOverflowOrder)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_dynamic_overflow_order(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DynamicOverflowOrder)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICalendarDatePickerDateChangedEventArgs, 1624837554, 20496, 18106, 132, 45, 164, 21, 44, 101, 4, 231);
RT_INTERFACE!{interface ICalendarDatePickerDateChangedEventArgs(ICalendarDatePickerDateChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICalendarDatePickerDateChangedEventArgs] {
    fn get_NewDate(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::DateTime>) -> HRESULT,
    fn get_OldDate(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::DateTime>) -> HRESULT
}}
impl ICalendarDatePickerDateChangedEventArgs {
    #[inline] pub unsafe fn get_new_date(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NewDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_old_date(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OldDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class CalendarDatePickerDateChangedEventArgs: ICalendarDatePickerDateChangedEventArgs}
DEFINE_IID!(IID_ICalendarViewDayItemChangingEventArgs, 1930716774, 8113, 17657, 183, 173, 77, 232, 89, 236, 197, 101);
RT_INTERFACE!{interface ICalendarViewDayItemChangingEventArgs(ICalendarViewDayItemChangingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICalendarViewDayItemChangingEventArgs] {
    fn get_InRecycleQueue(&self, out: *mut bool) -> HRESULT,
    fn get_Item(&self, out: *mut *mut CalendarViewDayItem) -> HRESULT,
    fn get_Phase(&self, out: *mut u32) -> HRESULT,
    fn RegisterUpdateCallback(&self, callback: *mut ::rt::gen::windows::foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs>) -> HRESULT,
    fn RegisterUpdateCallbackWithPhase(&self, callbackPhase: u32, callback: *mut ::rt::gen::windows::foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs>) -> HRESULT
}}
impl ICalendarViewDayItemChangingEventArgs {
    #[inline] pub unsafe fn get_in_recycle_queue(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InRecycleQueue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item(&self) -> Result<ComPtr<CalendarViewDayItem>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Item)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_phase(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Phase)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn register_update_callback(&self, callback: &::rt::gen::windows::foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs>) -> Result<()> {
        let hr = ((*self.lpVtbl).RegisterUpdateCallback)(self as *const _ as *mut _, callback as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn register_update_callback_with_phase(&self, callbackPhase: u32, callback: &::rt::gen::windows::foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs>) -> Result<()> {
        let hr = ((*self.lpVtbl).RegisterUpdateCallbackWithPhase)(self as *const _ as *mut _, callbackPhase, callback as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICalendarViewSelectedDatesChangedEventArgs, 3999295990, 5103, 18582, 143, 252, 83, 2, 177, 177, 117, 57);
RT_INTERFACE!{interface ICalendarViewSelectedDatesChangedEventArgs(ICalendarViewSelectedDatesChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICalendarViewSelectedDatesChangedEventArgs] {
    fn get_AddedDates(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<::rt::gen::windows::foundation::DateTime>) -> HRESULT,
    fn get_RemovedDates(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<::rt::gen::windows::foundation::DateTime>) -> HRESULT
}}
impl ICalendarViewSelectedDatesChangedEventArgs {
    #[inline] pub unsafe fn get_added_dates(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<::rt::gen::windows::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AddedDates)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_removed_dates(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<::rt::gen::windows::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RemovedDates)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class CalendarViewSelectedDatesChangedEventArgs: ICalendarViewSelectedDatesChangedEventArgs}
DEFINE_IID!(IID_IContentDialogButtonClickDeferral, 3171759671, 6606, 18758, 142, 119, 189, 3, 254, 142, 190, 3);
RT_INTERFACE!{interface IContentDialogButtonClickDeferral(IContentDialogButtonClickDeferralVtbl): IInspectable(IInspectableVtbl) [IID_IContentDialogButtonClickDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IContentDialogButtonClickDeferral {
    #[inline] pub unsafe fn complete(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ContentDialogButtonClickDeferral: IContentDialogButtonClickDeferral}
DEFINE_IID!(IID_IContentDialogButtonClickEventArgs, 1597293061, 35578, 19698, 140, 160, 38, 77, 115, 190, 214, 61);
RT_INTERFACE!{interface IContentDialogButtonClickEventArgs(IContentDialogButtonClickEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContentDialogButtonClickEventArgs] {
    fn get_Cancel(&self, out: *mut bool) -> HRESULT,
    fn put_Cancel(&self, value: bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ContentDialogButtonClickDeferral) -> HRESULT
}}
impl IContentDialogButtonClickEventArgs {
    #[inline] pub unsafe fn get_cancel(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cancel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_cancel(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Cancel)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<ContentDialogButtonClickDeferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContentDialogButtonClickEventArgs: IContentDialogButtonClickEventArgs}
DEFINE_IID!(IID_IContentDialogClosedEventArgs, 2421498607, 11450, 19192, 182, 102, 204, 54, 194, 39, 50, 251);
RT_INTERFACE!{interface IContentDialogClosedEventArgs(IContentDialogClosedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContentDialogClosedEventArgs] {
    fn get_Result(&self, out: *mut ContentDialogResult) -> HRESULT
}}
impl IContentDialogClosedEventArgs {
    #[inline] pub unsafe fn get_result(&self) -> Result<ContentDialogResult> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Result)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class ContentDialogClosedEventArgs: IContentDialogClosedEventArgs}
DEFINE_IID!(IID_IContentDialogClosingDeferral, 559762705, 32304, 19641, 167, 16, 90, 79, 156, 202, 139, 66);
RT_INTERFACE!{interface IContentDialogClosingDeferral(IContentDialogClosingDeferralVtbl): IInspectable(IInspectableVtbl) [IID_IContentDialogClosingDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IContentDialogClosingDeferral {
    #[inline] pub unsafe fn complete(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ContentDialogClosingDeferral: IContentDialogClosingDeferral}
DEFINE_IID!(IID_IContentDialogClosingEventArgs, 3678149684, 15295, 18388, 190, 79, 201, 236, 17, 89, 24, 185);
RT_INTERFACE!{interface IContentDialogClosingEventArgs(IContentDialogClosingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContentDialogClosingEventArgs] {
    fn get_Result(&self, out: *mut ContentDialogResult) -> HRESULT,
    fn get_Cancel(&self, out: *mut bool) -> HRESULT,
    fn put_Cancel(&self, value: bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ContentDialogClosingDeferral) -> HRESULT
}}
impl IContentDialogClosingEventArgs {
    #[inline] pub unsafe fn get_result(&self) -> Result<ContentDialogResult> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Result)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_cancel(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cancel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_cancel(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Cancel)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<ContentDialogClosingDeferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContentDialogClosingEventArgs: IContentDialogClosingEventArgs}
DEFINE_IID!(IID_IContentDialogOpenedEventArgs, 157725461, 24409, 18841, 158, 62, 55, 76, 15, 23, 75, 4);
RT_INTERFACE!{interface IContentDialogOpenedEventArgs(IContentDialogOpenedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContentDialogOpenedEventArgs] {
    
}}
RT_CLASS!{class ContentDialogOpenedEventArgs: IContentDialogOpenedEventArgs}
DEFINE_IID!(IID_IDatePickerValueChangedEventArgs, 451305906, 45492, 17011, 150, 224, 25, 218, 255, 24, 116, 70);
RT_INTERFACE!{interface IDatePickerValueChangedEventArgs(IDatePickerValueChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDatePickerValueChangedEventArgs] {
    fn get_OldDate(&self, out: *mut ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn get_NewDate(&self, out: *mut ::rt::gen::windows::foundation::DateTime) -> HRESULT
}}
impl IDatePickerValueChangedEventArgs {
    #[inline] pub unsafe fn get_old_date(&self) -> Result<::rt::gen::windows::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OldDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_new_date(&self) -> Result<::rt::gen::windows::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NewDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class DatePickerValueChangedEventArgs: IDatePickerValueChangedEventArgs}
DEFINE_IID!(IID_IDynamicOverflowItemsChangingEventArgs, 3376182127, 28526, 20035, 144, 217, 155, 70, 160, 216, 139, 159);
RT_INTERFACE!{interface IDynamicOverflowItemsChangingEventArgs(IDynamicOverflowItemsChangingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDynamicOverflowItemsChangingEventArgs] {
    fn get_Action(&self, out: *mut CommandBarDynamicOverflowAction) -> HRESULT
}}
impl IDynamicOverflowItemsChangingEventArgs {
    #[inline] pub unsafe fn get_action(&self) -> Result<CommandBarDynamicOverflowAction> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Action)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class DynamicOverflowItemsChangingEventArgs: IDynamicOverflowItemsChangingEventArgs}
impl RtActivatable<IActivationFactory> for DynamicOverflowItemsChangingEventArgs {}
DEFINE_CLSID!(DynamicOverflowItemsChangingEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,68,121,110,97,109,105,99,79,118,101,114,102,108,111,119,73,116,101,109,115,67,104,97,110,103,105,110,103,69,118,101,110,116,65,114,103,115,0]) [CLSID_DynamicOverflowItemsChangingEventArgs]);
RT_CLASS!{class HubSectionCollection: ::rt::gen::windows::foundation::collections::IVector<HubSection>}
DEFINE_IID!(IID_IHubSectionHeaderClickEventArgs, 3787845380, 7901, 16658, 174, 235, 153, 108, 150, 64, 6, 152);
RT_INTERFACE!{interface IHubSectionHeaderClickEventArgs(IHubSectionHeaderClickEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IHubSectionHeaderClickEventArgs] {
    fn get_Section(&self, out: *mut *mut HubSection) -> HRESULT
}}
impl IHubSectionHeaderClickEventArgs {
    #[inline] pub unsafe fn get_section(&self) -> Result<ComPtr<HubSection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Section)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewPersistenceHelper, 96331942, 8593, 19275, 140, 34, 155, 37, 103, 110, 128, 110);
RT_INTERFACE!{interface IListViewPersistenceHelper(IListViewPersistenceHelperVtbl): IInspectable(IInspectableVtbl) [IID_IListViewPersistenceHelper] {
    
}}
DEFINE_IID!(IID_IListViewPersistenceHelperStatics, 1829513992, 48027, 17657, 128, 99, 92, 63, 156, 33, 136, 75);
RT_INTERFACE!{static interface IListViewPersistenceHelperStatics(IListViewPersistenceHelperStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IListViewPersistenceHelperStatics] {
    fn GetRelativeScrollPosition(&self, listViewBase: *mut ListViewBase, itemToKeyHandler: *mut ListViewItemToKeyHandler, out: *mut HSTRING) -> HRESULT,
    fn SetRelativeScrollPositionAsync(&self, listViewBase: *mut ListViewBase, relativeScrollPosition: HSTRING, keyToItemHandler: *mut ListViewKeyToItemHandler, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IListViewPersistenceHelperStatics {
    #[inline] pub unsafe fn get_relative_scroll_position(&self, listViewBase: &ListViewBase, itemToKeyHandler: &ListViewItemToKeyHandler) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetRelativeScrollPosition)(self as *const _ as *mut _, listViewBase as *const _ as *mut _, itemToKeyHandler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_relative_scroll_position_async(&self, listViewBase: &ListViewBase, relativeScrollPosition: &HStringArg, keyToItemHandler: &ListViewKeyToItemHandler) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SetRelativeScrollPositionAsync)(self as *const _ as *mut _, listViewBase as *const _ as *mut _, relativeScrollPosition.get(), keyToItemHandler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ListViewPersistenceHelper: IListViewPersistenceHelper}
impl RtActivatable<IListViewPersistenceHelperStatics> for ListViewPersistenceHelper {}
impl ListViewPersistenceHelper {
    #[inline] pub fn get_relative_scroll_position(listViewBase: &ListViewBase, itemToKeyHandler: &ListViewItemToKeyHandler) -> Result<HString> { unsafe {
        <Self as RtActivatable<IListViewPersistenceHelperStatics>>::get_activation_factory().get_relative_scroll_position(listViewBase, itemToKeyHandler)
    }}
    #[inline] pub fn set_relative_scroll_position_async(listViewBase: &ListViewBase, relativeScrollPosition: &HStringArg, keyToItemHandler: &ListViewKeyToItemHandler) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<IListViewPersistenceHelperStatics>>::get_activation_factory().set_relative_scroll_position_async(listViewBase, relativeScrollPosition, keyToItemHandler)
    }}
}
DEFINE_CLSID!(ListViewPersistenceHelper(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,76,105,115,116,86,105,101,119,80,101,114,115,105,115,116,101,110,99,101,72,101,108,112,101,114,0]) [CLSID_ListViewPersistenceHelper]);
DEFINE_IID!(IID_IRichEditBoxTextChangingEventArgs, 1409699864, 10259, 18722, 159, 142, 182, 187, 175, 217, 149, 216);
RT_INTERFACE!{interface IRichEditBoxTextChangingEventArgs(IRichEditBoxTextChangingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IRichEditBoxTextChangingEventArgs] {
    
}}
DEFINE_IID!(IID_IRichEditBoxTextChangingEventArgs2, 962268597, 25454, 16702, 158, 180, 252, 34, 235, 250, 54, 40);
RT_INTERFACE!{interface IRichEditBoxTextChangingEventArgs2(IRichEditBoxTextChangingEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IRichEditBoxTextChangingEventArgs2] {
    fn get_IsContentChanging(&self, out: *mut bool) -> HRESULT
}}
impl IRichEditBoxTextChangingEventArgs2 {
    #[inline] pub unsafe fn get_is_content_changing(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsContentChanging)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class RichEditBoxTextChangingEventArgs: IRichEditBoxTextChangingEventArgs}
DEFINE_IID!(IID_IScrollViewerView, 1693040129, 19906, 18750, 171, 232, 203, 211, 197, 119, 73, 14);
RT_INTERFACE!{interface IScrollViewerView(IScrollViewerViewVtbl): IInspectable(IInspectableVtbl) [IID_IScrollViewerView] {
    fn get_HorizontalOffset(&self, out: *mut f64) -> HRESULT,
    fn get_VerticalOffset(&self, out: *mut f64) -> HRESULT,
    fn get_ZoomFactor(&self, out: *mut f32) -> HRESULT
}}
impl IScrollViewerView {
    #[inline] pub unsafe fn get_horizontal_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoom_factor(&self) -> Result<f32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ZoomFactor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class ScrollViewerView: IScrollViewerView}
DEFINE_IID!(IID_IScrollViewerViewChangedEventArgs, 1305497470, 31249, 19246, 153, 51, 87, 125, 243, 146, 82, 182);
RT_INTERFACE!{interface IScrollViewerViewChangedEventArgs(IScrollViewerViewChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IScrollViewerViewChangedEventArgs] {
    fn get_IsIntermediate(&self, out: *mut bool) -> HRESULT
}}
impl IScrollViewerViewChangedEventArgs {
    #[inline] pub unsafe fn get_is_intermediate(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsIntermediate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class ScrollViewerViewChangedEventArgs: IScrollViewerViewChangedEventArgs}
impl RtActivatable<IActivationFactory> for ScrollViewerViewChangedEventArgs {}
DEFINE_CLSID!(ScrollViewerViewChangedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,83,99,114,111,108,108,86,105,101,119,101,114,86,105,101,119,67,104,97,110,103,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_ScrollViewerViewChangedEventArgs]);
DEFINE_IID!(IID_IScrollViewerViewChangingEventArgs, 1305497471, 31249, 19246, 153, 51, 87, 125, 243, 146, 82, 182);
RT_INTERFACE!{interface IScrollViewerViewChangingEventArgs(IScrollViewerViewChangingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IScrollViewerViewChangingEventArgs] {
    fn get_NextView(&self, out: *mut *mut ScrollViewerView) -> HRESULT,
    fn get_FinalView(&self, out: *mut *mut ScrollViewerView) -> HRESULT,
    fn get_IsInertial(&self, out: *mut bool) -> HRESULT
}}
impl IScrollViewerViewChangingEventArgs {
    #[inline] pub unsafe fn get_next_view(&self) -> Result<ComPtr<ScrollViewerView>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NextView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_final_view(&self) -> Result<ComPtr<ScrollViewerView>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FinalView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_inertial(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsInertial)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class ScrollViewerViewChangingEventArgs: IScrollViewerViewChangingEventArgs}
DEFINE_IID!(IID_ISearchBoxQueryChangedEventArgs, 2846297999, 3248, 19410, 153, 152, 47, 181, 122, 213, 231, 49);
RT_INTERFACE!{interface ISearchBoxQueryChangedEventArgs(ISearchBoxQueryChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISearchBoxQueryChangedEventArgs] {
    fn get_QueryText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(feature="windows-applicationmodel")] fn get_LinguisticDetails(&self, out: *mut *mut ::rt::gen::windows::applicationmodel::search::SearchQueryLinguisticDetails) -> HRESULT
}}
impl ISearchBoxQueryChangedEventArgs {
    #[inline] pub unsafe fn get_query_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_QueryText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_language(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Language)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn get_linguistic_details(&self) -> Result<ComPtr<::rt::gen::windows::applicationmodel::search::SearchQueryLinguisticDetails>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LinguisticDetails)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SearchBoxQueryChangedEventArgs: ISearchBoxQueryChangedEventArgs}
DEFINE_IID!(IID_ISearchBoxQuerySubmittedEventArgs, 309235965, 15438, 19659, 154, 239, 71, 5, 209, 159, 229, 72);
RT_INTERFACE!{interface ISearchBoxQuerySubmittedEventArgs(ISearchBoxQuerySubmittedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISearchBoxQuerySubmittedEventArgs] {
    fn get_QueryText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-applicationmodel"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-applicationmodel")] fn get_LinguisticDetails(&self, out: *mut *mut ::rt::gen::windows::applicationmodel::search::SearchQueryLinguisticDetails) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_KeyModifiers(&self, out: *mut ::rt::gen::windows::system::VirtualKeyModifiers) -> HRESULT
}}
impl ISearchBoxQuerySubmittedEventArgs {
    #[inline] pub unsafe fn get_query_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_QueryText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_language(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Language)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn get_linguistic_details(&self) -> Result<ComPtr<::rt::gen::windows::applicationmodel::search::SearchQueryLinguisticDetails>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LinguisticDetails)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_key_modifiers(&self) -> Result<::rt::gen::windows::system::VirtualKeyModifiers> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeyModifiers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class SearchBoxQuerySubmittedEventArgs: ISearchBoxQuerySubmittedEventArgs}
DEFINE_IID!(IID_ISearchBoxResultSuggestionChosenEventArgs, 412191779, 58563, 18018, 160, 59, 208, 84, 255, 208, 249, 5);
RT_INTERFACE!{interface ISearchBoxResultSuggestionChosenEventArgs(ISearchBoxResultSuggestionChosenEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISearchBoxResultSuggestionChosenEventArgs] {
    fn get_Tag(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_KeyModifiers(&self, out: *mut ::rt::gen::windows::system::VirtualKeyModifiers) -> HRESULT
}}
impl ISearchBoxResultSuggestionChosenEventArgs {
    #[inline] pub unsafe fn get_tag(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Tag)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_key_modifiers(&self) -> Result<::rt::gen::windows::system::VirtualKeyModifiers> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeyModifiers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class SearchBoxResultSuggestionChosenEventArgs: ISearchBoxResultSuggestionChosenEventArgs}
impl RtActivatable<IActivationFactory> for SearchBoxResultSuggestionChosenEventArgs {}
DEFINE_CLSID!(SearchBoxResultSuggestionChosenEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,83,101,97,114,99,104,66,111,120,82,101,115,117,108,116,83,117,103,103,101,115,116,105,111,110,67,104,111,115,101,110,69,118,101,110,116,65,114,103,115,0]) [CLSID_SearchBoxResultSuggestionChosenEventArgs]);
DEFINE_IID!(IID_ISearchBoxSuggestionsRequestedEventArgs, 3658815246, 58726, 18635, 189, 17, 254, 75, 15, 48, 164, 77);
RT_INTERFACE!{interface ISearchBoxSuggestionsRequestedEventArgs(ISearchBoxSuggestionsRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISearchBoxSuggestionsRequestedEventArgs] {
    fn get_QueryText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(feature="windows-applicationmodel")] fn get_LinguisticDetails(&self, out: *mut *mut ::rt::gen::windows::applicationmodel::search::SearchQueryLinguisticDetails) -> HRESULT,
    #[cfg(feature="windows-applicationmodel")] fn get_Request(&self, out: *mut *mut ::rt::gen::windows::applicationmodel::search::SearchSuggestionsRequest) -> HRESULT
}}
impl ISearchBoxSuggestionsRequestedEventArgs {
    #[inline] pub unsafe fn get_query_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_QueryText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_language(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Language)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn get_linguistic_details(&self) -> Result<ComPtr<::rt::gen::windows::applicationmodel::search::SearchQueryLinguisticDetails>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LinguisticDetails)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<::rt::gen::windows::applicationmodel::search::SearchSuggestionsRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SearchBoxSuggestionsRequestedEventArgs: ISearchBoxSuggestionsRequestedEventArgs}
DEFINE_IID!(IID_ISectionsInViewChangedEventArgs, 3712609899, 53605, 17167, 163, 125, 184, 7, 6, 79, 133, 225);
RT_INTERFACE!{interface ISectionsInViewChangedEventArgs(ISectionsInViewChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISectionsInViewChangedEventArgs] {
    fn get_AddedSections(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<HubSection>) -> HRESULT,
    fn get_RemovedSections(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<HubSection>) -> HRESULT
}}
impl ISectionsInViewChangedEventArgs {
    #[inline] pub unsafe fn get_added_sections(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<HubSection>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AddedSections)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_removed_sections(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<HubSection>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RemovedSections)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISectionsInViewChangedEventArgsFactory, 1434407492, 37624, 16720, 183, 48, 230, 52, 110, 143, 80, 209);
RT_INTERFACE!{interface ISectionsInViewChangedEventArgsFactory(ISectionsInViewChangedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISectionsInViewChangedEventArgsFactory] {
    
}}
DEFINE_IID!(IID_ISplitViewPaneClosingEventArgs, 2479835470, 31381, 17624, 149, 98, 27, 52, 130, 72, 218, 159);
RT_INTERFACE!{interface ISplitViewPaneClosingEventArgs(ISplitViewPaneClosingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISplitViewPaneClosingEventArgs] {
    fn get_Cancel(&self, out: *mut bool) -> HRESULT,
    fn put_Cancel(&self, value: bool) -> HRESULT
}}
impl ISplitViewPaneClosingEventArgs {
    #[inline] pub unsafe fn get_cancel(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cancel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_cancel(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Cancel)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class SplitViewPaneClosingEventArgs: ISplitViewPaneClosingEventArgs}
DEFINE_IID!(IID_ITimePickerValueChangedEventArgs, 793697165, 47509, 20017, 139, 169, 196, 220, 222, 178, 28, 163);
RT_INTERFACE!{interface ITimePickerValueChangedEventArgs(ITimePickerValueChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ITimePickerValueChangedEventArgs] {
    fn get_OldTime(&self, out: *mut ::rt::gen::windows::foundation::TimeSpan) -> HRESULT,
    fn get_NewTime(&self, out: *mut ::rt::gen::windows::foundation::TimeSpan) -> HRESULT
}}
impl ITimePickerValueChangedEventArgs {
    #[inline] pub unsafe fn get_old_time(&self) -> Result<::rt::gen::windows::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OldTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_new_time(&self) -> Result<::rt::gen::windows::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NewTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class TimePickerValueChangedEventArgs: ITimePickerValueChangedEventArgs}
DEFINE_IID!(IID_IWebViewContentLoadingEventArgs, 1848213691, 39096, 16702, 129, 41, 151, 28, 111, 126, 76, 138);
RT_INTERFACE!{interface IWebViewContentLoadingEventArgs(IWebViewContentLoadingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWebViewContentLoadingEventArgs] {
    fn get_Uri(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT
}}
impl IWebViewContentLoadingEventArgs {
    #[inline] pub unsafe fn get_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class WebViewContentLoadingEventArgs: IWebViewContentLoadingEventArgs}
DEFINE_IID!(IID_IWebViewDeferredPermissionRequest, 2749154401, 29520, 19770, 143, 185, 64, 238, 236, 39, 70, 194);
RT_INTERFACE!{interface IWebViewDeferredPermissionRequest(IWebViewDeferredPermissionRequestVtbl): IInspectable(IInspectableVtbl) [IID_IWebViewDeferredPermissionRequest] {
    fn get_Uri(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn get_PermissionType(&self, out: *mut WebViewPermissionType) -> HRESULT,
    fn get_Id(&self, out: *mut u32) -> HRESULT,
    fn Allow(&self) -> HRESULT,
    fn Deny(&self) -> HRESULT
}}
impl IWebViewDeferredPermissionRequest {
    #[inline] pub unsafe fn get_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_permission_type(&self) -> Result<WebViewPermissionType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PermissionType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_id(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn allow(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Allow)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn deny(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Deny)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class WebViewDeferredPermissionRequest: IWebViewDeferredPermissionRequest}
DEFINE_IID!(IID_IWebViewDOMContentLoadedEventArgs, 3296639509, 56427, 19254, 157, 128, 130, 251, 136, 23, 185, 136);
RT_INTERFACE!{interface IWebViewDOMContentLoadedEventArgs(IWebViewDOMContentLoadedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWebViewDOMContentLoadedEventArgs] {
    fn get_Uri(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT
}}
impl IWebViewDOMContentLoadedEventArgs {
    #[inline] pub unsafe fn get_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class WebViewDOMContentLoadedEventArgs: IWebViewDOMContentLoadedEventArgs}
DEFINE_IID!(IID_IWebViewLongRunningScriptDetectedEventArgs, 4092600491, 42092, 17072, 158, 254, 105, 118, 77, 92, 255, 166);
RT_INTERFACE!{interface IWebViewLongRunningScriptDetectedEventArgs(IWebViewLongRunningScriptDetectedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWebViewLongRunningScriptDetectedEventArgs] {
    fn get_ExecutionTime(&self, out: *mut ::rt::gen::windows::foundation::TimeSpan) -> HRESULT,
    fn get_StopPageScriptExecution(&self, out: *mut bool) -> HRESULT,
    fn put_StopPageScriptExecution(&self, value: bool) -> HRESULT
}}
impl IWebViewLongRunningScriptDetectedEventArgs {
    #[inline] pub unsafe fn get_execution_time(&self) -> Result<::rt::gen::windows::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExecutionTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stop_page_script_execution(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StopPageScriptExecution)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stop_page_script_execution(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StopPageScriptExecution)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class WebViewLongRunningScriptDetectedEventArgs: IWebViewLongRunningScriptDetectedEventArgs}
DEFINE_IID!(IID_IWebViewNavigationCompletedEventArgs, 300347915, 60327, 17600, 136, 155, 237, 235, 106, 6, 77, 221);
RT_INTERFACE!{interface IWebViewNavigationCompletedEventArgs(IWebViewNavigationCompletedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWebViewNavigationCompletedEventArgs] {
    fn get_Uri(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn get_IsSuccess(&self, out: *mut bool) -> HRESULT,
    #[cfg(feature="windows-web")] fn get_WebErrorStatus(&self, out: *mut ::rt::gen::windows::web::WebErrorStatus) -> HRESULT
}}
impl IWebViewNavigationCompletedEventArgs {
    #[inline] pub unsafe fn get_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_success(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSuccess)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-web")] #[inline] pub unsafe fn get_web_error_status(&self) -> Result<::rt::gen::windows::web::WebErrorStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_WebErrorStatus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class WebViewNavigationCompletedEventArgs: IWebViewNavigationCompletedEventArgs}
DEFINE_IID!(IID_IWebViewNavigationFailedEventArgs, 2936627354, 4764, 16752, 158, 156, 226, 205, 240, 37, 220, 164);
RT_INTERFACE!{interface IWebViewNavigationFailedEventArgs(IWebViewNavigationFailedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWebViewNavigationFailedEventArgs] {
    fn get_Uri(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    #[cfg(feature="windows-web")] fn get_WebErrorStatus(&self, out: *mut ::rt::gen::windows::web::WebErrorStatus) -> HRESULT
}}
impl IWebViewNavigationFailedEventArgs {
    #[inline] pub unsafe fn get_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-web")] #[inline] pub unsafe fn get_web_error_status(&self) -> Result<::rt::gen::windows::web::WebErrorStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_WebErrorStatus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWebViewNavigationStartingEventArgs, 2496366184, 33639, 17365, 145, 187, 150, 235, 163, 126, 199, 132);
RT_INTERFACE!{interface IWebViewNavigationStartingEventArgs(IWebViewNavigationStartingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWebViewNavigationStartingEventArgs] {
    fn get_Uri(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn get_Cancel(&self, out: *mut bool) -> HRESULT,
    fn put_Cancel(&self, value: bool) -> HRESULT
}}
impl IWebViewNavigationStartingEventArgs {
    #[inline] pub unsafe fn get_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_cancel(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cancel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_cancel(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Cancel)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class WebViewNavigationStartingEventArgs: IWebViewNavigationStartingEventArgs}
DEFINE_IID!(IID_IWebViewNewWindowRequestedEventArgs, 1192208408, 26722, 17625, 179, 209, 192, 105, 99, 115, 222, 53);
RT_INTERFACE!{interface IWebViewNewWindowRequestedEventArgs(IWebViewNewWindowRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWebViewNewWindowRequestedEventArgs] {
    fn get_Uri(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn get_Referrer(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT
}}
impl IWebViewNewWindowRequestedEventArgs {
    #[inline] pub unsafe fn get_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_referrer(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Referrer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class WebViewNewWindowRequestedEventArgs: IWebViewNewWindowRequestedEventArgs}
DEFINE_IID!(IID_IWebViewPermissionRequest, 397894450, 26308, 16689, 153, 158, 223, 125, 226, 10, 140, 156);
RT_INTERFACE!{interface IWebViewPermissionRequest(IWebViewPermissionRequestVtbl): IInspectable(IInspectableVtbl) [IID_IWebViewPermissionRequest] {
    fn get_Uri(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn get_PermissionType(&self, out: *mut WebViewPermissionType) -> HRESULT,
    fn get_Id(&self, out: *mut u32) -> HRESULT,
    fn get_State(&self, out: *mut WebViewPermissionState) -> HRESULT,
    fn Defer(&self) -> HRESULT,
    fn Allow(&self) -> HRESULT,
    fn Deny(&self) -> HRESULT
}}
impl IWebViewPermissionRequest {
    #[inline] pub unsafe fn get_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_permission_type(&self) -> Result<WebViewPermissionType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PermissionType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_id(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_state(&self) -> Result<WebViewPermissionState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_State)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn defer(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Defer)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn allow(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Allow)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn deny(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Deny)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class WebViewPermissionRequest: IWebViewPermissionRequest}
DEFINE_IID!(IID_IWebViewPermissionRequestedEventArgs, 3672035280, 28190, 18239, 176, 190, 176, 36, 4, 214, 168, 109);
RT_INTERFACE!{interface IWebViewPermissionRequestedEventArgs(IWebViewPermissionRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWebViewPermissionRequestedEventArgs] {
    fn get_PermissionRequest(&self, out: *mut *mut WebViewPermissionRequest) -> HRESULT
}}
impl IWebViewPermissionRequestedEventArgs {
    #[inline] pub unsafe fn get_permission_request(&self) -> Result<ComPtr<WebViewPermissionRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PermissionRequest)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class WebViewPermissionRequestedEventArgs: IWebViewPermissionRequestedEventArgs}
DEFINE_IID!(IID_IWebViewSettings, 491826509, 44022, 18309, 141, 243, 253, 235, 193, 39, 3, 1);
RT_INTERFACE!{interface IWebViewSettings(IWebViewSettingsVtbl): IInspectable(IInspectableVtbl) [IID_IWebViewSettings] {
    fn get_IsJavaScriptEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsJavaScriptEnabled(&self, value: bool) -> HRESULT,
    fn get_IsIndexedDBEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsIndexedDBEnabled(&self, value: bool) -> HRESULT
}}
impl IWebViewSettings {
    #[inline] pub unsafe fn get_is_java_script_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsJavaScriptEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_java_script_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsJavaScriptEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_indexed_dbenabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsIndexedDBEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_indexed_dbenabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsIndexedDBEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class WebViewSettings: IWebViewSettings}
DEFINE_IID!(IID_IWebViewUnsupportedUriSchemeIdentifiedEventArgs, 3117015463, 25103, 18581, 147, 93, 16, 251, 172, 111, 210, 158);
RT_INTERFACE!{interface IWebViewUnsupportedUriSchemeIdentifiedEventArgs(IWebViewUnsupportedUriSchemeIdentifiedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWebViewUnsupportedUriSchemeIdentifiedEventArgs] {
    fn get_Uri(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT
}}
impl IWebViewUnsupportedUriSchemeIdentifiedEventArgs {
    #[inline] pub unsafe fn get_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class WebViewUnsupportedUriSchemeIdentifiedEventArgs: IWebViewUnsupportedUriSchemeIdentifiedEventArgs}
DEFINE_IID!(IID_IWebViewUnviewableContentIdentifiedEventArgs, 935073505, 24674, 18040, 178, 11, 108, 54, 172, 156, 89, 172);
RT_INTERFACE!{interface IWebViewUnviewableContentIdentifiedEventArgs(IWebViewUnviewableContentIdentifiedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWebViewUnviewableContentIdentifiedEventArgs] {
    fn get_Uri(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn get_Referrer(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT
}}
impl IWebViewUnviewableContentIdentifiedEventArgs {
    #[inline] pub unsafe fn get_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_referrer(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Referrer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWebViewUnviewableContentIdentifiedEventArgs2, 2596147540, 14064, 17000, 141, 136, 18, 30, 237, 244, 94, 106);
RT_INTERFACE!{interface IWebViewUnviewableContentIdentifiedEventArgs2(IWebViewUnviewableContentIdentifiedEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IWebViewUnviewableContentIdentifiedEventArgs2] {
    fn get_MediaType(&self, out: *mut HSTRING) -> HRESULT
}}
impl IWebViewUnviewableContentIdentifiedEventArgs2 {
    #[inline] pub unsafe fn get_media_type(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MediaType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class WebViewUnviewableContentIdentifiedEventArgs: IWebViewUnviewableContentIdentifiedEventArgs}
DEFINE_IID!(IID_IAutoSuggestBoxQuerySubmittedEventArgs, 2027729174, 33162, 19637, 188, 167, 56, 44, 230, 221, 201, 13);
RT_INTERFACE!{interface IAutoSuggestBoxQuerySubmittedEventArgs(IAutoSuggestBoxQuerySubmittedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAutoSuggestBoxQuerySubmittedEventArgs] {
    fn get_QueryText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ChosenSuggestion(&self, out: *mut *mut IInspectable) -> HRESULT
}}
impl IAutoSuggestBoxQuerySubmittedEventArgs {
    #[inline] pub unsafe fn get_query_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_QueryText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_chosen_suggestion(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ChosenSuggestion)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutoSuggestBoxSuggestionChosenEventArgs, 963605076, 7893, 19397, 160, 96, 101, 85, 48, 188, 166, 186);
RT_INTERFACE!{interface IAutoSuggestBoxSuggestionChosenEventArgs(IAutoSuggestBoxSuggestionChosenEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAutoSuggestBoxSuggestionChosenEventArgs] {
    fn get_SelectedItem(&self, out: *mut *mut IInspectable) -> HRESULT
}}
impl IAutoSuggestBoxSuggestionChosenEventArgs {
    #[inline] pub unsafe fn get_selected_item(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedItem)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutoSuggestBoxTextChangedEventArgs, 980382292, 7893, 19397, 160, 96, 101, 85, 48, 188, 166, 186);
RT_INTERFACE!{interface IAutoSuggestBoxTextChangedEventArgs(IAutoSuggestBoxTextChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAutoSuggestBoxTextChangedEventArgs] {
    fn get_Reason(&self, out: *mut AutoSuggestionBoxTextChangeReason) -> HRESULT,
    fn put_Reason(&self, value: AutoSuggestionBoxTextChangeReason) -> HRESULT,
    fn CheckCurrent(&self, out: *mut bool) -> HRESULT
}}
impl IAutoSuggestBoxTextChangedEventArgs {
    #[inline] pub unsafe fn get_reason(&self) -> Result<AutoSuggestionBoxTextChangeReason> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Reason)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_reason(&self, value: AutoSuggestionBoxTextChangeReason) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Reason)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn check_current(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).CheckCurrent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutoSuggestBoxTextChangedEventArgsStatics, 4277630763, 40773, 17627, 140, 39, 189, 163, 249, 51, 231, 181);
RT_INTERFACE!{static interface IAutoSuggestBoxTextChangedEventArgsStatics(IAutoSuggestBoxTextChangedEventArgsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAutoSuggestBoxTextChangedEventArgsStatics] {
    fn get_ReasonProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IAutoSuggestBoxTextChangedEventArgsStatics {
    #[inline] pub unsafe fn get_reason_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ReasonProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFlyout, 1703209951, 52167, 19993, 132, 58, 161, 79, 36, 167, 147, 234);
RT_INTERFACE!{interface IFlyout(IFlyoutVtbl): IInspectable(IInspectableVtbl) [IID_IFlyout] {
    fn get_Content(&self, out: *mut *mut super::UIElement) -> HRESULT,
    fn put_Content(&self, value: *mut super::UIElement) -> HRESULT,
    fn get_FlyoutPresenterStyle(&self, out: *mut *mut super::Style) -> HRESULT,
    fn put_FlyoutPresenterStyle(&self, value: *mut super::Style) -> HRESULT
}}
impl IFlyout {
    #[inline] pub unsafe fn get_content(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Content)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content(&self, value: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Content)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_flyout_presenter_style(&self) -> Result<ComPtr<super::Style>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FlyoutPresenterStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_flyout_presenter_style(&self, value: &super::Style) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FlyoutPresenterStyle)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFlyoutStatics, 1630948875, 56181, 18401, 178, 195, 91, 144, 28, 61, 116, 182);
RT_INTERFACE!{static interface IFlyoutStatics(IFlyoutStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IFlyoutStatics] {
    fn get_ContentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FlyoutPresenterStyleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IFlyoutStatics {
    #[inline] pub unsafe fn get_content_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_flyout_presenter_style_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FlyoutPresenterStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFlyoutFactory, 1273841971, 142, 19203, 163, 133, 121, 254, 82, 102, 221, 186);
RT_INTERFACE!{interface IFlyoutFactory(IFlyoutFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IFlyoutFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut Flyout) -> HRESULT
}}
impl IFlyoutFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<Flyout>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMenuFlyout, 2905739505, 39003, 16753, 187, 186, 103, 188, 199, 41, 100, 155);
RT_INTERFACE!{interface IMenuFlyout(IMenuFlyoutVtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyout] {
    fn get_Items(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<MenuFlyoutItemBase>) -> HRESULT,
    fn get_MenuFlyoutPresenterStyle(&self, out: *mut *mut super::Style) -> HRESULT,
    fn put_MenuFlyoutPresenterStyle(&self, value: *mut super::Style) -> HRESULT
}}
impl IMenuFlyout {
    #[inline] pub unsafe fn get_items(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<MenuFlyoutItemBase>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Items)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_menu_flyout_presenter_style(&self) -> Result<ComPtr<super::Style>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MenuFlyoutPresenterStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_menu_flyout_presenter_style(&self, value: &super::Style) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MenuFlyoutPresenterStyle)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMenuFlyoutStatics, 1035926433, 38178, 16453, 158, 88, 201, 155, 19, 170, 185, 185);
RT_INTERFACE!{static interface IMenuFlyoutStatics(IMenuFlyoutStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutStatics] {
    fn get_MenuFlyoutPresenterStyleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IMenuFlyoutStatics {
    #[inline] pub unsafe fn get_menu_flyout_presenter_style_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MenuFlyoutPresenterStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMenuFlyoutFactory, 1682256811, 48057, 18843, 159, 243, 48, 212, 14, 44, 86, 216);
RT_INTERFACE!{interface IMenuFlyoutFactory(IMenuFlyoutFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut MenuFlyout) -> HRESULT
}}
impl IMenuFlyoutFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<MenuFlyout>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMenuFlyout2, 1350335405, 55761, 19461, 157, 75, 205, 168, 222, 154, 178, 66);
RT_INTERFACE!{interface IMenuFlyout2(IMenuFlyout2Vtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyout2] {
    fn ShowAt(&self, targetElement: *mut super::UIElement, point: ::rt::gen::windows::foundation::Point) -> HRESULT
}}
impl IMenuFlyout2 {
    #[inline] pub unsafe fn show_at(&self, targetElement: &super::UIElement, point: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).ShowAt)(self as *const _ as *mut _, targetElement as *const _ as *mut _, point);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IIconElement, 2599452731, 53324, 18042, 187, 213, 155, 129, 240, 45, 154, 86);
RT_INTERFACE!{interface IIconElement(IIconElementVtbl): IInspectable(IInspectableVtbl) [IID_IIconElement] {
    fn get_Foreground(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_Foreground(&self, value: *mut super::media::Brush) -> HRESULT
}}
impl IIconElement {
    #[inline] pub unsafe fn get_foreground(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Foreground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_foreground(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Foreground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IIconElementStatics, 3189351971, 30671, 18223, 130, 234, 4, 120, 1, 209, 32, 18);
RT_INTERFACE!{static interface IIconElementStatics(IIconElementStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IIconElementStatics] {
    fn get_ForegroundProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IIconElementStatics {
    #[inline] pub unsafe fn get_foreground_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ForegroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IIconElementFactory, 3476530530, 1060, 17351, 139, 234, 114, 15, 186, 151, 62, 241);
RT_INTERFACE!{interface IIconElementFactory(IIconElementFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IIconElementFactory] {
    
}}
DEFINE_IID!(IID_IInkCanvas, 692337704, 36424, 20424, 164, 115, 53, 176, 186, 18, 172, 234);
RT_INTERFACE!{interface IInkCanvas(IInkCanvasVtbl): IInspectable(IInspectableVtbl) [IID_IInkCanvas] {
    #[cfg(feature="windows-ui")] fn get_InkPresenter(&self, out: *mut *mut super::super::input::inking::InkPresenter) -> HRESULT
}}
impl IInkCanvas {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_ink_presenter(&self) -> Result<ComPtr<super::super::input::inking::InkPresenter>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InkPresenter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkCanvasFactory, 2454373086, 43780, 18672, 150, 83, 224, 242, 218, 77, 191, 26);
RT_INTERFACE!{interface IInkCanvasFactory(IInkCanvasFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInkCanvasFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut InkCanvas) -> HRESULT
}}
impl IInkCanvasFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<InkCanvas>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMediaElement, 2744046287, 5086, 17049, 173, 226, 174, 24, 247, 78, 211, 83);
RT_INTERFACE!{interface IMediaElement(IMediaElementVtbl): IInspectable(IInspectableVtbl) [IID_IMediaElement] {
    fn get_PosterSource(&self, out: *mut *mut super::media::ImageSource) -> HRESULT,
    fn put_PosterSource(&self, value: *mut super::media::ImageSource) -> HRESULT,
    fn get_Source(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn put_Source(&self, value: *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn get_IsMuted(&self, out: *mut bool) -> HRESULT,
    fn put_IsMuted(&self, value: bool) -> HRESULT,
    fn get_IsAudioOnly(&self, out: *mut bool) -> HRESULT,
    fn get_AutoPlay(&self, out: *mut bool) -> HRESULT,
    fn put_AutoPlay(&self, value: bool) -> HRESULT,
    fn get_Volume(&self, out: *mut f64) -> HRESULT,
    fn put_Volume(&self, value: f64) -> HRESULT,
    fn get_Balance(&self, out: *mut f64) -> HRESULT,
    fn put_Balance(&self, value: f64) -> HRESULT,
    fn get_NaturalVideoHeight(&self, out: *mut i32) -> HRESULT,
    fn get_NaturalVideoWidth(&self, out: *mut i32) -> HRESULT,
    fn get_NaturalDuration(&self, out: *mut super::Duration) -> HRESULT,
    fn get_Position(&self, out: *mut ::rt::gen::windows::foundation::TimeSpan) -> HRESULT,
    fn put_Position(&self, value: ::rt::gen::windows::foundation::TimeSpan) -> HRESULT,
    fn get_DownloadProgress(&self, out: *mut f64) -> HRESULT,
    fn get_BufferingProgress(&self, out: *mut f64) -> HRESULT,
    fn get_DownloadProgressOffset(&self, out: *mut f64) -> HRESULT,
    fn get_CurrentState(&self, out: *mut super::media::MediaElementState) -> HRESULT,
    fn get_Markers(&self, out: *mut *mut super::media::TimelineMarkerCollection) -> HRESULT,
    fn get_CanSeek(&self, out: *mut bool) -> HRESULT,
    fn get_CanPause(&self, out: *mut bool) -> HRESULT,
    fn get_AudioStreamCount(&self, out: *mut i32) -> HRESULT,
    fn get_AudioStreamIndex(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<i32>) -> HRESULT,
    fn put_AudioStreamIndex(&self, value: *mut ::rt::gen::windows::foundation::IReference<i32>) -> HRESULT,
    fn get_PlaybackRate(&self, out: *mut f64) -> HRESULT,
    fn put_PlaybackRate(&self, value: f64) -> HRESULT,
    fn get_IsLooping(&self, out: *mut bool) -> HRESULT,
    fn put_IsLooping(&self, value: bool) -> HRESULT,
    #[cfg(not(feature="windows-media"))] fn __Dummy32(&self) -> (),
    #[cfg(feature="windows-media")] fn get_PlayToSource(&self, out: *mut *mut ::rt::gen::windows::media::playto::PlayToSource) -> HRESULT,
    fn get_DefaultPlaybackRate(&self, out: *mut f64) -> HRESULT,
    fn put_DefaultPlaybackRate(&self, value: f64) -> HRESULT,
    fn get_AspectRatioWidth(&self, out: *mut i32) -> HRESULT,
    fn get_AspectRatioHeight(&self, out: *mut i32) -> HRESULT,
    fn get_RealTimePlayback(&self, out: *mut bool) -> HRESULT,
    fn put_RealTimePlayback(&self, value: bool) -> HRESULT,
    fn get_AudioCategory(&self, out: *mut super::media::AudioCategory) -> HRESULT,
    fn put_AudioCategory(&self, value: super::media::AudioCategory) -> HRESULT,
    fn get_AudioDeviceType(&self, out: *mut super::media::AudioDeviceType) -> HRESULT,
    fn put_AudioDeviceType(&self, value: super::media::AudioDeviceType) -> HRESULT,
    #[cfg(not(feature="windows-media"))] fn __Dummy43(&self) -> (),
    #[cfg(feature="windows-media")] fn get_ProtectionManager(&self, out: *mut *mut ::rt::gen::windows::media::protection::MediaProtectionManager) -> HRESULT,
    #[cfg(not(feature="windows-media"))] fn __Dummy44(&self) -> (),
    #[cfg(feature="windows-media")] fn put_ProtectionManager(&self, value: *mut ::rt::gen::windows::media::protection::MediaProtectionManager) -> HRESULT,
    fn get_Stereo3DVideoPackingMode(&self, out: *mut super::media::Stereo3DVideoPackingMode) -> HRESULT,
    fn put_Stereo3DVideoPackingMode(&self, value: super::media::Stereo3DVideoPackingMode) -> HRESULT,
    fn get_Stereo3DVideoRenderMode(&self, out: *mut super::media::Stereo3DVideoRenderMode) -> HRESULT,
    fn put_Stereo3DVideoRenderMode(&self, value: super::media::Stereo3DVideoRenderMode) -> HRESULT,
    fn get_IsStereo3DVideo(&self, out: *mut bool) -> HRESULT,
    fn add_MediaOpened(&self, value: *mut super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MediaOpened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_MediaEnded(&self, value: *mut super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MediaEnded(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_MediaFailed(&self, value: *mut super::ExceptionRoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MediaFailed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_DownloadProgressChanged(&self, value: *mut super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DownloadProgressChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_BufferingProgressChanged(&self, value: *mut super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BufferingProgressChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_CurrentStateChanged(&self, value: *mut super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CurrentStateChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_MarkerReached(&self, value: *mut super::media::TimelineMarkerRoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MarkerReached(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_RateChanged(&self, value: *mut super::media::RateChangedRoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RateChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_VolumeChanged(&self, value: *mut super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VolumeChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_SeekCompleted(&self, value: *mut super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SeekCompleted(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn Play(&self) -> HRESULT,
    fn Pause(&self) -> HRESULT,
    fn CanPlayType(&self, type_: HSTRING, out: *mut super::media::MediaCanPlayResponse) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy74(&self) -> (),
    #[cfg(feature="windows-storage")] fn SetSource(&self, stream: *mut ::rt::gen::windows::storage::streams::IRandomAccessStream, mimeType: HSTRING) -> HRESULT,
    fn GetAudioStreamLanguage(&self, index: *mut ::rt::gen::windows::foundation::IReference<i32>, out: *mut HSTRING) -> HRESULT,
    fn AddAudioEffect(&self, effectID: HSTRING, effectOptional: bool, effectConfiguration: *mut ::rt::gen::windows::foundation::collections::IPropertySet) -> HRESULT,
    fn AddVideoEffect(&self, effectID: HSTRING, effectOptional: bool, effectConfiguration: *mut ::rt::gen::windows::foundation::collections::IPropertySet) -> HRESULT,
    fn RemoveAllEffects(&self) -> HRESULT,
    fn get_ActualStereo3DVideoPackingMode(&self, out: *mut super::media::Stereo3DVideoPackingMode) -> HRESULT
}}
impl IMediaElement {
    #[inline] pub unsafe fn get_poster_source(&self) -> Result<ComPtr<super::media::ImageSource>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PosterSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_poster_source(&self, value: &super::media::ImageSource) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PosterSource)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_source(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Source)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_source_(&self, value: &::rt::gen::windows::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Source)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_muted(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsMuted)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_muted(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsMuted)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_audio_only(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsAudioOnly)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_auto_play(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AutoPlay)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_auto_play(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AutoPlay)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_volume(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Volume)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_volume(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Volume)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_balance(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Balance)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_balance(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Balance)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_natural_video_height(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NaturalVideoHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_natural_video_width(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NaturalVideoWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_natural_duration(&self) -> Result<super::Duration> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NaturalDuration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_position(&self) -> Result<::rt::gen::windows::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_position(&self, value: ::rt::gen::windows::foundation::TimeSpan) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Position)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_download_progress(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DownloadProgress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_buffering_progress(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BufferingProgress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_download_progress_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DownloadProgressOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_current_state(&self) -> Result<super::media::MediaElementState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CurrentState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_markers(&self) -> Result<ComPtr<super::media::TimelineMarkerCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Markers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_seek(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanSeek)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_pause(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanPause)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_audio_stream_count(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AudioStreamCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_audio_stream_index(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AudioStreamIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_audio_stream_index(&self, value: &::rt::gen::windows::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AudioStreamIndex)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_playback_rate(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PlaybackRate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_playback_rate(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PlaybackRate)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_looping(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsLooping)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_looping(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsLooping)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-media")] #[inline] pub unsafe fn get_play_to_source(&self) -> Result<ComPtr<::rt::gen::windows::media::playto::PlayToSource>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlayToSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_default_playback_rate(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DefaultPlaybackRate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_default_playback_rate(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DefaultPlaybackRate)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_aspect_ratio_width(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AspectRatioWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_aspect_ratio_height(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AspectRatioHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_real_time_playback(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RealTimePlayback)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_real_time_playback(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RealTimePlayback)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_audio_category(&self) -> Result<super::media::AudioCategory> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AudioCategory)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_audio_category(&self, value: super::media::AudioCategory) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AudioCategory)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_audio_device_type(&self) -> Result<super::media::AudioDeviceType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AudioDeviceType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_audio_device_type(&self, value: super::media::AudioDeviceType) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AudioDeviceType)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-media")] #[inline] pub unsafe fn get_protection_manager(&self) -> Result<ComPtr<::rt::gen::windows::media::protection::MediaProtectionManager>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProtectionManager)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-media")] #[inline] pub unsafe fn set_protection_manager(&self, value: &::rt::gen::windows::media::protection::MediaProtectionManager) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ProtectionManager)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stereo3_dvideo_packing_mode(&self) -> Result<super::media::Stereo3DVideoPackingMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Stereo3DVideoPackingMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stereo3_dvideo_packing_mode(&self, value: super::media::Stereo3DVideoPackingMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Stereo3DVideoPackingMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stereo3_dvideo_render_mode(&self) -> Result<super::media::Stereo3DVideoRenderMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Stereo3DVideoRenderMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stereo3_dvideo_render_mode(&self, value: super::media::Stereo3DVideoRenderMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Stereo3DVideoRenderMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_stereo3_dvideo(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsStereo3DVideo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_media_opened(&self, value: &super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_MediaOpened)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_media_opened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_MediaOpened)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_media_ended(&self, value: &super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_MediaEnded)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_media_ended(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_MediaEnded)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_media_failed(&self, value: &super::ExceptionRoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_MediaFailed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_media_failed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_MediaFailed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_download_progress_changed(&self, value: &super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DownloadProgressChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_download_progress_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DownloadProgressChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_buffering_progress_changed(&self, value: &super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_BufferingProgressChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_buffering_progress_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_BufferingProgressChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_current_state_changed(&self, value: &super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CurrentStateChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_current_state_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_CurrentStateChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_marker_reached(&self, value: &super::media::TimelineMarkerRoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_MarkerReached)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_marker_reached(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_MarkerReached)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_rate_changed(&self, value: &super::media::RateChangedRoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_RateChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_rate_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_RateChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_volume_changed(&self, value: &super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_VolumeChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_volume_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_VolumeChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_seek_completed(&self, value: &super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SeekCompleted)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_seek_completed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SeekCompleted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn stop(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Stop)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn play(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Play)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn pause(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Pause)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn can_play_type(&self, type_: &HStringArg) -> Result<super::media::MediaCanPlayResponse> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).CanPlayType)(self as *const _ as *mut _, type_.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_source(&self, stream: &::rt::gen::windows::storage::streams::IRandomAccessStream, mimeType: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetSource)(self as *const _ as *mut _, stream as *const _ as *mut _, mimeType.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_audio_stream_language(&self, index: &::rt::gen::windows::foundation::IReference<i32>) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAudioStreamLanguage)(self as *const _ as *mut _, index as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_audio_effect(&self, effectID: &HStringArg, effectOptional: bool, effectConfiguration: &::rt::gen::windows::foundation::collections::IPropertySet) -> Result<()> {
        let hr = ((*self.lpVtbl).AddAudioEffect)(self as *const _ as *mut _, effectID.get(), effectOptional, effectConfiguration as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_video_effect(&self, effectID: &HStringArg, effectOptional: bool, effectConfiguration: &::rt::gen::windows::foundation::collections::IPropertySet) -> Result<()> {
        let hr = ((*self.lpVtbl).AddVideoEffect)(self as *const _ as *mut _, effectID.get(), effectOptional, effectConfiguration as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_all_effects(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).RemoveAllEffects)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_actual_stereo3_dvideo_packing_mode(&self) -> Result<super::media::Stereo3DVideoPackingMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ActualStereo3DVideoPackingMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMediaElementStatics, 3704433849, 30056, 18050, 167, 42, 141, 223, 42, 38, 101, 202);
RT_INTERFACE!{static interface IMediaElementStatics(IMediaElementStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMediaElementStatics] {
    fn get_PosterSourceProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SourceProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsMutedProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsAudioOnlyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_AutoPlayProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_VolumeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_BalanceProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_NaturalVideoHeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_NaturalVideoWidthProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_NaturalDurationProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PositionProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DownloadProgressProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_BufferingProgressProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DownloadProgressOffsetProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CurrentStateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CanSeekProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CanPauseProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_AudioStreamCountProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_AudioStreamIndexProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PlaybackRateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsLoopingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PlayToSourceProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DefaultPlaybackRateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_AspectRatioWidthProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_AspectRatioHeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_RealTimePlaybackProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_AudioCategoryProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_AudioDeviceTypeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ProtectionManagerProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_Stereo3DVideoPackingModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_Stereo3DVideoRenderModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsStereo3DVideoProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ActualStereo3DVideoPackingModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IMediaElementStatics {
    #[inline] pub unsafe fn get_poster_source_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PosterSourceProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_source_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourceProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_muted_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsMutedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_audio_only_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsAudioOnlyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_auto_play_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AutoPlayProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_volume_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VolumeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_balance_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BalanceProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_natural_video_height_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NaturalVideoHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_natural_video_width_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NaturalVideoWidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_natural_duration_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NaturalDurationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_position_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PositionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_download_progress_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DownloadProgressProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_buffering_progress_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BufferingProgressProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_download_progress_offset_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DownloadProgressOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_current_state_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CurrentStateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_seek_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CanSeekProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_pause_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CanPauseProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_audio_stream_count_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AudioStreamCountProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_audio_stream_index_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AudioStreamIndexProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_playback_rate_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlaybackRateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_looping_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsLoopingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_play_to_source_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlayToSourceProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_default_playback_rate_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DefaultPlaybackRateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_aspect_ratio_width_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AspectRatioWidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_aspect_ratio_height_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AspectRatioHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_real_time_playback_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RealTimePlaybackProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_audio_category_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AudioCategoryProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_audio_device_type_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AudioDeviceTypeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_protection_manager_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProtectionManagerProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stereo3_dvideo_packing_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Stereo3DVideoPackingModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stereo3_dvideo_render_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Stereo3DVideoRenderModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_stereo3_dvideo_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsStereo3DVideoProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_actual_stereo3_dvideo_packing_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ActualStereo3DVideoPackingModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMediaElement2, 4250131045, 45446, 18004, 191, 219, 24, 14, 210, 108, 173, 7);
RT_INTERFACE!{interface IMediaElement2(IMediaElement2Vtbl): IInspectable(IInspectableVtbl) [IID_IMediaElement2] {
    fn get_AreTransportControlsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_AreTransportControlsEnabled(&self, value: bool) -> HRESULT,
    fn get_Stretch(&self, out: *mut super::media::Stretch) -> HRESULT,
    fn put_Stretch(&self, value: super::media::Stretch) -> HRESULT,
    fn get_IsFullWindow(&self, out: *mut bool) -> HRESULT,
    fn put_IsFullWindow(&self, value: bool) -> HRESULT,
    #[cfg(not(feature="windows-media"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-media")] fn SetMediaStreamSource(&self, source: *mut ::rt::gen::windows::media::core::IMediaSource) -> HRESULT,
    fn get_PlayToPreferredSourceUri(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn put_PlayToPreferredSourceUri(&self, value: *mut ::rt::gen::windows::foundation::Uri) -> HRESULT
}}
impl IMediaElement2 {
    #[inline] pub unsafe fn get_are_transport_controls_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AreTransportControlsEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_are_transport_controls_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AreTransportControlsEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stretch(&self) -> Result<super::media::Stretch> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Stretch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stretch(&self, value: super::media::Stretch) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Stretch)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_full_window(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsFullWindow)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_full_window(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsFullWindow)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-media")] #[inline] pub unsafe fn set_media_stream_source(&self, source: &::rt::gen::windows::media::core::IMediaSource) -> Result<()> {
        let hr = ((*self.lpVtbl).SetMediaStreamSource)(self as *const _ as *mut _, source as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_play_to_preferred_source_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlayToPreferredSourceUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_play_to_preferred_source_uri(&self, value: &::rt::gen::windows::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PlayToPreferredSourceUri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMediaElementStatics2, 2666002470, 61780, 19910, 128, 20, 166, 235, 169, 135, 248, 71);
RT_INTERFACE!{static interface IMediaElementStatics2(IMediaElementStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IMediaElementStatics2] {
    fn get_AreTransportControlsEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_StretchProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsFullWindowProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PlayToPreferredSourceUriProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IMediaElementStatics2 {
    #[inline] pub unsafe fn get_are_transport_controls_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AreTransportControlsEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stretch_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StretchProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_full_window_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsFullWindowProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_play_to_preferred_source_uri_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlayToPreferredSourceUriProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMediaElement3, 1201630995, 4059, 20184, 146, 138, 77, 57, 22, 156, 60, 210);
RT_INTERFACE!{interface IMediaElement3(IMediaElement3Vtbl): IInspectable(IInspectableVtbl) [IID_IMediaElement3] {
    fn get_TransportControls(&self, out: *mut *mut MediaTransportControls) -> HRESULT,
    fn put_TransportControls(&self, value: *mut MediaTransportControls) -> HRESULT,
    fn add_PartialMediaFailureDetected(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MediaElement, super::media::PartialMediaFailureDetectedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PartialMediaFailureDetected(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    #[cfg(feature="windows-media")] fn SetPlaybackSource(&self, source: *mut ::rt::gen::windows::media::playback::IMediaPlaybackSource) -> HRESULT,
    #[cfg(feature="windows-media")] fn GetAsCastingSource(&self, out: *mut *mut ::rt::gen::windows::media::casting::CastingSource) -> HRESULT
}}
impl IMediaElement3 {
    #[inline] pub unsafe fn get_transport_controls(&self) -> Result<ComPtr<MediaTransportControls>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransportControls)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_transport_controls(&self, value: &MediaTransportControls) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TransportControls)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_partial_media_failure_detected(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MediaElement, super::media::PartialMediaFailureDetectedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PartialMediaFailureDetected)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_partial_media_failure_detected(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PartialMediaFailureDetected)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-media")] #[inline] pub unsafe fn set_playback_source(&self, source: &::rt::gen::windows::media::playback::IMediaPlaybackSource) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPlaybackSource)(self as *const _ as *mut _, source as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-media")] #[inline] pub unsafe fn get_as_casting_source(&self) -> Result<ComPtr<::rt::gen::windows::media::casting::CastingSource>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAsCastingSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMediaPlayerPresenter, 2007573286, 3163, 16892, 191, 73, 21, 246, 195, 82, 75, 107);
RT_INTERFACE!{interface IMediaPlayerPresenter(IMediaPlayerPresenterVtbl): IInspectable(IInspectableVtbl) [IID_IMediaPlayerPresenter] {
    #[cfg(not(feature="windows-media"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-media")] fn get_MediaPlayer(&self, out: *mut *mut ::rt::gen::windows::media::playback::MediaPlayer) -> HRESULT,
    #[cfg(not(feature="windows-media"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-media")] fn put_MediaPlayer(&self, value: *mut ::rt::gen::windows::media::playback::MediaPlayer) -> HRESULT,
    fn get_Stretch(&self, out: *mut super::media::Stretch) -> HRESULT,
    fn put_Stretch(&self, value: super::media::Stretch) -> HRESULT,
    fn get_IsFullWindow(&self, out: *mut bool) -> HRESULT,
    fn put_IsFullWindow(&self, value: bool) -> HRESULT
}}
impl IMediaPlayerPresenter {
    #[cfg(feature="windows-media")] #[inline] pub unsafe fn get_media_player(&self) -> Result<ComPtr<::rt::gen::windows::media::playback::MediaPlayer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MediaPlayer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-media")] #[inline] pub unsafe fn set_media_player(&self, value: &::rt::gen::windows::media::playback::MediaPlayer) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MediaPlayer)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stretch(&self) -> Result<super::media::Stretch> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Stretch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stretch(&self, value: super::media::Stretch) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Stretch)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_full_window(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsFullWindow)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_full_window(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsFullWindow)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMediaPlayerPresenterStatics, 2228712702, 60116, 18775, 180, 43, 34, 49, 88, 202, 13, 231);
RT_INTERFACE!{static interface IMediaPlayerPresenterStatics(IMediaPlayerPresenterStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMediaPlayerPresenterStatics] {
    fn get_MediaPlayerProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_StretchProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsFullWindowProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IMediaPlayerPresenterStatics {
    #[inline] pub unsafe fn get_media_player_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MediaPlayerProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stretch_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StretchProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_full_window_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsFullWindowProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMediaPlayerPresenterFactory, 3866521527, 55663, 19349, 179, 60, 89, 232, 28, 177, 233, 186);
RT_INTERFACE!{interface IMediaPlayerPresenterFactory(IMediaPlayerPresenterFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMediaPlayerPresenterFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut MediaPlayerPresenter) -> HRESULT
}}
impl IMediaPlayerPresenterFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<MediaPlayerPresenter>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWebView, 1482869830, 8061, 18331, 146, 166, 222, 120, 88, 254, 141, 84);
RT_INTERFACE!{interface IWebView(IWebViewVtbl): IInspectable(IInspectableVtbl) [IID_IWebView] {
    fn get_Source(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn put_Source(&self, value: *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn get_AllowedScriptNotifyUris(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<::rt::gen::windows::foundation::Uri>) -> HRESULT,
    fn put_AllowedScriptNotifyUris(&self, value: *mut ::rt::gen::windows::foundation::collections::IVector<::rt::gen::windows::foundation::Uri>) -> HRESULT,
    #[cfg(not(feature="windows-applicationmodel"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-applicationmodel")] fn get_DataTransferPackage(&self, out: *mut *mut ::rt::gen::windows::applicationmodel::datatransfer::DataPackage) -> HRESULT,
    fn add_LoadCompleted(&self, value: *mut super::navigation::LoadCompletedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LoadCompleted(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ScriptNotify(&self, value: *mut NotifyEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ScriptNotify(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_NavigationFailed(&self, value: *mut WebViewNavigationFailedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NavigationFailed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn InvokeScript(&self, scriptName: HSTRING, argumentsSize: u32, arguments: *mut HSTRING, out: *mut HSTRING) -> HRESULT,
    fn Navigate(&self, source: *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn NavigateToString(&self, text: HSTRING) -> HRESULT
}}
impl IWebView {
    #[inline] pub unsafe fn get_source(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Source)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_source(&self, value: &::rt::gen::windows::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Source)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_allowed_script_notify_uris(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<::rt::gen::windows::foundation::Uri>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AllowedScriptNotifyUris)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_allowed_script_notify_uris(&self, value: &::rt::gen::windows::foundation::collections::IVector<::rt::gen::windows::foundation::Uri>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AllowedScriptNotifyUris)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn get_data_transfer_package(&self) -> Result<ComPtr<::rt::gen::windows::applicationmodel::datatransfer::DataPackage>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DataTransferPackage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_load_completed(&self, value: &super::navigation::LoadCompletedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_LoadCompleted)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_load_completed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_LoadCompleted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_script_notify(&self, value: &NotifyEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ScriptNotify)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_script_notify(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ScriptNotify)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_navigation_failed(&self, value: &WebViewNavigationFailedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_NavigationFailed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_navigation_failed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_NavigationFailed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn invoke_script(&self, scriptName: &HStringArg, arguments: &[&HStringArg]) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).InvokeScript)(self as *const _ as *mut _, scriptName.get(), arguments.len() as u32, arguments.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn navigate(&self, source: &::rt::gen::windows::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).Navigate)(self as *const _ as *mut _, source as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn navigate_to_string(&self, text: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).NavigateToString)(self as *const _ as *mut _, text.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWebViewStatics, 2696241630, 24539, 17467, 185, 240, 92, 48, 246, 183, 161, 244);
RT_INTERFACE!{static interface IWebViewStatics(IWebViewStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IWebViewStatics] {
    fn get_AnyScriptNotifyUri(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<::rt::gen::windows::foundation::Uri>) -> HRESULT,
    fn get_SourceProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_AllowedScriptNotifyUrisProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DataTransferPackageProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IWebViewStatics {
    #[inline] pub unsafe fn get_any_script_notify_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<::rt::gen::windows::foundation::Uri>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AnyScriptNotifyUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_source_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourceProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_allowed_script_notify_uris_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AllowedScriptNotifyUrisProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_data_transfer_package_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DataTransferPackageProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWebView2, 3565254046, 16127, 17506, 130, 61, 253, 82, 249, 186, 76, 200);
RT_INTERFACE!{interface IWebView2(IWebView2Vtbl): IInspectable(IInspectableVtbl) [IID_IWebView2] {
    fn get_CanGoBack(&self, out: *mut bool) -> HRESULT,
    fn get_CanGoForward(&self, out: *mut bool) -> HRESULT,
    fn get_DocumentTitle(&self, out: *mut HSTRING) -> HRESULT,
    fn add_NavigationStarting(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewNavigationStartingEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NavigationStarting(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ContentLoading(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewContentLoadingEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ContentLoading(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_DOMContentLoaded(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewDOMContentLoadedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DOMContentLoaded(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn GoForward(&self) -> HRESULT,
    fn GoBack(&self) -> HRESULT,
    fn Refresh(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy13(&self) -> (),
    #[cfg(feature="windows-storage")] fn CapturePreviewToStreamAsync(&self, stream: *mut ::rt::gen::windows::storage::streams::IRandomAccessStream, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn InvokeScriptAsync(&self, scriptName: HSTRING, arguments: *mut ::rt::gen::windows::foundation::collections::IIterable<HString>, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<HString>) -> HRESULT,
    #[cfg(not(feature="windows-applicationmodel"))] fn __Dummy15(&self) -> (),
    #[cfg(feature="windows-applicationmodel")] fn CaptureSelectedContentToDataPackageAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::applicationmodel::datatransfer::DataPackage>) -> HRESULT,
    #[cfg(not(feature="windows-web"))] fn __Dummy16(&self) -> (),
    #[cfg(feature="windows-web")] fn NavigateToLocalStreamUri(&self, source: *mut ::rt::gen::windows::foundation::Uri, streamResolver: *mut ::rt::gen::windows::web::IUriToStreamResolver) -> HRESULT,
    fn BuildLocalStreamUri(&self, contentIdentifier: HSTRING, relativePath: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy18(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_DefaultBackgroundColor(&self, out: *mut super::super::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy19(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_DefaultBackgroundColor(&self, value: super::super::Color) -> HRESULT,
    fn add_NavigationCompleted(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewNavigationCompletedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NavigationCompleted(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_FrameNavigationStarting(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewNavigationStartingEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FrameNavigationStarting(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_FrameContentLoading(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewContentLoadingEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FrameContentLoading(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_FrameDOMContentLoaded(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewDOMContentLoadedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FrameDOMContentLoaded(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_FrameNavigationCompleted(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewNavigationCompletedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FrameNavigationCompleted(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_LongRunningScriptDetected(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewLongRunningScriptDetectedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LongRunningScriptDetected(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_UnsafeContentWarningDisplaying(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<WebView, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_UnsafeContentWarningDisplaying(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_UnviewableContentIdentified(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewUnviewableContentIdentifiedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_UnviewableContentIdentified(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    #[cfg(not(feature="windows-web"))] fn __Dummy36(&self) -> (),
    #[cfg(feature="windows-web")] fn NavigateWithHttpRequestMessage(&self, requestMessage: *mut ::rt::gen::windows::web::http::HttpRequestMessage) -> HRESULT,
    fn Focus(&self, value: super::FocusState, out: *mut bool) -> HRESULT
}}
impl IWebView2 {
    #[inline] pub unsafe fn get_can_go_back(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanGoBack)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_go_forward(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanGoForward)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_document_title(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DocumentTitle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_navigation_starting(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewNavigationStartingEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_NavigationStarting)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_navigation_starting(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_NavigationStarting)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_content_loading(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewContentLoadingEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ContentLoading)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_content_loading(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ContentLoading)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_domcontent_loaded(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewDOMContentLoadedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DOMContentLoaded)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_domcontent_loaded(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DOMContentLoaded)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn go_forward(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).GoForward)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn go_back(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).GoBack)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn refresh(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Refresh)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn stop(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Stop)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn capture_preview_to_stream_async(&self, stream: &::rt::gen::windows::storage::streams::IRandomAccessStream) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CapturePreviewToStreamAsync)(self as *const _ as *mut _, stream as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn invoke_script_async(&self, scriptName: &HStringArg, arguments: &::rt::gen::windows::foundation::collections::IIterable<HString>) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).InvokeScriptAsync)(self as *const _ as *mut _, scriptName.get(), arguments as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn capture_selected_content_to_data_package_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::applicationmodel::datatransfer::DataPackage>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CaptureSelectedContentToDataPackageAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-web")] #[inline] pub unsafe fn navigate_to_local_stream_uri(&self, source: &::rt::gen::windows::foundation::Uri, streamResolver: &::rt::gen::windows::web::IUriToStreamResolver) -> Result<()> {
        let hr = ((*self.lpVtbl).NavigateToLocalStreamUri)(self as *const _ as *mut _, source as *const _ as *mut _, streamResolver as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn build_local_stream_uri(&self, contentIdentifier: &HStringArg, relativePath: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).BuildLocalStreamUri)(self as *const _ as *mut _, contentIdentifier.get(), relativePath.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_default_background_color(&self) -> Result<super::super::Color> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DefaultBackgroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_default_background_color(&self, value: super::super::Color) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DefaultBackgroundColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_navigation_completed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewNavigationCompletedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_NavigationCompleted)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_navigation_completed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_NavigationCompleted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_frame_navigation_starting(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewNavigationStartingEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_FrameNavigationStarting)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_frame_navigation_starting(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_FrameNavigationStarting)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_frame_content_loading(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewContentLoadingEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_FrameContentLoading)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_frame_content_loading(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_FrameContentLoading)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_frame_domcontent_loaded(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewDOMContentLoadedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_FrameDOMContentLoaded)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_frame_domcontent_loaded(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_FrameDOMContentLoaded)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_frame_navigation_completed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewNavigationCompletedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_FrameNavigationCompleted)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_frame_navigation_completed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_FrameNavigationCompleted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_long_running_script_detected(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewLongRunningScriptDetectedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_LongRunningScriptDetected)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_long_running_script_detected(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_LongRunningScriptDetected)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_unsafe_content_warning_displaying(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<WebView, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_UnsafeContentWarningDisplaying)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_unsafe_content_warning_displaying(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_UnsafeContentWarningDisplaying)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_unviewable_content_identified(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewUnviewableContentIdentifiedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_UnviewableContentIdentified)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_unviewable_content_identified(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_UnviewableContentIdentified)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-web")] #[inline] pub unsafe fn navigate_with_http_request_message(&self, requestMessage: &::rt::gen::windows::web::http::HttpRequestMessage) -> Result<()> {
        let hr = ((*self.lpVtbl).NavigateWithHttpRequestMessage)(self as *const _ as *mut _, requestMessage as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn focus(&self, value: super::FocusState) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Focus)(self as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWebViewStatics2, 841975680, 59410, 18027, 158, 80, 142, 159, 236, 36, 1, 138);
RT_INTERFACE!{static interface IWebViewStatics2(IWebViewStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IWebViewStatics2] {
    fn get_CanGoBackProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CanGoForwardProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DocumentTitleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DefaultBackgroundColorProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IWebViewStatics2 {
    #[inline] pub unsafe fn get_can_go_back_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CanGoBackProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_go_forward_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CanGoForwardProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_document_title_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DocumentTitleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_default_background_color_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DefaultBackgroundColorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWebView3, 3298261147, 46233, 19817, 181, 194, 174, 157, 93, 109, 89, 78);
RT_INTERFACE!{interface IWebView3(IWebView3Vtbl): IInspectable(IInspectableVtbl) [IID_IWebView3] {
    fn get_ContainsFullScreenElement(&self, out: *mut bool) -> HRESULT,
    fn add_ContainsFullScreenElementChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<WebView, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ContainsFullScreenElementChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IWebView3 {
    #[inline] pub unsafe fn get_contains_full_screen_element(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ContainsFullScreenElement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_contains_full_screen_element_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<WebView, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ContainsFullScreenElementChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_contains_full_screen_element_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ContainsFullScreenElementChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWebViewStatics3, 312209290, 17673, 17268, 176, 209, 167, 16, 77, 12, 58, 47);
RT_INTERFACE!{static interface IWebViewStatics3(IWebViewStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IWebViewStatics3] {
    fn get_ContainsFullScreenElementProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IWebViewStatics3 {
    #[inline] pub unsafe fn get_contains_full_screen_element_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContainsFullScreenElementProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWebView4, 3800187836, 26611, 17962, 180, 224, 59, 191, 108, 61, 171, 11);
RT_INTERFACE!{interface IWebView4(IWebView4Vtbl): IInspectable(IInspectableVtbl) [IID_IWebView4] {
    fn get_ExecutionMode(&self, out: *mut WebViewExecutionMode) -> HRESULT,
    fn get_DeferredPermissionRequests(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<WebViewDeferredPermissionRequest>) -> HRESULT,
    fn get_Settings(&self, out: *mut *mut WebViewSettings) -> HRESULT,
    fn add_UnsupportedUriSchemeIdentified(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewUnsupportedUriSchemeIdentifiedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_UnsupportedUriSchemeIdentified(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_NewWindowRequested(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewNewWindowRequestedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NewWindowRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PermissionRequested(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewPermissionRequestedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PermissionRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn AddWebAllowedObject(&self, name: HSTRING, pObject: *mut IInspectable) -> HRESULT,
    fn DeferredPermissionRequestById(&self, id: u32, out: *mut *mut WebViewDeferredPermissionRequest) -> HRESULT
}}
impl IWebView4 {
    #[inline] pub unsafe fn get_execution_mode(&self) -> Result<WebViewExecutionMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExecutionMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferred_permission_requests(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<WebViewDeferredPermissionRequest>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DeferredPermissionRequests)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_settings(&self) -> Result<ComPtr<WebViewSettings>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Settings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_unsupported_uri_scheme_identified(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewUnsupportedUriSchemeIdentifiedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_UnsupportedUriSchemeIdentified)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_unsupported_uri_scheme_identified(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_UnsupportedUriSchemeIdentified)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_new_window_requested(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewNewWindowRequestedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_NewWindowRequested)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_new_window_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_NewWindowRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_permission_requested(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<WebView, WebViewPermissionRequestedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PermissionRequested)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_permission_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PermissionRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_web_allowed_object(&self, name: &HStringArg, pObject: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).AddWebAllowedObject)(self as *const _ as *mut _, name.get(), pObject as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn deferred_permission_request_by_id(&self, id: u32) -> Result<ComPtr<WebViewDeferredPermissionRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeferredPermissionRequestById)(self as *const _ as *mut _, id, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWebViewStatics4, 1152489392, 46918, 16627, 153, 54, 78, 187, 255, 107, 71, 184);
RT_INTERFACE!{static interface IWebViewStatics4(IWebViewStatics4Vtbl): IInspectable(IInspectableVtbl) [IID_IWebViewStatics4] {
    fn get_DefaultExecutionMode(&self, out: *mut WebViewExecutionMode) -> HRESULT,
    fn ClearTemporaryWebDataAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IWebViewStatics4 {
    #[inline] pub unsafe fn get_default_execution_mode(&self) -> Result<WebViewExecutionMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DefaultExecutionMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn clear_temporary_web_data_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ClearTemporaryWebDataAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWebViewFactory4, 2196614232, 61034, 19611, 163, 160, 147, 71, 167, 208, 239, 76);
RT_INTERFACE!{static interface IWebViewFactory4(IWebViewFactory4Vtbl): IInspectable(IInspectableVtbl) [IID_IWebViewFactory4] {
    fn CreateInstanceWithExecutionMode(&self, executionMode: WebViewExecutionMode, out: *mut *mut WebView) -> HRESULT
}}
impl IWebViewFactory4 {
    #[inline] pub unsafe fn create_instance_with_execution_mode(&self, executionMode: WebViewExecutionMode) -> Result<ComPtr<WebView>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithExecutionMode)(self as *const _ as *mut _, executionMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWebView5, 2358805670, 12091, 19029, 164, 99, 132, 68, 194, 9, 93, 0);
RT_INTERFACE!{interface IWebView5(IWebView5Vtbl): IInspectable(IInspectableVtbl) [IID_IWebView5] {
    fn get_XYFocusLeft(&self, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn put_XYFocusLeft(&self, value: *mut super::DependencyObject) -> HRESULT,
    fn get_XYFocusRight(&self, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn put_XYFocusRight(&self, value: *mut super::DependencyObject) -> HRESULT,
    fn get_XYFocusUp(&self, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn put_XYFocusUp(&self, value: *mut super::DependencyObject) -> HRESULT,
    fn get_XYFocusDown(&self, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn put_XYFocusDown(&self, value: *mut super::DependencyObject) -> HRESULT
}}
impl IWebView5 {
    #[inline] pub unsafe fn get_xyfocus_left(&self) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusLeft)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_xyfocus_left(&self, value: &super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_XYFocusLeft)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_right(&self) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusRight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_xyfocus_right(&self, value: &super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_XYFocusRight)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_up(&self) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusUp)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_xyfocus_up(&self, value: &super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_XYFocusUp)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_down(&self) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusDown)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_xyfocus_down(&self, value: &super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_XYFocusDown)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWebViewStatics5, 144750801, 20618, 19896, 151, 239, 15, 165, 5, 225, 158, 194);
RT_INTERFACE!{static interface IWebViewStatics5(IWebViewStatics5Vtbl): IInspectable(IInspectableVtbl) [IID_IWebViewStatics5] {
    fn get_XYFocusLeftProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_XYFocusRightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_XYFocusUpProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_XYFocusDownProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IWebViewStatics5 {
    #[inline] pub unsafe fn get_xyfocus_left_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusLeftProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_right_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusRightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_up_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusUpProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_down_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusDownProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWebViewBrush, 1088974709, 3316, 19314, 164, 214, 207, 93, 21, 120, 1, 22);
RT_INTERFACE!{interface IWebViewBrush(IWebViewBrushVtbl): IInspectable(IInspectableVtbl) [IID_IWebViewBrush] {
    fn get_SourceName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SourceName(&self, value: HSTRING) -> HRESULT,
    fn Redraw(&self) -> HRESULT,
    fn SetSource(&self, source: *mut WebView) -> HRESULT
}}
impl IWebViewBrush {
    #[inline] pub unsafe fn get_source_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourceName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_source_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SourceName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn redraw(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Redraw)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_source(&self, source: &WebView) -> Result<()> {
        let hr = ((*self.lpVtbl).SetSource)(self as *const _ as *mut _, source as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWebViewBrushStatics, 3612191268, 7429, 17982, 176, 40, 107, 170, 68, 32, 231, 98);
RT_INTERFACE!{static interface IWebViewBrushStatics(IWebViewBrushStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IWebViewBrushStatics] {
    fn get_SourceNameProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IWebViewBrushStatics {
    #[inline] pub unsafe fn get_source_name_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourceNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBarSeparator, 453481889, 7105, 19795, 149, 234, 251, 10, 44, 204, 201, 5);
RT_INTERFACE!{interface IAppBarSeparator(IAppBarSeparatorVtbl): IInspectable(IInspectableVtbl) [IID_IAppBarSeparator] {
    
}}
DEFINE_IID!(IID_IAppBarSeparatorStatics, 938620036, 23349, 18019, 167, 93, 242, 213, 12, 185, 198, 25);
RT_INTERFACE!{static interface IAppBarSeparatorStatics(IAppBarSeparatorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAppBarSeparatorStatics] {
    fn get_IsCompactProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IAppBarSeparatorStatics {
    #[inline] pub unsafe fn get_is_compact_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsCompactProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBarSeparatorFactory, 98182605, 62471, 18654, 139, 80, 255, 135, 209, 226, 129, 143);
RT_INTERFACE!{interface IAppBarSeparatorFactory(IAppBarSeparatorFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAppBarSeparatorFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut AppBarSeparator) -> HRESULT
}}
impl IAppBarSeparatorFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<AppBarSeparator>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBarSeparatorStatics3, 919032825, 29555, 20062, 155, 164, 195, 98, 42, 0, 60, 78);
RT_INTERFACE!{static interface IAppBarSeparatorStatics3(IAppBarSeparatorStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IAppBarSeparatorStatics3] {
    fn get_IsInOverflowProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DynamicOverflowOrderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IAppBarSeparatorStatics3 {
    #[inline] pub unsafe fn get_is_in_overflow_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsInOverflowProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_dynamic_overflow_order_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DynamicOverflowOrderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBitmapIcon, 3908966347, 13815, 16627, 161, 133, 72, 179, 151, 183, 62, 104);
RT_INTERFACE!{interface IBitmapIcon(IBitmapIconVtbl): IInspectable(IInspectableVtbl) [IID_IBitmapIcon] {
    fn get_UriSource(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn put_UriSource(&self, value: *mut ::rt::gen::windows::foundation::Uri) -> HRESULT
}}
impl IBitmapIcon {
    #[inline] pub unsafe fn get_uri_source(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UriSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_uri_source(&self, value: &::rt::gen::windows::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_UriSource)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBitmapIconStatics, 3765621015, 58599, 19980, 148, 112, 83, 255, 28, 232, 79, 103);
RT_INTERFACE!{static interface IBitmapIconStatics(IBitmapIconStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBitmapIconStatics] {
    fn get_UriSourceProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IBitmapIconStatics {
    #[inline] pub unsafe fn get_uri_source_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UriSourceProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBitmapIconFactory, 1188449053, 31305, 20326, 151, 41, 40, 72, 199, 136, 228, 2);
RT_INTERFACE!{interface IBitmapIconFactory(IBitmapIconFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IBitmapIconFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut BitmapIcon) -> HRESULT
}}
impl IBitmapIconFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<BitmapIcon>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBitmapIcon2, 103064074, 40401, 16897, 187, 32, 66, 134, 61, 161, 86, 88);
RT_INTERFACE!{interface IBitmapIcon2(IBitmapIcon2Vtbl): IInspectable(IInspectableVtbl) [IID_IBitmapIcon2] {
    fn get_ShowAsMonochrome(&self, out: *mut bool) -> HRESULT,
    fn put_ShowAsMonochrome(&self, value: bool) -> HRESULT
}}
impl IBitmapIcon2 {
    #[inline] pub unsafe fn get_show_as_monochrome(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ShowAsMonochrome)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_show_as_monochrome(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ShowAsMonochrome)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBitmapIconStatics2, 2537882219, 46914, 19081, 165, 215, 160, 229, 251, 128, 154, 241);
RT_INTERFACE!{static interface IBitmapIconStatics2(IBitmapIconStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IBitmapIconStatics2] {
    fn get_ShowAsMonochromeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IBitmapIconStatics2 {
    #[inline] pub unsafe fn get_show_as_monochrome_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ShowAsMonochromeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICalendarDatePicker, 1674166639, 26252, 17553, 148, 68, 212, 93, 139, 244, 250, 41);
RT_INTERFACE!{interface ICalendarDatePicker(ICalendarDatePickerVtbl): IInspectable(IInspectableVtbl) [IID_ICalendarDatePicker] {
    fn get_Date(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::DateTime>) -> HRESULT,
    fn put_Date(&self, value: *mut ::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::DateTime>) -> HRESULT,
    fn get_IsCalendarOpen(&self, out: *mut bool) -> HRESULT,
    fn put_IsCalendarOpen(&self, value: bool) -> HRESULT,
    fn get_DateFormat(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DateFormat(&self, value: HSTRING) -> HRESULT,
    fn get_PlaceholderText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PlaceholderText(&self, value: HSTRING) -> HRESULT,
    fn get_Header(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Header(&self, value: *mut IInspectable) -> HRESULT,
    fn get_HeaderTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_HeaderTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_CalendarViewStyle(&self, out: *mut *mut super::Style) -> HRESULT,
    fn put_CalendarViewStyle(&self, value: *mut super::Style) -> HRESULT,
    fn get_MinDate(&self, out: *mut ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn put_MinDate(&self, value: ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn get_MaxDate(&self, out: *mut ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn put_MaxDate(&self, value: ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn get_IsTodayHighlighted(&self, out: *mut bool) -> HRESULT,
    fn put_IsTodayHighlighted(&self, value: bool) -> HRESULT,
    fn get_DisplayMode(&self, out: *mut CalendarViewDisplayMode) -> HRESULT,
    fn put_DisplayMode(&self, value: CalendarViewDisplayMode) -> HRESULT,
    #[cfg(not(feature="windows-globalization"))] fn __Dummy22(&self) -> (),
    #[cfg(feature="windows-globalization")] fn get_FirstDayOfWeek(&self, out: *mut ::rt::gen::windows::globalization::DayOfWeek) -> HRESULT,
    #[cfg(not(feature="windows-globalization"))] fn __Dummy23(&self) -> (),
    #[cfg(feature="windows-globalization")] fn put_FirstDayOfWeek(&self, value: ::rt::gen::windows::globalization::DayOfWeek) -> HRESULT,
    fn get_DayOfWeekFormat(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DayOfWeekFormat(&self, value: HSTRING) -> HRESULT,
    fn get_CalendarIdentifier(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CalendarIdentifier(&self, value: HSTRING) -> HRESULT,
    fn get_IsOutOfScopeEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsOutOfScopeEnabled(&self, value: bool) -> HRESULT,
    fn get_IsGroupLabelVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsGroupLabelVisible(&self, value: bool) -> HRESULT,
    fn add_CalendarViewDayItemChanging(&self, value: *mut CalendarViewDayItemChangingEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CalendarViewDayItemChanging(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_DateChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<CalendarDatePicker, CalendarDatePickerDateChangedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DateChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Opened(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Opened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Closed(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn SetDisplayDate(&self, date: ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn SetYearDecadeDisplayDimensions(&self, columns: i32, rows: i32) -> HRESULT
}}
impl ICalendarDatePicker {
    #[inline] pub unsafe fn get_date(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Date)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_date(&self, value: &::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::DateTime>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Date)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_calendar_open(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCalendarOpen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_calendar_open(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsCalendarOpen)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_date_format(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DateFormat)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_date_format(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DateFormat)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placeholder_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlaceholderText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_placeholder_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PlaceholderText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Header)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Header)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_calendar_view_style(&self) -> Result<ComPtr<super::Style>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalendarViewStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_calendar_view_style(&self, value: &super::Style) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CalendarViewStyle)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_date(&self) -> Result<::rt::gen::windows::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_min_date(&self, value: ::rt::gen::windows::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MinDate)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_date(&self) -> Result<::rt::gen::windows::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_date(&self, value: ::rt::gen::windows::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxDate)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_today_highlighted(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTodayHighlighted)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_today_highlighted(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsTodayHighlighted)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_mode(&self) -> Result<CalendarViewDisplayMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DisplayMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_mode(&self, value: CalendarViewDisplayMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-globalization")] #[inline] pub unsafe fn get_first_day_of_week(&self) -> Result<::rt::gen::windows::globalization::DayOfWeek> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FirstDayOfWeek)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-globalization")] #[inline] pub unsafe fn set_first_day_of_week(&self, value: ::rt::gen::windows::globalization::DayOfWeek) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FirstDayOfWeek)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_day_of_week_format(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DayOfWeekFormat)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_day_of_week_format(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DayOfWeekFormat)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_calendar_identifier(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalendarIdentifier)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_calendar_identifier(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CalendarIdentifier)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_out_of_scope_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsOutOfScopeEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_out_of_scope_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsOutOfScopeEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_group_label_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsGroupLabelVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_group_label_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsGroupLabelVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_calendar_view_day_item_changing(&self, value: &CalendarViewDayItemChangingEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CalendarViewDayItemChanging)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_calendar_view_day_item_changing(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_CalendarViewDayItemChanging)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_date_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<CalendarDatePicker, CalendarDatePickerDateChangedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DateChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_date_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DateChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_opened(&self, value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Opened)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_opened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Opened)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_closed(&self, value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Closed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_closed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Closed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_date(&self, date: ::rt::gen::windows::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).SetDisplayDate)(self as *const _ as *mut _, date);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_year_decade_display_dimensions(&self, columns: i32, rows: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetYearDecadeDisplayDimensions)(self as *const _ as *mut _, columns, rows);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICalendarDatePickerStatics, 967037585, 44971, 19348, 131, 149, 186, 123, 135, 78, 60, 140);
RT_INTERFACE!{static interface ICalendarDatePickerStatics(ICalendarDatePickerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICalendarDatePickerStatics] {
    fn get_DateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsCalendarOpenProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DateFormatProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PlaceholderTextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HeaderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HeaderTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CalendarViewStyleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MinDateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MaxDateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsTodayHighlightedProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DisplayModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FirstDayOfWeekProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DayOfWeekFormatProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CalendarIdentifierProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsOutOfScopeEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsGroupLabelVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ICalendarDatePickerStatics {
    #[inline] pub unsafe fn get_date_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_calendar_open_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsCalendarOpenProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_date_format_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DateFormatProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placeholder_text_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlaceholderTextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_calendar_view_style_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalendarViewStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_date_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MinDateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_date_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxDateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_today_highlighted_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsTodayHighlightedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_first_day_of_week_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FirstDayOfWeekProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_day_of_week_format_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DayOfWeekFormatProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_calendar_identifier_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalendarIdentifierProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_out_of_scope_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsOutOfScopeEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_group_label_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsGroupLabelVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICalendarDatePickerFactory, 276475229, 14526, 17071, 169, 87, 252, 134, 165, 207, 30, 154);
RT_INTERFACE!{interface ICalendarDatePickerFactory(ICalendarDatePickerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICalendarDatePickerFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut CalendarDatePicker) -> HRESULT
}}
impl ICalendarDatePickerFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<CalendarDatePicker>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICalendarDatePicker2, 2987835737, 9233, 19040, 167, 170, 39, 65, 107, 73, 72, 30);
RT_INTERFACE!{interface ICalendarDatePicker2(ICalendarDatePicker2Vtbl): IInspectable(IInspectableVtbl) [IID_ICalendarDatePicker2] {
    fn get_LightDismissOverlayMode(&self, out: *mut LightDismissOverlayMode) -> HRESULT,
    fn put_LightDismissOverlayMode(&self, value: LightDismissOverlayMode) -> HRESULT
}}
impl ICalendarDatePicker2 {
    #[inline] pub unsafe fn get_light_dismiss_overlay_mode(&self) -> Result<LightDismissOverlayMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LightDismissOverlayMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_light_dismiss_overlay_mode(&self, value: LightDismissOverlayMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LightDismissOverlayMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICalendarDatePickerStatics2, 807431000, 41718, 18944, 141, 19, 51, 196, 107, 107, 142, 13);
RT_INTERFACE!{static interface ICalendarDatePickerStatics2(ICalendarDatePickerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_ICalendarDatePickerStatics2] {
    fn get_LightDismissOverlayModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ICalendarDatePickerStatics2 {
    #[inline] pub unsafe fn get_light_dismiss_overlay_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LightDismissOverlayModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICalendarView, 3445854723, 57269, 17170, 172, 7, 192, 57, 24, 36, 96, 123);
RT_INTERFACE!{interface ICalendarView(ICalendarViewVtbl): IInspectable(IInspectableVtbl) [IID_ICalendarView] {
    fn get_CalendarIdentifier(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CalendarIdentifier(&self, value: HSTRING) -> HRESULT,
    fn get_DayOfWeekFormat(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DayOfWeekFormat(&self, value: HSTRING) -> HRESULT,
    fn get_IsGroupLabelVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsGroupLabelVisible(&self, value: bool) -> HRESULT,
    fn get_DisplayMode(&self, out: *mut CalendarViewDisplayMode) -> HRESULT,
    fn put_DisplayMode(&self, value: CalendarViewDisplayMode) -> HRESULT,
    #[cfg(not(feature="windows-globalization"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-globalization")] fn get_FirstDayOfWeek(&self, out: *mut ::rt::gen::windows::globalization::DayOfWeek) -> HRESULT,
    #[cfg(not(feature="windows-globalization"))] fn __Dummy9(&self) -> (),
    #[cfg(feature="windows-globalization")] fn put_FirstDayOfWeek(&self, value: ::rt::gen::windows::globalization::DayOfWeek) -> HRESULT,
    fn get_IsOutOfScopeEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsOutOfScopeEnabled(&self, value: bool) -> HRESULT,
    fn get_IsTodayHighlighted(&self, out: *mut bool) -> HRESULT,
    fn put_IsTodayHighlighted(&self, value: bool) -> HRESULT,
    fn get_MaxDate(&self, out: *mut ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn put_MaxDate(&self, value: ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn get_MinDate(&self, out: *mut ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn put_MinDate(&self, value: ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn get_NumberOfWeeksInView(&self, out: *mut i32) -> HRESULT,
    fn put_NumberOfWeeksInView(&self, value: i32) -> HRESULT,
    fn get_SelectedDates(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<::rt::gen::windows::foundation::DateTime>) -> HRESULT,
    fn get_SelectionMode(&self, out: *mut CalendarViewSelectionMode) -> HRESULT,
    fn put_SelectionMode(&self, value: CalendarViewSelectionMode) -> HRESULT,
    fn get_TemplateSettings(&self, out: *mut *mut primitives::CalendarViewTemplateSettings) -> HRESULT,
    fn get_FocusBorderBrush(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_FocusBorderBrush(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_SelectedHoverBorderBrush(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_SelectedHoverBorderBrush(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_SelectedPressedBorderBrush(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_SelectedPressedBorderBrush(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_SelectedBorderBrush(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_SelectedBorderBrush(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_HoverBorderBrush(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_HoverBorderBrush(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_PressedBorderBrush(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_PressedBorderBrush(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_CalendarItemBorderBrush(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_CalendarItemBorderBrush(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_OutOfScopeBackground(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_OutOfScopeBackground(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_CalendarItemBackground(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_CalendarItemBackground(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_PressedForeground(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_PressedForeground(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_TodayForeground(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_TodayForeground(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_BlackoutForeground(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_BlackoutForeground(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_SelectedForeground(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_SelectedForeground(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_OutOfScopeForeground(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_OutOfScopeForeground(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_CalendarItemForeground(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_CalendarItemForeground(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_DayItemFontFamily(&self, out: *mut *mut super::media::FontFamily) -> HRESULT,
    fn put_DayItemFontFamily(&self, value: *mut super::media::FontFamily) -> HRESULT,
    fn get_DayItemFontSize(&self, out: *mut f64) -> HRESULT,
    fn put_DayItemFontSize(&self, value: f64) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy58(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_DayItemFontStyle(&self, out: *mut super::super::text::FontStyle) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy59(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_DayItemFontStyle(&self, value: super::super::text::FontStyle) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy60(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_DayItemFontWeight(&self, out: *mut super::super::text::FontWeight) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy61(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_DayItemFontWeight(&self, value: super::super::text::FontWeight) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy62(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_TodayFontWeight(&self, out: *mut super::super::text::FontWeight) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy63(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_TodayFontWeight(&self, value: super::super::text::FontWeight) -> HRESULT,
    fn get_FirstOfMonthLabelFontFamily(&self, out: *mut *mut super::media::FontFamily) -> HRESULT,
    fn put_FirstOfMonthLabelFontFamily(&self, value: *mut super::media::FontFamily) -> HRESULT,
    fn get_FirstOfMonthLabelFontSize(&self, out: *mut f64) -> HRESULT,
    fn put_FirstOfMonthLabelFontSize(&self, value: f64) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy68(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FirstOfMonthLabelFontStyle(&self, out: *mut super::super::text::FontStyle) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy69(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_FirstOfMonthLabelFontStyle(&self, value: super::super::text::FontStyle) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy70(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FirstOfMonthLabelFontWeight(&self, out: *mut super::super::text::FontWeight) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy71(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_FirstOfMonthLabelFontWeight(&self, value: super::super::text::FontWeight) -> HRESULT,
    fn get_MonthYearItemFontFamily(&self, out: *mut *mut super::media::FontFamily) -> HRESULT,
    fn put_MonthYearItemFontFamily(&self, value: *mut super::media::FontFamily) -> HRESULT,
    fn get_MonthYearItemFontSize(&self, out: *mut f64) -> HRESULT,
    fn put_MonthYearItemFontSize(&self, value: f64) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy76(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_MonthYearItemFontStyle(&self, out: *mut super::super::text::FontStyle) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy77(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_MonthYearItemFontStyle(&self, value: super::super::text::FontStyle) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy78(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_MonthYearItemFontWeight(&self, out: *mut super::super::text::FontWeight) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy79(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_MonthYearItemFontWeight(&self, value: super::super::text::FontWeight) -> HRESULT,
    fn get_FirstOfYearDecadeLabelFontFamily(&self, out: *mut *mut super::media::FontFamily) -> HRESULT,
    fn put_FirstOfYearDecadeLabelFontFamily(&self, value: *mut super::media::FontFamily) -> HRESULT,
    fn get_FirstOfYearDecadeLabelFontSize(&self, out: *mut f64) -> HRESULT,
    fn put_FirstOfYearDecadeLabelFontSize(&self, value: f64) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy84(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FirstOfYearDecadeLabelFontStyle(&self, out: *mut super::super::text::FontStyle) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy85(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_FirstOfYearDecadeLabelFontStyle(&self, value: super::super::text::FontStyle) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy86(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FirstOfYearDecadeLabelFontWeight(&self, out: *mut super::super::text::FontWeight) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy87(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_FirstOfYearDecadeLabelFontWeight(&self, value: super::super::text::FontWeight) -> HRESULT,
    fn get_HorizontalDayItemAlignment(&self, out: *mut super::HorizontalAlignment) -> HRESULT,
    fn put_HorizontalDayItemAlignment(&self, value: super::HorizontalAlignment) -> HRESULT,
    fn get_VerticalDayItemAlignment(&self, out: *mut super::VerticalAlignment) -> HRESULT,
    fn put_VerticalDayItemAlignment(&self, value: super::VerticalAlignment) -> HRESULT,
    fn get_HorizontalFirstOfMonthLabelAlignment(&self, out: *mut super::HorizontalAlignment) -> HRESULT,
    fn put_HorizontalFirstOfMonthLabelAlignment(&self, value: super::HorizontalAlignment) -> HRESULT,
    fn get_VerticalFirstOfMonthLabelAlignment(&self, out: *mut super::VerticalAlignment) -> HRESULT,
    fn put_VerticalFirstOfMonthLabelAlignment(&self, value: super::VerticalAlignment) -> HRESULT,
    fn get_CalendarItemBorderThickness(&self, out: *mut super::Thickness) -> HRESULT,
    fn put_CalendarItemBorderThickness(&self, value: super::Thickness) -> HRESULT,
    fn get_CalendarViewDayItemStyle(&self, out: *mut *mut super::Style) -> HRESULT,
    fn put_CalendarViewDayItemStyle(&self, value: *mut super::Style) -> HRESULT,
    fn add_CalendarViewDayItemChanging(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CalendarViewDayItemChanging(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_SelectedDatesChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<CalendarView, CalendarViewSelectedDatesChangedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SelectedDatesChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn SetDisplayDate(&self, date: ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn SetYearDecadeDisplayDimensions(&self, columns: i32, rows: i32) -> HRESULT
}}
impl ICalendarView {
    #[inline] pub unsafe fn get_calendar_identifier(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalendarIdentifier)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_calendar_identifier(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CalendarIdentifier)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_day_of_week_format(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DayOfWeekFormat)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_day_of_week_format(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DayOfWeekFormat)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_group_label_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsGroupLabelVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_group_label_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsGroupLabelVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_mode(&self) -> Result<CalendarViewDisplayMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DisplayMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_mode(&self, value: CalendarViewDisplayMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-globalization")] #[inline] pub unsafe fn get_first_day_of_week(&self) -> Result<::rt::gen::windows::globalization::DayOfWeek> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FirstDayOfWeek)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-globalization")] #[inline] pub unsafe fn set_first_day_of_week(&self, value: ::rt::gen::windows::globalization::DayOfWeek) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FirstDayOfWeek)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_out_of_scope_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsOutOfScopeEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_out_of_scope_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsOutOfScopeEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_today_highlighted(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTodayHighlighted)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_today_highlighted(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsTodayHighlighted)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_date(&self) -> Result<::rt::gen::windows::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_date(&self, value: ::rt::gen::windows::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxDate)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_date(&self) -> Result<::rt::gen::windows::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_min_date(&self, value: ::rt::gen::windows::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MinDate)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_number_of_weeks_in_view(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NumberOfWeeksInView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_number_of_weeks_in_view(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_NumberOfWeeksInView)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_dates(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<::rt::gen::windows::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedDates)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_mode(&self) -> Result<CalendarViewSelectionMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SelectionMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selection_mode(&self, value: CalendarViewSelectionMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectionMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_template_settings(&self) -> Result<ComPtr<primitives::CalendarViewTemplateSettings>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TemplateSettings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_border_brush(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FocusBorderBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_focus_border_brush(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FocusBorderBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_hover_border_brush(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedHoverBorderBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_hover_border_brush(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedHoverBorderBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_pressed_border_brush(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedPressedBorderBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_pressed_border_brush(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedPressedBorderBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_border_brush(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedBorderBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_border_brush(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedBorderBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_hover_border_brush(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HoverBorderBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_hover_border_brush(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HoverBorderBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pressed_border_brush(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PressedBorderBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_pressed_border_brush(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PressedBorderBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_calendar_item_border_brush(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalendarItemBorderBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_calendar_item_border_brush(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CalendarItemBorderBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_out_of_scope_background(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OutOfScopeBackground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_out_of_scope_background(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OutOfScopeBackground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_calendar_item_background(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalendarItemBackground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_calendar_item_background(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CalendarItemBackground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pressed_foreground(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PressedForeground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_pressed_foreground(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PressedForeground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_today_foreground(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TodayForeground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_today_foreground(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TodayForeground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_blackout_foreground(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BlackoutForeground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_blackout_foreground(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BlackoutForeground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_foreground(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedForeground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_foreground(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedForeground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_out_of_scope_foreground(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OutOfScopeForeground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_out_of_scope_foreground(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OutOfScopeForeground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_calendar_item_foreground(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalendarItemForeground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_calendar_item_foreground(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CalendarItemForeground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_day_item_font_family(&self) -> Result<ComPtr<super::media::FontFamily>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DayItemFontFamily)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_day_item_font_family(&self, value: &super::media::FontFamily) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DayItemFontFamily)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_day_item_font_size(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DayItemFontSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_day_item_font_size(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DayItemFontSize)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_day_item_font_style(&self) -> Result<super::super::text::FontStyle> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DayItemFontStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_day_item_font_style(&self, value: super::super::text::FontStyle) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DayItemFontStyle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_day_item_font_weight(&self) -> Result<super::super::text::FontWeight> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DayItemFontWeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_day_item_font_weight(&self, value: super::super::text::FontWeight) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DayItemFontWeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_today_font_weight(&self) -> Result<super::super::text::FontWeight> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TodayFontWeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_today_font_weight(&self, value: super::super::text::FontWeight) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TodayFontWeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_first_of_month_label_font_family(&self) -> Result<ComPtr<super::media::FontFamily>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FirstOfMonthLabelFontFamily)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_first_of_month_label_font_family(&self, value: &super::media::FontFamily) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FirstOfMonthLabelFontFamily)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_first_of_month_label_font_size(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FirstOfMonthLabelFontSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_first_of_month_label_font_size(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FirstOfMonthLabelFontSize)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_first_of_month_label_font_style(&self) -> Result<super::super::text::FontStyle> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FirstOfMonthLabelFontStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_first_of_month_label_font_style(&self, value: super::super::text::FontStyle) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FirstOfMonthLabelFontStyle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_first_of_month_label_font_weight(&self) -> Result<super::super::text::FontWeight> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FirstOfMonthLabelFontWeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_first_of_month_label_font_weight(&self, value: super::super::text::FontWeight) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FirstOfMonthLabelFontWeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_month_year_item_font_family(&self) -> Result<ComPtr<super::media::FontFamily>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MonthYearItemFontFamily)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_month_year_item_font_family(&self, value: &super::media::FontFamily) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MonthYearItemFontFamily)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_month_year_item_font_size(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MonthYearItemFontSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_month_year_item_font_size(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MonthYearItemFontSize)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_month_year_item_font_style(&self) -> Result<super::super::text::FontStyle> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MonthYearItemFontStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_month_year_item_font_style(&self, value: super::super::text::FontStyle) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MonthYearItemFontStyle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_month_year_item_font_weight(&self) -> Result<super::super::text::FontWeight> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MonthYearItemFontWeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_month_year_item_font_weight(&self, value: super::super::text::FontWeight) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MonthYearItemFontWeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_first_of_year_decade_label_font_family(&self) -> Result<ComPtr<super::media::FontFamily>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FirstOfYearDecadeLabelFontFamily)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_first_of_year_decade_label_font_family(&self, value: &super::media::FontFamily) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FirstOfYearDecadeLabelFontFamily)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_first_of_year_decade_label_font_size(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FirstOfYearDecadeLabelFontSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_first_of_year_decade_label_font_size(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FirstOfYearDecadeLabelFontSize)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_first_of_year_decade_label_font_style(&self) -> Result<super::super::text::FontStyle> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FirstOfYearDecadeLabelFontStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_first_of_year_decade_label_font_style(&self, value: super::super::text::FontStyle) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FirstOfYearDecadeLabelFontStyle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_first_of_year_decade_label_font_weight(&self) -> Result<super::super::text::FontWeight> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FirstOfYearDecadeLabelFontWeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_first_of_year_decade_label_font_weight(&self, value: super::super::text::FontWeight) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FirstOfYearDecadeLabelFontWeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_day_item_alignment(&self) -> Result<super::HorizontalAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalDayItemAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_horizontal_day_item_alignment(&self, value: super::HorizontalAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HorizontalDayItemAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_day_item_alignment(&self) -> Result<super::VerticalAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalDayItemAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_vertical_day_item_alignment(&self, value: super::VerticalAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_VerticalDayItemAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_first_of_month_label_alignment(&self) -> Result<super::HorizontalAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalFirstOfMonthLabelAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_horizontal_first_of_month_label_alignment(&self, value: super::HorizontalAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HorizontalFirstOfMonthLabelAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_first_of_month_label_alignment(&self) -> Result<super::VerticalAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalFirstOfMonthLabelAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_vertical_first_of_month_label_alignment(&self, value: super::VerticalAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_VerticalFirstOfMonthLabelAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_calendar_item_border_thickness(&self) -> Result<super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CalendarItemBorderThickness)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_calendar_item_border_thickness(&self, value: super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CalendarItemBorderThickness)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_calendar_view_day_item_style(&self) -> Result<ComPtr<super::Style>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalendarViewDayItemStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_calendar_view_day_item_style(&self, value: &super::Style) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CalendarViewDayItemStyle)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_calendar_view_day_item_changing(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CalendarViewDayItemChanging)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_calendar_view_day_item_changing(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_CalendarViewDayItemChanging)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_selected_dates_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<CalendarView, CalendarViewSelectedDatesChangedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SelectedDatesChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_selected_dates_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SelectedDatesChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_date(&self, date: ::rt::gen::windows::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).SetDisplayDate)(self as *const _ as *mut _, date);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_year_decade_display_dimensions(&self, columns: i32, rows: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetYearDecadeDisplayDimensions)(self as *const _ as *mut _, columns, rows);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICalendarViewStatics, 1918955972, 12125, 16829, 153, 187, 69, 113, 178, 11, 121, 168);
RT_INTERFACE!{static interface ICalendarViewStatics(ICalendarViewStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICalendarViewStatics] {
    fn get_CalendarIdentifierProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DayOfWeekFormatProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsGroupLabelVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DisplayModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FirstDayOfWeekProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsOutOfScopeEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsTodayHighlightedProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MaxDateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MinDateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_NumberOfWeeksInViewProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectedDatesProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectionModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TemplateSettingsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FocusBorderBrushProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectedHoverBorderBrushProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectedPressedBorderBrushProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectedBorderBrushProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HoverBorderBrushProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PressedBorderBrushProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CalendarItemBorderBrushProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OutOfScopeBackgroundProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CalendarItemBackgroundProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PressedForegroundProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TodayForegroundProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_BlackoutForegroundProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectedForegroundProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OutOfScopeForegroundProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CalendarItemForegroundProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DayItemFontFamilyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DayItemFontSizeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DayItemFontStyleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DayItemFontWeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TodayFontWeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FirstOfMonthLabelFontFamilyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FirstOfMonthLabelFontSizeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FirstOfMonthLabelFontStyleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FirstOfMonthLabelFontWeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MonthYearItemFontFamilyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MonthYearItemFontSizeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MonthYearItemFontStyleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MonthYearItemFontWeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FirstOfYearDecadeLabelFontFamilyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FirstOfYearDecadeLabelFontSizeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FirstOfYearDecadeLabelFontStyleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FirstOfYearDecadeLabelFontWeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HorizontalDayItemAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_VerticalDayItemAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HorizontalFirstOfMonthLabelAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_VerticalFirstOfMonthLabelAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CalendarItemBorderThicknessProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CalendarViewDayItemStyleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ICalendarViewStatics {
    #[inline] pub unsafe fn get_calendar_identifier_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalendarIdentifierProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_day_of_week_format_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DayOfWeekFormatProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_group_label_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsGroupLabelVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_first_day_of_week_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FirstDayOfWeekProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_out_of_scope_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsOutOfScopeEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_today_highlighted_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsTodayHighlightedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_date_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxDateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_date_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MinDateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_number_of_weeks_in_view_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NumberOfWeeksInViewProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_dates_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedDatesProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_template_settings_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TemplateSettingsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_border_brush_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FocusBorderBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_hover_border_brush_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedHoverBorderBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_pressed_border_brush_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedPressedBorderBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_border_brush_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedBorderBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_hover_border_brush_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HoverBorderBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pressed_border_brush_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PressedBorderBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_calendar_item_border_brush_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalendarItemBorderBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_out_of_scope_background_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OutOfScopeBackgroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_calendar_item_background_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalendarItemBackgroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pressed_foreground_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PressedForegroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_today_foreground_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TodayForegroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_blackout_foreground_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BlackoutForegroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_foreground_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedForegroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_out_of_scope_foreground_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OutOfScopeForegroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_calendar_item_foreground_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalendarItemForegroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_day_item_font_family_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DayItemFontFamilyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_day_item_font_size_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DayItemFontSizeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_day_item_font_style_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DayItemFontStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_day_item_font_weight_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DayItemFontWeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_today_font_weight_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TodayFontWeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_first_of_month_label_font_family_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FirstOfMonthLabelFontFamilyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_first_of_month_label_font_size_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FirstOfMonthLabelFontSizeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_first_of_month_label_font_style_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FirstOfMonthLabelFontStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_first_of_month_label_font_weight_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FirstOfMonthLabelFontWeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_month_year_item_font_family_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MonthYearItemFontFamilyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_month_year_item_font_size_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MonthYearItemFontSizeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_month_year_item_font_style_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MonthYearItemFontStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_month_year_item_font_weight_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MonthYearItemFontWeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_first_of_year_decade_label_font_family_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FirstOfYearDecadeLabelFontFamilyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_first_of_year_decade_label_font_size_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FirstOfYearDecadeLabelFontSizeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_first_of_year_decade_label_font_style_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FirstOfYearDecadeLabelFontStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_first_of_year_decade_label_font_weight_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FirstOfYearDecadeLabelFontWeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_day_item_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HorizontalDayItemAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_day_item_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VerticalDayItemAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_first_of_month_label_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HorizontalFirstOfMonthLabelAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_first_of_month_label_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VerticalFirstOfMonthLabelAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_calendar_item_border_thickness_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalendarItemBorderThicknessProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_calendar_view_day_item_style_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalendarViewDayItemStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICalendarViewFactory, 1032815331, 27846, 16958, 141, 124, 112, 20, 217, 84, 221, 239);
RT_INTERFACE!{interface ICalendarViewFactory(ICalendarViewFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICalendarViewFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut CalendarView) -> HRESULT
}}
impl ICalendarViewFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<CalendarView>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICalendarViewDayItem, 266022341, 12993, 19343, 190, 252, 1, 123, 85, 91, 50, 210);
RT_INTERFACE!{interface ICalendarViewDayItem(ICalendarViewDayItemVtbl): IInspectable(IInspectableVtbl) [IID_ICalendarViewDayItem] {
    fn get_IsBlackout(&self, out: *mut bool) -> HRESULT,
    fn put_IsBlackout(&self, value: bool) -> HRESULT,
    fn get_Date(&self, out: *mut ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    #[cfg(feature="windows-ui")] fn SetDensityColors(&self, colors: *mut ::rt::gen::windows::foundation::collections::IIterable<super::super::Color>) -> HRESULT
}}
impl ICalendarViewDayItem {
    #[inline] pub unsafe fn get_is_blackout(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsBlackout)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_blackout(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsBlackout)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_date(&self) -> Result<::rt::gen::windows::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Date)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_density_colors(&self, colors: &::rt::gen::windows::foundation::collections::IIterable<super::super::Color>) -> Result<()> {
        let hr = ((*self.lpVtbl).SetDensityColors)(self as *const _ as *mut _, colors as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICalendarViewDayItemStatics, 3282164671, 48520, 18571, 185, 22, 208, 13, 105, 177, 115, 90);
RT_INTERFACE!{static interface ICalendarViewDayItemStatics(ICalendarViewDayItemStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICalendarViewDayItemStatics] {
    fn get_IsBlackoutProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ICalendarViewDayItemStatics {
    #[inline] pub unsafe fn get_is_blackout_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsBlackoutProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_date_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICalendarViewDayItemFactory, 1645292508, 7471, 20036, 155, 175, 22, 101, 116, 149, 33, 242);
RT_INTERFACE!{interface ICalendarViewDayItemFactory(ICalendarViewDayItemFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICalendarViewDayItemFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut CalendarViewDayItem) -> HRESULT
}}
impl ICalendarViewDayItemFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<CalendarViewDayItem>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDatePicker, 114964806, 2232, 16643, 139, 138, 9, 62, 253, 106, 118, 87);
RT_INTERFACE!{interface IDatePicker(IDatePickerVtbl): IInspectable(IInspectableVtbl) [IID_IDatePicker] {
    fn get_Header(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Header(&self, value: *mut IInspectable) -> HRESULT,
    fn get_HeaderTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_HeaderTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_CalendarIdentifier(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CalendarIdentifier(&self, value: HSTRING) -> HRESULT,
    fn get_Date(&self, out: *mut ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn put_Date(&self, value: ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn get_DayVisible(&self, out: *mut bool) -> HRESULT,
    fn put_DayVisible(&self, value: bool) -> HRESULT,
    fn get_MonthVisible(&self, out: *mut bool) -> HRESULT,
    fn put_MonthVisible(&self, value: bool) -> HRESULT,
    fn get_YearVisible(&self, out: *mut bool) -> HRESULT,
    fn put_YearVisible(&self, value: bool) -> HRESULT,
    fn get_DayFormat(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DayFormat(&self, value: HSTRING) -> HRESULT,
    fn get_MonthFormat(&self, out: *mut HSTRING) -> HRESULT,
    fn put_MonthFormat(&self, value: HSTRING) -> HRESULT,
    fn get_YearFormat(&self, out: *mut HSTRING) -> HRESULT,
    fn put_YearFormat(&self, value: HSTRING) -> HRESULT,
    fn get_MinYear(&self, out: *mut ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn put_MinYear(&self, value: ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn get_MaxYear(&self, out: *mut ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn put_MaxYear(&self, value: ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn get_Orientation(&self, out: *mut Orientation) -> HRESULT,
    fn put_Orientation(&self, value: Orientation) -> HRESULT,
    fn add_DateChanged(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<DatePickerValueChangedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DateChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IDatePicker {
    #[inline] pub unsafe fn get_header(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Header)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Header)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_calendar_identifier(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalendarIdentifier)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_calendar_identifier(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CalendarIdentifier)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_date(&self) -> Result<::rt::gen::windows::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Date)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_date(&self, value: ::rt::gen::windows::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Date)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_day_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DayVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_day_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DayVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_month_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MonthVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_month_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MonthVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_year_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_YearVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_year_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_YearVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_day_format(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DayFormat)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_day_format(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DayFormat)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_month_format(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MonthFormat)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_month_format(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MonthFormat)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_year_format(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_YearFormat)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_year_format(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_YearFormat)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_year(&self) -> Result<::rt::gen::windows::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinYear)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_min_year(&self, value: ::rt::gen::windows::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MinYear)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_year(&self) -> Result<::rt::gen::windows::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxYear)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_year(&self, value: ::rt::gen::windows::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxYear)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation(&self) -> Result<Orientation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Orientation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_orientation(&self, value: Orientation) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Orientation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_date_changed(&self, value: &::rt::gen::windows::foundation::EventHandler<DatePickerValueChangedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DateChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_date_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DateChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDatePickerStatics, 405699689, 8470, 19559, 181, 19, 113, 51, 100, 131, 29, 121);
RT_INTERFACE!{static interface IDatePickerStatics(IDatePickerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDatePickerStatics] {
    fn get_HeaderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HeaderTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CalendarIdentifierProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DayVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MonthVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_YearVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DayFormatProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MonthFormatProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_YearFormatProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MinYearProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MaxYearProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OrientationProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IDatePickerStatics {
    #[inline] pub unsafe fn get_header_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_calendar_identifier_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalendarIdentifierProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_date_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_day_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DayVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_month_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MonthVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_year_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_YearVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_day_format_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DayFormatProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_month_format_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MonthFormatProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_year_format_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_YearFormatProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_year_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MinYearProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_year_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxYearProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OrientationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDatePickerFactory, 4005808772, 39062, 19069, 187, 53, 111, 178, 30, 174, 202, 17);
RT_INTERFACE!{interface IDatePickerFactory(IDatePickerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IDatePickerFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut DatePicker) -> HRESULT
}}
impl IDatePickerFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<DatePicker>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDatePicker2, 3140007029, 11295, 17216, 158, 48, 148, 143, 153, 201, 229, 122);
RT_INTERFACE!{interface IDatePicker2(IDatePicker2Vtbl): IInspectable(IInspectableVtbl) [IID_IDatePicker2] {
    fn get_LightDismissOverlayMode(&self, out: *mut LightDismissOverlayMode) -> HRESULT,
    fn put_LightDismissOverlayMode(&self, value: LightDismissOverlayMode) -> HRESULT
}}
impl IDatePicker2 {
    #[inline] pub unsafe fn get_light_dismiss_overlay_mode(&self) -> Result<LightDismissOverlayMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LightDismissOverlayMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_light_dismiss_overlay_mode(&self, value: LightDismissOverlayMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LightDismissOverlayMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDatePickerStatics2, 4043795958, 64422, 17744, 139, 136, 166, 66, 8, 71, 246, 13);
RT_INTERFACE!{static interface IDatePickerStatics2(IDatePickerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IDatePickerStatics2] {
    fn get_LightDismissOverlayModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IDatePickerStatics2 {
    #[inline] pub unsafe fn get_light_dismiss_overlay_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LightDismissOverlayModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFontIcon, 3570799505, 14764, 18768, 145, 102, 54, 6, 194, 100, 65, 139);
RT_INTERFACE!{interface IFontIcon(IFontIconVtbl): IInspectable(IInspectableVtbl) [IID_IFontIcon] {
    fn get_Glyph(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Glyph(&self, value: HSTRING) -> HRESULT,
    fn get_FontSize(&self, out: *mut f64) -> HRESULT,
    fn put_FontSize(&self, value: f64) -> HRESULT,
    fn get_FontFamily(&self, out: *mut *mut super::media::FontFamily) -> HRESULT,
    fn put_FontFamily(&self, value: *mut super::media::FontFamily) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_FontWeight(&self, out: *mut super::super::text::FontWeight) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_FontWeight(&self, value: super::super::text::FontWeight) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_FontStyle(&self, out: *mut super::super::text::FontStyle) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_FontStyle(&self, value: super::super::text::FontStyle) -> HRESULT
}}
impl IFontIcon {
    #[inline] pub unsafe fn get_glyph(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Glyph)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_glyph(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Glyph)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_size(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_font_size(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontSize)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_family(&self) -> Result<ComPtr<super::media::FontFamily>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontFamily)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_font_family(&self, value: &super::media::FontFamily) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontFamily)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_font_weight(&self) -> Result<super::super::text::FontWeight> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontWeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_font_weight(&self, value: super::super::text::FontWeight) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontWeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_font_style(&self) -> Result<super::super::text::FontStyle> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_font_style(&self, value: super::super::text::FontStyle) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontStyle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFontIconStatics, 3015605238, 5223, 16518, 187, 203, 78, 33, 217, 122, 123, 77);
RT_INTERFACE!{static interface IFontIconStatics(IFontIconStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IFontIconStatics] {
    fn get_GlyphProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontSizeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontFamilyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontWeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontStyleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IFontIconStatics {
    #[inline] pub unsafe fn get_glyph_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GlyphProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_size_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontSizeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_family_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontFamilyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_weight_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontWeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_style_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFontIconFactory, 477633387, 14271, 19932, 161, 168, 27, 119, 219, 60, 240, 234);
RT_INTERFACE!{interface IFontIconFactory(IFontIconFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IFontIconFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut FontIcon) -> HRESULT
}}
impl IFontIconFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<FontIcon>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFontIcon2, 4142651469, 14312, 18158, 165, 116, 65, 173, 85, 4, 130, 224);
RT_INTERFACE!{interface IFontIcon2(IFontIcon2Vtbl): IInspectable(IInspectableVtbl) [IID_IFontIcon2] {
    fn get_IsTextScaleFactorEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsTextScaleFactorEnabled(&self, value: bool) -> HRESULT
}}
impl IFontIcon2 {
    #[inline] pub unsafe fn get_is_text_scale_factor_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTextScaleFactorEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_text_scale_factor_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsTextScaleFactorEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFontIconStatics2, 3859285618, 2296, 17363, 135, 144, 70, 4, 41, 12, 190, 189);
RT_INTERFACE!{static interface IFontIconStatics2(IFontIconStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IFontIconStatics2] {
    fn get_IsTextScaleFactorEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IFontIconStatics2 {
    #[inline] pub unsafe fn get_is_text_scale_factor_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsTextScaleFactorEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFontIcon3, 1633016089, 7276, 18768, 135, 148, 35, 30, 240, 145, 77, 148);
RT_INTERFACE!{interface IFontIcon3(IFontIcon3Vtbl): IInspectable(IInspectableVtbl) [IID_IFontIcon3] {
    fn get_MirroredWhenRightToLeft(&self, out: *mut bool) -> HRESULT,
    fn put_MirroredWhenRightToLeft(&self, value: bool) -> HRESULT
}}
impl IFontIcon3 {
    #[inline] pub unsafe fn get_mirrored_when_right_to_left(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MirroredWhenRightToLeft)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_mirrored_when_right_to_left(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MirroredWhenRightToLeft)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFontIconStatics3, 2756872983, 45188, 19413, 170, 180, 254, 174, 157, 59, 93, 38);
RT_INTERFACE!{static interface IFontIconStatics3(IFontIconStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IFontIconStatics3] {
    fn get_MirroredWhenRightToLeftProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IFontIconStatics3 {
    #[inline] pub unsafe fn get_mirrored_when_right_to_left_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MirroredWhenRightToLeftProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IHub, 2926128770, 29460, 20305, 171, 17, 42, 241, 237, 74, 25, 248);
RT_INTERFACE!{interface IHub(IHubVtbl): IInspectable(IInspectableVtbl) [IID_IHub] {
    fn get_Header(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Header(&self, value: *mut IInspectable) -> HRESULT,
    fn get_HeaderTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_HeaderTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_Orientation(&self, out: *mut Orientation) -> HRESULT,
    fn put_Orientation(&self, value: Orientation) -> HRESULT,
    fn get_DefaultSectionIndex(&self, out: *mut i32) -> HRESULT,
    fn put_DefaultSectionIndex(&self, value: i32) -> HRESULT,
    fn get_Sections(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<HubSection>) -> HRESULT,
    fn get_SectionsInView(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<HubSection>) -> HRESULT,
    fn get_SectionHeaders(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IObservableVector<IInspectable>) -> HRESULT,
    fn add_SectionHeaderClick(&self, value: *mut HubSectionHeaderClickEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SectionHeaderClick(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_SectionsInViewChanged(&self, value: *mut SectionsInViewChangedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SectionsInViewChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn ScrollToSection(&self, section: *mut HubSection) -> HRESULT
}}
impl IHub {
    #[inline] pub unsafe fn get_header(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Header)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Header)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation(&self) -> Result<Orientation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Orientation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_orientation(&self, value: Orientation) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Orientation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_default_section_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DefaultSectionIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_default_section_index(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DefaultSectionIndex)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sections(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<HubSection>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Sections)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sections_in_view(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<HubSection>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SectionsInView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_section_headers(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IObservableVector<IInspectable>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SectionHeaders)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_section_header_click(&self, value: &HubSectionHeaderClickEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SectionHeaderClick)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_section_header_click(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SectionHeaderClick)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_sections_in_view_changed(&self, value: &SectionsInViewChangedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SectionsInViewChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_sections_in_view_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SectionsInViewChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn scroll_to_section(&self, section: &HubSection) -> Result<()> {
        let hr = ((*self.lpVtbl).ScrollToSection)(self as *const _ as *mut _, section as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IHubStatics, 242196532, 44348, 20274, 183, 1, 226, 79, 171, 86, 32, 40);
RT_INTERFACE!{static interface IHubStatics(IHubStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IHubStatics] {
    fn get_HeaderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HeaderTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OrientationProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DefaultSectionIndexProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SemanticZoomOwnerProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsActiveViewProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsZoomedInViewProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IHubStatics {
    #[inline] pub unsafe fn get_header_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OrientationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_default_section_index_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DefaultSectionIndexProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_semantic_zoom_owner_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SemanticZoomOwnerProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_active_view_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsActiveViewProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_zoomed_in_view_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsZoomedInViewProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IHubFactory, 3701912250, 50933, 18785, 153, 83, 197, 24, 115, 219, 84, 36);
RT_INTERFACE!{interface IHubFactory(IHubFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IHubFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut Hub) -> HRESULT
}}
impl IHubFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<Hub>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IHubSection, 2766564535, 32733, 20448, 171, 73, 194, 70, 99, 157, 204, 249);
RT_INTERFACE!{interface IHubSection(IHubSectionVtbl): IInspectable(IInspectableVtbl) [IID_IHubSection] {
    fn get_Header(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Header(&self, value: *mut IInspectable) -> HRESULT,
    fn get_HeaderTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_HeaderTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_ContentTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_ContentTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_IsHeaderInteractive(&self, out: *mut bool) -> HRESULT,
    fn put_IsHeaderInteractive(&self, value: bool) -> HRESULT
}}
impl IHubSection {
    #[inline] pub unsafe fn get_header(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Header)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Header)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_header_interactive(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsHeaderInteractive)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_header_interactive(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsHeaderInteractive)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IHubSectionStatics, 315807834, 59943, 17105, 153, 139, 97, 229, 42, 237, 132, 43);
RT_INTERFACE!{static interface IHubSectionStatics(IHubSectionStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IHubSectionStatics] {
    fn get_HeaderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HeaderTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ContentTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsHeaderInteractiveProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IHubSectionStatics {
    #[inline] pub unsafe fn get_header_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_header_interactive_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsHeaderInteractiveProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IHubSectionFactory, 4294270882, 60644, 19386, 170, 59, 152, 4, 174, 244, 120, 131);
RT_INTERFACE!{interface IHubSectionFactory(IHubSectionFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IHubSectionFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut HubSection) -> HRESULT
}}
impl IHubSectionFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<HubSection>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemsStackPanel, 3749361565, 31445, 19288, 147, 99, 145, 154, 249, 2, 38, 230);
RT_INTERFACE!{interface IItemsStackPanel(IItemsStackPanelVtbl): IInspectable(IInspectableVtbl) [IID_IItemsStackPanel] {
    fn get_GroupPadding(&self, out: *mut super::Thickness) -> HRESULT,
    fn put_GroupPadding(&self, value: super::Thickness) -> HRESULT,
    fn get_Orientation(&self, out: *mut Orientation) -> HRESULT,
    fn put_Orientation(&self, value: Orientation) -> HRESULT,
    fn get_FirstCacheIndex(&self, out: *mut i32) -> HRESULT,
    fn get_FirstVisibleIndex(&self, out: *mut i32) -> HRESULT,
    fn get_LastVisibleIndex(&self, out: *mut i32) -> HRESULT,
    fn get_LastCacheIndex(&self, out: *mut i32) -> HRESULT,
    fn get_ScrollingDirection(&self, out: *mut PanelScrollingDirection) -> HRESULT,
    fn get_GroupHeaderPlacement(&self, out: *mut primitives::GroupHeaderPlacement) -> HRESULT,
    fn put_GroupHeaderPlacement(&self, value: primitives::GroupHeaderPlacement) -> HRESULT,
    fn get_ItemsUpdatingScrollMode(&self, out: *mut ItemsUpdatingScrollMode) -> HRESULT,
    fn put_ItemsUpdatingScrollMode(&self, value: ItemsUpdatingScrollMode) -> HRESULT,
    fn get_CacheLength(&self, out: *mut f64) -> HRESULT,
    fn put_CacheLength(&self, value: f64) -> HRESULT
}}
impl IItemsStackPanel {
    #[inline] pub unsafe fn get_group_padding(&self) -> Result<super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_GroupPadding)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_group_padding(&self, value: super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_GroupPadding)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation(&self) -> Result<Orientation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Orientation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_orientation(&self, value: Orientation) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Orientation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_first_cache_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FirstCacheIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_first_visible_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FirstVisibleIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_last_visible_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LastVisibleIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_last_cache_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LastCacheIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scrolling_direction(&self) -> Result<PanelScrollingDirection> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScrollingDirection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_group_header_placement(&self) -> Result<primitives::GroupHeaderPlacement> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_GroupHeaderPlacement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_group_header_placement(&self, value: primitives::GroupHeaderPlacement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_GroupHeaderPlacement)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_items_updating_scroll_mode(&self) -> Result<ItemsUpdatingScrollMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ItemsUpdatingScrollMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_items_updating_scroll_mode(&self, value: ItemsUpdatingScrollMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemsUpdatingScrollMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_cache_length(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CacheLength)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_cache_length(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CacheLength)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemsStackPanelStatics, 3391477311, 1103, 19307, 179, 21, 11, 96, 224, 180, 248, 125);
RT_INTERFACE!{static interface IItemsStackPanelStatics(IItemsStackPanelStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IItemsStackPanelStatics] {
    fn get_GroupPaddingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OrientationProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_GroupHeaderPlacementProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CacheLengthProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IItemsStackPanelStatics {
    #[inline] pub unsafe fn get_group_padding_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GroupPaddingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OrientationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_group_header_placement_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GroupHeaderPlacementProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_cache_length_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CacheLengthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemsStackPanel2, 4008627632, 180, 17716, 147, 123, 86, 49, 139, 41, 62, 146);
RT_INTERFACE!{interface IItemsStackPanel2(IItemsStackPanel2Vtbl): IInspectable(IInspectableVtbl) [IID_IItemsStackPanel2] {
    fn get_AreStickyGroupHeadersEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_AreStickyGroupHeadersEnabled(&self, value: bool) -> HRESULT
}}
impl IItemsStackPanel2 {
    #[inline] pub unsafe fn get_are_sticky_group_headers_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AreStickyGroupHeadersEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_are_sticky_group_headers_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AreStickyGroupHeadersEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemsStackPanelStatics2, 963832620, 14410, 18623, 173, 253, 119, 46, 37, 114, 197, 4);
RT_INTERFACE!{static interface IItemsStackPanelStatics2(IItemsStackPanelStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IItemsStackPanelStatics2] {
    fn get_AreStickyGroupHeadersEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IItemsStackPanelStatics2 {
    #[inline] pub unsafe fn get_are_sticky_group_headers_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AreStickyGroupHeadersEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemsWrapGrid, 3724438367, 47752, 19069, 138, 91, 229, 140, 175, 15, 78, 45);
RT_INTERFACE!{interface IItemsWrapGrid(IItemsWrapGridVtbl): IInspectable(IInspectableVtbl) [IID_IItemsWrapGrid] {
    fn get_GroupPadding(&self, out: *mut super::Thickness) -> HRESULT,
    fn put_GroupPadding(&self, value: super::Thickness) -> HRESULT,
    fn get_Orientation(&self, out: *mut Orientation) -> HRESULT,
    fn put_Orientation(&self, value: Orientation) -> HRESULT,
    fn get_MaximumRowsOrColumns(&self, out: *mut i32) -> HRESULT,
    fn put_MaximumRowsOrColumns(&self, value: i32) -> HRESULT,
    fn get_ItemWidth(&self, out: *mut f64) -> HRESULT,
    fn put_ItemWidth(&self, value: f64) -> HRESULT,
    fn get_ItemHeight(&self, out: *mut f64) -> HRESULT,
    fn put_ItemHeight(&self, value: f64) -> HRESULT,
    fn get_FirstCacheIndex(&self, out: *mut i32) -> HRESULT,
    fn get_FirstVisibleIndex(&self, out: *mut i32) -> HRESULT,
    fn get_LastVisibleIndex(&self, out: *mut i32) -> HRESULT,
    fn get_LastCacheIndex(&self, out: *mut i32) -> HRESULT,
    fn get_ScrollingDirection(&self, out: *mut PanelScrollingDirection) -> HRESULT,
    fn get_GroupHeaderPlacement(&self, out: *mut primitives::GroupHeaderPlacement) -> HRESULT,
    fn put_GroupHeaderPlacement(&self, value: primitives::GroupHeaderPlacement) -> HRESULT,
    fn get_CacheLength(&self, out: *mut f64) -> HRESULT,
    fn put_CacheLength(&self, value: f64) -> HRESULT
}}
impl IItemsWrapGrid {
    #[inline] pub unsafe fn get_group_padding(&self) -> Result<super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_GroupPadding)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_group_padding(&self, value: super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_GroupPadding)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation(&self) -> Result<Orientation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Orientation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_orientation(&self, value: Orientation) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Orientation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_maximum_rows_or_columns(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaximumRowsOrColumns)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_maximum_rows_or_columns(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaximumRowsOrColumns)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ItemWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_item_width(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemWidth)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ItemHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_item_height(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemHeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_first_cache_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FirstCacheIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_first_visible_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FirstVisibleIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_last_visible_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LastVisibleIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_last_cache_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LastCacheIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scrolling_direction(&self) -> Result<PanelScrollingDirection> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScrollingDirection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_group_header_placement(&self) -> Result<primitives::GroupHeaderPlacement> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_GroupHeaderPlacement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_group_header_placement(&self, value: primitives::GroupHeaderPlacement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_GroupHeaderPlacement)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_cache_length(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CacheLength)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_cache_length(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CacheLength)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemsWrapGridStatics, 1321550461, 9376, 17562, 183, 99, 48, 119, 186, 15, 45, 213);
RT_INTERFACE!{static interface IItemsWrapGridStatics(IItemsWrapGridStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IItemsWrapGridStatics] {
    fn get_GroupPaddingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OrientationProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MaximumRowsOrColumnsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ItemWidthProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ItemHeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_GroupHeaderPlacementProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CacheLengthProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IItemsWrapGridStatics {
    #[inline] pub unsafe fn get_group_padding_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GroupPaddingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OrientationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_maximum_rows_or_columns_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaximumRowsOrColumnsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_width_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemWidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_height_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_group_header_placement_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GroupHeaderPlacementProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_cache_length_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CacheLengthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemsWrapGrid2, 2160204815, 25580, 16984, 189, 97, 212, 166, 149, 108, 134, 74);
RT_INTERFACE!{interface IItemsWrapGrid2(IItemsWrapGrid2Vtbl): IInspectable(IInspectableVtbl) [IID_IItemsWrapGrid2] {
    fn get_AreStickyGroupHeadersEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_AreStickyGroupHeadersEnabled(&self, value: bool) -> HRESULT
}}
impl IItemsWrapGrid2 {
    #[inline] pub unsafe fn get_are_sticky_group_headers_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AreStickyGroupHeadersEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_are_sticky_group_headers_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AreStickyGroupHeadersEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemsWrapGridStatics2, 774362103, 65194, 18317, 191, 209, 41, 51, 138, 220, 90, 3);
RT_INTERFACE!{static interface IItemsWrapGridStatics2(IItemsWrapGridStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IItemsWrapGridStatics2] {
    fn get_AreStickyGroupHeadersEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IItemsWrapGridStatics2 {
    #[inline] pub unsafe fn get_are_sticky_group_headers_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AreStickyGroupHeadersEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMediaPlayerElement, 994878758, 11813, 17816, 188, 113, 212, 145, 248, 232, 222, 57);
RT_INTERFACE!{interface IMediaPlayerElement(IMediaPlayerElementVtbl): IInspectable(IInspectableVtbl) [IID_IMediaPlayerElement] {
    #[cfg(feature="windows-media")] fn get_Source(&self, out: *mut *mut ::rt::gen::windows::media::playback::IMediaPlaybackSource) -> HRESULT,
    #[cfg(feature="windows-media")] fn put_Source(&self, value: *mut ::rt::gen::windows::media::playback::IMediaPlaybackSource) -> HRESULT,
    fn get_TransportControls(&self, out: *mut *mut MediaTransportControls) -> HRESULT,
    fn put_TransportControls(&self, value: *mut MediaTransportControls) -> HRESULT,
    fn get_AreTransportControlsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_AreTransportControlsEnabled(&self, value: bool) -> HRESULT,
    fn get_PosterSource(&self, out: *mut *mut super::media::ImageSource) -> HRESULT,
    fn put_PosterSource(&self, value: *mut super::media::ImageSource) -> HRESULT,
    fn get_Stretch(&self, out: *mut super::media::Stretch) -> HRESULT,
    fn put_Stretch(&self, value: super::media::Stretch) -> HRESULT,
    fn get_AutoPlay(&self, out: *mut bool) -> HRESULT,
    fn put_AutoPlay(&self, value: bool) -> HRESULT,
    fn get_IsFullWindow(&self, out: *mut bool) -> HRESULT,
    fn put_IsFullWindow(&self, value: bool) -> HRESULT,
    #[cfg(feature="windows-media")] fn get_MediaPlayer(&self, out: *mut *mut ::rt::gen::windows::media::playback::MediaPlayer) -> HRESULT,
    #[cfg(feature="windows-media")] fn SetMediaPlayer(&self, mediaPlayer: *mut ::rt::gen::windows::media::playback::MediaPlayer) -> HRESULT
}}
impl IMediaPlayerElement {
    #[cfg(feature="windows-media")] #[inline] pub unsafe fn get_source(&self) -> Result<ComPtr<::rt::gen::windows::media::playback::IMediaPlaybackSource>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Source)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-media")] #[inline] pub unsafe fn set_source(&self, value: &::rt::gen::windows::media::playback::IMediaPlaybackSource) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Source)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transport_controls(&self) -> Result<ComPtr<MediaTransportControls>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransportControls)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_transport_controls(&self, value: &MediaTransportControls) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TransportControls)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_are_transport_controls_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AreTransportControlsEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_are_transport_controls_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AreTransportControlsEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_poster_source(&self) -> Result<ComPtr<super::media::ImageSource>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PosterSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_poster_source(&self, value: &super::media::ImageSource) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PosterSource)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stretch(&self) -> Result<super::media::Stretch> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Stretch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stretch(&self, value: super::media::Stretch) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Stretch)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_auto_play(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AutoPlay)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_auto_play(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AutoPlay)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_full_window(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsFullWindow)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_full_window(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsFullWindow)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-media")] #[inline] pub unsafe fn get_media_player(&self) -> Result<ComPtr<::rt::gen::windows::media::playback::MediaPlayer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MediaPlayer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-media")] #[inline] pub unsafe fn set_media_player(&self, mediaPlayer: &::rt::gen::windows::media::playback::MediaPlayer) -> Result<()> {
        let hr = ((*self.lpVtbl).SetMediaPlayer)(self as *const _ as *mut _, mediaPlayer as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMediaPlayerElementStatics, 511459360, 44119, 17117, 173, 28, 62, 188, 45, 127, 8, 186);
RT_INTERFACE!{static interface IMediaPlayerElementStatics(IMediaPlayerElementStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMediaPlayerElementStatics] {
    fn get_SourceProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_AreTransportControlsEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PosterSourceProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_StretchProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_AutoPlayProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsFullWindowProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MediaPlayerProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IMediaPlayerElementStatics {
    #[inline] pub unsafe fn get_source_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourceProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_are_transport_controls_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AreTransportControlsEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_poster_source_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PosterSourceProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stretch_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StretchProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_auto_play_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AutoPlayProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_full_window_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsFullWindowProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_media_player_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MediaPlayerProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMediaPlayerElementFactory, 2011506115, 60183, 19341, 136, 157, 30, 168, 171, 219, 212, 239);
RT_INTERFACE!{interface IMediaPlayerElementFactory(IMediaPlayerElementFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMediaPlayerElementFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut MediaPlayerElement) -> HRESULT
}}
impl IMediaPlayerElementFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<MediaPlayerElement>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMenuFlyoutItemBase, 4189413447, 36262, 18224, 146, 8, 20, 65, 37, 198, 179, 150);
RT_INTERFACE!{interface IMenuFlyoutItemBase(IMenuFlyoutItemBaseVtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutItemBase] {
    
}}
DEFINE_IID!(IID_IMenuFlyoutItemBaseFactory, 2212944813, 64615, 16853, 135, 151, 96, 172, 209, 206, 177, 217);
RT_INTERFACE!{interface IMenuFlyoutItemBaseFactory(IMenuFlyoutItemBaseFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutItemBaseFactory] {
    
}}
DEFINE_IID!(IID_IPathIcon, 558654171, 50022, 18958, 185, 173, 220, 241, 104, 215, 236, 12);
RT_INTERFACE!{interface IPathIcon(IPathIconVtbl): IInspectable(IInspectableVtbl) [IID_IPathIcon] {
    fn get_Data(&self, out: *mut *mut super::media::Geometry) -> HRESULT,
    fn put_Data(&self, value: *mut super::media::Geometry) -> HRESULT
}}
impl IPathIcon {
    #[inline] pub unsafe fn get_data(&self) -> Result<ComPtr<super::media::Geometry>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Data)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_data(&self, value: &super::media::Geometry) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Data)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPathIconStatics, 2008505784, 64277, 18714, 182, 227, 125, 187, 169, 17, 186, 254);
RT_INTERFACE!{static interface IPathIconStatics(IPathIconStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPathIconStatics] {
    fn get_DataProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IPathIconStatics {
    #[inline] pub unsafe fn get_data_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DataProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPathIconFactory, 2946340434, 40029, 18999, 158, 26, 4, 74, 190, 239, 121, 43);
RT_INTERFACE!{interface IPathIconFactory(IPathIconFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPathIconFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut PathIcon) -> HRESULT
}}
impl IPathIconFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<PathIcon>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichEditBox, 2426763840, 32950, 20430, 177, 236, 227, 198, 22, 40, 75, 106);
RT_INTERFACE!{interface IRichEditBox(IRichEditBoxVtbl): IInspectable(IInspectableVtbl) [IID_IRichEditBox] {
    fn get_IsReadOnly(&self, out: *mut bool) -> HRESULT,
    fn put_IsReadOnly(&self, value: bool) -> HRESULT,
    fn get_AcceptsReturn(&self, out: *mut bool) -> HRESULT,
    fn put_AcceptsReturn(&self, value: bool) -> HRESULT,
    fn get_TextAlignment(&self, out: *mut super::TextAlignment) -> HRESULT,
    fn put_TextAlignment(&self, value: super::TextAlignment) -> HRESULT,
    fn get_TextWrapping(&self, out: *mut super::TextWrapping) -> HRESULT,
    fn put_TextWrapping(&self, value: super::TextWrapping) -> HRESULT,
    fn get_IsSpellCheckEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsSpellCheckEnabled(&self, value: bool) -> HRESULT,
    fn get_IsTextPredictionEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsTextPredictionEnabled(&self, value: bool) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy12(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Document(&self, out: *mut *mut super::super::text::ITextDocument) -> HRESULT,
    fn get_InputScope(&self, out: *mut *mut super::input::InputScope) -> HRESULT,
    fn put_InputScope(&self, value: *mut super::input::InputScope) -> HRESULT,
    fn add_TextChanged(&self, value: *mut super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TextChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_SelectionChanged(&self, value: *mut super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SelectionChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ContextMenuOpening(&self, value: *mut ContextMenuOpeningEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ContextMenuOpening(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IRichEditBox {
    #[inline] pub unsafe fn get_is_read_only(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsReadOnly)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_read_only(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsReadOnly)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_accepts_return(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AcceptsReturn)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_accepts_return(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AcceptsReturn)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_alignment(&self) -> Result<super::TextAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_alignment(&self, value: super::TextAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_wrapping(&self) -> Result<super::TextWrapping> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextWrapping)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_wrapping(&self, value: super::TextWrapping) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextWrapping)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_spell_check_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSpellCheckEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_spell_check_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSpellCheckEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_text_prediction_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTextPredictionEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_text_prediction_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsTextPredictionEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_document(&self) -> Result<ComPtr<super::super::text::ITextDocument>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Document)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_input_scope(&self) -> Result<ComPtr<super::input::InputScope>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InputScope)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_input_scope(&self, value: &super::input::InputScope) -> Result<()> {
        let hr = ((*self.lpVtbl).put_InputScope)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_text_changed(&self, value: &super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TextChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_text_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_TextChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_selection_changed(&self, value: &super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SelectionChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_selection_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SelectionChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_context_menu_opening(&self, value: &ContextMenuOpeningEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ContextMenuOpening)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_context_menu_opening(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ContextMenuOpening)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichEditBoxStatics, 4125112948, 35050, 18331, 154, 5, 55, 8, 159, 243, 14, 222);
RT_INTERFACE!{static interface IRichEditBoxStatics(IRichEditBoxStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRichEditBoxStatics] {
    fn get_IsReadOnlyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_AcceptsReturnProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextWrappingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsSpellCheckEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsTextPredictionEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_InputScopeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IRichEditBoxStatics {
    #[inline] pub unsafe fn get_is_read_only_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsReadOnlyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_accepts_return_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AcceptsReturnProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_wrapping_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextWrappingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_spell_check_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsSpellCheckEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_text_prediction_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsTextPredictionEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_input_scope_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InputScopeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichEditBoxFactory, 1637998434, 10246, 16877, 136, 237, 174, 33, 244, 122, 180, 34);
RT_INTERFACE!{interface IRichEditBoxFactory(IRichEditBoxFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IRichEditBoxFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut RichEditBox) -> HRESULT
}}
impl IRichEditBoxFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<RichEditBox>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichEditBox2, 3152703149, 59397, 18340, 187, 231, 71, 229, 155, 143, 116, 167);
RT_INTERFACE!{interface IRichEditBox2(IRichEditBox2Vtbl): IInspectable(IInspectableVtbl) [IID_IRichEditBox2] {
    fn get_Header(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Header(&self, value: *mut IInspectable) -> HRESULT,
    fn get_HeaderTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_HeaderTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_PlaceholderText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PlaceholderText(&self, value: HSTRING) -> HRESULT,
    fn get_SelectionHighlightColor(&self, out: *mut *mut super::media::SolidColorBrush) -> HRESULT,
    fn put_SelectionHighlightColor(&self, value: *mut super::media::SolidColorBrush) -> HRESULT,
    fn get_PreventKeyboardDisplayOnProgrammaticFocus(&self, out: *mut bool) -> HRESULT,
    fn put_PreventKeyboardDisplayOnProgrammaticFocus(&self, value: bool) -> HRESULT,
    fn get_IsColorFontEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsColorFontEnabled(&self, value: bool) -> HRESULT,
    fn add_Paste(&self, value: *mut TextControlPasteEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Paste(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IRichEditBox2 {
    #[inline] pub unsafe fn get_header(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Header)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Header)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placeholder_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlaceholderText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_placeholder_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PlaceholderText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_highlight_color(&self) -> Result<ComPtr<super::media::SolidColorBrush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionHighlightColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selection_highlight_color(&self, value: &super::media::SolidColorBrush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectionHighlightColor)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_prevent_keyboard_display_on_programmatic_focus(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PreventKeyboardDisplayOnProgrammaticFocus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_prevent_keyboard_display_on_programmatic_focus(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PreventKeyboardDisplayOnProgrammaticFocus)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_color_font_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsColorFontEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_color_font_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsColorFontEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_paste(&self, value: &TextControlPasteEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Paste)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_paste(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Paste)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichEditBoxStatics2, 3823838942, 10056, 16907, 177, 252, 206, 149, 182, 232, 94, 236);
RT_INTERFACE!{static interface IRichEditBoxStatics2(IRichEditBoxStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IRichEditBoxStatics2] {
    fn get_HeaderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HeaderTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PlaceholderTextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectionHighlightColorProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PreventKeyboardDisplayOnProgrammaticFocusProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsColorFontEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IRichEditBoxStatics2 {
    #[inline] pub unsafe fn get_header_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placeholder_text_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlaceholderTextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_highlight_color_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionHighlightColorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_prevent_keyboard_display_on_programmatic_focus_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PreventKeyboardDisplayOnProgrammaticFocusProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_color_font_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsColorFontEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichEditBox3, 1796711522, 64438, 20479, 153, 145, 147, 153, 203, 156, 11, 144);
RT_INTERFACE!{interface IRichEditBox3(IRichEditBox3Vtbl): IInspectable(IInspectableVtbl) [IID_IRichEditBox3] {
    fn add_TextCompositionStarted(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<RichEditBox, TextCompositionStartedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TextCompositionStarted(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_TextCompositionChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<RichEditBox, TextCompositionChangedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TextCompositionChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_TextCompositionEnded(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<RichEditBox, TextCompositionEndedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TextCompositionEnded(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn get_TextReadingOrder(&self, out: *mut super::TextReadingOrder) -> HRESULT,
    fn put_TextReadingOrder(&self, value: super::TextReadingOrder) -> HRESULT,
    fn get_DesiredCandidateWindowAlignment(&self, out: *mut CandidateWindowAlignment) -> HRESULT,
    fn put_DesiredCandidateWindowAlignment(&self, value: CandidateWindowAlignment) -> HRESULT,
    fn add_CandidateWindowBoundsChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<RichEditBox, CandidateWindowBoundsChangedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CandidateWindowBoundsChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_TextChanging(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<RichEditBox, RichEditBoxTextChangingEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TextChanging(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IRichEditBox3 {
    #[inline] pub unsafe fn add_text_composition_started(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<RichEditBox, TextCompositionStartedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TextCompositionStarted)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_text_composition_started(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_TextCompositionStarted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_text_composition_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<RichEditBox, TextCompositionChangedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TextCompositionChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_text_composition_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_TextCompositionChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_text_composition_ended(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<RichEditBox, TextCompositionEndedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TextCompositionEnded)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_text_composition_ended(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_TextCompositionEnded)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_reading_order(&self) -> Result<super::TextReadingOrder> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextReadingOrder)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_reading_order(&self, value: super::TextReadingOrder) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextReadingOrder)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_desired_candidate_window_alignment(&self) -> Result<CandidateWindowAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DesiredCandidateWindowAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_desired_candidate_window_alignment(&self, value: CandidateWindowAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DesiredCandidateWindowAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_candidate_window_bounds_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<RichEditBox, CandidateWindowBoundsChangedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CandidateWindowBoundsChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_candidate_window_bounds_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_CandidateWindowBoundsChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_text_changing(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<RichEditBox, RichEditBoxTextChangingEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TextChanging)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_text_changing(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_TextChanging)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichEditBoxStatics3, 1830284997, 8115, 19595, 170, 35, 245, 225, 93, 106, 182, 78);
RT_INTERFACE!{static interface IRichEditBoxStatics3(IRichEditBoxStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IRichEditBoxStatics3] {
    fn get_DesiredCandidateWindowAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextReadingOrderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IRichEditBoxStatics3 {
    #[inline] pub unsafe fn get_desired_candidate_window_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DesiredCandidateWindowAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_reading_order_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextReadingOrderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichEditBox4, 1554681141, 51256, 19373, 160, 124, 32, 65, 131, 187, 117, 31);
RT_INTERFACE!{interface IRichEditBox4(IRichEditBox4Vtbl): IInspectable(IInspectableVtbl) [IID_IRichEditBox4] {
    fn GetLinguisticAlternativesAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<HString>>) -> HRESULT,
    fn get_ClipboardCopyFormat(&self, out: *mut RichEditClipboardFormat) -> HRESULT,
    fn put_ClipboardCopyFormat(&self, value: RichEditClipboardFormat) -> HRESULT
}}
impl IRichEditBox4 {
    #[inline] pub unsafe fn get_linguistic_alternatives_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<HString>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetLinguisticAlternativesAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_clipboard_copy_format(&self) -> Result<RichEditClipboardFormat> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ClipboardCopyFormat)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_clipboard_copy_format(&self, value: RichEditClipboardFormat) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ClipboardCopyFormat)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichEditBoxStatics4, 4124397527, 30614, 17061, 165, 229, 44, 210, 17, 238, 129, 118);
RT_INTERFACE!{static interface IRichEditBoxStatics4(IRichEditBoxStatics4Vtbl): IInspectable(IInspectableVtbl) [IID_IRichEditBoxStatics4] {
    fn get_ClipboardCopyFormatProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IRichEditBoxStatics4 {
    #[inline] pub unsafe fn get_clipboard_copy_format_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ClipboardCopyFormatProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichEditBox5, 2792201450, 25489, 20283, 159, 211, 31, 208, 31, 73, 243, 39);
RT_INTERFACE!{interface IRichEditBox5(IRichEditBox5Vtbl): IInspectable(IInspectableVtbl) [IID_IRichEditBox5] {
    fn get_SelectionHighlightColorWhenNotFocused(&self, out: *mut *mut super::media::SolidColorBrush) -> HRESULT,
    fn put_SelectionHighlightColorWhenNotFocused(&self, value: *mut super::media::SolidColorBrush) -> HRESULT,
    fn get_MaxLength(&self, out: *mut i32) -> HRESULT,
    fn put_MaxLength(&self, value: i32) -> HRESULT
}}
impl IRichEditBox5 {
    #[inline] pub unsafe fn get_selection_highlight_color_when_not_focused(&self) -> Result<ComPtr<super::media::SolidColorBrush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionHighlightColorWhenNotFocused)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selection_highlight_color_when_not_focused(&self, value: &super::media::SolidColorBrush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectionHighlightColorWhenNotFocused)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_length(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxLength)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_length(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxLength)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichEditBoxStatics5, 1264338280, 17365, 17382, 187, 185, 203, 78, 98, 80, 244, 90);
RT_INTERFACE!{static interface IRichEditBoxStatics5(IRichEditBoxStatics5Vtbl): IInspectable(IInspectableVtbl) [IID_IRichEditBoxStatics5] {
    fn get_SelectionHighlightColorWhenNotFocusedProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MaxLengthProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IRichEditBoxStatics5 {
    #[inline] pub unsafe fn get_selection_highlight_color_when_not_focused_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionHighlightColorWhenNotFocusedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_length_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxLengthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IScrollContentPresenter, 1460858411, 3819, 18131, 170, 49, 95, 104, 1, 184, 222, 32);
RT_INTERFACE!{interface IScrollContentPresenter(IScrollContentPresenterVtbl): IInspectable(IInspectableVtbl) [IID_IScrollContentPresenter] {
    fn get_CanVerticallyScroll(&self, out: *mut bool) -> HRESULT,
    fn put_CanVerticallyScroll(&self, value: bool) -> HRESULT,
    fn get_CanHorizontallyScroll(&self, out: *mut bool) -> HRESULT,
    fn put_CanHorizontallyScroll(&self, value: bool) -> HRESULT,
    fn get_ExtentWidth(&self, out: *mut f64) -> HRESULT,
    fn get_ExtentHeight(&self, out: *mut f64) -> HRESULT,
    fn get_ViewportWidth(&self, out: *mut f64) -> HRESULT,
    fn get_ViewportHeight(&self, out: *mut f64) -> HRESULT,
    fn get_HorizontalOffset(&self, out: *mut f64) -> HRESULT,
    fn get_VerticalOffset(&self, out: *mut f64) -> HRESULT,
    fn get_ScrollOwner(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_ScrollOwner(&self, value: *mut IInspectable) -> HRESULT,
    fn LineUp(&self) -> HRESULT,
    fn LineDown(&self) -> HRESULT,
    fn LineLeft(&self) -> HRESULT,
    fn LineRight(&self) -> HRESULT,
    fn PageUp(&self) -> HRESULT,
    fn PageDown(&self) -> HRESULT,
    fn PageLeft(&self) -> HRESULT,
    fn PageRight(&self) -> HRESULT,
    fn MouseWheelUp(&self) -> HRESULT,
    fn MouseWheelDown(&self) -> HRESULT,
    fn MouseWheelLeft(&self) -> HRESULT,
    fn MouseWheelRight(&self) -> HRESULT,
    fn SetHorizontalOffset(&self, offset: f64) -> HRESULT,
    fn SetVerticalOffset(&self, offset: f64) -> HRESULT,
    fn MakeVisible(&self, visual: *mut super::UIElement, rectangle: ::rt::gen::windows::foundation::Rect, out: *mut ::rt::gen::windows::foundation::Rect) -> HRESULT
}}
impl IScrollContentPresenter {
    #[inline] pub unsafe fn get_can_vertically_scroll(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanVerticallyScroll)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_vertically_scroll(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanVerticallyScroll)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_horizontally_scroll(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanHorizontallyScroll)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_horizontally_scroll(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanHorizontallyScroll)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_extent_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExtentWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_extent_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExtentHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_viewport_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ViewportWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_viewport_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ViewportHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scroll_owner(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ScrollOwner)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_scroll_owner(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ScrollOwner)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn line_up(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).LineUp)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn line_down(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).LineDown)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn line_left(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).LineLeft)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn line_right(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).LineRight)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn page_up(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).PageUp)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn page_down(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).PageDown)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn page_left(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).PageLeft)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn page_right(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).PageRight)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn mouse_wheel_up(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).MouseWheelUp)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn mouse_wheel_down(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).MouseWheelDown)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn mouse_wheel_left(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).MouseWheelLeft)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn mouse_wheel_right(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).MouseWheelRight)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_horizontal_offset(&self, offset: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).SetHorizontalOffset)(self as *const _ as *mut _, offset);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_vertical_offset(&self, offset: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).SetVerticalOffset)(self as *const _ as *mut _, offset);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn make_visible(&self, visual: &super::UIElement, rectangle: ::rt::gen::windows::foundation::Rect) -> Result<::rt::gen::windows::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).MakeVisible)(self as *const _ as *mut _, visual as *const _ as *mut _, rectangle, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISearchBox, 4171156570, 39354, 19412, 150, 108, 241, 31, 164, 67, 209, 60);
RT_INTERFACE!{interface ISearchBox(ISearchBoxVtbl): IInspectable(IInspectableVtbl) [IID_ISearchBox] {
    fn get_SearchHistoryEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_SearchHistoryEnabled(&self, value: bool) -> HRESULT,
    fn get_SearchHistoryContext(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SearchHistoryContext(&self, value: HSTRING) -> HRESULT,
    fn get_PlaceholderText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PlaceholderText(&self, value: HSTRING) -> HRESULT,
    fn get_QueryText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_QueryText(&self, value: HSTRING) -> HRESULT,
    fn get_FocusOnKeyboardInput(&self, out: *mut bool) -> HRESULT,
    fn put_FocusOnKeyboardInput(&self, value: bool) -> HRESULT,
    fn get_ChooseSuggestionOnEnter(&self, out: *mut bool) -> HRESULT,
    fn put_ChooseSuggestionOnEnter(&self, value: bool) -> HRESULT,
    fn add_QueryChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<SearchBox, SearchBoxQueryChangedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_QueryChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_SuggestionsRequested(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<SearchBox, SearchBoxSuggestionsRequestedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SuggestionsRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_QuerySubmitted(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<SearchBox, SearchBoxQuerySubmittedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_QuerySubmitted(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ResultSuggestionChosen(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<SearchBox, SearchBoxResultSuggestionChosenEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ResultSuggestionChosen(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PrepareForFocusOnKeyboardInput(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<SearchBox, super::RoutedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PrepareForFocusOnKeyboardInput(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    #[cfg(feature="windows-applicationmodel")] fn SetLocalContentSuggestionSettings(&self, settings: *mut ::rt::gen::windows::applicationmodel::search::LocalContentSuggestionSettings) -> HRESULT
}}
impl ISearchBox {
    #[inline] pub unsafe fn get_search_history_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SearchHistoryEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_search_history_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SearchHistoryEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_search_history_context(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SearchHistoryContext)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_search_history_context(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SearchHistoryContext)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placeholder_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlaceholderText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_placeholder_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PlaceholderText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_query_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_QueryText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_query_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_QueryText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_on_keyboard_input(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FocusOnKeyboardInput)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_focus_on_keyboard_input(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FocusOnKeyboardInput)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_choose_suggestion_on_enter(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ChooseSuggestionOnEnter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_choose_suggestion_on_enter(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ChooseSuggestionOnEnter)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_query_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<SearchBox, SearchBoxQueryChangedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_QueryChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_query_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_QueryChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_suggestions_requested(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<SearchBox, SearchBoxSuggestionsRequestedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SuggestionsRequested)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_suggestions_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SuggestionsRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_query_submitted(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<SearchBox, SearchBoxQuerySubmittedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_QuerySubmitted)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_query_submitted(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_QuerySubmitted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_result_suggestion_chosen(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<SearchBox, SearchBoxResultSuggestionChosenEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ResultSuggestionChosen)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_result_suggestion_chosen(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ResultSuggestionChosen)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_prepare_for_focus_on_keyboard_input(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<SearchBox, super::RoutedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PrepareForFocusOnKeyboardInput)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_prepare_for_focus_on_keyboard_input(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PrepareForFocusOnKeyboardInput)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn set_local_content_suggestion_settings(&self, settings: &::rt::gen::windows::applicationmodel::search::LocalContentSuggestionSettings) -> Result<()> {
        let hr = ((*self.lpVtbl).SetLocalContentSuggestionSettings)(self as *const _ as *mut _, settings as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISearchBoxStatics, 2971886415, 26737, 18637, 146, 223, 76, 255, 34, 69, 144, 130);
RT_INTERFACE!{static interface ISearchBoxStatics(ISearchBoxStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISearchBoxStatics] {
    fn get_SearchHistoryEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SearchHistoryContextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PlaceholderTextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_QueryTextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FocusOnKeyboardInputProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ChooseSuggestionOnEnterProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ISearchBoxStatics {
    #[inline] pub unsafe fn get_search_history_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SearchHistoryEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_search_history_context_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SearchHistoryContextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placeholder_text_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlaceholderTextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_query_text_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_QueryTextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_on_keyboard_input_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FocusOnKeyboardInputProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_choose_suggestion_on_enter_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ChooseSuggestionOnEnterProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISearchBoxFactory, 3446947693, 34437, 18100, 157, 221, 32, 47, 105, 65, 183, 1);
RT_INTERFACE!{interface ISearchBoxFactory(ISearchBoxFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISearchBoxFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut SearchBox) -> HRESULT
}}
impl ISearchBoxFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<SearchBox>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISplitView, 2535599921, 14404, 17054, 147, 156, 22, 115, 21, 83, 34, 161);
RT_INTERFACE!{interface ISplitView(ISplitViewVtbl): IInspectable(IInspectableVtbl) [IID_ISplitView] {
    fn get_Content(&self, out: *mut *mut super::UIElement) -> HRESULT,
    fn put_Content(&self, value: *mut super::UIElement) -> HRESULT,
    fn get_Pane(&self, out: *mut *mut super::UIElement) -> HRESULT,
    fn put_Pane(&self, value: *mut super::UIElement) -> HRESULT,
    fn get_IsPaneOpen(&self, out: *mut bool) -> HRESULT,
    fn put_IsPaneOpen(&self, value: bool) -> HRESULT,
    fn get_OpenPaneLength(&self, out: *mut f64) -> HRESULT,
    fn put_OpenPaneLength(&self, value: f64) -> HRESULT,
    fn get_CompactPaneLength(&self, out: *mut f64) -> HRESULT,
    fn put_CompactPaneLength(&self, value: f64) -> HRESULT,
    fn get_PanePlacement(&self, out: *mut SplitViewPanePlacement) -> HRESULT,
    fn put_PanePlacement(&self, value: SplitViewPanePlacement) -> HRESULT,
    fn get_DisplayMode(&self, out: *mut SplitViewDisplayMode) -> HRESULT,
    fn put_DisplayMode(&self, value: SplitViewDisplayMode) -> HRESULT,
    fn get_TemplateSettings(&self, out: *mut *mut primitives::SplitViewTemplateSettings) -> HRESULT,
    fn get_PaneBackground(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_PaneBackground(&self, value: *mut super::media::Brush) -> HRESULT,
    fn add_PaneClosing(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<SplitView, SplitViewPaneClosingEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PaneClosing(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PaneClosed(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<SplitView, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PaneClosed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl ISplitView {
    #[inline] pub unsafe fn get_content(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Content)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content(&self, value: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Content)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pane(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Pane)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_pane(&self, value: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Pane)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_pane_open(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsPaneOpen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_pane_open(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsPaneOpen)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_open_pane_length(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OpenPaneLength)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_open_pane_length(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OpenPaneLength)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_compact_pane_length(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CompactPaneLength)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_compact_pane_length(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CompactPaneLength)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pane_placement(&self) -> Result<SplitViewPanePlacement> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PanePlacement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_pane_placement(&self, value: SplitViewPanePlacement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PanePlacement)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_mode(&self) -> Result<SplitViewDisplayMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DisplayMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_mode(&self, value: SplitViewDisplayMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_template_settings(&self) -> Result<ComPtr<primitives::SplitViewTemplateSettings>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TemplateSettings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pane_background(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PaneBackground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_pane_background(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PaneBackground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_pane_closing(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<SplitView, SplitViewPaneClosingEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PaneClosing)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_pane_closing(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PaneClosing)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_pane_closed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<SplitView, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PaneClosed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_pane_closed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PaneClosed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISplitViewStatics, 2241548143, 17579, 20043, 145, 193, 23, 183, 5, 109, 155, 95);
RT_INTERFACE!{static interface ISplitViewStatics(ISplitViewStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISplitViewStatics] {
    fn get_ContentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PaneProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsPaneOpenProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OpenPaneLengthProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CompactPaneLengthProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PanePlacementProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DisplayModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TemplateSettingsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PaneBackgroundProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ISplitViewStatics {
    #[inline] pub unsafe fn get_content_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pane_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PaneProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_pane_open_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsPaneOpenProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_open_pane_length_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OpenPaneLengthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_compact_pane_length_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CompactPaneLengthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pane_placement_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PanePlacementProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_template_settings_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TemplateSettingsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pane_background_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PaneBackgroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISplitViewFactory, 4043405114, 2126, 20409, 132, 66, 99, 34, 27, 68, 83, 63);
RT_INTERFACE!{interface ISplitViewFactory(ISplitViewFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISplitViewFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut SplitView) -> HRESULT
}}
impl ISplitViewFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<SplitView>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISplitView2, 1588059152, 52355, 16538, 130, 249, 62, 145, 214, 215, 8, 79);
RT_INTERFACE!{interface ISplitView2(ISplitView2Vtbl): IInspectable(IInspectableVtbl) [IID_ISplitView2] {
    fn get_LightDismissOverlayMode(&self, out: *mut LightDismissOverlayMode) -> HRESULT,
    fn put_LightDismissOverlayMode(&self, value: LightDismissOverlayMode) -> HRESULT
}}
impl ISplitView2 {
    #[inline] pub unsafe fn get_light_dismiss_overlay_mode(&self) -> Result<LightDismissOverlayMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LightDismissOverlayMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_light_dismiss_overlay_mode(&self, value: LightDismissOverlayMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LightDismissOverlayMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISplitViewStatics2, 347590010, 57276, 16940, 128, 169, 88, 88, 113, 41, 113, 19);
RT_INTERFACE!{static interface ISplitViewStatics2(ISplitViewStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_ISplitViewStatics2] {
    fn get_LightDismissOverlayModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ISplitViewStatics2 {
    #[inline] pub unsafe fn get_light_dismiss_overlay_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LightDismissOverlayModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISymbolIcon, 2051503305, 42659, 19248, 143, 241, 144, 129, 215, 14, 154, 92);
RT_INTERFACE!{interface ISymbolIcon(ISymbolIconVtbl): IInspectable(IInspectableVtbl) [IID_ISymbolIcon] {
    fn get_Symbol(&self, out: *mut Symbol) -> HRESULT,
    fn put_Symbol(&self, value: Symbol) -> HRESULT
}}
impl ISymbolIcon {
    #[inline] pub unsafe fn get_symbol(&self) -> Result<Symbol> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Symbol)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_symbol(&self, value: Symbol) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Symbol)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISymbolIconStatics, 2250570719, 38188, 20342, 176, 63, 48, 131, 59, 233, 149, 114);
RT_INTERFACE!{static interface ISymbolIconStatics(ISymbolIconStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISymbolIconStatics] {
    fn get_SymbolProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ISymbolIconStatics {
    #[inline] pub unsafe fn get_symbol_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SymbolProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISymbolIconFactory, 3341101960, 59244, 19268, 138, 5, 4, 107, 157, 199, 114, 184);
RT_INTERFACE!{static interface ISymbolIconFactory(ISymbolIconFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISymbolIconFactory] {
    fn CreateInstanceWithSymbol(&self, symbol: Symbol, out: *mut *mut SymbolIcon) -> HRESULT
}}
impl ISymbolIconFactory {
    #[inline] pub unsafe fn create_instance_with_symbol(&self, symbol: Symbol) -> Result<ComPtr<SymbolIcon>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithSymbol)(self as *const _ as *mut _, symbol, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITimePicker, 3817904626, 15103, 18322, 144, 158, 45, 153, 65, 236, 3, 87);
RT_INTERFACE!{interface ITimePicker(ITimePickerVtbl): IInspectable(IInspectableVtbl) [IID_ITimePicker] {
    fn get_Header(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Header(&self, value: *mut IInspectable) -> HRESULT,
    fn get_HeaderTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_HeaderTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_ClockIdentifier(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ClockIdentifier(&self, value: HSTRING) -> HRESULT,
    fn get_MinuteIncrement(&self, out: *mut i32) -> HRESULT,
    fn put_MinuteIncrement(&self, value: i32) -> HRESULT,
    fn get_Time(&self, out: *mut ::rt::gen::windows::foundation::TimeSpan) -> HRESULT,
    fn put_Time(&self, value: ::rt::gen::windows::foundation::TimeSpan) -> HRESULT,
    fn add_TimeChanged(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<TimePickerValueChangedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TimeChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl ITimePicker {
    #[inline] pub unsafe fn get_header(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Header)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Header)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_clock_identifier(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ClockIdentifier)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_clock_identifier(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ClockIdentifier)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_minute_increment(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinuteIncrement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_minute_increment(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MinuteIncrement)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_time(&self) -> Result<::rt::gen::windows::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Time)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_time(&self, value: ::rt::gen::windows::foundation::TimeSpan) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Time)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_time_changed(&self, value: &::rt::gen::windows::foundation::EventHandler<TimePickerValueChangedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TimeChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_time_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_TimeChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITimePickerStatics, 4201766833, 9022, 20273, 184, 190, 166, 234, 103, 12, 37, 205);
RT_INTERFACE!{static interface ITimePickerStatics(ITimePickerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ITimePickerStatics] {
    fn get_HeaderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HeaderTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ClockIdentifierProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MinuteIncrementProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TimeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ITimePickerStatics {
    #[inline] pub unsafe fn get_header_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_clock_identifier_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ClockIdentifierProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_minute_increment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MinuteIncrementProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_time_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TimeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITimePickerFactory, 1430250515, 27863, 18089, 169, 123, 161, 139, 220, 75, 76, 163);
RT_INTERFACE!{interface ITimePickerFactory(ITimePickerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ITimePickerFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut TimePicker) -> HRESULT
}}
impl ITimePickerFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<TimePicker>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITimePicker2, 267417996, 63778, 16799, 139, 61, 35, 238, 117, 134, 212, 142);
RT_INTERFACE!{interface ITimePicker2(ITimePicker2Vtbl): IInspectable(IInspectableVtbl) [IID_ITimePicker2] {
    fn get_LightDismissOverlayMode(&self, out: *mut LightDismissOverlayMode) -> HRESULT,
    fn put_LightDismissOverlayMode(&self, value: LightDismissOverlayMode) -> HRESULT
}}
impl ITimePicker2 {
    #[inline] pub unsafe fn get_light_dismiss_overlay_mode(&self) -> Result<LightDismissOverlayMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LightDismissOverlayMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_light_dismiss_overlay_mode(&self, value: LightDismissOverlayMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LightDismissOverlayMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITimePickerStatics2, 920169421, 19984, 17690, 185, 59, 26, 115, 30, 167, 238, 63);
RT_INTERFACE!{static interface ITimePickerStatics2(ITimePickerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_ITimePickerStatics2] {
    fn get_LightDismissOverlayModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ITimePickerStatics2 {
    #[inline] pub unsafe fn get_light_dismiss_overlay_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LightDismissOverlayModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBar, 2064630355, 34469, 19267, 152, 114, 11, 138, 98, 52, 183, 75);
RT_INTERFACE!{interface IAppBar(IAppBarVtbl): IInspectable(IInspectableVtbl) [IID_IAppBar] {
    fn get_IsOpen(&self, out: *mut bool) -> HRESULT,
    fn put_IsOpen(&self, value: bool) -> HRESULT,
    fn get_IsSticky(&self, out: *mut bool) -> HRESULT,
    fn put_IsSticky(&self, value: bool) -> HRESULT,
    fn add_Opened(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Opened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Closed(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IAppBar {
    #[inline] pub unsafe fn get_is_open(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsOpen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_open(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsOpen)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_sticky(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSticky)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_sticky(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSticky)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_opened(&self, value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Opened)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_opened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Opened)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_closed(&self, value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Closed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_closed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Closed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBarOverrides, 4026787042, 31503, 20298, 151, 13, 174, 138, 14, 170, 155, 112);
RT_INTERFACE!{interface IAppBarOverrides(IAppBarOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IAppBarOverrides] {
    fn OnClosed(&self, e: *mut IInspectable) -> HRESULT,
    fn OnOpened(&self, e: *mut IInspectable) -> HRESULT
}}
impl IAppBarOverrides {
    #[inline] pub unsafe fn on_closed(&self, e: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).OnClosed)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_opened(&self, e: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).OnOpened)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBarStatics, 2042330765, 56489, 19295, 164, 72, 55, 177, 50, 56, 237, 118);
RT_INTERFACE!{static interface IAppBarStatics(IAppBarStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAppBarStatics] {
    fn get_IsOpenProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsStickyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IAppBarStatics {
    #[inline] pub unsafe fn get_is_open_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsOpenProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_sticky_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsStickyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBarFactory, 1632045265, 36453, 17355, 146, 215, 142, 238, 23, 81, 95, 141);
RT_INTERFACE!{interface IAppBarFactory(IAppBarFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAppBarFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut AppBar) -> HRESULT
}}
impl IAppBarFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<AppBar>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBar2, 3282769843, 31447, 18038, 153, 16, 127, 227, 240, 232, 233, 147);
RT_INTERFACE!{interface IAppBar2(IAppBar2Vtbl): IInspectable(IInspectableVtbl) [IID_IAppBar2] {
    fn get_ClosedDisplayMode(&self, out: *mut AppBarClosedDisplayMode) -> HRESULT,
    fn put_ClosedDisplayMode(&self, value: AppBarClosedDisplayMode) -> HRESULT
}}
impl IAppBar2 {
    #[inline] pub unsafe fn get_closed_display_mode(&self) -> Result<AppBarClosedDisplayMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ClosedDisplayMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_closed_display_mode(&self, value: AppBarClosedDisplayMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ClosedDisplayMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBarStatics2, 572741097, 900, 18910, 135, 56, 223, 201, 212, 9, 172, 93);
RT_INTERFACE!{static interface IAppBarStatics2(IAppBarStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IAppBarStatics2] {
    fn get_ClosedDisplayModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IAppBarStatics2 {
    #[inline] pub unsafe fn get_closed_display_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ClosedDisplayModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBar3, 2552954911, 29998, 20090, 176, 85, 84, 128, 44, 158, 167, 73);
RT_INTERFACE!{interface IAppBar3(IAppBar3Vtbl): IInspectable(IInspectableVtbl) [IID_IAppBar3] {
    fn get_TemplateSettings(&self, out: *mut *mut primitives::AppBarTemplateSettings) -> HRESULT,
    fn add_Opening(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Opening(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Closing(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closing(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IAppBar3 {
    #[inline] pub unsafe fn get_template_settings(&self) -> Result<ComPtr<primitives::AppBarTemplateSettings>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TemplateSettings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_opening(&self, value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Opening)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_opening(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Opening)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_closing(&self, value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Closing)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_closing(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Closing)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBarOverrides3, 1093385160, 20944, 19273, 171, 98, 163, 221, 107, 220, 178, 152);
RT_INTERFACE!{interface IAppBarOverrides3(IAppBarOverrides3Vtbl): IInspectable(IInspectableVtbl) [IID_IAppBarOverrides3] {
    fn OnClosing(&self, e: *mut IInspectable) -> HRESULT,
    fn OnOpening(&self, e: *mut IInspectable) -> HRESULT
}}
impl IAppBarOverrides3 {
    #[inline] pub unsafe fn on_closing(&self, e: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).OnClosing)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_opening(&self, e: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).OnOpening)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBar4, 2498480333, 2660, 19875, 191, 67, 241, 49, 0, 164, 102, 5);
RT_INTERFACE!{interface IAppBar4(IAppBar4Vtbl): IInspectable(IInspectableVtbl) [IID_IAppBar4] {
    fn get_LightDismissOverlayMode(&self, out: *mut LightDismissOverlayMode) -> HRESULT,
    fn put_LightDismissOverlayMode(&self, value: LightDismissOverlayMode) -> HRESULT
}}
impl IAppBar4 {
    #[inline] pub unsafe fn get_light_dismiss_overlay_mode(&self) -> Result<LightDismissOverlayMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LightDismissOverlayMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_light_dismiss_overlay_mode(&self, value: LightDismissOverlayMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LightDismissOverlayMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBarStatics4, 3120695342, 4453, 17489, 148, 179, 235, 58, 199, 62, 65, 150);
RT_INTERFACE!{static interface IAppBarStatics4(IAppBarStatics4Vtbl): IInspectable(IInspectableVtbl) [IID_IAppBarStatics4] {
    fn get_LightDismissOverlayModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IAppBarStatics4 {
    #[inline] pub unsafe fn get_light_dismiss_overlay_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LightDismissOverlayModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutoSuggestBox, 272538387, 13312, 18966, 144, 185, 105, 18, 191, 6, 151, 79);
RT_INTERFACE!{interface IAutoSuggestBox(IAutoSuggestBoxVtbl): IInspectable(IInspectableVtbl) [IID_IAutoSuggestBox] {
    fn get_MaxSuggestionListHeight(&self, out: *mut f64) -> HRESULT,
    fn put_MaxSuggestionListHeight(&self, value: f64) -> HRESULT,
    fn get_IsSuggestionListOpen(&self, out: *mut bool) -> HRESULT,
    fn put_IsSuggestionListOpen(&self, value: bool) -> HRESULT,
    fn get_TextMemberPath(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TextMemberPath(&self, value: HSTRING) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Text(&self, value: HSTRING) -> HRESULT,
    fn get_UpdateTextOnSelect(&self, out: *mut bool) -> HRESULT,
    fn put_UpdateTextOnSelect(&self, value: bool) -> HRESULT,
    fn get_PlaceholderText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PlaceholderText(&self, value: HSTRING) -> HRESULT,
    fn get_Header(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Header(&self, value: *mut IInspectable) -> HRESULT,
    fn get_AutoMaximizeSuggestionArea(&self, out: *mut bool) -> HRESULT,
    fn put_AutoMaximizeSuggestionArea(&self, value: bool) -> HRESULT,
    fn get_TextBoxStyle(&self, out: *mut *mut super::Style) -> HRESULT,
    fn put_TextBoxStyle(&self, value: *mut super::Style) -> HRESULT,
    fn add_SuggestionChosen(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxSuggestionChosenEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SuggestionChosen(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_TextChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxTextChangedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TextChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IAutoSuggestBox {
    #[inline] pub unsafe fn get_max_suggestion_list_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxSuggestionListHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_suggestion_list_height(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxSuggestionListHeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_suggestion_list_open(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSuggestionListOpen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_suggestion_list_open(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSuggestionListOpen)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_member_path(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextMemberPath)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_member_path(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextMemberPath)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Text)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Text)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_update_text_on_select(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_UpdateTextOnSelect)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_update_text_on_select(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_UpdateTextOnSelect)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placeholder_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlaceholderText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_placeholder_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PlaceholderText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Header)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Header)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_auto_maximize_suggestion_area(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AutoMaximizeSuggestionArea)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_auto_maximize_suggestion_area(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AutoMaximizeSuggestionArea)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_box_style(&self) -> Result<ComPtr<super::Style>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextBoxStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_box_style(&self, value: &super::Style) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextBoxStyle)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_suggestion_chosen(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxSuggestionChosenEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SuggestionChosen)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_suggestion_chosen(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SuggestionChosen)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_text_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxTextChangedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TextChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_text_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_TextChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutoSuggestBoxStatics, 3995256820, 49501, 20467, 138, 148, 245, 13, 253, 251, 232, 154);
RT_INTERFACE!{static interface IAutoSuggestBoxStatics(IAutoSuggestBoxStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAutoSuggestBoxStatics] {
    fn get_MaxSuggestionListHeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsSuggestionListOpenProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextMemberPathProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_UpdateTextOnSelectProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PlaceholderTextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HeaderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_AutoMaximizeSuggestionAreaProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextBoxStyleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IAutoSuggestBoxStatics {
    #[inline] pub unsafe fn get_max_suggestion_list_height_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxSuggestionListHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_suggestion_list_open_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsSuggestionListOpenProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_member_path_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextMemberPathProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_update_text_on_select_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UpdateTextOnSelectProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placeholder_text_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlaceholderTextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_auto_maximize_suggestion_area_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AutoMaximizeSuggestionAreaProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_box_style_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextBoxStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutoSuggestBox2, 2861030878, 59001, 17842, 167, 201, 154, 237, 195, 157, 184, 134);
RT_INTERFACE!{interface IAutoSuggestBox2(IAutoSuggestBox2Vtbl): IInspectable(IInspectableVtbl) [IID_IAutoSuggestBox2] {
    fn get_QueryIcon(&self, out: *mut *mut IconElement) -> HRESULT,
    fn put_QueryIcon(&self, value: *mut IconElement) -> HRESULT,
    fn add_QuerySubmitted(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxQuerySubmittedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_QuerySubmitted(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IAutoSuggestBox2 {
    #[inline] pub unsafe fn get_query_icon(&self) -> Result<ComPtr<IconElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_QueryIcon)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_query_icon(&self, value: &IconElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_QueryIcon)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_query_submitted(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxQuerySubmittedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_QuerySubmitted)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_query_submitted(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_QuerySubmitted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutoSuggestBoxStatics2, 483563432, 36458, 16879, 169, 93, 113, 87, 220, 12, 113, 6);
RT_INTERFACE!{static interface IAutoSuggestBoxStatics2(IAutoSuggestBoxStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IAutoSuggestBoxStatics2] {
    fn get_QueryIconProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IAutoSuggestBoxStatics2 {
    #[inline] pub unsafe fn get_query_icon_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_QueryIconProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutoSuggestBox3, 2612788463, 62253, 16430, 144, 9, 5, 189, 186, 246, 51, 110);
RT_INTERFACE!{interface IAutoSuggestBox3(IAutoSuggestBox3Vtbl): IInspectable(IInspectableVtbl) [IID_IAutoSuggestBox3] {
    fn get_LightDismissOverlayMode(&self, out: *mut LightDismissOverlayMode) -> HRESULT,
    fn put_LightDismissOverlayMode(&self, value: LightDismissOverlayMode) -> HRESULT
}}
impl IAutoSuggestBox3 {
    #[inline] pub unsafe fn get_light_dismiss_overlay_mode(&self) -> Result<LightDismissOverlayMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LightDismissOverlayMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_light_dismiss_overlay_mode(&self, value: LightDismissOverlayMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LightDismissOverlayMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutoSuggestBoxStatics3, 753586909, 50389, 19122, 138, 19, 175, 221, 207, 6, 124, 134);
RT_INTERFACE!{static interface IAutoSuggestBoxStatics3(IAutoSuggestBoxStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IAutoSuggestBoxStatics3] {
    fn get_LightDismissOverlayModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IAutoSuggestBoxStatics3 {
    #[inline] pub unsafe fn get_light_dismiss_overlay_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LightDismissOverlayModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICommandBarOverflowPresenter, 1853527079, 22767, 17254, 160, 23, 24, 193, 147, 213, 107, 20);
RT_INTERFACE!{interface ICommandBarOverflowPresenter(ICommandBarOverflowPresenterVtbl): IInspectable(IInspectableVtbl) [IID_ICommandBarOverflowPresenter] {
    
}}
DEFINE_IID!(IID_ICommandBarOverflowPresenterFactory, 2200172404, 23210, 16457, 183, 143, 33, 140, 106, 25, 195, 126);
RT_INTERFACE!{interface ICommandBarOverflowPresenterFactory(ICommandBarOverflowPresenterFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICommandBarOverflowPresenterFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut CommandBarOverflowPresenter) -> HRESULT
}}
impl ICommandBarOverflowPresenterFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<CommandBarOverflowPresenter>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContentDialog, 953959428, 53838, 16600, 148, 21, 52, 148, 100, 193, 175, 220);
RT_INTERFACE!{interface IContentDialog(IContentDialogVtbl): IInspectable(IInspectableVtbl) [IID_IContentDialog] {
    fn get_Title(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Title(&self, value: *mut IInspectable) -> HRESULT,
    fn get_TitleTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_TitleTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_FullSizeDesired(&self, out: *mut bool) -> HRESULT,
    fn put_FullSizeDesired(&self, value: bool) -> HRESULT,
    fn get_PrimaryButtonText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PrimaryButtonText(&self, value: HSTRING) -> HRESULT,
    fn get_SecondaryButtonText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SecondaryButtonText(&self, value: HSTRING) -> HRESULT,
    fn get_PrimaryButtonCommand(&self, out: *mut *mut super::input::ICommand) -> HRESULT,
    fn put_PrimaryButtonCommand(&self, value: *mut super::input::ICommand) -> HRESULT,
    fn get_SecondaryButtonCommand(&self, out: *mut *mut super::input::ICommand) -> HRESULT,
    fn put_SecondaryButtonCommand(&self, value: *mut super::input::ICommand) -> HRESULT,
    fn get_PrimaryButtonCommandParameter(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_PrimaryButtonCommandParameter(&self, value: *mut IInspectable) -> HRESULT,
    fn get_SecondaryButtonCommandParameter(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_SecondaryButtonCommandParameter(&self, value: *mut IInspectable) -> HRESULT,
    fn get_IsPrimaryButtonEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsPrimaryButtonEnabled(&self, value: bool) -> HRESULT,
    fn get_IsSecondaryButtonEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsSecondaryButtonEnabled(&self, value: bool) -> HRESULT,
    fn add_Closing(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<ContentDialog, ContentDialogClosingEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closing(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Closed(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<ContentDialog, ContentDialogClosedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Opened(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<ContentDialog, ContentDialogOpenedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Opened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PrimaryButtonClick(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PrimaryButtonClick(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_SecondaryButtonClick(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SecondaryButtonClick(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn Hide(&self) -> HRESULT,
    fn ShowAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<ContentDialogResult>) -> HRESULT
}}
impl IContentDialog {
    #[inline] pub unsafe fn get_title(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Title)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_title(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Title)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_title_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TitleTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_title_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TitleTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_full_size_desired(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FullSizeDesired)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_full_size_desired(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FullSizeDesired)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_primary_button_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PrimaryButtonText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_primary_button_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PrimaryButtonText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_secondary_button_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SecondaryButtonText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_secondary_button_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SecondaryButtonText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_primary_button_command(&self) -> Result<ComPtr<super::input::ICommand>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PrimaryButtonCommand)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_primary_button_command(&self, value: &super::input::ICommand) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PrimaryButtonCommand)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_secondary_button_command(&self) -> Result<ComPtr<super::input::ICommand>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SecondaryButtonCommand)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_secondary_button_command(&self, value: &super::input::ICommand) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SecondaryButtonCommand)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_primary_button_command_parameter(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PrimaryButtonCommandParameter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_primary_button_command_parameter(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PrimaryButtonCommandParameter)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_secondary_button_command_parameter(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SecondaryButtonCommandParameter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_secondary_button_command_parameter(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SecondaryButtonCommandParameter)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_primary_button_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsPrimaryButtonEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_primary_button_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsPrimaryButtonEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_secondary_button_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSecondaryButtonEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_secondary_button_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSecondaryButtonEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_closing(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<ContentDialog, ContentDialogClosingEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Closing)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_closing(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Closing)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_closed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<ContentDialog, ContentDialogClosedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Closed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_closed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Closed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_opened(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<ContentDialog, ContentDialogOpenedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Opened)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_opened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Opened)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_primary_button_click(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PrimaryButtonClick)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_primary_button_click(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PrimaryButtonClick)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_secondary_button_click(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SecondaryButtonClick)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_secondary_button_click(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SecondaryButtonClick)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn hide(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Hide)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<ContentDialogResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContentDialogStatics, 598427558, 20618, 20275, 183, 134, 242, 250, 150, 216, 105, 175);
RT_INTERFACE!{static interface IContentDialogStatics(IContentDialogStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IContentDialogStatics] {
    fn get_TitleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TitleTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FullSizeDesiredProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PrimaryButtonTextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SecondaryButtonTextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PrimaryButtonCommandProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SecondaryButtonCommandProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PrimaryButtonCommandParameterProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SecondaryButtonCommandParameterProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsPrimaryButtonEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsSecondaryButtonEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IContentDialogStatics {
    #[inline] pub unsafe fn get_title_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TitleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_title_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TitleTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_full_size_desired_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FullSizeDesiredProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_primary_button_text_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PrimaryButtonTextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_secondary_button_text_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SecondaryButtonTextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_primary_button_command_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PrimaryButtonCommandProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_secondary_button_command_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SecondaryButtonCommandProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_primary_button_command_parameter_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PrimaryButtonCommandParameterProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_secondary_button_command_parameter_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SecondaryButtonCommandParameterProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_primary_button_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsPrimaryButtonEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_secondary_button_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsSecondaryButtonEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContentDialogFactory, 89485688, 40334, 17173, 179, 125, 104, 12, 20, 1, 44, 53);
RT_INTERFACE!{interface IContentDialogFactory(IContentDialogFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IContentDialogFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ContentDialog) -> HRESULT
}}
impl IContentDialogFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ContentDialog>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContentDialog2, 798223173, 60995, 17155, 155, 56, 63, 225, 161, 17, 236, 191);
RT_INTERFACE!{interface IContentDialog2(IContentDialog2Vtbl): IInspectable(IInspectableVtbl) [IID_IContentDialog2] {
    fn get_CloseButtonText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CloseButtonText(&self, value: HSTRING) -> HRESULT,
    fn get_CloseButtonCommand(&self, out: *mut *mut super::input::ICommand) -> HRESULT,
    fn put_CloseButtonCommand(&self, value: *mut super::input::ICommand) -> HRESULT,
    fn get_CloseButtonCommandParameter(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_CloseButtonCommandParameter(&self, value: *mut IInspectable) -> HRESULT,
    fn get_PrimaryButtonStyle(&self, out: *mut *mut super::Style) -> HRESULT,
    fn put_PrimaryButtonStyle(&self, value: *mut super::Style) -> HRESULT,
    fn get_SecondaryButtonStyle(&self, out: *mut *mut super::Style) -> HRESULT,
    fn put_SecondaryButtonStyle(&self, value: *mut super::Style) -> HRESULT,
    fn get_CloseButtonStyle(&self, out: *mut *mut super::Style) -> HRESULT,
    fn put_CloseButtonStyle(&self, value: *mut super::Style) -> HRESULT,
    fn get_DefaultButton(&self, out: *mut ContentDialogButton) -> HRESULT,
    fn put_DefaultButton(&self, value: ContentDialogButton) -> HRESULT,
    fn add_CloseButtonClick(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CloseButtonClick(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IContentDialog2 {
    #[inline] pub unsafe fn get_close_button_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CloseButtonText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_close_button_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CloseButtonText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_close_button_command(&self) -> Result<ComPtr<super::input::ICommand>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CloseButtonCommand)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_close_button_command(&self, value: &super::input::ICommand) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CloseButtonCommand)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_close_button_command_parameter(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CloseButtonCommandParameter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_close_button_command_parameter(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CloseButtonCommandParameter)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_primary_button_style(&self) -> Result<ComPtr<super::Style>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PrimaryButtonStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_primary_button_style(&self, value: &super::Style) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PrimaryButtonStyle)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_secondary_button_style(&self) -> Result<ComPtr<super::Style>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SecondaryButtonStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_secondary_button_style(&self, value: &super::Style) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SecondaryButtonStyle)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_close_button_style(&self) -> Result<ComPtr<super::Style>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CloseButtonStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_close_button_style(&self, value: &super::Style) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CloseButtonStyle)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_default_button(&self) -> Result<ContentDialogButton> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DefaultButton)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_default_button(&self, value: ContentDialogButton) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DefaultButton)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_close_button_click(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CloseButtonClick)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_close_button_click(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_CloseButtonClick)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContentDialogStatics2, 848831922, 36784, 16677, 187, 7, 231, 154, 90, 3, 129, 159);
RT_INTERFACE!{static interface IContentDialogStatics2(IContentDialogStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IContentDialogStatics2] {
    fn get_CloseButtonTextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CloseButtonCommandProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CloseButtonCommandParameterProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PrimaryButtonStyleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SecondaryButtonStyleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CloseButtonStyleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DefaultButtonProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IContentDialogStatics2 {
    #[inline] pub unsafe fn get_close_button_text_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CloseButtonTextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_close_button_command_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CloseButtonCommandProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_close_button_command_parameter_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CloseButtonCommandParameterProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_primary_button_style_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PrimaryButtonStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_secondary_button_style_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SecondaryButtonStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_close_button_style_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CloseButtonStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_default_button_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DefaultButtonProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFlyoutPresenter, 2189253497, 58235, 18085, 141, 68, 99, 161, 26, 88, 14, 131);
RT_INTERFACE!{interface IFlyoutPresenter(IFlyoutPresenterVtbl): IInspectable(IInspectableVtbl) [IID_IFlyoutPresenter] {
    
}}
DEFINE_IID!(IID_IFlyoutPresenterFactory, 3998049935, 55926, 18074, 172, 215, 48, 96, 230, 19, 173, 231);
RT_INTERFACE!{interface IFlyoutPresenterFactory(IFlyoutPresenterFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IFlyoutPresenterFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut FlyoutPresenter) -> HRESULT
}}
impl IFlyoutPresenterFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<FlyoutPresenter>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFrame, 1760186379, 16361, 18229, 182, 160, 231, 96, 25, 51, 176, 137);
RT_INTERFACE!{interface IFrame(IFrameVtbl): IInspectable(IInspectableVtbl) [IID_IFrame] {
    fn get_CacheSize(&self, out: *mut i32) -> HRESULT,
    fn put_CacheSize(&self, value: i32) -> HRESULT,
    fn get_CanGoBack(&self, out: *mut bool) -> HRESULT,
    fn get_CanGoForward(&self, out: *mut bool) -> HRESULT,
    fn get_CurrentSourcePageType(&self, out: *mut super::interop::TypeName) -> HRESULT,
    fn get_SourcePageType(&self, out: *mut super::interop::TypeName) -> HRESULT,
    fn put_SourcePageType(&self, value: super::interop::TypeName) -> HRESULT,
    fn get_BackStackDepth(&self, out: *mut i32) -> HRESULT,
    fn add_Navigated(&self, value: *mut super::navigation::NavigatedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Navigated(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Navigating(&self, value: *mut super::navigation::NavigatingCancelEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Navigating(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_NavigationFailed(&self, value: *mut super::navigation::NavigationFailedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NavigationFailed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_NavigationStopped(&self, value: *mut super::navigation::NavigationStoppedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NavigationStopped(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn GoBack(&self) -> HRESULT,
    fn GoForward(&self) -> HRESULT,
    fn Navigate(&self, sourcePageType: super::interop::TypeName, parameter: *mut IInspectable, out: *mut bool) -> HRESULT,
    fn GetNavigationState(&self, out: *mut HSTRING) -> HRESULT,
    fn SetNavigationState(&self, navigationState: HSTRING) -> HRESULT
}}
impl IFrame {
    #[inline] pub unsafe fn get_cache_size(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CacheSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_cache_size(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CacheSize)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_go_back(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanGoBack)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_go_forward(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanGoForward)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_current_source_page_type(&self) -> Result<super::interop::TypeName> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CurrentSourcePageType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_source_page_type(&self) -> Result<super::interop::TypeName> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SourcePageType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_source_page_type(&self, value: super::interop::TypeName) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SourcePageType)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_back_stack_depth(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BackStackDepth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_navigated(&self, value: &super::navigation::NavigatedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Navigated)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_navigated(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Navigated)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_navigating(&self, value: &super::navigation::NavigatingCancelEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Navigating)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_navigating(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Navigating)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_navigation_failed(&self, value: &super::navigation::NavigationFailedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_NavigationFailed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_navigation_failed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_NavigationFailed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_navigation_stopped(&self, value: &super::navigation::NavigationStoppedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_NavigationStopped)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_navigation_stopped(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_NavigationStopped)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn go_back(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).GoBack)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn go_forward(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).GoForward)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn navigate(&self, sourcePageType: super::interop::TypeName, parameter: &IInspectable) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Navigate)(self as *const _ as *mut _, sourcePageType, parameter as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_navigation_state(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetNavigationState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_navigation_state(&self, navigationState: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetNavigationState)(self as *const _ as *mut _, navigationState.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFrameStatics, 3584880873, 55655, 18203, 132, 89, 200, 175, 67, 65, 81, 27);
RT_INTERFACE!{static interface IFrameStatics(IFrameStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IFrameStatics] {
    fn get_CacheSizeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CanGoBackProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CanGoForwardProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CurrentSourcePageTypeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SourcePageTypeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_BackStackDepthProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IFrameStatics {
    #[inline] pub unsafe fn get_cache_size_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CacheSizeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_go_back_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CanGoBackProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_go_forward_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CanGoForwardProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_current_source_page_type_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CurrentSourcePageTypeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_source_page_type_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourcePageTypeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_back_stack_depth_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BackStackDepthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFrameFactory, 49189844, 17550, 18078, 151, 153, 10, 138, 31, 112, 241, 113);
RT_INTERFACE!{interface IFrameFactory(IFrameFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IFrameFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut Frame) -> HRESULT
}}
impl IFrameFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<Frame>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFrame2, 1060536199, 40794, 19204, 184, 24, 181, 84, 192, 105, 89, 122);
RT_INTERFACE!{interface IFrame2(IFrame2Vtbl): IInspectable(IInspectableVtbl) [IID_IFrame2] {
    fn get_BackStack(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<super::navigation::PageStackEntry>) -> HRESULT,
    fn get_ForwardStack(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<super::navigation::PageStackEntry>) -> HRESULT,
    fn Navigate(&self, sourcePageType: super::interop::TypeName, parameter: *mut IInspectable, infoOverride: *mut super::media::animation::NavigationTransitionInfo, out: *mut bool) -> HRESULT
}}
impl IFrame2 {
    #[inline] pub unsafe fn get_back_stack(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<super::navigation::PageStackEntry>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BackStack)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_forward_stack(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<super::navigation::PageStackEntry>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ForwardStack)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn navigate(&self, sourcePageType: super::interop::TypeName, parameter: &IInspectable, infoOverride: &super::media::animation::NavigationTransitionInfo) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Navigate)(self as *const _ as *mut _, sourcePageType, parameter as *const _ as *mut _, infoOverride as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFrameStatics2, 3837119998, 17136, 17506, 161, 193, 93, 37, 157, 216, 42, 3);
RT_INTERFACE!{static interface IFrameStatics2(IFrameStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IFrameStatics2] {
    fn get_BackStackProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ForwardStackProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IFrameStatics2 {
    #[inline] pub unsafe fn get_back_stack_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BackStackProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_forward_stack_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ForwardStackProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFrame3, 1686776653, 21450, 19290, 170, 142, 60, 199, 68, 15, 74, 103);
RT_INTERFACE!{interface IFrame3(IFrame3Vtbl): IInspectable(IInspectableVtbl) [IID_IFrame3] {
    fn GoBack(&self, transitionInfoOverride: *mut super::media::animation::NavigationTransitionInfo) -> HRESULT
}}
impl IFrame3 {
    #[inline] pub unsafe fn go_back(&self, transitionInfoOverride: &super::media::animation::NavigationTransitionInfo) -> Result<()> {
        let hr = ((*self.lpVtbl).GoBack)(self as *const _ as *mut _, transitionInfoOverride as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFrame4, 2602025498, 48427, 18944, 153, 235, 148, 107, 233, 97, 128, 132);
RT_INTERFACE!{interface IFrame4(IFrame4Vtbl): IInspectable(IInspectableVtbl) [IID_IFrame4] {
    fn SetNavigationStateWithNavigationControl(&self, navigationState: HSTRING, suppressNavigate: bool) -> HRESULT
}}
impl IFrame4 {
    #[inline] pub unsafe fn set_navigation_state_with_navigation_control(&self, navigationState: &HStringArg, suppressNavigate: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetNavigationStateWithNavigationControl)(self as *const _ as *mut _, navigationState.get(), suppressNavigate);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMenuFlyoutItem, 369587663, 46488, 17583, 164, 136, 195, 206, 42, 246, 211, 240);
RT_INTERFACE!{interface IMenuFlyoutItem(IMenuFlyoutItemVtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutItem] {
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Text(&self, value: HSTRING) -> HRESULT,
    fn get_Command(&self, out: *mut *mut super::input::ICommand) -> HRESULT,
    fn put_Command(&self, value: *mut super::input::ICommand) -> HRESULT,
    fn get_CommandParameter(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_CommandParameter(&self, value: *mut IInspectable) -> HRESULT,
    fn add_Click(&self, value: *mut super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Click(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IMenuFlyoutItem {
    #[inline] pub unsafe fn get_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Text)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Text)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_command(&self) -> Result<ComPtr<super::input::ICommand>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Command)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_command(&self, value: &super::input::ICommand) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Command)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_command_parameter(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CommandParameter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_command_parameter(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CommandParameter)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_click(&self, value: &super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Click)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_click(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Click)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMenuFlyoutItemStatics, 1230025764, 42042, 16887, 170, 58, 156, 233, 97, 151, 71, 213);
RT_INTERFACE!{static interface IMenuFlyoutItemStatics(IMenuFlyoutItemStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutItemStatics] {
    fn get_TextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CommandProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CommandParameterProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IMenuFlyoutItemStatics {
    #[inline] pub unsafe fn get_text_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_command_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CommandProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_command_parameter_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CommandParameterProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMenuFlyoutItemFactory, 3316267490, 17651, 17758, 156, 91, 98, 187, 106, 252, 227, 173);
RT_INTERFACE!{interface IMenuFlyoutItemFactory(IMenuFlyoutItemFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutItemFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut MenuFlyoutItem) -> HRESULT
}}
impl IMenuFlyoutItemFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<MenuFlyoutItem>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMenuFlyoutItem2, 182609643, 652, 17443, 168, 227, 152, 159, 217, 221, 113, 38);
RT_INTERFACE!{interface IMenuFlyoutItem2(IMenuFlyoutItem2Vtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutItem2] {
    fn get_Icon(&self, out: *mut *mut IconElement) -> HRESULT,
    fn put_Icon(&self, value: *mut IconElement) -> HRESULT
}}
impl IMenuFlyoutItem2 {
    #[inline] pub unsafe fn get_icon(&self) -> Result<ComPtr<IconElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Icon)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_icon(&self, value: &IconElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Icon)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMenuFlyoutItemStatics2, 2896491876, 6032, 17921, 145, 110, 90, 225, 240, 31, 75, 214);
RT_INTERFACE!{static interface IMenuFlyoutItemStatics2(IMenuFlyoutItemStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutItemStatics2] {
    fn get_IconProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IMenuFlyoutItemStatics2 {
    #[inline] pub unsafe fn get_icon_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IconProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMenuFlyoutPresenter, 2423128836, 9550, 16703, 178, 25, 199, 185, 127, 0, 55, 82);
RT_INTERFACE!{interface IMenuFlyoutPresenter(IMenuFlyoutPresenterVtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutPresenter] {
    
}}
DEFINE_IID!(IID_IMenuFlyoutPresenterFactory, 3096137873, 4124, 16888, 170, 193, 27, 16, 92, 20, 251, 153);
RT_INTERFACE!{interface IMenuFlyoutPresenterFactory(IMenuFlyoutPresenterFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutPresenterFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut MenuFlyoutPresenter) -> HRESULT
}}
impl IMenuFlyoutPresenterFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<MenuFlyoutPresenter>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMenuFlyoutPresenter2, 2304283871, 23199, 18975, 133, 236, 111, 60, 27, 109, 203, 137);
RT_INTERFACE!{interface IMenuFlyoutPresenter2(IMenuFlyoutPresenter2Vtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutPresenter2] {
    fn get_TemplateSettings(&self, out: *mut *mut primitives::MenuFlyoutPresenterTemplateSettings) -> HRESULT
}}
impl IMenuFlyoutPresenter2 {
    #[inline] pub unsafe fn get_template_settings(&self) -> Result<ComPtr<primitives::MenuFlyoutPresenterTemplateSettings>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TemplateSettings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMenuFlyoutSeparator, 1912220541, 2897, 18768, 161, 164, 187, 196, 46, 172, 76, 18);
RT_INTERFACE!{interface IMenuFlyoutSeparator(IMenuFlyoutSeparatorVtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutSeparator] {
    
}}
DEFINE_IID!(IID_IMenuFlyoutSeparatorFactory, 3243891912, 46135, 17632, 178, 75, 87, 32, 174, 161, 219, 172);
RT_INTERFACE!{interface IMenuFlyoutSeparatorFactory(IMenuFlyoutSeparatorFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutSeparatorFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut MenuFlyoutSeparator) -> HRESULT
}}
impl IMenuFlyoutSeparatorFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<MenuFlyoutSeparator>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMenuFlyoutSubItem, 3845678416, 65068, 17378, 167, 63, 98, 22, 143, 97, 153, 115);
RT_INTERFACE!{interface IMenuFlyoutSubItem(IMenuFlyoutSubItemVtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutSubItem] {
    fn get_Items(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<MenuFlyoutItemBase>) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Text(&self, value: HSTRING) -> HRESULT
}}
impl IMenuFlyoutSubItem {
    #[inline] pub unsafe fn get_items(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<MenuFlyoutItemBase>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Items)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Text)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Text)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMenuFlyoutSubItemStatics, 3719461430, 6260, 19183, 131, 125, 111, 236, 157, 164, 230, 129);
RT_INTERFACE!{static interface IMenuFlyoutSubItemStatics(IMenuFlyoutSubItemStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutSubItemStatics] {
    fn get_TextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IMenuFlyoutSubItemStatics {
    #[inline] pub unsafe fn get_text_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMenuFlyoutSubItem2, 2895336998, 6410, 19938, 141, 113, 124, 196, 116, 125, 165, 128);
RT_INTERFACE!{interface IMenuFlyoutSubItem2(IMenuFlyoutSubItem2Vtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutSubItem2] {
    fn get_Icon(&self, out: *mut *mut IconElement) -> HRESULT,
    fn put_Icon(&self, value: *mut IconElement) -> HRESULT
}}
impl IMenuFlyoutSubItem2 {
    #[inline] pub unsafe fn get_icon(&self) -> Result<ComPtr<IconElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Icon)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_icon(&self, value: &IconElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Icon)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMenuFlyoutSubItemStatics2, 2887045275, 16019, 18309, 148, 239, 253, 178, 59, 171, 169, 101);
RT_INTERFACE!{static interface IMenuFlyoutSubItemStatics2(IMenuFlyoutSubItemStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutSubItemStatics2] {
    fn get_IconProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IMenuFlyoutSubItemStatics2 {
    #[inline] pub unsafe fn get_icon_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IconProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPage, 3300028533, 58945, 17726, 130, 77, 1, 47, 199, 207, 149, 207);
RT_INTERFACE!{interface IPage(IPageVtbl): IInspectable(IInspectableVtbl) [IID_IPage] {
    fn get_Frame(&self, out: *mut *mut Frame) -> HRESULT,
    fn get_NavigationCacheMode(&self, out: *mut super::navigation::NavigationCacheMode) -> HRESULT,
    fn put_NavigationCacheMode(&self, value: super::navigation::NavigationCacheMode) -> HRESULT,
    fn get_TopAppBar(&self, out: *mut *mut AppBar) -> HRESULT,
    fn put_TopAppBar(&self, value: *mut AppBar) -> HRESULT,
    fn get_BottomAppBar(&self, out: *mut *mut AppBar) -> HRESULT,
    fn put_BottomAppBar(&self, value: *mut AppBar) -> HRESULT
}}
impl IPage {
    #[inline] pub unsafe fn get_frame(&self) -> Result<ComPtr<Frame>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Frame)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_navigation_cache_mode(&self) -> Result<super::navigation::NavigationCacheMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NavigationCacheMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_navigation_cache_mode(&self, value: super::navigation::NavigationCacheMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_NavigationCacheMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_top_app_bar(&self) -> Result<ComPtr<AppBar>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TopAppBar)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_top_app_bar(&self, value: &AppBar) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TopAppBar)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_bottom_app_bar(&self) -> Result<ComPtr<AppBar>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BottomAppBar)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_bottom_app_bar(&self, value: &AppBar) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BottomAppBar)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPageOverrides, 587963576, 13337, 17158, 170, 190, 74, 142, 104, 13, 54, 39);
RT_INTERFACE!{interface IPageOverrides(IPageOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IPageOverrides] {
    fn OnNavigatedFrom(&self, e: *mut super::navigation::NavigationEventArgs) -> HRESULT,
    fn OnNavigatedTo(&self, e: *mut super::navigation::NavigationEventArgs) -> HRESULT,
    fn OnNavigatingFrom(&self, e: *mut super::navigation::NavigatingCancelEventArgs) -> HRESULT
}}
impl IPageOverrides {
    #[inline] pub unsafe fn on_navigated_from(&self, e: &super::navigation::NavigationEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnNavigatedFrom)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_navigated_to(&self, e: &super::navigation::NavigationEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnNavigatedTo)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_navigating_from(&self, e: &super::navigation::NavigatingCancelEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnNavigatingFrom)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPageStatics, 929947249, 63269, 18141, 141, 128, 238, 234, 247, 218, 116, 229);
RT_INTERFACE!{static interface IPageStatics(IPageStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPageStatics] {
    fn get_FrameProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TopAppBarProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_BottomAppBarProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IPageStatics {
    #[inline] pub unsafe fn get_frame_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FrameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_top_app_bar_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TopAppBarProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_bottom_app_bar_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BottomAppBarProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPageFactory, 3751889324, 6217, 17502, 147, 124, 64, 169, 89, 12, 192, 118);
RT_INTERFACE!{interface IPageFactory(IPageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPageFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut Page) -> HRESULT
}}
impl IPageFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<Page>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IScrollViewer, 1693040128, 19905, 18749, 171, 231, 203, 211, 197, 119, 73, 13);
RT_INTERFACE!{interface IScrollViewer(IScrollViewerVtbl): IInspectable(IInspectableVtbl) [IID_IScrollViewer] {
    fn get_HorizontalScrollBarVisibility(&self, out: *mut ScrollBarVisibility) -> HRESULT,
    fn put_HorizontalScrollBarVisibility(&self, value: ScrollBarVisibility) -> HRESULT,
    fn get_VerticalScrollBarVisibility(&self, out: *mut ScrollBarVisibility) -> HRESULT,
    fn put_VerticalScrollBarVisibility(&self, value: ScrollBarVisibility) -> HRESULT,
    fn get_IsHorizontalRailEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsHorizontalRailEnabled(&self, value: bool) -> HRESULT,
    fn get_IsVerticalRailEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsVerticalRailEnabled(&self, value: bool) -> HRESULT,
    fn get_IsHorizontalScrollChainingEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsHorizontalScrollChainingEnabled(&self, value: bool) -> HRESULT,
    fn get_IsVerticalScrollChainingEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsVerticalScrollChainingEnabled(&self, value: bool) -> HRESULT,
    fn get_IsZoomChainingEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsZoomChainingEnabled(&self, value: bool) -> HRESULT,
    fn get_IsScrollInertiaEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsScrollInertiaEnabled(&self, value: bool) -> HRESULT,
    fn get_IsZoomInertiaEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsZoomInertiaEnabled(&self, value: bool) -> HRESULT,
    fn get_HorizontalScrollMode(&self, out: *mut ScrollMode) -> HRESULT,
    fn put_HorizontalScrollMode(&self, value: ScrollMode) -> HRESULT,
    fn get_VerticalScrollMode(&self, out: *mut ScrollMode) -> HRESULT,
    fn put_VerticalScrollMode(&self, value: ScrollMode) -> HRESULT,
    fn get_ZoomMode(&self, out: *mut ZoomMode) -> HRESULT,
    fn put_ZoomMode(&self, value: ZoomMode) -> HRESULT,
    fn get_HorizontalSnapPointsAlignment(&self, out: *mut primitives::SnapPointsAlignment) -> HRESULT,
    fn put_HorizontalSnapPointsAlignment(&self, value: primitives::SnapPointsAlignment) -> HRESULT,
    fn get_VerticalSnapPointsAlignment(&self, out: *mut primitives::SnapPointsAlignment) -> HRESULT,
    fn put_VerticalSnapPointsAlignment(&self, value: primitives::SnapPointsAlignment) -> HRESULT,
    fn get_HorizontalSnapPointsType(&self, out: *mut SnapPointsType) -> HRESULT,
    fn put_HorizontalSnapPointsType(&self, value: SnapPointsType) -> HRESULT,
    fn get_VerticalSnapPointsType(&self, out: *mut SnapPointsType) -> HRESULT,
    fn put_VerticalSnapPointsType(&self, value: SnapPointsType) -> HRESULT,
    fn get_ZoomSnapPointsType(&self, out: *mut SnapPointsType) -> HRESULT,
    fn put_ZoomSnapPointsType(&self, value: SnapPointsType) -> HRESULT,
    fn get_HorizontalOffset(&self, out: *mut f64) -> HRESULT,
    fn get_ViewportWidth(&self, out: *mut f64) -> HRESULT,
    fn get_ScrollableWidth(&self, out: *mut f64) -> HRESULT,
    fn get_ComputedHorizontalScrollBarVisibility(&self, out: *mut super::Visibility) -> HRESULT,
    fn get_ExtentWidth(&self, out: *mut f64) -> HRESULT,
    fn get_VerticalOffset(&self, out: *mut f64) -> HRESULT,
    fn get_ViewportHeight(&self, out: *mut f64) -> HRESULT,
    fn get_ScrollableHeight(&self, out: *mut f64) -> HRESULT,
    fn get_ComputedVerticalScrollBarVisibility(&self, out: *mut super::Visibility) -> HRESULT,
    fn get_ExtentHeight(&self, out: *mut f64) -> HRESULT,
    fn get_MinZoomFactor(&self, out: *mut f32) -> HRESULT,
    fn put_MinZoomFactor(&self, value: f32) -> HRESULT,
    fn get_MaxZoomFactor(&self, out: *mut f32) -> HRESULT,
    fn put_MaxZoomFactor(&self, value: f32) -> HRESULT,
    fn get_ZoomFactor(&self, out: *mut f32) -> HRESULT,
    fn get_ZoomSnapPoints(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<f32>) -> HRESULT,
    fn add_ViewChanged(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<ScrollViewerViewChangedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ViewChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn ScrollToHorizontalOffset(&self, offset: f64) -> HRESULT,
    fn ScrollToVerticalOffset(&self, offset: f64) -> HRESULT,
    fn ZoomToFactor(&self, factor: f32) -> HRESULT,
    fn InvalidateScrollInfo(&self) -> HRESULT,
    fn get_IsDeferredScrollingEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsDeferredScrollingEnabled(&self, value: bool) -> HRESULT,
    fn get_BringIntoViewOnFocusChange(&self, out: *mut bool) -> HRESULT,
    fn put_BringIntoViewOnFocusChange(&self, value: bool) -> HRESULT
}}
impl IScrollViewer {
    #[inline] pub unsafe fn get_horizontal_scroll_bar_visibility(&self) -> Result<ScrollBarVisibility> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalScrollBarVisibility)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_horizontal_scroll_bar_visibility(&self, value: ScrollBarVisibility) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HorizontalScrollBarVisibility)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_scroll_bar_visibility(&self) -> Result<ScrollBarVisibility> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalScrollBarVisibility)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_vertical_scroll_bar_visibility(&self, value: ScrollBarVisibility) -> Result<()> {
        let hr = ((*self.lpVtbl).put_VerticalScrollBarVisibility)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_horizontal_rail_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsHorizontalRailEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_horizontal_rail_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsHorizontalRailEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_vertical_rail_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsVerticalRailEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_vertical_rail_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsVerticalRailEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_horizontal_scroll_chaining_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsHorizontalScrollChainingEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_horizontal_scroll_chaining_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsHorizontalScrollChainingEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_vertical_scroll_chaining_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsVerticalScrollChainingEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_vertical_scroll_chaining_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsVerticalScrollChainingEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_zoom_chaining_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsZoomChainingEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_zoom_chaining_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsZoomChainingEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_scroll_inertia_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsScrollInertiaEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_scroll_inertia_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsScrollInertiaEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_zoom_inertia_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsZoomInertiaEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_zoom_inertia_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsZoomInertiaEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_scroll_mode(&self) -> Result<ScrollMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalScrollMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_horizontal_scroll_mode(&self, value: ScrollMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HorizontalScrollMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_scroll_mode(&self) -> Result<ScrollMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalScrollMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_vertical_scroll_mode(&self, value: ScrollMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_VerticalScrollMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoom_mode(&self) -> Result<ZoomMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ZoomMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_zoom_mode(&self, value: ZoomMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ZoomMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_snap_points_alignment(&self) -> Result<primitives::SnapPointsAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalSnapPointsAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_horizontal_snap_points_alignment(&self, value: primitives::SnapPointsAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HorizontalSnapPointsAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_snap_points_alignment(&self) -> Result<primitives::SnapPointsAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalSnapPointsAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_vertical_snap_points_alignment(&self, value: primitives::SnapPointsAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_VerticalSnapPointsAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_snap_points_type(&self) -> Result<SnapPointsType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalSnapPointsType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_horizontal_snap_points_type(&self, value: SnapPointsType) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HorizontalSnapPointsType)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_snap_points_type(&self) -> Result<SnapPointsType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalSnapPointsType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_vertical_snap_points_type(&self, value: SnapPointsType) -> Result<()> {
        let hr = ((*self.lpVtbl).put_VerticalSnapPointsType)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoom_snap_points_type(&self) -> Result<SnapPointsType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ZoomSnapPointsType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_zoom_snap_points_type(&self, value: SnapPointsType) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ZoomSnapPointsType)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_viewport_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ViewportWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scrollable_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScrollableWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_computed_horizontal_scroll_bar_visibility(&self) -> Result<super::Visibility> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ComputedHorizontalScrollBarVisibility)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_extent_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExtentWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_viewport_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ViewportHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scrollable_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScrollableHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_computed_vertical_scroll_bar_visibility(&self) -> Result<super::Visibility> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ComputedVerticalScrollBarVisibility)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_extent_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExtentHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_zoom_factor(&self) -> Result<f32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinZoomFactor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_min_zoom_factor(&self, value: f32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MinZoomFactor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_zoom_factor(&self) -> Result<f32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxZoomFactor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_zoom_factor(&self, value: f32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxZoomFactor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoom_factor(&self) -> Result<f32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ZoomFactor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoom_snap_points(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<f32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ZoomSnapPoints)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_view_changed(&self, value: &::rt::gen::windows::foundation::EventHandler<ScrollViewerViewChangedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ViewChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_view_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ViewChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn scroll_to_horizontal_offset(&self, offset: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).ScrollToHorizontalOffset)(self as *const _ as *mut _, offset);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn scroll_to_vertical_offset(&self, offset: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).ScrollToVerticalOffset)(self as *const _ as *mut _, offset);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn zoom_to_factor(&self, factor: f32) -> Result<()> {
        let hr = ((*self.lpVtbl).ZoomToFactor)(self as *const _ as *mut _, factor);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn invalidate_scroll_info(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).InvalidateScrollInfo)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_deferred_scrolling_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsDeferredScrollingEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_deferred_scrolling_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsDeferredScrollingEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_bring_into_view_on_focus_change(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BringIntoViewOnFocusChange)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_bring_into_view_on_focus_change(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BringIntoViewOnFocusChange)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IScrollViewerStatics, 869345693, 36206, 17040, 191, 34, 144, 92, 204, 208, 77, 49);
RT_INTERFACE!{static interface IScrollViewerStatics(IScrollViewerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IScrollViewerStatics] {
    fn get_HorizontalSnapPointsAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_VerticalSnapPointsAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HorizontalSnapPointsTypeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_VerticalSnapPointsTypeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ZoomSnapPointsTypeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HorizontalOffsetProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ViewportWidthProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ScrollableWidthProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ComputedHorizontalScrollBarVisibilityProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ExtentWidthProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_VerticalOffsetProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ViewportHeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ScrollableHeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ComputedVerticalScrollBarVisibilityProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ExtentHeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MinZoomFactorProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MaxZoomFactorProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ZoomFactorProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ZoomSnapPointsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HorizontalScrollBarVisibilityProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetHorizontalScrollBarVisibility(&self, element: *mut super::DependencyObject, out: *mut ScrollBarVisibility) -> HRESULT,
    fn SetHorizontalScrollBarVisibility(&self, element: *mut super::DependencyObject, horizontalScrollBarVisibility: ScrollBarVisibility) -> HRESULT,
    fn get_VerticalScrollBarVisibilityProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetVerticalScrollBarVisibility(&self, element: *mut super::DependencyObject, out: *mut ScrollBarVisibility) -> HRESULT,
    fn SetVerticalScrollBarVisibility(&self, element: *mut super::DependencyObject, verticalScrollBarVisibility: ScrollBarVisibility) -> HRESULT,
    fn get_IsHorizontalRailEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetIsHorizontalRailEnabled(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetIsHorizontalRailEnabled(&self, element: *mut super::DependencyObject, isHorizontalRailEnabled: bool) -> HRESULT,
    fn get_IsVerticalRailEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetIsVerticalRailEnabled(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetIsVerticalRailEnabled(&self, element: *mut super::DependencyObject, isVerticalRailEnabled: bool) -> HRESULT,
    fn get_IsHorizontalScrollChainingEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetIsHorizontalScrollChainingEnabled(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetIsHorizontalScrollChainingEnabled(&self, element: *mut super::DependencyObject, isHorizontalScrollChainingEnabled: bool) -> HRESULT,
    fn get_IsVerticalScrollChainingEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetIsVerticalScrollChainingEnabled(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetIsVerticalScrollChainingEnabled(&self, element: *mut super::DependencyObject, isVerticalScrollChainingEnabled: bool) -> HRESULT,
    fn get_IsZoomChainingEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetIsZoomChainingEnabled(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetIsZoomChainingEnabled(&self, element: *mut super::DependencyObject, isZoomChainingEnabled: bool) -> HRESULT,
    fn get_IsScrollInertiaEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetIsScrollInertiaEnabled(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetIsScrollInertiaEnabled(&self, element: *mut super::DependencyObject, isScrollInertiaEnabled: bool) -> HRESULT,
    fn get_IsZoomInertiaEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetIsZoomInertiaEnabled(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetIsZoomInertiaEnabled(&self, element: *mut super::DependencyObject, isZoomInertiaEnabled: bool) -> HRESULT,
    fn get_HorizontalScrollModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetHorizontalScrollMode(&self, element: *mut super::DependencyObject, out: *mut ScrollMode) -> HRESULT,
    fn SetHorizontalScrollMode(&self, element: *mut super::DependencyObject, horizontalScrollMode: ScrollMode) -> HRESULT,
    fn get_VerticalScrollModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetVerticalScrollMode(&self, element: *mut super::DependencyObject, out: *mut ScrollMode) -> HRESULT,
    fn SetVerticalScrollMode(&self, element: *mut super::DependencyObject, verticalScrollMode: ScrollMode) -> HRESULT,
    fn get_ZoomModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetZoomMode(&self, element: *mut super::DependencyObject, out: *mut ZoomMode) -> HRESULT,
    fn SetZoomMode(&self, element: *mut super::DependencyObject, zoomMode: ZoomMode) -> HRESULT,
    fn get_IsDeferredScrollingEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetIsDeferredScrollingEnabled(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetIsDeferredScrollingEnabled(&self, element: *mut super::DependencyObject, isDeferredScrollingEnabled: bool) -> HRESULT,
    fn get_BringIntoViewOnFocusChangeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetBringIntoViewOnFocusChange(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetBringIntoViewOnFocusChange(&self, element: *mut super::DependencyObject, bringIntoViewOnFocusChange: bool) -> HRESULT
}}
impl IScrollViewerStatics {
    #[inline] pub unsafe fn get_horizontal_snap_points_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HorizontalSnapPointsAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_snap_points_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VerticalSnapPointsAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_snap_points_type_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HorizontalSnapPointsTypeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_snap_points_type_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VerticalSnapPointsTypeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoom_snap_points_type_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ZoomSnapPointsTypeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_offset_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HorizontalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_viewport_width_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ViewportWidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scrollable_width_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ScrollableWidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_computed_horizontal_scroll_bar_visibility_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ComputedHorizontalScrollBarVisibilityProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_extent_width_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExtentWidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_offset_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VerticalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_viewport_height_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ViewportHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scrollable_height_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ScrollableHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_computed_vertical_scroll_bar_visibility_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ComputedVerticalScrollBarVisibilityProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_extent_height_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExtentHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_zoom_factor_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MinZoomFactorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_zoom_factor_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxZoomFactorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoom_factor_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ZoomFactorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoom_snap_points_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ZoomSnapPointsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_scroll_bar_visibility_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HorizontalScrollBarVisibilityProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_scroll_bar_visibility(&self, element: &super::DependencyObject) -> Result<ScrollBarVisibility> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetHorizontalScrollBarVisibility)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_horizontal_scroll_bar_visibility(&self, element: &super::DependencyObject, horizontalScrollBarVisibility: ScrollBarVisibility) -> Result<()> {
        let hr = ((*self.lpVtbl).SetHorizontalScrollBarVisibility)(self as *const _ as *mut _, element as *const _ as *mut _, horizontalScrollBarVisibility);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_scroll_bar_visibility_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VerticalScrollBarVisibilityProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_scroll_bar_visibility(&self, element: &super::DependencyObject) -> Result<ScrollBarVisibility> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetVerticalScrollBarVisibility)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_vertical_scroll_bar_visibility(&self, element: &super::DependencyObject, verticalScrollBarVisibility: ScrollBarVisibility) -> Result<()> {
        let hr = ((*self.lpVtbl).SetVerticalScrollBarVisibility)(self as *const _ as *mut _, element as *const _ as *mut _, verticalScrollBarVisibility);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_horizontal_rail_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsHorizontalRailEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_horizontal_rail_enabled(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsHorizontalRailEnabled)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_horizontal_rail_enabled(&self, element: &super::DependencyObject, isHorizontalRailEnabled: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetIsHorizontalRailEnabled)(self as *const _ as *mut _, element as *const _ as *mut _, isHorizontalRailEnabled);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_vertical_rail_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsVerticalRailEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_vertical_rail_enabled(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsVerticalRailEnabled)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_vertical_rail_enabled(&self, element: &super::DependencyObject, isVerticalRailEnabled: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetIsVerticalRailEnabled)(self as *const _ as *mut _, element as *const _ as *mut _, isVerticalRailEnabled);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_horizontal_scroll_chaining_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsHorizontalScrollChainingEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_horizontal_scroll_chaining_enabled(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsHorizontalScrollChainingEnabled)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_horizontal_scroll_chaining_enabled(&self, element: &super::DependencyObject, isHorizontalScrollChainingEnabled: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetIsHorizontalScrollChainingEnabled)(self as *const _ as *mut _, element as *const _ as *mut _, isHorizontalScrollChainingEnabled);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_vertical_scroll_chaining_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsVerticalScrollChainingEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_vertical_scroll_chaining_enabled(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsVerticalScrollChainingEnabled)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_vertical_scroll_chaining_enabled(&self, element: &super::DependencyObject, isVerticalScrollChainingEnabled: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetIsVerticalScrollChainingEnabled)(self as *const _ as *mut _, element as *const _ as *mut _, isVerticalScrollChainingEnabled);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_zoom_chaining_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsZoomChainingEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_zoom_chaining_enabled(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsZoomChainingEnabled)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_zoom_chaining_enabled(&self, element: &super::DependencyObject, isZoomChainingEnabled: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetIsZoomChainingEnabled)(self as *const _ as *mut _, element as *const _ as *mut _, isZoomChainingEnabled);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_scroll_inertia_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsScrollInertiaEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_scroll_inertia_enabled(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsScrollInertiaEnabled)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_scroll_inertia_enabled(&self, element: &super::DependencyObject, isScrollInertiaEnabled: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetIsScrollInertiaEnabled)(self as *const _ as *mut _, element as *const _ as *mut _, isScrollInertiaEnabled);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_zoom_inertia_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsZoomInertiaEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_zoom_inertia_enabled(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsZoomInertiaEnabled)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_zoom_inertia_enabled(&self, element: &super::DependencyObject, isZoomInertiaEnabled: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetIsZoomInertiaEnabled)(self as *const _ as *mut _, element as *const _ as *mut _, isZoomInertiaEnabled);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_scroll_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HorizontalScrollModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_scroll_mode(&self, element: &super::DependencyObject) -> Result<ScrollMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetHorizontalScrollMode)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_horizontal_scroll_mode(&self, element: &super::DependencyObject, horizontalScrollMode: ScrollMode) -> Result<()> {
        let hr = ((*self.lpVtbl).SetHorizontalScrollMode)(self as *const _ as *mut _, element as *const _ as *mut _, horizontalScrollMode);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_scroll_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VerticalScrollModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_scroll_mode(&self, element: &super::DependencyObject) -> Result<ScrollMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetVerticalScrollMode)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_vertical_scroll_mode(&self, element: &super::DependencyObject, verticalScrollMode: ScrollMode) -> Result<()> {
        let hr = ((*self.lpVtbl).SetVerticalScrollMode)(self as *const _ as *mut _, element as *const _ as *mut _, verticalScrollMode);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoom_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ZoomModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoom_mode(&self, element: &super::DependencyObject) -> Result<ZoomMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetZoomMode)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_zoom_mode(&self, element: &super::DependencyObject, zoomMode: ZoomMode) -> Result<()> {
        let hr = ((*self.lpVtbl).SetZoomMode)(self as *const _ as *mut _, element as *const _ as *mut _, zoomMode);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_deferred_scrolling_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsDeferredScrollingEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_deferred_scrolling_enabled(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsDeferredScrollingEnabled)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_deferred_scrolling_enabled(&self, element: &super::DependencyObject, isDeferredScrollingEnabled: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetIsDeferredScrollingEnabled)(self as *const _ as *mut _, element as *const _ as *mut _, isDeferredScrollingEnabled);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_bring_into_view_on_focus_change_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BringIntoViewOnFocusChangeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_bring_into_view_on_focus_change(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetBringIntoViewOnFocusChange)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_bring_into_view_on_focus_change(&self, element: &super::DependencyObject, bringIntoViewOnFocusChange: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetBringIntoViewOnFocusChange)(self as *const _ as *mut _, element as *const _ as *mut _, bringIntoViewOnFocusChange);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IScrollViewer2, 1693040144, 19921, 18765, 171, 247, 203, 211, 197, 119, 73, 29);
RT_INTERFACE!{interface IScrollViewer2(IScrollViewer2Vtbl): IInspectable(IInspectableVtbl) [IID_IScrollViewer2] {
    fn get_TopLeftHeader(&self, out: *mut *mut super::UIElement) -> HRESULT,
    fn put_TopLeftHeader(&self, value: *mut super::UIElement) -> HRESULT,
    fn get_LeftHeader(&self, out: *mut *mut super::UIElement) -> HRESULT,
    fn put_LeftHeader(&self, value: *mut super::UIElement) -> HRESULT,
    fn get_TopHeader(&self, out: *mut *mut super::UIElement) -> HRESULT,
    fn put_TopHeader(&self, value: *mut super::UIElement) -> HRESULT,
    fn add_ViewChanging(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<ScrollViewerViewChangingEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ViewChanging(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn ChangeView(&self, horizontalOffset: *mut ::rt::gen::windows::foundation::IReference<f64>, verticalOffset: *mut ::rt::gen::windows::foundation::IReference<f64>, zoomFactor: *mut ::rt::gen::windows::foundation::IReference<f32>, out: *mut bool) -> HRESULT,
    fn ChangeViewWithOptionalAnimation(&self, horizontalOffset: *mut ::rt::gen::windows::foundation::IReference<f64>, verticalOffset: *mut ::rt::gen::windows::foundation::IReference<f64>, zoomFactor: *mut ::rt::gen::windows::foundation::IReference<f32>, disableAnimation: bool, out: *mut bool) -> HRESULT
}}
impl IScrollViewer2 {
    #[inline] pub unsafe fn get_top_left_header(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TopLeftHeader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_top_left_header(&self, value: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TopLeftHeader)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_left_header(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LeftHeader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_left_header(&self, value: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LeftHeader)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_top_header(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TopHeader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_top_header(&self, value: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TopHeader)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_view_changing(&self, value: &::rt::gen::windows::foundation::EventHandler<ScrollViewerViewChangingEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ViewChanging)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_view_changing(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ViewChanging)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn change_view(&self, horizontalOffset: &::rt::gen::windows::foundation::IReference<f64>, verticalOffset: &::rt::gen::windows::foundation::IReference<f64>, zoomFactor: &::rt::gen::windows::foundation::IReference<f32>) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).ChangeView)(self as *const _ as *mut _, horizontalOffset as *const _ as *mut _, verticalOffset as *const _ as *mut _, zoomFactor as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn change_view_with_optional_animation(&self, horizontalOffset: &::rt::gen::windows::foundation::IReference<f64>, verticalOffset: &::rt::gen::windows::foundation::IReference<f64>, zoomFactor: &::rt::gen::windows::foundation::IReference<f32>, disableAnimation: bool) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).ChangeViewWithOptionalAnimation)(self as *const _ as *mut _, horizontalOffset as *const _ as *mut _, verticalOffset as *const _ as *mut _, zoomFactor as *const _ as *mut _, disableAnimation, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IScrollViewerStatics2, 869345709, 36222, 17056, 191, 50, 144, 92, 204, 208, 77, 65);
RT_INTERFACE!{static interface IScrollViewerStatics2(IScrollViewerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IScrollViewerStatics2] {
    fn get_TopLeftHeaderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_LeftHeaderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TopHeaderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IScrollViewerStatics2 {
    #[inline] pub unsafe fn get_top_left_header_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TopLeftHeaderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_left_header_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LeftHeaderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_top_header_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TopHeaderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IScrollViewer3, 1961475617, 24034, 22878, 188, 8, 219, 211, 197, 119, 73, 44);
RT_INTERFACE!{interface IScrollViewer3(IScrollViewer3Vtbl): IInspectable(IInspectableVtbl) [IID_IScrollViewer3] {
    fn add_DirectManipulationStarted(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DirectManipulationStarted(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_DirectManipulationCompleted(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DirectManipulationCompleted(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IScrollViewer3 {
    #[inline] pub unsafe fn add_direct_manipulation_started(&self, value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DirectManipulationStarted)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_direct_manipulation_started(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DirectManipulationStarted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_direct_manipulation_completed(&self, value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DirectManipulationCompleted)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_direct_manipulation_completed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DirectManipulationCompleted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISwapChainBackgroundPanel, 475650888, 33331, 19468, 188, 245, 2, 165, 251, 53, 174, 0);
RT_INTERFACE!{interface ISwapChainBackgroundPanel(ISwapChainBackgroundPanelVtbl): IInspectable(IInspectableVtbl) [IID_ISwapChainBackgroundPanel] {
    
}}
DEFINE_IID!(IID_ISwapChainBackgroundPanelFactory, 427985364, 51355, 18866, 137, 108, 89, 23, 191, 138, 220, 174);
RT_INTERFACE!{interface ISwapChainBackgroundPanelFactory(ISwapChainBackgroundPanelFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISwapChainBackgroundPanelFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut SwapChainBackgroundPanel) -> HRESULT
}}
impl ISwapChainBackgroundPanelFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<SwapChainBackgroundPanel>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISwapChainBackgroundPanel2, 568750834, 9618, 19512, 135, 15, 40, 251, 207, 82, 192, 149);
RT_INTERFACE!{interface ISwapChainBackgroundPanel2(ISwapChainBackgroundPanel2Vtbl): IInspectable(IInspectableVtbl) [IID_ISwapChainBackgroundPanel2] {
    #[cfg(feature="windows-ui")] fn CreateCoreIndependentInputSource(&self, deviceTypes: super::super::core::CoreInputDeviceTypes, out: *mut *mut super::super::core::CoreIndependentInputSource) -> HRESULT
}}
impl ISwapChainBackgroundPanel2 {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn create_core_independent_input_source(&self, deviceTypes: super::super::core::CoreInputDeviceTypes) -> Result<ComPtr<super::super::core::CoreIndependentInputSource>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateCoreIndependentInputSource)(self as *const _ as *mut _, deviceTypes, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISwapChainPanel, 3314115663, 60328, 17018, 183, 90, 159, 31, 147, 161, 26, 233);
RT_INTERFACE!{interface ISwapChainPanel(ISwapChainPanelVtbl): IInspectable(IInspectableVtbl) [IID_ISwapChainPanel] {
    fn get_CompositionScaleX(&self, out: *mut f32) -> HRESULT,
    fn get_CompositionScaleY(&self, out: *mut f32) -> HRESULT,
    fn add_CompositionScaleChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<SwapChainPanel, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CompositionScaleChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    #[cfg(feature="windows-ui")] fn CreateCoreIndependentInputSource(&self, deviceTypes: super::super::core::CoreInputDeviceTypes, out: *mut *mut super::super::core::CoreIndependentInputSource) -> HRESULT
}}
impl ISwapChainPanel {
    #[inline] pub unsafe fn get_composition_scale_x(&self) -> Result<f32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CompositionScaleX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_composition_scale_y(&self) -> Result<f32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CompositionScaleY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_composition_scale_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<SwapChainPanel, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CompositionScaleChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_composition_scale_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_CompositionScaleChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn create_core_independent_input_source(&self, deviceTypes: super::super::core::CoreInputDeviceTypes) -> Result<ComPtr<super::super::core::CoreIndependentInputSource>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateCoreIndependentInputSource)(self as *const _ as *mut _, deviceTypes, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISwapChainPanelStatics, 4170973847, 61096, 18828, 153, 196, 37, 126, 54, 96, 223, 126);
RT_INTERFACE!{static interface ISwapChainPanelStatics(ISwapChainPanelStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISwapChainPanelStatics] {
    fn get_CompositionScaleXProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CompositionScaleYProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ISwapChainPanelStatics {
    #[inline] pub unsafe fn get_composition_scale_xproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CompositionScaleXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_composition_scale_yproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CompositionScaleYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISwapChainPanelFactory, 4086271359, 6728, 18891, 134, 210, 16, 234, 170, 246, 253, 112);
RT_INTERFACE!{interface ISwapChainPanelFactory(ISwapChainPanelFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISwapChainPanelFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut SwapChainPanel) -> HRESULT
}}
impl ISwapChainPanelFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<SwapChainPanel>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICommandBar, 2562474624, 19005, 19694, 189, 7, 34, 206, 148, 197, 175, 118);
RT_INTERFACE!{interface ICommandBar(ICommandBarVtbl): IInspectable(IInspectableVtbl) [IID_ICommandBar] {
    fn get_PrimaryCommands(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IObservableVector<ICommandBarElement>) -> HRESULT,
    fn get_SecondaryCommands(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IObservableVector<ICommandBarElement>) -> HRESULT
}}
impl ICommandBar {
    #[inline] pub unsafe fn get_primary_commands(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IObservableVector<ICommandBarElement>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PrimaryCommands)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_secondary_commands(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IObservableVector<ICommandBarElement>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SecondaryCommands)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICommandBarStatics, 1540981226, 57976, 16540, 181, 34, 249, 70, 202, 37, 59, 68);
RT_INTERFACE!{static interface ICommandBarStatics(ICommandBarStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICommandBarStatics] {
    fn get_PrimaryCommandsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SecondaryCommandsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ICommandBarStatics {
    #[inline] pub unsafe fn get_primary_commands_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PrimaryCommandsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_secondary_commands_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SecondaryCommandsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICommandBarFactory, 1740499780, 8417, 16759, 173, 68, 246, 23, 179, 116, 232, 232);
RT_INTERFACE!{interface ICommandBarFactory(ICommandBarFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICommandBarFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut CommandBar) -> HRESULT
}}
impl ICommandBarFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<CommandBar>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICommandBar2, 1466314584, 23346, 18269, 190, 100, 76, 163, 110, 123, 151, 212);
RT_INTERFACE!{interface ICommandBar2(ICommandBar2Vtbl): IInspectable(IInspectableVtbl) [IID_ICommandBar2] {
    fn get_CommandBarOverflowPresenterStyle(&self, out: *mut *mut super::Style) -> HRESULT,
    fn put_CommandBarOverflowPresenterStyle(&self, value: *mut super::Style) -> HRESULT,
    fn get_CommandBarTemplateSettings(&self, out: *mut *mut primitives::CommandBarTemplateSettings) -> HRESULT
}}
impl ICommandBar2 {
    #[inline] pub unsafe fn get_command_bar_overflow_presenter_style(&self) -> Result<ComPtr<super::Style>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CommandBarOverflowPresenterStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_command_bar_overflow_presenter_style(&self, value: &super::Style) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CommandBarOverflowPresenterStyle)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_command_bar_template_settings(&self) -> Result<ComPtr<primitives::CommandBarTemplateSettings>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CommandBarTemplateSettings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICommandBarStatics2, 1033816291, 20905, 20020, 149, 108, 112, 129, 208, 111, 38, 248);
RT_INTERFACE!{static interface ICommandBarStatics2(ICommandBarStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_ICommandBarStatics2] {
    fn get_CommandBarOverflowPresenterStyleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ICommandBarStatics2 {
    #[inline] pub unsafe fn get_command_bar_overflow_presenter_style_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CommandBarOverflowPresenterStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICommandBar3, 1089190947, 10873, 18611, 154, 103, 100, 155, 133, 45, 133, 137);
RT_INTERFACE!{interface ICommandBar3(ICommandBar3Vtbl): IInspectable(IInspectableVtbl) [IID_ICommandBar3] {
    fn get_DefaultLabelPosition(&self, out: *mut CommandBarDefaultLabelPosition) -> HRESULT,
    fn put_DefaultLabelPosition(&self, value: CommandBarDefaultLabelPosition) -> HRESULT,
    fn get_OverflowButtonVisibility(&self, out: *mut CommandBarOverflowButtonVisibility) -> HRESULT,
    fn put_OverflowButtonVisibility(&self, value: CommandBarOverflowButtonVisibility) -> HRESULT,
    fn get_IsDynamicOverflowEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsDynamicOverflowEnabled(&self, value: bool) -> HRESULT,
    fn add_DynamicOverflowItemsChanging(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<CommandBar, DynamicOverflowItemsChangingEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DynamicOverflowItemsChanging(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl ICommandBar3 {
    #[inline] pub unsafe fn get_default_label_position(&self) -> Result<CommandBarDefaultLabelPosition> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DefaultLabelPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_default_label_position(&self, value: CommandBarDefaultLabelPosition) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DefaultLabelPosition)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_overflow_button_visibility(&self) -> Result<CommandBarOverflowButtonVisibility> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OverflowButtonVisibility)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_overflow_button_visibility(&self, value: CommandBarOverflowButtonVisibility) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OverflowButtonVisibility)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_dynamic_overflow_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsDynamicOverflowEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_dynamic_overflow_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsDynamicOverflowEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_dynamic_overflow_items_changing(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<CommandBar, DynamicOverflowItemsChangingEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DynamicOverflowItemsChanging)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_dynamic_overflow_items_changing(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DynamicOverflowItemsChanging)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICommandBarStatics3, 3025806500, 35569, 18499, 179, 25, 224, 63, 196, 90, 183, 38);
RT_INTERFACE!{static interface ICommandBarStatics3(ICommandBarStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_ICommandBarStatics3] {
    fn get_DefaultLabelPositionProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OverflowButtonVisibilityProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsDynamicOverflowEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ICommandBarStatics3 {
    #[inline] pub unsafe fn get_default_label_position_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DefaultLabelPositionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_overflow_button_visibility_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OverflowButtonVisibilityProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_dynamic_overflow_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsDynamicOverflowEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGridViewHeaderItem, 1926716798, 24003, 20476, 155, 28, 147, 155, 92, 55, 22, 28);
RT_INTERFACE!{interface IGridViewHeaderItem(IGridViewHeaderItemVtbl): IInspectable(IInspectableVtbl) [IID_IGridViewHeaderItem] {
    
}}
DEFINE_IID!(IID_IGridViewHeaderItemFactory, 920701294, 46442, 19259, 139, 172, 122, 239, 94, 111, 153, 69);
RT_INTERFACE!{interface IGridViewHeaderItemFactory(IGridViewHeaderItemFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGridViewHeaderItemFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut GridViewHeaderItem) -> HRESULT
}}
impl IGridViewHeaderItemFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<GridViewHeaderItem>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGridViewItem, 2107179505, 59329, 20099, 180, 112, 201, 214, 215, 189, 169, 245);
RT_INTERFACE!{interface IGridViewItem(IGridViewItemVtbl): IInspectable(IInspectableVtbl) [IID_IGridViewItem] {
    fn get_TemplateSettings(&self, out: *mut *mut primitives::GridViewItemTemplateSettings) -> HRESULT
}}
impl IGridViewItem {
    #[inline] pub unsafe fn get_template_settings(&self) -> Result<ComPtr<primitives::GridViewItemTemplateSettings>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TemplateSettings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGridViewItemFactory, 580583599, 16294, 17385, 151, 157, 7, 234, 13, 98, 128, 220);
RT_INTERFACE!{interface IGridViewItemFactory(IGridViewItemFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGridViewItemFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut GridViewItem) -> HRESULT
}}
impl IGridViewItemFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<GridViewItem>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewHeaderItem, 459389675, 57750, 19259, 165, 249, 30, 214, 54, 243, 247, 155);
RT_INTERFACE!{interface IListViewHeaderItem(IListViewHeaderItemVtbl): IInspectable(IInspectableVtbl) [IID_IListViewHeaderItem] {
    
}}
DEFINE_IID!(IID_IListViewHeaderItemFactory, 1758644586, 38576, 20232, 167, 165, 241, 8, 103, 32, 160, 250);
RT_INTERFACE!{interface IListViewHeaderItemFactory(IListViewHeaderItemFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IListViewHeaderItemFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ListViewHeaderItem) -> HRESULT
}}
impl IListViewHeaderItemFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ListViewHeaderItem>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewItem, 3082502917, 15833, 17374, 168, 192, 196, 114, 240, 133, 188, 17);
RT_INTERFACE!{interface IListViewItem(IListViewItemVtbl): IInspectable(IInspectableVtbl) [IID_IListViewItem] {
    fn get_TemplateSettings(&self, out: *mut *mut primitives::ListViewItemTemplateSettings) -> HRESULT
}}
impl IListViewItem {
    #[inline] pub unsafe fn get_template_settings(&self) -> Result<ComPtr<primitives::ListViewItemTemplateSettings>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TemplateSettings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewItemFactory, 4096853821, 40108, 17058, 130, 223, 15, 68, 144, 188, 78, 46);
RT_INTERFACE!{interface IListViewItemFactory(IListViewItemFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IListViewItemFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ListViewItem) -> HRESULT
}}
impl IListViewItemFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ListViewItem>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IToggleMenuFlyoutItem, 1233395421, 35049, 18019, 167, 1, 205, 79, 210, 94, 57, 143);
RT_INTERFACE!{interface IToggleMenuFlyoutItem(IToggleMenuFlyoutItemVtbl): IInspectable(IInspectableVtbl) [IID_IToggleMenuFlyoutItem] {
    fn get_IsChecked(&self, out: *mut bool) -> HRESULT,
    fn put_IsChecked(&self, value: bool) -> HRESULT
}}
impl IToggleMenuFlyoutItem {
    #[inline] pub unsafe fn get_is_checked(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsChecked)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_checked(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsChecked)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IToggleMenuFlyoutItemStatics, 382149883, 27674, 18514, 146, 88, 8, 192, 56, 54, 121, 7);
RT_INTERFACE!{static interface IToggleMenuFlyoutItemStatics(IToggleMenuFlyoutItemStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IToggleMenuFlyoutItemStatics] {
    fn get_IsCheckedProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IToggleMenuFlyoutItemStatics {
    #[inline] pub unsafe fn get_is_checked_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsCheckedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IToggleMenuFlyoutItemFactory, 2706478703, 15351, 18102, 182, 28, 155, 44, 27, 166, 136, 67);
RT_INTERFACE!{interface IToggleMenuFlyoutItemFactory(IToggleMenuFlyoutItemFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IToggleMenuFlyoutItemFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ToggleMenuFlyoutItem) -> HRESULT
}}
impl IToggleMenuFlyoutItemFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ToggleMenuFlyoutItem>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWrapGrid, 89266059, 30055, 18370, 189, 92, 173, 131, 148, 200, 40, 186);
RT_INTERFACE!{interface IWrapGrid(IWrapGridVtbl): IInspectable(IInspectableVtbl) [IID_IWrapGrid] {
    fn get_ItemWidth(&self, out: *mut f64) -> HRESULT,
    fn put_ItemWidth(&self, value: f64) -> HRESULT,
    fn get_ItemHeight(&self, out: *mut f64) -> HRESULT,
    fn put_ItemHeight(&self, value: f64) -> HRESULT,
    fn get_Orientation(&self, out: *mut Orientation) -> HRESULT,
    fn put_Orientation(&self, value: Orientation) -> HRESULT,
    fn get_HorizontalChildrenAlignment(&self, out: *mut super::HorizontalAlignment) -> HRESULT,
    fn put_HorizontalChildrenAlignment(&self, value: super::HorizontalAlignment) -> HRESULT,
    fn get_VerticalChildrenAlignment(&self, out: *mut super::VerticalAlignment) -> HRESULT,
    fn put_VerticalChildrenAlignment(&self, value: super::VerticalAlignment) -> HRESULT,
    fn get_MaximumRowsOrColumns(&self, out: *mut i32) -> HRESULT,
    fn put_MaximumRowsOrColumns(&self, value: i32) -> HRESULT
}}
impl IWrapGrid {
    #[inline] pub unsafe fn get_item_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ItemWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_item_width(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemWidth)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ItemHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_item_height(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemHeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation(&self) -> Result<Orientation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Orientation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_orientation(&self, value: Orientation) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Orientation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_children_alignment(&self) -> Result<super::HorizontalAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalChildrenAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_horizontal_children_alignment(&self, value: super::HorizontalAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HorizontalChildrenAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_children_alignment(&self) -> Result<super::VerticalAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalChildrenAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_vertical_children_alignment(&self, value: super::VerticalAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_VerticalChildrenAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_maximum_rows_or_columns(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaximumRowsOrColumns)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_maximum_rows_or_columns(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaximumRowsOrColumns)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWrapGridStatics, 3494538135, 5067, 18332, 162, 133, 228, 229, 104, 70, 196, 203);
RT_INTERFACE!{static interface IWrapGridStatics(IWrapGridStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IWrapGridStatics] {
    fn get_ItemWidthProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ItemHeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OrientationProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HorizontalChildrenAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_VerticalChildrenAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MaximumRowsOrColumnsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IWrapGridStatics {
    #[inline] pub unsafe fn get_item_width_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemWidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_height_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OrientationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_children_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HorizontalChildrenAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_children_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VerticalChildrenAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_maximum_rows_or_columns_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaximumRowsOrColumnsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBarButton, 1146725457, 27112, 17420, 152, 150, 75, 180, 245, 246, 66, 209);
RT_INTERFACE!{interface IAppBarButton(IAppBarButtonVtbl): IInspectable(IInspectableVtbl) [IID_IAppBarButton] {
    fn get_Label(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Label(&self, value: HSTRING) -> HRESULT,
    fn get_Icon(&self, out: *mut *mut IconElement) -> HRESULT,
    fn put_Icon(&self, value: *mut IconElement) -> HRESULT
}}
impl IAppBarButton {
    #[inline] pub unsafe fn get_label(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Label)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_label(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Label)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_icon(&self) -> Result<ComPtr<IconElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Icon)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_icon(&self, value: &IconElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Icon)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBarButtonStatics, 2093814758, 21249, 16511, 135, 78, 220, 145, 96, 170, 7, 175);
RT_INTERFACE!{static interface IAppBarButtonStatics(IAppBarButtonStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAppBarButtonStatics] {
    fn get_LabelProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IconProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsCompactProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IAppBarButtonStatics {
    #[inline] pub unsafe fn get_label_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LabelProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_icon_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IconProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_compact_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsCompactProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBarButtonFactory, 3183156150, 52014, 17014, 171, 214, 121, 53, 19, 5, 16, 224);
RT_INTERFACE!{interface IAppBarButtonFactory(IAppBarButtonFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAppBarButtonFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut AppBarButton) -> HRESULT
}}
impl IAppBarButtonFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<AppBarButton>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBarButton3, 187179344, 6539, 20100, 143, 28, 159, 106, 139, 162, 103, 167);
RT_INTERFACE!{interface IAppBarButton3(IAppBarButton3Vtbl): IInspectable(IInspectableVtbl) [IID_IAppBarButton3] {
    fn get_LabelPosition(&self, out: *mut CommandBarLabelPosition) -> HRESULT,
    fn put_LabelPosition(&self, value: CommandBarLabelPosition) -> HRESULT
}}
impl IAppBarButton3 {
    #[inline] pub unsafe fn get_label_position(&self) -> Result<CommandBarLabelPosition> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LabelPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_label_position(&self, value: CommandBarLabelPosition) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LabelPosition)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBarButtonStatics3, 1299968788, 11998, 17192, 137, 6, 117, 42, 31, 39, 205, 250);
RT_INTERFACE!{static interface IAppBarButtonStatics3(IAppBarButtonStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IAppBarButtonStatics3] {
    fn get_LabelPositionProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsInOverflowProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DynamicOverflowOrderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IAppBarButtonStatics3 {
    #[inline] pub unsafe fn get_label_position_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LabelPositionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_in_overflow_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsInOverflowProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_dynamic_overflow_order_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DynamicOverflowOrderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBarToggleButton, 781272120, 64851, 19341, 133, 139, 54, 68, 38, 159, 142, 77);
RT_INTERFACE!{interface IAppBarToggleButton(IAppBarToggleButtonVtbl): IInspectable(IInspectableVtbl) [IID_IAppBarToggleButton] {
    fn get_Label(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Label(&self, value: HSTRING) -> HRESULT,
    fn get_Icon(&self, out: *mut *mut IconElement) -> HRESULT,
    fn put_Icon(&self, value: *mut IconElement) -> HRESULT
}}
impl IAppBarToggleButton {
    #[inline] pub unsafe fn get_label(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Label)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_label(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Label)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_icon(&self) -> Result<ComPtr<IconElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Icon)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_icon(&self, value: &IconElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Icon)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBarToggleButtonStatics, 4267356054, 31017, 19873, 170, 103, 205, 223, 115, 163, 228, 181);
RT_INTERFACE!{static interface IAppBarToggleButtonStatics(IAppBarToggleButtonStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAppBarToggleButtonStatics] {
    fn get_LabelProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IconProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsCompactProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IAppBarToggleButtonStatics {
    #[inline] pub unsafe fn get_label_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LabelProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_icon_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IconProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_compact_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsCompactProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBarToggleButtonFactory, 42641364, 36692, 17830, 159, 144, 19, 96, 86, 86, 215, 147);
RT_INTERFACE!{interface IAppBarToggleButtonFactory(IAppBarToggleButtonFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAppBarToggleButtonFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut AppBarToggleButton) -> HRESULT
}}
impl IAppBarToggleButtonFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<AppBarToggleButton>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBarToggleButton3, 4019881445, 5887, 19826, 185, 232, 155, 134, 30, 175, 132, 168);
RT_INTERFACE!{interface IAppBarToggleButton3(IAppBarToggleButton3Vtbl): IInspectable(IInspectableVtbl) [IID_IAppBarToggleButton3] {
    fn get_LabelPosition(&self, out: *mut CommandBarLabelPosition) -> HRESULT,
    fn put_LabelPosition(&self, value: CommandBarLabelPosition) -> HRESULT
}}
impl IAppBarToggleButton3 {
    #[inline] pub unsafe fn get_label_position(&self) -> Result<CommandBarLabelPosition> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LabelPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_label_position(&self, value: CommandBarLabelPosition) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LabelPosition)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBarToggleButtonStatics3, 3175900607, 11997, 17617, 172, 213, 53, 192, 14, 47, 33, 188);
RT_INTERFACE!{static interface IAppBarToggleButtonStatics3(IAppBarToggleButtonStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IAppBarToggleButtonStatics3] {
    fn get_LabelPositionProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsInOverflowProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DynamicOverflowOrderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IAppBarToggleButtonStatics3 {
    #[inline] pub unsafe fn get_label_position_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LabelPositionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_in_overflow_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsInOverflowProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_dynamic_overflow_order_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DynamicOverflowOrderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGridView, 40560948, 46718, 19840, 143, 114, 138, 166, 75, 77, 130, 123);
RT_INTERFACE!{interface IGridView(IGridViewVtbl): IInspectable(IInspectableVtbl) [IID_IGridView] {
    
}}
DEFINE_IID!(IID_IGridViewFactory, 3653028489, 2553, 19566, 168, 62, 241, 153, 20, 111, 14, 125);
RT_INTERFACE!{interface IGridViewFactory(IGridViewFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGridViewFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut GridView) -> HRESULT
}}
impl IGridViewFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<GridView>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListView, 4140731501, 65174, 16813, 166, 74, 194, 184, 28, 74, 247, 248);
RT_INTERFACE!{interface IListView(IListViewVtbl): IInspectable(IInspectableVtbl) [IID_IListView] {
    
}}
DEFINE_IID!(IID_IListViewFactory, 3187632493, 16162, 16889, 151, 166, 136, 49, 52, 167, 97, 19);
RT_INTERFACE!{interface IListViewFactory(IListViewFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IListViewFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ListView) -> HRESULT
}}
impl IListViewFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ListView>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_ENUM! { enum LightDismissOverlayMode: i32 {
    Auto (LightDismissOverlayMode_Auto) = 0, On (LightDismissOverlayMode_On) = 1, Off (LightDismissOverlayMode_Off) = 2,
}}
RT_ENUM! { enum RequiresPointer: i32 {
    Never (RequiresPointer_Never) = 0, WhenEngaged (RequiresPointer_WhenEngaged) = 1, WhenFocused (RequiresPointer_WhenFocused) = 2,
}}
RT_CLASS!{class ColumnDefinition: IColumnDefinition}
impl RtActivatable<IColumnDefinitionStatics> for ColumnDefinition {}
impl RtActivatable<IActivationFactory> for ColumnDefinition {}
impl ColumnDefinition {
    #[inline] pub fn get_width_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IColumnDefinitionStatics>>::get_activation_factory().get_width_property()
    }}
    #[inline] pub fn get_max_width_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IColumnDefinitionStatics>>::get_activation_factory().get_max_width_property()
    }}
    #[inline] pub fn get_min_width_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IColumnDefinitionStatics>>::get_activation_factory().get_min_width_property()
    }}
}
DEFINE_CLSID!(ColumnDefinition(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,67,111,108,117,109,110,68,101,102,105,110,105,116,105,111,110,0]) [CLSID_ColumnDefinition]);
RT_CLASS!{class RowDefinition: IRowDefinition}
impl RtActivatable<IRowDefinitionStatics> for RowDefinition {}
impl RtActivatable<IActivationFactory> for RowDefinition {}
impl RowDefinition {
    #[inline] pub fn get_height_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRowDefinitionStatics>>::get_activation_factory().get_height_property()
    }}
    #[inline] pub fn get_max_height_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRowDefinitionStatics>>::get_activation_factory().get_max_height_property()
    }}
    #[inline] pub fn get_min_height_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRowDefinitionStatics>>::get_activation_factory().get_min_height_property()
    }}
}
DEFINE_CLSID!(RowDefinition(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,82,111,119,68,101,102,105,110,105,116,105,111,110,0]) [CLSID_RowDefinition]);
RT_CLASS!{class AutoSuggestBoxQuerySubmittedEventArgs: IAutoSuggestBoxQuerySubmittedEventArgs}
impl RtActivatable<IActivationFactory> for AutoSuggestBoxQuerySubmittedEventArgs {}
DEFINE_CLSID!(AutoSuggestBoxQuerySubmittedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,65,117,116,111,83,117,103,103,101,115,116,66,111,120,81,117,101,114,121,83,117,98,109,105,116,116,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_AutoSuggestBoxQuerySubmittedEventArgs]);
RT_CLASS!{class AutoSuggestBoxSuggestionChosenEventArgs: IAutoSuggestBoxSuggestionChosenEventArgs}
impl RtActivatable<IActivationFactory> for AutoSuggestBoxSuggestionChosenEventArgs {}
DEFINE_CLSID!(AutoSuggestBoxSuggestionChosenEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,65,117,116,111,83,117,103,103,101,115,116,66,111,120,83,117,103,103,101,115,116,105,111,110,67,104,111,115,101,110,69,118,101,110,116,65,114,103,115,0]) [CLSID_AutoSuggestBoxSuggestionChosenEventArgs]);
RT_CLASS!{class AutoSuggestBoxTextChangedEventArgs: IAutoSuggestBoxTextChangedEventArgs}
impl RtActivatable<IAutoSuggestBoxTextChangedEventArgsStatics> for AutoSuggestBoxTextChangedEventArgs {}
impl RtActivatable<IActivationFactory> for AutoSuggestBoxTextChangedEventArgs {}
impl AutoSuggestBoxTextChangedEventArgs {
    #[inline] pub fn get_reason_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutoSuggestBoxTextChangedEventArgsStatics>>::get_activation_factory().get_reason_property()
    }}
}
DEFINE_CLSID!(AutoSuggestBoxTextChangedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,65,117,116,111,83,117,103,103,101,115,116,66,111,120,84,101,120,116,67,104,97,110,103,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_AutoSuggestBoxTextChangedEventArgs]);
RT_CLASS!{class CleanUpVirtualizedItemEventArgs: ICleanUpVirtualizedItemEventArgs}
RT_CLASS!{class ContextMenuEventArgs: IContextMenuEventArgs}
RT_CLASS!{class ItemClickEventArgs: IItemClickEventArgs}
impl RtActivatable<IActivationFactory> for ItemClickEventArgs {}
DEFINE_CLSID!(ItemClickEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,73,116,101,109,67,108,105,99,107,69,118,101,110,116,65,114,103,115,0]) [CLSID_ItemClickEventArgs]);
RT_CLASS!{class SelectionChangedEventArgs: ISelectionChangedEventArgs}
RT_CLASS!{class TextChangedEventArgs: ITextChangedEventArgs}
RT_CLASS!{class ItemsPanelTemplate: IItemsPanelTemplate}
impl RtActivatable<IActivationFactory> for ItemsPanelTemplate {}
DEFINE_CLSID!(ItemsPanelTemplate(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,73,116,101,109,115,80,97,110,101,108,84,101,109,112,108,97,116,101,0]) [CLSID_ItemsPanelTemplate]);
RT_CLASS!{class Panel: IPanel}
impl RtActivatable<IPanelStatics> for Panel {}
impl Panel {
    #[inline] pub fn get_background_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPanelStatics>>::get_activation_factory().get_background_property()
    }}
    #[inline] pub fn get_is_items_host_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPanelStatics>>::get_activation_factory().get_is_items_host_property()
    }}
    #[inline] pub fn get_children_transitions_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPanelStatics>>::get_activation_factory().get_children_transitions_property()
    }}
}
DEFINE_CLSID!(Panel(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,97,110,101,108,0]) [CLSID_Panel]);
RT_CLASS!{class Border: IBorder}
impl RtActivatable<IBorderStatics> for Border {}
impl RtActivatable<IActivationFactory> for Border {}
impl Border {
    #[inline] pub fn get_border_brush_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBorderStatics>>::get_activation_factory().get_border_brush_property()
    }}
    #[inline] pub fn get_border_thickness_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBorderStatics>>::get_activation_factory().get_border_thickness_property()
    }}
    #[inline] pub fn get_background_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBorderStatics>>::get_activation_factory().get_background_property()
    }}
    #[inline] pub fn get_corner_radius_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBorderStatics>>::get_activation_factory().get_corner_radius_property()
    }}
    #[inline] pub fn get_padding_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBorderStatics>>::get_activation_factory().get_padding_property()
    }}
    #[inline] pub fn get_child_transitions_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBorderStatics>>::get_activation_factory().get_child_transitions_property()
    }}
}
DEFINE_CLSID!(Border(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,66,111,114,100,101,114,0]) [CLSID_Border]);
RT_CLASS!{class CaptureElement: ICaptureElement}
impl RtActivatable<ICaptureElementStatics> for CaptureElement {}
impl RtActivatable<IActivationFactory> for CaptureElement {}
impl CaptureElement {
    #[inline] pub fn get_source_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICaptureElementStatics>>::get_activation_factory().get_source_property()
    }}
    #[inline] pub fn get_stretch_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICaptureElementStatics>>::get_activation_factory().get_stretch_property()
    }}
}
DEFINE_CLSID!(CaptureElement(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,67,97,112,116,117,114,101,69,108,101,109,101,110,116,0]) [CLSID_CaptureElement]);
RT_CLASS!{class ContentPresenter: IContentPresenter}
impl RtActivatable<IContentPresenterStatics3> for ContentPresenter {}
impl RtActivatable<IContentPresenterStatics2> for ContentPresenter {}
impl RtActivatable<IContentPresenterStatics> for ContentPresenter {}
impl RtActivatable<IContentPresenterStatics4> for ContentPresenter {}
impl ContentPresenter {
    #[inline] pub fn get_is_text_scale_factor_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics3>>::get_activation_factory().get_is_text_scale_factor_enabled_property()
    }}
    #[inline] pub fn get_optical_margin_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics2>>::get_activation_factory().get_optical_margin_alignment_property()
    }}
    #[inline] pub fn get_text_line_bounds_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics2>>::get_activation_factory().get_text_line_bounds_property()
    }}
    #[inline] pub fn get_content_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics>>::get_activation_factory().get_content_property()
    }}
    #[inline] pub fn get_content_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics>>::get_activation_factory().get_content_template_property()
    }}
    #[inline] pub fn get_content_template_selector_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics>>::get_activation_factory().get_content_template_selector_property()
    }}
    #[inline] pub fn get_content_transitions_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics>>::get_activation_factory().get_content_transitions_property()
    }}
    #[inline] pub fn get_font_size_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics>>::get_activation_factory().get_font_size_property()
    }}
    #[inline] pub fn get_font_family_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics>>::get_activation_factory().get_font_family_property()
    }}
    #[inline] pub fn get_font_weight_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics>>::get_activation_factory().get_font_weight_property()
    }}
    #[inline] pub fn get_font_style_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics>>::get_activation_factory().get_font_style_property()
    }}
    #[inline] pub fn get_font_stretch_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics>>::get_activation_factory().get_font_stretch_property()
    }}
    #[inline] pub fn get_character_spacing_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics>>::get_activation_factory().get_character_spacing_property()
    }}
    #[inline] pub fn get_foreground_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics>>::get_activation_factory().get_foreground_property()
    }}
    #[inline] pub fn get_text_wrapping_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics4>>::get_activation_factory().get_text_wrapping_property()
    }}
    #[inline] pub fn get_max_lines_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics4>>::get_activation_factory().get_max_lines_property()
    }}
    #[inline] pub fn get_line_stacking_strategy_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics4>>::get_activation_factory().get_line_stacking_strategy_property()
    }}
    #[inline] pub fn get_line_height_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics4>>::get_activation_factory().get_line_height_property()
    }}
    #[inline] pub fn get_border_brush_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics4>>::get_activation_factory().get_border_brush_property()
    }}
    #[inline] pub fn get_border_thickness_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics4>>::get_activation_factory().get_border_thickness_property()
    }}
    #[inline] pub fn get_corner_radius_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics4>>::get_activation_factory().get_corner_radius_property()
    }}
    #[inline] pub fn get_padding_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics4>>::get_activation_factory().get_padding_property()
    }}
    #[inline] pub fn get_background_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics4>>::get_activation_factory().get_background_property()
    }}
    #[inline] pub fn get_horizontal_content_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics4>>::get_activation_factory().get_horizontal_content_alignment_property()
    }}
    #[inline] pub fn get_vertical_content_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentPresenterStatics4>>::get_activation_factory().get_vertical_content_alignment_property()
    }}
}
DEFINE_CLSID!(ContentPresenter(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,67,111,110,116,101,110,116,80,114,101,115,101,110,116,101,114,0]) [CLSID_ContentPresenter]);
RT_CLASS!{class Image: IImage}
impl RtActivatable<IImageStatics> for Image {}
impl RtActivatable<IActivationFactory> for Image {}
impl Image {
    #[inline] pub fn get_source_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IImageStatics>>::get_activation_factory().get_source_property()
    }}
    #[inline] pub fn get_stretch_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IImageStatics>>::get_activation_factory().get_stretch_property()
    }}
    #[inline] pub fn get_nine_grid_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IImageStatics>>::get_activation_factory().get_nine_grid_property()
    }}
    #[inline] pub fn get_play_to_source_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IImageStatics>>::get_activation_factory().get_play_to_source_property()
    }}
}
DEFINE_CLSID!(Image(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,73,109,97,103,101,0]) [CLSID_Image]);
RT_CLASS!{class ItemsPresenter: IItemsPresenter}
impl RtActivatable<IItemsPresenterStatics> for ItemsPresenter {}
impl RtActivatable<IItemsPresenterStatics2> for ItemsPresenter {}
impl RtActivatable<IActivationFactory> for ItemsPresenter {}
impl ItemsPresenter {
    #[inline] pub fn get_header_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsPresenterStatics>>::get_activation_factory().get_header_property()
    }}
    #[inline] pub fn get_header_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsPresenterStatics>>::get_activation_factory().get_header_template_property()
    }}
    #[inline] pub fn get_header_transitions_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsPresenterStatics>>::get_activation_factory().get_header_transitions_property()
    }}
    #[inline] pub fn get_padding_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsPresenterStatics>>::get_activation_factory().get_padding_property()
    }}
    #[inline] pub fn get_footer_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsPresenterStatics2>>::get_activation_factory().get_footer_property()
    }}
    #[inline] pub fn get_footer_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsPresenterStatics2>>::get_activation_factory().get_footer_template_property()
    }}
    #[inline] pub fn get_footer_transitions_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsPresenterStatics2>>::get_activation_factory().get_footer_transitions_property()
    }}
}
DEFINE_CLSID!(ItemsPresenter(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,73,116,101,109,115,80,114,101,115,101,110,116,101,114,0]) [CLSID_ItemsPresenter]);
RT_CLASS!{class RichTextBlockOverflow: IRichTextBlockOverflow}
impl RtActivatable<IRichTextBlockOverflowStatics2> for RichTextBlockOverflow {}
impl RtActivatable<IRichTextBlockOverflowStatics> for RichTextBlockOverflow {}
impl RtActivatable<IActivationFactory> for RichTextBlockOverflow {}
impl RichTextBlockOverflow {
    #[inline] pub fn get_max_lines_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockOverflowStatics2>>::get_activation_factory().get_max_lines_property()
    }}
    #[inline] pub fn get_overflow_content_target_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockOverflowStatics>>::get_activation_factory().get_overflow_content_target_property()
    }}
    #[inline] pub fn get_padding_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockOverflowStatics>>::get_activation_factory().get_padding_property()
    }}
    #[inline] pub fn get_has_overflow_content_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockOverflowStatics>>::get_activation_factory().get_has_overflow_content_property()
    }}
}
DEFINE_CLSID!(RichTextBlockOverflow(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,82,105,99,104,84,101,120,116,66,108,111,99,107,79,118,101,114,102,108,111,119,0]) [CLSID_RichTextBlockOverflow]);
RT_CLASS!{class RichTextBlock: IRichTextBlock}
impl RtActivatable<IRichTextBlockStatics3> for RichTextBlock {}
impl RtActivatable<IRichTextBlockStatics4> for RichTextBlock {}
impl RtActivatable<IRichTextBlockStatics2> for RichTextBlock {}
impl RtActivatable<IRichTextBlockStatics> for RichTextBlock {}
impl RtActivatable<IActivationFactory> for RichTextBlock {}
impl RichTextBlock {
    #[inline] pub fn get_is_text_scale_factor_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics3>>::get_activation_factory().get_is_text_scale_factor_enabled_property()
    }}
    #[inline] pub fn get_text_decorations_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics4>>::get_activation_factory().get_text_decorations_property()
    }}
    #[inline] pub fn get_max_lines_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics2>>::get_activation_factory().get_max_lines_property()
    }}
    #[inline] pub fn get_text_line_bounds_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics2>>::get_activation_factory().get_text_line_bounds_property()
    }}
    #[inline] pub fn get_selection_highlight_color_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics2>>::get_activation_factory().get_selection_highlight_color_property()
    }}
    #[inline] pub fn get_optical_margin_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics2>>::get_activation_factory().get_optical_margin_alignment_property()
    }}
    #[inline] pub fn get_is_color_font_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics2>>::get_activation_factory().get_is_color_font_enabled_property()
    }}
    #[inline] pub fn get_text_reading_order_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics2>>::get_activation_factory().get_text_reading_order_property()
    }}
    #[inline] pub fn get_font_size_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics>>::get_activation_factory().get_font_size_property()
    }}
    #[inline] pub fn get_font_family_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics>>::get_activation_factory().get_font_family_property()
    }}
    #[inline] pub fn get_font_weight_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics>>::get_activation_factory().get_font_weight_property()
    }}
    #[inline] pub fn get_font_style_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics>>::get_activation_factory().get_font_style_property()
    }}
    #[inline] pub fn get_font_stretch_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics>>::get_activation_factory().get_font_stretch_property()
    }}
    #[inline] pub fn get_foreground_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics>>::get_activation_factory().get_foreground_property()
    }}
    #[inline] pub fn get_text_wrapping_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics>>::get_activation_factory().get_text_wrapping_property()
    }}
    #[inline] pub fn get_text_trimming_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics>>::get_activation_factory().get_text_trimming_property()
    }}
    #[inline] pub fn get_text_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics>>::get_activation_factory().get_text_alignment_property()
    }}
    #[inline] pub fn get_padding_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics>>::get_activation_factory().get_padding_property()
    }}
    #[inline] pub fn get_line_height_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics>>::get_activation_factory().get_line_height_property()
    }}
    #[inline] pub fn get_line_stacking_strategy_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics>>::get_activation_factory().get_line_stacking_strategy_property()
    }}
    #[inline] pub fn get_character_spacing_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics>>::get_activation_factory().get_character_spacing_property()
    }}
    #[inline] pub fn get_overflow_content_target_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics>>::get_activation_factory().get_overflow_content_target_property()
    }}
    #[inline] pub fn get_is_text_selection_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics>>::get_activation_factory().get_is_text_selection_enabled_property()
    }}
    #[inline] pub fn get_has_overflow_content_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics>>::get_activation_factory().get_has_overflow_content_property()
    }}
    #[inline] pub fn get_selected_text_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics>>::get_activation_factory().get_selected_text_property()
    }}
    #[inline] pub fn get_text_indent_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichTextBlockStatics>>::get_activation_factory().get_text_indent_property()
    }}
}
DEFINE_CLSID!(RichTextBlock(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,82,105,99,104,84,101,120,116,66,108,111,99,107,0]) [CLSID_RichTextBlock]);
RT_CLASS!{class TextBlock: ITextBlock}
impl RtActivatable<ITextBlockStatics> for TextBlock {}
impl RtActivatable<ITextBlockStatics5> for TextBlock {}
impl RtActivatable<ITextBlockStatics2> for TextBlock {}
impl RtActivatable<ITextBlockStatics3> for TextBlock {}
impl RtActivatable<IActivationFactory> for TextBlock {}
impl TextBlock {
    #[inline] pub fn get_font_size_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics>>::get_activation_factory().get_font_size_property()
    }}
    #[inline] pub fn get_font_family_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics>>::get_activation_factory().get_font_family_property()
    }}
    #[inline] pub fn get_font_weight_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics>>::get_activation_factory().get_font_weight_property()
    }}
    #[inline] pub fn get_font_style_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics>>::get_activation_factory().get_font_style_property()
    }}
    #[inline] pub fn get_font_stretch_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics>>::get_activation_factory().get_font_stretch_property()
    }}
    #[inline] pub fn get_character_spacing_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics>>::get_activation_factory().get_character_spacing_property()
    }}
    #[inline] pub fn get_foreground_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics>>::get_activation_factory().get_foreground_property()
    }}
    #[inline] pub fn get_text_wrapping_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics>>::get_activation_factory().get_text_wrapping_property()
    }}
    #[inline] pub fn get_text_trimming_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics>>::get_activation_factory().get_text_trimming_property()
    }}
    #[inline] pub fn get_text_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics>>::get_activation_factory().get_text_alignment_property()
    }}
    #[inline] pub fn get_text_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics>>::get_activation_factory().get_text_property()
    }}
    #[inline] pub fn get_padding_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics>>::get_activation_factory().get_padding_property()
    }}
    #[inline] pub fn get_line_height_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics>>::get_activation_factory().get_line_height_property()
    }}
    #[inline] pub fn get_line_stacking_strategy_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics>>::get_activation_factory().get_line_stacking_strategy_property()
    }}
    #[inline] pub fn get_is_text_selection_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics>>::get_activation_factory().get_is_text_selection_enabled_property()
    }}
    #[inline] pub fn get_selected_text_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics>>::get_activation_factory().get_selected_text_property()
    }}
    #[inline] pub fn get_text_decorations_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics5>>::get_activation_factory().get_text_decorations_property()
    }}
    #[inline] pub fn get_selection_highlight_color_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics2>>::get_activation_factory().get_selection_highlight_color_property()
    }}
    #[inline] pub fn get_max_lines_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics2>>::get_activation_factory().get_max_lines_property()
    }}
    #[inline] pub fn get_text_line_bounds_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics2>>::get_activation_factory().get_text_line_bounds_property()
    }}
    #[inline] pub fn get_optical_margin_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics2>>::get_activation_factory().get_optical_margin_alignment_property()
    }}
    #[inline] pub fn get_is_color_font_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics2>>::get_activation_factory().get_is_color_font_enabled_property()
    }}
    #[inline] pub fn get_text_reading_order_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics2>>::get_activation_factory().get_text_reading_order_property()
    }}
    #[inline] pub fn get_is_text_scale_factor_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBlockStatics3>>::get_activation_factory().get_is_text_scale_factor_enabled_property()
    }}
}
DEFINE_CLSID!(TextBlock(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,84,101,120,116,66,108,111,99,107,0]) [CLSID_TextBlock]);
RT_CLASS!{class Viewbox: IViewbox}
impl RtActivatable<IViewboxStatics> for Viewbox {}
impl RtActivatable<IActivationFactory> for Viewbox {}
impl Viewbox {
    #[inline] pub fn get_stretch_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IViewboxStatics>>::get_activation_factory().get_stretch_property()
    }}
    #[inline] pub fn get_stretch_direction_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IViewboxStatics>>::get_activation_factory().get_stretch_direction_property()
    }}
}
DEFINE_CLSID!(Viewbox(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,86,105,101,119,98,111,120,0]) [CLSID_Viewbox]);
RT_CLASS!{class Canvas: ICanvas}
impl RtActivatable<ICanvasStatics> for Canvas {}
impl Canvas {
    #[inline] pub fn get_left_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICanvasStatics>>::get_activation_factory().get_left_property()
    }}
    #[inline] pub fn get_left(element: &super::UIElement) -> Result<f64> { unsafe {
        <Self as RtActivatable<ICanvasStatics>>::get_activation_factory().get_left(element)
    }}
    #[inline] pub fn set_left(element: &super::UIElement, length: f64) -> Result<()> { unsafe {
        <Self as RtActivatable<ICanvasStatics>>::get_activation_factory().set_left(element, length)
    }}
    #[inline] pub fn get_top_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICanvasStatics>>::get_activation_factory().get_top_property()
    }}
    #[inline] pub fn get_top(element: &super::UIElement) -> Result<f64> { unsafe {
        <Self as RtActivatable<ICanvasStatics>>::get_activation_factory().get_top(element)
    }}
    #[inline] pub fn set_top(element: &super::UIElement, length: f64) -> Result<()> { unsafe {
        <Self as RtActivatable<ICanvasStatics>>::get_activation_factory().set_top(element, length)
    }}
    #[inline] pub fn get_zindex_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICanvasStatics>>::get_activation_factory().get_zindex_property()
    }}
    #[inline] pub fn get_zindex(element: &super::UIElement) -> Result<i32> { unsafe {
        <Self as RtActivatable<ICanvasStatics>>::get_activation_factory().get_zindex(element)
    }}
    #[inline] pub fn set_zindex(element: &super::UIElement, value: i32) -> Result<()> { unsafe {
        <Self as RtActivatable<ICanvasStatics>>::get_activation_factory().set_zindex(element, value)
    }}
}
DEFINE_CLSID!(Canvas(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,67,97,110,118,97,115,0]) [CLSID_Canvas]);
RT_CLASS!{class Grid: IGrid}
impl RtActivatable<IGridStatics> for Grid {}
impl RtActivatable<IGridStatics2> for Grid {}
impl Grid {
    #[inline] pub fn get_row_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridStatics>>::get_activation_factory().get_row_property()
    }}
    #[inline] pub fn get_row(element: &super::FrameworkElement) -> Result<i32> { unsafe {
        <Self as RtActivatable<IGridStatics>>::get_activation_factory().get_row(element)
    }}
    #[inline] pub fn set_row(element: &super::FrameworkElement, value: i32) -> Result<()> { unsafe {
        <Self as RtActivatable<IGridStatics>>::get_activation_factory().set_row(element, value)
    }}
    #[inline] pub fn get_column_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridStatics>>::get_activation_factory().get_column_property()
    }}
    #[inline] pub fn get_column(element: &super::FrameworkElement) -> Result<i32> { unsafe {
        <Self as RtActivatable<IGridStatics>>::get_activation_factory().get_column(element)
    }}
    #[inline] pub fn set_column(element: &super::FrameworkElement, value: i32) -> Result<()> { unsafe {
        <Self as RtActivatable<IGridStatics>>::get_activation_factory().set_column(element, value)
    }}
    #[inline] pub fn get_row_span_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridStatics>>::get_activation_factory().get_row_span_property()
    }}
    #[inline] pub fn get_row_span(element: &super::FrameworkElement) -> Result<i32> { unsafe {
        <Self as RtActivatable<IGridStatics>>::get_activation_factory().get_row_span(element)
    }}
    #[inline] pub fn set_row_span(element: &super::FrameworkElement, value: i32) -> Result<()> { unsafe {
        <Self as RtActivatable<IGridStatics>>::get_activation_factory().set_row_span(element, value)
    }}
    #[inline] pub fn get_column_span_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridStatics>>::get_activation_factory().get_column_span_property()
    }}
    #[inline] pub fn get_column_span(element: &super::FrameworkElement) -> Result<i32> { unsafe {
        <Self as RtActivatable<IGridStatics>>::get_activation_factory().get_column_span(element)
    }}
    #[inline] pub fn set_column_span(element: &super::FrameworkElement, value: i32) -> Result<()> { unsafe {
        <Self as RtActivatable<IGridStatics>>::get_activation_factory().set_column_span(element, value)
    }}
    #[inline] pub fn get_border_brush_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridStatics2>>::get_activation_factory().get_border_brush_property()
    }}
    #[inline] pub fn get_border_thickness_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridStatics2>>::get_activation_factory().get_border_thickness_property()
    }}
    #[inline] pub fn get_corner_radius_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridStatics2>>::get_activation_factory().get_corner_radius_property()
    }}
    #[inline] pub fn get_padding_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridStatics2>>::get_activation_factory().get_padding_property()
    }}
}
DEFINE_CLSID!(Grid(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,71,114,105,100,0]) [CLSID_Grid]);
RT_CLASS!{class RelativePanel: IRelativePanel}
impl RtActivatable<IRelativePanelStatics> for RelativePanel {}
impl RelativePanel {
    #[inline] pub fn get_left_of_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_left_of_property()
    }}
    #[inline] pub fn get_left_of(element: &super::UIElement) -> Result<ComPtr<IInspectable>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_left_of(element)
    }}
    #[inline] pub fn set_left_of(element: &super::UIElement, value: &IInspectable) -> Result<()> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().set_left_of(element, value)
    }}
    #[inline] pub fn get_above_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_above_property()
    }}
    #[inline] pub fn get_above(element: &super::UIElement) -> Result<ComPtr<IInspectable>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_above(element)
    }}
    #[inline] pub fn set_above(element: &super::UIElement, value: &IInspectable) -> Result<()> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().set_above(element, value)
    }}
    #[inline] pub fn get_right_of_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_right_of_property()
    }}
    #[inline] pub fn get_right_of(element: &super::UIElement) -> Result<ComPtr<IInspectable>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_right_of(element)
    }}
    #[inline] pub fn set_right_of(element: &super::UIElement, value: &IInspectable) -> Result<()> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().set_right_of(element, value)
    }}
    #[inline] pub fn get_below_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_below_property()
    }}
    #[inline] pub fn get_below(element: &super::UIElement) -> Result<ComPtr<IInspectable>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_below(element)
    }}
    #[inline] pub fn set_below(element: &super::UIElement, value: &IInspectable) -> Result<()> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().set_below(element, value)
    }}
    #[inline] pub fn get_align_horizontal_center_with_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_horizontal_center_with_property()
    }}
    #[inline] pub fn get_align_horizontal_center_with(element: &super::UIElement) -> Result<ComPtr<IInspectable>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_horizontal_center_with(element)
    }}
    #[inline] pub fn set_align_horizontal_center_with(element: &super::UIElement, value: &IInspectable) -> Result<()> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().set_align_horizontal_center_with(element, value)
    }}
    #[inline] pub fn get_align_vertical_center_with_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_vertical_center_with_property()
    }}
    #[inline] pub fn get_align_vertical_center_with(element: &super::UIElement) -> Result<ComPtr<IInspectable>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_vertical_center_with(element)
    }}
    #[inline] pub fn set_align_vertical_center_with(element: &super::UIElement, value: &IInspectable) -> Result<()> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().set_align_vertical_center_with(element, value)
    }}
    #[inline] pub fn get_align_left_with_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_left_with_property()
    }}
    #[inline] pub fn get_align_left_with(element: &super::UIElement) -> Result<ComPtr<IInspectable>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_left_with(element)
    }}
    #[inline] pub fn set_align_left_with(element: &super::UIElement, value: &IInspectable) -> Result<()> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().set_align_left_with(element, value)
    }}
    #[inline] pub fn get_align_top_with_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_top_with_property()
    }}
    #[inline] pub fn get_align_top_with(element: &super::UIElement) -> Result<ComPtr<IInspectable>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_top_with(element)
    }}
    #[inline] pub fn set_align_top_with(element: &super::UIElement, value: &IInspectable) -> Result<()> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().set_align_top_with(element, value)
    }}
    #[inline] pub fn get_align_right_with_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_right_with_property()
    }}
    #[inline] pub fn get_align_right_with(element: &super::UIElement) -> Result<ComPtr<IInspectable>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_right_with(element)
    }}
    #[inline] pub fn set_align_right_with(element: &super::UIElement, value: &IInspectable) -> Result<()> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().set_align_right_with(element, value)
    }}
    #[inline] pub fn get_align_bottom_with_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_bottom_with_property()
    }}
    #[inline] pub fn get_align_bottom_with(element: &super::UIElement) -> Result<ComPtr<IInspectable>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_bottom_with(element)
    }}
    #[inline] pub fn set_align_bottom_with(element: &super::UIElement, value: &IInspectable) -> Result<()> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().set_align_bottom_with(element, value)
    }}
    #[inline] pub fn get_align_left_with_panel_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_left_with_panel_property()
    }}
    #[inline] pub fn get_align_left_with_panel(element: &super::UIElement) -> Result<bool> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_left_with_panel(element)
    }}
    #[inline] pub fn set_align_left_with_panel(element: &super::UIElement, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().set_align_left_with_panel(element, value)
    }}
    #[inline] pub fn get_align_top_with_panel_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_top_with_panel_property()
    }}
    #[inline] pub fn get_align_top_with_panel(element: &super::UIElement) -> Result<bool> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_top_with_panel(element)
    }}
    #[inline] pub fn set_align_top_with_panel(element: &super::UIElement, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().set_align_top_with_panel(element, value)
    }}
    #[inline] pub fn get_align_right_with_panel_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_right_with_panel_property()
    }}
    #[inline] pub fn get_align_right_with_panel(element: &super::UIElement) -> Result<bool> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_right_with_panel(element)
    }}
    #[inline] pub fn set_align_right_with_panel(element: &super::UIElement, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().set_align_right_with_panel(element, value)
    }}
    #[inline] pub fn get_align_bottom_with_panel_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_bottom_with_panel_property()
    }}
    #[inline] pub fn get_align_bottom_with_panel(element: &super::UIElement) -> Result<bool> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_bottom_with_panel(element)
    }}
    #[inline] pub fn set_align_bottom_with_panel(element: &super::UIElement, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().set_align_bottom_with_panel(element, value)
    }}
    #[inline] pub fn get_align_horizontal_center_with_panel_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_horizontal_center_with_panel_property()
    }}
    #[inline] pub fn get_align_horizontal_center_with_panel(element: &super::UIElement) -> Result<bool> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_horizontal_center_with_panel(element)
    }}
    #[inline] pub fn set_align_horizontal_center_with_panel(element: &super::UIElement, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().set_align_horizontal_center_with_panel(element, value)
    }}
    #[inline] pub fn get_align_vertical_center_with_panel_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_vertical_center_with_panel_property()
    }}
    #[inline] pub fn get_align_vertical_center_with_panel(element: &super::UIElement) -> Result<bool> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_align_vertical_center_with_panel(element)
    }}
    #[inline] pub fn set_align_vertical_center_with_panel(element: &super::UIElement, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().set_align_vertical_center_with_panel(element, value)
    }}
    #[inline] pub fn get_border_brush_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_border_brush_property()
    }}
    #[inline] pub fn get_border_thickness_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_border_thickness_property()
    }}
    #[inline] pub fn get_corner_radius_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_corner_radius_property()
    }}
    #[inline] pub fn get_padding_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRelativePanelStatics>>::get_activation_factory().get_padding_property()
    }}
}
DEFINE_CLSID!(RelativePanel(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,82,101,108,97,116,105,118,101,80,97,110,101,108,0]) [CLSID_RelativePanel]);
RT_CLASS!{class StackPanel: IStackPanel}
impl RtActivatable<IStackPanelStatics> for StackPanel {}
impl RtActivatable<IStackPanelStatics2> for StackPanel {}
impl StackPanel {
    #[inline] pub fn get_are_scroll_snap_points_regular_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IStackPanelStatics>>::get_activation_factory().get_are_scroll_snap_points_regular_property()
    }}
    #[inline] pub fn get_orientation_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IStackPanelStatics>>::get_activation_factory().get_orientation_property()
    }}
    #[inline] pub fn get_border_brush_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IStackPanelStatics2>>::get_activation_factory().get_border_brush_property()
    }}
    #[inline] pub fn get_border_thickness_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IStackPanelStatics2>>::get_activation_factory().get_border_thickness_property()
    }}
    #[inline] pub fn get_corner_radius_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IStackPanelStatics2>>::get_activation_factory().get_corner_radius_property()
    }}
    #[inline] pub fn get_padding_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IStackPanelStatics2>>::get_activation_factory().get_padding_property()
    }}
}
DEFINE_CLSID!(StackPanel(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,83,116,97,99,107,80,97,110,101,108,0]) [CLSID_StackPanel]);
RT_CLASS!{class VariableSizedWrapGrid: IVariableSizedWrapGrid}
impl RtActivatable<IVariableSizedWrapGridStatics> for VariableSizedWrapGrid {}
impl RtActivatable<IActivationFactory> for VariableSizedWrapGrid {}
impl VariableSizedWrapGrid {
    #[inline] pub fn get_item_height_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IVariableSizedWrapGridStatics>>::get_activation_factory().get_item_height_property()
    }}
    #[inline] pub fn get_item_width_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IVariableSizedWrapGridStatics>>::get_activation_factory().get_item_width_property()
    }}
    #[inline] pub fn get_orientation_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IVariableSizedWrapGridStatics>>::get_activation_factory().get_orientation_property()
    }}
    #[inline] pub fn get_horizontal_children_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IVariableSizedWrapGridStatics>>::get_activation_factory().get_horizontal_children_alignment_property()
    }}
    #[inline] pub fn get_vertical_children_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IVariableSizedWrapGridStatics>>::get_activation_factory().get_vertical_children_alignment_property()
    }}
    #[inline] pub fn get_maximum_rows_or_columns_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IVariableSizedWrapGridStatics>>::get_activation_factory().get_maximum_rows_or_columns_property()
    }}
    #[inline] pub fn get_row_span_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IVariableSizedWrapGridStatics>>::get_activation_factory().get_row_span_property()
    }}
    #[inline] pub fn get_row_span(element: &super::UIElement) -> Result<i32> { unsafe {
        <Self as RtActivatable<IVariableSizedWrapGridStatics>>::get_activation_factory().get_row_span(element)
    }}
    #[inline] pub fn set_row_span(element: &super::UIElement, value: i32) -> Result<()> { unsafe {
        <Self as RtActivatable<IVariableSizedWrapGridStatics>>::get_activation_factory().set_row_span(element, value)
    }}
    #[inline] pub fn get_column_span_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IVariableSizedWrapGridStatics>>::get_activation_factory().get_column_span_property()
    }}
    #[inline] pub fn get_column_span(element: &super::UIElement) -> Result<i32> { unsafe {
        <Self as RtActivatable<IVariableSizedWrapGridStatics>>::get_activation_factory().get_column_span(element)
    }}
    #[inline] pub fn set_column_span(element: &super::UIElement, value: i32) -> Result<()> { unsafe {
        <Self as RtActivatable<IVariableSizedWrapGridStatics>>::get_activation_factory().set_column_span(element, value)
    }}
}
DEFINE_CLSID!(VariableSizedWrapGrid(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,86,97,114,105,97,98,108,101,83,105,122,101,100,87,114,97,112,71,114,105,100,0]) [CLSID_VariableSizedWrapGrid]);
RT_CLASS!{class VirtualizingPanel: IVirtualizingPanel}
RT_CLASS!{class VirtualizingStackPanel: IVirtualizingStackPanel}
impl RtActivatable<IVirtualizingStackPanelStatics> for VirtualizingStackPanel {}
impl RtActivatable<IActivationFactory> for VirtualizingStackPanel {}
impl VirtualizingStackPanel {
    #[inline] pub fn get_are_scroll_snap_points_regular_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IVirtualizingStackPanelStatics>>::get_activation_factory().get_are_scroll_snap_points_regular_property()
    }}
    #[inline] pub fn get_orientation_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IVirtualizingStackPanelStatics>>::get_activation_factory().get_orientation_property()
    }}
    #[inline] pub fn get_virtualization_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IVirtualizingStackPanelStatics>>::get_activation_factory().get_virtualization_mode_property()
    }}
    #[inline] pub fn get_virtualization_mode(element: &super::DependencyObject) -> Result<VirtualizationMode> { unsafe {
        <Self as RtActivatable<IVirtualizingStackPanelStatics>>::get_activation_factory().get_virtualization_mode(element)
    }}
    #[inline] pub fn set_virtualization_mode(element: &super::DependencyObject, value: VirtualizationMode) -> Result<()> { unsafe {
        <Self as RtActivatable<IVirtualizingStackPanelStatics>>::get_activation_factory().set_virtualization_mode(element, value)
    }}
    #[inline] pub fn get_is_virtualizing_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IVirtualizingStackPanelStatics>>::get_activation_factory().get_is_virtualizing_property()
    }}
    #[inline] pub fn get_is_virtualizing(o: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<IVirtualizingStackPanelStatics>>::get_activation_factory().get_is_virtualizing(o)
    }}
}
DEFINE_CLSID!(VirtualizingStackPanel(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,86,105,114,116,117,97,108,105,122,105,110,103,83,116,97,99,107,80,97,110,101,108,0]) [CLSID_VirtualizingStackPanel]);
RT_CLASS!{class IconElement: IIconElement}
impl RtActivatable<IIconElementStatics> for IconElement {}
impl IconElement {
    #[inline] pub fn get_foreground_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IIconElementStatics>>::get_activation_factory().get_foreground_property()
    }}
}
DEFINE_CLSID!(IconElement(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,73,99,111,110,69,108,101,109,101,110,116,0]) [CLSID_IconElement]);
RT_CLASS!{class InkCanvas: IInkCanvas}
RT_CLASS!{class MediaElement: IMediaElement}
impl RtActivatable<IMediaElementStatics> for MediaElement {}
impl RtActivatable<IMediaElementStatics2> for MediaElement {}
impl RtActivatable<IActivationFactory> for MediaElement {}
impl MediaElement {
    #[inline] pub fn get_poster_source_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_poster_source_property()
    }}
    #[inline] pub fn get_source_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_source_property()
    }}
    #[inline] pub fn get_is_muted_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_is_muted_property()
    }}
    #[inline] pub fn get_is_audio_only_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_is_audio_only_property()
    }}
    #[inline] pub fn get_auto_play_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_auto_play_property()
    }}
    #[inline] pub fn get_volume_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_volume_property()
    }}
    #[inline] pub fn get_balance_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_balance_property()
    }}
    #[inline] pub fn get_natural_video_height_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_natural_video_height_property()
    }}
    #[inline] pub fn get_natural_video_width_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_natural_video_width_property()
    }}
    #[inline] pub fn get_natural_duration_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_natural_duration_property()
    }}
    #[inline] pub fn get_position_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_position_property()
    }}
    #[inline] pub fn get_download_progress_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_download_progress_property()
    }}
    #[inline] pub fn get_buffering_progress_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_buffering_progress_property()
    }}
    #[inline] pub fn get_download_progress_offset_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_download_progress_offset_property()
    }}
    #[inline] pub fn get_current_state_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_current_state_property()
    }}
    #[inline] pub fn get_can_seek_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_can_seek_property()
    }}
    #[inline] pub fn get_can_pause_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_can_pause_property()
    }}
    #[inline] pub fn get_audio_stream_count_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_audio_stream_count_property()
    }}
    #[inline] pub fn get_audio_stream_index_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_audio_stream_index_property()
    }}
    #[inline] pub fn get_playback_rate_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_playback_rate_property()
    }}
    #[inline] pub fn get_is_looping_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_is_looping_property()
    }}
    #[inline] pub fn get_play_to_source_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_play_to_source_property()
    }}
    #[inline] pub fn get_default_playback_rate_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_default_playback_rate_property()
    }}
    #[inline] pub fn get_aspect_ratio_width_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_aspect_ratio_width_property()
    }}
    #[inline] pub fn get_aspect_ratio_height_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_aspect_ratio_height_property()
    }}
    #[inline] pub fn get_real_time_playback_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_real_time_playback_property()
    }}
    #[inline] pub fn get_audio_category_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_audio_category_property()
    }}
    #[inline] pub fn get_audio_device_type_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_audio_device_type_property()
    }}
    #[inline] pub fn get_protection_manager_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_protection_manager_property()
    }}
    #[inline] pub fn get_stereo3_dvideo_packing_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_stereo3_dvideo_packing_mode_property()
    }}
    #[inline] pub fn get_stereo3_dvideo_render_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_stereo3_dvideo_render_mode_property()
    }}
    #[inline] pub fn get_is_stereo3_dvideo_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_is_stereo3_dvideo_property()
    }}
    #[inline] pub fn get_actual_stereo3_dvideo_packing_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics>>::get_activation_factory().get_actual_stereo3_dvideo_packing_mode_property()
    }}
    #[inline] pub fn get_are_transport_controls_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics2>>::get_activation_factory().get_are_transport_controls_enabled_property()
    }}
    #[inline] pub fn get_stretch_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics2>>::get_activation_factory().get_stretch_property()
    }}
    #[inline] pub fn get_is_full_window_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics2>>::get_activation_factory().get_is_full_window_property()
    }}
    #[inline] pub fn get_play_to_preferred_source_uri_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaElementStatics2>>::get_activation_factory().get_play_to_preferred_source_uri_property()
    }}
}
DEFINE_CLSID!(MediaElement(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,101,100,105,97,69,108,101,109,101,110,116,0]) [CLSID_MediaElement]);
RT_CLASS!{class MediaPlayerPresenter: IMediaPlayerPresenter}
impl RtActivatable<IMediaPlayerPresenterStatics> for MediaPlayerPresenter {}
impl MediaPlayerPresenter {
    #[inline] pub fn get_media_player_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaPlayerPresenterStatics>>::get_activation_factory().get_media_player_property()
    }}
    #[inline] pub fn get_stretch_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaPlayerPresenterStatics>>::get_activation_factory().get_stretch_property()
    }}
    #[inline] pub fn get_is_full_window_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaPlayerPresenterStatics>>::get_activation_factory().get_is_full_window_property()
    }}
}
DEFINE_CLSID!(MediaPlayerPresenter(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,101,100,105,97,80,108,97,121,101,114,80,114,101,115,101,110,116,101,114,0]) [CLSID_MediaPlayerPresenter]);
RT_CLASS!{class WebView: IWebView}
impl RtActivatable<IWebViewFactory4> for WebView {}
impl RtActivatable<IWebViewStatics5> for WebView {}
impl RtActivatable<IWebViewStatics2> for WebView {}
impl RtActivatable<IWebViewStatics4> for WebView {}
impl RtActivatable<IWebViewStatics> for WebView {}
impl RtActivatable<IWebViewStatics3> for WebView {}
impl RtActivatable<IActivationFactory> for WebView {}
impl WebView {
    #[inline] pub fn create_instance_with_execution_mode(executionMode: WebViewExecutionMode) -> Result<ComPtr<WebView>> { unsafe {
        <Self as RtActivatable<IWebViewFactory4>>::get_activation_factory().create_instance_with_execution_mode(executionMode)
    }}
    #[inline] pub fn get_xyfocus_left_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IWebViewStatics5>>::get_activation_factory().get_xyfocus_left_property()
    }}
    #[inline] pub fn get_xyfocus_right_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IWebViewStatics5>>::get_activation_factory().get_xyfocus_right_property()
    }}
    #[inline] pub fn get_xyfocus_up_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IWebViewStatics5>>::get_activation_factory().get_xyfocus_up_property()
    }}
    #[inline] pub fn get_xyfocus_down_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IWebViewStatics5>>::get_activation_factory().get_xyfocus_down_property()
    }}
    #[inline] pub fn get_can_go_back_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IWebViewStatics2>>::get_activation_factory().get_can_go_back_property()
    }}
    #[inline] pub fn get_can_go_forward_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IWebViewStatics2>>::get_activation_factory().get_can_go_forward_property()
    }}
    #[inline] pub fn get_document_title_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IWebViewStatics2>>::get_activation_factory().get_document_title_property()
    }}
    #[inline] pub fn get_default_background_color_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IWebViewStatics2>>::get_activation_factory().get_default_background_color_property()
    }}
    #[inline] pub fn get_default_execution_mode() -> Result<WebViewExecutionMode> { unsafe {
        <Self as RtActivatable<IWebViewStatics4>>::get_activation_factory().get_default_execution_mode()
    }}
    #[inline] pub fn clear_temporary_web_data_async() -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<IWebViewStatics4>>::get_activation_factory().clear_temporary_web_data_async()
    }}
    #[inline] pub fn get_any_script_notify_uri() -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<::rt::gen::windows::foundation::Uri>>> { unsafe {
        <Self as RtActivatable<IWebViewStatics>>::get_activation_factory().get_any_script_notify_uri()
    }}
    #[inline] pub fn get_source_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IWebViewStatics>>::get_activation_factory().get_source_property()
    }}
    #[inline] pub fn get_allowed_script_notify_uris_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IWebViewStatics>>::get_activation_factory().get_allowed_script_notify_uris_property()
    }}
    #[inline] pub fn get_data_transfer_package_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IWebViewStatics>>::get_activation_factory().get_data_transfer_package_property()
    }}
    #[inline] pub fn get_contains_full_screen_element_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IWebViewStatics3>>::get_activation_factory().get_contains_full_screen_element_property()
    }}
}
DEFINE_CLSID!(WebView(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,87,101,98,86,105,101,119,0]) [CLSID_WebView]);
RT_CLASS!{class BitmapIcon: IBitmapIcon}
impl RtActivatable<IBitmapIconStatics2> for BitmapIcon {}
impl RtActivatable<IBitmapIconStatics> for BitmapIcon {}
impl BitmapIcon {
    #[inline] pub fn get_show_as_monochrome_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBitmapIconStatics2>>::get_activation_factory().get_show_as_monochrome_property()
    }}
    #[inline] pub fn get_uri_source_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBitmapIconStatics>>::get_activation_factory().get_uri_source_property()
    }}
}
DEFINE_CLSID!(BitmapIcon(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,66,105,116,109,97,112,73,99,111,110,0]) [CLSID_BitmapIcon]);
RT_CLASS!{class FontIcon: IFontIcon}
impl RtActivatable<IFontIconStatics2> for FontIcon {}
impl RtActivatable<IFontIconStatics3> for FontIcon {}
impl RtActivatable<IFontIconStatics> for FontIcon {}
impl FontIcon {
    #[inline] pub fn get_is_text_scale_factor_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFontIconStatics2>>::get_activation_factory().get_is_text_scale_factor_enabled_property()
    }}
    #[inline] pub fn get_mirrored_when_right_to_left_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFontIconStatics3>>::get_activation_factory().get_mirrored_when_right_to_left_property()
    }}
    #[inline] pub fn get_glyph_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFontIconStatics>>::get_activation_factory().get_glyph_property()
    }}
    #[inline] pub fn get_font_size_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFontIconStatics>>::get_activation_factory().get_font_size_property()
    }}
    #[inline] pub fn get_font_family_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFontIconStatics>>::get_activation_factory().get_font_family_property()
    }}
    #[inline] pub fn get_font_weight_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFontIconStatics>>::get_activation_factory().get_font_weight_property()
    }}
    #[inline] pub fn get_font_style_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFontIconStatics>>::get_activation_factory().get_font_style_property()
    }}
}
DEFINE_CLSID!(FontIcon(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,70,111,110,116,73,99,111,110,0]) [CLSID_FontIcon]);
RT_CLASS!{class ItemsStackPanel: IItemsStackPanel}
impl RtActivatable<IItemsStackPanelStatics2> for ItemsStackPanel {}
impl RtActivatable<IItemsStackPanelStatics> for ItemsStackPanel {}
impl RtActivatable<IActivationFactory> for ItemsStackPanel {}
impl ItemsStackPanel {
    #[inline] pub fn get_are_sticky_group_headers_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsStackPanelStatics2>>::get_activation_factory().get_are_sticky_group_headers_enabled_property()
    }}
    #[inline] pub fn get_group_padding_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsStackPanelStatics>>::get_activation_factory().get_group_padding_property()
    }}
    #[inline] pub fn get_orientation_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsStackPanelStatics>>::get_activation_factory().get_orientation_property()
    }}
    #[inline] pub fn get_group_header_placement_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsStackPanelStatics>>::get_activation_factory().get_group_header_placement_property()
    }}
    #[inline] pub fn get_cache_length_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsStackPanelStatics>>::get_activation_factory().get_cache_length_property()
    }}
}
DEFINE_CLSID!(ItemsStackPanel(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,73,116,101,109,115,83,116,97,99,107,80,97,110,101,108,0]) [CLSID_ItemsStackPanel]);
RT_CLASS!{class ItemsWrapGrid: IItemsWrapGrid}
impl RtActivatable<IItemsWrapGridStatics2> for ItemsWrapGrid {}
impl RtActivatable<IItemsWrapGridStatics> for ItemsWrapGrid {}
impl RtActivatable<IActivationFactory> for ItemsWrapGrid {}
impl ItemsWrapGrid {
    #[inline] pub fn get_are_sticky_group_headers_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsWrapGridStatics2>>::get_activation_factory().get_are_sticky_group_headers_enabled_property()
    }}
    #[inline] pub fn get_group_padding_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsWrapGridStatics>>::get_activation_factory().get_group_padding_property()
    }}
    #[inline] pub fn get_orientation_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsWrapGridStatics>>::get_activation_factory().get_orientation_property()
    }}
    #[inline] pub fn get_maximum_rows_or_columns_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsWrapGridStatics>>::get_activation_factory().get_maximum_rows_or_columns_property()
    }}
    #[inline] pub fn get_item_width_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsWrapGridStatics>>::get_activation_factory().get_item_width_property()
    }}
    #[inline] pub fn get_item_height_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsWrapGridStatics>>::get_activation_factory().get_item_height_property()
    }}
    #[inline] pub fn get_group_header_placement_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsWrapGridStatics>>::get_activation_factory().get_group_header_placement_property()
    }}
    #[inline] pub fn get_cache_length_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsWrapGridStatics>>::get_activation_factory().get_cache_length_property()
    }}
}
DEFINE_CLSID!(ItemsWrapGrid(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,73,116,101,109,115,87,114,97,112,71,114,105,100,0]) [CLSID_ItemsWrapGrid]);
RT_CLASS!{class PathIcon: IPathIcon}
impl RtActivatable<IPathIconStatics> for PathIcon {}
impl PathIcon {
    #[inline] pub fn get_data_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPathIconStatics>>::get_activation_factory().get_data_property()
    }}
}
DEFINE_CLSID!(PathIcon(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,97,116,104,73,99,111,110,0]) [CLSID_PathIcon]);
RT_CLASS!{class ScrollContentPresenter: IScrollContentPresenter}
impl RtActivatable<IActivationFactory> for ScrollContentPresenter {}
DEFINE_CLSID!(ScrollContentPresenter(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,83,99,114,111,108,108,67,111,110,116,101,110,116,80,114,101,115,101,110,116,101,114,0]) [CLSID_ScrollContentPresenter]);
RT_CLASS!{class SymbolIcon: ISymbolIcon}
impl RtActivatable<ISymbolIconFactory> for SymbolIcon {}
impl RtActivatable<ISymbolIconStatics> for SymbolIcon {}
impl RtActivatable<IActivationFactory> for SymbolIcon {}
impl SymbolIcon {
    #[inline] pub fn create_instance_with_symbol(symbol: Symbol) -> Result<ComPtr<SymbolIcon>> { unsafe {
        <Self as RtActivatable<ISymbolIconFactory>>::get_activation_factory().create_instance_with_symbol(symbol)
    }}
    #[inline] pub fn get_symbol_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISymbolIconStatics>>::get_activation_factory().get_symbol_property()
    }}
}
DEFINE_CLSID!(SymbolIcon(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,83,121,109,98,111,108,73,99,111,110,0]) [CLSID_SymbolIcon]);
RT_CLASS!{class SwapChainBackgroundPanel: ISwapChainBackgroundPanel}
RT_CLASS!{class SwapChainPanel: ISwapChainPanel}
impl RtActivatable<ISwapChainPanelStatics> for SwapChainPanel {}
impl SwapChainPanel {
    #[inline] pub fn get_composition_scale_xproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISwapChainPanelStatics>>::get_activation_factory().get_composition_scale_xproperty()
    }}
    #[inline] pub fn get_composition_scale_yproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISwapChainPanelStatics>>::get_activation_factory().get_composition_scale_yproperty()
    }}
}
DEFINE_CLSID!(SwapChainPanel(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,83,119,97,112,67,104,97,105,110,80,97,110,101,108,0]) [CLSID_SwapChainPanel]);
RT_CLASS!{class WrapGrid: IWrapGrid}
impl RtActivatable<IWrapGridStatics> for WrapGrid {}
impl RtActivatable<IActivationFactory> for WrapGrid {}
impl WrapGrid {
    #[inline] pub fn get_item_width_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IWrapGridStatics>>::get_activation_factory().get_item_width_property()
    }}
    #[inline] pub fn get_item_height_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IWrapGridStatics>>::get_activation_factory().get_item_height_property()
    }}
    #[inline] pub fn get_orientation_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IWrapGridStatics>>::get_activation_factory().get_orientation_property()
    }}
    #[inline] pub fn get_horizontal_children_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IWrapGridStatics>>::get_activation_factory().get_horizontal_children_alignment_property()
    }}
    #[inline] pub fn get_vertical_children_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IWrapGridStatics>>::get_activation_factory().get_vertical_children_alignment_property()
    }}
    #[inline] pub fn get_maximum_rows_or_columns_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IWrapGridStatics>>::get_activation_factory().get_maximum_rows_or_columns_property()
    }}
}
DEFINE_CLSID!(WrapGrid(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,87,114,97,112,71,114,105,100,0]) [CLSID_WrapGrid]);
DEFINE_IID!(IID_IFocusDisengagedEventArgs, 1578379279, 38206, 19704, 185, 234, 197, 48, 161, 206, 2, 173);
RT_INTERFACE!{interface IFocusDisengagedEventArgs(IFocusDisengagedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IFocusDisengagedEventArgs] {
    
}}
RT_CLASS!{class FocusDisengagedEventArgs: IFocusDisengagedEventArgs}
DEFINE_IID!(IID_IFocusEngagedEventArgs, 2795488082, 55910, 16460, 130, 63, 83, 88, 89, 78, 112, 187);
RT_INTERFACE!{interface IFocusEngagedEventArgs(IFocusEngagedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IFocusEngagedEventArgs] {
    
}}
DEFINE_IID!(IID_IFocusEngagedEventArgs2, 1247404276, 34752, 19661, 147, 196, 163, 160, 28, 227, 146, 101);
RT_INTERFACE!{interface IFocusEngagedEventArgs2(IFocusEngagedEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IFocusEngagedEventArgs2] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT
}}
impl IFocusEngagedEventArgs2 {
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class FocusEngagedEventArgs: IFocusEngagedEventArgs}
DEFINE_IID!(IID_IControlTemplate, 4023533966, 16864, 18619, 139, 130, 145, 237, 161, 186, 63, 226);
RT_INTERFACE!{interface IControlTemplate(IControlTemplateVtbl): IInspectable(IInspectableVtbl) [IID_IControlTemplate] {
    fn get_TargetType(&self, out: *mut super::interop::TypeName) -> HRESULT,
    fn put_TargetType(&self, value: super::interop::TypeName) -> HRESULT
}}
impl IControlTemplate {
    #[inline] pub unsafe fn get_target_type(&self) -> Result<super::interop::TypeName> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TargetType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_type(&self, value: super::interop::TypeName) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetType)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ControlTemplate: IControlTemplate}
impl RtActivatable<IActivationFactory> for ControlTemplate {}
DEFINE_CLSID!(ControlTemplate(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,67,111,110,116,114,111,108,84,101,109,112,108,97,116,101,0]) [CLSID_ControlTemplate]);
DEFINE_IID!(IID_IControl, 2828083811, 10577, 20312, 169, 197, 90, 19, 78, 170, 127, 7);
RT_INTERFACE!{interface IControl(IControlVtbl): IInspectable(IInspectableVtbl) [IID_IControl] {
    fn get_FontSize(&self, out: *mut f64) -> HRESULT,
    fn put_FontSize(&self, value: f64) -> HRESULT,
    fn get_FontFamily(&self, out: *mut *mut super::media::FontFamily) -> HRESULT,
    fn put_FontFamily(&self, value: *mut super::media::FontFamily) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FontWeight(&self, out: *mut super::super::text::FontWeight) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_FontWeight(&self, value: super::super::text::FontWeight) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FontStyle(&self, out: *mut super::super::text::FontStyle) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_FontStyle(&self, value: super::super::text::FontStyle) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FontStretch(&self, out: *mut super::super::text::FontStretch) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy9(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_FontStretch(&self, value: super::super::text::FontStretch) -> HRESULT,
    fn get_CharacterSpacing(&self, out: *mut i32) -> HRESULT,
    fn put_CharacterSpacing(&self, value: i32) -> HRESULT,
    fn get_Foreground(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_Foreground(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_IsTabStop(&self, out: *mut bool) -> HRESULT,
    fn put_IsTabStop(&self, value: bool) -> HRESULT,
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsEnabled(&self, value: bool) -> HRESULT,
    fn get_TabIndex(&self, out: *mut i32) -> HRESULT,
    fn put_TabIndex(&self, value: i32) -> HRESULT,
    fn get_TabNavigation(&self, out: *mut super::input::KeyboardNavigationMode) -> HRESULT,
    fn put_TabNavigation(&self, value: super::input::KeyboardNavigationMode) -> HRESULT,
    fn get_Template(&self, out: *mut *mut ControlTemplate) -> HRESULT,
    fn put_Template(&self, value: *mut ControlTemplate) -> HRESULT,
    fn get_Padding(&self, out: *mut super::Thickness) -> HRESULT,
    fn put_Padding(&self, value: super::Thickness) -> HRESULT,
    fn get_HorizontalContentAlignment(&self, out: *mut super::HorizontalAlignment) -> HRESULT,
    fn put_HorizontalContentAlignment(&self, value: super::HorizontalAlignment) -> HRESULT,
    fn get_VerticalContentAlignment(&self, out: *mut super::VerticalAlignment) -> HRESULT,
    fn put_VerticalContentAlignment(&self, value: super::VerticalAlignment) -> HRESULT,
    fn get_Background(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_Background(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_BorderThickness(&self, out: *mut super::Thickness) -> HRESULT,
    fn put_BorderThickness(&self, value: super::Thickness) -> HRESULT,
    fn get_BorderBrush(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_BorderBrush(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_FocusState(&self, out: *mut super::FocusState) -> HRESULT,
    fn add_IsEnabledChanged(&self, value: *mut super::DependencyPropertyChangedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_IsEnabledChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn ApplyTemplate(&self, out: *mut bool) -> HRESULT,
    fn Focus(&self, value: super::FocusState, out: *mut bool) -> HRESULT
}}
impl IControl {
    #[inline] pub unsafe fn get_font_size(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_font_size(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontSize)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_family(&self) -> Result<ComPtr<super::media::FontFamily>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontFamily)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_font_family(&self, value: &super::media::FontFamily) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontFamily)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_font_weight(&self) -> Result<super::super::text::FontWeight> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontWeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_font_weight(&self, value: super::super::text::FontWeight) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontWeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_font_style(&self) -> Result<super::super::text::FontStyle> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_font_style(&self, value: super::super::text::FontStyle) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontStyle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_font_stretch(&self) -> Result<super::super::text::FontStretch> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontStretch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_font_stretch(&self, value: super::super::text::FontStretch) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FontStretch)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_character_spacing(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CharacterSpacing)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_character_spacing(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CharacterSpacing)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_foreground(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Foreground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_foreground(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Foreground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_tab_stop(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTabStop)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_tab_stop(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsTabStop)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tab_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TabIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_tab_index(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TabIndex)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tab_navigation(&self) -> Result<super::input::KeyboardNavigationMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TabNavigation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_tab_navigation(&self, value: super::input::KeyboardNavigationMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TabNavigation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_template(&self) -> Result<ComPtr<ControlTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Template)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_template(&self, value: &ControlTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Template)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_padding(&self) -> Result<super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Padding)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_padding(&self, value: super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Padding)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_content_alignment(&self) -> Result<super::HorizontalAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalContentAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_horizontal_content_alignment(&self, value: super::HorizontalAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HorizontalContentAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_content_alignment(&self) -> Result<super::VerticalAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalContentAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_vertical_content_alignment(&self, value: super::VerticalAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_VerticalContentAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_background(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Background)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_background(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Background)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_border_thickness(&self) -> Result<super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BorderThickness)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_border_thickness(&self, value: super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BorderThickness)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_border_brush(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BorderBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_border_brush(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BorderBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_state(&self) -> Result<super::FocusState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FocusState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_is_enabled_changed(&self, value: &super::DependencyPropertyChangedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_IsEnabledChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_is_enabled_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_IsEnabledChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn apply_template(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).ApplyTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn focus(&self, value: super::FocusState) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Focus)(self as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IControlOverrides, 2694222303, 38948, 16894, 181, 48, 176, 216, 153, 14, 100, 193);
RT_INTERFACE!{interface IControlOverrides(IControlOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IControlOverrides] {
    fn OnPointerEntered(&self, e: *mut super::input::PointerRoutedEventArgs) -> HRESULT,
    fn OnPointerPressed(&self, e: *mut super::input::PointerRoutedEventArgs) -> HRESULT,
    fn OnPointerMoved(&self, e: *mut super::input::PointerRoutedEventArgs) -> HRESULT,
    fn OnPointerReleased(&self, e: *mut super::input::PointerRoutedEventArgs) -> HRESULT,
    fn OnPointerExited(&self, e: *mut super::input::PointerRoutedEventArgs) -> HRESULT,
    fn OnPointerCaptureLost(&self, e: *mut super::input::PointerRoutedEventArgs) -> HRESULT,
    fn OnPointerCanceled(&self, e: *mut super::input::PointerRoutedEventArgs) -> HRESULT,
    fn OnPointerWheelChanged(&self, e: *mut super::input::PointerRoutedEventArgs) -> HRESULT,
    fn OnTapped(&self, e: *mut super::input::TappedRoutedEventArgs) -> HRESULT,
    fn OnDoubleTapped(&self, e: *mut super::input::DoubleTappedRoutedEventArgs) -> HRESULT,
    fn OnHolding(&self, e: *mut super::input::HoldingRoutedEventArgs) -> HRESULT,
    fn OnRightTapped(&self, e: *mut super::input::RightTappedRoutedEventArgs) -> HRESULT,
    fn OnManipulationStarting(&self, e: *mut super::input::ManipulationStartingRoutedEventArgs) -> HRESULT,
    fn OnManipulationInertiaStarting(&self, e: *mut super::input::ManipulationInertiaStartingRoutedEventArgs) -> HRESULT,
    fn OnManipulationStarted(&self, e: *mut super::input::ManipulationStartedRoutedEventArgs) -> HRESULT,
    fn OnManipulationDelta(&self, e: *mut super::input::ManipulationDeltaRoutedEventArgs) -> HRESULT,
    fn OnManipulationCompleted(&self, e: *mut super::input::ManipulationCompletedRoutedEventArgs) -> HRESULT,
    fn OnKeyUp(&self, e: *mut super::input::KeyRoutedEventArgs) -> HRESULT,
    fn OnKeyDown(&self, e: *mut super::input::KeyRoutedEventArgs) -> HRESULT,
    fn OnGotFocus(&self, e: *mut super::RoutedEventArgs) -> HRESULT,
    fn OnLostFocus(&self, e: *mut super::RoutedEventArgs) -> HRESULT,
    fn OnDragEnter(&self, e: *mut super::DragEventArgs) -> HRESULT,
    fn OnDragLeave(&self, e: *mut super::DragEventArgs) -> HRESULT,
    fn OnDragOver(&self, e: *mut super::DragEventArgs) -> HRESULT,
    fn OnDrop(&self, e: *mut super::DragEventArgs) -> HRESULT
}}
impl IControlOverrides {
    #[inline] pub unsafe fn on_pointer_entered(&self, e: &super::input::PointerRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnPointerEntered)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_pointer_pressed(&self, e: &super::input::PointerRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnPointerPressed)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_pointer_moved(&self, e: &super::input::PointerRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnPointerMoved)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_pointer_released(&self, e: &super::input::PointerRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnPointerReleased)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_pointer_exited(&self, e: &super::input::PointerRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnPointerExited)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_pointer_capture_lost(&self, e: &super::input::PointerRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnPointerCaptureLost)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_pointer_canceled(&self, e: &super::input::PointerRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnPointerCanceled)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_pointer_wheel_changed(&self, e: &super::input::PointerRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnPointerWheelChanged)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_tapped(&self, e: &super::input::TappedRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnTapped)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_double_tapped(&self, e: &super::input::DoubleTappedRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnDoubleTapped)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_holding(&self, e: &super::input::HoldingRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnHolding)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_right_tapped(&self, e: &super::input::RightTappedRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnRightTapped)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_manipulation_starting(&self, e: &super::input::ManipulationStartingRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnManipulationStarting)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_manipulation_inertia_starting(&self, e: &super::input::ManipulationInertiaStartingRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnManipulationInertiaStarting)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_manipulation_started(&self, e: &super::input::ManipulationStartedRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnManipulationStarted)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_manipulation_delta(&self, e: &super::input::ManipulationDeltaRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnManipulationDelta)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_manipulation_completed(&self, e: &super::input::ManipulationCompletedRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnManipulationCompleted)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_key_up(&self, e: &super::input::KeyRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnKeyUp)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_key_down(&self, e: &super::input::KeyRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnKeyDown)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_got_focus(&self, e: &super::RoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnGotFocus)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_lost_focus(&self, e: &super::RoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnLostFocus)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_drag_enter(&self, e: &super::DragEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnDragEnter)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_drag_leave(&self, e: &super::DragEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnDragLeave)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_drag_over(&self, e: &super::DragEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnDragOver)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_drop(&self, e: &super::DragEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).OnDrop)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IControlProtected, 395401338, 10876, 18817, 162, 216, 171, 153, 255, 252, 101, 185);
RT_INTERFACE!{interface IControlProtected(IControlProtectedVtbl): IInspectable(IInspectableVtbl) [IID_IControlProtected] {
    fn get_DefaultStyleKey(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_DefaultStyleKey(&self, value: *mut IInspectable) -> HRESULT,
    fn GetTemplateChild(&self, childName: HSTRING, out: *mut *mut super::DependencyObject) -> HRESULT
}}
impl IControlProtected {
    #[inline] pub unsafe fn get_default_style_key(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DefaultStyleKey)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_default_style_key(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DefaultStyleKey)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_template_child(&self, childName: &HStringArg) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetTemplateChild)(self as *const _ as *mut _, childName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IControlStatics, 1195061339, 34685, 19509, 143, 202, 70, 160, 95, 150, 96, 122);
RT_INTERFACE!{static interface IControlStatics(IControlStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IControlStatics] {
    fn get_FontSizeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontFamilyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontWeightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontStyleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FontStretchProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CharacterSpacingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ForegroundProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsTabStopProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TabIndexProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TabNavigationProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PaddingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HorizontalContentAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_VerticalContentAlignmentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_BackgroundProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_BorderThicknessProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_BorderBrushProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DefaultStyleKeyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FocusStateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IControlStatics {
    #[inline] pub unsafe fn get_font_size_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontSizeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_family_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontFamilyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_weight_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontWeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_style_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_font_stretch_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontStretchProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_character_spacing_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CharacterSpacingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_foreground_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ForegroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_tab_stop_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsTabStopProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tab_index_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TabIndexProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tab_navigation_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TabNavigationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_padding_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PaddingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_content_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HorizontalContentAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_content_alignment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VerticalContentAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_background_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BackgroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_border_thickness_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BorderThicknessProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_border_brush_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BorderBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_default_style_key_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DefaultStyleKeyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_state_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FocusStateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IControlFactory, 2972392794, 25625, 19990, 178, 18, 164, 83, 54, 183, 87, 120);
RT_INTERFACE!{interface IControlFactory(IControlFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IControlFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut Control) -> HRESULT
}}
impl IControlFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<Control>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IControl2, 1138818576, 5356, 17022, 140, 87, 222, 230, 13, 246, 10, 168);
RT_INTERFACE!{interface IControl2(IControl2Vtbl): IInspectable(IInspectableVtbl) [IID_IControl2] {
    fn get_IsTextScaleFactorEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsTextScaleFactorEnabled(&self, value: bool) -> HRESULT
}}
impl IControl2 {
    #[inline] pub unsafe fn get_is_text_scale_factor_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTextScaleFactorEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_text_scale_factor_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsTextScaleFactorEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IControlStatics2, 841170486, 43892, 18981, 165, 86, 69, 41, 49, 53, 178, 197);
RT_INTERFACE!{static interface IControlStatics2(IControlStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IControlStatics2] {
    fn get_IsTextScaleFactorEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IControlStatics2 {
    #[inline] pub unsafe fn get_is_text_scale_factor_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsTextScaleFactorEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IControl3, 125512164, 56030, 20309, 155, 150, 9, 226, 27, 40, 235, 28);
RT_INTERFACE!{interface IControl3(IControl3Vtbl): IInspectable(IInspectableVtbl) [IID_IControl3] {
    fn get_UseSystemFocusVisuals(&self, out: *mut bool) -> HRESULT,
    fn put_UseSystemFocusVisuals(&self, value: bool) -> HRESULT
}}
impl IControl3 {
    #[inline] pub unsafe fn get_use_system_focus_visuals(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_UseSystemFocusVisuals)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_use_system_focus_visuals(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_UseSystemFocusVisuals)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IControlStatics3, 2865847905, 58553, 19826, 182, 83, 147, 65, 73, 170, 80, 3);
RT_INTERFACE!{static interface IControlStatics3(IControlStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IControlStatics3] {
    fn get_UseSystemFocusVisualsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsTemplateFocusTargetProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetIsTemplateFocusTarget(&self, element: *mut super::FrameworkElement, out: *mut bool) -> HRESULT,
    fn SetIsTemplateFocusTarget(&self, element: *mut super::FrameworkElement, value: bool) -> HRESULT
}}
impl IControlStatics3 {
    #[inline] pub unsafe fn get_use_system_focus_visuals_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UseSystemFocusVisualsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_template_focus_target_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsTemplateFocusTargetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_template_focus_target(&self, element: &super::FrameworkElement) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsTemplateFocusTarget)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_template_focus_target(&self, element: &super::FrameworkElement, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetIsTemplateFocusTarget)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IControl4, 236498670, 24366, 17642, 133, 19, 211, 135, 92, 10, 117, 19);
RT_INTERFACE!{interface IControl4(IControl4Vtbl): IInspectable(IInspectableVtbl) [IID_IControl4] {
    fn get_IsFocusEngagementEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsFocusEngagementEnabled(&self, value: bool) -> HRESULT,
    fn get_IsFocusEngaged(&self, out: *mut bool) -> HRESULT,
    fn put_IsFocusEngaged(&self, value: bool) -> HRESULT,
    fn get_RequiresPointer(&self, out: *mut RequiresPointer) -> HRESULT,
    fn put_RequiresPointer(&self, value: RequiresPointer) -> HRESULT,
    fn get_XYFocusLeft(&self, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn put_XYFocusLeft(&self, value: *mut super::DependencyObject) -> HRESULT,
    fn get_XYFocusRight(&self, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn put_XYFocusRight(&self, value: *mut super::DependencyObject) -> HRESULT,
    fn get_XYFocusUp(&self, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn put_XYFocusUp(&self, value: *mut super::DependencyObject) -> HRESULT,
    fn get_XYFocusDown(&self, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn put_XYFocusDown(&self, value: *mut super::DependencyObject) -> HRESULT,
    fn get_ElementSoundMode(&self, out: *mut super::ElementSoundMode) -> HRESULT,
    fn put_ElementSoundMode(&self, value: super::ElementSoundMode) -> HRESULT,
    fn add_FocusEngaged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<Control, FocusEngagedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FocusEngaged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_FocusDisengaged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<Control, FocusDisengagedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FocusDisengaged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn RemoveFocusEngagement(&self) -> HRESULT
}}
impl IControl4 {
    #[inline] pub unsafe fn get_is_focus_engagement_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsFocusEngagementEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_focus_engagement_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsFocusEngagementEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_focus_engaged(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsFocusEngaged)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_focus_engaged(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsFocusEngaged)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_requires_pointer(&self) -> Result<RequiresPointer> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RequiresPointer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_requires_pointer(&self, value: RequiresPointer) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RequiresPointer)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_left(&self) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusLeft)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_xyfocus_left(&self, value: &super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_XYFocusLeft)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_right(&self) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusRight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_xyfocus_right(&self, value: &super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_XYFocusRight)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_up(&self) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusUp)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_xyfocus_up(&self, value: &super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_XYFocusUp)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_down(&self) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusDown)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_xyfocus_down(&self, value: &super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_XYFocusDown)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_element_sound_mode(&self) -> Result<super::ElementSoundMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ElementSoundMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_element_sound_mode(&self, value: super::ElementSoundMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ElementSoundMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_focus_engaged(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<Control, FocusEngagedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_FocusEngaged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_focus_engaged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_FocusEngaged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_focus_disengaged(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<Control, FocusDisengagedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_FocusDisengaged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_focus_disengaged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_FocusDisengaged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_focus_engagement(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).RemoveFocusEngagement)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IControlStatics4, 1509795624, 49242, 20162, 138, 75, 6, 173, 105, 182, 110, 21);
RT_INTERFACE!{static interface IControlStatics4(IControlStatics4Vtbl): IInspectable(IInspectableVtbl) [IID_IControlStatics4] {
    fn get_IsFocusEngagementEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsFocusEngagedProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_RequiresPointerProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_XYFocusLeftProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_XYFocusRightProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_XYFocusUpProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_XYFocusDownProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ElementSoundModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IControlStatics4 {
    #[inline] pub unsafe fn get_is_focus_engagement_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsFocusEngagementEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_focus_engaged_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsFocusEngagedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_requires_pointer_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RequiresPointerProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_left_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusLeftProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_right_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusRightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_up_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusUpProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_down_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XYFocusDownProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_element_sound_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ElementSoundModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IControl5, 1589334485, 40536, 18871, 188, 45, 1, 85, 255, 17, 134, 100);
RT_INTERFACE!{interface IControl5(IControl5Vtbl): IInspectable(IInspectableVtbl) [IID_IControl5] {
    fn get_DefaultStyleResourceUri(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn put_DefaultStyleResourceUri(&self, value: *mut ::rt::gen::windows::foundation::Uri) -> HRESULT
}}
impl IControl5 {
    #[inline] pub unsafe fn get_default_style_resource_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DefaultStyleResourceUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_default_style_resource_uri(&self, value: &::rt::gen::windows::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DefaultStyleResourceUri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class Control: IControl}
impl RtActivatable<IControlStatics4> for Control {}
impl RtActivatable<IControlStatics5> for Control {}
impl RtActivatable<IControlStatics3> for Control {}
impl RtActivatable<IControlStatics2> for Control {}
impl RtActivatable<IControlStatics> for Control {}
impl Control {
    #[inline] pub fn get_is_focus_engagement_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics4>>::get_activation_factory().get_is_focus_engagement_enabled_property()
    }}
    #[inline] pub fn get_is_focus_engaged_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics4>>::get_activation_factory().get_is_focus_engaged_property()
    }}
    #[inline] pub fn get_requires_pointer_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics4>>::get_activation_factory().get_requires_pointer_property()
    }}
    #[inline] pub fn get_xyfocus_left_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics4>>::get_activation_factory().get_xyfocus_left_property()
    }}
    #[inline] pub fn get_xyfocus_right_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics4>>::get_activation_factory().get_xyfocus_right_property()
    }}
    #[inline] pub fn get_xyfocus_up_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics4>>::get_activation_factory().get_xyfocus_up_property()
    }}
    #[inline] pub fn get_xyfocus_down_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics4>>::get_activation_factory().get_xyfocus_down_property()
    }}
    #[inline] pub fn get_element_sound_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics4>>::get_activation_factory().get_element_sound_mode_property()
    }}
    #[inline] pub fn get_default_style_resource_uri_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics5>>::get_activation_factory().get_default_style_resource_uri_property()
    }}
    #[inline] pub fn get_is_template_key_tip_target_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics5>>::get_activation_factory().get_is_template_key_tip_target_property()
    }}
    #[inline] pub fn get_is_template_key_tip_target(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<IControlStatics5>>::get_activation_factory().get_is_template_key_tip_target(element)
    }}
    #[inline] pub fn set_is_template_key_tip_target(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IControlStatics5>>::get_activation_factory().set_is_template_key_tip_target(element, value)
    }}
    #[inline] pub fn get_use_system_focus_visuals_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics3>>::get_activation_factory().get_use_system_focus_visuals_property()
    }}
    #[inline] pub fn get_is_template_focus_target_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics3>>::get_activation_factory().get_is_template_focus_target_property()
    }}
    #[inline] pub fn get_is_template_focus_target(element: &super::FrameworkElement) -> Result<bool> { unsafe {
        <Self as RtActivatable<IControlStatics3>>::get_activation_factory().get_is_template_focus_target(element)
    }}
    #[inline] pub fn set_is_template_focus_target(element: &super::FrameworkElement, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IControlStatics3>>::get_activation_factory().set_is_template_focus_target(element, value)
    }}
    #[inline] pub fn get_is_text_scale_factor_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics2>>::get_activation_factory().get_is_text_scale_factor_enabled_property()
    }}
    #[inline] pub fn get_font_size_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics>>::get_activation_factory().get_font_size_property()
    }}
    #[inline] pub fn get_font_family_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics>>::get_activation_factory().get_font_family_property()
    }}
    #[inline] pub fn get_font_weight_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics>>::get_activation_factory().get_font_weight_property()
    }}
    #[inline] pub fn get_font_style_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics>>::get_activation_factory().get_font_style_property()
    }}
    #[inline] pub fn get_font_stretch_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics>>::get_activation_factory().get_font_stretch_property()
    }}
    #[inline] pub fn get_character_spacing_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics>>::get_activation_factory().get_character_spacing_property()
    }}
    #[inline] pub fn get_foreground_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics>>::get_activation_factory().get_foreground_property()
    }}
    #[inline] pub fn get_is_tab_stop_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics>>::get_activation_factory().get_is_tab_stop_property()
    }}
    #[inline] pub fn get_is_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics>>::get_activation_factory().get_is_enabled_property()
    }}
    #[inline] pub fn get_tab_index_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics>>::get_activation_factory().get_tab_index_property()
    }}
    #[inline] pub fn get_tab_navigation_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics>>::get_activation_factory().get_tab_navigation_property()
    }}
    #[inline] pub fn get_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics>>::get_activation_factory().get_template_property()
    }}
    #[inline] pub fn get_padding_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics>>::get_activation_factory().get_padding_property()
    }}
    #[inline] pub fn get_horizontal_content_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics>>::get_activation_factory().get_horizontal_content_alignment_property()
    }}
    #[inline] pub fn get_vertical_content_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics>>::get_activation_factory().get_vertical_content_alignment_property()
    }}
    #[inline] pub fn get_background_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics>>::get_activation_factory().get_background_property()
    }}
    #[inline] pub fn get_border_thickness_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics>>::get_activation_factory().get_border_thickness_property()
    }}
    #[inline] pub fn get_border_brush_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics>>::get_activation_factory().get_border_brush_property()
    }}
    #[inline] pub fn get_default_style_key_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics>>::get_activation_factory().get_default_style_key_property()
    }}
    #[inline] pub fn get_focus_state_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IControlStatics>>::get_activation_factory().get_focus_state_property()
    }}
}
DEFINE_CLSID!(Control(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,67,111,110,116,114,111,108,0]) [CLSID_Control]);
RT_CLASS!{class SemanticZoom: ISemanticZoom}
impl RtActivatable<ISemanticZoomStatics> for SemanticZoom {}
impl RtActivatable<IActivationFactory> for SemanticZoom {}
impl SemanticZoom {
    #[inline] pub fn get_zoomed_in_view_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISemanticZoomStatics>>::get_activation_factory().get_zoomed_in_view_property()
    }}
    #[inline] pub fn get_zoomed_out_view_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISemanticZoomStatics>>::get_activation_factory().get_zoomed_out_view_property()
    }}
    #[inline] pub fn get_is_zoomed_in_view_active_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISemanticZoomStatics>>::get_activation_factory().get_is_zoomed_in_view_active_property()
    }}
    #[inline] pub fn get_can_change_views_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISemanticZoomStatics>>::get_activation_factory().get_can_change_views_property()
    }}
    #[inline] pub fn get_is_zoom_out_button_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISemanticZoomStatics>>::get_activation_factory().get_is_zoom_out_button_enabled_property()
    }}
}
DEFINE_CLSID!(SemanticZoom(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,83,101,109,97,110,116,105,99,90,111,111,109,0]) [CLSID_SemanticZoom]);
RT_CLASS!{class ContentControl: IContentControl}
impl RtActivatable<IContentControlStatics> for ContentControl {}
impl ContentControl {
    #[inline] pub fn get_content_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentControlStatics>>::get_activation_factory().get_content_property()
    }}
    #[inline] pub fn get_content_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentControlStatics>>::get_activation_factory().get_content_template_property()
    }}
    #[inline] pub fn get_content_template_selector_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentControlStatics>>::get_activation_factory().get_content_template_selector_property()
    }}
    #[inline] pub fn get_content_transitions_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentControlStatics>>::get_activation_factory().get_content_transitions_property()
    }}
}
DEFINE_CLSID!(ContentControl(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,67,111,110,116,101,110,116,67,111,110,116,114,111,108,0]) [CLSID_ContentControl]);
RT_CLASS!{class ListViewBaseHeaderItem: IListViewBaseHeaderItem}
RT_CLASS!{class ItemsControl: IItemsControl}
impl RtActivatable<IItemsControlStatics> for ItemsControl {}
impl ItemsControl {
    #[inline] pub fn get_items_source_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsControlStatics>>::get_activation_factory().get_items_source_property()
    }}
    #[inline] pub fn get_item_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsControlStatics>>::get_activation_factory().get_item_template_property()
    }}
    #[inline] pub fn get_item_template_selector_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsControlStatics>>::get_activation_factory().get_item_template_selector_property()
    }}
    #[inline] pub fn get_items_panel_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsControlStatics>>::get_activation_factory().get_items_panel_property()
    }}
    #[inline] pub fn get_display_member_path_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsControlStatics>>::get_activation_factory().get_display_member_path_property()
    }}
    #[inline] pub fn get_item_container_style_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsControlStatics>>::get_activation_factory().get_item_container_style_property()
    }}
    #[inline] pub fn get_item_container_style_selector_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsControlStatics>>::get_activation_factory().get_item_container_style_selector_property()
    }}
    #[inline] pub fn get_item_container_transitions_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsControlStatics>>::get_activation_factory().get_item_container_transitions_property()
    }}
    #[inline] pub fn get_group_style_selector_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsControlStatics>>::get_activation_factory().get_group_style_selector_property()
    }}
    #[inline] pub fn get_is_grouping_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IItemsControlStatics>>::get_activation_factory().get_is_grouping_property()
    }}
    #[inline] pub fn get_items_owner(element: &super::DependencyObject) -> Result<ComPtr<ItemsControl>> { unsafe {
        <Self as RtActivatable<IItemsControlStatics>>::get_activation_factory().get_items_owner(element)
    }}
    #[inline] pub fn items_control_from_item_container(container: &super::DependencyObject) -> Result<ComPtr<ItemsControl>> { unsafe {
        <Self as RtActivatable<IItemsControlStatics>>::get_activation_factory().items_control_from_item_container(container)
    }}
}
DEFINE_CLSID!(ItemsControl(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,73,116,101,109,115,67,111,110,116,114,111,108,0]) [CLSID_ItemsControl]);
RT_CLASS!{class MediaTransportControls: IMediaTransportControls}
impl RtActivatable<IMediaTransportControlsStatics> for MediaTransportControls {}
impl RtActivatable<IMediaTransportControlsStatics2> for MediaTransportControls {}
impl MediaTransportControls {
    #[inline] pub fn get_is_full_window_button_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics>>::get_activation_factory().get_is_full_window_button_visible_property()
    }}
    #[inline] pub fn get_is_full_window_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics>>::get_activation_factory().get_is_full_window_enabled_property()
    }}
    #[inline] pub fn get_is_zoom_button_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics>>::get_activation_factory().get_is_zoom_button_visible_property()
    }}
    #[inline] pub fn get_is_zoom_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics>>::get_activation_factory().get_is_zoom_enabled_property()
    }}
    #[inline] pub fn get_is_fast_forward_button_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics>>::get_activation_factory().get_is_fast_forward_button_visible_property()
    }}
    #[inline] pub fn get_is_fast_forward_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics>>::get_activation_factory().get_is_fast_forward_enabled_property()
    }}
    #[inline] pub fn get_is_fast_rewind_button_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics>>::get_activation_factory().get_is_fast_rewind_button_visible_property()
    }}
    #[inline] pub fn get_is_fast_rewind_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics>>::get_activation_factory().get_is_fast_rewind_enabled_property()
    }}
    #[inline] pub fn get_is_stop_button_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics>>::get_activation_factory().get_is_stop_button_visible_property()
    }}
    #[inline] pub fn get_is_stop_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics>>::get_activation_factory().get_is_stop_enabled_property()
    }}
    #[inline] pub fn get_is_volume_button_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics>>::get_activation_factory().get_is_volume_button_visible_property()
    }}
    #[inline] pub fn get_is_volume_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics>>::get_activation_factory().get_is_volume_enabled_property()
    }}
    #[inline] pub fn get_is_playback_rate_button_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics>>::get_activation_factory().get_is_playback_rate_button_visible_property()
    }}
    #[inline] pub fn get_is_playback_rate_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics>>::get_activation_factory().get_is_playback_rate_enabled_property()
    }}
    #[inline] pub fn get_is_seek_bar_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics>>::get_activation_factory().get_is_seek_bar_visible_property()
    }}
    #[inline] pub fn get_is_seek_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics>>::get_activation_factory().get_is_seek_enabled_property()
    }}
    #[inline] pub fn get_is_compact_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics>>::get_activation_factory().get_is_compact_property()
    }}
    #[inline] pub fn get_is_skip_forward_button_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics2>>::get_activation_factory().get_is_skip_forward_button_visible_property()
    }}
    #[inline] pub fn get_is_skip_forward_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics2>>::get_activation_factory().get_is_skip_forward_enabled_property()
    }}
    #[inline] pub fn get_is_skip_backward_button_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics2>>::get_activation_factory().get_is_skip_backward_button_visible_property()
    }}
    #[inline] pub fn get_is_skip_backward_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics2>>::get_activation_factory().get_is_skip_backward_enabled_property()
    }}
    #[inline] pub fn get_is_next_track_button_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics2>>::get_activation_factory().get_is_next_track_button_visible_property()
    }}
    #[inline] pub fn get_is_previous_track_button_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics2>>::get_activation_factory().get_is_previous_track_button_visible_property()
    }}
    #[inline] pub fn get_fast_play_fallback_behaviour_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaTransportControlsStatics2>>::get_activation_factory().get_fast_play_fallback_behaviour_property()
    }}
}
DEFINE_CLSID!(MediaTransportControls(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,101,100,105,97,84,114,97,110,115,112,111,114,116,67,111,110,116,114,111,108,115,0]) [CLSID_MediaTransportControls]);
RT_CLASS!{class PasswordBox: IPasswordBox}
impl RtActivatable<IPasswordBoxStatics> for PasswordBox {}
impl RtActivatable<IPasswordBoxStatics2> for PasswordBox {}
impl RtActivatable<IPasswordBoxStatics3> for PasswordBox {}
impl RtActivatable<IActivationFactory> for PasswordBox {}
impl PasswordBox {
    #[inline] pub fn get_password_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPasswordBoxStatics>>::get_activation_factory().get_password_property()
    }}
    #[inline] pub fn get_password_char_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPasswordBoxStatics>>::get_activation_factory().get_password_char_property()
    }}
    #[inline] pub fn get_is_password_reveal_button_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPasswordBoxStatics>>::get_activation_factory().get_is_password_reveal_button_enabled_property()
    }}
    #[inline] pub fn get_max_length_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPasswordBoxStatics>>::get_activation_factory().get_max_length_property()
    }}
    #[inline] pub fn get_header_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPasswordBoxStatics2>>::get_activation_factory().get_header_property()
    }}
    #[inline] pub fn get_header_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPasswordBoxStatics2>>::get_activation_factory().get_header_template_property()
    }}
    #[inline] pub fn get_placeholder_text_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPasswordBoxStatics2>>::get_activation_factory().get_placeholder_text_property()
    }}
    #[inline] pub fn get_selection_highlight_color_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPasswordBoxStatics2>>::get_activation_factory().get_selection_highlight_color_property()
    }}
    #[inline] pub fn get_prevent_keyboard_display_on_programmatic_focus_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPasswordBoxStatics2>>::get_activation_factory().get_prevent_keyboard_display_on_programmatic_focus_property()
    }}
    #[inline] pub fn get_password_reveal_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPasswordBoxStatics3>>::get_activation_factory().get_password_reveal_mode_property()
    }}
    #[inline] pub fn get_text_reading_order_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPasswordBoxStatics3>>::get_activation_factory().get_text_reading_order_property()
    }}
    #[inline] pub fn get_input_scope_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPasswordBoxStatics3>>::get_activation_factory().get_input_scope_property()
    }}
}
DEFINE_CLSID!(PasswordBox(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,97,115,115,119,111,114,100,66,111,120,0]) [CLSID_PasswordBox]);
RT_CLASS!{class ProgressRing: IProgressRing}
impl RtActivatable<IProgressRingStatics> for ProgressRing {}
impl RtActivatable<IActivationFactory> for ProgressRing {}
impl ProgressRing {
    #[inline] pub fn get_is_active_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IProgressRingStatics>>::get_activation_factory().get_is_active_property()
    }}
}
DEFINE_CLSID!(ProgressRing(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,111,103,114,101,115,115,82,105,110,103,0]) [CLSID_ProgressRing]);
RT_CLASS!{class TextBox: ITextBox}
impl RtActivatable<ITextBoxStatics> for TextBox {}
impl RtActivatable<ITextBoxStatics3> for TextBox {}
impl RtActivatable<ITextBoxStatics5> for TextBox {}
impl RtActivatable<ITextBoxStatics2> for TextBox {}
impl TextBox {
    #[inline] pub fn get_text_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBoxStatics>>::get_activation_factory().get_text_property()
    }}
    #[inline] pub fn get_max_length_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBoxStatics>>::get_activation_factory().get_max_length_property()
    }}
    #[inline] pub fn get_is_read_only_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBoxStatics>>::get_activation_factory().get_is_read_only_property()
    }}
    #[inline] pub fn get_accepts_return_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBoxStatics>>::get_activation_factory().get_accepts_return_property()
    }}
    #[inline] pub fn get_text_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBoxStatics>>::get_activation_factory().get_text_alignment_property()
    }}
    #[inline] pub fn get_text_wrapping_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBoxStatics>>::get_activation_factory().get_text_wrapping_property()
    }}
    #[inline] pub fn get_is_spell_check_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBoxStatics>>::get_activation_factory().get_is_spell_check_enabled_property()
    }}
    #[inline] pub fn get_is_text_prediction_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBoxStatics>>::get_activation_factory().get_is_text_prediction_enabled_property()
    }}
    #[inline] pub fn get_input_scope_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBoxStatics>>::get_activation_factory().get_input_scope_property()
    }}
    #[inline] pub fn get_desired_candidate_window_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBoxStatics3>>::get_activation_factory().get_desired_candidate_window_alignment_property()
    }}
    #[inline] pub fn get_text_reading_order_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBoxStatics3>>::get_activation_factory().get_text_reading_order_property()
    }}
    #[inline] pub fn get_selection_highlight_color_when_not_focused_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBoxStatics5>>::get_activation_factory().get_selection_highlight_color_when_not_focused_property()
    }}
    #[inline] pub fn get_header_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBoxStatics2>>::get_activation_factory().get_header_property()
    }}
    #[inline] pub fn get_header_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBoxStatics2>>::get_activation_factory().get_header_template_property()
    }}
    #[inline] pub fn get_placeholder_text_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBoxStatics2>>::get_activation_factory().get_placeholder_text_property()
    }}
    #[inline] pub fn get_selection_highlight_color_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBoxStatics2>>::get_activation_factory().get_selection_highlight_color_property()
    }}
    #[inline] pub fn get_prevent_keyboard_display_on_programmatic_focus_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBoxStatics2>>::get_activation_factory().get_prevent_keyboard_display_on_programmatic_focus_property()
    }}
    #[inline] pub fn get_is_color_font_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITextBoxStatics2>>::get_activation_factory().get_is_color_font_enabled_property()
    }}
}
DEFINE_CLSID!(TextBox(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,84,101,120,116,66,111,120,0]) [CLSID_TextBox]);
RT_CLASS!{class ToggleSwitch: IToggleSwitch}
impl RtActivatable<IToggleSwitchStatics> for ToggleSwitch {}
impl RtActivatable<IActivationFactory> for ToggleSwitch {}
impl ToggleSwitch {
    #[inline] pub fn get_is_on_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IToggleSwitchStatics>>::get_activation_factory().get_is_on_property()
    }}
    #[inline] pub fn get_header_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IToggleSwitchStatics>>::get_activation_factory().get_header_property()
    }}
    #[inline] pub fn get_header_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IToggleSwitchStatics>>::get_activation_factory().get_header_template_property()
    }}
    #[inline] pub fn get_on_content_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IToggleSwitchStatics>>::get_activation_factory().get_on_content_property()
    }}
    #[inline] pub fn get_on_content_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IToggleSwitchStatics>>::get_activation_factory().get_on_content_template_property()
    }}
    #[inline] pub fn get_off_content_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IToggleSwitchStatics>>::get_activation_factory().get_off_content_property()
    }}
    #[inline] pub fn get_off_content_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IToggleSwitchStatics>>::get_activation_factory().get_off_content_template_property()
    }}
}
DEFINE_CLSID!(ToggleSwitch(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,84,111,103,103,108,101,83,119,105,116,99,104,0]) [CLSID_ToggleSwitch]);
RT_CLASS!{class UserControl: IUserControl}
impl RtActivatable<IUserControlStatics> for UserControl {}
impl UserControl {
    #[inline] pub fn get_content_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IUserControlStatics>>::get_activation_factory().get_content_property()
    }}
}
DEFINE_CLSID!(UserControl(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,85,115,101,114,67,111,110,116,114,111,108,0]) [CLSID_UserControl]);
RT_CLASS!{class GroupItem: IGroupItem}
RT_CLASS!{class SettingsFlyout: ISettingsFlyout}
impl RtActivatable<ISettingsFlyoutStatics> for SettingsFlyout {}
impl SettingsFlyout {
    #[inline] pub fn get_title_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISettingsFlyoutStatics>>::get_activation_factory().get_title_property()
    }}
    #[inline] pub fn get_header_background_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISettingsFlyoutStatics>>::get_activation_factory().get_header_background_property()
    }}
    #[inline] pub fn get_header_foreground_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISettingsFlyoutStatics>>::get_activation_factory().get_header_foreground_property()
    }}
    #[inline] pub fn get_icon_source_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISettingsFlyoutStatics>>::get_activation_factory().get_icon_source_property()
    }}
}
DEFINE_CLSID!(SettingsFlyout(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,83,101,116,116,105,110,103,115,70,108,121,111,117,116,0]) [CLSID_SettingsFlyout]);
RT_CLASS!{class ToolTip: IToolTip}
impl RtActivatable<IToolTipStatics> for ToolTip {}
impl ToolTip {
    #[inline] pub fn get_horizontal_offset_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IToolTipStatics>>::get_activation_factory().get_horizontal_offset_property()
    }}
    #[inline] pub fn get_is_open_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IToolTipStatics>>::get_activation_factory().get_is_open_property()
    }}
    #[inline] pub fn get_placement_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IToolTipStatics>>::get_activation_factory().get_placement_property()
    }}
    #[inline] pub fn get_placement_target_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IToolTipStatics>>::get_activation_factory().get_placement_target_property()
    }}
    #[inline] pub fn get_vertical_offset_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IToolTipStatics>>::get_activation_factory().get_vertical_offset_property()
    }}
}
DEFINE_CLSID!(ToolTip(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,84,111,111,108,84,105,112,0]) [CLSID_ToolTip]);
RT_CLASS!{class ComboBoxItem: IComboBoxItem}
RT_CLASS!{class FlipViewItem: IFlipViewItem}
RT_CLASS!{class ListBoxItem: IListBoxItem}
RT_CLASS!{class ProgressBar: IProgressBar}
impl RtActivatable<IProgressBarStatics> for ProgressBar {}
impl ProgressBar {
    #[inline] pub fn get_is_indeterminate_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IProgressBarStatics>>::get_activation_factory().get_is_indeterminate_property()
    }}
    #[inline] pub fn get_show_error_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IProgressBarStatics>>::get_activation_factory().get_show_error_property()
    }}
    #[inline] pub fn get_show_paused_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IProgressBarStatics>>::get_activation_factory().get_show_paused_property()
    }}
}
DEFINE_CLSID!(ProgressBar(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,111,103,114,101,115,115,66,97,114,0]) [CLSID_ProgressBar]);
RT_CLASS!{class Slider: ISlider}
impl RtActivatable<ISliderStatics> for Slider {}
impl RtActivatable<ISliderStatics2> for Slider {}
impl Slider {
    #[inline] pub fn get_intermediate_value_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISliderStatics>>::get_activation_factory().get_intermediate_value_property()
    }}
    #[inline] pub fn get_step_frequency_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISliderStatics>>::get_activation_factory().get_step_frequency_property()
    }}
    #[inline] pub fn get_snaps_to_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISliderStatics>>::get_activation_factory().get_snaps_to_property()
    }}
    #[inline] pub fn get_tick_frequency_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISliderStatics>>::get_activation_factory().get_tick_frequency_property()
    }}
    #[inline] pub fn get_tick_placement_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISliderStatics>>::get_activation_factory().get_tick_placement_property()
    }}
    #[inline] pub fn get_orientation_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISliderStatics>>::get_activation_factory().get_orientation_property()
    }}
    #[inline] pub fn get_is_direction_reversed_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISliderStatics>>::get_activation_factory().get_is_direction_reversed_property()
    }}
    #[inline] pub fn get_is_thumb_tool_tip_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISliderStatics>>::get_activation_factory().get_is_thumb_tool_tip_enabled_property()
    }}
    #[inline] pub fn get_thumb_tool_tip_value_converter_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISliderStatics>>::get_activation_factory().get_thumb_tool_tip_value_converter_property()
    }}
    #[inline] pub fn get_header_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISliderStatics2>>::get_activation_factory().get_header_property()
    }}
    #[inline] pub fn get_header_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISliderStatics2>>::get_activation_factory().get_header_template_property()
    }}
}
DEFINE_CLSID!(Slider(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,83,108,105,100,101,114,0]) [CLSID_Slider]);
RT_CLASS!{class Button: IButton}
impl RtActivatable<IButtonStaticsWithFlyout> for Button {}
impl Button {
    #[inline] pub fn get_flyout_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IButtonStaticsWithFlyout>>::get_activation_factory().get_flyout_property()
    }}
}
DEFINE_CLSID!(Button(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,66,117,116,116,111,110,0]) [CLSID_Button]);
RT_CLASS!{class HyperlinkButton: IHyperlinkButton}
impl RtActivatable<IHyperlinkButtonStatics> for HyperlinkButton {}
impl HyperlinkButton {
    #[inline] pub fn get_navigate_uri_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHyperlinkButtonStatics>>::get_activation_factory().get_navigate_uri_property()
    }}
}
DEFINE_CLSID!(HyperlinkButton(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,72,121,112,101,114,108,105,110,107,66,117,116,116,111,110,0]) [CLSID_HyperlinkButton]);
RT_CLASS!{class ListViewBase: IListViewBase}
impl RtActivatable<IListViewBaseStatics> for ListViewBase {}
impl RtActivatable<IListViewBaseStatics2> for ListViewBase {}
impl RtActivatable<IListViewBaseStatics5> for ListViewBase {}
impl RtActivatable<IListViewBaseStatics4> for ListViewBase {}
impl RtActivatable<IListViewBaseStatics3> for ListViewBase {}
impl ListViewBase {
    #[inline] pub fn get_selection_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewBaseStatics>>::get_activation_factory().get_selection_mode_property()
    }}
    #[inline] pub fn get_is_swipe_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewBaseStatics>>::get_activation_factory().get_is_swipe_enabled_property()
    }}
    #[inline] pub fn get_can_drag_items_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewBaseStatics>>::get_activation_factory().get_can_drag_items_property()
    }}
    #[inline] pub fn get_can_reorder_items_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewBaseStatics>>::get_activation_factory().get_can_reorder_items_property()
    }}
    #[inline] pub fn get_is_item_click_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewBaseStatics>>::get_activation_factory().get_is_item_click_enabled_property()
    }}
    #[inline] pub fn get_data_fetch_size_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewBaseStatics>>::get_activation_factory().get_data_fetch_size_property()
    }}
    #[inline] pub fn get_incremental_loading_threshold_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewBaseStatics>>::get_activation_factory().get_incremental_loading_threshold_property()
    }}
    #[inline] pub fn get_incremental_loading_trigger_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewBaseStatics>>::get_activation_factory().get_incremental_loading_trigger_property()
    }}
    #[inline] pub fn get_semantic_zoom_owner_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewBaseStatics>>::get_activation_factory().get_semantic_zoom_owner_property()
    }}
    #[inline] pub fn get_is_active_view_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewBaseStatics>>::get_activation_factory().get_is_active_view_property()
    }}
    #[inline] pub fn get_is_zoomed_in_view_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewBaseStatics>>::get_activation_factory().get_is_zoomed_in_view_property()
    }}
    #[inline] pub fn get_header_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewBaseStatics>>::get_activation_factory().get_header_property()
    }}
    #[inline] pub fn get_header_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewBaseStatics>>::get_activation_factory().get_header_template_property()
    }}
    #[inline] pub fn get_header_transitions_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewBaseStatics>>::get_activation_factory().get_header_transitions_property()
    }}
    #[inline] pub fn get_shows_scrolling_placeholders_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewBaseStatics2>>::get_activation_factory().get_shows_scrolling_placeholders_property()
    }}
    #[inline] pub fn get_footer_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewBaseStatics2>>::get_activation_factory().get_footer_property()
    }}
    #[inline] pub fn get_footer_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewBaseStatics2>>::get_activation_factory().get_footer_template_property()
    }}
    #[inline] pub fn get_footer_transitions_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewBaseStatics2>>::get_activation_factory().get_footer_transitions_property()
    }}
    #[inline] pub fn get_single_selection_follows_focus_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewBaseStatics5>>::get_activation_factory().get_single_selection_follows_focus_property()
    }}
    #[inline] pub fn get_is_multi_select_check_box_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewBaseStatics4>>::get_activation_factory().get_is_multi_select_check_box_enabled_property()
    }}
    #[inline] pub fn get_reorder_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewBaseStatics3>>::get_activation_factory().get_reorder_mode_property()
    }}
}
DEFINE_CLSID!(ListViewBase(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,76,105,115,116,86,105,101,119,66,97,115,101,0]) [CLSID_ListViewBase]);
RT_CLASS!{class ComboBox: IComboBox}
impl RtActivatable<IComboBoxStatics> for ComboBox {}
impl RtActivatable<IComboBoxStatics4> for ComboBox {}
impl RtActivatable<IComboBoxStatics3> for ComboBox {}
impl RtActivatable<IComboBoxStatics2> for ComboBox {}
impl ComboBox {
    #[inline] pub fn get_is_drop_down_open_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IComboBoxStatics>>::get_activation_factory().get_is_drop_down_open_property()
    }}
    #[inline] pub fn get_max_drop_down_height_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IComboBoxStatics>>::get_activation_factory().get_max_drop_down_height_property()
    }}
    #[inline] pub fn get_selection_changed_trigger_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IComboBoxStatics4>>::get_activation_factory().get_selection_changed_trigger_property()
    }}
    #[inline] pub fn get_light_dismiss_overlay_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IComboBoxStatics3>>::get_activation_factory().get_light_dismiss_overlay_mode_property()
    }}
    #[inline] pub fn get_is_text_search_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IComboBoxStatics3>>::get_activation_factory().get_is_text_search_enabled_property()
    }}
    #[inline] pub fn get_header_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IComboBoxStatics2>>::get_activation_factory().get_header_property()
    }}
    #[inline] pub fn get_header_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IComboBoxStatics2>>::get_activation_factory().get_header_template_property()
    }}
    #[inline] pub fn get_placeholder_text_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IComboBoxStatics2>>::get_activation_factory().get_placeholder_text_property()
    }}
}
DEFINE_CLSID!(ComboBox(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,67,111,109,98,111,66,111,120,0]) [CLSID_ComboBox]);
RT_CLASS!{class FlipView: IFlipView}
impl RtActivatable<IFlipViewStatics2> for FlipView {}
impl FlipView {
    #[inline] pub fn get_use_touch_animations_for_all_navigation_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFlipViewStatics2>>::get_activation_factory().get_use_touch_animations_for_all_navigation_property()
    }}
}
DEFINE_CLSID!(FlipView(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,70,108,105,112,86,105,101,119,0]) [CLSID_FlipView]);
RT_CLASS!{class ListBox: IListBox}
impl RtActivatable<IListBoxStatics> for ListBox {}
impl RtActivatable<IListBoxStatics2> for ListBox {}
impl ListBox {
    #[inline] pub fn get_selection_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListBoxStatics>>::get_activation_factory().get_selection_mode_property()
    }}
    #[inline] pub fn get_single_selection_follows_focus_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListBoxStatics2>>::get_activation_factory().get_single_selection_follows_focus_property()
    }}
}
DEFINE_CLSID!(ListBox(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,76,105,115,116,66,111,120,0]) [CLSID_ListBox]);
RT_CLASS!{class CheckBox: ICheckBox}
RT_CLASS!{class RadioButton: IRadioButton}
impl RtActivatable<IRadioButtonStatics> for RadioButton {}
impl RadioButton {
    #[inline] pub fn get_group_name_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRadioButtonStatics>>::get_activation_factory().get_group_name_property()
    }}
}
DEFINE_CLSID!(RadioButton(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,82,97,100,105,111,66,117,116,116,111,110,0]) [CLSID_RadioButton]);
RT_CLASS!{class CalendarView: ICalendarView}
impl RtActivatable<ICalendarViewStatics> for CalendarView {}
impl CalendarView {
    #[inline] pub fn get_calendar_identifier_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_calendar_identifier_property()
    }}
    #[inline] pub fn get_day_of_week_format_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_day_of_week_format_property()
    }}
    #[inline] pub fn get_is_group_label_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_is_group_label_visible_property()
    }}
    #[inline] pub fn get_display_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_display_mode_property()
    }}
    #[inline] pub fn get_first_day_of_week_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_first_day_of_week_property()
    }}
    #[inline] pub fn get_is_out_of_scope_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_is_out_of_scope_enabled_property()
    }}
    #[inline] pub fn get_is_today_highlighted_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_is_today_highlighted_property()
    }}
    #[inline] pub fn get_max_date_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_max_date_property()
    }}
    #[inline] pub fn get_min_date_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_min_date_property()
    }}
    #[inline] pub fn get_number_of_weeks_in_view_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_number_of_weeks_in_view_property()
    }}
    #[inline] pub fn get_selected_dates_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_selected_dates_property()
    }}
    #[inline] pub fn get_selection_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_selection_mode_property()
    }}
    #[inline] pub fn get_template_settings_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_template_settings_property()
    }}
    #[inline] pub fn get_focus_border_brush_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_focus_border_brush_property()
    }}
    #[inline] pub fn get_selected_hover_border_brush_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_selected_hover_border_brush_property()
    }}
    #[inline] pub fn get_selected_pressed_border_brush_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_selected_pressed_border_brush_property()
    }}
    #[inline] pub fn get_selected_border_brush_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_selected_border_brush_property()
    }}
    #[inline] pub fn get_hover_border_brush_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_hover_border_brush_property()
    }}
    #[inline] pub fn get_pressed_border_brush_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_pressed_border_brush_property()
    }}
    #[inline] pub fn get_calendar_item_border_brush_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_calendar_item_border_brush_property()
    }}
    #[inline] pub fn get_out_of_scope_background_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_out_of_scope_background_property()
    }}
    #[inline] pub fn get_calendar_item_background_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_calendar_item_background_property()
    }}
    #[inline] pub fn get_pressed_foreground_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_pressed_foreground_property()
    }}
    #[inline] pub fn get_today_foreground_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_today_foreground_property()
    }}
    #[inline] pub fn get_blackout_foreground_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_blackout_foreground_property()
    }}
    #[inline] pub fn get_selected_foreground_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_selected_foreground_property()
    }}
    #[inline] pub fn get_out_of_scope_foreground_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_out_of_scope_foreground_property()
    }}
    #[inline] pub fn get_calendar_item_foreground_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_calendar_item_foreground_property()
    }}
    #[inline] pub fn get_day_item_font_family_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_day_item_font_family_property()
    }}
    #[inline] pub fn get_day_item_font_size_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_day_item_font_size_property()
    }}
    #[inline] pub fn get_day_item_font_style_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_day_item_font_style_property()
    }}
    #[inline] pub fn get_day_item_font_weight_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_day_item_font_weight_property()
    }}
    #[inline] pub fn get_today_font_weight_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_today_font_weight_property()
    }}
    #[inline] pub fn get_first_of_month_label_font_family_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_first_of_month_label_font_family_property()
    }}
    #[inline] pub fn get_first_of_month_label_font_size_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_first_of_month_label_font_size_property()
    }}
    #[inline] pub fn get_first_of_month_label_font_style_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_first_of_month_label_font_style_property()
    }}
    #[inline] pub fn get_first_of_month_label_font_weight_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_first_of_month_label_font_weight_property()
    }}
    #[inline] pub fn get_month_year_item_font_family_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_month_year_item_font_family_property()
    }}
    #[inline] pub fn get_month_year_item_font_size_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_month_year_item_font_size_property()
    }}
    #[inline] pub fn get_month_year_item_font_style_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_month_year_item_font_style_property()
    }}
    #[inline] pub fn get_month_year_item_font_weight_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_month_year_item_font_weight_property()
    }}
    #[inline] pub fn get_first_of_year_decade_label_font_family_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_first_of_year_decade_label_font_family_property()
    }}
    #[inline] pub fn get_first_of_year_decade_label_font_size_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_first_of_year_decade_label_font_size_property()
    }}
    #[inline] pub fn get_first_of_year_decade_label_font_style_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_first_of_year_decade_label_font_style_property()
    }}
    #[inline] pub fn get_first_of_year_decade_label_font_weight_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_first_of_year_decade_label_font_weight_property()
    }}
    #[inline] pub fn get_horizontal_day_item_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_horizontal_day_item_alignment_property()
    }}
    #[inline] pub fn get_vertical_day_item_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_vertical_day_item_alignment_property()
    }}
    #[inline] pub fn get_horizontal_first_of_month_label_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_horizontal_first_of_month_label_alignment_property()
    }}
    #[inline] pub fn get_vertical_first_of_month_label_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_vertical_first_of_month_label_alignment_property()
    }}
    #[inline] pub fn get_calendar_item_border_thickness_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_calendar_item_border_thickness_property()
    }}
    #[inline] pub fn get_calendar_view_day_item_style_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewStatics>>::get_activation_factory().get_calendar_view_day_item_style_property()
    }}
}
DEFINE_CLSID!(CalendarView(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,67,97,108,101,110,100,97,114,86,105,101,119,0]) [CLSID_CalendarView]);
RT_CLASS!{class CalendarViewDayItem: ICalendarViewDayItem}
impl RtActivatable<ICalendarViewDayItemStatics> for CalendarViewDayItem {}
impl CalendarViewDayItem {
    #[inline] pub fn get_is_blackout_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewDayItemStatics>>::get_activation_factory().get_is_blackout_property()
    }}
    #[inline] pub fn get_date_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarViewDayItemStatics>>::get_activation_factory().get_date_property()
    }}
}
DEFINE_CLSID!(CalendarViewDayItem(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,67,97,108,101,110,100,97,114,86,105,101,119,68,97,121,73,116,101,109,0]) [CLSID_CalendarViewDayItem]);
RT_CLASS!{class HubSection: IHubSection}
impl RtActivatable<IHubSectionStatics> for HubSection {}
impl HubSection {
    #[inline] pub fn get_header_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHubSectionStatics>>::get_activation_factory().get_header_property()
    }}
    #[inline] pub fn get_header_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHubSectionStatics>>::get_activation_factory().get_header_template_property()
    }}
    #[inline] pub fn get_content_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHubSectionStatics>>::get_activation_factory().get_content_template_property()
    }}
    #[inline] pub fn get_is_header_interactive_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHubSectionStatics>>::get_activation_factory().get_is_header_interactive_property()
    }}
}
DEFINE_CLSID!(HubSection(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,72,117,98,83,101,99,116,105,111,110,0]) [CLSID_HubSection]);
RT_CLASS!{class MenuFlyoutItemBase: IMenuFlyoutItemBase}
RT_CLASS!{class AppBarSeparator: IAppBarSeparator}
impl RtActivatable<IAppBarSeparatorStatics3> for AppBarSeparator {}
impl RtActivatable<IAppBarSeparatorStatics> for AppBarSeparator {}
impl AppBarSeparator {
    #[inline] pub fn get_is_in_overflow_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAppBarSeparatorStatics3>>::get_activation_factory().get_is_in_overflow_property()
    }}
    #[inline] pub fn get_dynamic_overflow_order_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAppBarSeparatorStatics3>>::get_activation_factory().get_dynamic_overflow_order_property()
    }}
    #[inline] pub fn get_is_compact_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAppBarSeparatorStatics>>::get_activation_factory().get_is_compact_property()
    }}
}
DEFINE_CLSID!(AppBarSeparator(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,65,112,112,66,97,114,83,101,112,97,114,97,116,111,114,0]) [CLSID_AppBarSeparator]);
RT_CLASS!{class CalendarDatePicker: ICalendarDatePicker}
impl RtActivatable<ICalendarDatePickerStatics2> for CalendarDatePicker {}
impl RtActivatable<ICalendarDatePickerStatics> for CalendarDatePicker {}
impl CalendarDatePicker {
    #[inline] pub fn get_light_dismiss_overlay_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarDatePickerStatics2>>::get_activation_factory().get_light_dismiss_overlay_mode_property()
    }}
    #[inline] pub fn get_date_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarDatePickerStatics>>::get_activation_factory().get_date_property()
    }}
    #[inline] pub fn get_is_calendar_open_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarDatePickerStatics>>::get_activation_factory().get_is_calendar_open_property()
    }}
    #[inline] pub fn get_date_format_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarDatePickerStatics>>::get_activation_factory().get_date_format_property()
    }}
    #[inline] pub fn get_placeholder_text_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarDatePickerStatics>>::get_activation_factory().get_placeholder_text_property()
    }}
    #[inline] pub fn get_header_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarDatePickerStatics>>::get_activation_factory().get_header_property()
    }}
    #[inline] pub fn get_header_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarDatePickerStatics>>::get_activation_factory().get_header_template_property()
    }}
    #[inline] pub fn get_calendar_view_style_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarDatePickerStatics>>::get_activation_factory().get_calendar_view_style_property()
    }}
    #[inline] pub fn get_min_date_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarDatePickerStatics>>::get_activation_factory().get_min_date_property()
    }}
    #[inline] pub fn get_max_date_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarDatePickerStatics>>::get_activation_factory().get_max_date_property()
    }}
    #[inline] pub fn get_is_today_highlighted_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarDatePickerStatics>>::get_activation_factory().get_is_today_highlighted_property()
    }}
    #[inline] pub fn get_display_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarDatePickerStatics>>::get_activation_factory().get_display_mode_property()
    }}
    #[inline] pub fn get_first_day_of_week_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarDatePickerStatics>>::get_activation_factory().get_first_day_of_week_property()
    }}
    #[inline] pub fn get_day_of_week_format_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarDatePickerStatics>>::get_activation_factory().get_day_of_week_format_property()
    }}
    #[inline] pub fn get_calendar_identifier_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarDatePickerStatics>>::get_activation_factory().get_calendar_identifier_property()
    }}
    #[inline] pub fn get_is_out_of_scope_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarDatePickerStatics>>::get_activation_factory().get_is_out_of_scope_enabled_property()
    }}
    #[inline] pub fn get_is_group_label_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICalendarDatePickerStatics>>::get_activation_factory().get_is_group_label_visible_property()
    }}
}
DEFINE_CLSID!(CalendarDatePicker(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,67,97,108,101,110,100,97,114,68,97,116,101,80,105,99,107,101,114,0]) [CLSID_CalendarDatePicker]);
RT_CLASS!{class DatePicker: IDatePicker}
impl RtActivatable<IDatePickerStatics> for DatePicker {}
impl RtActivatable<IDatePickerStatics2> for DatePicker {}
impl DatePicker {
    #[inline] pub fn get_header_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerStatics>>::get_activation_factory().get_header_property()
    }}
    #[inline] pub fn get_header_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerStatics>>::get_activation_factory().get_header_template_property()
    }}
    #[inline] pub fn get_calendar_identifier_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerStatics>>::get_activation_factory().get_calendar_identifier_property()
    }}
    #[inline] pub fn get_date_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerStatics>>::get_activation_factory().get_date_property()
    }}
    #[inline] pub fn get_day_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerStatics>>::get_activation_factory().get_day_visible_property()
    }}
    #[inline] pub fn get_month_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerStatics>>::get_activation_factory().get_month_visible_property()
    }}
    #[inline] pub fn get_year_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerStatics>>::get_activation_factory().get_year_visible_property()
    }}
    #[inline] pub fn get_day_format_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerStatics>>::get_activation_factory().get_day_format_property()
    }}
    #[inline] pub fn get_month_format_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerStatics>>::get_activation_factory().get_month_format_property()
    }}
    #[inline] pub fn get_year_format_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerStatics>>::get_activation_factory().get_year_format_property()
    }}
    #[inline] pub fn get_min_year_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerStatics>>::get_activation_factory().get_min_year_property()
    }}
    #[inline] pub fn get_max_year_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerStatics>>::get_activation_factory().get_max_year_property()
    }}
    #[inline] pub fn get_orientation_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerStatics>>::get_activation_factory().get_orientation_property()
    }}
    #[inline] pub fn get_light_dismiss_overlay_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerStatics2>>::get_activation_factory().get_light_dismiss_overlay_mode_property()
    }}
}
DEFINE_CLSID!(DatePicker(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,68,97,116,101,80,105,99,107,101,114,0]) [CLSID_DatePicker]);
RT_CLASS!{class Hub: IHub}
impl RtActivatable<IHubStatics> for Hub {}
impl Hub {
    #[inline] pub fn get_header_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHubStatics>>::get_activation_factory().get_header_property()
    }}
    #[inline] pub fn get_header_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHubStatics>>::get_activation_factory().get_header_template_property()
    }}
    #[inline] pub fn get_orientation_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHubStatics>>::get_activation_factory().get_orientation_property()
    }}
    #[inline] pub fn get_default_section_index_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHubStatics>>::get_activation_factory().get_default_section_index_property()
    }}
    #[inline] pub fn get_semantic_zoom_owner_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHubStatics>>::get_activation_factory().get_semantic_zoom_owner_property()
    }}
    #[inline] pub fn get_is_active_view_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHubStatics>>::get_activation_factory().get_is_active_view_property()
    }}
    #[inline] pub fn get_is_zoomed_in_view_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IHubStatics>>::get_activation_factory().get_is_zoomed_in_view_property()
    }}
}
DEFINE_CLSID!(Hub(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,72,117,98,0]) [CLSID_Hub]);
RT_CLASS!{class MediaPlayerElement: IMediaPlayerElement}
impl RtActivatable<IMediaPlayerElementStatics> for MediaPlayerElement {}
impl MediaPlayerElement {
    #[inline] pub fn get_source_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaPlayerElementStatics>>::get_activation_factory().get_source_property()
    }}
    #[inline] pub fn get_are_transport_controls_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaPlayerElementStatics>>::get_activation_factory().get_are_transport_controls_enabled_property()
    }}
    #[inline] pub fn get_poster_source_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaPlayerElementStatics>>::get_activation_factory().get_poster_source_property()
    }}
    #[inline] pub fn get_stretch_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaPlayerElementStatics>>::get_activation_factory().get_stretch_property()
    }}
    #[inline] pub fn get_auto_play_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaPlayerElementStatics>>::get_activation_factory().get_auto_play_property()
    }}
    #[inline] pub fn get_is_full_window_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaPlayerElementStatics>>::get_activation_factory().get_is_full_window_property()
    }}
    #[inline] pub fn get_media_player_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMediaPlayerElementStatics>>::get_activation_factory().get_media_player_property()
    }}
}
DEFINE_CLSID!(MediaPlayerElement(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,101,100,105,97,80,108,97,121,101,114,69,108,101,109,101,110,116,0]) [CLSID_MediaPlayerElement]);
RT_CLASS!{class RichEditBox: IRichEditBox}
impl RtActivatable<IRichEditBoxStatics> for RichEditBox {}
impl RtActivatable<IRichEditBoxStatics3> for RichEditBox {}
impl RtActivatable<IRichEditBoxStatics4> for RichEditBox {}
impl RtActivatable<IRichEditBoxStatics2> for RichEditBox {}
impl RtActivatable<IRichEditBoxStatics5> for RichEditBox {}
impl RichEditBox {
    #[inline] pub fn get_is_read_only_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichEditBoxStatics>>::get_activation_factory().get_is_read_only_property()
    }}
    #[inline] pub fn get_accepts_return_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichEditBoxStatics>>::get_activation_factory().get_accepts_return_property()
    }}
    #[inline] pub fn get_text_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichEditBoxStatics>>::get_activation_factory().get_text_alignment_property()
    }}
    #[inline] pub fn get_text_wrapping_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichEditBoxStatics>>::get_activation_factory().get_text_wrapping_property()
    }}
    #[inline] pub fn get_is_spell_check_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichEditBoxStatics>>::get_activation_factory().get_is_spell_check_enabled_property()
    }}
    #[inline] pub fn get_is_text_prediction_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichEditBoxStatics>>::get_activation_factory().get_is_text_prediction_enabled_property()
    }}
    #[inline] pub fn get_input_scope_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichEditBoxStatics>>::get_activation_factory().get_input_scope_property()
    }}
    #[inline] pub fn get_desired_candidate_window_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichEditBoxStatics3>>::get_activation_factory().get_desired_candidate_window_alignment_property()
    }}
    #[inline] pub fn get_text_reading_order_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichEditBoxStatics3>>::get_activation_factory().get_text_reading_order_property()
    }}
    #[inline] pub fn get_clipboard_copy_format_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichEditBoxStatics4>>::get_activation_factory().get_clipboard_copy_format_property()
    }}
    #[inline] pub fn get_header_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichEditBoxStatics2>>::get_activation_factory().get_header_property()
    }}
    #[inline] pub fn get_header_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichEditBoxStatics2>>::get_activation_factory().get_header_template_property()
    }}
    #[inline] pub fn get_placeholder_text_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichEditBoxStatics2>>::get_activation_factory().get_placeholder_text_property()
    }}
    #[inline] pub fn get_selection_highlight_color_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichEditBoxStatics2>>::get_activation_factory().get_selection_highlight_color_property()
    }}
    #[inline] pub fn get_prevent_keyboard_display_on_programmatic_focus_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichEditBoxStatics2>>::get_activation_factory().get_prevent_keyboard_display_on_programmatic_focus_property()
    }}
    #[inline] pub fn get_is_color_font_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichEditBoxStatics2>>::get_activation_factory().get_is_color_font_enabled_property()
    }}
    #[inline] pub fn get_selection_highlight_color_when_not_focused_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichEditBoxStatics5>>::get_activation_factory().get_selection_highlight_color_when_not_focused_property()
    }}
    #[inline] pub fn get_max_length_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRichEditBoxStatics5>>::get_activation_factory().get_max_length_property()
    }}
}
DEFINE_CLSID!(RichEditBox(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,82,105,99,104,69,100,105,116,66,111,120,0]) [CLSID_RichEditBox]);
RT_CLASS!{class SearchBox: ISearchBox}
impl RtActivatable<ISearchBoxStatics> for SearchBox {}
impl SearchBox {
    #[inline] pub fn get_search_history_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISearchBoxStatics>>::get_activation_factory().get_search_history_enabled_property()
    }}
    #[inline] pub fn get_search_history_context_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISearchBoxStatics>>::get_activation_factory().get_search_history_context_property()
    }}
    #[inline] pub fn get_placeholder_text_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISearchBoxStatics>>::get_activation_factory().get_placeholder_text_property()
    }}
    #[inline] pub fn get_query_text_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISearchBoxStatics>>::get_activation_factory().get_query_text_property()
    }}
    #[inline] pub fn get_focus_on_keyboard_input_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISearchBoxStatics>>::get_activation_factory().get_focus_on_keyboard_input_property()
    }}
    #[inline] pub fn get_choose_suggestion_on_enter_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISearchBoxStatics>>::get_activation_factory().get_choose_suggestion_on_enter_property()
    }}
}
DEFINE_CLSID!(SearchBox(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,83,101,97,114,99,104,66,111,120,0]) [CLSID_SearchBox]);
RT_CLASS!{class SplitView: ISplitView}
impl RtActivatable<ISplitViewStatics> for SplitView {}
impl RtActivatable<ISplitViewStatics2> for SplitView {}
impl SplitView {
    #[inline] pub fn get_content_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitViewStatics>>::get_activation_factory().get_content_property()
    }}
    #[inline] pub fn get_pane_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitViewStatics>>::get_activation_factory().get_pane_property()
    }}
    #[inline] pub fn get_is_pane_open_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitViewStatics>>::get_activation_factory().get_is_pane_open_property()
    }}
    #[inline] pub fn get_open_pane_length_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitViewStatics>>::get_activation_factory().get_open_pane_length_property()
    }}
    #[inline] pub fn get_compact_pane_length_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitViewStatics>>::get_activation_factory().get_compact_pane_length_property()
    }}
    #[inline] pub fn get_pane_placement_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitViewStatics>>::get_activation_factory().get_pane_placement_property()
    }}
    #[inline] pub fn get_display_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitViewStatics>>::get_activation_factory().get_display_mode_property()
    }}
    #[inline] pub fn get_template_settings_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitViewStatics>>::get_activation_factory().get_template_settings_property()
    }}
    #[inline] pub fn get_pane_background_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitViewStatics>>::get_activation_factory().get_pane_background_property()
    }}
    #[inline] pub fn get_light_dismiss_overlay_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitViewStatics2>>::get_activation_factory().get_light_dismiss_overlay_mode_property()
    }}
}
DEFINE_CLSID!(SplitView(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,83,112,108,105,116,86,105,101,119,0]) [CLSID_SplitView]);
RT_CLASS!{class TimePicker: ITimePicker}
impl RtActivatable<ITimePickerStatics> for TimePicker {}
impl RtActivatable<ITimePickerStatics2> for TimePicker {}
impl TimePicker {
    #[inline] pub fn get_header_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITimePickerStatics>>::get_activation_factory().get_header_property()
    }}
    #[inline] pub fn get_header_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITimePickerStatics>>::get_activation_factory().get_header_template_property()
    }}
    #[inline] pub fn get_clock_identifier_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITimePickerStatics>>::get_activation_factory().get_clock_identifier_property()
    }}
    #[inline] pub fn get_minute_increment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITimePickerStatics>>::get_activation_factory().get_minute_increment_property()
    }}
    #[inline] pub fn get_time_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITimePickerStatics>>::get_activation_factory().get_time_property()
    }}
    #[inline] pub fn get_light_dismiss_overlay_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITimePickerStatics2>>::get_activation_factory().get_light_dismiss_overlay_mode_property()
    }}
}
DEFINE_CLSID!(TimePicker(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,84,105,109,101,80,105,99,107,101,114,0]) [CLSID_TimePicker]);
RT_CLASS!{class AppBar: IAppBar}
impl RtActivatable<IAppBarStatics2> for AppBar {}
impl RtActivatable<IAppBarStatics> for AppBar {}
impl RtActivatable<IAppBarStatics4> for AppBar {}
impl AppBar {
    #[inline] pub fn get_closed_display_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAppBarStatics2>>::get_activation_factory().get_closed_display_mode_property()
    }}
    #[inline] pub fn get_is_open_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAppBarStatics>>::get_activation_factory().get_is_open_property()
    }}
    #[inline] pub fn get_is_sticky_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAppBarStatics>>::get_activation_factory().get_is_sticky_property()
    }}
    #[inline] pub fn get_light_dismiss_overlay_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAppBarStatics4>>::get_activation_factory().get_light_dismiss_overlay_mode_property()
    }}
}
DEFINE_CLSID!(AppBar(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,65,112,112,66,97,114,0]) [CLSID_AppBar]);
RT_CLASS!{class AutoSuggestBox: IAutoSuggestBox}
impl RtActivatable<IAutoSuggestBoxStatics3> for AutoSuggestBox {}
impl RtActivatable<IAutoSuggestBoxStatics2> for AutoSuggestBox {}
impl RtActivatable<IAutoSuggestBoxStatics> for AutoSuggestBox {}
impl RtActivatable<IActivationFactory> for AutoSuggestBox {}
impl AutoSuggestBox {
    #[inline] pub fn get_light_dismiss_overlay_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutoSuggestBoxStatics3>>::get_activation_factory().get_light_dismiss_overlay_mode_property()
    }}
    #[inline] pub fn get_query_icon_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutoSuggestBoxStatics2>>::get_activation_factory().get_query_icon_property()
    }}
    #[inline] pub fn get_max_suggestion_list_height_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutoSuggestBoxStatics>>::get_activation_factory().get_max_suggestion_list_height_property()
    }}
    #[inline] pub fn get_is_suggestion_list_open_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutoSuggestBoxStatics>>::get_activation_factory().get_is_suggestion_list_open_property()
    }}
    #[inline] pub fn get_text_member_path_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutoSuggestBoxStatics>>::get_activation_factory().get_text_member_path_property()
    }}
    #[inline] pub fn get_text_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutoSuggestBoxStatics>>::get_activation_factory().get_text_property()
    }}
    #[inline] pub fn get_update_text_on_select_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutoSuggestBoxStatics>>::get_activation_factory().get_update_text_on_select_property()
    }}
    #[inline] pub fn get_placeholder_text_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutoSuggestBoxStatics>>::get_activation_factory().get_placeholder_text_property()
    }}
    #[inline] pub fn get_header_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutoSuggestBoxStatics>>::get_activation_factory().get_header_property()
    }}
    #[inline] pub fn get_auto_maximize_suggestion_area_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutoSuggestBoxStatics>>::get_activation_factory().get_auto_maximize_suggestion_area_property()
    }}
    #[inline] pub fn get_text_box_style_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutoSuggestBoxStatics>>::get_activation_factory().get_text_box_style_property()
    }}
}
DEFINE_CLSID!(AutoSuggestBox(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,65,117,116,111,83,117,103,103,101,115,116,66,111,120,0]) [CLSID_AutoSuggestBox]);
RT_CLASS!{class CommandBarOverflowPresenter: ICommandBarOverflowPresenter}
RT_CLASS!{class ContentDialog: IContentDialog}
impl RtActivatable<IContentDialogStatics> for ContentDialog {}
impl RtActivatable<IContentDialogStatics2> for ContentDialog {}
impl ContentDialog {
    #[inline] pub fn get_title_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentDialogStatics>>::get_activation_factory().get_title_property()
    }}
    #[inline] pub fn get_title_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentDialogStatics>>::get_activation_factory().get_title_template_property()
    }}
    #[inline] pub fn get_full_size_desired_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentDialogStatics>>::get_activation_factory().get_full_size_desired_property()
    }}
    #[inline] pub fn get_primary_button_text_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentDialogStatics>>::get_activation_factory().get_primary_button_text_property()
    }}
    #[inline] pub fn get_secondary_button_text_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentDialogStatics>>::get_activation_factory().get_secondary_button_text_property()
    }}
    #[inline] pub fn get_primary_button_command_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentDialogStatics>>::get_activation_factory().get_primary_button_command_property()
    }}
    #[inline] pub fn get_secondary_button_command_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentDialogStatics>>::get_activation_factory().get_secondary_button_command_property()
    }}
    #[inline] pub fn get_primary_button_command_parameter_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentDialogStatics>>::get_activation_factory().get_primary_button_command_parameter_property()
    }}
    #[inline] pub fn get_secondary_button_command_parameter_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentDialogStatics>>::get_activation_factory().get_secondary_button_command_parameter_property()
    }}
    #[inline] pub fn get_is_primary_button_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentDialogStatics>>::get_activation_factory().get_is_primary_button_enabled_property()
    }}
    #[inline] pub fn get_is_secondary_button_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentDialogStatics>>::get_activation_factory().get_is_secondary_button_enabled_property()
    }}
    #[inline] pub fn get_close_button_text_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentDialogStatics2>>::get_activation_factory().get_close_button_text_property()
    }}
    #[inline] pub fn get_close_button_command_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentDialogStatics2>>::get_activation_factory().get_close_button_command_property()
    }}
    #[inline] pub fn get_close_button_command_parameter_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentDialogStatics2>>::get_activation_factory().get_close_button_command_parameter_property()
    }}
    #[inline] pub fn get_primary_button_style_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentDialogStatics2>>::get_activation_factory().get_primary_button_style_property()
    }}
    #[inline] pub fn get_secondary_button_style_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentDialogStatics2>>::get_activation_factory().get_secondary_button_style_property()
    }}
    #[inline] pub fn get_close_button_style_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentDialogStatics2>>::get_activation_factory().get_close_button_style_property()
    }}
    #[inline] pub fn get_default_button_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentDialogStatics2>>::get_activation_factory().get_default_button_property()
    }}
}
DEFINE_CLSID!(ContentDialog(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,67,111,110,116,101,110,116,68,105,97,108,111,103,0]) [CLSID_ContentDialog]);
RT_CLASS!{class FlyoutPresenter: IFlyoutPresenter}
RT_CLASS!{class Frame: IFrame}
impl RtActivatable<IFrameStatics> for Frame {}
impl RtActivatable<IFrameStatics2> for Frame {}
impl Frame {
    #[inline] pub fn get_cache_size_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameStatics>>::get_activation_factory().get_cache_size_property()
    }}
    #[inline] pub fn get_can_go_back_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameStatics>>::get_activation_factory().get_can_go_back_property()
    }}
    #[inline] pub fn get_can_go_forward_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameStatics>>::get_activation_factory().get_can_go_forward_property()
    }}
    #[inline] pub fn get_current_source_page_type_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameStatics>>::get_activation_factory().get_current_source_page_type_property()
    }}
    #[inline] pub fn get_source_page_type_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameStatics>>::get_activation_factory().get_source_page_type_property()
    }}
    #[inline] pub fn get_back_stack_depth_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameStatics>>::get_activation_factory().get_back_stack_depth_property()
    }}
    #[inline] pub fn get_back_stack_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameStatics2>>::get_activation_factory().get_back_stack_property()
    }}
    #[inline] pub fn get_forward_stack_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFrameStatics2>>::get_activation_factory().get_forward_stack_property()
    }}
}
DEFINE_CLSID!(Frame(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,70,114,97,109,101,0]) [CLSID_Frame]);
RT_CLASS!{class MenuFlyoutItem: IMenuFlyoutItem}
impl RtActivatable<IMenuFlyoutItemStatics2> for MenuFlyoutItem {}
impl RtActivatable<IMenuFlyoutItemStatics> for MenuFlyoutItem {}
impl MenuFlyoutItem {
    #[inline] pub fn get_icon_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMenuFlyoutItemStatics2>>::get_activation_factory().get_icon_property()
    }}
    #[inline] pub fn get_text_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMenuFlyoutItemStatics>>::get_activation_factory().get_text_property()
    }}
    #[inline] pub fn get_command_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMenuFlyoutItemStatics>>::get_activation_factory().get_command_property()
    }}
    #[inline] pub fn get_command_parameter_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMenuFlyoutItemStatics>>::get_activation_factory().get_command_parameter_property()
    }}
}
DEFINE_CLSID!(MenuFlyoutItem(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,101,110,117,70,108,121,111,117,116,73,116,101,109,0]) [CLSID_MenuFlyoutItem]);
RT_CLASS!{class MenuFlyoutPresenter: IMenuFlyoutPresenter}
RT_CLASS!{class MenuFlyoutSeparator: IMenuFlyoutSeparator}
RT_CLASS!{class MenuFlyoutSubItem: IMenuFlyoutSubItem}
impl RtActivatable<IMenuFlyoutSubItemStatics> for MenuFlyoutSubItem {}
impl RtActivatable<IMenuFlyoutSubItemStatics2> for MenuFlyoutSubItem {}
impl RtActivatable<IActivationFactory> for MenuFlyoutSubItem {}
impl MenuFlyoutSubItem {
    #[inline] pub fn get_text_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMenuFlyoutSubItemStatics>>::get_activation_factory().get_text_property()
    }}
    #[inline] pub fn get_icon_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMenuFlyoutSubItemStatics2>>::get_activation_factory().get_icon_property()
    }}
}
DEFINE_CLSID!(MenuFlyoutSubItem(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,101,110,117,70,108,121,111,117,116,83,117,98,73,116,101,109,0]) [CLSID_MenuFlyoutSubItem]);
RT_CLASS!{class Page: IPage}
impl RtActivatable<IPageStatics> for Page {}
impl Page {
    #[inline] pub fn get_frame_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPageStatics>>::get_activation_factory().get_frame_property()
    }}
    #[inline] pub fn get_top_app_bar_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPageStatics>>::get_activation_factory().get_top_app_bar_property()
    }}
    #[inline] pub fn get_bottom_app_bar_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPageStatics>>::get_activation_factory().get_bottom_app_bar_property()
    }}
}
DEFINE_CLSID!(Page(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,97,103,101,0]) [CLSID_Page]);
RT_CLASS!{class ScrollViewer: IScrollViewer}
impl RtActivatable<IScrollViewerStatics> for ScrollViewer {}
impl RtActivatable<IScrollViewerStatics2> for ScrollViewer {}
impl RtActivatable<IActivationFactory> for ScrollViewer {}
impl ScrollViewer {
    #[inline] pub fn get_horizontal_snap_points_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_horizontal_snap_points_alignment_property()
    }}
    #[inline] pub fn get_vertical_snap_points_alignment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_vertical_snap_points_alignment_property()
    }}
    #[inline] pub fn get_horizontal_snap_points_type_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_horizontal_snap_points_type_property()
    }}
    #[inline] pub fn get_vertical_snap_points_type_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_vertical_snap_points_type_property()
    }}
    #[inline] pub fn get_zoom_snap_points_type_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_zoom_snap_points_type_property()
    }}
    #[inline] pub fn get_horizontal_offset_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_horizontal_offset_property()
    }}
    #[inline] pub fn get_viewport_width_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_viewport_width_property()
    }}
    #[inline] pub fn get_scrollable_width_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_scrollable_width_property()
    }}
    #[inline] pub fn get_computed_horizontal_scroll_bar_visibility_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_computed_horizontal_scroll_bar_visibility_property()
    }}
    #[inline] pub fn get_extent_width_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_extent_width_property()
    }}
    #[inline] pub fn get_vertical_offset_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_vertical_offset_property()
    }}
    #[inline] pub fn get_viewport_height_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_viewport_height_property()
    }}
    #[inline] pub fn get_scrollable_height_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_scrollable_height_property()
    }}
    #[inline] pub fn get_computed_vertical_scroll_bar_visibility_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_computed_vertical_scroll_bar_visibility_property()
    }}
    #[inline] pub fn get_extent_height_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_extent_height_property()
    }}
    #[inline] pub fn get_min_zoom_factor_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_min_zoom_factor_property()
    }}
    #[inline] pub fn get_max_zoom_factor_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_max_zoom_factor_property()
    }}
    #[inline] pub fn get_zoom_factor_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_zoom_factor_property()
    }}
    #[inline] pub fn get_zoom_snap_points_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_zoom_snap_points_property()
    }}
    #[inline] pub fn get_horizontal_scroll_bar_visibility_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_horizontal_scroll_bar_visibility_property()
    }}
    #[inline] pub fn get_horizontal_scroll_bar_visibility(element: &super::DependencyObject) -> Result<ScrollBarVisibility> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_horizontal_scroll_bar_visibility(element)
    }}
    #[inline] pub fn set_horizontal_scroll_bar_visibility(element: &super::DependencyObject, horizontalScrollBarVisibility: ScrollBarVisibility) -> Result<()> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().set_horizontal_scroll_bar_visibility(element, horizontalScrollBarVisibility)
    }}
    #[inline] pub fn get_vertical_scroll_bar_visibility_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_vertical_scroll_bar_visibility_property()
    }}
    #[inline] pub fn get_vertical_scroll_bar_visibility(element: &super::DependencyObject) -> Result<ScrollBarVisibility> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_vertical_scroll_bar_visibility(element)
    }}
    #[inline] pub fn set_vertical_scroll_bar_visibility(element: &super::DependencyObject, verticalScrollBarVisibility: ScrollBarVisibility) -> Result<()> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().set_vertical_scroll_bar_visibility(element, verticalScrollBarVisibility)
    }}
    #[inline] pub fn get_is_horizontal_rail_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_is_horizontal_rail_enabled_property()
    }}
    #[inline] pub fn get_is_horizontal_rail_enabled(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_is_horizontal_rail_enabled(element)
    }}
    #[inline] pub fn set_is_horizontal_rail_enabled(element: &super::DependencyObject, isHorizontalRailEnabled: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().set_is_horizontal_rail_enabled(element, isHorizontalRailEnabled)
    }}
    #[inline] pub fn get_is_vertical_rail_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_is_vertical_rail_enabled_property()
    }}
    #[inline] pub fn get_is_vertical_rail_enabled(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_is_vertical_rail_enabled(element)
    }}
    #[inline] pub fn set_is_vertical_rail_enabled(element: &super::DependencyObject, isVerticalRailEnabled: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().set_is_vertical_rail_enabled(element, isVerticalRailEnabled)
    }}
    #[inline] pub fn get_is_horizontal_scroll_chaining_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_is_horizontal_scroll_chaining_enabled_property()
    }}
    #[inline] pub fn get_is_horizontal_scroll_chaining_enabled(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_is_horizontal_scroll_chaining_enabled(element)
    }}
    #[inline] pub fn set_is_horizontal_scroll_chaining_enabled(element: &super::DependencyObject, isHorizontalScrollChainingEnabled: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().set_is_horizontal_scroll_chaining_enabled(element, isHorizontalScrollChainingEnabled)
    }}
    #[inline] pub fn get_is_vertical_scroll_chaining_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_is_vertical_scroll_chaining_enabled_property()
    }}
    #[inline] pub fn get_is_vertical_scroll_chaining_enabled(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_is_vertical_scroll_chaining_enabled(element)
    }}
    #[inline] pub fn set_is_vertical_scroll_chaining_enabled(element: &super::DependencyObject, isVerticalScrollChainingEnabled: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().set_is_vertical_scroll_chaining_enabled(element, isVerticalScrollChainingEnabled)
    }}
    #[inline] pub fn get_is_zoom_chaining_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_is_zoom_chaining_enabled_property()
    }}
    #[inline] pub fn get_is_zoom_chaining_enabled(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_is_zoom_chaining_enabled(element)
    }}
    #[inline] pub fn set_is_zoom_chaining_enabled(element: &super::DependencyObject, isZoomChainingEnabled: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().set_is_zoom_chaining_enabled(element, isZoomChainingEnabled)
    }}
    #[inline] pub fn get_is_scroll_inertia_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_is_scroll_inertia_enabled_property()
    }}
    #[inline] pub fn get_is_scroll_inertia_enabled(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_is_scroll_inertia_enabled(element)
    }}
    #[inline] pub fn set_is_scroll_inertia_enabled(element: &super::DependencyObject, isScrollInertiaEnabled: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().set_is_scroll_inertia_enabled(element, isScrollInertiaEnabled)
    }}
    #[inline] pub fn get_is_zoom_inertia_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_is_zoom_inertia_enabled_property()
    }}
    #[inline] pub fn get_is_zoom_inertia_enabled(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_is_zoom_inertia_enabled(element)
    }}
    #[inline] pub fn set_is_zoom_inertia_enabled(element: &super::DependencyObject, isZoomInertiaEnabled: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().set_is_zoom_inertia_enabled(element, isZoomInertiaEnabled)
    }}
    #[inline] pub fn get_horizontal_scroll_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_horizontal_scroll_mode_property()
    }}
    #[inline] pub fn get_horizontal_scroll_mode(element: &super::DependencyObject) -> Result<ScrollMode> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_horizontal_scroll_mode(element)
    }}
    #[inline] pub fn set_horizontal_scroll_mode(element: &super::DependencyObject, horizontalScrollMode: ScrollMode) -> Result<()> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().set_horizontal_scroll_mode(element, horizontalScrollMode)
    }}
    #[inline] pub fn get_vertical_scroll_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_vertical_scroll_mode_property()
    }}
    #[inline] pub fn get_vertical_scroll_mode(element: &super::DependencyObject) -> Result<ScrollMode> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_vertical_scroll_mode(element)
    }}
    #[inline] pub fn set_vertical_scroll_mode(element: &super::DependencyObject, verticalScrollMode: ScrollMode) -> Result<()> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().set_vertical_scroll_mode(element, verticalScrollMode)
    }}
    #[inline] pub fn get_zoom_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_zoom_mode_property()
    }}
    #[inline] pub fn get_zoom_mode(element: &super::DependencyObject) -> Result<ZoomMode> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_zoom_mode(element)
    }}
    #[inline] pub fn set_zoom_mode(element: &super::DependencyObject, zoomMode: ZoomMode) -> Result<()> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().set_zoom_mode(element, zoomMode)
    }}
    #[inline] pub fn get_is_deferred_scrolling_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_is_deferred_scrolling_enabled_property()
    }}
    #[inline] pub fn get_is_deferred_scrolling_enabled(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_is_deferred_scrolling_enabled(element)
    }}
    #[inline] pub fn set_is_deferred_scrolling_enabled(element: &super::DependencyObject, isDeferredScrollingEnabled: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().set_is_deferred_scrolling_enabled(element, isDeferredScrollingEnabled)
    }}
    #[inline] pub fn get_bring_into_view_on_focus_change_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_bring_into_view_on_focus_change_property()
    }}
    #[inline] pub fn get_bring_into_view_on_focus_change(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().get_bring_into_view_on_focus_change(element)
    }}
    #[inline] pub fn set_bring_into_view_on_focus_change(element: &super::DependencyObject, bringIntoViewOnFocusChange: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics>>::get_activation_factory().set_bring_into_view_on_focus_change(element, bringIntoViewOnFocusChange)
    }}
    #[inline] pub fn get_top_left_header_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics2>>::get_activation_factory().get_top_left_header_property()
    }}
    #[inline] pub fn get_left_header_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics2>>::get_activation_factory().get_left_header_property()
    }}
    #[inline] pub fn get_top_header_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollViewerStatics2>>::get_activation_factory().get_top_header_property()
    }}
}
DEFINE_CLSID!(ScrollViewer(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,83,99,114,111,108,108,86,105,101,119,101,114,0]) [CLSID_ScrollViewer]);
RT_CLASS!{class CommandBar: ICommandBar}
impl RtActivatable<ICommandBarStatics2> for CommandBar {}
impl RtActivatable<ICommandBarStatics> for CommandBar {}
impl RtActivatable<ICommandBarStatics3> for CommandBar {}
impl CommandBar {
    #[inline] pub fn get_command_bar_overflow_presenter_style_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICommandBarStatics2>>::get_activation_factory().get_command_bar_overflow_presenter_style_property()
    }}
    #[inline] pub fn get_primary_commands_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICommandBarStatics>>::get_activation_factory().get_primary_commands_property()
    }}
    #[inline] pub fn get_secondary_commands_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICommandBarStatics>>::get_activation_factory().get_secondary_commands_property()
    }}
    #[inline] pub fn get_default_label_position_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICommandBarStatics3>>::get_activation_factory().get_default_label_position_property()
    }}
    #[inline] pub fn get_overflow_button_visibility_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICommandBarStatics3>>::get_activation_factory().get_overflow_button_visibility_property()
    }}
    #[inline] pub fn get_is_dynamic_overflow_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICommandBarStatics3>>::get_activation_factory().get_is_dynamic_overflow_enabled_property()
    }}
}
DEFINE_CLSID!(CommandBar(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,67,111,109,109,97,110,100,66,97,114,0]) [CLSID_CommandBar]);
RT_CLASS!{class GridViewHeaderItem: IGridViewHeaderItem}
RT_CLASS!{class GridViewItem: IGridViewItem}
RT_CLASS!{class ListViewHeaderItem: IListViewHeaderItem}
RT_CLASS!{class ListViewItem: IListViewItem}
RT_CLASS!{class ToggleMenuFlyoutItem: IToggleMenuFlyoutItem}
impl RtActivatable<IToggleMenuFlyoutItemStatics> for ToggleMenuFlyoutItem {}
impl ToggleMenuFlyoutItem {
    #[inline] pub fn get_is_checked_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IToggleMenuFlyoutItemStatics>>::get_activation_factory().get_is_checked_property()
    }}
}
DEFINE_CLSID!(ToggleMenuFlyoutItem(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,84,111,103,103,108,101,77,101,110,117,70,108,121,111,117,116,73,116,101,109,0]) [CLSID_ToggleMenuFlyoutItem]);
RT_CLASS!{class AppBarButton: IAppBarButton}
impl RtActivatable<IAppBarButtonStatics3> for AppBarButton {}
impl RtActivatable<IAppBarButtonStatics> for AppBarButton {}
impl AppBarButton {
    #[inline] pub fn get_label_position_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAppBarButtonStatics3>>::get_activation_factory().get_label_position_property()
    }}
    #[inline] pub fn get_is_in_overflow_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAppBarButtonStatics3>>::get_activation_factory().get_is_in_overflow_property()
    }}
    #[inline] pub fn get_dynamic_overflow_order_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAppBarButtonStatics3>>::get_activation_factory().get_dynamic_overflow_order_property()
    }}
    #[inline] pub fn get_label_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAppBarButtonStatics>>::get_activation_factory().get_label_property()
    }}
    #[inline] pub fn get_icon_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAppBarButtonStatics>>::get_activation_factory().get_icon_property()
    }}
    #[inline] pub fn get_is_compact_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAppBarButtonStatics>>::get_activation_factory().get_is_compact_property()
    }}
}
DEFINE_CLSID!(AppBarButton(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,65,112,112,66,97,114,66,117,116,116,111,110,0]) [CLSID_AppBarButton]);
RT_CLASS!{class AppBarToggleButton: IAppBarToggleButton}
impl RtActivatable<IAppBarToggleButtonStatics> for AppBarToggleButton {}
impl RtActivatable<IAppBarToggleButtonStatics3> for AppBarToggleButton {}
impl AppBarToggleButton {
    #[inline] pub fn get_label_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAppBarToggleButtonStatics>>::get_activation_factory().get_label_property()
    }}
    #[inline] pub fn get_icon_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAppBarToggleButtonStatics>>::get_activation_factory().get_icon_property()
    }}
    #[inline] pub fn get_is_compact_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAppBarToggleButtonStatics>>::get_activation_factory().get_is_compact_property()
    }}
    #[inline] pub fn get_label_position_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAppBarToggleButtonStatics3>>::get_activation_factory().get_label_position_property()
    }}
    #[inline] pub fn get_is_in_overflow_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAppBarToggleButtonStatics3>>::get_activation_factory().get_is_in_overflow_property()
    }}
    #[inline] pub fn get_dynamic_overflow_order_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAppBarToggleButtonStatics3>>::get_activation_factory().get_dynamic_overflow_order_property()
    }}
}
DEFINE_CLSID!(AppBarToggleButton(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,65,112,112,66,97,114,84,111,103,103,108,101,66,117,116,116,111,110,0]) [CLSID_AppBarToggleButton]);
RT_CLASS!{class GridView: IGridView}
RT_CLASS!{class ListView: IListView}
DEFINE_IID!(IID_IControlStatics5, 4130715043, 61326, 16463, 135, 123, 85, 128, 71, 55, 16, 166);
RT_INTERFACE!{static interface IControlStatics5(IControlStatics5Vtbl): IInspectable(IInspectableVtbl) [IID_IControlStatics5] {
    fn get_DefaultStyleResourceUriProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsTemplateKeyTipTargetProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetIsTemplateKeyTipTarget(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetIsTemplateKeyTipTarget(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT
}}
impl IControlStatics5 {
    #[inline] pub unsafe fn get_default_style_resource_uri_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DefaultStyleResourceUriProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_template_key_tip_target_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsTemplateKeyTipTargetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_template_key_tip_target(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsTemplateKeyTipTarget)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_template_key_tip_target(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetIsTemplateKeyTipTarget)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class Flyout: IFlyout}
impl RtActivatable<IFlyoutStatics> for Flyout {}
impl Flyout {
    #[inline] pub fn get_content_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFlyoutStatics>>::get_activation_factory().get_content_property()
    }}
    #[inline] pub fn get_flyout_presenter_style_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFlyoutStatics>>::get_activation_factory().get_flyout_presenter_style_property()
    }}
}
DEFINE_CLSID!(Flyout(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,70,108,121,111,117,116,0]) [CLSID_Flyout]);
RT_CLASS!{class MenuFlyout: IMenuFlyout}
impl RtActivatable<IMenuFlyoutStatics> for MenuFlyout {}
impl MenuFlyout {
    #[inline] pub fn get_menu_flyout_presenter_style_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMenuFlyoutStatics>>::get_activation_factory().get_menu_flyout_presenter_style_property()
    }}
}
DEFINE_CLSID!(MenuFlyout(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,101,110,117,70,108,121,111,117,116,0]) [CLSID_MenuFlyout]);
RT_CLASS!{class WebViewBrush: IWebViewBrush}
impl RtActivatable<IWebViewBrushStatics> for WebViewBrush {}
impl RtActivatable<IActivationFactory> for WebViewBrush {}
impl WebViewBrush {
    #[inline] pub fn get_source_name_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IWebViewBrushStatics>>::get_activation_factory().get_source_name_property()
    }}
}
DEFINE_CLSID!(WebViewBrush(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,87,101,98,86,105,101,119,66,114,117,115,104,0]) [CLSID_WebViewBrush]);
RT_ENUM! { enum InkToolbarButtonFlyoutPlacement: i32 {
    Auto (InkToolbarButtonFlyoutPlacement_Auto) = 0, Top (InkToolbarButtonFlyoutPlacement_Top) = 1, Bottom (InkToolbarButtonFlyoutPlacement_Bottom) = 2, Left (InkToolbarButtonFlyoutPlacement_Left) = 3, Right (InkToolbarButtonFlyoutPlacement_Right) = 4,
}}
RT_ENUM! { enum InkToolbarFlyoutItemKind: i32 {
    Simple (InkToolbarFlyoutItemKind_Simple) = 0, Radio (InkToolbarFlyoutItemKind_Radio) = 1, Check (InkToolbarFlyoutItemKind_Check) = 2, RadioCheck (InkToolbarFlyoutItemKind_RadioCheck) = 3,
}}
RT_ENUM! { enum InkToolbarInitialControls: i32 {
    All (InkToolbarInitialControls_All) = 0, None (InkToolbarInitialControls_None) = 1, PensOnly (InkToolbarInitialControls_PensOnly) = 2, AllExceptPens (InkToolbarInitialControls_AllExceptPens) = 3,
}}
RT_ENUM! { enum InkToolbarMenuKind: i32 {
    Stencil (InkToolbarMenuKind_Stencil) = 0,
}}
RT_ENUM! { enum InkToolbarStencilKind: i32 {
    Ruler (InkToolbarStencilKind_Ruler) = 0, Protractor (InkToolbarStencilKind_Protractor) = 1,
}}
RT_ENUM! { enum InkToolbarToggle: i32 {
    Ruler (InkToolbarToggle_Ruler) = 0, Custom (InkToolbarToggle_Custom) = 1,
}}
RT_ENUM! { enum InkToolbarTool: i32 {
    BallpointPen (InkToolbarTool_BallpointPen) = 0, Pencil (InkToolbarTool_Pencil) = 1, Highlighter (InkToolbarTool_Highlighter) = 2, Eraser (InkToolbarTool_Eraser) = 3, CustomPen (InkToolbarTool_CustomPen) = 4, CustomTool (InkToolbarTool_CustomTool) = 5,
}}
DEFINE_IID!(IID_IInkToolbarIsStencilButtonCheckedChangedEventArgs, 40820006, 54059, 20008, 160, 51, 213, 9, 118, 98, 178, 146);
RT_INTERFACE!{interface IInkToolbarIsStencilButtonCheckedChangedEventArgs(IInkToolbarIsStencilButtonCheckedChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarIsStencilButtonCheckedChangedEventArgs] {
    fn get_StencilButton(&self, out: *mut *mut InkToolbarStencilButton) -> HRESULT,
    fn get_StencilKind(&self, out: *mut InkToolbarStencilKind) -> HRESULT
}}
impl IInkToolbarIsStencilButtonCheckedChangedEventArgs {
    #[inline] pub unsafe fn get_stencil_button(&self) -> Result<ComPtr<InkToolbarStencilButton>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StencilButton)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stencil_kind(&self) -> Result<InkToolbarStencilKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StencilKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class InkToolbarIsStencilButtonCheckedChangedEventArgs: IInkToolbarIsStencilButtonCheckedChangedEventArgs}
impl RtActivatable<IActivationFactory> for InkToolbarIsStencilButtonCheckedChangedEventArgs {}
DEFINE_CLSID!(InkToolbarIsStencilButtonCheckedChangedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,73,110,107,84,111,111,108,98,97,114,73,115,83,116,101,110,99,105,108,66,117,116,116,111,110,67,104,101,99,107,101,100,67,104,97,110,103,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_InkToolbarIsStencilButtonCheckedChangedEventArgs]);
DEFINE_IID!(IID_IInkToolbarCustomPen, 1082269819, 12093, 20074, 140, 39, 254, 97, 239, 126, 112, 235);
RT_INTERFACE!{interface IInkToolbarCustomPen(IInkToolbarCustomPenVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarCustomPen] {
    #[cfg(feature="windows-ui")] fn CreateInkDrawingAttributes(&self, brush: *mut super::media::Brush, strokeWidth: f64, out: *mut *mut super::super::input::inking::InkDrawingAttributes) -> HRESULT
}}
impl IInkToolbarCustomPen {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn create_ink_drawing_attributes(&self, brush: &super::media::Brush, strokeWidth: f64) -> Result<ComPtr<super::super::input::inking::InkDrawingAttributes>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInkDrawingAttributes)(self as *const _ as *mut _, brush as *const _ as *mut _, strokeWidth, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbarCustomPenOverrides, 2636311404, 4693, 16982, 182, 189, 130, 194, 253, 39, 52, 136);
RT_INTERFACE!{interface IInkToolbarCustomPenOverrides(IInkToolbarCustomPenOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarCustomPenOverrides] {
    #[cfg(feature="windows-ui")] fn CreateInkDrawingAttributesCore(&self, brush: *mut super::media::Brush, strokeWidth: f64, out: *mut *mut super::super::input::inking::InkDrawingAttributes) -> HRESULT
}}
impl IInkToolbarCustomPenOverrides {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn create_ink_drawing_attributes_core(&self, brush: &super::media::Brush, strokeWidth: f64) -> Result<ComPtr<super::super::input::inking::InkDrawingAttributes>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInkDrawingAttributesCore)(self as *const _ as *mut _, brush as *const _ as *mut _, strokeWidth, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbarCustomPenFactory, 3524580918, 61866, 20296, 191, 44, 169, 38, 202, 174, 76, 96);
RT_INTERFACE!{interface IInkToolbarCustomPenFactory(IInkToolbarCustomPenFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarCustomPenFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut InkToolbarCustomPen) -> HRESULT
}}
impl IInkToolbarCustomPenFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<InkToolbarCustomPen>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class InkToolbarCustomPen: IInkToolbarCustomPen}
DEFINE_IID!(IID_IInkToolbar, 1037896906, 20976, 18543, 160, 62, 78, 225, 61, 193, 43, 203);
RT_INTERFACE!{interface IInkToolbar(IInkToolbarVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbar] {
    fn get_InitialControls(&self, out: *mut InkToolbarInitialControls) -> HRESULT,
    fn put_InitialControls(&self, value: InkToolbarInitialControls) -> HRESULT,
    fn get_Children(&self, out: *mut *mut super::DependencyObjectCollection) -> HRESULT,
    fn get_ActiveTool(&self, out: *mut *mut InkToolbarToolButton) -> HRESULT,
    fn put_ActiveTool(&self, value: *mut InkToolbarToolButton) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_InkDrawingAttributes(&self, out: *mut *mut super::super::input::inking::InkDrawingAttributes) -> HRESULT,
    fn get_IsRulerButtonChecked(&self, out: *mut bool) -> HRESULT,
    fn put_IsRulerButtonChecked(&self, value: bool) -> HRESULT,
    fn get_TargetInkCanvas(&self, out: *mut *mut InkCanvas) -> HRESULT,
    fn put_TargetInkCanvas(&self, value: *mut InkCanvas) -> HRESULT,
    fn add_ActiveToolChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<InkToolbar, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ActiveToolChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_InkDrawingAttributesChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<InkToolbar, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_InkDrawingAttributesChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_EraseAllClicked(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<InkToolbar, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EraseAllClicked(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_IsRulerButtonCheckedChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<InkToolbar, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_IsRulerButtonCheckedChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn GetToolButton(&self, tool: InkToolbarTool, out: *mut *mut InkToolbarToolButton) -> HRESULT,
    fn GetToggleButton(&self, tool: InkToolbarToggle, out: *mut *mut InkToolbarToggleButton) -> HRESULT
}}
impl IInkToolbar {
    #[inline] pub unsafe fn get_initial_controls(&self) -> Result<InkToolbarInitialControls> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InitialControls)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_initial_controls(&self, value: InkToolbarInitialControls) -> Result<()> {
        let hr = ((*self.lpVtbl).put_InitialControls)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_children(&self) -> Result<ComPtr<super::DependencyObjectCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Children)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_active_tool(&self) -> Result<ComPtr<InkToolbarToolButton>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ActiveTool)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_active_tool(&self, value: &InkToolbarToolButton) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ActiveTool)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_ink_drawing_attributes(&self) -> Result<ComPtr<super::super::input::inking::InkDrawingAttributes>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InkDrawingAttributes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_ruler_button_checked(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsRulerButtonChecked)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_ruler_button_checked(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsRulerButtonChecked)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_target_ink_canvas(&self) -> Result<ComPtr<InkCanvas>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetInkCanvas)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_ink_canvas(&self, value: &InkCanvas) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetInkCanvas)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_active_tool_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<InkToolbar, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ActiveToolChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_active_tool_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ActiveToolChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_ink_drawing_attributes_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<InkToolbar, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_InkDrawingAttributesChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_ink_drawing_attributes_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_InkDrawingAttributesChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_erase_all_clicked(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<InkToolbar, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_EraseAllClicked)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_erase_all_clicked(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_EraseAllClicked)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_is_ruler_button_checked_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<InkToolbar, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_IsRulerButtonCheckedChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_is_ruler_button_checked_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_IsRulerButtonCheckedChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tool_button(&self, tool: InkToolbarTool) -> Result<ComPtr<InkToolbarToolButton>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetToolButton)(self as *const _ as *mut _, tool, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_toggle_button(&self, tool: InkToolbarToggle) -> Result<ComPtr<InkToolbarToggleButton>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetToggleButton)(self as *const _ as *mut _, tool, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbarStatics, 2746520507, 52047, 20075, 163, 61, 241, 30, 122, 41, 94, 250);
RT_INTERFACE!{static interface IInkToolbarStatics(IInkToolbarStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarStatics] {
    fn get_InitialControlsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ChildrenProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ActiveToolProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_InkDrawingAttributesProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsRulerButtonCheckedProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TargetInkCanvasProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IInkToolbarStatics {
    #[inline] pub unsafe fn get_initial_controls_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InitialControlsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_children_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ChildrenProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_active_tool_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ActiveToolProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_ink_drawing_attributes_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InkDrawingAttributesProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_ruler_button_checked_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsRulerButtonCheckedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_target_ink_canvas_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetInkCanvasProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbarFactory, 960998041, 14001, 17268, 171, 92, 152, 191, 7, 164, 50, 11);
RT_INTERFACE!{interface IInkToolbarFactory(IInkToolbarFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut InkToolbar) -> HRESULT
}}
impl IInkToolbarFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<InkToolbar>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbar2, 2263925009, 46212, 17738, 174, 120, 29, 37, 163, 61, 28, 103);
RT_INTERFACE!{interface IInkToolbar2(IInkToolbar2Vtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbar2] {
    fn get_IsStencilButtonChecked(&self, out: *mut bool) -> HRESULT,
    fn put_IsStencilButtonChecked(&self, value: bool) -> HRESULT,
    fn get_ButtonFlyoutPlacement(&self, out: *mut InkToolbarButtonFlyoutPlacement) -> HRESULT,
    fn put_ButtonFlyoutPlacement(&self, value: InkToolbarButtonFlyoutPlacement) -> HRESULT,
    fn get_Orientation(&self, out: *mut Orientation) -> HRESULT,
    fn put_Orientation(&self, value: Orientation) -> HRESULT,
    fn add_IsStencilButtonCheckedChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<InkToolbar, InkToolbarIsStencilButtonCheckedChangedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_IsStencilButtonCheckedChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn GetMenuButton(&self, menu: InkToolbarMenuKind, out: *mut *mut InkToolbarMenuButton) -> HRESULT
}}
impl IInkToolbar2 {
    #[inline] pub unsafe fn get_is_stencil_button_checked(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsStencilButtonChecked)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_stencil_button_checked(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsStencilButtonChecked)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_button_flyout_placement(&self) -> Result<InkToolbarButtonFlyoutPlacement> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ButtonFlyoutPlacement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_button_flyout_placement(&self, value: InkToolbarButtonFlyoutPlacement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ButtonFlyoutPlacement)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation(&self) -> Result<Orientation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Orientation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_orientation(&self, value: Orientation) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Orientation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_is_stencil_button_checked_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<InkToolbar, InkToolbarIsStencilButtonCheckedChangedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_IsStencilButtonCheckedChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_is_stencil_button_checked_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_IsStencilButtonCheckedChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_menu_button(&self, menu: InkToolbarMenuKind) -> Result<ComPtr<InkToolbarMenuButton>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMenuButton)(self as *const _ as *mut _, menu, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class InkToolbar: IInkToolbar}
impl RtActivatable<IInkToolbarStatics> for InkToolbar {}
impl RtActivatable<IInkToolbarStatics2> for InkToolbar {}
impl InkToolbar {
    #[inline] pub fn get_initial_controls_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarStatics>>::get_activation_factory().get_initial_controls_property()
    }}
    #[inline] pub fn get_children_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarStatics>>::get_activation_factory().get_children_property()
    }}
    #[inline] pub fn get_active_tool_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarStatics>>::get_activation_factory().get_active_tool_property()
    }}
    #[inline] pub fn get_ink_drawing_attributes_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarStatics>>::get_activation_factory().get_ink_drawing_attributes_property()
    }}
    #[inline] pub fn get_is_ruler_button_checked_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarStatics>>::get_activation_factory().get_is_ruler_button_checked_property()
    }}
    #[inline] pub fn get_target_ink_canvas_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarStatics>>::get_activation_factory().get_target_ink_canvas_property()
    }}
    #[inline] pub fn get_is_stencil_button_checked_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarStatics2>>::get_activation_factory().get_is_stencil_button_checked_property()
    }}
    #[inline] pub fn get_button_flyout_placement_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarStatics2>>::get_activation_factory().get_button_flyout_placement_property()
    }}
    #[inline] pub fn get_orientation_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarStatics2>>::get_activation_factory().get_orientation_property()
    }}
}
DEFINE_CLSID!(InkToolbar(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,73,110,107,84,111,111,108,98,97,114,0]) [CLSID_InkToolbar]);
DEFINE_IID!(IID_IInkToolbarStatics2, 2864838898, 11295, 20124, 179, 243, 49, 255, 34, 181, 28, 122);
RT_INTERFACE!{static interface IInkToolbarStatics2(IInkToolbarStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarStatics2] {
    fn get_IsStencilButtonCheckedProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ButtonFlyoutPlacementProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OrientationProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IInkToolbarStatics2 {
    #[inline] pub unsafe fn get_is_stencil_button_checked_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsStencilButtonCheckedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_button_flyout_placement_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ButtonFlyoutPlacementProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OrientationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbarPenConfigurationControl, 1612375542, 10405, 17612, 137, 166, 56, 14, 145, 165, 114, 221);
RT_INTERFACE!{interface IInkToolbarPenConfigurationControl(IInkToolbarPenConfigurationControlVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarPenConfigurationControl] {
    fn get_PenButton(&self, out: *mut *mut InkToolbarPenButton) -> HRESULT
}}
impl IInkToolbarPenConfigurationControl {
    #[inline] pub unsafe fn get_pen_button(&self) -> Result<ComPtr<InkToolbarPenButton>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PenButton)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbarPenConfigurationControlStatics, 1218845679, 6606, 16827, 171, 224, 124, 135, 38, 250, 231, 94);
RT_INTERFACE!{static interface IInkToolbarPenConfigurationControlStatics(IInkToolbarPenConfigurationControlStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarPenConfigurationControlStatics] {
    fn get_PenButtonProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IInkToolbarPenConfigurationControlStatics {
    #[inline] pub unsafe fn get_pen_button_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PenButtonProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbarPenConfigurationControlFactory, 1743807982, 62951, 18155, 145, 135, 141, 60, 163, 175, 137, 27);
RT_INTERFACE!{interface IInkToolbarPenConfigurationControlFactory(IInkToolbarPenConfigurationControlFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarPenConfigurationControlFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut InkToolbarPenConfigurationControl) -> HRESULT
}}
impl IInkToolbarPenConfigurationControlFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<InkToolbarPenConfigurationControl>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class InkToolbarPenConfigurationControl: IInkToolbarPenConfigurationControl}
impl RtActivatable<IInkToolbarPenConfigurationControlStatics> for InkToolbarPenConfigurationControl {}
impl InkToolbarPenConfigurationControl {
    #[inline] pub fn get_pen_button_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarPenConfigurationControlStatics>>::get_activation_factory().get_pen_button_property()
    }}
}
DEFINE_CLSID!(InkToolbarPenConfigurationControl(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,73,110,107,84,111,111,108,98,97,114,80,101,110,67,111,110,102,105,103,117,114,97,116,105,111,110,67,111,110,116,114,111,108,0]) [CLSID_InkToolbarPenConfigurationControl]);
DEFINE_IID!(IID_IInkToolbarFlyoutItem, 2461435782, 14318, 18709, 158, 137, 225, 135, 86, 74, 136, 154);
RT_INTERFACE!{interface IInkToolbarFlyoutItem(IInkToolbarFlyoutItemVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarFlyoutItem] {
    fn get_Kind(&self, out: *mut InkToolbarFlyoutItemKind) -> HRESULT,
    fn put_Kind(&self, value: InkToolbarFlyoutItemKind) -> HRESULT,
    fn get_IsChecked(&self, out: *mut bool) -> HRESULT,
    fn put_IsChecked(&self, value: bool) -> HRESULT,
    fn add_Checked(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<InkToolbarFlyoutItem, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Checked(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Unchecked(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<InkToolbarFlyoutItem, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Unchecked(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IInkToolbarFlyoutItem {
    #[inline] pub unsafe fn get_kind(&self) -> Result<InkToolbarFlyoutItemKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_kind(&self, value: InkToolbarFlyoutItemKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Kind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_checked(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsChecked)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_checked(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsChecked)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_checked(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<InkToolbarFlyoutItem, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Checked)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_checked(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Checked)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_unchecked(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<InkToolbarFlyoutItem, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Unchecked)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_unchecked(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Unchecked)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class InkToolbarFlyoutItem: IInkToolbarFlyoutItem}
impl RtActivatable<IInkToolbarFlyoutItemStatics> for InkToolbarFlyoutItem {}
impl InkToolbarFlyoutItem {
    #[inline] pub fn get_kind_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarFlyoutItemStatics>>::get_activation_factory().get_kind_property()
    }}
    #[inline] pub fn get_is_checked_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarFlyoutItemStatics>>::get_activation_factory().get_is_checked_property()
    }}
}
DEFINE_CLSID!(InkToolbarFlyoutItem(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,73,110,107,84,111,111,108,98,97,114,70,108,121,111,117,116,73,116,101,109,0]) [CLSID_InkToolbarFlyoutItem]);
DEFINE_IID!(IID_IInkToolbarFlyoutItemStatics, 535120740, 16483, 19039, 184, 156, 159, 88, 147, 94, 227, 121);
RT_INTERFACE!{static interface IInkToolbarFlyoutItemStatics(IInkToolbarFlyoutItemStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarFlyoutItemStatics] {
    fn get_KindProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsCheckedProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IInkToolbarFlyoutItemStatics {
    #[inline] pub unsafe fn get_kind_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KindProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_checked_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsCheckedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbarFlyoutItemFactory, 892238739, 32827, 20238, 140, 114, 157, 252, 3, 41, 50, 159);
RT_INTERFACE!{interface IInkToolbarFlyoutItemFactory(IInkToolbarFlyoutItemFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarFlyoutItemFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut InkToolbarFlyoutItem) -> HRESULT
}}
impl IInkToolbarFlyoutItemFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<InkToolbarFlyoutItem>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbarMenuButton, 2249116389, 30259, 20129, 162, 9, 80, 57, 45, 26, 235, 209);
RT_INTERFACE!{interface IInkToolbarMenuButton(IInkToolbarMenuButtonVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarMenuButton] {
    fn get_MenuKind(&self, out: *mut InkToolbarMenuKind) -> HRESULT,
    fn get_IsExtensionGlyphShown(&self, out: *mut bool) -> HRESULT,
    fn put_IsExtensionGlyphShown(&self, value: bool) -> HRESULT
}}
impl IInkToolbarMenuButton {
    #[inline] pub unsafe fn get_menu_kind(&self) -> Result<InkToolbarMenuKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MenuKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_extension_glyph_shown(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsExtensionGlyphShown)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_extension_glyph_shown(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsExtensionGlyphShown)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class InkToolbarMenuButton: IInkToolbarMenuButton}
impl RtActivatable<IInkToolbarMenuButtonStatics> for InkToolbarMenuButton {}
impl InkToolbarMenuButton {
    #[inline] pub fn get_is_extension_glyph_shown_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarMenuButtonStatics>>::get_activation_factory().get_is_extension_glyph_shown_property()
    }}
}
DEFINE_CLSID!(InkToolbarMenuButton(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,73,110,107,84,111,111,108,98,97,114,77,101,110,117,66,117,116,116,111,110,0]) [CLSID_InkToolbarMenuButton]);
DEFINE_IID!(IID_IInkToolbarMenuButtonStatics, 4030404518, 47280, 19079, 169, 97, 55, 205, 5, 216, 49, 55);
RT_INTERFACE!{static interface IInkToolbarMenuButtonStatics(IInkToolbarMenuButtonStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarMenuButtonStatics] {
    fn get_IsExtensionGlyphShownProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IInkToolbarMenuButtonStatics {
    #[inline] pub unsafe fn get_is_extension_glyph_shown_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsExtensionGlyphShownProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbarMenuButtonFactory, 2051422877, 24007, 17575, 175, 208, 43, 104, 92, 185, 169, 108);
RT_INTERFACE!{interface IInkToolbarMenuButtonFactory(IInkToolbarMenuButtonFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarMenuButtonFactory] {
    
}}
DEFINE_IID!(IID_IInkToolbarStencilButton, 812262934, 23360, 19443, 146, 183, 241, 223, 147, 106, 239, 245);
RT_INTERFACE!{interface IInkToolbarStencilButton(IInkToolbarStencilButtonVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarStencilButton] {
    #[cfg(not(feature="windows-ui"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Ruler(&self, out: *mut *mut super::super::input::inking::InkPresenterRuler) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Protractor(&self, out: *mut *mut super::super::input::inking::InkPresenterProtractor) -> HRESULT,
    fn get_SelectedStencil(&self, out: *mut InkToolbarStencilKind) -> HRESULT,
    fn put_SelectedStencil(&self, value: InkToolbarStencilKind) -> HRESULT,
    fn get_IsRulerItemVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsRulerItemVisible(&self, value: bool) -> HRESULT,
    fn get_IsProtractorItemVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsProtractorItemVisible(&self, value: bool) -> HRESULT
}}
impl IInkToolbarStencilButton {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_ruler(&self) -> Result<ComPtr<super::super::input::inking::InkPresenterRuler>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Ruler)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_protractor(&self) -> Result<ComPtr<super::super::input::inking::InkPresenterProtractor>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Protractor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_stencil(&self) -> Result<InkToolbarStencilKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SelectedStencil)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_stencil(&self, value: InkToolbarStencilKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedStencil)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_ruler_item_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsRulerItemVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_ruler_item_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsRulerItemVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_protractor_item_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsProtractorItemVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_protractor_item_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsProtractorItemVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class InkToolbarStencilButton: IInkToolbarStencilButton}
impl RtActivatable<IInkToolbarStencilButtonStatics> for InkToolbarStencilButton {}
impl InkToolbarStencilButton {
    #[inline] pub fn get_ruler_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarStencilButtonStatics>>::get_activation_factory().get_ruler_property()
    }}
    #[inline] pub fn get_protractor_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarStencilButtonStatics>>::get_activation_factory().get_protractor_property()
    }}
    #[inline] pub fn get_selected_stencil_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarStencilButtonStatics>>::get_activation_factory().get_selected_stencil_property()
    }}
    #[inline] pub fn get_is_ruler_item_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarStencilButtonStatics>>::get_activation_factory().get_is_ruler_item_visible_property()
    }}
    #[inline] pub fn get_is_protractor_item_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarStencilButtonStatics>>::get_activation_factory().get_is_protractor_item_visible_property()
    }}
}
DEFINE_CLSID!(InkToolbarStencilButton(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,73,110,107,84,111,111,108,98,97,114,83,116,101,110,99,105,108,66,117,116,116,111,110,0]) [CLSID_InkToolbarStencilButton]);
DEFINE_IID!(IID_IInkToolbarStencilButtonStatics, 1195950207, 25572, 16909, 147, 154, 107, 114, 67, 233, 209, 36);
RT_INTERFACE!{static interface IInkToolbarStencilButtonStatics(IInkToolbarStencilButtonStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarStencilButtonStatics] {
    fn get_RulerProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ProtractorProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectedStencilProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsRulerItemVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsProtractorItemVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IInkToolbarStencilButtonStatics {
    #[inline] pub unsafe fn get_ruler_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RulerProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_protractor_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProtractorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_stencil_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedStencilProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_ruler_item_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsRulerItemVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_protractor_item_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsProtractorItemVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbarStencilButtonFactory, 2718368209, 35440, 19831, 137, 212, 23, 48, 163, 165, 142, 223);
RT_INTERFACE!{interface IInkToolbarStencilButtonFactory(IInkToolbarStencilButtonFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarStencilButtonFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut InkToolbarStencilButton) -> HRESULT
}}
impl IInkToolbarStencilButtonFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<InkToolbarStencilButton>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbarToggleButton, 3030546682, 62960, 19231, 190, 176, 11, 138, 41, 144, 90, 74);
RT_INTERFACE!{interface IInkToolbarToggleButton(IInkToolbarToggleButtonVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarToggleButton] {
    fn get_ToggleKind(&self, out: *mut InkToolbarToggle) -> HRESULT
}}
impl IInkToolbarToggleButton {
    #[inline] pub unsafe fn get_toggle_kind(&self) -> Result<InkToolbarToggle> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ToggleKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class InkToolbarToggleButton: IInkToolbarToggleButton}
DEFINE_IID!(IID_IInkToolbarToggleButtonFactory, 3002664720, 58785, 17253, 157, 26, 229, 183, 173, 139, 150, 104);
RT_INTERFACE!{interface IInkToolbarToggleButtonFactory(IInkToolbarToggleButtonFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarToggleButtonFactory] {
    
}}
DEFINE_IID!(IID_IInkToolbarToolButton, 1549464606, 52407, 17496, 128, 100, 169, 132, 157, 49, 86, 27);
RT_INTERFACE!{interface IInkToolbarToolButton(IInkToolbarToolButtonVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarToolButton] {
    fn get_ToolKind(&self, out: *mut InkToolbarTool) -> HRESULT,
    fn get_IsExtensionGlyphShown(&self, out: *mut bool) -> HRESULT,
    fn put_IsExtensionGlyphShown(&self, value: bool) -> HRESULT
}}
impl IInkToolbarToolButton {
    #[inline] pub unsafe fn get_tool_kind(&self) -> Result<InkToolbarTool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ToolKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_extension_glyph_shown(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsExtensionGlyphShown)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_extension_glyph_shown(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsExtensionGlyphShown)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class InkToolbarToolButton: IInkToolbarToolButton}
impl RtActivatable<IInkToolbarToolButtonStatics> for InkToolbarToolButton {}
impl InkToolbarToolButton {
    #[inline] pub fn get_is_extension_glyph_shown_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarToolButtonStatics>>::get_activation_factory().get_is_extension_glyph_shown_property()
    }}
}
DEFINE_CLSID!(InkToolbarToolButton(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,73,110,107,84,111,111,108,98,97,114,84,111,111,108,66,117,116,116,111,110,0]) [CLSID_InkToolbarToolButton]);
DEFINE_IID!(IID_IInkToolbarToolButtonStatics, 2651421976, 53558, 20214, 176, 253, 26, 120, 194, 136, 74, 1);
RT_INTERFACE!{static interface IInkToolbarToolButtonStatics(IInkToolbarToolButtonStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarToolButtonStatics] {
    fn get_IsExtensionGlyphShownProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IInkToolbarToolButtonStatics {
    #[inline] pub unsafe fn get_is_extension_glyph_shown_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsExtensionGlyphShownProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbarToolButtonFactory, 1653849931, 35326, 20176, 161, 166, 136, 211, 235, 169, 23, 178);
RT_INTERFACE!{interface IInkToolbarToolButtonFactory(IInkToolbarToolButtonFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarToolButtonFactory] {
    
}}
DEFINE_IID!(IID_IInkToolbarCustomToggleButton, 1426869636, 20308, 20414, 177, 43, 224, 165, 10, 171, 13, 5);
RT_INTERFACE!{interface IInkToolbarCustomToggleButton(IInkToolbarCustomToggleButtonVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarCustomToggleButton] {
    
}}
DEFINE_IID!(IID_IInkToolbarCustomToggleButtonFactory, 1241528141, 19666, 20185, 134, 62, 131, 184, 207, 63, 210, 175);
RT_INTERFACE!{interface IInkToolbarCustomToggleButtonFactory(IInkToolbarCustomToggleButtonFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarCustomToggleButtonFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut InkToolbarCustomToggleButton) -> HRESULT
}}
impl IInkToolbarCustomToggleButtonFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<InkToolbarCustomToggleButton>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class InkToolbarCustomToggleButton: IInkToolbarCustomToggleButton}
DEFINE_IID!(IID_IInkToolbarCustomToolButton, 2677583063, 50693, 16645, 190, 16, 57, 67, 167, 192, 218, 60);
RT_INTERFACE!{interface IInkToolbarCustomToolButton(IInkToolbarCustomToolButtonVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarCustomToolButton] {
    fn get_ConfigurationContent(&self, out: *mut *mut super::UIElement) -> HRESULT,
    fn put_ConfigurationContent(&self, value: *mut super::UIElement) -> HRESULT
}}
impl IInkToolbarCustomToolButton {
    #[inline] pub unsafe fn get_configuration_content(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ConfigurationContent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_configuration_content(&self, value: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ConfigurationContent)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbarCustomToolButtonStatics, 301878457, 48044, 17172, 147, 68, 146, 198, 105, 61, 222, 175);
RT_INTERFACE!{static interface IInkToolbarCustomToolButtonStatics(IInkToolbarCustomToolButtonStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarCustomToolButtonStatics] {
    fn get_ConfigurationContentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IInkToolbarCustomToolButtonStatics {
    #[inline] pub unsafe fn get_configuration_content_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ConfigurationContentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbarCustomToolButtonFactory, 3264609870, 12523, 16688, 166, 182, 140, 133, 216, 226, 110, 137);
RT_INTERFACE!{interface IInkToolbarCustomToolButtonFactory(IInkToolbarCustomToolButtonFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarCustomToolButtonFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut InkToolbarCustomToolButton) -> HRESULT
}}
impl IInkToolbarCustomToolButtonFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<InkToolbarCustomToolButton>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class InkToolbarCustomToolButton: IInkToolbarCustomToolButton}
impl RtActivatable<IInkToolbarCustomToolButtonStatics> for InkToolbarCustomToolButton {}
impl InkToolbarCustomToolButton {
    #[inline] pub fn get_configuration_content_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarCustomToolButtonStatics>>::get_activation_factory().get_configuration_content_property()
    }}
}
DEFINE_CLSID!(InkToolbarCustomToolButton(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,73,110,107,84,111,111,108,98,97,114,67,117,115,116,111,109,84,111,111,108,66,117,116,116,111,110,0]) [CLSID_InkToolbarCustomToolButton]);
DEFINE_IID!(IID_IInkToolbarEraserButton, 1287502126, 24414, 19253, 164, 28, 22, 255, 176, 40, 59, 192);
RT_INTERFACE!{interface IInkToolbarEraserButton(IInkToolbarEraserButtonVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarEraserButton] {
    
}}
DEFINE_IID!(IID_IInkToolbarEraserButtonFactory, 4248854813, 53690, 19815, 175, 0, 20, 128, 54, 173, 73, 44);
RT_INTERFACE!{interface IInkToolbarEraserButtonFactory(IInkToolbarEraserButtonFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarEraserButtonFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut InkToolbarEraserButton) -> HRESULT
}}
impl IInkToolbarEraserButtonFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<InkToolbarEraserButton>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbarEraserButton2, 3886387799, 23272, 17261, 178, 226, 147, 194, 0, 144, 12, 160);
RT_INTERFACE!{interface IInkToolbarEraserButton2(IInkToolbarEraserButton2Vtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarEraserButton2] {
    fn get_IsClearAllVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsClearAllVisible(&self, value: bool) -> HRESULT
}}
impl IInkToolbarEraserButton2 {
    #[inline] pub unsafe fn get_is_clear_all_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsClearAllVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_clear_all_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsClearAllVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class InkToolbarEraserButton: IInkToolbarEraserButton}
impl RtActivatable<IInkToolbarEraserButtonStatics2> for InkToolbarEraserButton {}
impl InkToolbarEraserButton {
    #[inline] pub fn get_is_clear_all_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarEraserButtonStatics2>>::get_activation_factory().get_is_clear_all_visible_property()
    }}
}
DEFINE_CLSID!(InkToolbarEraserButton(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,73,110,107,84,111,111,108,98,97,114,69,114,97,115,101,114,66,117,116,116,111,110,0]) [CLSID_InkToolbarEraserButton]);
DEFINE_IID!(IID_IInkToolbarEraserButtonStatics2, 59381558, 50637, 17169, 131, 244, 56, 203, 240, 124, 32, 102);
RT_INTERFACE!{static interface IInkToolbarEraserButtonStatics2(IInkToolbarEraserButtonStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarEraserButtonStatics2] {
    fn get_IsClearAllVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IInkToolbarEraserButtonStatics2 {
    #[inline] pub unsafe fn get_is_clear_all_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsClearAllVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbarPenButton, 3770158113, 45106, 16622, 162, 185, 80, 127, 108, 203, 130, 123);
RT_INTERFACE!{interface IInkToolbarPenButton(IInkToolbarPenButtonVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarPenButton] {
    fn get_Palette(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<super::media::Brush>) -> HRESULT,
    fn put_Palette(&self, value: *mut ::rt::gen::windows::foundation::collections::IVector<super::media::Brush>) -> HRESULT,
    fn get_MinStrokeWidth(&self, out: *mut f64) -> HRESULT,
    fn put_MinStrokeWidth(&self, value: f64) -> HRESULT,
    fn get_MaxStrokeWidth(&self, out: *mut f64) -> HRESULT,
    fn put_MaxStrokeWidth(&self, value: f64) -> HRESULT,
    fn get_SelectedBrush(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn get_SelectedBrushIndex(&self, out: *mut i32) -> HRESULT,
    fn put_SelectedBrushIndex(&self, value: i32) -> HRESULT,
    fn get_SelectedStrokeWidth(&self, out: *mut f64) -> HRESULT,
    fn put_SelectedStrokeWidth(&self, value: f64) -> HRESULT
}}
impl IInkToolbarPenButton {
    #[inline] pub unsafe fn get_palette(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<super::media::Brush>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Palette)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_palette(&self, value: &::rt::gen::windows::foundation::collections::IVector<super::media::Brush>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Palette)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_stroke_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinStrokeWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_min_stroke_width(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MinStrokeWidth)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_stroke_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxStrokeWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_stroke_width(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxStrokeWidth)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_brush(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_brush_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SelectedBrushIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_brush_index(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedBrushIndex)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_stroke_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SelectedStrokeWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_stroke_width(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedStrokeWidth)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class InkToolbarPenButton: IInkToolbarPenButton}
impl RtActivatable<IInkToolbarPenButtonStatics> for InkToolbarPenButton {}
impl InkToolbarPenButton {
    #[inline] pub fn get_palette_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarPenButtonStatics>>::get_activation_factory().get_palette_property()
    }}
    #[inline] pub fn get_min_stroke_width_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarPenButtonStatics>>::get_activation_factory().get_min_stroke_width_property()
    }}
    #[inline] pub fn get_max_stroke_width_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarPenButtonStatics>>::get_activation_factory().get_max_stroke_width_property()
    }}
    #[inline] pub fn get_selected_brush_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarPenButtonStatics>>::get_activation_factory().get_selected_brush_property()
    }}
    #[inline] pub fn get_selected_brush_index_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarPenButtonStatics>>::get_activation_factory().get_selected_brush_index_property()
    }}
    #[inline] pub fn get_selected_stroke_width_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarPenButtonStatics>>::get_activation_factory().get_selected_stroke_width_property()
    }}
}
DEFINE_CLSID!(InkToolbarPenButton(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,73,110,107,84,111,111,108,98,97,114,80,101,110,66,117,116,116,111,110,0]) [CLSID_InkToolbarPenButton]);
DEFINE_IID!(IID_IInkToolbarPenButtonStatics, 3106065986, 2544, 17725, 128, 38, 68, 218, 242, 117, 63, 101);
RT_INTERFACE!{static interface IInkToolbarPenButtonStatics(IInkToolbarPenButtonStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarPenButtonStatics] {
    fn get_PaletteProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MinStrokeWidthProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MaxStrokeWidthProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectedBrushProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectedBrushIndexProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectedStrokeWidthProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IInkToolbarPenButtonStatics {
    #[inline] pub unsafe fn get_palette_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PaletteProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_stroke_width_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MinStrokeWidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_stroke_width_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxStrokeWidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_brush_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_brush_index_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedBrushIndexProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_stroke_width_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedStrokeWidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbarPenButtonFactory, 2974170401, 22987, 19075, 146, 225, 105, 40, 66, 121, 123, 46);
RT_INTERFACE!{interface IInkToolbarPenButtonFactory(IInkToolbarPenButtonFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarPenButtonFactory] {
    
}}
DEFINE_IID!(IID_IInkToolbarRulerButton, 1251551282, 6532, 16712, 159, 37, 56, 43, 53, 219, 8, 127);
RT_INTERFACE!{interface IInkToolbarRulerButton(IInkToolbarRulerButtonVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarRulerButton] {
    #[cfg(feature="windows-ui")] fn get_Ruler(&self, out: *mut *mut super::super::input::inking::InkPresenterRuler) -> HRESULT
}}
impl IInkToolbarRulerButton {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_ruler(&self) -> Result<ComPtr<super::super::input::inking::InkPresenterRuler>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Ruler)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbarRulerButtonStatics, 3135725413, 48688, 19438, 150, 75, 255, 158, 73, 143, 238, 55);
RT_INTERFACE!{static interface IInkToolbarRulerButtonStatics(IInkToolbarRulerButtonStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarRulerButtonStatics] {
    fn get_RulerProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IInkToolbarRulerButtonStatics {
    #[inline] pub unsafe fn get_ruler_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RulerProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbarRulerButtonFactory, 3139885151, 53206, 18783, 147, 171, 184, 86, 106, 249, 248, 175);
RT_INTERFACE!{interface IInkToolbarRulerButtonFactory(IInkToolbarRulerButtonFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarRulerButtonFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut InkToolbarRulerButton) -> HRESULT
}}
impl IInkToolbarRulerButtonFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<InkToolbarRulerButton>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class InkToolbarRulerButton: IInkToolbarRulerButton}
impl RtActivatable<IInkToolbarRulerButtonStatics> for InkToolbarRulerButton {}
impl InkToolbarRulerButton {
    #[inline] pub fn get_ruler_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarRulerButtonStatics>>::get_activation_factory().get_ruler_property()
    }}
}
DEFINE_CLSID!(InkToolbarRulerButton(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,73,110,107,84,111,111,108,98,97,114,82,117,108,101,114,66,117,116,116,111,110,0]) [CLSID_InkToolbarRulerButton]);
DEFINE_IID!(IID_IInkToolbarBallpointPenButton, 360917496, 7833, 15052, 145, 15, 157, 162, 216, 114, 174, 18);
RT_INTERFACE!{interface IInkToolbarBallpointPenButton(IInkToolbarBallpointPenButtonVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarBallpointPenButton] {
    
}}
DEFINE_IID!(IID_IInkToolbarBallpointPenButtonFactory, 789304292, 55124, 16981, 142, 196, 0, 205, 16, 18, 150, 171);
RT_INTERFACE!{interface IInkToolbarBallpointPenButtonFactory(IInkToolbarBallpointPenButtonFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarBallpointPenButtonFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut InkToolbarBallpointPenButton) -> HRESULT
}}
impl IInkToolbarBallpointPenButtonFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<InkToolbarBallpointPenButton>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class InkToolbarBallpointPenButton: IInkToolbarBallpointPenButton}
DEFINE_IID!(IID_IInkToolbarCustomPenButton, 1174553601, 11050, 20284, 165, 60, 26, 4, 90, 64, 142, 250);
RT_INTERFACE!{interface IInkToolbarCustomPenButton(IInkToolbarCustomPenButtonVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarCustomPenButton] {
    fn get_CustomPen(&self, out: *mut *mut InkToolbarCustomPen) -> HRESULT,
    fn put_CustomPen(&self, value: *mut InkToolbarCustomPen) -> HRESULT,
    fn get_ConfigurationContent(&self, out: *mut *mut super::UIElement) -> HRESULT,
    fn put_ConfigurationContent(&self, value: *mut super::UIElement) -> HRESULT
}}
impl IInkToolbarCustomPenButton {
    #[inline] pub unsafe fn get_custom_pen(&self) -> Result<ComPtr<InkToolbarCustomPen>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CustomPen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_custom_pen(&self, value: &InkToolbarCustomPen) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CustomPen)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_configuration_content(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ConfigurationContent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_configuration_content(&self, value: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ConfigurationContent)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbarCustomPenButtonStatics, 926688756, 58709, 20101, 168, 13, 218, 107, 132, 51, 219, 222);
RT_INTERFACE!{static interface IInkToolbarCustomPenButtonStatics(IInkToolbarCustomPenButtonStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarCustomPenButtonStatics] {
    fn get_CustomPenProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ConfigurationContentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IInkToolbarCustomPenButtonStatics {
    #[inline] pub unsafe fn get_custom_pen_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CustomPenProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_configuration_content_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ConfigurationContentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInkToolbarCustomPenButtonFactory, 254734522, 51385, 19510, 137, 135, 148, 211, 218, 254, 222, 24);
RT_INTERFACE!{interface IInkToolbarCustomPenButtonFactory(IInkToolbarCustomPenButtonFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarCustomPenButtonFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut InkToolbarCustomPenButton) -> HRESULT
}}
impl IInkToolbarCustomPenButtonFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<InkToolbarCustomPenButton>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class InkToolbarCustomPenButton: IInkToolbarCustomPenButton}
impl RtActivatable<IInkToolbarCustomPenButtonStatics> for InkToolbarCustomPenButton {}
impl InkToolbarCustomPenButton {
    #[inline] pub fn get_custom_pen_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarCustomPenButtonStatics>>::get_activation_factory().get_custom_pen_property()
    }}
    #[inline] pub fn get_configuration_content_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IInkToolbarCustomPenButtonStatics>>::get_activation_factory().get_configuration_content_property()
    }}
}
DEFINE_CLSID!(InkToolbarCustomPenButton(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,73,110,107,84,111,111,108,98,97,114,67,117,115,116,111,109,80,101,110,66,117,116,116,111,110,0]) [CLSID_InkToolbarCustomPenButton]);
DEFINE_IID!(IID_IInkToolbarHighlighterButton, 188531035, 31423, 18558, 172, 193, 91, 80, 72, 254, 230, 210);
RT_INTERFACE!{interface IInkToolbarHighlighterButton(IInkToolbarHighlighterButtonVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarHighlighterButton] {
    
}}
DEFINE_IID!(IID_IInkToolbarHighlighterButtonFactory, 2083736285, 17098, 18755, 148, 164, 35, 181, 166, 229, 92, 241);
RT_INTERFACE!{interface IInkToolbarHighlighterButtonFactory(IInkToolbarHighlighterButtonFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarHighlighterButtonFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut InkToolbarHighlighterButton) -> HRESULT
}}
impl IInkToolbarHighlighterButtonFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<InkToolbarHighlighterButton>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class InkToolbarHighlighterButton: IInkToolbarHighlighterButton}
DEFINE_IID!(IID_IInkToolbarPencilButton, 1527851058, 6532, 16712, 159, 37, 56, 43, 53, 219, 8, 127);
RT_INTERFACE!{interface IInkToolbarPencilButton(IInkToolbarPencilButtonVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarPencilButton] {
    
}}
DEFINE_IID!(IID_IInkToolbarPencilButtonFactory, 3680950367, 53206, 18783, 147, 171, 184, 86, 106, 249, 248, 175);
RT_INTERFACE!{interface IInkToolbarPencilButtonFactory(IInkToolbarPencilButtonFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarPencilButtonFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut InkToolbarPencilButton) -> HRESULT
}}
impl IInkToolbarPencilButtonFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<InkToolbarPencilButton>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class InkToolbarPencilButton: IInkToolbarPencilButton}
RT_ENUM! { enum ListPickerFlyoutSelectionMode: i32 {
    Single (ListPickerFlyoutSelectionMode_Single) = 0, Multiple (ListPickerFlyoutSelectionMode_Multiple) = 1,
}}
RT_ENUM! { enum PivotHeaderFocusVisualPlacement: i32 {
    ItemHeaders (PivotHeaderFocusVisualPlacement_ItemHeaders) = 0, SelectedItemHeader (PivotHeaderFocusVisualPlacement_SelectedItemHeader) = 1,
}}
RT_ENUM! { enum PivotSlideInAnimationGroup: i32 {
    Default (PivotSlideInAnimationGroup_Default) = 0, GroupOne (PivotSlideInAnimationGroup_GroupOne) = 1, GroupTwo (PivotSlideInAnimationGroup_GroupTwo) = 2, GroupThree (PivotSlideInAnimationGroup_GroupThree) = 3,
}}
DEFINE_IID!(IID_IPivotItemEventArgs, 443511380, 7893, 19397, 160, 96, 101, 85, 48, 188, 166, 186);
RT_INTERFACE!{interface IPivotItemEventArgs(IPivotItemEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPivotItemEventArgs] {
    fn get_Item(&self, out: *mut *mut PivotItem) -> HRESULT,
    fn put_Item(&self, value: *mut PivotItem) -> HRESULT
}}
impl IPivotItemEventArgs {
    #[inline] pub unsafe fn get_item(&self) -> Result<ComPtr<PivotItem>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Item)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_item(&self, value: &PivotItem) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Item)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class PivotItemEventArgs: IPivotItemEventArgs}
impl RtActivatable<IActivationFactory> for PivotItemEventArgs {}
DEFINE_CLSID!(PivotItemEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,105,118,111,116,73,116,101,109,69,118,101,110,116,65,114,103,115,0]) [CLSID_PivotItemEventArgs]);
DEFINE_IID!(IID_IDatePickedEventArgs, 2706537234, 22977, 17697, 178, 140, 177, 118, 103, 94, 124, 90);
RT_INTERFACE!{interface IDatePickedEventArgs(IDatePickedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDatePickedEventArgs] {
    fn get_OldDate(&self, out: *mut ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn get_NewDate(&self, out: *mut ::rt::gen::windows::foundation::DateTime) -> HRESULT
}}
impl IDatePickedEventArgs {
    #[inline] pub unsafe fn get_old_date(&self) -> Result<::rt::gen::windows::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OldDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_new_date(&self) -> Result<::rt::gen::windows::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NewDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class DatePickedEventArgs: IDatePickedEventArgs}
impl RtActivatable<IActivationFactory> for DatePickedEventArgs {}
DEFINE_CLSID!(DatePickedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,68,97,116,101,80,105,99,107,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_DatePickedEventArgs]);
DEFINE_IID!(IID_IDatePickerFlyoutItem, 2644230793, 210, 19116, 156, 133, 215, 79, 6, 54, 120, 135);
RT_INTERFACE!{interface IDatePickerFlyoutItem(IDatePickerFlyoutItemVtbl): IInspectable(IInspectableVtbl) [IID_IDatePickerFlyoutItem] {
    fn get_PrimaryText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PrimaryText(&self, value: HSTRING) -> HRESULT,
    fn get_SecondaryText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SecondaryText(&self, value: HSTRING) -> HRESULT
}}
impl IDatePickerFlyoutItem {
    #[inline] pub unsafe fn get_primary_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PrimaryText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_primary_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PrimaryText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_secondary_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SecondaryText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_secondary_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SecondaryText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDatePickerFlyoutItemStatics, 2862387674, 2038, 19679, 137, 180, 221, 163, 189, 176, 234, 107);
RT_INTERFACE!{static interface IDatePickerFlyoutItemStatics(IDatePickerFlyoutItemStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDatePickerFlyoutItemStatics] {
    fn get_PrimaryTextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SecondaryTextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IDatePickerFlyoutItemStatics {
    #[inline] pub unsafe fn get_primary_text_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PrimaryTextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_secondary_text_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SecondaryTextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class DatePickerFlyoutItem: IDatePickerFlyoutItem}
impl RtActivatable<IDatePickerFlyoutItemStatics> for DatePickerFlyoutItem {}
impl DatePickerFlyoutItem {
    #[inline] pub fn get_primary_text_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerFlyoutItemStatics>>::get_activation_factory().get_primary_text_property()
    }}
    #[inline] pub fn get_secondary_text_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerFlyoutItemStatics>>::get_activation_factory().get_secondary_text_property()
    }}
}
DEFINE_CLSID!(DatePickerFlyoutItem(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,68,97,116,101,80,105,99,107,101,114,70,108,121,111,117,116,73,116,101,109,0]) [CLSID_DatePickerFlyoutItem]);
DEFINE_IID!(IID_IItemsPickedEventArgs, 4183530156, 42529, 18574, 145, 86, 142, 227, 17, 101, 190, 4);
RT_INTERFACE!{interface IItemsPickedEventArgs(IItemsPickedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IItemsPickedEventArgs] {
    fn get_AddedItems(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<IInspectable>) -> HRESULT,
    fn get_RemovedItems(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<IInspectable>) -> HRESULT
}}
impl IItemsPickedEventArgs {
    #[inline] pub unsafe fn get_added_items(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<IInspectable>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AddedItems)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_removed_items(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<IInspectable>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RemovedItems)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ItemsPickedEventArgs: IItemsPickedEventArgs}
impl RtActivatable<IActivationFactory> for ItemsPickedEventArgs {}
DEFINE_CLSID!(ItemsPickedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,73,116,101,109,115,80,105,99,107,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_ItemsPickedEventArgs]);
DEFINE_IID!(IID_IPickerConfirmedEventArgs, 1148885841, 7715, 18297, 153, 43, 152, 104, 73, 113, 57, 65);
RT_INTERFACE!{interface IPickerConfirmedEventArgs(IPickerConfirmedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPickerConfirmedEventArgs] {
    
}}
RT_CLASS!{class PickerConfirmedEventArgs: IPickerConfirmedEventArgs}
impl RtActivatable<IActivationFactory> for PickerConfirmedEventArgs {}
DEFINE_CLSID!(PickerConfirmedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,105,99,107,101,114,67,111,110,102,105,114,109,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_PickerConfirmedEventArgs]);
DEFINE_IID!(IID_ITimePickedEventArgs, 2329149217, 24422, 18309, 185, 153, 36, 254, 243, 159, 182, 219);
RT_INTERFACE!{interface ITimePickedEventArgs(ITimePickedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ITimePickedEventArgs] {
    fn get_OldTime(&self, out: *mut ::rt::gen::windows::foundation::TimeSpan) -> HRESULT,
    fn get_NewTime(&self, out: *mut ::rt::gen::windows::foundation::TimeSpan) -> HRESULT
}}
impl ITimePickedEventArgs {
    #[inline] pub unsafe fn get_old_time(&self) -> Result<::rt::gen::windows::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OldTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_new_time(&self) -> Result<::rt::gen::windows::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NewTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class TimePickedEventArgs: ITimePickedEventArgs}
impl RtActivatable<IActivationFactory> for TimePickedEventArgs {}
DEFINE_CLSID!(TimePickedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,84,105,109,101,80,105,99,107,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_TimePickedEventArgs]);
DEFINE_IID!(IID_IDatePickerFlyout, 4227021594, 41892, 19960, 146, 40, 35, 165, 172, 39, 223, 78);
RT_INTERFACE!{interface IDatePickerFlyout(IDatePickerFlyoutVtbl): IInspectable(IInspectableVtbl) [IID_IDatePickerFlyout] {
    fn get_CalendarIdentifier(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CalendarIdentifier(&self, value: HSTRING) -> HRESULT,
    fn get_Date(&self, out: *mut ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn put_Date(&self, value: ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn get_DayVisible(&self, out: *mut bool) -> HRESULT,
    fn put_DayVisible(&self, value: bool) -> HRESULT,
    fn get_MonthVisible(&self, out: *mut bool) -> HRESULT,
    fn put_MonthVisible(&self, value: bool) -> HRESULT,
    fn get_YearVisible(&self, out: *mut bool) -> HRESULT,
    fn put_YearVisible(&self, value: bool) -> HRESULT,
    fn get_MinYear(&self, out: *mut ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn put_MinYear(&self, value: ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn get_MaxYear(&self, out: *mut ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn put_MaxYear(&self, value: ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn add_DatePicked(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<DatePickerFlyout, DatePickedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DatePicked(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn ShowAtAsync(&self, target: *mut super::FrameworkElement, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::DateTime>>) -> HRESULT
}}
impl IDatePickerFlyout {
    #[inline] pub unsafe fn get_calendar_identifier(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalendarIdentifier)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_calendar_identifier(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CalendarIdentifier)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_date(&self) -> Result<::rt::gen::windows::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Date)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_date(&self, value: ::rt::gen::windows::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Date)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_day_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DayVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_day_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DayVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_month_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MonthVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_month_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MonthVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_year_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_YearVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_year_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_YearVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_year(&self) -> Result<::rt::gen::windows::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinYear)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_min_year(&self, value: ::rt::gen::windows::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MinYear)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_year(&self) -> Result<::rt::gen::windows::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxYear)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_year(&self, value: ::rt::gen::windows::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxYear)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_date_picked(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<DatePickerFlyout, DatePickedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DatePicked)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_date_picked(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DatePicked)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_at_async(&self, target: &super::FrameworkElement) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::DateTime>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAtAsync)(self as *const _ as *mut _, target as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDatePickerFlyoutStatics, 3445031799, 22597, 19474, 140, 16, 89, 45, 159, 204, 124, 217);
RT_INTERFACE!{static interface IDatePickerFlyoutStatics(IDatePickerFlyoutStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDatePickerFlyoutStatics] {
    fn get_CalendarIdentifierProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DayVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MonthVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_YearVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MinYearProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MaxYearProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IDatePickerFlyoutStatics {
    #[inline] pub unsafe fn get_calendar_identifier_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalendarIdentifierProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_date_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_day_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DayVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_month_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MonthVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_year_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_YearVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_year_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MinYearProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_year_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxYearProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDatePickerFlyout2, 3484519867, 39217, 16665, 139, 218, 84, 168, 111, 223, 172, 132);
RT_INTERFACE!{interface IDatePickerFlyout2(IDatePickerFlyout2Vtbl): IInspectable(IInspectableVtbl) [IID_IDatePickerFlyout2] {
    fn get_DayFormat(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DayFormat(&self, value: HSTRING) -> HRESULT,
    fn get_MonthFormat(&self, out: *mut HSTRING) -> HRESULT,
    fn put_MonthFormat(&self, value: HSTRING) -> HRESULT,
    fn get_YearFormat(&self, out: *mut HSTRING) -> HRESULT,
    fn put_YearFormat(&self, value: HSTRING) -> HRESULT
}}
impl IDatePickerFlyout2 {
    #[inline] pub unsafe fn get_day_format(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DayFormat)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_day_format(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DayFormat)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_month_format(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MonthFormat)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_month_format(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MonthFormat)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_year_format(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_YearFormat)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_year_format(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_YearFormat)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDatePickerFlyoutStatics2, 2949899625, 33254, 19284, 132, 169, 104, 7, 155, 115, 227, 78);
RT_INTERFACE!{static interface IDatePickerFlyoutStatics2(IDatePickerFlyoutStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IDatePickerFlyoutStatics2] {
    fn get_DayFormatProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MonthFormatProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_YearFormatProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IDatePickerFlyoutStatics2 {
    #[inline] pub unsafe fn get_day_format_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DayFormatProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_month_format_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MonthFormatProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_year_format_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_YearFormatProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListPickerFlyout, 252492247, 58867, 17894, 144, 99, 255, 123, 187, 25, 60, 71);
RT_INTERFACE!{interface IListPickerFlyout(IListPickerFlyoutVtbl): IInspectable(IInspectableVtbl) [IID_IListPickerFlyout] {
    fn get_ItemsSource(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_ItemsSource(&self, value: *mut IInspectable) -> HRESULT,
    fn get_ItemTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_ItemTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_DisplayMemberPath(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayMemberPath(&self, value: HSTRING) -> HRESULT,
    fn get_SelectionMode(&self, out: *mut ListPickerFlyoutSelectionMode) -> HRESULT,
    fn put_SelectionMode(&self, value: ListPickerFlyoutSelectionMode) -> HRESULT,
    fn get_SelectedIndex(&self, out: *mut i32) -> HRESULT,
    fn put_SelectedIndex(&self, value: i32) -> HRESULT,
    fn get_SelectedItem(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_SelectedItem(&self, value: *mut IInspectable) -> HRESULT,
    fn get_SelectedValue(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_SelectedValue(&self, value: *mut IInspectable) -> HRESULT,
    fn get_SelectedValuePath(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SelectedValuePath(&self, value: HSTRING) -> HRESULT,
    fn get_SelectedItems(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<IInspectable>) -> HRESULT,
    fn add_ItemsPicked(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<ListPickerFlyout, ItemsPickedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ItemsPicked(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn ShowAtAsync(&self, target: *mut super::FrameworkElement, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<IInspectable>>) -> HRESULT
}}
impl IListPickerFlyout {
    #[inline] pub unsafe fn get_items_source(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemsSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_items_source(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemsSource)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_item_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_member_path(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayMemberPath)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_member_path(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayMemberPath)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_mode(&self) -> Result<ListPickerFlyoutSelectionMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SelectionMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selection_mode(&self, value: ListPickerFlyoutSelectionMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectionMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SelectedIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_index(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedIndex)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_item(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedItem)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_item(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedItem)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_value(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_value(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedValue)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_value_path(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedValuePath)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_value_path(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedValuePath)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_items(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<IInspectable>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedItems)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_items_picked(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<ListPickerFlyout, ItemsPickedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ItemsPicked)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_items_picked(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ItemsPicked)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_at_async(&self, target: &super::FrameworkElement) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<IInspectable>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAtAsync)(self as *const _ as *mut _, target as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListPickerFlyoutStatics, 4276247447, 35734, 17922, 129, 210, 130, 253, 142, 15, 126, 168);
RT_INTERFACE!{static interface IListPickerFlyoutStatics(IListPickerFlyoutStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IListPickerFlyoutStatics] {
    fn get_ItemsSourceProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ItemTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_DisplayMemberPathProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectionModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectedIndexProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectedItemProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectedValueProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectedValuePathProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IListPickerFlyoutStatics {
    #[inline] pub unsafe fn get_items_source_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemsSourceProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_member_path_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayMemberPathProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_index_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedIndexProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_item_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedItemProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_value_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedValueProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_value_path_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedValuePathProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPickerFlyout, 2738290651, 2265, 17382, 148, 78, 242, 229, 199, 206, 230, 48);
RT_INTERFACE!{interface IPickerFlyout(IPickerFlyoutVtbl): IInspectable(IInspectableVtbl) [IID_IPickerFlyout] {
    fn get_Content(&self, out: *mut *mut super::UIElement) -> HRESULT,
    fn put_Content(&self, value: *mut super::UIElement) -> HRESULT,
    fn get_ConfirmationButtonsVisible(&self, out: *mut bool) -> HRESULT,
    fn put_ConfirmationButtonsVisible(&self, value: bool) -> HRESULT,
    fn add_Confirmed(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<PickerFlyout, PickerConfirmedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Confirmed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn ShowAtAsync(&self, target: *mut super::FrameworkElement, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl IPickerFlyout {
    #[inline] pub unsafe fn get_content(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Content)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content(&self, value: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Content)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_confirmation_buttons_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ConfirmationButtonsVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_confirmation_buttons_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ConfirmationButtonsVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_confirmed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<PickerFlyout, PickerConfirmedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Confirmed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_confirmed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Confirmed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_at_async(&self, target: &super::FrameworkElement) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAtAsync)(self as *const _ as *mut _, target as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPickerFlyoutStatics, 2937627702, 62346, 19133, 185, 51, 98, 134, 193, 21, 176, 127);
RT_INTERFACE!{static interface IPickerFlyoutStatics(IPickerFlyoutStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPickerFlyoutStatics] {
    fn get_ContentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ConfirmationButtonsVisibleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IPickerFlyoutStatics {
    #[inline] pub unsafe fn get_content_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_confirmation_buttons_visible_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ConfirmationButtonsVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITimePickerFlyout, 3144916341, 59446, 17310, 134, 213, 80, 109, 45, 24, 228, 4);
RT_INTERFACE!{interface ITimePickerFlyout(ITimePickerFlyoutVtbl): IInspectable(IInspectableVtbl) [IID_ITimePickerFlyout] {
    fn get_ClockIdentifier(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ClockIdentifier(&self, value: HSTRING) -> HRESULT,
    fn get_Time(&self, out: *mut ::rt::gen::windows::foundation::TimeSpan) -> HRESULT,
    fn put_Time(&self, value: ::rt::gen::windows::foundation::TimeSpan) -> HRESULT,
    fn get_MinuteIncrement(&self, out: *mut i32) -> HRESULT,
    fn put_MinuteIncrement(&self, value: i32) -> HRESULT,
    fn add_TimePicked(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<TimePickerFlyout, TimePickedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TimePicked(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn ShowAtAsync(&self, target: *mut super::FrameworkElement, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::TimeSpan>>) -> HRESULT
}}
impl ITimePickerFlyout {
    #[inline] pub unsafe fn get_clock_identifier(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ClockIdentifier)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_clock_identifier(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ClockIdentifier)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_time(&self) -> Result<::rt::gen::windows::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Time)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_time(&self, value: ::rt::gen::windows::foundation::TimeSpan) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Time)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_minute_increment(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinuteIncrement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_minute_increment(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MinuteIncrement)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_time_picked(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<TimePickerFlyout, TimePickedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TimePicked)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_time_picked(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_TimePicked)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_at_async(&self, target: &super::FrameworkElement) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::TimeSpan>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAtAsync)(self as *const _ as *mut _, target as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITimePickerFlyoutStatics, 1063725262, 8553, 16387, 180, 168, 141, 231, 3, 90, 10, 214);
RT_INTERFACE!{static interface ITimePickerFlyoutStatics(ITimePickerFlyoutStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ITimePickerFlyoutStatics] {
    fn get_ClockIdentifierProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TimeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MinuteIncrementProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ITimePickerFlyoutStatics {
    #[inline] pub unsafe fn get_clock_identifier_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ClockIdentifierProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_time_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TimeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_minute_increment_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MinuteIncrementProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDatePickerFlyoutPresenter, 2086860558, 11740, 17281, 131, 47, 84, 203, 223, 170, 132, 154);
RT_INTERFACE!{interface IDatePickerFlyoutPresenter(IDatePickerFlyoutPresenterVtbl): IInspectable(IInspectableVtbl) [IID_IDatePickerFlyoutPresenter] {
    
}}
RT_CLASS!{class DatePickerFlyoutPresenter: IDatePickerFlyoutPresenter}
DEFINE_IID!(IID_IListPickerFlyoutPresenter, 1746231219, 34878, 16762, 128, 208, 226, 253, 136, 65, 0, 132);
RT_INTERFACE!{interface IListPickerFlyoutPresenter(IListPickerFlyoutPresenterVtbl): IInspectable(IInspectableVtbl) [IID_IListPickerFlyoutPresenter] {
    
}}
RT_CLASS!{class ListPickerFlyoutPresenter: IListPickerFlyoutPresenter}
DEFINE_IID!(IID_ITimePickerFlyoutPresenter, 3308389944, 31256, 16621, 159, 208, 76, 133, 44, 9, 178, 78);
RT_INTERFACE!{interface ITimePickerFlyoutPresenter(ITimePickerFlyoutPresenterVtbl): IInspectable(IInspectableVtbl) [IID_ITimePickerFlyoutPresenter] {
    
}}
RT_CLASS!{class TimePickerFlyoutPresenter: ITimePickerFlyoutPresenter}
DEFINE_IID!(IID_IPickerFlyoutPresenter, 1485097336, 27431, 19256, 169, 174, 103, 124, 41, 148, 101, 46);
RT_INTERFACE!{interface IPickerFlyoutPresenter(IPickerFlyoutPresenterVtbl): IInspectable(IInspectableVtbl) [IID_IPickerFlyoutPresenter] {
    
}}
RT_CLASS!{class PickerFlyoutPresenter: IPickerFlyoutPresenter}
DEFINE_IID!(IID_IPivot, 272538387, 13312, 18966, 144, 185, 105, 18, 191, 6, 151, 78);
RT_INTERFACE!{interface IPivot(IPivotVtbl): IInspectable(IInspectableVtbl) [IID_IPivot] {
    fn get_Title(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Title(&self, value: *mut IInspectable) -> HRESULT,
    fn get_TitleTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_TitleTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_HeaderTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_HeaderTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_SelectedIndex(&self, out: *mut i32) -> HRESULT,
    fn put_SelectedIndex(&self, value: i32) -> HRESULT,
    fn get_SelectedItem(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_SelectedItem(&self, value: *mut IInspectable) -> HRESULT,
    fn get_IsLocked(&self, out: *mut bool) -> HRESULT,
    fn put_IsLocked(&self, value: bool) -> HRESULT,
    fn add_SelectionChanged(&self, value: *mut SelectionChangedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SelectionChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PivotItemLoading(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<Pivot, PivotItemEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PivotItemLoading(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PivotItemLoaded(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<Pivot, PivotItemEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PivotItemLoaded(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PivotItemUnloading(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<Pivot, PivotItemEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PivotItemUnloading(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PivotItemUnloaded(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<Pivot, PivotItemEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PivotItemUnloaded(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IPivot {
    #[inline] pub unsafe fn get_title(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Title)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_title(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Title)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_title_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TitleTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_title_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TitleTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SelectedIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_index(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedIndex)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_item(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedItem)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_item(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedItem)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_locked(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsLocked)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_locked(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsLocked)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_selection_changed(&self, value: &SelectionChangedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SelectionChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_selection_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SelectionChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_pivot_item_loading(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<Pivot, PivotItemEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PivotItemLoading)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_pivot_item_loading(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PivotItemLoading)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_pivot_item_loaded(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<Pivot, PivotItemEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PivotItemLoaded)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_pivot_item_loaded(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PivotItemLoaded)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_pivot_item_unloading(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<Pivot, PivotItemEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PivotItemUnloading)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_pivot_item_unloading(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PivotItemUnloading)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_pivot_item_unloaded(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<Pivot, PivotItemEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PivotItemUnloaded)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_pivot_item_unloaded(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PivotItemUnloaded)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPivotStatics, 3995256820, 49501, 20467, 138, 148, 245, 13, 253, 251, 232, 153);
RT_INTERFACE!{static interface IPivotStatics(IPivotStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPivotStatics] {
    fn get_TitleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TitleTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_HeaderTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectedIndexProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SelectedItemProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsLockedProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SlideInAnimationGroupProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetSlideInAnimationGroup(&self, element: *mut super::FrameworkElement, out: *mut PivotSlideInAnimationGroup) -> HRESULT,
    fn SetSlideInAnimationGroup(&self, element: *mut super::FrameworkElement, value: PivotSlideInAnimationGroup) -> HRESULT
}}
impl IPivotStatics {
    #[inline] pub unsafe fn get_title_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TitleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_title_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TitleTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_index_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedIndexProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_item_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedItemProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_locked_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsLockedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_slide_in_animation_group_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SlideInAnimationGroupProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_slide_in_animation_group(&self, element: &super::FrameworkElement) -> Result<PivotSlideInAnimationGroup> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetSlideInAnimationGroup)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_slide_in_animation_group(&self, element: &super::FrameworkElement, value: PivotSlideInAnimationGroup) -> Result<()> {
        let hr = ((*self.lpVtbl).SetSlideInAnimationGroup)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPivotFactory, 453673358, 9513, 18274, 186, 68, 154, 188, 104, 195, 206, 202);
RT_INTERFACE!{interface IPivotFactory(IPivotFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPivotFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut Pivot) -> HRESULT
}}
impl IPivotFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<Pivot>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPivot2, 2341111392, 6741, 16668, 168, 45, 24, 153, 28, 63, 13, 111);
RT_INTERFACE!{interface IPivot2(IPivot2Vtbl): IInspectable(IInspectableVtbl) [IID_IPivot2] {
    fn get_LeftHeader(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_LeftHeader(&self, value: *mut IInspectable) -> HRESULT,
    fn get_LeftHeaderTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_LeftHeaderTemplate(&self, value: *mut super::DataTemplate) -> HRESULT,
    fn get_RightHeader(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_RightHeader(&self, value: *mut IInspectable) -> HRESULT,
    fn get_RightHeaderTemplate(&self, out: *mut *mut super::DataTemplate) -> HRESULT,
    fn put_RightHeaderTemplate(&self, value: *mut super::DataTemplate) -> HRESULT
}}
impl IPivot2 {
    #[inline] pub unsafe fn get_left_header(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LeftHeader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_left_header(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LeftHeader)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_left_header_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LeftHeaderTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_left_header_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LeftHeaderTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_right_header(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RightHeader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_right_header(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RightHeader)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_right_header_template(&self) -> Result<ComPtr<super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RightHeaderTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_right_header_template(&self, value: &super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RightHeaderTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPivotStatics2, 3612445405, 48757, 16419, 141, 235, 198, 81, 60, 49, 146, 163);
RT_INTERFACE!{static interface IPivotStatics2(IPivotStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IPivotStatics2] {
    fn get_LeftHeaderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_LeftHeaderTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_RightHeaderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_RightHeaderTemplateProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IPivotStatics2 {
    #[inline] pub unsafe fn get_left_header_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LeftHeaderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_left_header_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LeftHeaderTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_right_header_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RightHeaderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_right_header_template_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RightHeaderTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPivot3, 2512174998, 61658, 16521, 140, 101, 232, 184, 19, 84, 199, 102);
RT_INTERFACE!{interface IPivot3(IPivot3Vtbl): IInspectable(IInspectableVtbl) [IID_IPivot3] {
    fn get_HeaderFocusVisualPlacement(&self, out: *mut PivotHeaderFocusVisualPlacement) -> HRESULT,
    fn put_HeaderFocusVisualPlacement(&self, value: PivotHeaderFocusVisualPlacement) -> HRESULT,
    fn get_IsHeaderItemsCarouselEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsHeaderItemsCarouselEnabled(&self, value: bool) -> HRESULT
}}
impl IPivot3 {
    #[inline] pub unsafe fn get_header_focus_visual_placement(&self) -> Result<PivotHeaderFocusVisualPlacement> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HeaderFocusVisualPlacement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_focus_visual_placement(&self, value: PivotHeaderFocusVisualPlacement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderFocusVisualPlacement)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_header_items_carousel_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsHeaderItemsCarouselEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_header_items_carousel_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsHeaderItemsCarouselEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class Pivot: IPivot}
impl RtActivatable<IPivotStatics3> for Pivot {}
impl RtActivatable<IPivotStatics> for Pivot {}
impl RtActivatable<IPivotStatics2> for Pivot {}
impl Pivot {
    #[inline] pub fn get_header_focus_visual_placement_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPivotStatics3>>::get_activation_factory().get_header_focus_visual_placement_property()
    }}
    #[inline] pub fn get_is_header_items_carousel_enabled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPivotStatics3>>::get_activation_factory().get_is_header_items_carousel_enabled_property()
    }}
    #[inline] pub fn get_title_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPivotStatics>>::get_activation_factory().get_title_property()
    }}
    #[inline] pub fn get_title_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPivotStatics>>::get_activation_factory().get_title_template_property()
    }}
    #[inline] pub fn get_header_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPivotStatics>>::get_activation_factory().get_header_template_property()
    }}
    #[inline] pub fn get_selected_index_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPivotStatics>>::get_activation_factory().get_selected_index_property()
    }}
    #[inline] pub fn get_selected_item_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPivotStatics>>::get_activation_factory().get_selected_item_property()
    }}
    #[inline] pub fn get_is_locked_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPivotStatics>>::get_activation_factory().get_is_locked_property()
    }}
    #[inline] pub fn get_slide_in_animation_group_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPivotStatics>>::get_activation_factory().get_slide_in_animation_group_property()
    }}
    #[inline] pub fn get_slide_in_animation_group(element: &super::FrameworkElement) -> Result<PivotSlideInAnimationGroup> { unsafe {
        <Self as RtActivatable<IPivotStatics>>::get_activation_factory().get_slide_in_animation_group(element)
    }}
    #[inline] pub fn set_slide_in_animation_group(element: &super::FrameworkElement, value: PivotSlideInAnimationGroup) -> Result<()> { unsafe {
        <Self as RtActivatable<IPivotStatics>>::get_activation_factory().set_slide_in_animation_group(element, value)
    }}
    #[inline] pub fn get_left_header_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPivotStatics2>>::get_activation_factory().get_left_header_property()
    }}
    #[inline] pub fn get_left_header_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPivotStatics2>>::get_activation_factory().get_left_header_template_property()
    }}
    #[inline] pub fn get_right_header_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPivotStatics2>>::get_activation_factory().get_right_header_property()
    }}
    #[inline] pub fn get_right_header_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPivotStatics2>>::get_activation_factory().get_right_header_template_property()
    }}
}
DEFINE_CLSID!(Pivot(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,105,118,111,116,0]) [CLSID_Pivot]);
DEFINE_IID!(IID_IPivotStatics3, 2025203534, 26134, 17920, 160, 57, 146, 42, 93, 9, 51, 11);
RT_INTERFACE!{static interface IPivotStatics3(IPivotStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IPivotStatics3] {
    fn get_HeaderFocusVisualPlacementProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsHeaderItemsCarouselEnabledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IPivotStatics3 {
    #[inline] pub unsafe fn get_header_focus_visual_placement_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderFocusVisualPlacementProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_header_items_carousel_enabled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsHeaderItemsCarouselEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPivotItem, 2759213937, 42242, 18339, 145, 94, 74, 160, 150, 218, 248, 127);
RT_INTERFACE!{interface IPivotItem(IPivotItemVtbl): IInspectable(IInspectableVtbl) [IID_IPivotItem] {
    fn get_Header(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Header(&self, value: *mut IInspectable) -> HRESULT
}}
impl IPivotItem {
    #[inline] pub unsafe fn get_header(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Header)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Header)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class PivotItem: IPivotItem}
impl RtActivatable<IPivotItemStatics> for PivotItem {}
impl PivotItem {
    #[inline] pub fn get_header_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPivotItemStatics>>::get_activation_factory().get_header_property()
    }}
}
DEFINE_CLSID!(PivotItem(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,105,118,111,116,73,116,101,109,0]) [CLSID_PivotItem]);
DEFINE_IID!(IID_IPivotItemStatics, 3779570956, 18571, 19054, 190, 205, 165, 219, 217, 148, 23, 84);
RT_INTERFACE!{static interface IPivotItemStatics(IPivotItemStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPivotItemStatics] {
    fn get_HeaderProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IPivotItemStatics {
    #[inline] pub unsafe fn get_header_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPivotItemFactory, 231659905, 25454, 18996, 138, 63, 142, 224, 24, 99, 146, 133);
RT_INTERFACE!{interface IPivotItemFactory(IPivotItemFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPivotItemFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut PivotItem) -> HRESULT
}}
impl IPivotItemFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<PivotItem>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class DatePickerFlyout: IDatePickerFlyout}
impl RtActivatable<IDatePickerFlyoutStatics2> for DatePickerFlyout {}
impl RtActivatable<IDatePickerFlyoutStatics> for DatePickerFlyout {}
impl RtActivatable<IActivationFactory> for DatePickerFlyout {}
impl DatePickerFlyout {
    #[inline] pub fn get_day_format_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerFlyoutStatics2>>::get_activation_factory().get_day_format_property()
    }}
    #[inline] pub fn get_month_format_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerFlyoutStatics2>>::get_activation_factory().get_month_format_property()
    }}
    #[inline] pub fn get_year_format_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerFlyoutStatics2>>::get_activation_factory().get_year_format_property()
    }}
    #[inline] pub fn get_calendar_identifier_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerFlyoutStatics>>::get_activation_factory().get_calendar_identifier_property()
    }}
    #[inline] pub fn get_date_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerFlyoutStatics>>::get_activation_factory().get_date_property()
    }}
    #[inline] pub fn get_day_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerFlyoutStatics>>::get_activation_factory().get_day_visible_property()
    }}
    #[inline] pub fn get_month_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerFlyoutStatics>>::get_activation_factory().get_month_visible_property()
    }}
    #[inline] pub fn get_year_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerFlyoutStatics>>::get_activation_factory().get_year_visible_property()
    }}
    #[inline] pub fn get_min_year_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerFlyoutStatics>>::get_activation_factory().get_min_year_property()
    }}
    #[inline] pub fn get_max_year_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDatePickerFlyoutStatics>>::get_activation_factory().get_max_year_property()
    }}
}
DEFINE_CLSID!(DatePickerFlyout(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,68,97,116,101,80,105,99,107,101,114,70,108,121,111,117,116,0]) [CLSID_DatePickerFlyout]);
RT_CLASS!{class ListPickerFlyout: IListPickerFlyout}
impl RtActivatable<IListPickerFlyoutStatics> for ListPickerFlyout {}
impl RtActivatable<IActivationFactory> for ListPickerFlyout {}
impl ListPickerFlyout {
    #[inline] pub fn get_items_source_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListPickerFlyoutStatics>>::get_activation_factory().get_items_source_property()
    }}
    #[inline] pub fn get_item_template_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListPickerFlyoutStatics>>::get_activation_factory().get_item_template_property()
    }}
    #[inline] pub fn get_display_member_path_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListPickerFlyoutStatics>>::get_activation_factory().get_display_member_path_property()
    }}
    #[inline] pub fn get_selection_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListPickerFlyoutStatics>>::get_activation_factory().get_selection_mode_property()
    }}
    #[inline] pub fn get_selected_index_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListPickerFlyoutStatics>>::get_activation_factory().get_selected_index_property()
    }}
    #[inline] pub fn get_selected_item_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListPickerFlyoutStatics>>::get_activation_factory().get_selected_item_property()
    }}
    #[inline] pub fn get_selected_value_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListPickerFlyoutStatics>>::get_activation_factory().get_selected_value_property()
    }}
    #[inline] pub fn get_selected_value_path_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListPickerFlyoutStatics>>::get_activation_factory().get_selected_value_path_property()
    }}
}
DEFINE_CLSID!(ListPickerFlyout(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,76,105,115,116,80,105,99,107,101,114,70,108,121,111,117,116,0]) [CLSID_ListPickerFlyout]);
RT_CLASS!{class PickerFlyout: IPickerFlyout}
impl RtActivatable<IPickerFlyoutStatics> for PickerFlyout {}
impl RtActivatable<IActivationFactory> for PickerFlyout {}
impl PickerFlyout {
    #[inline] pub fn get_content_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPickerFlyoutStatics>>::get_activation_factory().get_content_property()
    }}
    #[inline] pub fn get_confirmation_buttons_visible_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPickerFlyoutStatics>>::get_activation_factory().get_confirmation_buttons_visible_property()
    }}
}
DEFINE_CLSID!(PickerFlyout(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,105,99,107,101,114,70,108,121,111,117,116,0]) [CLSID_PickerFlyout]);
RT_CLASS!{class TimePickerFlyout: ITimePickerFlyout}
impl RtActivatable<ITimePickerFlyoutStatics> for TimePickerFlyout {}
impl RtActivatable<IActivationFactory> for TimePickerFlyout {}
impl TimePickerFlyout {
    #[inline] pub fn get_clock_identifier_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITimePickerFlyoutStatics>>::get_activation_factory().get_clock_identifier_property()
    }}
    #[inline] pub fn get_time_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITimePickerFlyoutStatics>>::get_activation_factory().get_time_property()
    }}
    #[inline] pub fn get_minute_increment_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITimePickerFlyoutStatics>>::get_activation_factory().get_minute_increment_property()
    }}
}
DEFINE_CLSID!(TimePickerFlyout(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,84,105,109,101,80,105,99,107,101,114,70,108,121,111,117,116,0]) [CLSID_TimePickerFlyout]);
pub mod primitives { // Windows.UI.Xaml.Controls.Primitives
use ::prelude::*;
RT_ENUM! { enum GeneratorDirection: i32 {
    Forward (GeneratorDirection_Forward) = 0, Backward (GeneratorDirection_Backward) = 1,
}}
RT_ENUM! { enum GroupHeaderPlacement: i32 {
    Top (GroupHeaderPlacement_Top) = 0, Left (GroupHeaderPlacement_Left) = 1,
}}
RT_ENUM! { enum PlacementMode: i32 {
    Bottom (PlacementMode_Bottom) = 2, Left (PlacementMode_Left) = 9, Mouse (PlacementMode_Mouse) = 7, Right (PlacementMode_Right) = 4, Top (PlacementMode_Top) = 10,
}}
RT_ENUM! { enum ScrollEventType: i32 {
    SmallDecrement (ScrollEventType_SmallDecrement) = 0, SmallIncrement (ScrollEventType_SmallIncrement) = 1, LargeDecrement (ScrollEventType_LargeDecrement) = 2, LargeIncrement (ScrollEventType_LargeIncrement) = 3, ThumbPosition (ScrollEventType_ThumbPosition) = 4, ThumbTrack (ScrollEventType_ThumbTrack) = 5, First (ScrollEventType_First) = 6, Last (ScrollEventType_Last) = 7, EndScroll (ScrollEventType_EndScroll) = 8,
}}
RT_ENUM! { enum ScrollingIndicatorMode: i32 {
    None (ScrollingIndicatorMode_None) = 0, TouchIndicator (ScrollingIndicatorMode_TouchIndicator) = 1, MouseIndicator (ScrollingIndicatorMode_MouseIndicator) = 2,
}}
RT_ENUM! { enum SliderSnapsTo: i32 {
    StepValues (SliderSnapsTo_StepValues) = 0, Ticks (SliderSnapsTo_Ticks) = 1,
}}
RT_ENUM! { enum SnapPointsAlignment: i32 {
    Near (SnapPointsAlignment_Near) = 0, Center (SnapPointsAlignment_Center) = 1, Far (SnapPointsAlignment_Far) = 2,
}}
RT_ENUM! { enum TickPlacement: i32 {
    None (TickPlacement_None) = 0, TopLeft (TickPlacement_TopLeft) = 1, BottomRight (TickPlacement_BottomRight) = 2, Outside (TickPlacement_Outside) = 3, Inline (TickPlacement_Inline) = 4,
}}
DEFINE_IID!(IID_DragCompletedEventHandler, 917670024, 6572, 19278, 145, 55, 166, 207, 43, 2, 56, 131);
RT_DELEGATE!{delegate DragCompletedEventHandler(DragCompletedEventHandlerVtbl, DragCompletedEventHandlerImpl) [IID_DragCompletedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut DragCompletedEventArgs) -> HRESULT
}}
impl DragCompletedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &DragCompletedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_DragDeltaEventHandler, 1254248351, 44072, 18921, 145, 137, 220, 207, 254, 182, 100, 114);
RT_DELEGATE!{delegate DragDeltaEventHandler(DragDeltaEventHandlerVtbl, DragDeltaEventHandlerImpl) [IID_DragDeltaEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut DragDeltaEventArgs) -> HRESULT
}}
impl DragDeltaEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &DragDeltaEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_DragStartedEventHandler, 3538855050, 50778, 18781, 162, 241, 114, 198, 105, 137, 20, 45);
RT_DELEGATE!{delegate DragStartedEventHandler(DragStartedEventHandlerVtbl, DragStartedEventHandlerImpl) [IID_DragStartedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut DragStartedEventArgs) -> HRESULT
}}
impl DragStartedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &DragStartedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ItemsChangedEventHandler, 394418110, 41732, 18479, 139, 240, 185, 210, 227, 150, 18, 163);
RT_DELEGATE!{delegate ItemsChangedEventHandler(ItemsChangedEventHandlerVtbl, ItemsChangedEventHandlerImpl) [IID_ItemsChangedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut ItemsChangedEventArgs) -> HRESULT
}}
impl ItemsChangedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &ItemsChangedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ItemsChangedEventArgs: IItemsChangedEventArgs}
DEFINE_IID!(IID_RangeBaseValueChangedEventHandler, 3817893849, 19739, 19144, 164, 60, 195, 185, 8, 116, 39, 153);
RT_DELEGATE!{delegate RangeBaseValueChangedEventHandler(RangeBaseValueChangedEventHandlerVtbl, RangeBaseValueChangedEventHandlerImpl) [IID_RangeBaseValueChangedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut RangeBaseValueChangedEventArgs) -> HRESULT
}}
impl RangeBaseValueChangedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &RangeBaseValueChangedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ScrollEventHandler, 2288038052, 41859, 19587, 179, 6, 161, 195, 157, 125, 184, 127);
RT_DELEGATE!{delegate ScrollEventHandler(ScrollEventHandlerVtbl, ScrollEventHandlerImpl) [IID_ScrollEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut ScrollEventArgs) -> HRESULT
}}
impl ScrollEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &ScrollEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IScrollSnapPointsInfo, 459084598, 58907, 19793, 190, 65, 253, 141, 220, 85, 197, 140);
RT_INTERFACE!{interface IScrollSnapPointsInfo(IScrollSnapPointsInfoVtbl): IInspectable(IInspectableVtbl) [IID_IScrollSnapPointsInfo] {
    fn get_AreHorizontalSnapPointsRegular(&self, out: *mut bool) -> HRESULT,
    fn get_AreVerticalSnapPointsRegular(&self, out: *mut bool) -> HRESULT,
    fn add_HorizontalSnapPointsChanged(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_HorizontalSnapPointsChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_VerticalSnapPointsChanged(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VerticalSnapPointsChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn GetIrregularSnapPoints(&self, orientation: super::Orientation, alignment: SnapPointsAlignment, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<f32>) -> HRESULT,
    fn GetRegularSnapPoints(&self, orientation: super::Orientation, alignment: SnapPointsAlignment, offset: *mut f32, out: *mut f32) -> HRESULT
}}
impl IScrollSnapPointsInfo {
    #[inline] pub unsafe fn get_are_horizontal_snap_points_regular(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AreHorizontalSnapPointsRegular)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_are_vertical_snap_points_regular(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AreVerticalSnapPointsRegular)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_horizontal_snap_points_changed(&self, value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_HorizontalSnapPointsChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_horizontal_snap_points_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_HorizontalSnapPointsChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_vertical_snap_points_changed(&self, value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_VerticalSnapPointsChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_vertical_snap_points_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_VerticalSnapPointsChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_irregular_snap_points(&self, orientation: super::Orientation, alignment: SnapPointsAlignment) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<f32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetIrregularSnapPoints)(self as *const _ as *mut _, orientation, alignment, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_regular_snap_points(&self, orientation: super::Orientation, alignment: SnapPointsAlignment) -> Result<(f32, f32)> {
        let mut offset = zeroed(); let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetRegularSnapPoints)(self as *const _ as *mut _, orientation, alignment, &mut offset, &mut out);
        if hr == S_OK { Ok((offset, out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemsChangedEventArgs, 3904132456, 32016, 16926, 190, 41, 129, 131, 154, 145, 222, 32);
RT_INTERFACE!{interface IItemsChangedEventArgs(IItemsChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IItemsChangedEventArgs] {
    fn get_Action(&self, out: *mut i32) -> HRESULT,
    fn get_Position(&self, out: *mut GeneratorPosition) -> HRESULT,
    fn get_OldPosition(&self, out: *mut GeneratorPosition) -> HRESULT,
    fn get_ItemCount(&self, out: *mut i32) -> HRESULT,
    fn get_ItemUICount(&self, out: *mut i32) -> HRESULT
}}
impl IItemsChangedEventArgs {
    #[inline] pub unsafe fn get_action(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Action)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_position(&self) -> Result<GeneratorPosition> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_old_position(&self) -> Result<GeneratorPosition> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OldPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_count(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ItemCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_uicount(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ItemUICount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ILayoutInformation, 3040365723, 51407, 16819, 191, 22, 24, 200, 66, 14, 114, 201);
RT_INTERFACE!{interface ILayoutInformation(ILayoutInformationVtbl): IInspectable(IInspectableVtbl) [IID_ILayoutInformation] {
    
}}
DEFINE_IID!(IID_ILayoutInformationStatics, 3473330073, 22761, 18050, 131, 38, 80, 202, 171, 101, 237, 124);
RT_INTERFACE!{static interface ILayoutInformationStatics(ILayoutInformationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ILayoutInformationStatics] {
    fn GetLayoutExceptionElement(&self, dispatcher: *mut IInspectable, out: *mut *mut super::super::UIElement) -> HRESULT,
    fn GetLayoutSlot(&self, element: *mut super::super::FrameworkElement, out: *mut ::rt::gen::windows::foundation::Rect) -> HRESULT
}}
impl ILayoutInformationStatics {
    #[inline] pub unsafe fn get_layout_exception_element(&self, dispatcher: &IInspectable) -> Result<ComPtr<super::super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetLayoutExceptionElement)(self as *const _ as *mut _, dispatcher as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_layout_slot(&self, element: &super::super::FrameworkElement) -> Result<::rt::gen::windows::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetLayoutSlot)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class LayoutInformation: ILayoutInformation}
impl RtActivatable<ILayoutInformationStatics> for LayoutInformation {}
impl LayoutInformation {
    #[inline] pub fn get_layout_exception_element(dispatcher: &IInspectable) -> Result<ComPtr<super::super::UIElement>> { unsafe {
        <Self as RtActivatable<ILayoutInformationStatics>>::get_activation_factory().get_layout_exception_element(dispatcher)
    }}
    #[inline] pub fn get_layout_slot(element: &super::super::FrameworkElement) -> Result<::rt::gen::windows::foundation::Rect> { unsafe {
        <Self as RtActivatable<ILayoutInformationStatics>>::get_activation_factory().get_layout_slot(element)
    }}
}
DEFINE_CLSID!(LayoutInformation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,76,97,121,111,117,116,73,110,102,111,114,109,97,116,105,111,110,0]) [CLSID_LayoutInformation]);
DEFINE_IID!(IID_IComboBoxTemplateSettings, 2200460366, 6134, 19107, 182, 27, 232, 124, 113, 134, 4, 234);
RT_INTERFACE!{interface IComboBoxTemplateSettings(IComboBoxTemplateSettingsVtbl): IInspectable(IInspectableVtbl) [IID_IComboBoxTemplateSettings] {
    fn get_DropDownOpenedHeight(&self, out: *mut f64) -> HRESULT,
    fn get_DropDownClosedHeight(&self, out: *mut f64) -> HRESULT,
    fn get_DropDownOffset(&self, out: *mut f64) -> HRESULT,
    fn get_SelectedItemDirection(&self, out: *mut AnimationDirection) -> HRESULT
}}
impl IComboBoxTemplateSettings {
    #[inline] pub unsafe fn get_drop_down_opened_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DropDownOpenedHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drop_down_closed_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DropDownClosedHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drop_down_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DropDownOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_item_direction(&self) -> Result<AnimationDirection> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SelectedItemDirection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IComboBoxTemplateSettings2, 15273175, 26814, 17565, 181, 167, 118, 226, 111, 112, 62, 155);
RT_INTERFACE!{interface IComboBoxTemplateSettings2(IComboBoxTemplateSettings2Vtbl): IInspectable(IInspectableVtbl) [IID_IComboBoxTemplateSettings2] {
    fn get_DropDownContentMinWidth(&self, out: *mut f64) -> HRESULT
}}
impl IComboBoxTemplateSettings2 {
    #[inline] pub unsafe fn get_drop_down_content_min_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DropDownContentMinWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDragCompletedEventArgs, 2957978017, 48406, 18678, 165, 17, 156, 39, 99, 100, 19, 49);
RT_INTERFACE!{interface IDragCompletedEventArgs(IDragCompletedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDragCompletedEventArgs] {
    fn get_HorizontalChange(&self, out: *mut f64) -> HRESULT,
    fn get_VerticalChange(&self, out: *mut f64) -> HRESULT,
    fn get_Canceled(&self, out: *mut bool) -> HRESULT
}}
impl IDragCompletedEventArgs {
    #[inline] pub unsafe fn get_horizontal_change(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalChange)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_change(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalChange)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_canceled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Canceled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDragCompletedEventArgsFactory, 916969885, 5260, 18783, 160, 252, 175, 200, 113, 214, 47, 51);
RT_INTERFACE!{interface IDragCompletedEventArgsFactory(IDragCompletedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IDragCompletedEventArgsFactory] {
    fn CreateInstanceWithHorizontalChangeVerticalChangeAndCanceled(&self, horizontalChange: f64, verticalChange: f64, canceled: bool, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut DragCompletedEventArgs) -> HRESULT
}}
impl IDragCompletedEventArgsFactory {
    #[inline] pub unsafe fn create_instance_with_horizontal_change_vertical_change_and_canceled(&self, horizontalChange: f64, verticalChange: f64, canceled: bool, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<DragCompletedEventArgs>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithHorizontalChangeVerticalChangeAndCanceled)(self as *const _ as *mut _, horizontalChange, verticalChange, canceled, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDragDeltaEventArgs, 741201724, 10246, 18940, 170, 233, 109, 121, 43, 87, 43, 106);
RT_INTERFACE!{interface IDragDeltaEventArgs(IDragDeltaEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDragDeltaEventArgs] {
    fn get_HorizontalChange(&self, out: *mut f64) -> HRESULT,
    fn get_VerticalChange(&self, out: *mut f64) -> HRESULT
}}
impl IDragDeltaEventArgs {
    #[inline] pub unsafe fn get_horizontal_change(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalChange)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_change(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalChange)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDragDeltaEventArgsFactory, 1189585391, 44565, 17574, 138, 4, 149, 176, 191, 154, 184, 118);
RT_INTERFACE!{interface IDragDeltaEventArgsFactory(IDragDeltaEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IDragDeltaEventArgsFactory] {
    fn CreateInstanceWithHorizontalChangeAndVerticalChange(&self, horizontalChange: f64, verticalChange: f64, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut DragDeltaEventArgs) -> HRESULT
}}
impl IDragDeltaEventArgsFactory {
    #[inline] pub unsafe fn create_instance_with_horizontal_change_and_vertical_change(&self, horizontalChange: f64, verticalChange: f64, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<DragDeltaEventArgs>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithHorizontalChangeAndVerticalChange)(self as *const _ as *mut _, horizontalChange, verticalChange, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDragStartedEventArgs, 2677104080, 41252, 17254, 189, 133, 36, 8, 33, 74, 238, 212);
RT_INTERFACE!{interface IDragStartedEventArgs(IDragStartedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDragStartedEventArgs] {
    fn get_HorizontalOffset(&self, out: *mut f64) -> HRESULT,
    fn get_VerticalOffset(&self, out: *mut f64) -> HRESULT
}}
impl IDragStartedEventArgs {
    #[inline] pub unsafe fn get_horizontal_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDragStartedEventArgsFactory, 1592780153, 50950, 18305, 163, 8, 201, 231, 244, 198, 161, 215);
RT_INTERFACE!{interface IDragStartedEventArgsFactory(IDragStartedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IDragStartedEventArgsFactory] {
    fn CreateInstanceWithHorizontalOffsetAndVerticalOffset(&self, horizontalOffset: f64, verticalOffset: f64, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut DragStartedEventArgs) -> HRESULT
}}
impl IDragStartedEventArgsFactory {
    #[inline] pub unsafe fn create_instance_with_horizontal_offset_and_vertical_offset(&self, horizontalOffset: f64, verticalOffset: f64, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<DragStartedEventArgs>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithHorizontalOffsetAndVerticalOffset)(self as *const _ as *mut _, horizontalOffset, verticalOffset, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGridViewItemTemplateSettings, 2653993647, 5725, 16999, 164, 94, 26, 67, 167, 87, 6, 172);
RT_INTERFACE!{interface IGridViewItemTemplateSettings(IGridViewItemTemplateSettingsVtbl): IInspectable(IInspectableVtbl) [IID_IGridViewItemTemplateSettings] {
    fn get_DragItemsCount(&self, out: *mut i32) -> HRESULT
}}
impl IGridViewItemTemplateSettings {
    #[inline] pub unsafe fn get_drag_items_count(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DragItemsCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewItemTemplateSettings, 1739556031, 33401, 18054, 147, 38, 205, 24, 159, 39, 87, 93);
RT_INTERFACE!{interface IListViewItemTemplateSettings(IListViewItemTemplateSettingsVtbl): IInspectable(IInspectableVtbl) [IID_IListViewItemTemplateSettings] {
    fn get_DragItemsCount(&self, out: *mut i32) -> HRESULT
}}
impl IListViewItemTemplateSettings {
    #[inline] pub unsafe fn get_drag_items_count(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DragItemsCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMenuFlyoutPresenterTemplateSettings, 3599749133, 25245, 17225, 172, 81, 184, 119, 200, 9, 131, 184);
RT_INTERFACE!{interface IMenuFlyoutPresenterTemplateSettings(IMenuFlyoutPresenterTemplateSettingsVtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutPresenterTemplateSettings] {
    fn get_FlyoutContentMinWidth(&self, out: *mut f64) -> HRESULT
}}
impl IMenuFlyoutPresenterTemplateSettings {
    #[inline] pub unsafe fn get_flyout_content_min_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FlyoutContentMinWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IProgressBarTemplateSettings, 1071835690, 58354, 19499, 148, 136, 145, 141, 119, 210, 187, 228);
RT_INTERFACE!{interface IProgressBarTemplateSettings(IProgressBarTemplateSettingsVtbl): IInspectable(IInspectableVtbl) [IID_IProgressBarTemplateSettings] {
    fn get_EllipseDiameter(&self, out: *mut f64) -> HRESULT,
    fn get_EllipseOffset(&self, out: *mut f64) -> HRESULT,
    fn get_EllipseAnimationWellPosition(&self, out: *mut f64) -> HRESULT,
    fn get_EllipseAnimationEndPosition(&self, out: *mut f64) -> HRESULT,
    fn get_ContainerAnimationStartPosition(&self, out: *mut f64) -> HRESULT,
    fn get_ContainerAnimationEndPosition(&self, out: *mut f64) -> HRESULT,
    fn get_IndicatorLengthDelta(&self, out: *mut f64) -> HRESULT
}}
impl IProgressBarTemplateSettings {
    #[inline] pub unsafe fn get_ellipse_diameter(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EllipseDiameter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_ellipse_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EllipseOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_ellipse_animation_well_position(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EllipseAnimationWellPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_ellipse_animation_end_position(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EllipseAnimationEndPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_container_animation_start_position(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ContainerAnimationStartPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_container_animation_end_position(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ContainerAnimationEndPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_indicator_length_delta(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IndicatorLengthDelta)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IProgressRingTemplateSettings, 3115742700, 50979, 17126, 131, 233, 152, 38, 39, 43, 220, 14);
RT_INTERFACE!{interface IProgressRingTemplateSettings(IProgressRingTemplateSettingsVtbl): IInspectable(IInspectableVtbl) [IID_IProgressRingTemplateSettings] {
    fn get_EllipseDiameter(&self, out: *mut f64) -> HRESULT,
    fn get_EllipseOffset(&self, out: *mut super::super::Thickness) -> HRESULT,
    fn get_MaxSideLength(&self, out: *mut f64) -> HRESULT
}}
impl IProgressRingTemplateSettings {
    #[inline] pub unsafe fn get_ellipse_diameter(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EllipseDiameter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_ellipse_offset(&self) -> Result<super::super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EllipseOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_side_length(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxSideLength)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRangeBaseValueChangedEventArgs, 2710706039, 54721, 20380, 167, 176, 4, 1, 183, 230, 220, 92);
RT_INTERFACE!{interface IRangeBaseValueChangedEventArgs(IRangeBaseValueChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IRangeBaseValueChangedEventArgs] {
    fn get_OldValue(&self, out: *mut f64) -> HRESULT,
    fn get_NewValue(&self, out: *mut f64) -> HRESULT
}}
impl IRangeBaseValueChangedEventArgs {
    #[inline] pub unsafe fn get_old_value(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OldValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_new_value(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NewValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IScrollEventArgs, 3313389928, 15102, 17549, 183, 82, 47, 54, 76, 117, 215, 67);
RT_INTERFACE!{interface IScrollEventArgs(IScrollEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IScrollEventArgs] {
    fn get_NewValue(&self, out: *mut f64) -> HRESULT,
    fn get_ScrollEventType(&self, out: *mut ScrollEventType) -> HRESULT
}}
impl IScrollEventArgs {
    #[inline] pub unsafe fn get_new_value(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NewValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scroll_event_type(&self) -> Result<ScrollEventType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScrollEventType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISettingsFlyoutTemplateSettings, 3169930256, 52903, 17393, 157, 104, 87, 96, 93, 237, 105, 212);
RT_INTERFACE!{interface ISettingsFlyoutTemplateSettings(ISettingsFlyoutTemplateSettingsVtbl): IInspectable(IInspectableVtbl) [IID_ISettingsFlyoutTemplateSettings] {
    fn get_HeaderBackground(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn get_HeaderForeground(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn get_BorderBrush(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn get_BorderThickness(&self, out: *mut super::super::Thickness) -> HRESULT,
    fn get_IconSource(&self, out: *mut *mut super::super::media::ImageSource) -> HRESULT,
    fn get_ContentTransitions(&self, out: *mut *mut super::super::media::animation::TransitionCollection) -> HRESULT
}}
impl ISettingsFlyoutTemplateSettings {
    #[inline] pub unsafe fn get_header_background(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderBackground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_foreground(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderForeground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_border_brush(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BorderBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_border_thickness(&self) -> Result<super::super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BorderThickness)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_icon_source(&self) -> Result<ComPtr<super::super::media::ImageSource>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IconSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_transitions(&self) -> Result<ComPtr<super::super::media::animation::TransitionCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTransitions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IToggleSwitchTemplateSettings, 45596109, 25226, 17251, 134, 224, 81, 214, 226, 232, 158, 88);
RT_INTERFACE!{interface IToggleSwitchTemplateSettings(IToggleSwitchTemplateSettingsVtbl): IInspectable(IInspectableVtbl) [IID_IToggleSwitchTemplateSettings] {
    fn get_KnobCurrentToOnOffset(&self, out: *mut f64) -> HRESULT,
    fn get_KnobCurrentToOffOffset(&self, out: *mut f64) -> HRESULT,
    fn get_KnobOnToOffOffset(&self, out: *mut f64) -> HRESULT,
    fn get_KnobOffToOnOffset(&self, out: *mut f64) -> HRESULT,
    fn get_CurtainCurrentToOnOffset(&self, out: *mut f64) -> HRESULT,
    fn get_CurtainCurrentToOffOffset(&self, out: *mut f64) -> HRESULT,
    fn get_CurtainOnToOffOffset(&self, out: *mut f64) -> HRESULT,
    fn get_CurtainOffToOnOffset(&self, out: *mut f64) -> HRESULT
}}
impl IToggleSwitchTemplateSettings {
    #[inline] pub unsafe fn get_knob_current_to_on_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KnobCurrentToOnOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_knob_current_to_off_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KnobCurrentToOffOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_knob_on_to_off_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KnobOnToOffOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_knob_off_to_on_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KnobOffToOnOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_curtain_current_to_on_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CurtainCurrentToOnOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_curtain_current_to_off_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CurtainCurrentToOffOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_curtain_on_to_off_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CurtainOnToOffOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_curtain_off_to_on_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CurtainOffToOnOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IToolTipTemplateSettings, 3560473159, 3780, 17670, 175, 253, 175, 172, 34, 37, 180, 140);
RT_INTERFACE!{interface IToolTipTemplateSettings(IToolTipTemplateSettingsVtbl): IInspectable(IInspectableVtbl) [IID_IToolTipTemplateSettings] {
    fn get_FromHorizontalOffset(&self, out: *mut f64) -> HRESULT,
    fn get_FromVerticalOffset(&self, out: *mut f64) -> HRESULT
}}
impl IToolTipTemplateSettings {
    #[inline] pub unsafe fn get_from_horizontal_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FromHorizontalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_from_vertical_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FromVerticalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPopup, 1648460352, 59091, 18181, 161, 220, 57, 21, 100, 86, 238, 41);
RT_INTERFACE!{interface IPopup(IPopupVtbl): IInspectable(IInspectableVtbl) [IID_IPopup] {
    fn get_Child(&self, out: *mut *mut super::super::UIElement) -> HRESULT,
    fn put_Child(&self, value: *mut super::super::UIElement) -> HRESULT,
    fn get_IsOpen(&self, out: *mut bool) -> HRESULT,
    fn put_IsOpen(&self, value: bool) -> HRESULT,
    fn get_HorizontalOffset(&self, out: *mut f64) -> HRESULT,
    fn put_HorizontalOffset(&self, value: f64) -> HRESULT,
    fn get_VerticalOffset(&self, out: *mut f64) -> HRESULT,
    fn put_VerticalOffset(&self, value: f64) -> HRESULT,
    fn get_ChildTransitions(&self, out: *mut *mut super::super::media::animation::TransitionCollection) -> HRESULT,
    fn put_ChildTransitions(&self, value: *mut super::super::media::animation::TransitionCollection) -> HRESULT,
    fn get_IsLightDismissEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsLightDismissEnabled(&self, value: bool) -> HRESULT,
    fn add_Opened(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Opened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Closed(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IPopup {
    #[inline] pub unsafe fn get_child(&self) -> Result<ComPtr<super::super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Child)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_child(&self, value: &super::super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Child)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_open(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsOpen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_open(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsOpen)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_horizontal_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HorizontalOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_vertical_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_VerticalOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_child_transitions(&self) -> Result<ComPtr<super::super::media::animation::TransitionCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ChildTransitions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_child_transitions(&self, value: &super::super::media::animation::TransitionCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ChildTransitions)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_light_dismiss_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsLightDismissEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_light_dismiss_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsLightDismissEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_opened(&self, value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Opened)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_opened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Opened)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_closed(&self, value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Closed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_closed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Closed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPopupStatics, 1524875034, 28212, 16598, 138, 127, 202, 130, 42, 175, 89, 227);
RT_INTERFACE!{static interface IPopupStatics(IPopupStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPopupStatics] {
    fn get_ChildProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_IsOpenProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_HorizontalOffsetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_VerticalOffsetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ChildTransitionsProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_IsLightDismissEnabledProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IPopupStatics {
    #[inline] pub unsafe fn get_child_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ChildProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_open_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsOpenProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_offset_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HorizontalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_offset_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VerticalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_child_transitions_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ChildTransitionsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_light_dismiss_enabled_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsLightDismissEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPopup2, 929729612, 43712, 19232, 150, 106, 11, 147, 100, 254, 180, 181);
RT_INTERFACE!{interface IPopup2(IPopup2Vtbl): IInspectable(IInspectableVtbl) [IID_IPopup2] {
    fn get_LightDismissOverlayMode(&self, out: *mut super::LightDismissOverlayMode) -> HRESULT,
    fn put_LightDismissOverlayMode(&self, value: super::LightDismissOverlayMode) -> HRESULT
}}
impl IPopup2 {
    #[inline] pub unsafe fn get_light_dismiss_overlay_mode(&self) -> Result<super::LightDismissOverlayMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LightDismissOverlayMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_light_dismiss_overlay_mode(&self, value: super::LightDismissOverlayMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LightDismissOverlayMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPopupStatics2, 731572716, 21999, 17334, 180, 89, 18, 228, 15, 250, 67, 2);
RT_INTERFACE!{static interface IPopupStatics2(IPopupStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IPopupStatics2] {
    fn get_LightDismissOverlayModeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IPopupStatics2 {
    #[inline] pub unsafe fn get_light_dismiss_overlay_mode_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LightDismissOverlayModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITickBar, 2571535354, 61942, 18557, 165, 172, 193, 89, 33, 191, 169, 149);
RT_INTERFACE!{interface ITickBar(ITickBarVtbl): IInspectable(IInspectableVtbl) [IID_ITickBar] {
    fn get_Fill(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_Fill(&self, value: *mut super::super::media::Brush) -> HRESULT
}}
impl ITickBar {
    #[inline] pub unsafe fn get_fill(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Fill)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_fill(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Fill)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITickBarStatics, 745373248, 31133, 19028, 190, 9, 31, 239, 198, 29, 1, 142);
RT_INTERFACE!{static interface ITickBarStatics(ITickBarStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ITickBarStatics] {
    fn get_FillProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl ITickBarStatics {
    #[inline] pub unsafe fn get_fill_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FillProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRangeBase, 4194315290, 18766, 18127, 145, 212, 225, 74, 141, 121, 134, 117);
RT_INTERFACE!{interface IRangeBase(IRangeBaseVtbl): IInspectable(IInspectableVtbl) [IID_IRangeBase] {
    fn get_Minimum(&self, out: *mut f64) -> HRESULT,
    fn put_Minimum(&self, value: f64) -> HRESULT,
    fn get_Maximum(&self, out: *mut f64) -> HRESULT,
    fn put_Maximum(&self, value: f64) -> HRESULT,
    fn get_SmallChange(&self, out: *mut f64) -> HRESULT,
    fn put_SmallChange(&self, value: f64) -> HRESULT,
    fn get_LargeChange(&self, out: *mut f64) -> HRESULT,
    fn put_LargeChange(&self, value: f64) -> HRESULT,
    fn get_Value(&self, out: *mut f64) -> HRESULT,
    fn put_Value(&self, value: f64) -> HRESULT,
    fn add_ValueChanged(&self, value: *mut RangeBaseValueChangedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ValueChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IRangeBase {
    #[inline] pub unsafe fn get_minimum(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Minimum)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_minimum(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Minimum)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_maximum(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Maximum)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_maximum(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Maximum)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_small_change(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SmallChange)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_small_change(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SmallChange)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_large_change(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LargeChange)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_large_change(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LargeChange)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_value(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Value)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_value(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Value)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_value_changed(&self, value: &RangeBaseValueChangedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ValueChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_value_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ValueChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRangeBaseOverrides, 1116843833, 32523, 19394, 153, 196, 6, 231, 6, 38, 130, 216);
RT_INTERFACE!{interface IRangeBaseOverrides(IRangeBaseOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IRangeBaseOverrides] {
    fn OnMinimumChanged(&self, oldMinimum: f64, newMinimum: f64) -> HRESULT,
    fn OnMaximumChanged(&self, oldMaximum: f64, newMaximum: f64) -> HRESULT,
    fn OnValueChanged(&self, oldValue: f64, newValue: f64) -> HRESULT
}}
impl IRangeBaseOverrides {
    #[inline] pub unsafe fn on_minimum_changed(&self, oldMinimum: f64, newMinimum: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).OnMinimumChanged)(self as *const _ as *mut _, oldMinimum, newMinimum);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_maximum_changed(&self, oldMaximum: f64, newMaximum: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).OnMaximumChanged)(self as *const _ as *mut _, oldMaximum, newMaximum);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_value_changed(&self, oldValue: f64, newValue: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).OnValueChanged)(self as *const _ as *mut _, oldValue, newValue);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRangeBaseStatics, 1743722465, 65079, 18255, 158, 151, 59, 94, 11, 48, 242, 224);
RT_INTERFACE!{static interface IRangeBaseStatics(IRangeBaseStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRangeBaseStatics] {
    fn get_MinimumProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_MaximumProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_SmallChangeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_LargeChangeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ValueProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IRangeBaseStatics {
    #[inline] pub unsafe fn get_minimum_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MinimumProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_maximum_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaximumProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_small_change_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SmallChangeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_large_change_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LargeChangeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_value_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ValueProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRangeBaseFactory, 949714033, 21024, 17074, 153, 146, 38, 144, 193, 166, 112, 48);
RT_INTERFACE!{interface IRangeBaseFactory(IRangeBaseFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IRangeBaseFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut RangeBase) -> HRESULT
}}
impl IRangeBaseFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<RangeBase>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IThumb, 3904025217, 3434, 17871, 179, 51, 36, 2, 176, 55, 240, 153);
RT_INTERFACE!{interface IThumb(IThumbVtbl): IInspectable(IInspectableVtbl) [IID_IThumb] {
    fn get_IsDragging(&self, out: *mut bool) -> HRESULT,
    fn add_DragStarted(&self, value: *mut DragStartedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DragStarted(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_DragDelta(&self, value: *mut DragDeltaEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DragDelta(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_DragCompleted(&self, value: *mut DragCompletedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DragCompleted(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn CancelDrag(&self) -> HRESULT
}}
impl IThumb {
    #[inline] pub unsafe fn get_is_dragging(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsDragging)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_drag_started(&self, value: &DragStartedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DragStarted)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_drag_started(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DragStarted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_drag_delta(&self, value: &DragDeltaEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DragDelta)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_drag_delta(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DragDelta)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_drag_completed(&self, value: &DragCompletedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DragCompleted)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_drag_completed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DragCompleted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn cancel_drag(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).CancelDrag)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IThumbStatics, 2505057515, 14067, 18034, 161, 134, 186, 175, 98, 106, 196, 173);
RT_INTERFACE!{static interface IThumbStatics(IThumbStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IThumbStatics] {
    fn get_IsDraggingProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IThumbStatics {
    #[inline] pub unsafe fn get_is_dragging_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsDraggingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IButtonBase, 4194315290, 18766, 18127, 145, 212, 225, 74, 141, 121, 134, 116);
RT_INTERFACE!{interface IButtonBase(IButtonBaseVtbl): IInspectable(IInspectableVtbl) [IID_IButtonBase] {
    fn get_ClickMode(&self, out: *mut super::ClickMode) -> HRESULT,
    fn put_ClickMode(&self, value: super::ClickMode) -> HRESULT,
    fn get_IsPointerOver(&self, out: *mut bool) -> HRESULT,
    fn get_IsPressed(&self, out: *mut bool) -> HRESULT,
    fn get_Command(&self, out: *mut *mut super::super::input::ICommand) -> HRESULT,
    fn put_Command(&self, value: *mut super::super::input::ICommand) -> HRESULT,
    fn get_CommandParameter(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_CommandParameter(&self, value: *mut IInspectable) -> HRESULT,
    fn add_Click(&self, value: *mut super::super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Click(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IButtonBase {
    #[inline] pub unsafe fn get_click_mode(&self) -> Result<super::ClickMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ClickMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_click_mode(&self, value: super::ClickMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ClickMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_pointer_over(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsPointerOver)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_pressed(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsPressed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_command(&self) -> Result<ComPtr<super::super::input::ICommand>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Command)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_command(&self, value: &super::super::input::ICommand) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Command)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_command_parameter(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CommandParameter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_command_parameter(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CommandParameter)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_click(&self, value: &super::super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Click)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_click(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Click)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IButtonBaseStatics, 1743722465, 65079, 18255, 158, 151, 59, 94, 11, 48, 242, 223);
RT_INTERFACE!{static interface IButtonBaseStatics(IButtonBaseStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IButtonBaseStatics] {
    fn get_ClickModeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_IsPointerOverProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_IsPressedProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_CommandProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_CommandParameterProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IButtonBaseStatics {
    #[inline] pub unsafe fn get_click_mode_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ClickModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_pointer_over_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsPointerOverProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_pressed_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsPressedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_command_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CommandProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_command_parameter_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CommandParameterProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IButtonBaseFactory, 949714033, 21024, 17074, 153, 146, 38, 144, 193, 166, 112, 47);
RT_INTERFACE!{interface IButtonBaseFactory(IButtonBaseFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IButtonBaseFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ButtonBase) -> HRESULT
}}
impl IButtonBaseFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ButtonBase>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICarouselPanel, 3735779506, 14139, 16721, 135, 133, 229, 68, 208, 217, 54, 43);
RT_INTERFACE!{interface ICarouselPanel(ICarouselPanelVtbl): IInspectable(IInspectableVtbl) [IID_ICarouselPanel] {
    fn get_CanVerticallyScroll(&self, out: *mut bool) -> HRESULT,
    fn put_CanVerticallyScroll(&self, value: bool) -> HRESULT,
    fn get_CanHorizontallyScroll(&self, out: *mut bool) -> HRESULT,
    fn put_CanHorizontallyScroll(&self, value: bool) -> HRESULT,
    fn get_ExtentWidth(&self, out: *mut f64) -> HRESULT,
    fn get_ExtentHeight(&self, out: *mut f64) -> HRESULT,
    fn get_ViewportWidth(&self, out: *mut f64) -> HRESULT,
    fn get_ViewportHeight(&self, out: *mut f64) -> HRESULT,
    fn get_HorizontalOffset(&self, out: *mut f64) -> HRESULT,
    fn get_VerticalOffset(&self, out: *mut f64) -> HRESULT,
    fn get_ScrollOwner(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_ScrollOwner(&self, value: *mut IInspectable) -> HRESULT,
    fn LineUp(&self) -> HRESULT,
    fn LineDown(&self) -> HRESULT,
    fn LineLeft(&self) -> HRESULT,
    fn LineRight(&self) -> HRESULT,
    fn PageUp(&self) -> HRESULT,
    fn PageDown(&self) -> HRESULT,
    fn PageLeft(&self) -> HRESULT,
    fn PageRight(&self) -> HRESULT,
    fn MouseWheelUp(&self) -> HRESULT,
    fn MouseWheelDown(&self) -> HRESULT,
    fn MouseWheelLeft(&self) -> HRESULT,
    fn MouseWheelRight(&self) -> HRESULT,
    fn SetHorizontalOffset(&self, offset: f64) -> HRESULT,
    fn SetVerticalOffset(&self, offset: f64) -> HRESULT,
    fn MakeVisible(&self, visual: *mut super::super::UIElement, rectangle: ::rt::gen::windows::foundation::Rect, out: *mut ::rt::gen::windows::foundation::Rect) -> HRESULT
}}
impl ICarouselPanel {
    #[inline] pub unsafe fn get_can_vertically_scroll(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanVerticallyScroll)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_vertically_scroll(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanVerticallyScroll)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_horizontally_scroll(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanHorizontallyScroll)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_horizontally_scroll(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanHorizontallyScroll)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_extent_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExtentWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_extent_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExtentHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_viewport_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ViewportWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_viewport_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ViewportHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scroll_owner(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ScrollOwner)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_scroll_owner(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ScrollOwner)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn line_up(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).LineUp)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn line_down(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).LineDown)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn line_left(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).LineLeft)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn line_right(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).LineRight)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn page_up(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).PageUp)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn page_down(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).PageDown)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn page_left(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).PageLeft)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn page_right(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).PageRight)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn mouse_wheel_up(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).MouseWheelUp)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn mouse_wheel_down(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).MouseWheelDown)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn mouse_wheel_left(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).MouseWheelLeft)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn mouse_wheel_right(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).MouseWheelRight)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_horizontal_offset(&self, offset: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).SetHorizontalOffset)(self as *const _ as *mut _, offset);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_vertical_offset(&self, offset: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).SetVerticalOffset)(self as *const _ as *mut _, offset);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn make_visible(&self, visual: &super::super::UIElement, rectangle: ::rt::gen::windows::foundation::Rect) -> Result<::rt::gen::windows::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).MakeVisible)(self as *const _ as *mut _, visual as *const _ as *mut _, rectangle, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICarouselPanelFactory, 3239089156, 39649, 17422, 160, 221, 187, 182, 226, 41, 60, 190);
RT_INTERFACE!{interface ICarouselPanelFactory(ICarouselPanelFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICarouselPanelFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut CarouselPanel) -> HRESULT
}}
impl ICarouselPanelFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<CarouselPanel>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IOrientedVirtualizingPanel, 4034377079, 14781, 18158, 189, 215, 8, 38, 190, 237, 113, 184);
RT_INTERFACE!{interface IOrientedVirtualizingPanel(IOrientedVirtualizingPanelVtbl): IInspectable(IInspectableVtbl) [IID_IOrientedVirtualizingPanel] {
    fn get_CanVerticallyScroll(&self, out: *mut bool) -> HRESULT,
    fn put_CanVerticallyScroll(&self, value: bool) -> HRESULT,
    fn get_CanHorizontallyScroll(&self, out: *mut bool) -> HRESULT,
    fn put_CanHorizontallyScroll(&self, value: bool) -> HRESULT,
    fn get_ExtentWidth(&self, out: *mut f64) -> HRESULT,
    fn get_ExtentHeight(&self, out: *mut f64) -> HRESULT,
    fn get_ViewportWidth(&self, out: *mut f64) -> HRESULT,
    fn get_ViewportHeight(&self, out: *mut f64) -> HRESULT,
    fn get_HorizontalOffset(&self, out: *mut f64) -> HRESULT,
    fn get_VerticalOffset(&self, out: *mut f64) -> HRESULT,
    fn get_ScrollOwner(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_ScrollOwner(&self, value: *mut IInspectable) -> HRESULT,
    fn LineUp(&self) -> HRESULT,
    fn LineDown(&self) -> HRESULT,
    fn LineLeft(&self) -> HRESULT,
    fn LineRight(&self) -> HRESULT,
    fn PageUp(&self) -> HRESULT,
    fn PageDown(&self) -> HRESULT,
    fn PageLeft(&self) -> HRESULT,
    fn PageRight(&self) -> HRESULT,
    fn MouseWheelUp(&self) -> HRESULT,
    fn MouseWheelDown(&self) -> HRESULT,
    fn MouseWheelLeft(&self) -> HRESULT,
    fn MouseWheelRight(&self) -> HRESULT,
    fn SetHorizontalOffset(&self, offset: f64) -> HRESULT,
    fn SetVerticalOffset(&self, offset: f64) -> HRESULT,
    fn MakeVisible(&self, visual: *mut super::super::UIElement, rectangle: ::rt::gen::windows::foundation::Rect, out: *mut ::rt::gen::windows::foundation::Rect) -> HRESULT
}}
impl IOrientedVirtualizingPanel {
    #[inline] pub unsafe fn get_can_vertically_scroll(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanVerticallyScroll)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_vertically_scroll(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanVerticallyScroll)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_horizontally_scroll(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanHorizontallyScroll)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_horizontally_scroll(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanHorizontallyScroll)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_extent_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExtentWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_extent_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExtentHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_viewport_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ViewportWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_viewport_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ViewportHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scroll_owner(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ScrollOwner)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_scroll_owner(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ScrollOwner)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn line_up(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).LineUp)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn line_down(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).LineDown)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn line_left(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).LineLeft)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn line_right(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).LineRight)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn page_up(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).PageUp)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn page_down(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).PageDown)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn page_left(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).PageLeft)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn page_right(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).PageRight)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn mouse_wheel_up(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).MouseWheelUp)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn mouse_wheel_down(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).MouseWheelDown)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn mouse_wheel_left(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).MouseWheelLeft)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn mouse_wheel_right(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).MouseWheelRight)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_horizontal_offset(&self, offset: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).SetHorizontalOffset)(self as *const _ as *mut _, offset);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_vertical_offset(&self, offset: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).SetVerticalOffset)(self as *const _ as *mut _, offset);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn make_visible(&self, visual: &super::super::UIElement, rectangle: ::rt::gen::windows::foundation::Rect) -> Result<::rt::gen::windows::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).MakeVisible)(self as *const _ as *mut _, visual as *const _ as *mut _, rectangle, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IOrientedVirtualizingPanelFactory, 2072948399, 63791, 17309, 158, 191, 233, 145, 159, 86, 201, 77);
RT_INTERFACE!{interface IOrientedVirtualizingPanelFactory(IOrientedVirtualizingPanelFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IOrientedVirtualizingPanelFactory] {
    
}}
DEFINE_IID!(IID_IScrollBar, 4118472394, 53670, 19344, 164, 233, 84, 223, 27, 168, 210, 236);
RT_INTERFACE!{interface IScrollBar(IScrollBarVtbl): IInspectable(IInspectableVtbl) [IID_IScrollBar] {
    fn get_Orientation(&self, out: *mut super::Orientation) -> HRESULT,
    fn put_Orientation(&self, value: super::Orientation) -> HRESULT,
    fn get_ViewportSize(&self, out: *mut f64) -> HRESULT,
    fn put_ViewportSize(&self, value: f64) -> HRESULT,
    fn get_IndicatorMode(&self, out: *mut ScrollingIndicatorMode) -> HRESULT,
    fn put_IndicatorMode(&self, value: ScrollingIndicatorMode) -> HRESULT,
    fn add_Scroll(&self, value: *mut ScrollEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Scroll(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IScrollBar {
    #[inline] pub unsafe fn get_orientation(&self) -> Result<super::Orientation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Orientation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_orientation(&self, value: super::Orientation) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Orientation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_viewport_size(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ViewportSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_viewport_size(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ViewportSize)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_indicator_mode(&self) -> Result<ScrollingIndicatorMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IndicatorMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_indicator_mode(&self, value: ScrollingIndicatorMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IndicatorMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_scroll(&self, value: &ScrollEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Scroll)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_scroll(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Scroll)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IScrollBarStatics, 1173025677, 47124, 18639, 151, 242, 83, 158, 177, 109, 253, 77);
RT_INTERFACE!{static interface IScrollBarStatics(IScrollBarStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IScrollBarStatics] {
    fn get_OrientationProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ViewportSizeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_IndicatorModeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IScrollBarStatics {
    #[inline] pub unsafe fn get_orientation_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OrientationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_viewport_size_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ViewportSizeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_indicator_mode_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IndicatorModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISelector, 3809391525, 45931, 17116, 133, 39, 205, 37, 19, 108, 8, 60);
RT_INTERFACE!{interface ISelector(ISelectorVtbl): IInspectable(IInspectableVtbl) [IID_ISelector] {
    fn get_SelectedIndex(&self, out: *mut i32) -> HRESULT,
    fn put_SelectedIndex(&self, value: i32) -> HRESULT,
    fn get_SelectedItem(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_SelectedItem(&self, value: *mut IInspectable) -> HRESULT,
    fn get_SelectedValue(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_SelectedValue(&self, value: *mut IInspectable) -> HRESULT,
    fn get_SelectedValuePath(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SelectedValuePath(&self, value: HSTRING) -> HRESULT,
    fn get_IsSynchronizedWithCurrentItem(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<bool>) -> HRESULT,
    fn put_IsSynchronizedWithCurrentItem(&self, value: *mut ::rt::gen::windows::foundation::IReference<bool>) -> HRESULT,
    fn add_SelectionChanged(&self, value: *mut super::SelectionChangedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SelectionChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl ISelector {
    #[inline] pub unsafe fn get_selected_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SelectedIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_index(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedIndex)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_item(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedItem)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_item(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedItem)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_value(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_value(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedValue)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_value_path(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedValuePath)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_value_path(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedValuePath)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_synchronized_with_current_item(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsSynchronizedWithCurrentItem)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_synchronized_with_current_item(&self, value: &::rt::gen::windows::foundation::IReference<bool>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSynchronizedWithCurrentItem)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_selection_changed(&self, value: &super::SelectionChangedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SelectionChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_selection_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SelectionChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISelectorStatics, 321915654, 48400, 19977, 191, 247, 113, 239, 184, 187, 180, 43);
RT_INTERFACE!{static interface ISelectorStatics(ISelectorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISelectorStatics] {
    fn get_SelectedIndexProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_SelectedItemProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_SelectedValueProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_SelectedValuePathProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_IsSynchronizedWithCurrentItemProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn GetIsSelectionActive(&self, element: *mut super::super::DependencyObject, out: *mut bool) -> HRESULT
}}
impl ISelectorStatics {
    #[inline] pub unsafe fn get_selected_index_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedIndexProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_item_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedItemProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_value_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedValueProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_value_path_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedValuePathProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_synchronized_with_current_item_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsSynchronizedWithCurrentItemProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_selection_active(&self, element: &super::super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsSelectionActive)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISelectorFactory, 3384682901, 53558, 17920, 177, 135, 138, 213, 96, 121, 180, 138);
RT_INTERFACE!{interface ISelectorFactory(ISelectorFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISelectorFactory] {
    
}}
DEFINE_IID!(IID_ISelectorItem, 1411157356, 643, 17793, 185, 69, 42, 100, 194, 138, 6, 70);
RT_INTERFACE!{interface ISelectorItem(ISelectorItemVtbl): IInspectable(IInspectableVtbl) [IID_ISelectorItem] {
    fn get_IsSelected(&self, out: *mut bool) -> HRESULT,
    fn put_IsSelected(&self, value: bool) -> HRESULT
}}
impl ISelectorItem {
    #[inline] pub unsafe fn get_is_selected(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSelected)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_selected(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSelected)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISelectorItemStatics, 708131512, 52201, 17155, 146, 231, 200, 144, 110, 33, 131, 146);
RT_INTERFACE!{static interface ISelectorItemStatics(ISelectorItemStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISelectorItemStatics] {
    fn get_IsSelectedProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl ISelectorItemStatics {
    #[inline] pub unsafe fn get_is_selected_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsSelectedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISelectorItemFactory, 3107338565, 51306, 19230, 148, 64, 24, 121, 55, 141, 83, 19);
RT_INTERFACE!{interface ISelectorItemFactory(ISelectorItemFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISelectorItemFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut SelectorItem) -> HRESULT
}}
impl ISelectorItemFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<SelectorItem>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRepeatButton, 35655161, 538, 18506, 169, 59, 15, 49, 2, 3, 20, 229);
RT_INTERFACE!{interface IRepeatButton(IRepeatButtonVtbl): IInspectable(IInspectableVtbl) [IID_IRepeatButton] {
    fn get_Delay(&self, out: *mut i32) -> HRESULT,
    fn put_Delay(&self, value: i32) -> HRESULT,
    fn get_Interval(&self, out: *mut i32) -> HRESULT,
    fn put_Interval(&self, value: i32) -> HRESULT
}}
impl IRepeatButton {
    #[inline] pub unsafe fn get_delay(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Delay)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_delay(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Delay)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_interval(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Interval)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_interval(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Interval)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRepeatButtonStatics, 957656142, 62562, 20339, 129, 151, 232, 132, 102, 57, 198, 130);
RT_INTERFACE!{static interface IRepeatButtonStatics(IRepeatButtonStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRepeatButtonStatics] {
    fn get_DelayProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_IntervalProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IRepeatButtonStatics {
    #[inline] pub unsafe fn get_delay_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DelayProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_interval_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IntervalProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IToggleButton, 1486387195, 4039, 16438, 157, 139, 18, 125, 250, 117, 193, 109);
RT_INTERFACE!{interface IToggleButton(IToggleButtonVtbl): IInspectable(IInspectableVtbl) [IID_IToggleButton] {
    fn get_IsChecked(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<bool>) -> HRESULT,
    fn put_IsChecked(&self, value: *mut ::rt::gen::windows::foundation::IReference<bool>) -> HRESULT,
    fn get_IsThreeState(&self, out: *mut bool) -> HRESULT,
    fn put_IsThreeState(&self, value: bool) -> HRESULT,
    fn add_Checked(&self, value: *mut super::super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Checked(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Unchecked(&self, value: *mut super::super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Unchecked(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Indeterminate(&self, value: *mut super::super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Indeterminate(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IToggleButton {
    #[inline] pub unsafe fn get_is_checked(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsChecked)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_checked(&self, value: &::rt::gen::windows::foundation::IReference<bool>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsChecked)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_three_state(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsThreeState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_three_state(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsThreeState)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_checked(&self, value: &super::super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Checked)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_checked(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Checked)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_unchecked(&self, value: &super::super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Unchecked)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_unchecked(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Unchecked)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_indeterminate(&self, value: &super::super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Indeterminate)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_indeterminate(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Indeterminate)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IToggleButtonOverrides, 3524152360, 61835, 18714, 154, 69, 241, 160, 74, 147, 105, 164);
RT_INTERFACE!{interface IToggleButtonOverrides(IToggleButtonOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IToggleButtonOverrides] {
    fn OnToggle(&self) -> HRESULT
}}
impl IToggleButtonOverrides {
    #[inline] pub unsafe fn on_toggle(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).OnToggle)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IToggleButtonStatics, 2938022674, 296, 20327, 156, 90, 130, 50, 12, 68, 93, 25);
RT_INTERFACE!{static interface IToggleButtonStatics(IToggleButtonStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IToggleButtonStatics] {
    fn get_IsCheckedProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_IsThreeStateProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IToggleButtonStatics {
    #[inline] pub unsafe fn get_is_checked_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsCheckedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_three_state_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsThreeStateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IToggleButtonFactory, 3580535548, 64639, 17564, 152, 85, 122, 16, 85, 214, 104, 168);
RT_INTERFACE!{interface IToggleButtonFactory(IToggleButtonFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IToggleButtonFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ToggleButton) -> HRESULT
}}
impl IToggleButtonFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ToggleButton>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_ENUM! { enum ListViewItemPresenterCheckMode: i32 {
    Inline (ListViewItemPresenterCheckMode_Inline) = 0, Overlay (ListViewItemPresenterCheckMode_Overlay) = 1,
}}
DEFINE_IID!(IID_IAppBarTemplateSettings, 3166873699, 60213, 16956, 131, 137, 215, 130, 123, 227, 191, 103);
RT_INTERFACE!{interface IAppBarTemplateSettings(IAppBarTemplateSettingsVtbl): IInspectable(IInspectableVtbl) [IID_IAppBarTemplateSettings] {
    fn get_ClipRect(&self, out: *mut ::rt::gen::windows::foundation::Rect) -> HRESULT,
    fn get_CompactVerticalDelta(&self, out: *mut f64) -> HRESULT,
    fn get_CompactRootMargin(&self, out: *mut super::super::Thickness) -> HRESULT,
    fn get_MinimalVerticalDelta(&self, out: *mut f64) -> HRESULT,
    fn get_MinimalRootMargin(&self, out: *mut super::super::Thickness) -> HRESULT,
    fn get_HiddenVerticalDelta(&self, out: *mut f64) -> HRESULT,
    fn get_HiddenRootMargin(&self, out: *mut super::super::Thickness) -> HRESULT
}}
impl IAppBarTemplateSettings {
    #[inline] pub unsafe fn get_clip_rect(&self) -> Result<::rt::gen::windows::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ClipRect)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_compact_vertical_delta(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CompactVerticalDelta)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_compact_root_margin(&self) -> Result<super::super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CompactRootMargin)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_minimal_vertical_delta(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinimalVerticalDelta)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_minimal_root_margin(&self) -> Result<super::super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinimalRootMargin)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_hidden_vertical_delta(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HiddenVerticalDelta)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_hidden_root_margin(&self) -> Result<super::super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HiddenRootMargin)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICalendarViewTemplateSettings, 1455887491, 25825, 18300, 138, 11, 203, 47, 51, 52, 185, 176);
RT_INTERFACE!{interface ICalendarViewTemplateSettings(ICalendarViewTemplateSettingsVtbl): IInspectable(IInspectableVtbl) [IID_ICalendarViewTemplateSettings] {
    fn get_MinViewWidth(&self, out: *mut f64) -> HRESULT,
    fn get_HeaderText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_WeekDay1(&self, out: *mut HSTRING) -> HRESULT,
    fn get_WeekDay2(&self, out: *mut HSTRING) -> HRESULT,
    fn get_WeekDay3(&self, out: *mut HSTRING) -> HRESULT,
    fn get_WeekDay4(&self, out: *mut HSTRING) -> HRESULT,
    fn get_WeekDay5(&self, out: *mut HSTRING) -> HRESULT,
    fn get_WeekDay6(&self, out: *mut HSTRING) -> HRESULT,
    fn get_WeekDay7(&self, out: *mut HSTRING) -> HRESULT,
    fn get_HasMoreContentAfter(&self, out: *mut bool) -> HRESULT,
    fn get_HasMoreContentBefore(&self, out: *mut bool) -> HRESULT,
    fn get_HasMoreViews(&self, out: *mut bool) -> HRESULT,
    fn get_ClipRect(&self, out: *mut ::rt::gen::windows::foundation::Rect) -> HRESULT,
    fn get_CenterX(&self, out: *mut f64) -> HRESULT,
    fn get_CenterY(&self, out: *mut f64) -> HRESULT
}}
impl ICalendarViewTemplateSettings {
    #[inline] pub unsafe fn get_min_view_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinViewWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_header_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_week_day1(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_WeekDay1)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_week_day2(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_WeekDay2)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_week_day3(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_WeekDay3)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_week_day4(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_WeekDay4)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_week_day5(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_WeekDay5)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_week_day6(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_WeekDay6)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_week_day7(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_WeekDay7)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_has_more_content_after(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HasMoreContentAfter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_has_more_content_before(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HasMoreContentBefore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_has_more_views(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HasMoreViews)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_clip_rect(&self) -> Result<::rt::gen::windows::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ClipRect)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_center_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CenterX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_center_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CenterY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICommandBarTemplateSettings, 1640560940, 1450, 16714, 162, 174, 72, 44, 90, 70, 192, 142);
RT_INTERFACE!{interface ICommandBarTemplateSettings(ICommandBarTemplateSettingsVtbl): IInspectable(IInspectableVtbl) [IID_ICommandBarTemplateSettings] {
    fn get_ContentHeight(&self, out: *mut f64) -> HRESULT,
    fn get_OverflowContentClipRect(&self, out: *mut ::rt::gen::windows::foundation::Rect) -> HRESULT,
    fn get_OverflowContentMinWidth(&self, out: *mut f64) -> HRESULT,
    fn get_OverflowContentMaxHeight(&self, out: *mut f64) -> HRESULT,
    fn get_OverflowContentHorizontalOffset(&self, out: *mut f64) -> HRESULT,
    fn get_OverflowContentHeight(&self, out: *mut f64) -> HRESULT,
    fn get_NegativeOverflowContentHeight(&self, out: *mut f64) -> HRESULT
}}
impl ICommandBarTemplateSettings {
    #[inline] pub unsafe fn get_content_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ContentHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_overflow_content_clip_rect(&self) -> Result<::rt::gen::windows::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OverflowContentClipRect)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_overflow_content_min_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OverflowContentMinWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_overflow_content_max_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OverflowContentMaxHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_overflow_content_horizontal_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OverflowContentHorizontalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_overflow_content_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OverflowContentHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_negative_overflow_content_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NegativeOverflowContentHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICommandBarTemplateSettings2, 4222766995, 49890, 16759, 162, 182, 60, 215, 5, 7, 60, 246);
RT_INTERFACE!{interface ICommandBarTemplateSettings2(ICommandBarTemplateSettings2Vtbl): IInspectable(IInspectableVtbl) [IID_ICommandBarTemplateSettings2] {
    fn get_OverflowContentMaxWidth(&self, out: *mut f64) -> HRESULT
}}
impl ICommandBarTemplateSettings2 {
    #[inline] pub unsafe fn get_overflow_content_max_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OverflowContentMaxWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICommandBarTemplateSettings3, 1003953850, 13315, 19454, 132, 45, 44, 232, 197, 17, 210, 69);
RT_INTERFACE!{interface ICommandBarTemplateSettings3(ICommandBarTemplateSettings3Vtbl): IInspectable(IInspectableVtbl) [IID_ICommandBarTemplateSettings3] {
    fn get_EffectiveOverflowButtonVisibility(&self, out: *mut super::super::Visibility) -> HRESULT
}}
impl ICommandBarTemplateSettings3 {
    #[inline] pub unsafe fn get_effective_overflow_button_visibility(&self) -> Result<super::super::Visibility> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EffectiveOverflowButtonVisibility)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISplitViewTemplateSettings, 3244996007, 18838, 17475, 177, 153, 107, 107, 137, 18, 78, 171);
RT_INTERFACE!{interface ISplitViewTemplateSettings(ISplitViewTemplateSettingsVtbl): IInspectable(IInspectableVtbl) [IID_ISplitViewTemplateSettings] {
    fn get_OpenPaneLength(&self, out: *mut f64) -> HRESULT,
    fn get_NegativeOpenPaneLength(&self, out: *mut f64) -> HRESULT,
    fn get_OpenPaneLengthMinusCompactLength(&self, out: *mut f64) -> HRESULT,
    fn get_NegativeOpenPaneLengthMinusCompactLength(&self, out: *mut f64) -> HRESULT,
    fn get_OpenPaneGridLength(&self, out: *mut super::super::GridLength) -> HRESULT,
    fn get_CompactPaneGridLength(&self, out: *mut super::super::GridLength) -> HRESULT
}}
impl ISplitViewTemplateSettings {
    #[inline] pub unsafe fn get_open_pane_length(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OpenPaneLength)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_negative_open_pane_length(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NegativeOpenPaneLength)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_open_pane_length_minus_compact_length(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OpenPaneLengthMinusCompactLength)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_negative_open_pane_length_minus_compact_length(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NegativeOpenPaneLengthMinusCompactLength)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_open_pane_grid_length(&self) -> Result<super::super::GridLength> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OpenPaneGridLength)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_compact_pane_grid_length(&self) -> Result<super::super::GridLength> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CompactPaneGridLength)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICalendarPanel, 4241840685, 723, 20198, 154, 144, 157, 243, 234, 208, 9, 148);
RT_INTERFACE!{interface ICalendarPanel(ICalendarPanelVtbl): IInspectable(IInspectableVtbl) [IID_ICalendarPanel] {
    
}}
DEFINE_IID!(IID_IGridViewItemPresenter, 558862352, 22242, 18465, 138, 28, 35, 5, 112, 154, 249, 75);
RT_INTERFACE!{interface IGridViewItemPresenter(IGridViewItemPresenterVtbl): IInspectable(IInspectableVtbl) [IID_IGridViewItemPresenter] {
    fn get_SelectionCheckMarkVisualEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_SelectionCheckMarkVisualEnabled(&self, value: bool) -> HRESULT,
    fn get_CheckHintBrush(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_CheckHintBrush(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_CheckSelectingBrush(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_CheckSelectingBrush(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_CheckBrush(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_CheckBrush(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_DragBackground(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_DragBackground(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_DragForeground(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_DragForeground(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_FocusBorderBrush(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_FocusBorderBrush(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_PlaceholderBackground(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_PlaceholderBackground(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_PointerOverBackground(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_PointerOverBackground(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_SelectedBackground(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_SelectedBackground(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_SelectedForeground(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_SelectedForeground(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_SelectedPointerOverBackground(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_SelectedPointerOverBackground(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_SelectedPointerOverBorderBrush(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_SelectedPointerOverBorderBrush(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_SelectedBorderThickness(&self, out: *mut super::super::Thickness) -> HRESULT,
    fn put_SelectedBorderThickness(&self, value: super::super::Thickness) -> HRESULT,
    fn get_DisabledOpacity(&self, out: *mut f64) -> HRESULT,
    fn put_DisabledOpacity(&self, value: f64) -> HRESULT,
    fn get_DragOpacity(&self, out: *mut f64) -> HRESULT,
    fn put_DragOpacity(&self, value: f64) -> HRESULT,
    fn get_ReorderHintOffset(&self, out: *mut f64) -> HRESULT,
    fn put_ReorderHintOffset(&self, value: f64) -> HRESULT,
    fn get_GridViewItemPresenterHorizontalContentAlignment(&self, out: *mut super::super::HorizontalAlignment) -> HRESULT,
    fn put_GridViewItemPresenterHorizontalContentAlignment(&self, value: super::super::HorizontalAlignment) -> HRESULT,
    fn get_GridViewItemPresenterVerticalContentAlignment(&self, out: *mut super::super::VerticalAlignment) -> HRESULT,
    fn put_GridViewItemPresenterVerticalContentAlignment(&self, value: super::super::VerticalAlignment) -> HRESULT,
    fn get_GridViewItemPresenterPadding(&self, out: *mut super::super::Thickness) -> HRESULT,
    fn put_GridViewItemPresenterPadding(&self, value: super::super::Thickness) -> HRESULT,
    fn get_PointerOverBackgroundMargin(&self, out: *mut super::super::Thickness) -> HRESULT,
    fn put_PointerOverBackgroundMargin(&self, value: super::super::Thickness) -> HRESULT,
    fn get_ContentMargin(&self, out: *mut super::super::Thickness) -> HRESULT,
    fn put_ContentMargin(&self, value: super::super::Thickness) -> HRESULT
}}
impl IGridViewItemPresenter {
    #[inline] pub unsafe fn get_selection_check_mark_visual_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SelectionCheckMarkVisualEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selection_check_mark_visual_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectionCheckMarkVisualEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_check_hint_brush(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CheckHintBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_check_hint_brush(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CheckHintBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_check_selecting_brush(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CheckSelectingBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_check_selecting_brush(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CheckSelectingBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_check_brush(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CheckBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_check_brush(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CheckBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drag_background(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DragBackground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_drag_background(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DragBackground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drag_foreground(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DragForeground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_drag_foreground(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DragForeground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_border_brush(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FocusBorderBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_focus_border_brush(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FocusBorderBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placeholder_background(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlaceholderBackground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_placeholder_background(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PlaceholderBackground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pointer_over_background(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointerOverBackground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_pointer_over_background(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PointerOverBackground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_background(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedBackground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_background(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedBackground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_foreground(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedForeground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_foreground(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedForeground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_pointer_over_background(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedPointerOverBackground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_pointer_over_background(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedPointerOverBackground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_pointer_over_border_brush(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedPointerOverBorderBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_pointer_over_border_brush(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedPointerOverBorderBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_border_thickness(&self) -> Result<super::super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SelectedBorderThickness)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_border_thickness(&self, value: super::super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedBorderThickness)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_disabled_opacity(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DisabledOpacity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_disabled_opacity(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisabledOpacity)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drag_opacity(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DragOpacity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_drag_opacity(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DragOpacity)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_reorder_hint_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ReorderHintOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_reorder_hint_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ReorderHintOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_grid_view_item_presenter_horizontal_content_alignment(&self) -> Result<super::super::HorizontalAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_GridViewItemPresenterHorizontalContentAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_grid_view_item_presenter_horizontal_content_alignment(&self, value: super::super::HorizontalAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_GridViewItemPresenterHorizontalContentAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_grid_view_item_presenter_vertical_content_alignment(&self) -> Result<super::super::VerticalAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_GridViewItemPresenterVerticalContentAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_grid_view_item_presenter_vertical_content_alignment(&self, value: super::super::VerticalAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_GridViewItemPresenterVerticalContentAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_grid_view_item_presenter_padding(&self) -> Result<super::super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_GridViewItemPresenterPadding)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_grid_view_item_presenter_padding(&self, value: super::super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_GridViewItemPresenterPadding)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pointer_over_background_margin(&self) -> Result<super::super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerOverBackgroundMargin)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_pointer_over_background_margin(&self, value: super::super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PointerOverBackgroundMargin)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_margin(&self) -> Result<super::super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ContentMargin)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_margin(&self, value: super::super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentMargin)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGridViewItemPresenterStatics, 3914922180, 10110, 19058, 160, 30, 158, 22, 136, 152, 1, 120);
RT_INTERFACE!{static interface IGridViewItemPresenterStatics(IGridViewItemPresenterStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGridViewItemPresenterStatics] {
    fn get_SelectionCheckMarkVisualEnabledProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_CheckHintBrushProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_CheckSelectingBrushProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_CheckBrushProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_DragBackgroundProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_DragForegroundProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_FocusBorderBrushProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_PlaceholderBackgroundProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_PointerOverBackgroundProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_SelectedBackgroundProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_SelectedForegroundProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_SelectedPointerOverBackgroundProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_SelectedPointerOverBorderBrushProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_SelectedBorderThicknessProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_DisabledOpacityProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_DragOpacityProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ReorderHintOffsetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_GridViewItemPresenterHorizontalContentAlignmentProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_GridViewItemPresenterVerticalContentAlignmentProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_GridViewItemPresenterPaddingProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_PointerOverBackgroundMarginProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ContentMarginProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IGridViewItemPresenterStatics {
    #[inline] pub unsafe fn get_selection_check_mark_visual_enabled_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionCheckMarkVisualEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_check_hint_brush_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CheckHintBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_check_selecting_brush_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CheckSelectingBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_check_brush_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CheckBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drag_background_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DragBackgroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drag_foreground_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DragForegroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_border_brush_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FocusBorderBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placeholder_background_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlaceholderBackgroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pointer_over_background_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointerOverBackgroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_background_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedBackgroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_foreground_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedForegroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_pointer_over_background_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedPointerOverBackgroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_pointer_over_border_brush_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedPointerOverBorderBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_border_thickness_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedBorderThicknessProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_disabled_opacity_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisabledOpacityProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drag_opacity_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DragOpacityProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_reorder_hint_offset_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ReorderHintOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_grid_view_item_presenter_horizontal_content_alignment_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GridViewItemPresenterHorizontalContentAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_grid_view_item_presenter_vertical_content_alignment_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GridViewItemPresenterVerticalContentAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_grid_view_item_presenter_padding_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GridViewItemPresenterPaddingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pointer_over_background_margin_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointerOverBackgroundMarginProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_margin_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentMarginProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGridViewItemPresenterFactory, 1405165944, 25531, 19045, 163, 241, 171, 17, 76, 252, 111, 254);
RT_INTERFACE!{interface IGridViewItemPresenterFactory(IGridViewItemPresenterFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGridViewItemPresenterFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut GridViewItemPresenter) -> HRESULT
}}
impl IGridViewItemPresenterFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<GridViewItemPresenter>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewItemPresenter, 4236854973, 41890, 18793, 129, 116, 37, 181, 211, 194, 128, 51);
RT_INTERFACE!{interface IListViewItemPresenter(IListViewItemPresenterVtbl): IInspectable(IInspectableVtbl) [IID_IListViewItemPresenter] {
    fn get_SelectionCheckMarkVisualEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_SelectionCheckMarkVisualEnabled(&self, value: bool) -> HRESULT,
    fn get_CheckHintBrush(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_CheckHintBrush(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_CheckSelectingBrush(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_CheckSelectingBrush(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_CheckBrush(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_CheckBrush(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_DragBackground(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_DragBackground(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_DragForeground(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_DragForeground(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_FocusBorderBrush(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_FocusBorderBrush(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_PlaceholderBackground(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_PlaceholderBackground(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_PointerOverBackground(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_PointerOverBackground(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_SelectedBackground(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_SelectedBackground(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_SelectedForeground(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_SelectedForeground(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_SelectedPointerOverBackground(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_SelectedPointerOverBackground(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_SelectedPointerOverBorderBrush(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_SelectedPointerOverBorderBrush(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_SelectedBorderThickness(&self, out: *mut super::super::Thickness) -> HRESULT,
    fn put_SelectedBorderThickness(&self, value: super::super::Thickness) -> HRESULT,
    fn get_DisabledOpacity(&self, out: *mut f64) -> HRESULT,
    fn put_DisabledOpacity(&self, value: f64) -> HRESULT,
    fn get_DragOpacity(&self, out: *mut f64) -> HRESULT,
    fn put_DragOpacity(&self, value: f64) -> HRESULT,
    fn get_ReorderHintOffset(&self, out: *mut f64) -> HRESULT,
    fn put_ReorderHintOffset(&self, value: f64) -> HRESULT,
    fn get_ListViewItemPresenterHorizontalContentAlignment(&self, out: *mut super::super::HorizontalAlignment) -> HRESULT,
    fn put_ListViewItemPresenterHorizontalContentAlignment(&self, value: super::super::HorizontalAlignment) -> HRESULT,
    fn get_ListViewItemPresenterVerticalContentAlignment(&self, out: *mut super::super::VerticalAlignment) -> HRESULT,
    fn put_ListViewItemPresenterVerticalContentAlignment(&self, value: super::super::VerticalAlignment) -> HRESULT,
    fn get_ListViewItemPresenterPadding(&self, out: *mut super::super::Thickness) -> HRESULT,
    fn put_ListViewItemPresenterPadding(&self, value: super::super::Thickness) -> HRESULT,
    fn get_PointerOverBackgroundMargin(&self, out: *mut super::super::Thickness) -> HRESULT,
    fn put_PointerOverBackgroundMargin(&self, value: super::super::Thickness) -> HRESULT,
    fn get_ContentMargin(&self, out: *mut super::super::Thickness) -> HRESULT,
    fn put_ContentMargin(&self, value: super::super::Thickness) -> HRESULT
}}
impl IListViewItemPresenter {
    #[inline] pub unsafe fn get_selection_check_mark_visual_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SelectionCheckMarkVisualEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selection_check_mark_visual_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectionCheckMarkVisualEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_check_hint_brush(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CheckHintBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_check_hint_brush(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CheckHintBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_check_selecting_brush(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CheckSelectingBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_check_selecting_brush(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CheckSelectingBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_check_brush(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CheckBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_check_brush(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CheckBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drag_background(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DragBackground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_drag_background(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DragBackground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drag_foreground(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DragForeground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_drag_foreground(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DragForeground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_border_brush(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FocusBorderBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_focus_border_brush(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FocusBorderBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placeholder_background(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlaceholderBackground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_placeholder_background(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PlaceholderBackground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pointer_over_background(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointerOverBackground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_pointer_over_background(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PointerOverBackground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_background(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedBackground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_background(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedBackground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_foreground(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedForeground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_foreground(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedForeground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_pointer_over_background(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedPointerOverBackground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_pointer_over_background(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedPointerOverBackground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_pointer_over_border_brush(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedPointerOverBorderBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_pointer_over_border_brush(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedPointerOverBorderBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_border_thickness(&self) -> Result<super::super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SelectedBorderThickness)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_border_thickness(&self, value: super::super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedBorderThickness)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_disabled_opacity(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DisabledOpacity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_disabled_opacity(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisabledOpacity)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drag_opacity(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DragOpacity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_drag_opacity(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DragOpacity)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_reorder_hint_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ReorderHintOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_reorder_hint_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ReorderHintOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_list_view_item_presenter_horizontal_content_alignment(&self) -> Result<super::super::HorizontalAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ListViewItemPresenterHorizontalContentAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_list_view_item_presenter_horizontal_content_alignment(&self, value: super::super::HorizontalAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ListViewItemPresenterHorizontalContentAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_list_view_item_presenter_vertical_content_alignment(&self) -> Result<super::super::VerticalAlignment> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ListViewItemPresenterVerticalContentAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_list_view_item_presenter_vertical_content_alignment(&self, value: super::super::VerticalAlignment) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ListViewItemPresenterVerticalContentAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_list_view_item_presenter_padding(&self) -> Result<super::super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ListViewItemPresenterPadding)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_list_view_item_presenter_padding(&self, value: super::super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ListViewItemPresenterPadding)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pointer_over_background_margin(&self) -> Result<super::super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerOverBackgroundMargin)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_pointer_over_background_margin(&self, value: super::super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PointerOverBackgroundMargin)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_margin(&self) -> Result<super::super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ContentMargin)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_margin(&self, value: super::super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentMargin)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewItemPresenterStatics, 1694803290, 5597, 17147, 170, 93, 45, 140, 226, 233, 194, 148);
RT_INTERFACE!{static interface IListViewItemPresenterStatics(IListViewItemPresenterStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IListViewItemPresenterStatics] {
    fn get_SelectionCheckMarkVisualEnabledProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_CheckHintBrushProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_CheckSelectingBrushProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_CheckBrushProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_DragBackgroundProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_DragForegroundProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_FocusBorderBrushProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_PlaceholderBackgroundProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_PointerOverBackgroundProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_SelectedBackgroundProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_SelectedForegroundProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_SelectedPointerOverBackgroundProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_SelectedPointerOverBorderBrushProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_SelectedBorderThicknessProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_DisabledOpacityProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_DragOpacityProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ReorderHintOffsetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ListViewItemPresenterHorizontalContentAlignmentProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ListViewItemPresenterVerticalContentAlignmentProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ListViewItemPresenterPaddingProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_PointerOverBackgroundMarginProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ContentMarginProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IListViewItemPresenterStatics {
    #[inline] pub unsafe fn get_selection_check_mark_visual_enabled_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionCheckMarkVisualEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_check_hint_brush_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CheckHintBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_check_selecting_brush_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CheckSelectingBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_check_brush_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CheckBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drag_background_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DragBackgroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drag_foreground_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DragForegroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_border_brush_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FocusBorderBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placeholder_background_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlaceholderBackgroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pointer_over_background_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointerOverBackgroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_background_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedBackgroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_foreground_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedForegroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_pointer_over_background_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedPointerOverBackgroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_pointer_over_border_brush_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedPointerOverBorderBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_border_thickness_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedBorderThicknessProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_disabled_opacity_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisabledOpacityProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drag_opacity_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DragOpacityProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_reorder_hint_offset_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ReorderHintOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_list_view_item_presenter_horizontal_content_alignment_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ListViewItemPresenterHorizontalContentAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_list_view_item_presenter_vertical_content_alignment_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ListViewItemPresenterVerticalContentAlignmentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_list_view_item_presenter_padding_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ListViewItemPresenterPaddingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pointer_over_background_margin_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointerOverBackgroundMarginProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_margin_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentMarginProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewItemPresenterFactory, 3765927165, 63460, 19047, 154, 192, 169, 148, 252, 172, 208, 32);
RT_INTERFACE!{interface IListViewItemPresenterFactory(IListViewItemPresenterFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IListViewItemPresenterFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ListViewItemPresenter) -> HRESULT
}}
impl IListViewItemPresenterFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ListViewItemPresenter>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewItemPresenter2, 4124857494, 57634, 19543, 166, 37, 172, 75, 8, 251, 45, 76);
RT_INTERFACE!{interface IListViewItemPresenter2(IListViewItemPresenter2Vtbl): IInspectable(IInspectableVtbl) [IID_IListViewItemPresenter2] {
    fn get_SelectedPressedBackground(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_SelectedPressedBackground(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_PressedBackground(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_PressedBackground(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_CheckBoxBrush(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_CheckBoxBrush(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_FocusSecondaryBorderBrush(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_FocusSecondaryBorderBrush(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_CheckMode(&self, out: *mut ListViewItemPresenterCheckMode) -> HRESULT,
    fn put_CheckMode(&self, value: ListViewItemPresenterCheckMode) -> HRESULT,
    fn get_PointerOverForeground(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_PointerOverForeground(&self, value: *mut super::super::media::Brush) -> HRESULT
}}
impl IListViewItemPresenter2 {
    #[inline] pub unsafe fn get_selected_pressed_background(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedPressedBackground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_pressed_background(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedPressedBackground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pressed_background(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PressedBackground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_pressed_background(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PressedBackground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_check_box_brush(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CheckBoxBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_check_box_brush(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CheckBoxBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_secondary_border_brush(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FocusSecondaryBorderBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_focus_secondary_border_brush(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FocusSecondaryBorderBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_check_mode(&self) -> Result<ListViewItemPresenterCheckMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CheckMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_check_mode(&self, value: ListViewItemPresenterCheckMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CheckMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pointer_over_foreground(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointerOverForeground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_pointer_over_foreground(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PointerOverForeground)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewItemPresenterStatics2, 1286846789, 53837, 17059, 158, 131, 168, 109, 6, 24, 191, 27);
RT_INTERFACE!{static interface IListViewItemPresenterStatics2(IListViewItemPresenterStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IListViewItemPresenterStatics2] {
    fn get_SelectedPressedBackgroundProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_PressedBackgroundProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_CheckBoxBrushProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_FocusSecondaryBorderBrushProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_CheckModeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_PointerOverForegroundProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IListViewItemPresenterStatics2 {
    #[inline] pub unsafe fn get_selected_pressed_background_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedPressedBackgroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pressed_background_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PressedBackgroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_check_box_brush_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CheckBoxBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_secondary_border_brush_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FocusSecondaryBorderBrushProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_check_mode_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CheckModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pointer_over_foreground_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointerOverForegroundProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum AnimationDirection: i32 {
    Left (AnimationDirection_Left) = 0, Top (AnimationDirection_Top) = 1, Right (AnimationDirection_Right) = 2, Bottom (AnimationDirection_Bottom) = 3,
}}
RT_ENUM! { enum ComponentResourceLocation: i32 {
    Application (ComponentResourceLocation_Application) = 0, Nested (ComponentResourceLocation_Nested) = 1,
}}
RT_ENUM! { enum EdgeTransitionLocation: i32 {
    Left (EdgeTransitionLocation_Left) = 0, Top (EdgeTransitionLocation_Top) = 1, Right (EdgeTransitionLocation_Right) = 2, Bottom (EdgeTransitionLocation_Bottom) = 3,
}}
RT_ENUM! { enum FlyoutPlacementMode: i32 {
    Top (FlyoutPlacementMode_Top) = 0, Bottom (FlyoutPlacementMode_Bottom) = 1, Left (FlyoutPlacementMode_Left) = 2, Right (FlyoutPlacementMode_Right) = 3, Full (FlyoutPlacementMode_Full) = 4,
}}
RT_STRUCT! { struct GeneratorPosition {
    Index: i32, Offset: i32,
}}
DEFINE_IID!(IID_IGeneratorPositionHelper, 3443536269, 30533, 16601, 171, 157, 171, 189, 164, 167, 255, 234);
RT_INTERFACE!{interface IGeneratorPositionHelper(IGeneratorPositionHelperVtbl): IInspectable(IInspectableVtbl) [IID_IGeneratorPositionHelper] {
    
}}
DEFINE_IID!(IID_IGeneratorPositionHelperStatics, 2906691021, 24812, 17800, 141, 96, 57, 210, 144, 151, 164, 223);
RT_INTERFACE!{static interface IGeneratorPositionHelperStatics(IGeneratorPositionHelperStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGeneratorPositionHelperStatics] {
    fn FromIndexAndOffset(&self, index: i32, offset: i32, out: *mut GeneratorPosition) -> HRESULT
}}
impl IGeneratorPositionHelperStatics {
    #[inline] pub unsafe fn from_index_and_offset(&self, index: i32, offset: i32) -> Result<GeneratorPosition> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).FromIndexAndOffset)(self as *const _ as *mut _, index, offset, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class GeneratorPositionHelper: IGeneratorPositionHelper}
impl RtActivatable<IGeneratorPositionHelperStatics> for GeneratorPositionHelper {}
impl GeneratorPositionHelper {
    #[inline] pub fn from_index_and_offset(index: i32, offset: i32) -> Result<GeneratorPosition> { unsafe {
        <Self as RtActivatable<IGeneratorPositionHelperStatics>>::get_activation_factory().from_index_and_offset(index, offset)
    }}
}
DEFINE_CLSID!(GeneratorPositionHelper(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,71,101,110,101,114,97,116,111,114,80,111,115,105,116,105,111,110,72,101,108,112,101,114,0]) [CLSID_GeneratorPositionHelper]);
RT_CLASS!{class ProgressRingTemplateSettings: IProgressRingTemplateSettings}
RT_CLASS!{class ToggleSwitchTemplateSettings: IToggleSwitchTemplateSettings}
RT_CLASS!{class ProgressBarTemplateSettings: IProgressBarTemplateSettings}
RT_CLASS!{class SettingsFlyoutTemplateSettings: ISettingsFlyoutTemplateSettings}
RT_CLASS!{class ToolTipTemplateSettings: IToolTipTemplateSettings}
RT_CLASS!{class ComboBoxTemplateSettings: IComboBoxTemplateSettings}
RT_CLASS!{class GridViewItemTemplateSettings: IGridViewItemTemplateSettings}
RT_CLASS!{class ListViewItemTemplateSettings: IListViewItemTemplateSettings}
RT_CLASS!{class MenuFlyoutPresenterTemplateSettings: IMenuFlyoutPresenterTemplateSettings}
RT_CLASS!{class CalendarViewTemplateSettings: ICalendarViewTemplateSettings}
RT_CLASS!{class SplitViewTemplateSettings: ISplitViewTemplateSettings}
RT_CLASS!{class AppBarTemplateSettings: IAppBarTemplateSettings}
RT_CLASS!{class CommandBarTemplateSettings: ICommandBarTemplateSettings}
RT_CLASS!{class DragCompletedEventArgs: IDragCompletedEventArgs}
RT_CLASS!{class DragDeltaEventArgs: IDragDeltaEventArgs}
RT_CLASS!{class DragStartedEventArgs: IDragStartedEventArgs}
RT_CLASS!{class RangeBaseValueChangedEventArgs: IRangeBaseValueChangedEventArgs}
RT_CLASS!{class ScrollEventArgs: IScrollEventArgs}
impl RtActivatable<IActivationFactory> for ScrollEventArgs {}
DEFINE_CLSID!(ScrollEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,83,99,114,111,108,108,69,118,101,110,116,65,114,103,115,0]) [CLSID_ScrollEventArgs]);
RT_CLASS!{class Popup: IPopup}
impl RtActivatable<IPopupStatics2> for Popup {}
impl RtActivatable<IPopupStatics> for Popup {}
impl RtActivatable<IActivationFactory> for Popup {}
impl Popup {
    #[inline] pub fn get_light_dismiss_overlay_mode_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPopupStatics2>>::get_activation_factory().get_light_dismiss_overlay_mode_property()
    }}
    #[inline] pub fn get_child_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPopupStatics>>::get_activation_factory().get_child_property()
    }}
    #[inline] pub fn get_is_open_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPopupStatics>>::get_activation_factory().get_is_open_property()
    }}
    #[inline] pub fn get_horizontal_offset_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPopupStatics>>::get_activation_factory().get_horizontal_offset_property()
    }}
    #[inline] pub fn get_vertical_offset_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPopupStatics>>::get_activation_factory().get_vertical_offset_property()
    }}
    #[inline] pub fn get_child_transitions_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPopupStatics>>::get_activation_factory().get_child_transitions_property()
    }}
    #[inline] pub fn get_is_light_dismiss_enabled_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPopupStatics>>::get_activation_factory().get_is_light_dismiss_enabled_property()
    }}
}
DEFINE_CLSID!(Popup(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,80,111,112,117,112,0]) [CLSID_Popup]);
RT_CLASS!{class TickBar: ITickBar}
impl RtActivatable<ITickBarStatics> for TickBar {}
impl RtActivatable<IActivationFactory> for TickBar {}
impl TickBar {
    #[inline] pub fn get_fill_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITickBarStatics>>::get_activation_factory().get_fill_property()
    }}
}
DEFINE_CLSID!(TickBar(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,84,105,99,107,66,97,114,0]) [CLSID_TickBar]);
RT_CLASS!{class CarouselPanel: ICarouselPanel}
RT_CLASS!{class OrientedVirtualizingPanel: IOrientedVirtualizingPanel}
RT_CLASS!{class CalendarPanel: ICalendarPanel}
impl RtActivatable<IActivationFactory> for CalendarPanel {}
DEFINE_CLSID!(CalendarPanel(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,67,97,108,101,110,100,97,114,80,97,110,101,108,0]) [CLSID_CalendarPanel]);
RT_CLASS!{class GridViewItemPresenter: IGridViewItemPresenter}
impl RtActivatable<IGridViewItemPresenterStatics> for GridViewItemPresenter {}
impl GridViewItemPresenter {
    #[inline] pub fn get_selection_check_mark_visual_enabled_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridViewItemPresenterStatics>>::get_activation_factory().get_selection_check_mark_visual_enabled_property()
    }}
    #[inline] pub fn get_check_hint_brush_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridViewItemPresenterStatics>>::get_activation_factory().get_check_hint_brush_property()
    }}
    #[inline] pub fn get_check_selecting_brush_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridViewItemPresenterStatics>>::get_activation_factory().get_check_selecting_brush_property()
    }}
    #[inline] pub fn get_check_brush_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridViewItemPresenterStatics>>::get_activation_factory().get_check_brush_property()
    }}
    #[inline] pub fn get_drag_background_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridViewItemPresenterStatics>>::get_activation_factory().get_drag_background_property()
    }}
    #[inline] pub fn get_drag_foreground_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridViewItemPresenterStatics>>::get_activation_factory().get_drag_foreground_property()
    }}
    #[inline] pub fn get_focus_border_brush_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridViewItemPresenterStatics>>::get_activation_factory().get_focus_border_brush_property()
    }}
    #[inline] pub fn get_placeholder_background_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridViewItemPresenterStatics>>::get_activation_factory().get_placeholder_background_property()
    }}
    #[inline] pub fn get_pointer_over_background_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridViewItemPresenterStatics>>::get_activation_factory().get_pointer_over_background_property()
    }}
    #[inline] pub fn get_selected_background_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridViewItemPresenterStatics>>::get_activation_factory().get_selected_background_property()
    }}
    #[inline] pub fn get_selected_foreground_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridViewItemPresenterStatics>>::get_activation_factory().get_selected_foreground_property()
    }}
    #[inline] pub fn get_selected_pointer_over_background_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridViewItemPresenterStatics>>::get_activation_factory().get_selected_pointer_over_background_property()
    }}
    #[inline] pub fn get_selected_pointer_over_border_brush_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridViewItemPresenterStatics>>::get_activation_factory().get_selected_pointer_over_border_brush_property()
    }}
    #[inline] pub fn get_selected_border_thickness_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridViewItemPresenterStatics>>::get_activation_factory().get_selected_border_thickness_property()
    }}
    #[inline] pub fn get_disabled_opacity_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridViewItemPresenterStatics>>::get_activation_factory().get_disabled_opacity_property()
    }}
    #[inline] pub fn get_drag_opacity_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridViewItemPresenterStatics>>::get_activation_factory().get_drag_opacity_property()
    }}
    #[inline] pub fn get_reorder_hint_offset_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridViewItemPresenterStatics>>::get_activation_factory().get_reorder_hint_offset_property()
    }}
    #[inline] pub fn get_grid_view_item_presenter_horizontal_content_alignment_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridViewItemPresenterStatics>>::get_activation_factory().get_grid_view_item_presenter_horizontal_content_alignment_property()
    }}
    #[inline] pub fn get_grid_view_item_presenter_vertical_content_alignment_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridViewItemPresenterStatics>>::get_activation_factory().get_grid_view_item_presenter_vertical_content_alignment_property()
    }}
    #[inline] pub fn get_grid_view_item_presenter_padding_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridViewItemPresenterStatics>>::get_activation_factory().get_grid_view_item_presenter_padding_property()
    }}
    #[inline] pub fn get_pointer_over_background_margin_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridViewItemPresenterStatics>>::get_activation_factory().get_pointer_over_background_margin_property()
    }}
    #[inline] pub fn get_content_margin_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGridViewItemPresenterStatics>>::get_activation_factory().get_content_margin_property()
    }}
}
DEFINE_CLSID!(GridViewItemPresenter(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,71,114,105,100,86,105,101,119,73,116,101,109,80,114,101,115,101,110,116,101,114,0]) [CLSID_GridViewItemPresenter]);
RT_CLASS!{class ListViewItemPresenter: IListViewItemPresenter}
impl RtActivatable<IListViewItemPresenterStatics> for ListViewItemPresenter {}
impl RtActivatable<IListViewItemPresenterStatics2> for ListViewItemPresenter {}
impl ListViewItemPresenter {
    #[inline] pub fn get_selection_check_mark_visual_enabled_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics>>::get_activation_factory().get_selection_check_mark_visual_enabled_property()
    }}
    #[inline] pub fn get_check_hint_brush_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics>>::get_activation_factory().get_check_hint_brush_property()
    }}
    #[inline] pub fn get_check_selecting_brush_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics>>::get_activation_factory().get_check_selecting_brush_property()
    }}
    #[inline] pub fn get_check_brush_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics>>::get_activation_factory().get_check_brush_property()
    }}
    #[inline] pub fn get_drag_background_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics>>::get_activation_factory().get_drag_background_property()
    }}
    #[inline] pub fn get_drag_foreground_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics>>::get_activation_factory().get_drag_foreground_property()
    }}
    #[inline] pub fn get_focus_border_brush_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics>>::get_activation_factory().get_focus_border_brush_property()
    }}
    #[inline] pub fn get_placeholder_background_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics>>::get_activation_factory().get_placeholder_background_property()
    }}
    #[inline] pub fn get_pointer_over_background_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics>>::get_activation_factory().get_pointer_over_background_property()
    }}
    #[inline] pub fn get_selected_background_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics>>::get_activation_factory().get_selected_background_property()
    }}
    #[inline] pub fn get_selected_foreground_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics>>::get_activation_factory().get_selected_foreground_property()
    }}
    #[inline] pub fn get_selected_pointer_over_background_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics>>::get_activation_factory().get_selected_pointer_over_background_property()
    }}
    #[inline] pub fn get_selected_pointer_over_border_brush_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics>>::get_activation_factory().get_selected_pointer_over_border_brush_property()
    }}
    #[inline] pub fn get_selected_border_thickness_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics>>::get_activation_factory().get_selected_border_thickness_property()
    }}
    #[inline] pub fn get_disabled_opacity_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics>>::get_activation_factory().get_disabled_opacity_property()
    }}
    #[inline] pub fn get_drag_opacity_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics>>::get_activation_factory().get_drag_opacity_property()
    }}
    #[inline] pub fn get_reorder_hint_offset_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics>>::get_activation_factory().get_reorder_hint_offset_property()
    }}
    #[inline] pub fn get_list_view_item_presenter_horizontal_content_alignment_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics>>::get_activation_factory().get_list_view_item_presenter_horizontal_content_alignment_property()
    }}
    #[inline] pub fn get_list_view_item_presenter_vertical_content_alignment_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics>>::get_activation_factory().get_list_view_item_presenter_vertical_content_alignment_property()
    }}
    #[inline] pub fn get_list_view_item_presenter_padding_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics>>::get_activation_factory().get_list_view_item_presenter_padding_property()
    }}
    #[inline] pub fn get_pointer_over_background_margin_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics>>::get_activation_factory().get_pointer_over_background_margin_property()
    }}
    #[inline] pub fn get_content_margin_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics>>::get_activation_factory().get_content_margin_property()
    }}
    #[inline] pub fn get_selected_pressed_background_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics2>>::get_activation_factory().get_selected_pressed_background_property()
    }}
    #[inline] pub fn get_pressed_background_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics2>>::get_activation_factory().get_pressed_background_property()
    }}
    #[inline] pub fn get_check_box_brush_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics2>>::get_activation_factory().get_check_box_brush_property()
    }}
    #[inline] pub fn get_focus_secondary_border_brush_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics2>>::get_activation_factory().get_focus_secondary_border_brush_property()
    }}
    #[inline] pub fn get_check_mode_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics2>>::get_activation_factory().get_check_mode_property()
    }}
    #[inline] pub fn get_pointer_over_foreground_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IListViewItemPresenterStatics2>>::get_activation_factory().get_pointer_over_foreground_property()
    }}
}
DEFINE_CLSID!(ListViewItemPresenter(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,76,105,115,116,86,105,101,119,73,116,101,109,80,114,101,115,101,110,116,101,114,0]) [CLSID_ListViewItemPresenter]);
RT_CLASS!{class SelectorItem: ISelectorItem}
impl RtActivatable<ISelectorItemStatics> for SelectorItem {}
impl SelectorItem {
    #[inline] pub fn get_is_selected_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISelectorItemStatics>>::get_activation_factory().get_is_selected_property()
    }}
}
DEFINE_CLSID!(SelectorItem(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,83,101,108,101,99,116,111,114,73,116,101,109,0]) [CLSID_SelectorItem]);
RT_CLASS!{class RangeBase: IRangeBase}
impl RtActivatable<IRangeBaseStatics> for RangeBase {}
impl RangeBase {
    #[inline] pub fn get_minimum_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRangeBaseStatics>>::get_activation_factory().get_minimum_property()
    }}
    #[inline] pub fn get_maximum_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRangeBaseStatics>>::get_activation_factory().get_maximum_property()
    }}
    #[inline] pub fn get_small_change_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRangeBaseStatics>>::get_activation_factory().get_small_change_property()
    }}
    #[inline] pub fn get_large_change_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRangeBaseStatics>>::get_activation_factory().get_large_change_property()
    }}
    #[inline] pub fn get_value_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRangeBaseStatics>>::get_activation_factory().get_value_property()
    }}
}
DEFINE_CLSID!(RangeBase(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,82,97,110,103,101,66,97,115,101,0]) [CLSID_RangeBase]);
RT_CLASS!{class Thumb: IThumb}
impl RtActivatable<IThumbStatics> for Thumb {}
impl RtActivatable<IActivationFactory> for Thumb {}
impl Thumb {
    #[inline] pub fn get_is_dragging_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IThumbStatics>>::get_activation_factory().get_is_dragging_property()
    }}
}
DEFINE_CLSID!(Thumb(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,84,104,117,109,98,0]) [CLSID_Thumb]);
RT_CLASS!{class ButtonBase: IButtonBase}
impl RtActivatable<IButtonBaseStatics> for ButtonBase {}
impl ButtonBase {
    #[inline] pub fn get_click_mode_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IButtonBaseStatics>>::get_activation_factory().get_click_mode_property()
    }}
    #[inline] pub fn get_is_pointer_over_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IButtonBaseStatics>>::get_activation_factory().get_is_pointer_over_property()
    }}
    #[inline] pub fn get_is_pressed_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IButtonBaseStatics>>::get_activation_factory().get_is_pressed_property()
    }}
    #[inline] pub fn get_command_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IButtonBaseStatics>>::get_activation_factory().get_command_property()
    }}
    #[inline] pub fn get_command_parameter_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IButtonBaseStatics>>::get_activation_factory().get_command_parameter_property()
    }}
}
DEFINE_CLSID!(ButtonBase(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,66,117,116,116,111,110,66,97,115,101,0]) [CLSID_ButtonBase]);
RT_CLASS!{class ScrollBar: IScrollBar}
impl RtActivatable<IScrollBarStatics> for ScrollBar {}
impl RtActivatable<IActivationFactory> for ScrollBar {}
impl ScrollBar {
    #[inline] pub fn get_orientation_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollBarStatics>>::get_activation_factory().get_orientation_property()
    }}
    #[inline] pub fn get_viewport_size_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollBarStatics>>::get_activation_factory().get_viewport_size_property()
    }}
    #[inline] pub fn get_indicator_mode_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScrollBarStatics>>::get_activation_factory().get_indicator_mode_property()
    }}
}
DEFINE_CLSID!(ScrollBar(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,83,99,114,111,108,108,66,97,114,0]) [CLSID_ScrollBar]);
RT_CLASS!{class Selector: ISelector}
impl RtActivatable<ISelectorStatics> for Selector {}
impl Selector {
    #[inline] pub fn get_selected_index_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISelectorStatics>>::get_activation_factory().get_selected_index_property()
    }}
    #[inline] pub fn get_selected_item_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISelectorStatics>>::get_activation_factory().get_selected_item_property()
    }}
    #[inline] pub fn get_selected_value_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISelectorStatics>>::get_activation_factory().get_selected_value_property()
    }}
    #[inline] pub fn get_selected_value_path_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISelectorStatics>>::get_activation_factory().get_selected_value_path_property()
    }}
    #[inline] pub fn get_is_synchronized_with_current_item_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISelectorStatics>>::get_activation_factory().get_is_synchronized_with_current_item_property()
    }}
    #[inline] pub fn get_is_selection_active(element: &super::super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<ISelectorStatics>>::get_activation_factory().get_is_selection_active(element)
    }}
}
DEFINE_CLSID!(Selector(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,83,101,108,101,99,116,111,114,0]) [CLSID_Selector]);
RT_CLASS!{class RepeatButton: IRepeatButton}
impl RtActivatable<IRepeatButtonStatics> for RepeatButton {}
impl RtActivatable<IActivationFactory> for RepeatButton {}
impl RepeatButton {
    #[inline] pub fn get_delay_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRepeatButtonStatics>>::get_activation_factory().get_delay_property()
    }}
    #[inline] pub fn get_interval_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRepeatButtonStatics>>::get_activation_factory().get_interval_property()
    }}
}
DEFINE_CLSID!(RepeatButton(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,82,101,112,101,97,116,66,117,116,116,111,110,0]) [CLSID_RepeatButton]);
RT_CLASS!{class ToggleButton: IToggleButton}
impl RtActivatable<IToggleButtonStatics> for ToggleButton {}
impl ToggleButton {
    #[inline] pub fn get_is_checked_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IToggleButtonStatics>>::get_activation_factory().get_is_checked_property()
    }}
    #[inline] pub fn get_is_three_state_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IToggleButtonStatics>>::get_activation_factory().get_is_three_state_property()
    }}
}
DEFINE_CLSID!(ToggleButton(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,84,111,103,103,108,101,66,117,116,116,111,110,0]) [CLSID_ToggleButton]);
DEFINE_IID!(IID_IFlyoutBaseClosingEventArgs, 3497362733, 45210, 20433, 176, 5, 219, 43, 160, 18, 6, 251);
RT_INTERFACE!{interface IFlyoutBaseClosingEventArgs(IFlyoutBaseClosingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IFlyoutBaseClosingEventArgs] {
    fn get_Cancel(&self, out: *mut bool) -> HRESULT,
    fn put_Cancel(&self, value: bool) -> HRESULT
}}
impl IFlyoutBaseClosingEventArgs {
    #[inline] pub unsafe fn get_cancel(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cancel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_cancel(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Cancel)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class FlyoutBaseClosingEventArgs: IFlyoutBaseClosingEventArgs}
DEFINE_IID!(IID_IFlyoutBase, 1916725771, 53550, 17165, 169, 240, 155, 179, 43, 191, 153, 19);
RT_INTERFACE!{interface IFlyoutBase(IFlyoutBaseVtbl): IInspectable(IInspectableVtbl) [IID_IFlyoutBase] {
    fn get_Placement(&self, out: *mut FlyoutPlacementMode) -> HRESULT,
    fn put_Placement(&self, value: FlyoutPlacementMode) -> HRESULT,
    fn add_Opened(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Opened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Closed(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Opening(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Opening(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn ShowAt(&self, placementTarget: *mut super::super::FrameworkElement) -> HRESULT,
    fn Hide(&self) -> HRESULT
}}
impl IFlyoutBase {
    #[inline] pub unsafe fn get_placement(&self) -> Result<FlyoutPlacementMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Placement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_placement(&self, value: FlyoutPlacementMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Placement)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_opened(&self, value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Opened)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_opened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Opened)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_closed(&self, value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Closed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_closed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Closed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_opening(&self, value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Opening)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_opening(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Opening)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_at(&self, placementTarget: &super::super::FrameworkElement) -> Result<()> {
        let hr = ((*self.lpVtbl).ShowAt)(self as *const _ as *mut _, placementTarget as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn hide(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Hide)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFlyoutBaseOverrides, 270396550, 28493, 17828, 157, 14, 62, 206, 111, 22, 151, 126);
RT_INTERFACE!{interface IFlyoutBaseOverrides(IFlyoutBaseOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IFlyoutBaseOverrides] {
    fn CreatePresenter(&self, out: *mut *mut super::Control) -> HRESULT
}}
impl IFlyoutBaseOverrides {
    #[inline] pub unsafe fn create_presenter(&self) -> Result<ComPtr<super::Control>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreatePresenter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFlyoutBaseStatics, 3805779427, 34240, 19938, 186, 193, 82, 148, 202, 1, 26, 120);
RT_INTERFACE!{static interface IFlyoutBaseStatics(IFlyoutBaseStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IFlyoutBaseStatics] {
    fn get_PlacementProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_AttachedFlyoutProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn GetAttachedFlyout(&self, element: *mut super::super::FrameworkElement, out: *mut *mut FlyoutBase) -> HRESULT,
    fn SetAttachedFlyout(&self, element: *mut super::super::FrameworkElement, value: *mut FlyoutBase) -> HRESULT,
    fn ShowAttachedFlyout(&self, flyoutOwner: *mut super::super::FrameworkElement) -> HRESULT
}}
impl IFlyoutBaseStatics {
    #[inline] pub unsafe fn get_placement_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlacementProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_attached_flyout_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AttachedFlyoutProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_attached_flyout(&self, element: &super::super::FrameworkElement) -> Result<ComPtr<FlyoutBase>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAttachedFlyout)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_attached_flyout(&self, element: &super::super::FrameworkElement, value: &FlyoutBase) -> Result<()> {
        let hr = ((*self.lpVtbl).SetAttachedFlyout)(self as *const _ as *mut _, element as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_attached_flyout(&self, flyoutOwner: &super::super::FrameworkElement) -> Result<()> {
        let hr = ((*self.lpVtbl).ShowAttachedFlyout)(self as *const _ as *mut _, flyoutOwner as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFlyoutBaseFactory, 473129943, 64679, 16510, 146, 14, 112, 225, 94, 159, 11, 241);
RT_INTERFACE!{interface IFlyoutBaseFactory(IFlyoutBaseFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IFlyoutBaseFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut FlyoutBase) -> HRESULT
}}
impl IFlyoutBaseFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<FlyoutBase>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFlyoutBase2, 4163584862, 26035, 16838, 169, 226, 119, 182, 123, 196, 192, 12);
RT_INTERFACE!{interface IFlyoutBase2(IFlyoutBase2Vtbl): IInspectable(IInspectableVtbl) [IID_IFlyoutBase2] {
    fn get_Target(&self, out: *mut *mut super::super::FrameworkElement) -> HRESULT,
    fn get_AllowFocusOnInteraction(&self, out: *mut bool) -> HRESULT,
    fn put_AllowFocusOnInteraction(&self, value: bool) -> HRESULT,
    fn get_LightDismissOverlayMode(&self, out: *mut super::LightDismissOverlayMode) -> HRESULT,
    fn put_LightDismissOverlayMode(&self, value: super::LightDismissOverlayMode) -> HRESULT,
    fn get_AllowFocusWhenDisabled(&self, out: *mut bool) -> HRESULT,
    fn put_AllowFocusWhenDisabled(&self, value: bool) -> HRESULT,
    fn get_ElementSoundMode(&self, out: *mut super::super::ElementSoundMode) -> HRESULT,
    fn put_ElementSoundMode(&self, value: super::super::ElementSoundMode) -> HRESULT,
    fn add_Closing(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<FlyoutBase, FlyoutBaseClosingEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closing(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IFlyoutBase2 {
    #[inline] pub unsafe fn get_target(&self) -> Result<ComPtr<super::super::FrameworkElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Target)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_allow_focus_on_interaction(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AllowFocusOnInteraction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_allow_focus_on_interaction(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AllowFocusOnInteraction)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_light_dismiss_overlay_mode(&self) -> Result<super::LightDismissOverlayMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LightDismissOverlayMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_light_dismiss_overlay_mode(&self, value: super::LightDismissOverlayMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LightDismissOverlayMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_allow_focus_when_disabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AllowFocusWhenDisabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_allow_focus_when_disabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AllowFocusWhenDisabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_element_sound_mode(&self) -> Result<super::super::ElementSoundMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ElementSoundMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_element_sound_mode(&self, value: super::super::ElementSoundMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ElementSoundMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_closing(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<FlyoutBase, FlyoutBaseClosingEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Closing)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_closing(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Closing)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFlyoutBaseStatics2, 2833847294, 11616, 17159, 170, 217, 86, 180, 80, 18, 27, 88);
RT_INTERFACE!{static interface IFlyoutBaseStatics2(IFlyoutBaseStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IFlyoutBaseStatics2] {
    fn get_AllowFocusOnInteractionProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_LightDismissOverlayModeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_AllowFocusWhenDisabledProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ElementSoundModeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IFlyoutBaseStatics2 {
    #[inline] pub unsafe fn get_allow_focus_on_interaction_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AllowFocusOnInteractionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_light_dismiss_overlay_mode_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LightDismissOverlayModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_allow_focus_when_disabled_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AllowFocusWhenDisabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_element_sound_mode_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ElementSoundModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFlyoutBase3, 2828834578, 18656, 16960, 149, 185, 13, 253, 8, 38, 168, 211);
RT_INTERFACE!{interface IFlyoutBase3(IFlyoutBase3Vtbl): IInspectable(IInspectableVtbl) [IID_IFlyoutBase3] {
    fn get_OverlayInputPassThroughElement(&self, out: *mut *mut super::super::DependencyObject) -> HRESULT,
    fn put_OverlayInputPassThroughElement(&self, value: *mut super::super::DependencyObject) -> HRESULT
}}
impl IFlyoutBase3 {
    #[inline] pub unsafe fn get_overlay_input_pass_through_element(&self) -> Result<ComPtr<super::super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OverlayInputPassThroughElement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_overlay_input_pass_through_element(&self, value: &super::super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OverlayInputPassThroughElement)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class FlyoutBase: IFlyoutBase}
impl RtActivatable<IFlyoutBaseStatics3> for FlyoutBase {}
impl RtActivatable<IFlyoutBaseStatics2> for FlyoutBase {}
impl RtActivatable<IFlyoutBaseStatics> for FlyoutBase {}
impl FlyoutBase {
    #[inline] pub fn get_overlay_input_pass_through_element_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFlyoutBaseStatics3>>::get_activation_factory().get_overlay_input_pass_through_element_property()
    }}
    #[inline] pub fn get_allow_focus_on_interaction_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFlyoutBaseStatics2>>::get_activation_factory().get_allow_focus_on_interaction_property()
    }}
    #[inline] pub fn get_light_dismiss_overlay_mode_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFlyoutBaseStatics2>>::get_activation_factory().get_light_dismiss_overlay_mode_property()
    }}
    #[inline] pub fn get_allow_focus_when_disabled_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFlyoutBaseStatics2>>::get_activation_factory().get_allow_focus_when_disabled_property()
    }}
    #[inline] pub fn get_element_sound_mode_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFlyoutBaseStatics2>>::get_activation_factory().get_element_sound_mode_property()
    }}
    #[inline] pub fn get_placement_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFlyoutBaseStatics>>::get_activation_factory().get_placement_property()
    }}
    #[inline] pub fn get_attached_flyout_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFlyoutBaseStatics>>::get_activation_factory().get_attached_flyout_property()
    }}
    #[inline] pub fn get_attached_flyout(element: &super::super::FrameworkElement) -> Result<ComPtr<FlyoutBase>> { unsafe {
        <Self as RtActivatable<IFlyoutBaseStatics>>::get_activation_factory().get_attached_flyout(element)
    }}
    #[inline] pub fn set_attached_flyout(element: &super::super::FrameworkElement, value: &FlyoutBase) -> Result<()> { unsafe {
        <Self as RtActivatable<IFlyoutBaseStatics>>::get_activation_factory().set_attached_flyout(element, value)
    }}
    #[inline] pub fn show_attached_flyout(flyoutOwner: &super::super::FrameworkElement) -> Result<()> { unsafe {
        <Self as RtActivatable<IFlyoutBaseStatics>>::get_activation_factory().show_attached_flyout(flyoutOwner)
    }}
}
DEFINE_CLSID!(FlyoutBase(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,70,108,121,111,117,116,66,97,115,101,0]) [CLSID_FlyoutBase]);
DEFINE_IID!(IID_IFlyoutBaseStatics3, 2074685007, 56598, 19428, 153, 219, 189, 157, 68, 6, 192, 248);
RT_INTERFACE!{static interface IFlyoutBaseStatics3(IFlyoutBaseStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IFlyoutBaseStatics3] {
    fn get_OverlayInputPassThroughElementProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IFlyoutBaseStatics3 {
    #[inline] pub unsafe fn get_overlay_input_pass_through_element_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OverlayInputPassThroughElementProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IJumpListItemBackgroundConverter, 2165799000, 53796, 16652, 177, 108, 197, 182, 187, 97, 136, 178);
RT_INTERFACE!{interface IJumpListItemBackgroundConverter(IJumpListItemBackgroundConverterVtbl): IInspectable(IInspectableVtbl) [IID_IJumpListItemBackgroundConverter] {
    fn get_Enabled(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_Enabled(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_Disabled(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_Disabled(&self, value: *mut super::super::media::Brush) -> HRESULT
}}
impl IJumpListItemBackgroundConverter {
    #[inline] pub unsafe fn get_enabled(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Enabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_enabled(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Enabled)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_disabled(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Disabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_disabled(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Disabled)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IJumpListItemBackgroundConverterStatics, 552059869, 28455, 18440, 176, 190, 131, 224, 233, 181, 204, 69);
RT_INTERFACE!{static interface IJumpListItemBackgroundConverterStatics(IJumpListItemBackgroundConverterStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IJumpListItemBackgroundConverterStatics] {
    fn get_EnabledProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_DisabledProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IJumpListItemBackgroundConverterStatics {
    #[inline] pub unsafe fn get_enabled_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_disabled_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class JumpListItemBackgroundConverter: IJumpListItemBackgroundConverter}
impl RtActivatable<IJumpListItemBackgroundConverterStatics> for JumpListItemBackgroundConverter {}
impl RtActivatable<IActivationFactory> for JumpListItemBackgroundConverter {}
impl JumpListItemBackgroundConverter {
    #[inline] pub fn get_enabled_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IJumpListItemBackgroundConverterStatics>>::get_activation_factory().get_enabled_property()
    }}
    #[inline] pub fn get_disabled_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IJumpListItemBackgroundConverterStatics>>::get_activation_factory().get_disabled_property()
    }}
}
DEFINE_CLSID!(JumpListItemBackgroundConverter(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,74,117,109,112,76,105,115,116,73,116,101,109,66,97,99,107,103,114,111,117,110,100,67,111,110,118,101,114,116,101,114,0]) [CLSID_JumpListItemBackgroundConverter]);
DEFINE_IID!(IID_IJumpListItemForegroundConverter, 361819448, 50436, 18326, 166, 58, 91, 252, 158, 239, 170, 232);
RT_INTERFACE!{interface IJumpListItemForegroundConverter(IJumpListItemForegroundConverterVtbl): IInspectable(IInspectableVtbl) [IID_IJumpListItemForegroundConverter] {
    fn get_Enabled(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_Enabled(&self, value: *mut super::super::media::Brush) -> HRESULT,
    fn get_Disabled(&self, out: *mut *mut super::super::media::Brush) -> HRESULT,
    fn put_Disabled(&self, value: *mut super::super::media::Brush) -> HRESULT
}}
impl IJumpListItemForegroundConverter {
    #[inline] pub unsafe fn get_enabled(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Enabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_enabled(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Enabled)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_disabled(&self) -> Result<ComPtr<super::super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Disabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_disabled(&self, value: &super::super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Disabled)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IJumpListItemForegroundConverterStatics, 1196323666, 8460, 18035, 172, 106, 65, 63, 14, 44, 119, 80);
RT_INTERFACE!{static interface IJumpListItemForegroundConverterStatics(IJumpListItemForegroundConverterStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IJumpListItemForegroundConverterStatics] {
    fn get_EnabledProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_DisabledProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IJumpListItemForegroundConverterStatics {
    #[inline] pub unsafe fn get_enabled_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_disabled_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class JumpListItemForegroundConverter: IJumpListItemForegroundConverter}
impl RtActivatable<IJumpListItemForegroundConverterStatics> for JumpListItemForegroundConverter {}
impl RtActivatable<IActivationFactory> for JumpListItemForegroundConverter {}
impl JumpListItemForegroundConverter {
    #[inline] pub fn get_enabled_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IJumpListItemForegroundConverterStatics>>::get_activation_factory().get_enabled_property()
    }}
    #[inline] pub fn get_disabled_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IJumpListItemForegroundConverterStatics>>::get_activation_factory().get_disabled_property()
    }}
}
DEFINE_CLSID!(JumpListItemForegroundConverter(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,74,117,109,112,76,105,115,116,73,116,101,109,70,111,114,101,103,114,111,117,110,100,67,111,110,118,101,114,116,101,114,0]) [CLSID_JumpListItemForegroundConverter]);
DEFINE_IID!(IID_IPickerFlyoutBase, 3811931370, 4214, 17617, 147, 131, 220, 36, 172, 92, 255, 42);
RT_INTERFACE!{interface IPickerFlyoutBase(IPickerFlyoutBaseVtbl): IInspectable(IInspectableVtbl) [IID_IPickerFlyoutBase] {
    
}}
DEFINE_IID!(IID_IPickerFlyoutBaseOverrides, 1543262026, 18466, 18356, 169, 88, 119, 194, 11, 161, 32, 211);
RT_INTERFACE!{interface IPickerFlyoutBaseOverrides(IPickerFlyoutBaseOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IPickerFlyoutBaseOverrides] {
    fn OnConfirmed(&self) -> HRESULT,
    fn ShouldShowConfirmationButtons(&self, out: *mut bool) -> HRESULT
}}
impl IPickerFlyoutBaseOverrides {
    #[inline] pub unsafe fn on_confirmed(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).OnConfirmed)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn should_show_confirmation_buttons(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).ShouldShowConfirmationButtons)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPickerFlyoutBaseStatics, 1514998469, 35246, 16613, 167, 241, 187, 112, 35, 85, 173, 243);
RT_INTERFACE!{static interface IPickerFlyoutBaseStatics(IPickerFlyoutBaseStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPickerFlyoutBaseStatics] {
    fn get_TitleProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn GetTitle(&self, element: *mut super::super::DependencyObject, out: *mut HSTRING) -> HRESULT,
    fn SetTitle(&self, element: *mut super::super::DependencyObject, value: HSTRING) -> HRESULT
}}
impl IPickerFlyoutBaseStatics {
    #[inline] pub unsafe fn get_title_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TitleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_title(&self, element: &super::super::DependencyObject) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetTitle)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_title(&self, element: &super::super::DependencyObject, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetTitle)(self as *const _ as *mut _, element as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPickerFlyoutBaseFactory, 2126674515, 38146, 19435, 179, 66, 0, 86, 108, 143, 22, 176);
RT_INTERFACE!{interface IPickerFlyoutBaseFactory(IPickerFlyoutBaseFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPickerFlyoutBaseFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut PickerFlyoutBase) -> HRESULT
}}
impl IPickerFlyoutBaseFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<PickerFlyoutBase>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class PickerFlyoutBase: IPickerFlyoutBase}
impl RtActivatable<IPickerFlyoutBaseStatics> for PickerFlyoutBase {}
impl PickerFlyoutBase {
    #[inline] pub fn get_title_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPickerFlyoutBaseStatics>>::get_activation_factory().get_title_property()
    }}
    #[inline] pub fn get_title(element: &super::super::DependencyObject) -> Result<HString> { unsafe {
        <Self as RtActivatable<IPickerFlyoutBaseStatics>>::get_activation_factory().get_title(element)
    }}
    #[inline] pub fn set_title(element: &super::super::DependencyObject, value: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<IPickerFlyoutBaseStatics>>::get_activation_factory().set_title(element, value)
    }}
}
DEFINE_CLSID!(PickerFlyoutBase(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,80,105,99,107,101,114,70,108,121,111,117,116,66,97,115,101,0]) [CLSID_PickerFlyoutBase]);
DEFINE_IID!(IID_ILoopingSelector, 1285176836, 18471, 18905, 136, 6, 9, 57, 87, 176, 253, 33);
RT_INTERFACE!{interface ILoopingSelector(ILoopingSelectorVtbl): IInspectable(IInspectableVtbl) [IID_ILoopingSelector] {
    fn get_ShouldLoop(&self, out: *mut bool) -> HRESULT,
    fn put_ShouldLoop(&self, value: bool) -> HRESULT,
    fn get_Items(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<IInspectable>) -> HRESULT,
    fn put_Items(&self, value: *mut ::rt::gen::windows::foundation::collections::IVector<IInspectable>) -> HRESULT,
    fn get_SelectedIndex(&self, out: *mut i32) -> HRESULT,
    fn put_SelectedIndex(&self, value: i32) -> HRESULT,
    fn get_SelectedItem(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_SelectedItem(&self, value: *mut IInspectable) -> HRESULT,
    fn get_ItemWidth(&self, out: *mut i32) -> HRESULT,
    fn put_ItemWidth(&self, value: i32) -> HRESULT,
    fn get_ItemHeight(&self, out: *mut i32) -> HRESULT,
    fn put_ItemHeight(&self, value: i32) -> HRESULT,
    fn get_ItemTemplate(&self, out: *mut *mut super::super::DataTemplate) -> HRESULT,
    fn put_ItemTemplate(&self, value: *mut super::super::DataTemplate) -> HRESULT,
    fn add_SelectionChanged(&self, value: *mut super::SelectionChangedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SelectionChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl ILoopingSelector {
    #[inline] pub unsafe fn get_should_loop(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ShouldLoop)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_should_loop(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ShouldLoop)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_items(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<IInspectable>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Items)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_items(&self, value: &::rt::gen::windows::foundation::collections::IVector<IInspectable>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Items)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SelectedIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_index(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedIndex)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_item(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedItem)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selected_item(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectedItem)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_width(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ItemWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_item_width(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemWidth)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_height(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ItemHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_item_height(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemHeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_template(&self) -> Result<ComPtr<super::super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_item_template(&self, value: &super::super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_selection_changed(&self, value: &super::SelectionChangedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SelectionChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_selection_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SelectionChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ILoopingSelectorStatics, 65583866, 35965, 20421, 185, 42, 240, 73, 251, 147, 60, 197);
RT_INTERFACE!{static interface ILoopingSelectorStatics(ILoopingSelectorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ILoopingSelectorStatics] {
    fn get_ShouldLoopProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ItemsProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_SelectedIndexProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_SelectedItemProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ItemWidthProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ItemHeightProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ItemTemplateProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl ILoopingSelectorStatics {
    #[inline] pub unsafe fn get_should_loop_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ShouldLoopProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_items_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_index_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedIndexProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_item_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedItemProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_width_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemWidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_height_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_template_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class LoopingSelector: ILoopingSelector}
impl RtActivatable<ILoopingSelectorStatics> for LoopingSelector {}
impl LoopingSelector {
    #[inline] pub fn get_should_loop_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ILoopingSelectorStatics>>::get_activation_factory().get_should_loop_property()
    }}
    #[inline] pub fn get_items_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ILoopingSelectorStatics>>::get_activation_factory().get_items_property()
    }}
    #[inline] pub fn get_selected_index_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ILoopingSelectorStatics>>::get_activation_factory().get_selected_index_property()
    }}
    #[inline] pub fn get_selected_item_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ILoopingSelectorStatics>>::get_activation_factory().get_selected_item_property()
    }}
    #[inline] pub fn get_item_width_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ILoopingSelectorStatics>>::get_activation_factory().get_item_width_property()
    }}
    #[inline] pub fn get_item_height_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ILoopingSelectorStatics>>::get_activation_factory().get_item_height_property()
    }}
    #[inline] pub fn get_item_template_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ILoopingSelectorStatics>>::get_activation_factory().get_item_template_property()
    }}
}
DEFINE_CLSID!(LoopingSelector(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,76,111,111,112,105,110,103,83,101,108,101,99,116,111,114,0]) [CLSID_LoopingSelector]);
DEFINE_IID!(IID_IPivotPanel, 2907618944, 8873, 19619, 146, 18, 39, 115, 182, 53, 159, 243);
RT_INTERFACE!{interface IPivotPanel(IPivotPanelVtbl): IInspectable(IInspectableVtbl) [IID_IPivotPanel] {
    
}}
RT_CLASS!{class PivotPanel: IPivotPanel}
impl RtActivatable<IActivationFactory> for PivotPanel {}
DEFINE_CLSID!(PivotPanel(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,80,105,118,111,116,80,97,110,101,108,0]) [CLSID_PivotPanel]);
DEFINE_IID!(IID_ILoopingSelectorItem, 3331790009, 10182, 17459, 157, 124, 13, 191, 178, 244, 52, 79);
RT_INTERFACE!{interface ILoopingSelectorItem(ILoopingSelectorItemVtbl): IInspectable(IInspectableVtbl) [IID_ILoopingSelectorItem] {
    
}}
RT_CLASS!{class LoopingSelectorItem: ILoopingSelectorItem}
DEFINE_IID!(IID_ILoopingSelectorPanel, 1084865136, 4113, 18296, 135, 247, 107, 253, 32, 214, 55, 125);
RT_INTERFACE!{interface ILoopingSelectorPanel(ILoopingSelectorPanelVtbl): IInspectable(IInspectableVtbl) [IID_ILoopingSelectorPanel] {
    
}}
RT_CLASS!{class LoopingSelectorPanel: ILoopingSelectorPanel}
DEFINE_IID!(IID_IPivotHeaderItem, 1497723586, 33450, 16651, 158, 85, 253, 142, 44, 152, 134, 45);
RT_INTERFACE!{interface IPivotHeaderItem(IPivotHeaderItemVtbl): IInspectable(IInspectableVtbl) [IID_IPivotHeaderItem] {
    
}}
DEFINE_IID!(IID_IPivotHeaderItemFactory, 338725687, 6235, 16663, 188, 119, 221, 162, 235, 38, 27, 153);
RT_INTERFACE!{interface IPivotHeaderItemFactory(IPivotHeaderItemFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPivotHeaderItemFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut PivotHeaderItem) -> HRESULT
}}
impl IPivotHeaderItemFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<PivotHeaderItem>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class PivotHeaderItem: IPivotHeaderItem}
DEFINE_IID!(IID_IPivotHeaderPanel, 558386876, 37441, 16899, 189, 55, 108, 8, 251, 9, 102, 18);
RT_INTERFACE!{interface IPivotHeaderPanel(IPivotHeaderPanelVtbl): IInspectable(IInspectableVtbl) [IID_IPivotHeaderPanel] {
    
}}
RT_CLASS!{class PivotHeaderPanel: IPivotHeaderPanel}
impl RtActivatable<IActivationFactory> for PivotHeaderPanel {}
DEFINE_CLSID!(PivotHeaderPanel(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,80,114,105,109,105,116,105,118,101,115,46,80,105,118,111,116,72,101,97,100,101,114,80,97,110,101,108,0]) [CLSID_PivotHeaderPanel]);
} // Windows.UI.Xaml.Controls.Primitives
pub mod maps { // Windows.UI.Xaml.Controls.Maps
use ::prelude::*;
RT_ENUM! { enum MapAnimationKind: i32 {
    Default (MapAnimationKind_Default) = 0, None (MapAnimationKind_None) = 1, Linear (MapAnimationKind_Linear) = 2, Bow (MapAnimationKind_Bow) = 3,
}}
RT_ENUM! { enum MapCameraChangeReason: i32 {
    System (MapCameraChangeReason_System) = 0, UserInteraction (MapCameraChangeReason_UserInteraction) = 1, Programmatic (MapCameraChangeReason_Programmatic) = 2,
}}
RT_ENUM! { enum MapColorScheme: i32 {
    Light (MapColorScheme_Light) = 0, Dark (MapColorScheme_Dark) = 1,
}}
RT_ENUM! { enum MapElementCollisionBehavior: i32 {
    Hide (MapElementCollisionBehavior_Hide) = 0, RemainVisible (MapElementCollisionBehavior_RemainVisible) = 1,
}}
RT_ENUM! { enum MapInteractionMode: i32 {
    Auto (MapInteractionMode_Auto) = 0, Disabled (MapInteractionMode_Disabled) = 1, GestureOnly (MapInteractionMode_GestureOnly) = 2, PointerAndKeyboard (MapInteractionMode_PointerAndKeyboard) = 2, ControlOnly (MapInteractionMode_ControlOnly) = 3, GestureAndControl (MapInteractionMode_GestureAndControl) = 4, PointerKeyboardAndControl (MapInteractionMode_PointerKeyboardAndControl) = 4, PointerOnly (MapInteractionMode_PointerOnly) = 5,
}}
RT_ENUM! { enum MapLoadingStatus: i32 {
    Loading (MapLoadingStatus_Loading) = 0, Loaded (MapLoadingStatus_Loaded) = 1, DataUnavailable (MapLoadingStatus_DataUnavailable) = 2,
}}
RT_ENUM! { enum MapPanInteractionMode: i32 {
    Auto (MapPanInteractionMode_Auto) = 0, Disabled (MapPanInteractionMode_Disabled) = 1,
}}
RT_ENUM! { enum MapProjection: i32 {
    WebMercator (MapProjection_WebMercator) = 0, Globe (MapProjection_Globe) = 1,
}}
RT_ENUM! { enum MapStyle: i32 {
    None (MapStyle_None) = 0, Road (MapStyle_Road) = 1, Aerial (MapStyle_Aerial) = 2, AerialWithRoads (MapStyle_AerialWithRoads) = 3, Terrain (MapStyle_Terrain) = 4, Aerial3D (MapStyle_Aerial3D) = 5, Aerial3DWithRoads (MapStyle_Aerial3DWithRoads) = 6, Custom (MapStyle_Custom) = 7,
}}
RT_ENUM! { enum MapTileLayer: i32 {
    LabelOverlay (MapTileLayer_LabelOverlay) = 0, RoadOverlay (MapTileLayer_RoadOverlay) = 1, AreaOverlay (MapTileLayer_AreaOverlay) = 2, BackgroundOverlay (MapTileLayer_BackgroundOverlay) = 3, BackgroundReplacement (MapTileLayer_BackgroundReplacement) = 4,
}}
RT_ENUM! { enum MapVisibleRegionKind: i32 {
    Near (MapVisibleRegionKind_Near) = 0, Full (MapVisibleRegionKind_Full) = 1,
}}
RT_ENUM! { enum MapWatermarkMode: i32 {
    Automatic (MapWatermarkMode_Automatic) = 0, On (MapWatermarkMode_On) = 1,
}}
RT_STRUCT! { struct MapZoomLevelRange {
    Min: f64, Max: f64,
}}
DEFINE_IID!(IID_IMapActualCameraChangedEventArgs, 3667951834, 47092, 16940, 166, 24, 187, 170, 124, 29, 129, 76);
RT_INTERFACE!{interface IMapActualCameraChangedEventArgs(IMapActualCameraChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMapActualCameraChangedEventArgs] {
    fn get_Camera(&self, out: *mut *mut MapCamera) -> HRESULT
}}
impl IMapActualCameraChangedEventArgs {
    #[inline] pub unsafe fn get_camera(&self) -> Result<ComPtr<MapCamera>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Camera)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapActualCameraChangedEventArgs2, 2074396645, 4316, 17754, 157, 4, 29, 114, 251, 109, 155, 147);
RT_INTERFACE!{interface IMapActualCameraChangedEventArgs2(IMapActualCameraChangedEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IMapActualCameraChangedEventArgs2] {
    fn get_ChangeReason(&self, out: *mut MapCameraChangeReason) -> HRESULT
}}
impl IMapActualCameraChangedEventArgs2 {
    #[inline] pub unsafe fn get_change_reason(&self) -> Result<MapCameraChangeReason> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ChangeReason)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class MapActualCameraChangedEventArgs: IMapActualCameraChangedEventArgs}
impl RtActivatable<IActivationFactory> for MapActualCameraChangedEventArgs {}
DEFINE_CLSID!(MapActualCameraChangedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,65,99,116,117,97,108,67,97,109,101,114,97,67,104,97,110,103,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_MapActualCameraChangedEventArgs]);
DEFINE_IID!(IID_IMapActualCameraChangingEventArgs, 1796062934, 37879, 18050, 141, 229, 164, 122, 28, 199, 169, 69);
RT_INTERFACE!{interface IMapActualCameraChangingEventArgs(IMapActualCameraChangingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMapActualCameraChangingEventArgs] {
    fn get_Camera(&self, out: *mut *mut MapCamera) -> HRESULT
}}
impl IMapActualCameraChangingEventArgs {
    #[inline] pub unsafe fn get_camera(&self) -> Result<ComPtr<MapCamera>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Camera)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapActualCameraChangingEventArgs2, 4068898967, 16556, 20106, 169, 39, 81, 15, 56, 70, 164, 126);
RT_INTERFACE!{interface IMapActualCameraChangingEventArgs2(IMapActualCameraChangingEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IMapActualCameraChangingEventArgs2] {
    fn get_ChangeReason(&self, out: *mut MapCameraChangeReason) -> HRESULT
}}
impl IMapActualCameraChangingEventArgs2 {
    #[inline] pub unsafe fn get_change_reason(&self) -> Result<MapCameraChangeReason> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ChangeReason)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class MapActualCameraChangingEventArgs: IMapActualCameraChangingEventArgs}
impl RtActivatable<IActivationFactory> for MapActualCameraChangingEventArgs {}
DEFINE_CLSID!(MapActualCameraChangingEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,65,99,116,117,97,108,67,97,109,101,114,97,67,104,97,110,103,105,110,103,69,118,101,110,116,65,114,103,115,0]) [CLSID_MapActualCameraChangingEventArgs]);
DEFINE_IID!(IID_IMapContextRequestedEventArgs, 4258378787, 51553, 19954, 187, 87, 130, 238, 15, 11, 181, 145);
RT_INTERFACE!{interface IMapContextRequestedEventArgs(IMapContextRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMapContextRequestedEventArgs] {
    fn get_Position(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_Location(&self, out: *mut *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT,
    fn get_MapElements(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<MapElement>) -> HRESULT
}}
impl IMapContextRequestedEventArgs {
    #[inline] pub unsafe fn get_position(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_location(&self) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::Geopoint>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Location)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_map_elements(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<MapElement>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MapElements)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class MapContextRequestedEventArgs: IMapContextRequestedEventArgs}
impl RtActivatable<IActivationFactory> for MapContextRequestedEventArgs {}
DEFINE_CLSID!(MapContextRequestedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,67,111,110,116,101,120,116,82,101,113,117,101,115,116,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_MapContextRequestedEventArgs]);
DEFINE_IID!(IID_IMapCustomExperienceChangedEventArgs, 3118922651, 36801, 16450, 172, 52, 166, 27, 56, 187, 117, 20);
RT_INTERFACE!{interface IMapCustomExperienceChangedEventArgs(IMapCustomExperienceChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMapCustomExperienceChangedEventArgs] {
    
}}
RT_CLASS!{class MapCustomExperienceChangedEventArgs: IMapCustomExperienceChangedEventArgs}
impl RtActivatable<IActivationFactory> for MapCustomExperienceChangedEventArgs {}
DEFINE_CLSID!(MapCustomExperienceChangedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,67,117,115,116,111,109,69,120,112,101,114,105,101,110,99,101,67,104,97,110,103,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_MapCustomExperienceChangedEventArgs]);
DEFINE_IID!(IID_IMapElementClickEventArgs, 1075218961, 53376, 17689, 153, 161, 49, 73, 251, 137, 153, 208);
RT_INTERFACE!{interface IMapElementClickEventArgs(IMapElementClickEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMapElementClickEventArgs] {
    fn get_Position(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_Location(&self, out: *mut *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT,
    fn get_MapElements(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<MapElement>) -> HRESULT
}}
impl IMapElementClickEventArgs {
    #[inline] pub unsafe fn get_position(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_location(&self) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::Geopoint>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Location)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_map_elements(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<MapElement>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MapElements)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class MapElementClickEventArgs: IMapElementClickEventArgs}
impl RtActivatable<IActivationFactory> for MapElementClickEventArgs {}
DEFINE_CLSID!(MapElementClickEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,69,108,101,109,101,110,116,67,108,105,99,107,69,118,101,110,116,65,114,103,115,0]) [CLSID_MapElementClickEventArgs]);
DEFINE_IID!(IID_IMapElementPointerEnteredEventArgs, 2877676878, 37335, 19249, 143, 10, 211, 144, 199, 211, 162, 239);
RT_INTERFACE!{interface IMapElementPointerEnteredEventArgs(IMapElementPointerEnteredEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMapElementPointerEnteredEventArgs] {
    fn get_Position(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_Location(&self, out: *mut *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT,
    fn get_MapElement(&self, out: *mut *mut MapElement) -> HRESULT
}}
impl IMapElementPointerEnteredEventArgs {
    #[inline] pub unsafe fn get_position(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_location(&self) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::Geopoint>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Location)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_map_element(&self) -> Result<ComPtr<MapElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MapElement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class MapElementPointerEnteredEventArgs: IMapElementPointerEnteredEventArgs}
impl RtActivatable<IActivationFactory> for MapElementPointerEnteredEventArgs {}
DEFINE_CLSID!(MapElementPointerEnteredEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,69,108,101,109,101,110,116,80,111,105,110,116,101,114,69,110,116,101,114,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_MapElementPointerEnteredEventArgs]);
DEFINE_IID!(IID_IMapElementPointerExitedEventArgs, 3248773881, 24777, 18041, 145, 25, 32, 171, 199, 93, 147, 31);
RT_INTERFACE!{interface IMapElementPointerExitedEventArgs(IMapElementPointerExitedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMapElementPointerExitedEventArgs] {
    fn get_Position(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_Location(&self, out: *mut *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT,
    fn get_MapElement(&self, out: *mut *mut MapElement) -> HRESULT
}}
impl IMapElementPointerExitedEventArgs {
    #[inline] pub unsafe fn get_position(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_location(&self) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::Geopoint>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Location)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_map_element(&self) -> Result<ComPtr<MapElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MapElement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class MapElementPointerExitedEventArgs: IMapElementPointerExitedEventArgs}
impl RtActivatable<IActivationFactory> for MapElementPointerExitedEventArgs {}
DEFINE_CLSID!(MapElementPointerExitedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,69,108,101,109,101,110,116,80,111,105,110,116,101,114,69,120,105,116,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_MapElementPointerExitedEventArgs]);
DEFINE_IID!(IID_IMapRightTappedEventArgs, 546582897, 28648, 16550, 173, 14, 41, 115, 121, 181, 117, 167);
RT_INTERFACE!{interface IMapRightTappedEventArgs(IMapRightTappedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMapRightTappedEventArgs] {
    fn get_Position(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    #[cfg(feature="windows-devices")] fn get_Location(&self, out: *mut *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT
}}
impl IMapRightTappedEventArgs {
    #[inline] pub unsafe fn get_position(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_location(&self) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::Geopoint>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Location)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class MapRightTappedEventArgs: IMapRightTappedEventArgs}
impl RtActivatable<IActivationFactory> for MapRightTappedEventArgs {}
DEFINE_CLSID!(MapRightTappedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,82,105,103,104,116,84,97,112,112,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_MapRightTappedEventArgs]);
DEFINE_IID!(IID_IMapTargetCameraChangedEventArgs, 3689940082, 59731, 20392, 151, 208, 234, 134, 53, 144, 87, 207);
RT_INTERFACE!{interface IMapTargetCameraChangedEventArgs(IMapTargetCameraChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMapTargetCameraChangedEventArgs] {
    fn get_Camera(&self, out: *mut *mut MapCamera) -> HRESULT
}}
impl IMapTargetCameraChangedEventArgs {
    #[inline] pub unsafe fn get_camera(&self) -> Result<ComPtr<MapCamera>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Camera)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapTargetCameraChangedEventArgs2, 2545988402, 62134, 17931, 141, 145, 172, 2, 10, 35, 131, 221);
RT_INTERFACE!{interface IMapTargetCameraChangedEventArgs2(IMapTargetCameraChangedEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IMapTargetCameraChangedEventArgs2] {
    fn get_ChangeReason(&self, out: *mut MapCameraChangeReason) -> HRESULT
}}
impl IMapTargetCameraChangedEventArgs2 {
    #[inline] pub unsafe fn get_change_reason(&self) -> Result<MapCameraChangeReason> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ChangeReason)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class MapTargetCameraChangedEventArgs: IMapTargetCameraChangedEventArgs}
impl RtActivatable<IActivationFactory> for MapTargetCameraChangedEventArgs {}
DEFINE_CLSID!(MapTargetCameraChangedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,84,97,114,103,101,116,67,97,109,101,114,97,67,104,97,110,103,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_MapTargetCameraChangedEventArgs]);
DEFINE_IID!(IID_IMapTileBitmapRequest, 1181958076, 55453, 18219, 181, 246, 215, 6, 107, 5, 132, 244);
RT_INTERFACE!{interface IMapTileBitmapRequest(IMapTileBitmapRequestVtbl): IInspectable(IInspectableVtbl) [IID_IMapTileBitmapRequest] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_PixelData(&self, out: *mut *mut ::rt::gen::windows::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_PixelData(&self, value: *mut ::rt::gen::windows::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut MapTileBitmapRequestDeferral) -> HRESULT
}}
impl IMapTileBitmapRequest {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_pixel_data(&self) -> Result<ComPtr<::rt::gen::windows::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PixelData)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_pixel_data(&self, value: &::rt::gen::windows::storage::streams::IRandomAccessStreamReference) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PixelData)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<MapTileBitmapRequestDeferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class MapTileBitmapRequestDeferral: IMapTileBitmapRequestDeferral}
impl RtActivatable<IActivationFactory> for MapTileBitmapRequestDeferral {}
DEFINE_CLSID!(MapTileBitmapRequestDeferral(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,84,105,108,101,66,105,116,109,97,112,82,101,113,117,101,115,116,68,101,102,101,114,114,97,108,0]) [CLSID_MapTileBitmapRequestDeferral]);
RT_CLASS!{class MapTileBitmapRequest: IMapTileBitmapRequest}
impl RtActivatable<IActivationFactory> for MapTileBitmapRequest {}
DEFINE_CLSID!(MapTileBitmapRequest(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,84,105,108,101,66,105,116,109,97,112,82,101,113,117,101,115,116,0]) [CLSID_MapTileBitmapRequest]);
DEFINE_IID!(IID_IMapTileBitmapRequestDeferral, 4265018690, 42156, 20218, 150, 101, 4, 144, 176, 202, 253, 210);
RT_INTERFACE!{interface IMapTileBitmapRequestDeferral(IMapTileBitmapRequestDeferralVtbl): IInspectable(IInspectableVtbl) [IID_IMapTileBitmapRequestDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IMapTileBitmapRequestDeferral {
    #[inline] pub unsafe fn complete(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapTileBitmapRequestedEventArgs, 863987997, 39682, 19106, 139, 30, 204, 77, 145, 113, 155, 243);
RT_INTERFACE!{interface IMapTileBitmapRequestedEventArgs(IMapTileBitmapRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMapTileBitmapRequestedEventArgs] {
    fn get_X(&self, out: *mut i32) -> HRESULT,
    fn get_Y(&self, out: *mut i32) -> HRESULT,
    fn get_ZoomLevel(&self, out: *mut i32) -> HRESULT,
    fn get_Request(&self, out: *mut *mut MapTileBitmapRequest) -> HRESULT
}}
impl IMapTileBitmapRequestedEventArgs {
    #[inline] pub unsafe fn get_x(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_X)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_y(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Y)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoom_level(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ZoomLevel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<MapTileBitmapRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class MapTileBitmapRequestedEventArgs: IMapTileBitmapRequestedEventArgs}
impl RtActivatable<IActivationFactory> for MapTileBitmapRequestedEventArgs {}
DEFINE_CLSID!(MapTileBitmapRequestedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,84,105,108,101,66,105,116,109,97,112,82,101,113,117,101,115,116,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_MapTileBitmapRequestedEventArgs]);
DEFINE_IID!(IID_IMapTileUriRequest, 390079285, 12583, 17848, 135, 167, 153, 248, 125, 78, 39, 69);
RT_INTERFACE!{interface IMapTileUriRequest(IMapTileUriRequestVtbl): IInspectable(IInspectableVtbl) [IID_IMapTileUriRequest] {
    fn get_Uri(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn put_Uri(&self, value: *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut MapTileUriRequestDeferral) -> HRESULT
}}
impl IMapTileUriRequest {
    #[inline] pub unsafe fn get_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_uri(&self, value: &::rt::gen::windows::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Uri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<MapTileUriRequestDeferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class MapTileUriRequestDeferral: IMapTileUriRequestDeferral}
impl RtActivatable<IActivationFactory> for MapTileUriRequestDeferral {}
DEFINE_CLSID!(MapTileUriRequestDeferral(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,84,105,108,101,85,114,105,82,101,113,117,101,115,116,68,101,102,101,114,114,97,108,0]) [CLSID_MapTileUriRequestDeferral]);
RT_CLASS!{class MapTileUriRequest: IMapTileUriRequest}
impl RtActivatable<IActivationFactory> for MapTileUriRequest {}
DEFINE_CLSID!(MapTileUriRequest(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,84,105,108,101,85,114,105,82,101,113,117,101,115,116,0]) [CLSID_MapTileUriRequest]);
DEFINE_IID!(IID_IMapTileUriRequestDeferral, 3239554528, 48958, 19537, 143, 170, 75, 89, 60, 246, 142, 178);
RT_INTERFACE!{interface IMapTileUriRequestDeferral(IMapTileUriRequestDeferralVtbl): IInspectable(IInspectableVtbl) [IID_IMapTileUriRequestDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IMapTileUriRequestDeferral {
    #[inline] pub unsafe fn complete(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapTileUriRequestedEventArgs, 3524557635, 7103, 19352, 141, 211, 183, 131, 78, 64, 126, 13);
RT_INTERFACE!{interface IMapTileUriRequestedEventArgs(IMapTileUriRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMapTileUriRequestedEventArgs] {
    fn get_X(&self, out: *mut i32) -> HRESULT,
    fn get_Y(&self, out: *mut i32) -> HRESULT,
    fn get_ZoomLevel(&self, out: *mut i32) -> HRESULT,
    fn get_Request(&self, out: *mut *mut MapTileUriRequest) -> HRESULT
}}
impl IMapTileUriRequestedEventArgs {
    #[inline] pub unsafe fn get_x(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_X)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_y(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Y)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoom_level(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ZoomLevel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<MapTileUriRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class MapTileUriRequestedEventArgs: IMapTileUriRequestedEventArgs}
impl RtActivatable<IActivationFactory> for MapTileUriRequestedEventArgs {}
DEFINE_CLSID!(MapTileUriRequestedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,84,105,108,101,85,114,105,82,101,113,117,101,115,116,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_MapTileUriRequestedEventArgs]);
DEFINE_IID!(IID_IMapCamera, 1403434531, 49400, 19851, 173, 30, 165, 149, 152, 234, 132, 11);
RT_INTERFACE!{interface IMapCamera(IMapCameraVtbl): IInspectable(IInspectableVtbl) [IID_IMapCamera] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_Location(&self, out: *mut *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-devices")] fn put_Location(&self, value: *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT,
    fn get_Heading(&self, out: *mut f64) -> HRESULT,
    fn put_Heading(&self, value: f64) -> HRESULT,
    fn get_Pitch(&self, out: *mut f64) -> HRESULT,
    fn put_Pitch(&self, value: f64) -> HRESULT,
    fn get_Roll(&self, out: *mut f64) -> HRESULT,
    fn put_Roll(&self, value: f64) -> HRESULT,
    fn get_FieldOfView(&self, out: *mut f64) -> HRESULT,
    fn put_FieldOfView(&self, value: f64) -> HRESULT
}}
impl IMapCamera {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_location(&self) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::Geopoint>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Location)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn set_location(&self, value: &::rt::gen::windows::devices::geolocation::Geopoint) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Location)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_heading(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Heading)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_heading(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Heading)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pitch(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Pitch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_pitch(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Pitch)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_roll(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Roll)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_roll(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Roll)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_field_of_view(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FieldOfView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_field_of_view(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FieldOfView)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class MapCamera: IMapCamera}
impl RtActivatable<IMapCameraFactory> for MapCamera {}
impl MapCamera {
    #[cfg(feature="windows-devices")] #[inline] pub fn create_instance_with_location(location: &::rt::gen::windows::devices::geolocation::Geopoint) -> Result<ComPtr<MapCamera>> { unsafe {
        <Self as RtActivatable<IMapCameraFactory>>::get_activation_factory().create_instance_with_location(location)
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn create_instance_with_location_and_heading(location: &::rt::gen::windows::devices::geolocation::Geopoint, headingInDegrees: f64) -> Result<ComPtr<MapCamera>> { unsafe {
        <Self as RtActivatable<IMapCameraFactory>>::get_activation_factory().create_instance_with_location_and_heading(location, headingInDegrees)
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn create_instance_with_location_heading_and_pitch(location: &::rt::gen::windows::devices::geolocation::Geopoint, headingInDegrees: f64, pitchInDegrees: f64) -> Result<ComPtr<MapCamera>> { unsafe {
        <Self as RtActivatable<IMapCameraFactory>>::get_activation_factory().create_instance_with_location_heading_and_pitch(location, headingInDegrees, pitchInDegrees)
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn create_instance_with_location_heading_pitch_roll_and_field_of_view(location: &::rt::gen::windows::devices::geolocation::Geopoint, headingInDegrees: f64, pitchInDegrees: f64, rollInDegrees: f64, fieldOfViewInDegrees: f64) -> Result<ComPtr<MapCamera>> { unsafe {
        <Self as RtActivatable<IMapCameraFactory>>::get_activation_factory().create_instance_with_location_heading_pitch_roll_and_field_of_view(location, headingInDegrees, pitchInDegrees, rollInDegrees, fieldOfViewInDegrees)
    }}
}
DEFINE_CLSID!(MapCamera(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,67,97,109,101,114,97,0]) [CLSID_MapCamera]);
DEFINE_IID!(IID_IMapCameraFactory, 3929739030, 33711, 19150, 142, 113, 16, 173, 159, 30, 158, 127);
RT_INTERFACE!{static interface IMapCameraFactory(IMapCameraFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMapCameraFactory] {
    #[cfg(feature="windows-devices")] fn CreateInstanceWithLocation(&self, location: *mut ::rt::gen::windows::devices::geolocation::Geopoint, out: *mut *mut MapCamera) -> HRESULT,
    #[cfg(feature="windows-devices")] fn CreateInstanceWithLocationAndHeading(&self, location: *mut ::rt::gen::windows::devices::geolocation::Geopoint, headingInDegrees: f64, out: *mut *mut MapCamera) -> HRESULT,
    #[cfg(feature="windows-devices")] fn CreateInstanceWithLocationHeadingAndPitch(&self, location: *mut ::rt::gen::windows::devices::geolocation::Geopoint, headingInDegrees: f64, pitchInDegrees: f64, out: *mut *mut MapCamera) -> HRESULT,
    #[cfg(feature="windows-devices")] fn CreateInstanceWithLocationHeadingPitchRollAndFieldOfView(&self, location: *mut ::rt::gen::windows::devices::geolocation::Geopoint, headingInDegrees: f64, pitchInDegrees: f64, rollInDegrees: f64, fieldOfViewInDegrees: f64, out: *mut *mut MapCamera) -> HRESULT
}}
impl IMapCameraFactory {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn create_instance_with_location(&self, location: &::rt::gen::windows::devices::geolocation::Geopoint) -> Result<ComPtr<MapCamera>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithLocation)(self as *const _ as *mut _, location as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn create_instance_with_location_and_heading(&self, location: &::rt::gen::windows::devices::geolocation::Geopoint, headingInDegrees: f64) -> Result<ComPtr<MapCamera>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithLocationAndHeading)(self as *const _ as *mut _, location as *const _ as *mut _, headingInDegrees, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn create_instance_with_location_heading_and_pitch(&self, location: &::rt::gen::windows::devices::geolocation::Geopoint, headingInDegrees: f64, pitchInDegrees: f64) -> Result<ComPtr<MapCamera>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithLocationHeadingAndPitch)(self as *const _ as *mut _, location as *const _ as *mut _, headingInDegrees, pitchInDegrees, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn create_instance_with_location_heading_pitch_roll_and_field_of_view(&self, location: &::rt::gen::windows::devices::geolocation::Geopoint, headingInDegrees: f64, pitchInDegrees: f64, rollInDegrees: f64, fieldOfViewInDegrees: f64) -> Result<ComPtr<MapCamera>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithLocationHeadingPitchRollAndFieldOfView)(self as *const _ as *mut _, location as *const _ as *mut _, headingInDegrees, pitchInDegrees, rollInDegrees, fieldOfViewInDegrees, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapCustomExperience, 1683564646, 5283, 20063, 136, 131, 142, 156, 80, 14, 238, 222);
RT_INTERFACE!{interface IMapCustomExperience(IMapCustomExperienceVtbl): IInspectable(IInspectableVtbl) [IID_IMapCustomExperience] {
    
}}
DEFINE_IID!(IID_IMapCustomExperienceFactory, 2051030965, 41393, 20095, 146, 30, 62, 107, 141, 142, 190, 214);
RT_INTERFACE!{interface IMapCustomExperienceFactory(IMapCustomExperienceFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMapCustomExperienceFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut MapCustomExperience) -> HRESULT
}}
impl IMapCustomExperienceFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<MapCustomExperience>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class MapCustomExperience: IMapCustomExperience}
DEFINE_IID!(IID_IMapElement, 3592406239, 45637, 18418, 154, 194, 67, 192, 88, 177, 201, 3);
RT_INTERFACE!{interface IMapElement(IMapElementVtbl): IInspectable(IInspectableVtbl) [IID_IMapElement] {
    fn get_ZIndex(&self, out: *mut i32) -> HRESULT,
    fn put_ZIndex(&self, value: i32) -> HRESULT,
    fn get_Visible(&self, out: *mut bool) -> HRESULT,
    fn put_Visible(&self, value: bool) -> HRESULT
}}
impl IMapElement {
    #[inline] pub unsafe fn get_zindex(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ZIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_zindex(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ZIndex)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Visible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Visible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapElementStatics, 3905363186, 49135, 19273, 142, 153, 65, 181, 227, 120, 159, 210);
RT_INTERFACE!{static interface IMapElementStatics(IMapElementStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMapElementStatics] {
    fn get_ZIndexProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_VisibleProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IMapElementStatics {
    #[inline] pub unsafe fn get_zindex_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ZIndexProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_visible_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapElementFactory, 1244712967, 3030, 18341, 134, 11, 126, 124, 245, 240, 197, 115);
RT_INTERFACE!{interface IMapElementFactory(IMapElementFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMapElementFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut MapElement) -> HRESULT
}}
impl IMapElementFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<MapElement>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapElement2, 1712976481, 64422, 18788, 167, 255, 241, 175, 99, 171, 156, 176);
RT_INTERFACE!{interface IMapElement2(IMapElement2Vtbl): IInspectable(IInspectableVtbl) [IID_IMapElement2] {
    fn get_MapTabIndex(&self, out: *mut i32) -> HRESULT,
    fn put_MapTabIndex(&self, value: i32) -> HRESULT
}}
impl IMapElement2 {
    #[inline] pub unsafe fn get_map_tab_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MapTabIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_map_tab_index(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MapTabIndex)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class MapElement: IMapElement}
impl RtActivatable<IMapElementStatics> for MapElement {}
impl RtActivatable<IMapElementStatics2> for MapElement {}
impl MapElement {
    #[inline] pub fn get_zindex_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapElementStatics>>::get_activation_factory().get_zindex_property()
    }}
    #[inline] pub fn get_visible_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapElementStatics>>::get_activation_factory().get_visible_property()
    }}
    #[inline] pub fn get_map_tab_index_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapElementStatics2>>::get_activation_factory().get_map_tab_index_property()
    }}
}
DEFINE_CLSID!(MapElement(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,69,108,101,109,101,110,116,0]) [CLSID_MapElement]);
DEFINE_IID!(IID_IMapElementStatics2, 2616667952, 33022, 20272, 188, 193, 250, 137, 64, 80, 246, 118);
RT_INTERFACE!{static interface IMapElementStatics2(IMapElementStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IMapElementStatics2] {
    fn get_MapTabIndexProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IMapElementStatics2 {
    #[inline] pub unsafe fn get_map_tab_index_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MapTabIndexProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapInputEventArgs, 2680488864, 43170, 17300, 146, 233, 34, 71, 118, 79, 47, 73);
RT_INTERFACE!{interface IMapInputEventArgs(IMapInputEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMapInputEventArgs] {
    fn get_Position(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    #[cfg(feature="windows-devices")] fn get_Location(&self, out: *mut *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT
}}
impl IMapInputEventArgs {
    #[inline] pub unsafe fn get_position(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_location(&self) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::Geopoint>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Location)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class MapInputEventArgs: IMapInputEventArgs}
impl RtActivatable<IActivationFactory> for MapInputEventArgs {}
DEFINE_CLSID!(MapInputEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,73,110,112,117,116,69,118,101,110,116,65,114,103,115,0]) [CLSID_MapInputEventArgs]);
DEFINE_IID!(IID_IMapItemsControl, 2495792339, 45877, 17093, 182, 96, 230, 160, 126, 195, 189, 220);
RT_INTERFACE!{interface IMapItemsControl(IMapItemsControlVtbl): IInspectable(IInspectableVtbl) [IID_IMapItemsControl] {
    fn get_ItemsSource(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_ItemsSource(&self, value: *mut IInspectable) -> HRESULT,
    fn get_Items(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<super::super::DependencyObject>) -> HRESULT,
    fn get_ItemTemplate(&self, out: *mut *mut super::super::DataTemplate) -> HRESULT,
    fn put_ItemTemplate(&self, value: *mut super::super::DataTemplate) -> HRESULT
}}
impl IMapItemsControl {
    #[inline] pub unsafe fn get_items_source(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemsSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_items_source(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemsSource)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_items(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<super::super::DependencyObject>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Items)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_template(&self) -> Result<ComPtr<super::super::DataTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemTemplate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_item_template(&self, value: &super::super::DataTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemTemplate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapItemsControlStatics, 866671047, 30875, 16988, 138, 10, 50, 56, 88, 150, 203, 74);
RT_INTERFACE!{static interface IMapItemsControlStatics(IMapItemsControlStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMapItemsControlStatics] {
    fn get_ItemsSourceProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ItemsProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ItemTemplateProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IMapItemsControlStatics {
    #[inline] pub unsafe fn get_items_source_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemsSourceProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_items_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_template_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemTemplateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class MapItemsControl: IMapItemsControl}
impl RtActivatable<IMapItemsControlStatics> for MapItemsControl {}
impl RtActivatable<IActivationFactory> for MapItemsControl {}
impl MapItemsControl {
    #[inline] pub fn get_items_source_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapItemsControlStatics>>::get_activation_factory().get_items_source_property()
    }}
    #[inline] pub fn get_items_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapItemsControlStatics>>::get_activation_factory().get_items_property()
    }}
    #[inline] pub fn get_item_template_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapItemsControlStatics>>::get_activation_factory().get_item_template_property()
    }}
}
DEFINE_CLSID!(MapItemsControl(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,73,116,101,109,115,67,111,110,116,114,111,108,0]) [CLSID_MapItemsControl]);
DEFINE_IID!(IID_IMapRouteView, 1947119301, 47820, 16865, 166, 126, 221, 101, 19, 131, 32, 73);
RT_INTERFACE!{interface IMapRouteView(IMapRouteViewVtbl): IInspectable(IInspectableVtbl) [IID_IMapRouteView] {
    #[cfg(not(feature="windows-ui"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_RouteColor(&self, out: *mut super::super::super::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_RouteColor(&self, value: super::super::super::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_OutlineColor(&self, out: *mut super::super::super::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_OutlineColor(&self, value: super::super::super::Color) -> HRESULT,
    #[cfg(feature="windows-services")] fn get_Route(&self, out: *mut *mut ::rt::gen::windows::services::maps::MapRoute) -> HRESULT
}}
impl IMapRouteView {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_route_color(&self) -> Result<super::super::super::Color> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RouteColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_route_color(&self, value: super::super::super::Color) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RouteColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_outline_color(&self) -> Result<super::super::super::Color> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OutlineColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_outline_color(&self, value: super::super::super::Color) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OutlineColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-services")] #[inline] pub unsafe fn get_route(&self) -> Result<ComPtr<::rt::gen::windows::services::maps::MapRoute>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Route)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapRouteViewFactory, 4035161567, 102, 17960, 130, 254, 234, 120, 194, 60, 236, 30);
RT_INTERFACE!{interface IMapRouteViewFactory(IMapRouteViewFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMapRouteViewFactory] {
    #[cfg(feature="windows-services")] fn CreateInstanceWithMapRoute(&self, route: *mut ::rt::gen::windows::services::maps::MapRoute, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut MapRouteView) -> HRESULT
}}
impl IMapRouteViewFactory {
    #[cfg(feature="windows-services")] #[inline] pub unsafe fn create_instance_with_map_route(&self, route: &::rt::gen::windows::services::maps::MapRoute, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<MapRouteView>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithMapRoute)(self as *const _ as *mut _, route as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class MapRouteView: IMapRouteView}
DEFINE_IID!(IID_IMapScene, 2344226985, 20711, 18476, 151, 137, 198, 136, 177, 120, 172, 36);
RT_INTERFACE!{interface IMapScene(IMapSceneVtbl): IInspectable(IInspectableVtbl) [IID_IMapScene] {
    fn get_TargetCamera(&self, out: *mut *mut MapCamera) -> HRESULT,
    fn add_TargetCameraChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapScene, MapTargetCameraChangedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TargetCameraChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IMapScene {
    #[inline] pub unsafe fn get_target_camera(&self) -> Result<ComPtr<MapCamera>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetCamera)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_target_camera_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapScene, MapTargetCameraChangedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TargetCameraChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_target_camera_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_TargetCameraChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class MapScene: IMapScene}
impl RtActivatable<IMapSceneStatics> for MapScene {}
impl MapScene {
    #[cfg(feature="windows-devices")] #[inline] pub fn create_from_bounding_box(bounds: &::rt::gen::windows::devices::geolocation::GeoboundingBox) -> Result<ComPtr<MapScene>> { unsafe {
        <Self as RtActivatable<IMapSceneStatics>>::get_activation_factory().create_from_bounding_box(bounds)
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn create_from_bounding_box_with_heading_and_pitch(bounds: &::rt::gen::windows::devices::geolocation::GeoboundingBox, headingInDegrees: f64, pitchInDegrees: f64) -> Result<ComPtr<MapScene>> { unsafe {
        <Self as RtActivatable<IMapSceneStatics>>::get_activation_factory().create_from_bounding_box_with_heading_and_pitch(bounds, headingInDegrees, pitchInDegrees)
    }}
    #[inline] pub fn create_from_camera(camera: &MapCamera) -> Result<ComPtr<MapScene>> { unsafe {
        <Self as RtActivatable<IMapSceneStatics>>::get_activation_factory().create_from_camera(camera)
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn create_from_location(location: &::rt::gen::windows::devices::geolocation::Geopoint) -> Result<ComPtr<MapScene>> { unsafe {
        <Self as RtActivatable<IMapSceneStatics>>::get_activation_factory().create_from_location(location)
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn create_from_location_with_heading_and_pitch(location: &::rt::gen::windows::devices::geolocation::Geopoint, headingInDegrees: f64, pitchInDegrees: f64) -> Result<ComPtr<MapScene>> { unsafe {
        <Self as RtActivatable<IMapSceneStatics>>::get_activation_factory().create_from_location_with_heading_and_pitch(location, headingInDegrees, pitchInDegrees)
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn create_from_location_and_radius(location: &::rt::gen::windows::devices::geolocation::Geopoint, radiusInMeters: f64) -> Result<ComPtr<MapScene>> { unsafe {
        <Self as RtActivatable<IMapSceneStatics>>::get_activation_factory().create_from_location_and_radius(location, radiusInMeters)
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn create_from_location_and_radius_with_heading_and_pitch(location: &::rt::gen::windows::devices::geolocation::Geopoint, radiusInMeters: f64, headingInDegrees: f64, pitchInDegrees: f64) -> Result<ComPtr<MapScene>> { unsafe {
        <Self as RtActivatable<IMapSceneStatics>>::get_activation_factory().create_from_location_and_radius_with_heading_and_pitch(location, radiusInMeters, headingInDegrees, pitchInDegrees)
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn create_from_locations(locations: &::rt::gen::windows::foundation::collections::IIterable<::rt::gen::windows::devices::geolocation::Geopoint>) -> Result<ComPtr<MapScene>> { unsafe {
        <Self as RtActivatable<IMapSceneStatics>>::get_activation_factory().create_from_locations(locations)
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn create_from_locations_with_heading_and_pitch(locations: &::rt::gen::windows::foundation::collections::IIterable<::rt::gen::windows::devices::geolocation::Geopoint>, headingInDegrees: f64, pitchInDegrees: f64) -> Result<ComPtr<MapScene>> { unsafe {
        <Self as RtActivatable<IMapSceneStatics>>::get_activation_factory().create_from_locations_with_heading_and_pitch(locations, headingInDegrees, pitchInDegrees)
    }}
}
DEFINE_CLSID!(MapScene(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,83,99,101,110,101,0]) [CLSID_MapScene]);
DEFINE_IID!(IID_IMapSceneStatics, 65318252, 34540, 17625, 149, 151, 251, 117, 183, 222, 186, 10);
RT_INTERFACE!{static interface IMapSceneStatics(IMapSceneStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMapSceneStatics] {
    #[cfg(feature="windows-devices")] fn CreateFromBoundingBox(&self, bounds: *mut ::rt::gen::windows::devices::geolocation::GeoboundingBox, out: *mut *mut MapScene) -> HRESULT,
    #[cfg(feature="windows-devices")] fn CreateFromBoundingBoxWithHeadingAndPitch(&self, bounds: *mut ::rt::gen::windows::devices::geolocation::GeoboundingBox, headingInDegrees: f64, pitchInDegrees: f64, out: *mut *mut MapScene) -> HRESULT,
    fn CreateFromCamera(&self, camera: *mut MapCamera, out: *mut *mut MapScene) -> HRESULT,
    #[cfg(feature="windows-devices")] fn CreateFromLocation(&self, location: *mut ::rt::gen::windows::devices::geolocation::Geopoint, out: *mut *mut MapScene) -> HRESULT,
    #[cfg(feature="windows-devices")] fn CreateFromLocationWithHeadingAndPitch(&self, location: *mut ::rt::gen::windows::devices::geolocation::Geopoint, headingInDegrees: f64, pitchInDegrees: f64, out: *mut *mut MapScene) -> HRESULT,
    #[cfg(feature="windows-devices")] fn CreateFromLocationAndRadius(&self, location: *mut ::rt::gen::windows::devices::geolocation::Geopoint, radiusInMeters: f64, out: *mut *mut MapScene) -> HRESULT,
    #[cfg(feature="windows-devices")] fn CreateFromLocationAndRadiusWithHeadingAndPitch(&self, location: *mut ::rt::gen::windows::devices::geolocation::Geopoint, radiusInMeters: f64, headingInDegrees: f64, pitchInDegrees: f64, out: *mut *mut MapScene) -> HRESULT,
    #[cfg(feature="windows-devices")] fn CreateFromLocations(&self, locations: *mut ::rt::gen::windows::foundation::collections::IIterable<::rt::gen::windows::devices::geolocation::Geopoint>, out: *mut *mut MapScene) -> HRESULT,
    #[cfg(feature="windows-devices")] fn CreateFromLocationsWithHeadingAndPitch(&self, locations: *mut ::rt::gen::windows::foundation::collections::IIterable<::rt::gen::windows::devices::geolocation::Geopoint>, headingInDegrees: f64, pitchInDegrees: f64, out: *mut *mut MapScene) -> HRESULT
}}
impl IMapSceneStatics {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn create_from_bounding_box(&self, bounds: &::rt::gen::windows::devices::geolocation::GeoboundingBox) -> Result<ComPtr<MapScene>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateFromBoundingBox)(self as *const _ as *mut _, bounds as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn create_from_bounding_box_with_heading_and_pitch(&self, bounds: &::rt::gen::windows::devices::geolocation::GeoboundingBox, headingInDegrees: f64, pitchInDegrees: f64) -> Result<ComPtr<MapScene>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateFromBoundingBoxWithHeadingAndPitch)(self as *const _ as *mut _, bounds as *const _ as *mut _, headingInDegrees, pitchInDegrees, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_from_camera(&self, camera: &MapCamera) -> Result<ComPtr<MapScene>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateFromCamera)(self as *const _ as *mut _, camera as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn create_from_location(&self, location: &::rt::gen::windows::devices::geolocation::Geopoint) -> Result<ComPtr<MapScene>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateFromLocation)(self as *const _ as *mut _, location as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn create_from_location_with_heading_and_pitch(&self, location: &::rt::gen::windows::devices::geolocation::Geopoint, headingInDegrees: f64, pitchInDegrees: f64) -> Result<ComPtr<MapScene>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateFromLocationWithHeadingAndPitch)(self as *const _ as *mut _, location as *const _ as *mut _, headingInDegrees, pitchInDegrees, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn create_from_location_and_radius(&self, location: &::rt::gen::windows::devices::geolocation::Geopoint, radiusInMeters: f64) -> Result<ComPtr<MapScene>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateFromLocationAndRadius)(self as *const _ as *mut _, location as *const _ as *mut _, radiusInMeters, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn create_from_location_and_radius_with_heading_and_pitch(&self, location: &::rt::gen::windows::devices::geolocation::Geopoint, radiusInMeters: f64, headingInDegrees: f64, pitchInDegrees: f64) -> Result<ComPtr<MapScene>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateFromLocationAndRadiusWithHeadingAndPitch)(self as *const _ as *mut _, location as *const _ as *mut _, radiusInMeters, headingInDegrees, pitchInDegrees, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn create_from_locations(&self, locations: &::rt::gen::windows::foundation::collections::IIterable<::rt::gen::windows::devices::geolocation::Geopoint>) -> Result<ComPtr<MapScene>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateFromLocations)(self as *const _ as *mut _, locations as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn create_from_locations_with_heading_and_pitch(&self, locations: &::rt::gen::windows::foundation::collections::IIterable<::rt::gen::windows::devices::geolocation::Geopoint>, headingInDegrees: f64, pitchInDegrees: f64) -> Result<ComPtr<MapScene>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateFromLocationsWithHeadingAndPitch)(self as *const _ as *mut _, locations as *const _ as *mut _, headingInDegrees, pitchInDegrees, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapStyleSheet, 2924786367, 35217, 17133, 141, 88, 32, 71, 61, 238, 222, 29);
RT_INTERFACE!{interface IMapStyleSheet(IMapStyleSheetVtbl): IInspectable(IInspectableVtbl) [IID_IMapStyleSheet] {
    
}}
DEFINE_IID!(IID_IMapStyleSheetStatics, 2881290413, 2588, 17205, 130, 244, 97, 217, 54, 170, 25, 125);
RT_INTERFACE!{static interface IMapStyleSheetStatics(IMapStyleSheetStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMapStyleSheetStatics] {
    fn Aerial(&self, out: *mut *mut MapStyleSheet) -> HRESULT,
    fn AerialWithOverlay(&self, out: *mut *mut MapStyleSheet) -> HRESULT,
    fn RoadLight(&self, out: *mut *mut MapStyleSheet) -> HRESULT,
    fn RoadDark(&self, out: *mut *mut MapStyleSheet) -> HRESULT,
    fn RoadHighContrastLight(&self, out: *mut *mut MapStyleSheet) -> HRESULT,
    fn RoadHighContrastDark(&self, out: *mut *mut MapStyleSheet) -> HRESULT,
    fn Combine(&self, styleSheets: *mut ::rt::gen::windows::foundation::collections::IIterable<MapStyleSheet>, out: *mut *mut MapStyleSheet) -> HRESULT,
    fn ParseFromJson(&self, styleAsJson: HSTRING, out: *mut *mut MapStyleSheet) -> HRESULT,
    fn TryParseFromJson(&self, styleAsJson: HSTRING, styleSheet: *mut *mut MapStyleSheet, out: *mut bool) -> HRESULT
}}
impl IMapStyleSheetStatics {
    #[inline] pub unsafe fn aerial(&self) -> Result<ComPtr<MapStyleSheet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Aerial)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn aerial_with_overlay(&self) -> Result<ComPtr<MapStyleSheet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).AerialWithOverlay)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn road_light(&self) -> Result<ComPtr<MapStyleSheet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RoadLight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn road_dark(&self) -> Result<ComPtr<MapStyleSheet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RoadDark)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn road_high_contrast_light(&self) -> Result<ComPtr<MapStyleSheet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RoadHighContrastLight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn road_high_contrast_dark(&self) -> Result<ComPtr<MapStyleSheet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RoadHighContrastDark)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn combine(&self, styleSheets: &::rt::gen::windows::foundation::collections::IIterable<MapStyleSheet>) -> Result<ComPtr<MapStyleSheet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Combine)(self as *const _ as *mut _, styleSheets as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn parse_from_json(&self, styleAsJson: &HStringArg) -> Result<ComPtr<MapStyleSheet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ParseFromJson)(self as *const _ as *mut _, styleAsJson.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_parse_from_json(&self, styleAsJson: &HStringArg) -> Result<(ComPtr<MapStyleSheet>, bool)> {
        let mut styleSheet = null_mut(); let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryParseFromJson)(self as *const _ as *mut _, styleAsJson.get(), &mut styleSheet, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(styleSheet), out)) } else { err(hr) }
    }
}
RT_CLASS!{class MapStyleSheet: IMapStyleSheet}
impl RtActivatable<IMapStyleSheetStatics> for MapStyleSheet {}
impl MapStyleSheet {
    #[inline] pub fn aerial() -> Result<ComPtr<MapStyleSheet>> { unsafe {
        <Self as RtActivatable<IMapStyleSheetStatics>>::get_activation_factory().aerial()
    }}
    #[inline] pub fn aerial_with_overlay() -> Result<ComPtr<MapStyleSheet>> { unsafe {
        <Self as RtActivatable<IMapStyleSheetStatics>>::get_activation_factory().aerial_with_overlay()
    }}
    #[inline] pub fn road_light() -> Result<ComPtr<MapStyleSheet>> { unsafe {
        <Self as RtActivatable<IMapStyleSheetStatics>>::get_activation_factory().road_light()
    }}
    #[inline] pub fn road_dark() -> Result<ComPtr<MapStyleSheet>> { unsafe {
        <Self as RtActivatable<IMapStyleSheetStatics>>::get_activation_factory().road_dark()
    }}
    #[inline] pub fn road_high_contrast_light() -> Result<ComPtr<MapStyleSheet>> { unsafe {
        <Self as RtActivatable<IMapStyleSheetStatics>>::get_activation_factory().road_high_contrast_light()
    }}
    #[inline] pub fn road_high_contrast_dark() -> Result<ComPtr<MapStyleSheet>> { unsafe {
        <Self as RtActivatable<IMapStyleSheetStatics>>::get_activation_factory().road_high_contrast_dark()
    }}
    #[inline] pub fn combine(styleSheets: &::rt::gen::windows::foundation::collections::IIterable<MapStyleSheet>) -> Result<ComPtr<MapStyleSheet>> { unsafe {
        <Self as RtActivatable<IMapStyleSheetStatics>>::get_activation_factory().combine(styleSheets)
    }}
    #[inline] pub fn parse_from_json(styleAsJson: &HStringArg) -> Result<ComPtr<MapStyleSheet>> { unsafe {
        <Self as RtActivatable<IMapStyleSheetStatics>>::get_activation_factory().parse_from_json(styleAsJson)
    }}
    #[inline] pub fn try_parse_from_json(styleAsJson: &HStringArg) -> Result<(ComPtr<MapStyleSheet>, bool)> { unsafe {
        <Self as RtActivatable<IMapStyleSheetStatics>>::get_activation_factory().try_parse_from_json(styleAsJson)
    }}
}
DEFINE_CLSID!(MapStyleSheet(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,83,116,121,108,101,83,104,101,101,116,0]) [CLSID_MapStyleSheet]);
DEFINE_IID!(IID_IMapTileDataSource, 3225263966, 48671, 19561, 153, 105, 121, 70, 122, 81, 60, 56);
RT_INTERFACE!{interface IMapTileDataSource(IMapTileDataSourceVtbl): IInspectable(IInspectableVtbl) [IID_IMapTileDataSource] {
    
}}
DEFINE_IID!(IID_IMapTileDataSourceFactory, 2744258493, 58438, 17992, 167, 77, 253, 44, 93, 85, 124, 6);
RT_INTERFACE!{interface IMapTileDataSourceFactory(IMapTileDataSourceFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMapTileDataSourceFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut MapTileDataSource) -> HRESULT
}}
impl IMapTileDataSourceFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<MapTileDataSource>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class MapTileDataSource: IMapTileDataSource}
DEFINE_IID!(IID_IMapTileSource, 2292674126, 12255, 17767, 146, 85, 17, 0, 81, 156, 141, 98);
RT_INTERFACE!{interface IMapTileSource(IMapTileSourceVtbl): IInspectable(IInspectableVtbl) [IID_IMapTileSource] {
    fn get_DataSource(&self, out: *mut *mut MapTileDataSource) -> HRESULT,
    fn put_DataSource(&self, value: *mut MapTileDataSource) -> HRESULT,
    fn get_Layer(&self, out: *mut MapTileLayer) -> HRESULT,
    fn put_Layer(&self, value: MapTileLayer) -> HRESULT,
    fn get_ZoomLevelRange(&self, out: *mut MapZoomLevelRange) -> HRESULT,
    fn put_ZoomLevelRange(&self, value: MapZoomLevelRange) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_Bounds(&self, out: *mut *mut ::rt::gen::windows::devices::geolocation::GeoboundingBox) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-devices")] fn put_Bounds(&self, value: *mut ::rt::gen::windows::devices::geolocation::GeoboundingBox) -> HRESULT,
    fn get_AllowOverstretch(&self, out: *mut bool) -> HRESULT,
    fn put_AllowOverstretch(&self, value: bool) -> HRESULT,
    fn get_IsFadingEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsFadingEnabled(&self, value: bool) -> HRESULT,
    fn get_IsTransparencyEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsTransparencyEnabled(&self, value: bool) -> HRESULT,
    fn get_IsRetryEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsRetryEnabled(&self, value: bool) -> HRESULT,
    fn get_ZIndex(&self, out: *mut i32) -> HRESULT,
    fn put_ZIndex(&self, value: i32) -> HRESULT,
    fn get_TilePixelSize(&self, out: *mut i32) -> HRESULT,
    fn put_TilePixelSize(&self, value: i32) -> HRESULT,
    fn get_Visible(&self, out: *mut bool) -> HRESULT,
    fn put_Visible(&self, value: bool) -> HRESULT
}}
impl IMapTileSource {
    #[inline] pub unsafe fn get_data_source(&self) -> Result<ComPtr<MapTileDataSource>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DataSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_data_source(&self, value: &MapTileDataSource) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DataSource)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_layer(&self) -> Result<MapTileLayer> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Layer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_layer(&self, value: MapTileLayer) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Layer)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoom_level_range(&self) -> Result<MapZoomLevelRange> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ZoomLevelRange)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_zoom_level_range(&self, value: MapZoomLevelRange) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ZoomLevelRange)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_bounds(&self) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::GeoboundingBox>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Bounds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn set_bounds(&self, value: &::rt::gen::windows::devices::geolocation::GeoboundingBox) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Bounds)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_allow_overstretch(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AllowOverstretch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_allow_overstretch(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AllowOverstretch)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_fading_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsFadingEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_fading_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsFadingEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_transparency_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTransparencyEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_transparency_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsTransparencyEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_retry_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsRetryEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_retry_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsRetryEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zindex(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ZIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_zindex(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ZIndex)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tile_pixel_size(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TilePixelSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_tile_pixel_size(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TilePixelSize)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Visible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Visible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapTileSourceStatics, 2482817340, 28725, 17923, 153, 177, 230, 89, 146, 27, 96, 147);
RT_INTERFACE!{static interface IMapTileSourceStatics(IMapTileSourceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMapTileSourceStatics] {
    fn get_DataSourceProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_LayerProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ZoomLevelRangeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_BoundsProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_AllowOverstretchProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_IsFadingEnabledProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_IsTransparencyEnabledProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_IsRetryEnabledProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ZIndexProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_TilePixelSizeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_VisibleProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IMapTileSourceStatics {
    #[inline] pub unsafe fn get_data_source_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DataSourceProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_layer_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LayerProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoom_level_range_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ZoomLevelRangeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_bounds_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BoundsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_allow_overstretch_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AllowOverstretchProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_fading_enabled_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsFadingEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_transparency_enabled_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsTransparencyEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_retry_enabled_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsRetryEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zindex_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ZIndexProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tile_pixel_size_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TilePixelSizeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_visible_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapTileSourceFactory, 3447685407, 30714, 18475, 157, 52, 113, 211, 29, 70, 92, 72);
RT_INTERFACE!{interface IMapTileSourceFactory(IMapTileSourceFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMapTileSourceFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut MapTileSource) -> HRESULT,
    fn CreateInstanceWithDataSource(&self, dataSource: *mut MapTileDataSource, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut MapTileSource) -> HRESULT,
    fn CreateInstanceWithDataSourceAndZoomRange(&self, dataSource: *mut MapTileDataSource, zoomLevelRange: MapZoomLevelRange, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut MapTileSource) -> HRESULT,
    #[cfg(feature="windows-devices")] fn CreateInstanceWithDataSourceZoomRangeAndBounds(&self, dataSource: *mut MapTileDataSource, zoomLevelRange: MapZoomLevelRange, bounds: *mut ::rt::gen::windows::devices::geolocation::GeoboundingBox, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut MapTileSource) -> HRESULT,
    #[cfg(feature="windows-devices")] fn CreateInstanceWithDataSourceZoomRangeBoundsAndTileSize(&self, dataSource: *mut MapTileDataSource, zoomLevelRange: MapZoomLevelRange, bounds: *mut ::rt::gen::windows::devices::geolocation::GeoboundingBox, tileSizeInPixels: i32, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut MapTileSource) -> HRESULT
}}
impl IMapTileSourceFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<MapTileSource>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_instance_with_data_source(&self, dataSource: &MapTileDataSource, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<MapTileSource>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithDataSource)(self as *const _ as *mut _, dataSource as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_instance_with_data_source_and_zoom_range(&self, dataSource: &MapTileDataSource, zoomLevelRange: MapZoomLevelRange, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<MapTileSource>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithDataSourceAndZoomRange)(self as *const _ as *mut _, dataSource as *const _ as *mut _, zoomLevelRange, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn create_instance_with_data_source_zoom_range_and_bounds(&self, dataSource: &MapTileDataSource, zoomLevelRange: MapZoomLevelRange, bounds: &::rt::gen::windows::devices::geolocation::GeoboundingBox, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<MapTileSource>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithDataSourceZoomRangeAndBounds)(self as *const _ as *mut _, dataSource as *const _ as *mut _, zoomLevelRange, bounds as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn create_instance_with_data_source_zoom_range_bounds_and_tile_size(&self, dataSource: &MapTileDataSource, zoomLevelRange: MapZoomLevelRange, bounds: &::rt::gen::windows::devices::geolocation::GeoboundingBox, tileSizeInPixels: i32, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<MapTileSource>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithDataSourceZoomRangeBoundsAndTileSize)(self as *const _ as *mut _, dataSource as *const _ as *mut _, zoomLevelRange, bounds as *const _ as *mut _, tileSizeInPixels, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class MapTileSource: IMapTileSource}
impl RtActivatable<IMapTileSourceStatics> for MapTileSource {}
impl MapTileSource {
    #[inline] pub fn get_data_source_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapTileSourceStatics>>::get_activation_factory().get_data_source_property()
    }}
    #[inline] pub fn get_layer_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapTileSourceStatics>>::get_activation_factory().get_layer_property()
    }}
    #[inline] pub fn get_zoom_level_range_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapTileSourceStatics>>::get_activation_factory().get_zoom_level_range_property()
    }}
    #[inline] pub fn get_bounds_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapTileSourceStatics>>::get_activation_factory().get_bounds_property()
    }}
    #[inline] pub fn get_allow_overstretch_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapTileSourceStatics>>::get_activation_factory().get_allow_overstretch_property()
    }}
    #[inline] pub fn get_is_fading_enabled_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapTileSourceStatics>>::get_activation_factory().get_is_fading_enabled_property()
    }}
    #[inline] pub fn get_is_transparency_enabled_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapTileSourceStatics>>::get_activation_factory().get_is_transparency_enabled_property()
    }}
    #[inline] pub fn get_is_retry_enabled_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapTileSourceStatics>>::get_activation_factory().get_is_retry_enabled_property()
    }}
    #[inline] pub fn get_zindex_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapTileSourceStatics>>::get_activation_factory().get_zindex_property()
    }}
    #[inline] pub fn get_tile_pixel_size_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapTileSourceStatics>>::get_activation_factory().get_tile_pixel_size_property()
    }}
    #[inline] pub fn get_visible_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapTileSourceStatics>>::get_activation_factory().get_visible_property()
    }}
}
DEFINE_CLSID!(MapTileSource(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,84,105,108,101,83,111,117,114,99,101,0]) [CLSID_MapTileSource]);
DEFINE_IID!(IID_IStreetsidePanorama, 1876955096, 44384, 18020, 181, 57, 177, 6, 159, 22, 197, 175);
RT_INTERFACE!{interface IStreetsidePanorama(IStreetsidePanoramaVtbl): IInspectable(IInspectableVtbl) [IID_IStreetsidePanorama] {
    #[cfg(feature="windows-devices")] fn get_Location(&self, out: *mut *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT
}}
impl IStreetsidePanorama {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_location(&self) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::Geopoint>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Location)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IStreetsidePanoramaStatics, 3551821673, 21683, 20165, 178, 160, 79, 130, 4, 87, 101, 7);
RT_INTERFACE!{static interface IStreetsidePanoramaStatics(IStreetsidePanoramaStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IStreetsidePanoramaStatics] {
    #[cfg(feature="windows-devices")] fn FindNearbyWithLocationAsync(&self, location: *mut ::rt::gen::windows::devices::geolocation::Geopoint, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<StreetsidePanorama>) -> HRESULT,
    #[cfg(feature="windows-devices")] fn FindNearbyWithLocationAndRadiusAsync(&self, location: *mut ::rt::gen::windows::devices::geolocation::Geopoint, radiusInMeters: f64, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<StreetsidePanorama>) -> HRESULT
}}
impl IStreetsidePanoramaStatics {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn find_nearby_with_location_async(&self, location: &::rt::gen::windows::devices::geolocation::Geopoint) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<StreetsidePanorama>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindNearbyWithLocationAsync)(self as *const _ as *mut _, location as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn find_nearby_with_location_and_radius_async(&self, location: &::rt::gen::windows::devices::geolocation::Geopoint, radiusInMeters: f64) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<StreetsidePanorama>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindNearbyWithLocationAndRadiusAsync)(self as *const _ as *mut _, location as *const _ as *mut _, radiusInMeters, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class StreetsidePanorama: IStreetsidePanorama}
impl RtActivatable<IStreetsidePanoramaStatics> for StreetsidePanorama {}
impl StreetsidePanorama {
    #[cfg(feature="windows-devices")] #[inline] pub fn find_nearby_with_location_async(location: &::rt::gen::windows::devices::geolocation::Geopoint) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<StreetsidePanorama>>> { unsafe {
        <Self as RtActivatable<IStreetsidePanoramaStatics>>::get_activation_factory().find_nearby_with_location_async(location)
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn find_nearby_with_location_and_radius_async(location: &::rt::gen::windows::devices::geolocation::Geopoint, radiusInMeters: f64) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<StreetsidePanorama>>> { unsafe {
        <Self as RtActivatable<IStreetsidePanoramaStatics>>::get_activation_factory().find_nearby_with_location_and_radius_async(location, radiusInMeters)
    }}
}
DEFINE_CLSID!(StreetsidePanorama(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,83,116,114,101,101,116,115,105,100,101,80,97,110,111,114,97,109,97,0]) [CLSID_StreetsidePanorama]);
DEFINE_IID!(IID_ICustomMapTileDataSource, 1708800074, 11697, 19425, 177, 85, 61, 12, 158, 207, 71, 153);
RT_INTERFACE!{interface ICustomMapTileDataSource(ICustomMapTileDataSourceVtbl): IInspectable(IInspectableVtbl) [IID_ICustomMapTileDataSource] {
    fn add_BitmapRequested(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<CustomMapTileDataSource, MapTileBitmapRequestedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BitmapRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl ICustomMapTileDataSource {
    #[inline] pub unsafe fn add_bitmap_requested(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<CustomMapTileDataSource, MapTileBitmapRequestedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_BitmapRequested)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_bitmap_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_BitmapRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class CustomMapTileDataSource: ICustomMapTileDataSource}
DEFINE_IID!(IID_ICustomMapTileDataSourceFactory, 3360127303, 51541, 20258, 148, 68, 161, 216, 215, 68, 175, 17);
RT_INTERFACE!{interface ICustomMapTileDataSourceFactory(ICustomMapTileDataSourceFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICustomMapTileDataSourceFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut CustomMapTileDataSource) -> HRESULT
}}
impl ICustomMapTileDataSourceFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<CustomMapTileDataSource>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IHttpMapTileDataSource, 2634271580, 64889, 18325, 135, 190, 126, 84, 202, 11, 55, 208);
RT_INTERFACE!{interface IHttpMapTileDataSource(IHttpMapTileDataSourceVtbl): IInspectable(IInspectableVtbl) [IID_IHttpMapTileDataSource] {
    fn get_UriFormatString(&self, out: *mut HSTRING) -> HRESULT,
    fn put_UriFormatString(&self, value: HSTRING) -> HRESULT,
    fn get_AdditionalRequestHeaders(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IMap<HString, HString>) -> HRESULT,
    fn get_AllowCaching(&self, out: *mut bool) -> HRESULT,
    fn put_AllowCaching(&self, value: bool) -> HRESULT,
    fn add_UriRequested(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<HttpMapTileDataSource, MapTileUriRequestedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_UriRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IHttpMapTileDataSource {
    #[inline] pub unsafe fn get_uri_format_string(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UriFormatString)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_uri_format_string(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_UriFormatString)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_additional_request_headers(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IMap<HString, HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AdditionalRequestHeaders)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_allow_caching(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AllowCaching)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_allow_caching(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AllowCaching)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_uri_requested(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<HttpMapTileDataSource, MapTileUriRequestedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_UriRequested)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_uri_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_UriRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class HttpMapTileDataSource: IHttpMapTileDataSource}
DEFINE_IID!(IID_IHttpMapTileDataSourceFactory, 1404350727, 34012, 17041, 137, 248, 109, 11, 182, 18, 160, 85);
RT_INTERFACE!{interface IHttpMapTileDataSourceFactory(IHttpMapTileDataSourceFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IHttpMapTileDataSourceFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut HttpMapTileDataSource) -> HRESULT,
    fn CreateInstanceWithUriFormatString(&self, uriFormatString: HSTRING, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut HttpMapTileDataSource) -> HRESULT
}}
impl IHttpMapTileDataSourceFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<HttpMapTileDataSource>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_instance_with_uri_format_string(&self, uriFormatString: &HStringArg, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<HttpMapTileDataSource>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithUriFormatString)(self as *const _ as *mut _, uriFormatString.get(), outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ILocalMapTileDataSource, 1633834933, 37128, 20242, 139, 244, 187, 60, 143, 98, 116, 229);
RT_INTERFACE!{interface ILocalMapTileDataSource(ILocalMapTileDataSourceVtbl): IInspectable(IInspectableVtbl) [IID_ILocalMapTileDataSource] {
    fn get_UriFormatString(&self, out: *mut HSTRING) -> HRESULT,
    fn put_UriFormatString(&self, value: HSTRING) -> HRESULT,
    fn add_UriRequested(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<LocalMapTileDataSource, MapTileUriRequestedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_UriRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl ILocalMapTileDataSource {
    #[inline] pub unsafe fn get_uri_format_string(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UriFormatString)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_uri_format_string(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_UriFormatString)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_uri_requested(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<LocalMapTileDataSource, MapTileUriRequestedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_UriRequested)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_uri_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_UriRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class LocalMapTileDataSource: ILocalMapTileDataSource}
DEFINE_IID!(IID_ILocalMapTileDataSourceFactory, 3318737404, 29356, 18489, 138, 13, 1, 31, 36, 105, 60, 121);
RT_INTERFACE!{interface ILocalMapTileDataSourceFactory(ILocalMapTileDataSourceFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ILocalMapTileDataSourceFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut LocalMapTileDataSource) -> HRESULT,
    fn CreateInstanceWithUriFormatString(&self, uriFormatString: HSTRING, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut LocalMapTileDataSource) -> HRESULT
}}
impl ILocalMapTileDataSourceFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<LocalMapTileDataSource>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_instance_with_uri_format_string(&self, uriFormatString: &HStringArg, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<LocalMapTileDataSource>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithUriFormatString)(self as *const _ as *mut _, uriFormatString.get(), outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapBillboard, 378807709, 2786, 20290, 160, 46, 41, 44, 168, 53, 211, 157);
RT_INTERFACE!{interface IMapBillboard(IMapBillboardVtbl): IInspectable(IInspectableVtbl) [IID_IMapBillboard] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_Location(&self, out: *mut *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-devices")] fn put_Location(&self, value: *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT,
    fn get_NormalizedAnchorPoint(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn put_NormalizedAnchorPoint(&self, value: ::rt::gen::windows::foundation::Point) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Image(&self, out: *mut *mut ::rt::gen::windows::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Image(&self, value: *mut ::rt::gen::windows::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    fn get_CollisionBehaviorDesired(&self, out: *mut MapElementCollisionBehavior) -> HRESULT,
    fn put_CollisionBehaviorDesired(&self, value: MapElementCollisionBehavior) -> HRESULT,
    fn get_ReferenceCamera(&self, out: *mut *mut MapCamera) -> HRESULT
}}
impl IMapBillboard {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_location(&self) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::Geopoint>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Location)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn set_location(&self, value: &::rt::gen::windows::devices::geolocation::Geopoint) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Location)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_normalized_anchor_point(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NormalizedAnchorPoint)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_normalized_anchor_point(&self, value: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).put_NormalizedAnchorPoint)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_image(&self) -> Result<ComPtr<::rt::gen::windows::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Image)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_image(&self, value: &::rt::gen::windows::storage::streams::IRandomAccessStreamReference) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Image)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_collision_behavior_desired(&self) -> Result<MapElementCollisionBehavior> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CollisionBehaviorDesired)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_collision_behavior_desired(&self, value: MapElementCollisionBehavior) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CollisionBehaviorDesired)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_reference_camera(&self) -> Result<ComPtr<MapCamera>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ReferenceCamera)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapBillboardStatics, 4260903422, 57847, 20400, 136, 135, 125, 166, 140, 100, 115, 51);
RT_INTERFACE!{static interface IMapBillboardStatics(IMapBillboardStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMapBillboardStatics] {
    fn get_LocationProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_NormalizedAnchorPointProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_CollisionBehaviorDesiredProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IMapBillboardStatics {
    #[inline] pub unsafe fn get_location_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LocationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_normalized_anchor_point_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NormalizedAnchorPointProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_collision_behavior_desired_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CollisionBehaviorDesiredProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapBillboardFactory, 3192235205, 36617, 19334, 174, 40, 120, 55, 64, 235, 139, 49);
RT_INTERFACE!{static interface IMapBillboardFactory(IMapBillboardFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMapBillboardFactory] {
    fn CreateInstanceFromCamera(&self, camera: *mut MapCamera, out: *mut *mut MapBillboard) -> HRESULT
}}
impl IMapBillboardFactory {
    #[inline] pub unsafe fn create_instance_from_camera(&self, camera: &MapCamera) -> Result<ComPtr<MapBillboard>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceFromCamera)(self as *const _ as *mut _, camera as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class MapBillboard: IMapBillboard}
impl RtActivatable<IMapBillboardFactory> for MapBillboard {}
impl RtActivatable<IMapBillboardStatics> for MapBillboard {}
impl MapBillboard {
    #[inline] pub fn create_instance_from_camera(camera: &MapCamera) -> Result<ComPtr<MapBillboard>> { unsafe {
        <Self as RtActivatable<IMapBillboardFactory>>::get_activation_factory().create_instance_from_camera(camera)
    }}
    #[inline] pub fn get_location_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapBillboardStatics>>::get_activation_factory().get_location_property()
    }}
    #[inline] pub fn get_normalized_anchor_point_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapBillboardStatics>>::get_activation_factory().get_normalized_anchor_point_property()
    }}
    #[inline] pub fn get_collision_behavior_desired_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapBillboardStatics>>::get_activation_factory().get_collision_behavior_desired_property()
    }}
}
DEFINE_CLSID!(MapBillboard(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,66,105,108,108,98,111,97,114,100,0]) [CLSID_MapBillboard]);
DEFINE_IID!(IID_IMapIcon, 3523831922, 9177, 18987, 139, 224, 105, 243, 168, 84, 130, 171);
RT_INTERFACE!{interface IMapIcon(IMapIconVtbl): IInspectable(IInspectableVtbl) [IID_IMapIcon] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_Location(&self, out: *mut *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-devices")] fn put_Location(&self, value: *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT,
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    fn get_NormalizedAnchorPoint(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn put_NormalizedAnchorPoint(&self, value: ::rt::gen::windows::foundation::Point) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_Image(&self, out: *mut *mut ::rt::gen::windows::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_Image(&self, value: *mut ::rt::gen::windows::storage::streams::IRandomAccessStreamReference) -> HRESULT
}}
impl IMapIcon {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_location(&self) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::Geopoint>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Location)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn set_location(&self, value: &::rt::gen::windows::devices::geolocation::Geopoint) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Location)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_title(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Title)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_title(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Title)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_normalized_anchor_point(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NormalizedAnchorPoint)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_normalized_anchor_point(&self, value: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).put_NormalizedAnchorPoint)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_image(&self) -> Result<ComPtr<::rt::gen::windows::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Image)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_image(&self, value: &::rt::gen::windows::storage::streams::IRandomAccessStreamReference) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Image)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapIconStatics, 3703348822, 4496, 19293, 158, 86, 229, 182, 114, 74, 163, 40);
RT_INTERFACE!{static interface IMapIconStatics(IMapIconStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMapIconStatics] {
    fn get_LocationProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_TitleProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_NormalizedAnchorPointProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IMapIconStatics {
    #[inline] pub unsafe fn get_location_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LocationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_title_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TitleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_normalized_anchor_point_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NormalizedAnchorPointProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapIcon2, 1628591289, 55466, 19389, 163, 22, 186, 223, 6, 145, 29, 99);
RT_INTERFACE!{interface IMapIcon2(IMapIcon2Vtbl): IInspectable(IInspectableVtbl) [IID_IMapIcon2] {
    fn get_CollisionBehaviorDesired(&self, out: *mut MapElementCollisionBehavior) -> HRESULT,
    fn put_CollisionBehaviorDesired(&self, value: MapElementCollisionBehavior) -> HRESULT
}}
impl IMapIcon2 {
    #[inline] pub unsafe fn get_collision_behavior_desired(&self) -> Result<MapElementCollisionBehavior> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CollisionBehaviorDesired)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_collision_behavior_desired(&self, value: MapElementCollisionBehavior) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CollisionBehaviorDesired)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapIconStatics2, 4283183210, 53110, 18091, 161, 47, 182, 3, 185, 134, 198, 150);
RT_INTERFACE!{static interface IMapIconStatics2(IMapIconStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IMapIconStatics2] {
    fn get_CollisionBehaviorDesiredProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IMapIconStatics2 {
    #[inline] pub unsafe fn get_collision_behavior_desired_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CollisionBehaviorDesiredProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class MapIcon: IMapIcon}
impl RtActivatable<IMapIconStatics> for MapIcon {}
impl RtActivatable<IMapIconStatics2> for MapIcon {}
impl RtActivatable<IActivationFactory> for MapIcon {}
impl MapIcon {
    #[inline] pub fn get_location_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapIconStatics>>::get_activation_factory().get_location_property()
    }}
    #[inline] pub fn get_title_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapIconStatics>>::get_activation_factory().get_title_property()
    }}
    #[inline] pub fn get_normalized_anchor_point_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapIconStatics>>::get_activation_factory().get_normalized_anchor_point_property()
    }}
    #[inline] pub fn get_collision_behavior_desired_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapIconStatics2>>::get_activation_factory().get_collision_behavior_desired_property()
    }}
}
DEFINE_CLSID!(MapIcon(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,73,99,111,110,0]) [CLSID_MapIcon]);
DEFINE_IID!(IID_IMapPolygon, 2883199621, 18726, 19514, 165, 249, 25, 223, 127, 105, 219, 61);
RT_INTERFACE!{interface IMapPolygon(IMapPolygonVtbl): IInspectable(IInspectableVtbl) [IID_IMapPolygon] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_Path(&self, out: *mut *mut ::rt::gen::windows::devices::geolocation::Geopath) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-devices")] fn put_Path(&self, value: *mut ::rt::gen::windows::devices::geolocation::Geopath) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_StrokeColor(&self, out: *mut super::super::super::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_StrokeColor(&self, value: super::super::super::Color) -> HRESULT,
    fn get_StrokeThickness(&self, out: *mut f64) -> HRESULT,
    fn put_StrokeThickness(&self, value: f64) -> HRESULT,
    fn get_StrokeDashed(&self, out: *mut bool) -> HRESULT,
    fn put_StrokeDashed(&self, value: bool) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_FillColor(&self, out: *mut super::super::super::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_FillColor(&self, value: super::super::super::Color) -> HRESULT
}}
impl IMapPolygon {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_path(&self) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::Geopath>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Path)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn set_path(&self, value: &::rt::gen::windows::devices::geolocation::Geopath) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Path)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_stroke_color(&self) -> Result<super::super::super::Color> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StrokeColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_stroke_color(&self, value: super::super::super::Color) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StrokeColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_thickness(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StrokeThickness)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stroke_thickness(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StrokeThickness)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_dashed(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StrokeDashed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stroke_dashed(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StrokeDashed)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_fill_color(&self) -> Result<super::super::super::Color> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FillColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_fill_color(&self, value: super::super::super::Color) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FillColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapPolygonStatics, 938832830, 2427, 16972, 135, 204, 46, 224, 66, 253, 166, 210);
RT_INTERFACE!{static interface IMapPolygonStatics(IMapPolygonStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMapPolygonStatics] {
    fn get_PathProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_StrokeThicknessProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_StrokeDashedProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IMapPolygonStatics {
    #[inline] pub unsafe fn get_path_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PathProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_thickness_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StrokeThicknessProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_dashed_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StrokeDashedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapPolygon2, 2529730846, 25451, 16408, 156, 46, 172, 201, 18, 42, 1, 178);
RT_INTERFACE!{interface IMapPolygon2(IMapPolygon2Vtbl): IInspectable(IInspectableVtbl) [IID_IMapPolygon2] {
    #[cfg(feature="windows-devices")] fn get_Paths(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<::rt::gen::windows::devices::geolocation::Geopath>) -> HRESULT
}}
impl IMapPolygon2 {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_paths(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<::rt::gen::windows::devices::geolocation::Geopath>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Paths)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class MapPolygon: IMapPolygon}
impl RtActivatable<IMapPolygonStatics> for MapPolygon {}
impl RtActivatable<IActivationFactory> for MapPolygon {}
impl MapPolygon {
    #[inline] pub fn get_path_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapPolygonStatics>>::get_activation_factory().get_path_property()
    }}
    #[inline] pub fn get_stroke_thickness_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapPolygonStatics>>::get_activation_factory().get_stroke_thickness_property()
    }}
    #[inline] pub fn get_stroke_dashed_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapPolygonStatics>>::get_activation_factory().get_stroke_dashed_property()
    }}
}
DEFINE_CLSID!(MapPolygon(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,80,111,108,121,103,111,110,0]) [CLSID_MapPolygon]);
DEFINE_IID!(IID_IMapPolyline, 4222428322, 9439, 19078, 143, 250, 15, 143, 77, 158, 193, 125);
RT_INTERFACE!{interface IMapPolyline(IMapPolylineVtbl): IInspectable(IInspectableVtbl) [IID_IMapPolyline] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_Path(&self, out: *mut *mut ::rt::gen::windows::devices::geolocation::Geopath) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-devices")] fn put_Path(&self, value: *mut ::rt::gen::windows::devices::geolocation::Geopath) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_StrokeColor(&self, out: *mut super::super::super::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_StrokeColor(&self, value: super::super::super::Color) -> HRESULT,
    fn get_StrokeThickness(&self, out: *mut f64) -> HRESULT,
    fn put_StrokeThickness(&self, value: f64) -> HRESULT,
    fn get_StrokeDashed(&self, out: *mut bool) -> HRESULT,
    fn put_StrokeDashed(&self, value: bool) -> HRESULT
}}
impl IMapPolyline {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_path(&self) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::Geopath>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Path)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn set_path(&self, value: &::rt::gen::windows::devices::geolocation::Geopath) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Path)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_stroke_color(&self) -> Result<super::super::super::Color> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StrokeColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_stroke_color(&self, value: super::super::super::Color) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StrokeColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_thickness(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StrokeThickness)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stroke_thickness(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StrokeThickness)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_dashed(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StrokeDashed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stroke_dashed(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StrokeDashed)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapPolylineStatics, 1644029003, 7647, 17155, 184, 9, 236, 135, 245, 138, 208, 101);
RT_INTERFACE!{static interface IMapPolylineStatics(IMapPolylineStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMapPolylineStatics] {
    fn get_PathProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_StrokeDashedProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IMapPolylineStatics {
    #[inline] pub unsafe fn get_path_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PathProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_dashed_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StrokeDashedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class MapPolyline: IMapPolyline}
impl RtActivatable<IMapPolylineStatics> for MapPolyline {}
impl RtActivatable<IActivationFactory> for MapPolyline {}
impl MapPolyline {
    #[inline] pub fn get_path_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapPolylineStatics>>::get_activation_factory().get_path_property()
    }}
    #[inline] pub fn get_stroke_dashed_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapPolylineStatics>>::get_activation_factory().get_stroke_dashed_property()
    }}
}
DEFINE_CLSID!(MapPolyline(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,80,111,108,121,108,105,110,101,0]) [CLSID_MapPolyline]);
DEFINE_IID!(IID_IStreetsideExperience, 2774052553, 58124, 18120, 129, 22, 72, 70, 145, 103, 85, 88);
RT_INTERFACE!{interface IStreetsideExperience(IStreetsideExperienceVtbl): IInspectable(IInspectableVtbl) [IID_IStreetsideExperience] {
    fn get_AddressTextVisible(&self, out: *mut bool) -> HRESULT,
    fn put_AddressTextVisible(&self, value: bool) -> HRESULT,
    fn get_CursorVisible(&self, out: *mut bool) -> HRESULT,
    fn put_CursorVisible(&self, value: bool) -> HRESULT,
    fn get_OverviewMapVisible(&self, out: *mut bool) -> HRESULT,
    fn put_OverviewMapVisible(&self, value: bool) -> HRESULT,
    fn get_StreetLabelsVisible(&self, out: *mut bool) -> HRESULT,
    fn put_StreetLabelsVisible(&self, value: bool) -> HRESULT,
    fn get_ExitButtonVisible(&self, out: *mut bool) -> HRESULT,
    fn put_ExitButtonVisible(&self, value: bool) -> HRESULT,
    fn get_ZoomButtonsVisible(&self, out: *mut bool) -> HRESULT,
    fn put_ZoomButtonsVisible(&self, value: bool) -> HRESULT
}}
impl IStreetsideExperience {
    #[inline] pub unsafe fn get_address_text_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AddressTextVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_address_text_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AddressTextVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_cursor_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CursorVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_cursor_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CursorVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_overview_map_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OverviewMapVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_overview_map_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OverviewMapVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_street_labels_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StreetLabelsVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_street_labels_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StreetLabelsVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_exit_button_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExitButtonVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_exit_button_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ExitButtonVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoom_buttons_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ZoomButtonsVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_zoom_buttons_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ZoomButtonsVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IStreetsideExperienceFactory, 2052837180, 25758, 17218, 153, 149, 104, 166, 207, 89, 97, 167);
RT_INTERFACE!{static interface IStreetsideExperienceFactory(IStreetsideExperienceFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IStreetsideExperienceFactory] {
    fn CreateInstanceWithPanorama(&self, panorama: *mut StreetsidePanorama, out: *mut *mut StreetsideExperience) -> HRESULT,
    fn CreateInstanceWithPanoramaHeadingPitchAndFieldOfView(&self, panorama: *mut StreetsidePanorama, headingInDegrees: f64, pitchInDegrees: f64, fieldOfViewInDegrees: f64, out: *mut *mut StreetsideExperience) -> HRESULT
}}
impl IStreetsideExperienceFactory {
    #[inline] pub unsafe fn create_instance_with_panorama(&self, panorama: &StreetsidePanorama) -> Result<ComPtr<StreetsideExperience>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithPanorama)(self as *const _ as *mut _, panorama as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_instance_with_panorama_heading_pitch_and_field_of_view(&self, panorama: &StreetsidePanorama, headingInDegrees: f64, pitchInDegrees: f64, fieldOfViewInDegrees: f64) -> Result<ComPtr<StreetsideExperience>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithPanoramaHeadingPitchAndFieldOfView)(self as *const _ as *mut _, panorama as *const _ as *mut _, headingInDegrees, pitchInDegrees, fieldOfViewInDegrees, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class StreetsideExperience: IStreetsideExperience}
impl RtActivatable<IStreetsideExperienceFactory> for StreetsideExperience {}
impl StreetsideExperience {
    #[inline] pub fn create_instance_with_panorama(panorama: &StreetsidePanorama) -> Result<ComPtr<StreetsideExperience>> { unsafe {
        <Self as RtActivatable<IStreetsideExperienceFactory>>::get_activation_factory().create_instance_with_panorama(panorama)
    }}
    #[inline] pub fn create_instance_with_panorama_heading_pitch_and_field_of_view(panorama: &StreetsidePanorama, headingInDegrees: f64, pitchInDegrees: f64, fieldOfViewInDegrees: f64) -> Result<ComPtr<StreetsideExperience>> { unsafe {
        <Self as RtActivatable<IStreetsideExperienceFactory>>::get_activation_factory().create_instance_with_panorama_heading_pitch_and_field_of_view(panorama, headingInDegrees, pitchInDegrees, fieldOfViewInDegrees)
    }}
}
DEFINE_CLSID!(StreetsideExperience(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,83,116,114,101,101,116,115,105,100,101,69,120,112,101,114,105,101,110,99,101,0]) [CLSID_StreetsideExperience]);
DEFINE_IID!(IID_IMapControl, 1120974929, 21078, 18247, 158, 108, 13, 17, 233, 102, 20, 30);
RT_INTERFACE!{interface IMapControl(IMapControlVtbl): IInspectable(IInspectableVtbl) [IID_IMapControl] {
    #[cfg(feature="windows-devices")] fn get_Center(&self, out: *mut *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT,
    #[cfg(feature="windows-devices")] fn put_Center(&self, value: *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT,
    fn get_Children(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<super::super::DependencyObject>) -> HRESULT,
    fn get_ColorScheme(&self, out: *mut MapColorScheme) -> HRESULT,
    fn put_ColorScheme(&self, value: MapColorScheme) -> HRESULT,
    fn get_DesiredPitch(&self, out: *mut f64) -> HRESULT,
    fn put_DesiredPitch(&self, value: f64) -> HRESULT,
    fn get_Heading(&self, out: *mut f64) -> HRESULT,
    fn put_Heading(&self, value: f64) -> HRESULT,
    fn get_LandmarksVisible(&self, out: *mut bool) -> HRESULT,
    fn put_LandmarksVisible(&self, value: bool) -> HRESULT,
    fn get_LoadingStatus(&self, out: *mut MapLoadingStatus) -> HRESULT,
    fn get_MapServiceToken(&self, out: *mut HSTRING) -> HRESULT,
    fn put_MapServiceToken(&self, value: HSTRING) -> HRESULT,
    fn get_MaxZoomLevel(&self, out: *mut f64) -> HRESULT,
    fn get_MinZoomLevel(&self, out: *mut f64) -> HRESULT,
    fn get_PedestrianFeaturesVisible(&self, out: *mut bool) -> HRESULT,
    fn put_PedestrianFeaturesVisible(&self, value: bool) -> HRESULT,
    fn get_Pitch(&self, out: *mut f64) -> HRESULT,
    fn get_Style(&self, out: *mut MapStyle) -> HRESULT,
    fn put_Style(&self, value: MapStyle) -> HRESULT,
    fn get_TrafficFlowVisible(&self, out: *mut bool) -> HRESULT,
    fn put_TrafficFlowVisible(&self, value: bool) -> HRESULT,
    fn get_TransformOrigin(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn put_TransformOrigin(&self, value: ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn get_WatermarkMode(&self, out: *mut MapWatermarkMode) -> HRESULT,
    fn put_WatermarkMode(&self, value: MapWatermarkMode) -> HRESULT,
    fn get_ZoomLevel(&self, out: *mut f64) -> HRESULT,
    fn put_ZoomLevel(&self, value: f64) -> HRESULT,
    fn get_MapElements(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<MapElement>) -> HRESULT,
    fn get_Routes(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<MapRouteView>) -> HRESULT,
    fn get_TileSources(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<MapTileSource>) -> HRESULT,
    fn add_CenterChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CenterChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_HeadingChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_HeadingChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_LoadingStatusChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LoadingStatusChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_MapDoubleTapped(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapInputEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MapDoubleTapped(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_MapHolding(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapInputEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MapHolding(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_MapTapped(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapInputEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MapTapped(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PitchChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PitchChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_TransformOriginChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TransformOriginChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ZoomLevelChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ZoomLevelChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn FindMapElementsAtOffset(&self, offset: ::rt::gen::windows::foundation::Point, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<MapElement>) -> HRESULT,
    #[cfg(feature="windows-devices")] fn GetLocationFromOffset(&self, offset: ::rt::gen::windows::foundation::Point, location: *mut *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT,
    #[cfg(feature="windows-devices")] fn GetOffsetFromLocation(&self, location: *mut ::rt::gen::windows::devices::geolocation::Geopoint, offset: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    #[cfg(feature="windows-devices")] fn IsLocationInView(&self, location: *mut ::rt::gen::windows::devices::geolocation::Geopoint, isInView: *mut bool) -> HRESULT,
    #[cfg(feature="windows-devices")] fn TrySetViewBoundsAsync(&self, bounds: *mut ::rt::gen::windows::devices::geolocation::GeoboundingBox, margin: *mut ::rt::gen::windows::foundation::IReference<super::super::Thickness>, animation: MapAnimationKind, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT,
    #[cfg(feature="windows-devices")] fn TrySetViewWithCenterAsync(&self, center: *mut ::rt::gen::windows::devices::geolocation::Geopoint, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT,
    #[cfg(feature="windows-devices")] fn TrySetViewWithCenterAndZoomAsync(&self, center: *mut ::rt::gen::windows::devices::geolocation::Geopoint, zoomLevel: *mut ::rt::gen::windows::foundation::IReference<f64>, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT,
    #[cfg(feature="windows-devices")] fn TrySetViewWithCenterZoomHeadingAndPitchAsync(&self, center: *mut ::rt::gen::windows::devices::geolocation::Geopoint, zoomLevel: *mut ::rt::gen::windows::foundation::IReference<f64>, heading: *mut ::rt::gen::windows::foundation::IReference<f64>, desiredPitch: *mut ::rt::gen::windows::foundation::IReference<f64>, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT,
    #[cfg(feature="windows-devices")] fn TrySetViewWithCenterZoomHeadingPitchAndAnimationAsync(&self, center: *mut ::rt::gen::windows::devices::geolocation::Geopoint, zoomLevel: *mut ::rt::gen::windows::foundation::IReference<f64>, heading: *mut ::rt::gen::windows::foundation::IReference<f64>, desiredPitch: *mut ::rt::gen::windows::foundation::IReference<f64>, animation: MapAnimationKind, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl IMapControl {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_center(&self) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::Geopoint>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Center)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn set_center(&self, value: &::rt::gen::windows::devices::geolocation::Geopoint) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Center)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_children(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<super::super::DependencyObject>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Children)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_color_scheme(&self) -> Result<MapColorScheme> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ColorScheme)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_color_scheme(&self, value: MapColorScheme) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ColorScheme)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_desired_pitch(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DesiredPitch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_desired_pitch(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DesiredPitch)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_heading(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Heading)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_heading(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Heading)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_landmarks_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LandmarksVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_landmarks_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LandmarksVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_loading_status(&self) -> Result<MapLoadingStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LoadingStatus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_map_service_token(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MapServiceToken)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_map_service_token(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MapServiceToken)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_zoom_level(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxZoomLevel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_zoom_level(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinZoomLevel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pedestrian_features_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PedestrianFeaturesVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_pedestrian_features_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PedestrianFeaturesVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pitch(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Pitch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_style(&self) -> Result<MapStyle> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Style)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_style(&self, value: MapStyle) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Style)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_traffic_flow_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TrafficFlowVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_traffic_flow_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TrafficFlowVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transform_origin(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TransformOrigin)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_transform_origin(&self, value: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TransformOrigin)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_watermark_mode(&self) -> Result<MapWatermarkMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_WatermarkMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_watermark_mode(&self, value: MapWatermarkMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_WatermarkMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoom_level(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ZoomLevel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_zoom_level(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ZoomLevel)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_map_elements(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<MapElement>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MapElements)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_routes(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<MapRouteView>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Routes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tile_sources(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<MapTileSource>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TileSources)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_center_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CenterChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_center_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_CenterChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_heading_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_HeadingChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_heading_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_HeadingChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_loading_status_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_LoadingStatusChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_loading_status_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_LoadingStatusChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_map_double_tapped(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapInputEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_MapDoubleTapped)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_map_double_tapped(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_MapDoubleTapped)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_map_holding(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapInputEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_MapHolding)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_map_holding(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_MapHolding)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_map_tapped(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapInputEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_MapTapped)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_map_tapped(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_MapTapped)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_pitch_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PitchChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_pitch_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PitchChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_transform_origin_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TransformOriginChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_transform_origin_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_TransformOriginChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_zoom_level_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ZoomLevelChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_zoom_level_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ZoomLevelChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_map_elements_at_offset(&self, offset: ::rt::gen::windows::foundation::Point) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<MapElement>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindMapElementsAtOffset)(self as *const _ as *mut _, offset, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_location_from_offset(&self, offset: ::rt::gen::windows::foundation::Point) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::Geopoint>> {
        let mut location = null_mut();
        let hr = ((*self.lpVtbl).GetLocationFromOffset)(self as *const _ as *mut _, offset, &mut location);
        if hr == S_OK { Ok(ComPtr::wrap(location)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_offset_from_location(&self, location: &::rt::gen::windows::devices::geolocation::Geopoint) -> Result<::rt::gen::windows::foundation::Point> {
        let mut offset = zeroed();
        let hr = ((*self.lpVtbl).GetOffsetFromLocation)(self as *const _ as *mut _, location as *const _ as *mut _, &mut offset);
        if hr == S_OK { Ok(offset) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn is_location_in_view(&self, location: &::rt::gen::windows::devices::geolocation::Geopoint) -> Result<bool> {
        let mut isInView = zeroed();
        let hr = ((*self.lpVtbl).IsLocationInView)(self as *const _ as *mut _, location as *const _ as *mut _, &mut isInView);
        if hr == S_OK { Ok(isInView) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn try_set_view_bounds_async(&self, bounds: &::rt::gen::windows::devices::geolocation::GeoboundingBox, margin: &::rt::gen::windows::foundation::IReference<super::super::Thickness>, animation: MapAnimationKind) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TrySetViewBoundsAsync)(self as *const _ as *mut _, bounds as *const _ as *mut _, margin as *const _ as *mut _, animation, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn try_set_view_with_center_async(&self, center: &::rt::gen::windows::devices::geolocation::Geopoint) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TrySetViewWithCenterAsync)(self as *const _ as *mut _, center as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn try_set_view_with_center_and_zoom_async(&self, center: &::rt::gen::windows::devices::geolocation::Geopoint, zoomLevel: &::rt::gen::windows::foundation::IReference<f64>) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TrySetViewWithCenterAndZoomAsync)(self as *const _ as *mut _, center as *const _ as *mut _, zoomLevel as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn try_set_view_with_center_zoom_heading_and_pitch_async(&self, center: &::rt::gen::windows::devices::geolocation::Geopoint, zoomLevel: &::rt::gen::windows::foundation::IReference<f64>, heading: &::rt::gen::windows::foundation::IReference<f64>, desiredPitch: &::rt::gen::windows::foundation::IReference<f64>) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TrySetViewWithCenterZoomHeadingAndPitchAsync)(self as *const _ as *mut _, center as *const _ as *mut _, zoomLevel as *const _ as *mut _, heading as *const _ as *mut _, desiredPitch as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn try_set_view_with_center_zoom_heading_pitch_and_animation_async(&self, center: &::rt::gen::windows::devices::geolocation::Geopoint, zoomLevel: &::rt::gen::windows::foundation::IReference<f64>, heading: &::rt::gen::windows::foundation::IReference<f64>, desiredPitch: &::rt::gen::windows::foundation::IReference<f64>, animation: MapAnimationKind) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TrySetViewWithCenterZoomHeadingPitchAndAnimationAsync)(self as *const _ as *mut _, center as *const _ as *mut _, zoomLevel as *const _ as *mut _, heading as *const _ as *mut _, desiredPitch as *const _ as *mut _, animation, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapControlStatics, 3267762069, 8519, 20234, 148, 42, 84, 147, 168, 93, 232, 7);
RT_INTERFACE!{static interface IMapControlStatics(IMapControlStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMapControlStatics] {
    fn get_CenterProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ChildrenProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ColorSchemeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_DesiredPitchProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_HeadingProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_LandmarksVisibleProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_LoadingStatusProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_MapServiceTokenProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_PedestrianFeaturesVisibleProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_PitchProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_StyleProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_TrafficFlowVisibleProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_TransformOriginProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_WatermarkModeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ZoomLevelProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_MapElementsProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_RoutesProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_TileSourcesProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_LocationProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy19(&self) -> (),
    #[cfg(feature="windows-devices")] fn GetLocation(&self, element: *mut super::super::DependencyObject, out: *mut *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy20(&self) -> (),
    #[cfg(feature="windows-devices")] fn SetLocation(&self, element: *mut super::super::DependencyObject, value: *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT,
    fn get_NormalizedAnchorPointProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn GetNormalizedAnchorPoint(&self, element: *mut super::super::DependencyObject, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn SetNormalizedAnchorPoint(&self, element: *mut super::super::DependencyObject, value: ::rt::gen::windows::foundation::Point) -> HRESULT
}}
impl IMapControlStatics {
    #[inline] pub unsafe fn get_center_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CenterProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_children_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ChildrenProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_color_scheme_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ColorSchemeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_desired_pitch_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DesiredPitchProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_heading_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeadingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_landmarks_visible_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LandmarksVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_loading_status_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LoadingStatusProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_map_service_token_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MapServiceTokenProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pedestrian_features_visible_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PedestrianFeaturesVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pitch_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PitchProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_style_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_traffic_flow_visible_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TrafficFlowVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transform_origin_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransformOriginProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_watermark_mode_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_WatermarkModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoom_level_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ZoomLevelProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_map_elements_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MapElementsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_routes_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RoutesProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tile_sources_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TileSourcesProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_location_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LocationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_location(&self, element: &super::super::DependencyObject) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::Geopoint>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetLocation)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn set_location(&self, element: &super::super::DependencyObject, value: &::rt::gen::windows::devices::geolocation::Geopoint) -> Result<()> {
        let hr = ((*self.lpVtbl).SetLocation)(self as *const _ as *mut _, element as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_normalized_anchor_point_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NormalizedAnchorPointProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_normalized_anchor_point(&self, element: &super::super::DependencyObject) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetNormalizedAnchorPoint)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_normalized_anchor_point(&self, element: &super::super::DependencyObject, value: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).SetNormalizedAnchorPoint)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapControl2, 3791479885, 38636, 16485, 176, 240, 117, 40, 29, 163, 101, 77);
RT_INTERFACE!{interface IMapControl2(IMapControl2Vtbl): IInspectable(IInspectableVtbl) [IID_IMapControl2] {
    fn get_BusinessLandmarksVisible(&self, out: *mut bool) -> HRESULT,
    fn put_BusinessLandmarksVisible(&self, value: bool) -> HRESULT,
    fn get_TransitFeaturesVisible(&self, out: *mut bool) -> HRESULT,
    fn put_TransitFeaturesVisible(&self, value: bool) -> HRESULT,
    fn get_PanInteractionMode(&self, out: *mut MapPanInteractionMode) -> HRESULT,
    fn put_PanInteractionMode(&self, value: MapPanInteractionMode) -> HRESULT,
    fn get_RotateInteractionMode(&self, out: *mut MapInteractionMode) -> HRESULT,
    fn put_RotateInteractionMode(&self, value: MapInteractionMode) -> HRESULT,
    fn get_TiltInteractionMode(&self, out: *mut MapInteractionMode) -> HRESULT,
    fn put_TiltInteractionMode(&self, value: MapInteractionMode) -> HRESULT,
    fn get_ZoomInteractionMode(&self, out: *mut MapInteractionMode) -> HRESULT,
    fn put_ZoomInteractionMode(&self, value: MapInteractionMode) -> HRESULT,
    fn get_Is3DSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsStreetsideSupported(&self, out: *mut bool) -> HRESULT,
    fn get_Scene(&self, out: *mut *mut MapScene) -> HRESULT,
    fn put_Scene(&self, value: *mut MapScene) -> HRESULT,
    fn get_ActualCamera(&self, out: *mut *mut MapCamera) -> HRESULT,
    fn get_TargetCamera(&self, out: *mut *mut MapCamera) -> HRESULT,
    fn get_CustomExperience(&self, out: *mut *mut MapCustomExperience) -> HRESULT,
    fn put_CustomExperience(&self, value: *mut MapCustomExperience) -> HRESULT,
    fn add_MapElementClick(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapElementClickEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MapElementClick(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_MapElementPointerEntered(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapElementPointerEnteredEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MapElementPointerEntered(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_MapElementPointerExited(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapElementPointerExitedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MapElementPointerExited(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ActualCameraChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapActualCameraChangedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ActualCameraChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ActualCameraChanging(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapActualCameraChangingEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ActualCameraChanging(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_TargetCameraChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapTargetCameraChangedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TargetCameraChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_CustomExperienceChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapCustomExperienceChangedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CustomExperienceChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn StartContinuousRotate(&self, rateInDegreesPerSecond: f64) -> HRESULT,
    fn StopContinuousRotate(&self) -> HRESULT,
    fn StartContinuousTilt(&self, rateInDegreesPerSecond: f64) -> HRESULT,
    fn StopContinuousTilt(&self) -> HRESULT,
    fn StartContinuousZoom(&self, rateOfChangePerSecond: f64) -> HRESULT,
    fn StopContinuousZoom(&self) -> HRESULT,
    fn TryRotateAsync(&self, degrees: f64, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryRotateToAsync(&self, angleInDegrees: f64, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryTiltAsync(&self, degrees: f64, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryTiltToAsync(&self, angleInDegrees: f64, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryZoomInAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryZoomOutAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryZoomToAsync(&self, zoomLevel: f64, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TrySetSceneAsync(&self, scene: *mut MapScene, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TrySetSceneWithAnimationAsync(&self, scene: *mut MapScene, animationKind: MapAnimationKind, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl IMapControl2 {
    #[inline] pub unsafe fn get_business_landmarks_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BusinessLandmarksVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_business_landmarks_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BusinessLandmarksVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transit_features_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TransitFeaturesVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_transit_features_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TransitFeaturesVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pan_interaction_mode(&self) -> Result<MapPanInteractionMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PanInteractionMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_pan_interaction_mode(&self, value: MapPanInteractionMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PanInteractionMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rotate_interaction_mode(&self) -> Result<MapInteractionMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RotateInteractionMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_rotate_interaction_mode(&self, value: MapInteractionMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RotateInteractionMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tilt_interaction_mode(&self) -> Result<MapInteractionMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TiltInteractionMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_tilt_interaction_mode(&self, value: MapInteractionMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TiltInteractionMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoom_interaction_mode(&self) -> Result<MapInteractionMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ZoomInteractionMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_zoom_interaction_mode(&self, value: MapInteractionMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ZoomInteractionMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is3_dsupported(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Is3DSupported)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_streetside_supported(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsStreetsideSupported)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scene(&self) -> Result<ComPtr<MapScene>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Scene)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_scene(&self, value: &MapScene) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Scene)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_actual_camera(&self) -> Result<ComPtr<MapCamera>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ActualCamera)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_target_camera(&self) -> Result<ComPtr<MapCamera>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetCamera)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_custom_experience(&self) -> Result<ComPtr<MapCustomExperience>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CustomExperience)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_custom_experience(&self, value: &MapCustomExperience) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CustomExperience)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_map_element_click(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapElementClickEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_MapElementClick)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_map_element_click(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_MapElementClick)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_map_element_pointer_entered(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapElementPointerEnteredEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_MapElementPointerEntered)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_map_element_pointer_entered(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_MapElementPointerEntered)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_map_element_pointer_exited(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapElementPointerExitedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_MapElementPointerExited)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_map_element_pointer_exited(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_MapElementPointerExited)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_actual_camera_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapActualCameraChangedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ActualCameraChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_actual_camera_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ActualCameraChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_actual_camera_changing(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapActualCameraChangingEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ActualCameraChanging)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_actual_camera_changing(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ActualCameraChanging)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_target_camera_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapTargetCameraChangedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TargetCameraChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_target_camera_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_TargetCameraChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_custom_experience_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapCustomExperienceChangedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CustomExperienceChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_custom_experience_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_CustomExperienceChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn start_continuous_rotate(&self, rateInDegreesPerSecond: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).StartContinuousRotate)(self as *const _ as *mut _, rateInDegreesPerSecond);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn stop_continuous_rotate(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).StopContinuousRotate)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn start_continuous_tilt(&self, rateInDegreesPerSecond: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).StartContinuousTilt)(self as *const _ as *mut _, rateInDegreesPerSecond);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn stop_continuous_tilt(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).StopContinuousTilt)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn start_continuous_zoom(&self, rateOfChangePerSecond: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).StartContinuousZoom)(self as *const _ as *mut _, rateOfChangePerSecond);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn stop_continuous_zoom(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).StopContinuousZoom)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_rotate_async(&self, degrees: f64) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryRotateAsync)(self as *const _ as *mut _, degrees, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_rotate_to_async(&self, angleInDegrees: f64) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryRotateToAsync)(self as *const _ as *mut _, angleInDegrees, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_tilt_async(&self, degrees: f64) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryTiltAsync)(self as *const _ as *mut _, degrees, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_tilt_to_async(&self, angleInDegrees: f64) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryTiltToAsync)(self as *const _ as *mut _, angleInDegrees, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_zoom_in_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryZoomInAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_zoom_out_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryZoomOutAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_zoom_to_async(&self, zoomLevel: f64) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryZoomToAsync)(self as *const _ as *mut _, zoomLevel, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_set_scene_async(&self, scene: &MapScene) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TrySetSceneAsync)(self as *const _ as *mut _, scene as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_set_scene_with_animation_async(&self, scene: &MapScene, animationKind: MapAnimationKind) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TrySetSceneWithAnimationAsync)(self as *const _ as *mut _, scene as *const _ as *mut _, animationKind, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapControlStatics2, 75836307, 46150, 19761, 151, 82, 30, 198, 154, 89, 150, 174);
RT_INTERFACE!{static interface IMapControlStatics2(IMapControlStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IMapControlStatics2] {
    fn get_BusinessLandmarksVisibleProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_TransitFeaturesVisibleProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_PanInteractionModeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_RotateInteractionModeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_TiltInteractionModeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ZoomInteractionModeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_Is3DSupportedProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_IsStreetsideSupportedProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_SceneProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IMapControlStatics2 {
    #[inline] pub unsafe fn get_business_landmarks_visible_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BusinessLandmarksVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transit_features_visible_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransitFeaturesVisibleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pan_interaction_mode_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PanInteractionModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rotate_interaction_mode_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RotateInteractionModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tilt_interaction_mode_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TiltInteractionModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoom_interaction_mode_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ZoomInteractionModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is3_dsupported_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Is3DSupportedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_streetside_supported_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsStreetsideSupportedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scene_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SceneProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapControl3, 1482893560, 36061, 16558, 147, 56, 175, 42, 123, 232, 69, 229);
RT_INTERFACE!{interface IMapControl3(IMapControl3Vtbl): IInspectable(IInspectableVtbl) [IID_IMapControl3] {
    fn add_MapRightTapped(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapRightTappedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MapRightTapped(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IMapControl3 {
    #[inline] pub unsafe fn add_map_right_tapped(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapRightTappedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_MapRightTapped)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_map_right_tapped(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_MapRightTapped)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapControl4, 110039850, 6167, 18029, 183, 206, 65, 155, 63, 142, 36, 139);
RT_INTERFACE!{interface IMapControl4(IMapControl4Vtbl): IInspectable(IInspectableVtbl) [IID_IMapControl4] {
    fn get_BusinessLandmarksEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_BusinessLandmarksEnabled(&self, value: bool) -> HRESULT,
    fn get_TransitFeaturesEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_TransitFeaturesEnabled(&self, value: bool) -> HRESULT,
    #[cfg(feature="windows-devices")] fn GetVisibleRegion(&self, region: MapVisibleRegionKind, out: *mut *mut ::rt::gen::windows::devices::geolocation::Geopath) -> HRESULT
}}
impl IMapControl4 {
    #[inline] pub unsafe fn get_business_landmarks_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BusinessLandmarksEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_business_landmarks_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BusinessLandmarksEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transit_features_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TransitFeaturesEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_transit_features_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TransitFeaturesEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_visible_region(&self, region: MapVisibleRegionKind) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::Geopath>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetVisibleRegion)(self as *const _ as *mut _, region, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapControlStatics4, 4269301143, 23827, 20385, 191, 29, 132, 6, 23, 104, 193, 131);
RT_INTERFACE!{static interface IMapControlStatics4(IMapControlStatics4Vtbl): IInspectable(IInspectableVtbl) [IID_IMapControlStatics4] {
    fn get_BusinessLandmarksEnabledProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_TransitFeaturesEnabledProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IMapControlStatics4 {
    #[inline] pub unsafe fn get_business_landmarks_enabled_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BusinessLandmarksEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transit_features_enabled_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransitFeaturesEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapControl5, 3717926909, 30755, 18082, 130, 201, 101, 221, 172, 79, 54, 95);
RT_INTERFACE!{interface IMapControl5(IMapControl5Vtbl): IInspectable(IInspectableVtbl) [IID_IMapControl5] {
    fn get_MapProjection(&self, out: *mut MapProjection) -> HRESULT,
    fn put_MapProjection(&self, value: MapProjection) -> HRESULT,
    fn get_StyleSheet(&self, out: *mut *mut MapStyleSheet) -> HRESULT,
    fn put_StyleSheet(&self, value: *mut MapStyleSheet) -> HRESULT,
    fn get_ViewPadding(&self, out: *mut super::super::Thickness) -> HRESULT,
    fn put_ViewPadding(&self, value: super::super::Thickness) -> HRESULT,
    fn add_MapContextRequested(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapContextRequestedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MapContextRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn FindMapElementsAtOffsetWithRadius(&self, offset: ::rt::gen::windows::foundation::Point, radius: f64, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<MapElement>) -> HRESULT,
    #[cfg(feature="windows-devices")] fn GetLocationFromOffsetWithReferenceSystem(&self, offset: ::rt::gen::windows::foundation::Point, desiredReferenceSystem: ::rt::gen::windows::devices::geolocation::AltitudeReferenceSystem, location: *mut *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT,
    fn StartContinuousPan(&self, horizontalPixelsPerSecond: f64, verticalPixelsPerSecond: f64) -> HRESULT,
    fn StopContinuousPan(&self) -> HRESULT,
    fn TryPanAsync(&self, horizontalPixels: f64, verticalPixels: f64, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT,
    #[cfg(feature="windows-devices")] fn TryPanToAsync(&self, location: *mut ::rt::gen::windows::devices::geolocation::Geopoint, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl IMapControl5 {
    #[inline] pub unsafe fn get_map_projection(&self) -> Result<MapProjection> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MapProjection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_map_projection(&self, value: MapProjection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MapProjection)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_style_sheet(&self) -> Result<ComPtr<MapStyleSheet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StyleSheet)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_style_sheet(&self, value: &MapStyleSheet) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StyleSheet)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_view_padding(&self) -> Result<super::super::Thickness> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ViewPadding)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_view_padding(&self, value: super::super::Thickness) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ViewPadding)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_map_context_requested(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapContextRequestedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_MapContextRequested)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_map_context_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_MapContextRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_map_elements_at_offset_with_radius(&self, offset: ::rt::gen::windows::foundation::Point, radius: f64) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<MapElement>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindMapElementsAtOffsetWithRadius)(self as *const _ as *mut _, offset, radius, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_location_from_offset_with_reference_system(&self, offset: ::rt::gen::windows::foundation::Point, desiredReferenceSystem: ::rt::gen::windows::devices::geolocation::AltitudeReferenceSystem) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::Geopoint>> {
        let mut location = null_mut();
        let hr = ((*self.lpVtbl).GetLocationFromOffsetWithReferenceSystem)(self as *const _ as *mut _, offset, desiredReferenceSystem, &mut location);
        if hr == S_OK { Ok(ComPtr::wrap(location)) } else { err(hr) }
    }
    #[inline] pub unsafe fn start_continuous_pan(&self, horizontalPixelsPerSecond: f64, verticalPixelsPerSecond: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).StartContinuousPan)(self as *const _ as *mut _, horizontalPixelsPerSecond, verticalPixelsPerSecond);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn stop_continuous_pan(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).StopContinuousPan)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_pan_async(&self, horizontalPixels: f64, verticalPixels: f64) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryPanAsync)(self as *const _ as *mut _, horizontalPixels, verticalPixels, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn try_pan_to_async(&self, location: &::rt::gen::windows::devices::geolocation::Geopoint) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryPanToAsync)(self as *const _ as *mut _, location as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class MapControl: IMapControl}
impl RtActivatable<IMapControlStatics> for MapControl {}
impl RtActivatable<IMapControlStatics4> for MapControl {}
impl RtActivatable<IMapControlStatics5> for MapControl {}
impl RtActivatable<IMapControlStatics2> for MapControl {}
impl RtActivatable<IActivationFactory> for MapControl {}
impl MapControl {
    #[inline] pub fn get_center_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().get_center_property()
    }}
    #[inline] pub fn get_children_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().get_children_property()
    }}
    #[inline] pub fn get_color_scheme_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().get_color_scheme_property()
    }}
    #[inline] pub fn get_desired_pitch_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().get_desired_pitch_property()
    }}
    #[inline] pub fn get_heading_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().get_heading_property()
    }}
    #[inline] pub fn get_landmarks_visible_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().get_landmarks_visible_property()
    }}
    #[inline] pub fn get_loading_status_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().get_loading_status_property()
    }}
    #[inline] pub fn get_map_service_token_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().get_map_service_token_property()
    }}
    #[inline] pub fn get_pedestrian_features_visible_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().get_pedestrian_features_visible_property()
    }}
    #[inline] pub fn get_pitch_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().get_pitch_property()
    }}
    #[inline] pub fn get_style_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().get_style_property()
    }}
    #[inline] pub fn get_traffic_flow_visible_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().get_traffic_flow_visible_property()
    }}
    #[inline] pub fn get_transform_origin_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().get_transform_origin_property()
    }}
    #[inline] pub fn get_watermark_mode_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().get_watermark_mode_property()
    }}
    #[inline] pub fn get_zoom_level_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().get_zoom_level_property()
    }}
    #[inline] pub fn get_map_elements_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().get_map_elements_property()
    }}
    #[inline] pub fn get_routes_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().get_routes_property()
    }}
    #[inline] pub fn get_tile_sources_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().get_tile_sources_property()
    }}
    #[inline] pub fn get_location_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().get_location_property()
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_location(element: &super::super::DependencyObject) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::Geopoint>> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().get_location(element)
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn set_location(element: &super::super::DependencyObject, value: &::rt::gen::windows::devices::geolocation::Geopoint) -> Result<()> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().set_location(element, value)
    }}
    #[inline] pub fn get_normalized_anchor_point_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().get_normalized_anchor_point_property()
    }}
    #[inline] pub fn get_normalized_anchor_point(element: &super::super::DependencyObject) -> Result<::rt::gen::windows::foundation::Point> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().get_normalized_anchor_point(element)
    }}
    #[inline] pub fn set_normalized_anchor_point(element: &super::super::DependencyObject, value: ::rt::gen::windows::foundation::Point) -> Result<()> { unsafe {
        <Self as RtActivatable<IMapControlStatics>>::get_activation_factory().set_normalized_anchor_point(element, value)
    }}
    #[inline] pub fn get_business_landmarks_enabled_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics4>>::get_activation_factory().get_business_landmarks_enabled_property()
    }}
    #[inline] pub fn get_transit_features_enabled_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics4>>::get_activation_factory().get_transit_features_enabled_property()
    }}
    #[inline] pub fn get_map_projection_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics5>>::get_activation_factory().get_map_projection_property()
    }}
    #[inline] pub fn get_style_sheet_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics5>>::get_activation_factory().get_style_sheet_property()
    }}
    #[inline] pub fn get_view_padding_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics5>>::get_activation_factory().get_view_padding_property()
    }}
    #[inline] pub fn get_business_landmarks_visible_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics2>>::get_activation_factory().get_business_landmarks_visible_property()
    }}
    #[inline] pub fn get_transit_features_visible_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics2>>::get_activation_factory().get_transit_features_visible_property()
    }}
    #[inline] pub fn get_pan_interaction_mode_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics2>>::get_activation_factory().get_pan_interaction_mode_property()
    }}
    #[inline] pub fn get_rotate_interaction_mode_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics2>>::get_activation_factory().get_rotate_interaction_mode_property()
    }}
    #[inline] pub fn get_tilt_interaction_mode_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics2>>::get_activation_factory().get_tilt_interaction_mode_property()
    }}
    #[inline] pub fn get_zoom_interaction_mode_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics2>>::get_activation_factory().get_zoom_interaction_mode_property()
    }}
    #[inline] pub fn get_is3_dsupported_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics2>>::get_activation_factory().get_is3_dsupported_property()
    }}
    #[inline] pub fn get_is_streetside_supported_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics2>>::get_activation_factory().get_is_streetside_supported_property()
    }}
    #[inline] pub fn get_scene_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMapControlStatics2>>::get_activation_factory().get_scene_property()
    }}
}
DEFINE_CLSID!(MapControl(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,67,111,110,116,114,111,108,0]) [CLSID_MapControl]);
DEFINE_IID!(IID_IMapControlStatics5, 157445888, 47069, 16777, 167, 247, 131, 12, 65, 45, 238, 163);
RT_INTERFACE!{static interface IMapControlStatics5(IMapControlStatics5Vtbl): IInspectable(IInspectableVtbl) [IID_IMapControlStatics5] {
    fn get_MapProjectionProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_StyleSheetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ViewPaddingProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IMapControlStatics5 {
    #[inline] pub unsafe fn get_map_projection_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MapProjectionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_style_sheet_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StyleSheetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_view_padding_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ViewPaddingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapControlDataHelper, 2343628956, 5291, 18540, 157, 229, 90, 93, 239, 2, 5, 162);
RT_INTERFACE!{interface IMapControlDataHelper(IMapControlDataHelperVtbl): IInspectable(IInspectableVtbl) [IID_IMapControlDataHelper] {
    fn add_BusinessLandmarkClick(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapControlBusinessLandmarkClickEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BusinessLandmarkClick(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_TransitFeatureClick(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapControlTransitFeatureClickEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TransitFeatureClick(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_BusinessLandmarkRightTapped(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapControlBusinessLandmarkRightTappedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BusinessLandmarkRightTapped(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_TransitFeatureRightTapped(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapControlTransitFeatureRightTappedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TransitFeatureRightTapped(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IMapControlDataHelper {
    #[inline] pub unsafe fn add_business_landmark_click(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapControlBusinessLandmarkClickEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_BusinessLandmarkClick)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_business_landmark_click(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_BusinessLandmarkClick)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_transit_feature_click(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapControlTransitFeatureClickEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TransitFeatureClick)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_transit_feature_click(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_TransitFeatureClick)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_business_landmark_right_tapped(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapControlBusinessLandmarkRightTappedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_BusinessLandmarkRightTapped)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_business_landmark_right_tapped(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_BusinessLandmarkRightTapped)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_transit_feature_right_tapped(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapControlTransitFeatureRightTappedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TransitFeatureRightTapped)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_transit_feature_right_tapped(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_TransitFeatureRightTapped)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class MapControlBusinessLandmarkClickEventArgs: IMapControlBusinessLandmarkClickEventArgs}
impl RtActivatable<IActivationFactory> for MapControlBusinessLandmarkClickEventArgs {}
DEFINE_CLSID!(MapControlBusinessLandmarkClickEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,67,111,110,116,114,111,108,66,117,115,105,110,101,115,115,76,97,110,100,109,97,114,107,67,108,105,99,107,69,118,101,110,116,65,114,103,115,0]) [CLSID_MapControlBusinessLandmarkClickEventArgs]);
RT_CLASS!{class MapControlTransitFeatureClickEventArgs: IMapControlTransitFeatureClickEventArgs}
impl RtActivatable<IActivationFactory> for MapControlTransitFeatureClickEventArgs {}
DEFINE_CLSID!(MapControlTransitFeatureClickEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,67,111,110,116,114,111,108,84,114,97,110,115,105,116,70,101,97,116,117,114,101,67,108,105,99,107,69,118,101,110,116,65,114,103,115,0]) [CLSID_MapControlTransitFeatureClickEventArgs]);
RT_CLASS!{class MapControlBusinessLandmarkRightTappedEventArgs: IMapControlBusinessLandmarkRightTappedEventArgs}
impl RtActivatable<IActivationFactory> for MapControlBusinessLandmarkRightTappedEventArgs {}
DEFINE_CLSID!(MapControlBusinessLandmarkRightTappedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,67,111,110,116,114,111,108,66,117,115,105,110,101,115,115,76,97,110,100,109,97,114,107,82,105,103,104,116,84,97,112,112,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_MapControlBusinessLandmarkRightTappedEventArgs]);
RT_CLASS!{class MapControlTransitFeatureRightTappedEventArgs: IMapControlTransitFeatureRightTappedEventArgs}
impl RtActivatable<IActivationFactory> for MapControlTransitFeatureRightTappedEventArgs {}
DEFINE_CLSID!(MapControlTransitFeatureRightTappedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,67,111,110,116,114,111,108,84,114,97,110,115,105,116,70,101,97,116,117,114,101,82,105,103,104,116,84,97,112,112,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_MapControlTransitFeatureRightTappedEventArgs]);
DEFINE_IID!(IID_IMapControlDataHelper2, 1506689694, 22063, 19489, 166, 116, 15, 17, 222, 207, 15, 179);
RT_INTERFACE!{interface IMapControlDataHelper2(IMapControlDataHelper2Vtbl): IInspectable(IInspectableVtbl) [IID_IMapControlDataHelper2] {
    fn add_BusinessLandmarkPointerEntered(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapControlBusinessLandmarkPointerEnteredEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BusinessLandmarkPointerEntered(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_TransitFeaturePointerEntered(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapControlTransitFeaturePointerEnteredEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TransitFeaturePointerEntered(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_BusinessLandmarkPointerExited(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapControlBusinessLandmarkPointerExitedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BusinessLandmarkPointerExited(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_TransitFeaturePointerExited(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapControlTransitFeaturePointerExitedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TransitFeaturePointerExited(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IMapControlDataHelper2 {
    #[inline] pub unsafe fn add_business_landmark_pointer_entered(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapControlBusinessLandmarkPointerEnteredEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_BusinessLandmarkPointerEntered)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_business_landmark_pointer_entered(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_BusinessLandmarkPointerEntered)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_transit_feature_pointer_entered(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapControlTransitFeaturePointerEnteredEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TransitFeaturePointerEntered)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_transit_feature_pointer_entered(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_TransitFeaturePointerEntered)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_business_landmark_pointer_exited(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapControlBusinessLandmarkPointerExitedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_BusinessLandmarkPointerExited)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_business_landmark_pointer_exited(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_BusinessLandmarkPointerExited)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_transit_feature_pointer_exited(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<MapControl, MapControlTransitFeaturePointerExitedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TransitFeaturePointerExited)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_transit_feature_pointer_exited(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_TransitFeaturePointerExited)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class MapControlBusinessLandmarkPointerEnteredEventArgs: IMapControlBusinessLandmarkPointerEnteredEventArgs}
impl RtActivatable<IActivationFactory> for MapControlBusinessLandmarkPointerEnteredEventArgs {}
DEFINE_CLSID!(MapControlBusinessLandmarkPointerEnteredEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,67,111,110,116,114,111,108,66,117,115,105,110,101,115,115,76,97,110,100,109,97,114,107,80,111,105,110,116,101,114,69,110,116,101,114,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_MapControlBusinessLandmarkPointerEnteredEventArgs]);
RT_CLASS!{class MapControlTransitFeaturePointerEnteredEventArgs: IMapControlTransitFeaturePointerEnteredEventArgs}
impl RtActivatable<IActivationFactory> for MapControlTransitFeaturePointerEnteredEventArgs {}
DEFINE_CLSID!(MapControlTransitFeaturePointerEnteredEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,67,111,110,116,114,111,108,84,114,97,110,115,105,116,70,101,97,116,117,114,101,80,111,105,110,116,101,114,69,110,116,101,114,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_MapControlTransitFeaturePointerEnteredEventArgs]);
RT_CLASS!{class MapControlBusinessLandmarkPointerExitedEventArgs: IMapControlBusinessLandmarkPointerExitedEventArgs}
impl RtActivatable<IActivationFactory> for MapControlBusinessLandmarkPointerExitedEventArgs {}
DEFINE_CLSID!(MapControlBusinessLandmarkPointerExitedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,67,111,110,116,114,111,108,66,117,115,105,110,101,115,115,76,97,110,100,109,97,114,107,80,111,105,110,116,101,114,69,120,105,116,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_MapControlBusinessLandmarkPointerExitedEventArgs]);
RT_CLASS!{class MapControlTransitFeaturePointerExitedEventArgs: IMapControlTransitFeaturePointerExitedEventArgs}
impl RtActivatable<IActivationFactory> for MapControlTransitFeaturePointerExitedEventArgs {}
DEFINE_CLSID!(MapControlTransitFeaturePointerExitedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,67,111,110,116,114,111,108,84,114,97,110,115,105,116,70,101,97,116,117,114,101,80,111,105,110,116,101,114,69,120,105,116,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_MapControlTransitFeaturePointerExitedEventArgs]);
DEFINE_IID!(IID_IMapControlDataHelperFactory, 997239438, 751, 18076, 187, 175, 220, 33, 88, 212, 40, 155);
RT_INTERFACE!{static interface IMapControlDataHelperFactory(IMapControlDataHelperFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMapControlDataHelperFactory] {
    fn CreateInstance(&self, map: *mut MapControl, out: *mut *mut MapControlDataHelper) -> HRESULT
}}
impl IMapControlDataHelperFactory {
    #[inline] pub unsafe fn create_instance(&self, map: &MapControl) -> Result<ComPtr<MapControlDataHelper>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, map as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class MapControlDataHelper: IMapControlDataHelper}
impl RtActivatable<IMapControlDataHelperFactory> for MapControlDataHelper {}
impl MapControlDataHelper {
    #[inline] pub fn create_instance(map: &MapControl) -> Result<ComPtr<MapControlDataHelper>> { unsafe {
        <Self as RtActivatable<IMapControlDataHelperFactory>>::get_activation_factory().create_instance(map)
    }}
}
DEFINE_CLSID!(MapControlDataHelper(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,67,111,110,116,114,111,108,115,46,77,97,112,115,46,77,97,112,67,111,110,116,114,111,108,68,97,116,97,72,101,108,112,101,114,0]) [CLSID_MapControlDataHelper]);
DEFINE_IID!(IID_IMapControlBusinessLandmarkClickEventArgs, 1581664546, 18970, 18327, 190, 183, 92, 247, 117, 76, 184, 103);
RT_INTERFACE!{interface IMapControlBusinessLandmarkClickEventArgs(IMapControlBusinessLandmarkClickEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMapControlBusinessLandmarkClickEventArgs] {
    #[cfg(feature="windows-services")] fn get_LocalLocations(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<::rt::gen::windows::services::maps::localsearch::LocalLocation>) -> HRESULT
}}
impl IMapControlBusinessLandmarkClickEventArgs {
    #[cfg(feature="windows-services")] #[inline] pub unsafe fn get_local_locations(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<::rt::gen::windows::services::maps::localsearch::LocalLocation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LocalLocations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapControlTransitFeatureClickEventArgs, 1981258089, 46949, 17954, 176, 138, 48, 114, 116, 90, 69, 65);
RT_INTERFACE!{interface IMapControlTransitFeatureClickEventArgs(IMapControlTransitFeatureClickEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMapControlTransitFeatureClickEventArgs] {
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_Location(&self, out: *mut *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT,
    fn get_TransitProperties(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IMapView<HString, IInspectable>) -> HRESULT
}}
impl IMapControlTransitFeatureClickEventArgs {
    #[inline] pub unsafe fn get_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_location(&self) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::Geopoint>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Location)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transit_properties(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IMapView<HString, IInspectable>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransitProperties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapControlBusinessLandmarkRightTappedEventArgs, 1504414439, 61828, 19121, 176, 176, 53, 200, 191, 6, 84, 178);
RT_INTERFACE!{interface IMapControlBusinessLandmarkRightTappedEventArgs(IMapControlBusinessLandmarkRightTappedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMapControlBusinessLandmarkRightTappedEventArgs] {
    #[cfg(feature="windows-services")] fn get_LocalLocations(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<::rt::gen::windows::services::maps::localsearch::LocalLocation>) -> HRESULT
}}
impl IMapControlBusinessLandmarkRightTappedEventArgs {
    #[cfg(feature="windows-services")] #[inline] pub unsafe fn get_local_locations(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<::rt::gen::windows::services::maps::localsearch::LocalLocation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LocalLocations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapControlTransitFeatureRightTappedEventArgs, 2929839177, 42793, 20142, 165, 154, 62, 201, 161, 37, 160, 40);
RT_INTERFACE!{interface IMapControlTransitFeatureRightTappedEventArgs(IMapControlTransitFeatureRightTappedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMapControlTransitFeatureRightTappedEventArgs] {
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_Location(&self, out: *mut *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT,
    fn get_TransitProperties(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IMapView<HString, IInspectable>) -> HRESULT
}}
impl IMapControlTransitFeatureRightTappedEventArgs {
    #[inline] pub unsafe fn get_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_location(&self) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::Geopoint>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Location)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transit_properties(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IMapView<HString, IInspectable>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransitProperties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapControlBusinessLandmarkPointerEnteredEventArgs, 1581285798, 60056, 20373, 140, 175, 91, 66, 105, 111, 245, 4);
RT_INTERFACE!{interface IMapControlBusinessLandmarkPointerEnteredEventArgs(IMapControlBusinessLandmarkPointerEnteredEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMapControlBusinessLandmarkPointerEnteredEventArgs] {
    #[cfg(feature="windows-services")] fn get_LocalLocations(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<::rt::gen::windows::services::maps::localsearch::LocalLocation>) -> HRESULT
}}
impl IMapControlBusinessLandmarkPointerEnteredEventArgs {
    #[cfg(feature="windows-services")] #[inline] pub unsafe fn get_local_locations(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<::rt::gen::windows::services::maps::localsearch::LocalLocation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LocalLocations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapControlTransitFeaturePointerEnteredEventArgs, 1938889294, 60495, 18334, 148, 161, 54, 224, 129, 208, 216, 151);
RT_INTERFACE!{interface IMapControlTransitFeaturePointerEnteredEventArgs(IMapControlTransitFeaturePointerEnteredEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMapControlTransitFeaturePointerEnteredEventArgs] {
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_Location(&self, out: *mut *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT,
    fn get_TransitProperties(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IMapView<HString, IInspectable>) -> HRESULT
}}
impl IMapControlTransitFeaturePointerEnteredEventArgs {
    #[inline] pub unsafe fn get_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_location(&self) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::Geopoint>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Location)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transit_properties(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IMapView<HString, IInspectable>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransitProperties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapControlBusinessLandmarkPointerExitedEventArgs, 733293743, 62026, 18128, 180, 99, 101, 247, 25, 115, 16, 87);
RT_INTERFACE!{interface IMapControlBusinessLandmarkPointerExitedEventArgs(IMapControlBusinessLandmarkPointerExitedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMapControlBusinessLandmarkPointerExitedEventArgs] {
    #[cfg(feature="windows-services")] fn get_LocalLocations(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<::rt::gen::windows::services::maps::localsearch::LocalLocation>) -> HRESULT
}}
impl IMapControlBusinessLandmarkPointerExitedEventArgs {
    #[cfg(feature="windows-services")] #[inline] pub unsafe fn get_local_locations(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<::rt::gen::windows::services::maps::localsearch::LocalLocation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LocalLocations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMapControlTransitFeaturePointerExitedEventArgs, 1779508621, 17549, 17639, 188, 105, 209, 61, 73, 113, 84, 233);
RT_INTERFACE!{interface IMapControlTransitFeaturePointerExitedEventArgs(IMapControlTransitFeaturePointerExitedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMapControlTransitFeaturePointerExitedEventArgs] {
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_Location(&self, out: *mut *mut ::rt::gen::windows::devices::geolocation::Geopoint) -> HRESULT,
    fn get_TransitProperties(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IMapView<HString, IInspectable>) -> HRESULT
}}
impl IMapControlTransitFeaturePointerExitedEventArgs {
    #[inline] pub unsafe fn get_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_location(&self) -> Result<ComPtr<::rt::gen::windows::devices::geolocation::Geopoint>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Location)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transit_properties(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IMapView<HString, IInspectable>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransitProperties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
} // Windows.UI.Xaml.Controls.Maps
} // Windows.UI.Xaml.Controls
pub mod printing { // Windows.UI.Xaml.Printing
use ::prelude::*;
RT_ENUM! { enum PreviewPageCountType: i32 {
    Final (PreviewPageCountType_Final) = 0, Intermediate (PreviewPageCountType_Intermediate) = 1,
}}
DEFINE_IID!(IID_AddPagesEventHandler, 3568662896, 22432, 16905, 132, 124, 192, 147, 181, 75, 199, 41);
RT_DELEGATE!{delegate AddPagesEventHandler(AddPagesEventHandlerVtbl, AddPagesEventHandlerImpl) [IID_AddPagesEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut AddPagesEventArgs) -> HRESULT
}}
impl AddPagesEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &AddPagesEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class AddPagesEventArgs: IAddPagesEventArgs}
impl RtActivatable<IActivationFactory> for AddPagesEventArgs {}
DEFINE_CLSID!(AddPagesEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,80,114,105,110,116,105,110,103,46,65,100,100,80,97,103,101,115,69,118,101,110,116,65,114,103,115,0]) [CLSID_AddPagesEventArgs]);
DEFINE_IID!(IID_GetPreviewPageEventHandler, 3434342893, 39953, 20048, 171, 73, 233, 128, 134, 187, 253, 239);
RT_DELEGATE!{delegate GetPreviewPageEventHandler(GetPreviewPageEventHandlerVtbl, GetPreviewPageEventHandlerImpl) [IID_GetPreviewPageEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut GetPreviewPageEventArgs) -> HRESULT
}}
impl GetPreviewPageEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &GetPreviewPageEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class GetPreviewPageEventArgs: IGetPreviewPageEventArgs}
impl RtActivatable<IActivationFactory> for GetPreviewPageEventArgs {}
DEFINE_CLSID!(GetPreviewPageEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,80,114,105,110,116,105,110,103,46,71,101,116,80,114,101,118,105,101,119,80,97,103,101,69,118,101,110,116,65,114,103,115,0]) [CLSID_GetPreviewPageEventArgs]);
DEFINE_IID!(IID_PaginateEventHandler, 213932897, 33051, 18994, 153, 101, 19, 235, 120, 219, 176, 27);
RT_DELEGATE!{delegate PaginateEventHandler(PaginateEventHandlerVtbl, PaginateEventHandlerImpl) [IID_PaginateEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut PaginateEventArgs) -> HRESULT
}}
impl PaginateEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &PaginateEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class PaginateEventArgs: IPaginateEventArgs}
impl RtActivatable<IActivationFactory> for PaginateEventArgs {}
DEFINE_CLSID!(PaginateEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,80,114,105,110,116,105,110,103,46,80,97,103,105,110,97,116,101,69,118,101,110,116,65,114,103,115,0]) [CLSID_PaginateEventArgs]);
DEFINE_IID!(IID_IAddPagesEventArgs, 3806669797, 1388, 17440, 151, 149, 203, 53, 38, 206, 12, 32);
RT_INTERFACE!{interface IAddPagesEventArgs(IAddPagesEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAddPagesEventArgs] {
    #[cfg(feature="windows-graphics")] fn get_PrintTaskOptions(&self, out: *mut *mut ::rt::gen::windows::graphics::printing::PrintTaskOptions) -> HRESULT
}}
impl IAddPagesEventArgs {
    #[cfg(feature="windows-graphics")] #[inline] pub unsafe fn get_print_task_options(&self) -> Result<ComPtr<::rt::gen::windows::graphics::printing::PrintTaskOptions>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PrintTaskOptions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGetPreviewPageEventArgs, 2755489853, 57001, 19958, 167, 237, 53, 4, 156, 212, 133, 199);
RT_INTERFACE!{interface IGetPreviewPageEventArgs(IGetPreviewPageEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IGetPreviewPageEventArgs] {
    fn get_PageNumber(&self, out: *mut i32) -> HRESULT
}}
impl IGetPreviewPageEventArgs {
    #[inline] pub unsafe fn get_page_number(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PageNumber)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPaginateEventArgs, 3985924054, 31147, 17079, 147, 10, 61, 110, 9, 1, 29, 33);
RT_INTERFACE!{interface IPaginateEventArgs(IPaginateEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPaginateEventArgs] {
    #[cfg(not(feature="windows-graphics"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_PrintTaskOptions(&self, out: *mut *mut ::rt::gen::windows::graphics::printing::PrintTaskOptions) -> HRESULT,
    fn get_CurrentPreviewPageNumber(&self, out: *mut i32) -> HRESULT
}}
impl IPaginateEventArgs {
    #[cfg(feature="windows-graphics")] #[inline] pub unsafe fn get_print_task_options(&self) -> Result<ComPtr<::rt::gen::windows::graphics::printing::PrintTaskOptions>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PrintTaskOptions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_current_preview_page_number(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CurrentPreviewPageNumber)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPrintDocument, 3829606339, 43417, 18523, 177, 216, 114, 220, 81, 120, 33, 230);
RT_INTERFACE!{interface IPrintDocument(IPrintDocumentVtbl): IInspectable(IInspectableVtbl) [IID_IPrintDocument] {
    #[cfg(not(feature="windows-graphics"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_DocumentSource(&self, out: *mut *mut ::rt::gen::windows::graphics::printing::IPrintDocumentSource) -> HRESULT,
    fn add_Paginate(&self, value: *mut PaginateEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Paginate(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_GetPreviewPage(&self, value: *mut GetPreviewPageEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_GetPreviewPage(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_AddPages(&self, value: *mut AddPagesEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AddPages(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn AddPage(&self, pageVisual: *mut super::UIElement) -> HRESULT,
    fn AddPagesComplete(&self) -> HRESULT,
    fn SetPreviewPageCount(&self, count: i32, type_: PreviewPageCountType) -> HRESULT,
    fn SetPreviewPage(&self, pageNumber: i32, pageVisual: *mut super::UIElement) -> HRESULT,
    fn InvalidatePreview(&self) -> HRESULT
}}
impl IPrintDocument {
    #[cfg(feature="windows-graphics")] #[inline] pub unsafe fn get_document_source(&self) -> Result<ComPtr<::rt::gen::windows::graphics::printing::IPrintDocumentSource>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DocumentSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_paginate(&self, value: &PaginateEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Paginate)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_paginate(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Paginate)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_get_preview_page(&self, value: &GetPreviewPageEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_GetPreviewPage)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_get_preview_page(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_GetPreviewPage)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_add_pages(&self, value: &AddPagesEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_AddPages)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_add_pages(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_AddPages)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_page(&self, pageVisual: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).AddPage)(self as *const _ as *mut _, pageVisual as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_pages_complete(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).AddPagesComplete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_preview_page_count(&self, count: i32, type_: PreviewPageCountType) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPreviewPageCount)(self as *const _ as *mut _, count, type_);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_preview_page(&self, pageNumber: i32, pageVisual: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPreviewPage)(self as *const _ as *mut _, pageNumber, pageVisual as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn invalidate_preview(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).InvalidatePreview)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPrintDocumentStatics, 4254534204, 45394, 18912, 166, 189, 106, 166, 71, 126, 67, 199);
RT_INTERFACE!{static interface IPrintDocumentStatics(IPrintDocumentStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPrintDocumentStatics] {
    fn get_DocumentSourceProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IPrintDocumentStatics {
    #[inline] pub unsafe fn get_document_source_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DocumentSourceProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPrintDocumentFactory, 4219974031, 9734, 18991, 153, 212, 167, 205, 188, 53, 215, 199);
RT_INTERFACE!{interface IPrintDocumentFactory(IPrintDocumentFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPrintDocumentFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut PrintDocument) -> HRESULT
}}
impl IPrintDocumentFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<PrintDocument>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class PrintDocument: IPrintDocument}
impl RtActivatable<IPrintDocumentStatics> for PrintDocument {}
impl PrintDocument {
    #[inline] pub fn get_document_source_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPrintDocumentStatics>>::get_activation_factory().get_document_source_property()
    }}
}
DEFINE_CLSID!(PrintDocument(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,80,114,105,110,116,105,110,103,46,80,114,105,110,116,68,111,99,117,109,101,110,116,0]) [CLSID_PrintDocument]);
} // Windows.UI.Xaml.Printing
pub mod navigation { // Windows.UI.Xaml.Navigation
use ::prelude::*;
RT_ENUM! { enum NavigationCacheMode: i32 {
    Disabled (NavigationCacheMode_Disabled) = 0, Required (NavigationCacheMode_Required) = 1, Enabled (NavigationCacheMode_Enabled) = 2,
}}
RT_ENUM! { enum NavigationMode: i32 {
    New (NavigationMode_New) = 0, Back (NavigationMode_Back) = 1, Forward (NavigationMode_Forward) = 2, Refresh (NavigationMode_Refresh) = 3,
}}
DEFINE_IID!(IID_LoadCompletedEventHandler, 2931488645, 17404, 20012, 149, 195, 151, 174, 132, 234, 188, 142);
RT_DELEGATE!{delegate LoadCompletedEventHandler(LoadCompletedEventHandlerVtbl, LoadCompletedEventHandlerImpl) [IID_LoadCompletedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut NavigationEventArgs) -> HRESULT
}}
impl LoadCompletedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &NavigationEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class NavigationEventArgs: INavigationEventArgs}
DEFINE_IID!(IID_NavigatedEventHandler, 2077347668, 9167, 19662, 178, 245, 76, 231, 141, 150, 137, 110);
RT_DELEGATE!{delegate NavigatedEventHandler(NavigatedEventHandlerVtbl, NavigatedEventHandlerImpl) [IID_NavigatedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut NavigationEventArgs) -> HRESULT
}}
impl NavigatedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &NavigationEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_NavigatingCancelEventHandler, 1977001871, 41730, 17545, 152, 152, 36, 234, 73, 24, 41, 16);
RT_DELEGATE!{delegate NavigatingCancelEventHandler(NavigatingCancelEventHandlerVtbl, NavigatingCancelEventHandlerImpl) [IID_NavigatingCancelEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut NavigatingCancelEventArgs) -> HRESULT
}}
impl NavigatingCancelEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &NavigatingCancelEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class NavigatingCancelEventArgs: INavigatingCancelEventArgs}
DEFINE_IID!(IID_NavigationFailedEventHandler, 1303070321, 4786, 17351, 184, 146, 155, 226, 220, 211, 232, 141);
RT_DELEGATE!{delegate NavigationFailedEventHandler(NavigationFailedEventHandlerVtbl, NavigationFailedEventHandlerImpl) [IID_NavigationFailedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut NavigationFailedEventArgs) -> HRESULT
}}
impl NavigationFailedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &NavigationFailedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class NavigationFailedEventArgs: INavigationFailedEventArgs}
DEFINE_IID!(IID_NavigationStoppedEventHandler, 4027678171, 4858, 19853, 139, 38, 179, 131, 208, 156, 43, 60);
RT_DELEGATE!{delegate NavigationStoppedEventHandler(NavigationStoppedEventHandlerVtbl, NavigationStoppedEventHandlerImpl) [IID_NavigationStoppedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut NavigationEventArgs) -> HRESULT
}}
impl NavigationStoppedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &NavigationEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_INavigatingCancelEventArgs, 4246562734, 60155, 16505, 190, 128, 109, 201, 42, 3, 174, 223);
RT_INTERFACE!{interface INavigatingCancelEventArgs(INavigatingCancelEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_INavigatingCancelEventArgs] {
    fn get_Cancel(&self, out: *mut bool) -> HRESULT,
    fn put_Cancel(&self, value: bool) -> HRESULT,
    fn get_NavigationMode(&self, out: *mut NavigationMode) -> HRESULT,
    fn get_SourcePageType(&self, out: *mut super::interop::TypeName) -> HRESULT
}}
impl INavigatingCancelEventArgs {
    #[inline] pub unsafe fn get_cancel(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cancel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_cancel(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Cancel)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_navigation_mode(&self) -> Result<NavigationMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NavigationMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_source_page_type(&self) -> Result<super::interop::TypeName> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SourcePageType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_INavigatingCancelEventArgs2, 1409791748, 33095, 17219, 131, 143, 221, 30, 233, 8, 193, 55);
RT_INTERFACE!{interface INavigatingCancelEventArgs2(INavigatingCancelEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_INavigatingCancelEventArgs2] {
    fn get_Parameter(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn get_NavigationTransitionInfo(&self, out: *mut *mut super::media::animation::NavigationTransitionInfo) -> HRESULT
}}
impl INavigatingCancelEventArgs2 {
    #[inline] pub unsafe fn get_parameter(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Parameter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_navigation_transition_info(&self) -> Result<ComPtr<super::media::animation::NavigationTransitionInfo>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NavigationTransitionInfo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_INavigationEventArgs, 3064633396, 26257, 17617, 189, 247, 88, 130, 12, 39, 176, 208);
RT_INTERFACE!{interface INavigationEventArgs(INavigationEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_INavigationEventArgs] {
    fn get_Content(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn get_Parameter(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn get_SourcePageType(&self, out: *mut super::interop::TypeName) -> HRESULT,
    fn get_NavigationMode(&self, out: *mut NavigationMode) -> HRESULT,
    fn get_Uri(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn put_Uri(&self, value: *mut ::rt::gen::windows::foundation::Uri) -> HRESULT
}}
impl INavigationEventArgs {
    #[inline] pub unsafe fn get_content(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Content)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_parameter(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Parameter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_source_page_type(&self) -> Result<super::interop::TypeName> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SourcePageType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_navigation_mode(&self) -> Result<NavigationMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NavigationMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_uri(&self, value: &::rt::gen::windows::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Uri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_INavigationEventArgs2, 3690951129, 38810, 19246, 164, 155, 59, 177, 127, 222, 245, 116);
RT_INTERFACE!{interface INavigationEventArgs2(INavigationEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_INavigationEventArgs2] {
    fn get_NavigationTransitionInfo(&self, out: *mut *mut super::media::animation::NavigationTransitionInfo) -> HRESULT
}}
impl INavigationEventArgs2 {
    #[inline] pub unsafe fn get_navigation_transition_info(&self) -> Result<ComPtr<super::media::animation::NavigationTransitionInfo>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NavigationTransitionInfo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_INavigationFailedEventArgs, 297918455, 14018, 16642, 178, 239, 2, 23, 169, 114, 137, 179);
RT_INTERFACE!{interface INavigationFailedEventArgs(INavigationFailedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_INavigationFailedEventArgs] {
    fn get_Exception(&self, out: *mut ::rt::gen::windows::foundation::HResult) -> HRESULT,
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn get_SourcePageType(&self, out: *mut super::interop::TypeName) -> HRESULT
}}
impl INavigationFailedEventArgs {
    #[inline] pub unsafe fn get_exception(&self) -> Result<::rt::gen::windows::foundation::HResult> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Exception)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_source_page_type(&self) -> Result<super::interop::TypeName> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SourcePageType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPageStackEntry, 4018672806, 37768, 19146, 133, 114, 64, 81, 148, 6, 144, 128);
RT_INTERFACE!{interface IPageStackEntry(IPageStackEntryVtbl): IInspectable(IInspectableVtbl) [IID_IPageStackEntry] {
    fn get_SourcePageType(&self, out: *mut super::interop::TypeName) -> HRESULT,
    fn get_Parameter(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn get_NavigationTransitionInfo(&self, out: *mut *mut super::media::animation::NavigationTransitionInfo) -> HRESULT
}}
impl IPageStackEntry {
    #[inline] pub unsafe fn get_source_page_type(&self) -> Result<super::interop::TypeName> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SourcePageType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_parameter(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Parameter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_navigation_transition_info(&self) -> Result<ComPtr<super::media::animation::NavigationTransitionInfo>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NavigationTransitionInfo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPageStackEntryStatics, 2901407971, 9324, 16435, 159, 1, 1, 203, 13, 165, 37, 78);
RT_INTERFACE!{static interface IPageStackEntryStatics(IPageStackEntryStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPageStackEntryStatics] {
    fn get_SourcePageTypeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IPageStackEntryStatics {
    #[inline] pub unsafe fn get_source_page_type_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourcePageTypeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPageStackEntryFactory, 1146356874, 43193, 20344, 155, 132, 31, 81, 245, 136, 81, 255);
RT_INTERFACE!{static interface IPageStackEntryFactory(IPageStackEntryFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPageStackEntryFactory] {
    fn CreateInstance(&self, sourcePageType: super::interop::TypeName, parameter: *mut IInspectable, navigationTransitionInfo: *mut super::media::animation::NavigationTransitionInfo, out: *mut *mut PageStackEntry) -> HRESULT
}}
impl IPageStackEntryFactory {
    #[inline] pub unsafe fn create_instance(&self, sourcePageType: super::interop::TypeName, parameter: &IInspectable, navigationTransitionInfo: &super::media::animation::NavigationTransitionInfo) -> Result<ComPtr<PageStackEntry>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, sourcePageType, parameter as *const _ as *mut _, navigationTransitionInfo as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PageStackEntry: IPageStackEntry}
impl RtActivatable<IPageStackEntryFactory> for PageStackEntry {}
impl RtActivatable<IPageStackEntryStatics> for PageStackEntry {}
impl PageStackEntry {
    #[inline] pub fn create_instance(sourcePageType: super::interop::TypeName, parameter: &IInspectable, navigationTransitionInfo: &super::media::animation::NavigationTransitionInfo) -> Result<ComPtr<PageStackEntry>> { unsafe {
        <Self as RtActivatable<IPageStackEntryFactory>>::get_activation_factory().create_instance(sourcePageType, parameter, navigationTransitionInfo)
    }}
    #[inline] pub fn get_source_page_type_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPageStackEntryStatics>>::get_activation_factory().get_source_page_type_property()
    }}
}
DEFINE_CLSID!(PageStackEntry(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,78,97,118,105,103,97,116,105,111,110,46,80,97,103,101,83,116,97,99,107,69,110,116,114,121,0]) [CLSID_PageStackEntry]);
} // Windows.UI.Xaml.Navigation
pub mod interop { // Windows.UI.Xaml.Interop
use ::prelude::*;
RT_ENUM! { enum NotifyCollectionChangedAction: i32 {
    Add (NotifyCollectionChangedAction_Add) = 0, Remove (NotifyCollectionChangedAction_Remove) = 1, Replace (NotifyCollectionChangedAction_Replace) = 2, Move (NotifyCollectionChangedAction_Move) = 3, Reset (NotifyCollectionChangedAction_Reset) = 4,
}}
DEFINE_IID!(IID_BindableVectorChangedEventHandler, 1649202401, 53255, 17329, 156, 3, 175, 77, 62, 98, 88, 196);
RT_DELEGATE!{delegate BindableVectorChangedEventHandler(BindableVectorChangedEventHandlerVtbl, BindableVectorChangedEventHandlerImpl) [IID_BindableVectorChangedEventHandler] {
    fn Invoke(&self, vector: *mut IBindableObservableVector, e: *mut IInspectable) -> HRESULT
}}
impl BindableVectorChangedEventHandler {
    #[inline] pub unsafe fn invoke(&self, vector: &IBindableObservableVector, e: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, vector as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBindableIterable, 57486344, 57129, 16815, 138, 162, 215, 116, 190, 98, 186, 111);
RT_INTERFACE!{interface IBindableIterable(IBindableIterableVtbl): IInspectable(IInspectableVtbl) [IID_IBindableIterable] {
    fn First(&self, out: *mut *mut IBindableIterator) -> HRESULT
}}
impl IBindableIterable {
    #[inline] pub unsafe fn first(&self) -> Result<ComPtr<IBindableIterator>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).First)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBindableVector, 960358366, 28624, 19469, 187, 113, 71, 36, 74, 17, 62, 147);
RT_INTERFACE!{interface IBindableVector(IBindableVectorVtbl): IInspectable(IInspectableVtbl) [IID_IBindableVector] {
    fn GetAt(&self, index: u32, out: *mut *mut IInspectable) -> HRESULT,
    fn get_Size(&self, out: *mut u32) -> HRESULT,
    fn GetView(&self, out: *mut *mut IBindableVectorView) -> HRESULT,
    fn IndexOf(&self, value: *mut IInspectable, index: *mut u32, out: *mut bool) -> HRESULT,
    fn SetAt(&self, index: u32, value: *mut IInspectable) -> HRESULT,
    fn InsertAt(&self, index: u32, value: *mut IInspectable) -> HRESULT,
    fn RemoveAt(&self, index: u32) -> HRESULT,
    fn Append(&self, value: *mut IInspectable) -> HRESULT,
    fn RemoveAtEnd(&self) -> HRESULT,
    fn Clear(&self) -> HRESULT
}}
impl IBindableVector {
    #[inline] pub unsafe fn get_at(&self, index: u32) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAt)(self as *const _ as *mut _, index, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_size(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Size)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_view(&self) -> Result<ComPtr<IBindableVectorView>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn index_of(&self, value: &IInspectable) -> Result<(u32, bool)> {
        let mut index = zeroed(); let mut out = zeroed();
        let hr = ((*self.lpVtbl).IndexOf)(self as *const _ as *mut _, value as *const _ as *mut _, &mut index, &mut out);
        if hr == S_OK { Ok((index, out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_at(&self, index: u32, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).SetAt)(self as *const _ as *mut _, index, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn insert_at(&self, index: u32, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).InsertAt)(self as *const _ as *mut _, index, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_at(&self, index: u32) -> Result<()> {
        let hr = ((*self.lpVtbl).RemoveAt)(self as *const _ as *mut _, index);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn append(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).Append)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_at_end(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).RemoveAtEnd)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn clear(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Clear)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBindableObservableVector, 4263425334, 32383, 20368, 172, 154, 71, 73, 132, 170, 229, 18);
RT_INTERFACE!{interface IBindableObservableVector(IBindableObservableVectorVtbl): IInspectable(IInspectableVtbl) [IID_IBindableObservableVector] {
    fn add_VectorChanged(&self, value: *mut BindableVectorChangedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VectorChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IBindableObservableVector {
    #[inline] pub unsafe fn add_vector_changed(&self, value: &BindableVectorChangedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_VectorChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_vector_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_VectorChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBindableVectorView, 879613671, 38766, 19395, 129, 93, 236, 226, 67, 188, 15, 51);
RT_INTERFACE!{interface IBindableVectorView(IBindableVectorViewVtbl): IInspectable(IInspectableVtbl) [IID_IBindableVectorView] {
    fn GetAt(&self, index: u32, out: *mut *mut IInspectable) -> HRESULT,
    fn get_Size(&self, out: *mut u32) -> HRESULT,
    fn IndexOf(&self, value: *mut IInspectable, index: *mut u32, out: *mut bool) -> HRESULT
}}
impl IBindableVectorView {
    #[inline] pub unsafe fn get_at(&self, index: u32) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAt)(self as *const _ as *mut _, index, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_size(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Size)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn index_of(&self, value: &IInspectable) -> Result<(u32, bool)> {
        let mut index = zeroed(); let mut out = zeroed();
        let hr = ((*self.lpVtbl).IndexOf)(self as *const _ as *mut _, value as *const _ as *mut _, &mut index, &mut out);
        if hr == S_OK { Ok((index, out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBindableIterator, 1780313095, 1901, 18930, 131, 20, 245, 44, 156, 154, 131, 49);
RT_INTERFACE!{interface IBindableIterator(IBindableIteratorVtbl): IInspectable(IInspectableVtbl) [IID_IBindableIterator] {
    fn get_Current(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn get_HasCurrent(&self, out: *mut bool) -> HRESULT,
    fn MoveNext(&self, out: *mut bool) -> HRESULT
}}
impl IBindableIterator {
    #[inline] pub unsafe fn get_current(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Current)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_has_current(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HasCurrent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn move_next(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).MoveNext)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_NotifyCollectionChangedEventHandler, 3390092156, 62338, 17809, 133, 87, 94, 36, 150, 82, 121, 176);
RT_DELEGATE!{delegate NotifyCollectionChangedEventHandler(NotifyCollectionChangedEventHandlerVtbl, NotifyCollectionChangedEventHandlerImpl) [IID_NotifyCollectionChangedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut NotifyCollectionChangedEventArgs) -> HRESULT
}}
impl NotifyCollectionChangedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &NotifyCollectionChangedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class NotifyCollectionChangedEventArgs: INotifyCollectionChangedEventArgs}
DEFINE_IID!(IID_INotifyCollectionChanged, 682715093, 6705, 18011, 155, 37, 213, 195, 174, 104, 108, 64);
RT_INTERFACE!{interface INotifyCollectionChanged(INotifyCollectionChangedVtbl): IInspectable(IInspectableVtbl) [IID_INotifyCollectionChanged] {
    fn add_CollectionChanged(&self, value: *mut NotifyCollectionChangedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CollectionChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl INotifyCollectionChanged {
    #[inline] pub unsafe fn add_collection_changed(&self, value: &NotifyCollectionChangedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CollectionChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_collection_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_CollectionChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_INotifyCollectionChangedEventArgs, 1291226419, 58354, 18788, 184, 94, 148, 91, 79, 126, 47, 33);
RT_INTERFACE!{interface INotifyCollectionChangedEventArgs(INotifyCollectionChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_INotifyCollectionChangedEventArgs] {
    fn get_Action(&self, out: *mut NotifyCollectionChangedAction) -> HRESULT,
    fn get_NewItems(&self, out: *mut *mut IBindableVector) -> HRESULT,
    fn get_OldItems(&self, out: *mut *mut IBindableVector) -> HRESULT,
    fn get_NewStartingIndex(&self, out: *mut i32) -> HRESULT,
    fn get_OldStartingIndex(&self, out: *mut i32) -> HRESULT
}}
impl INotifyCollectionChangedEventArgs {
    #[inline] pub unsafe fn get_action(&self) -> Result<NotifyCollectionChangedAction> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Action)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_new_items(&self) -> Result<ComPtr<IBindableVector>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NewItems)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_old_items(&self) -> Result<ComPtr<IBindableVector>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OldItems)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_new_starting_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NewStartingIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_old_starting_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OldStartingIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_INotifyCollectionChangedEventArgsFactory, 3003924026, 57229, 17573, 154, 56, 122, 192, 208, 140, 230, 61);
RT_INTERFACE!{interface INotifyCollectionChangedEventArgsFactory(INotifyCollectionChangedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_INotifyCollectionChangedEventArgsFactory] {
    fn CreateInstanceWithAllParameters(&self, action: NotifyCollectionChangedAction, newItems: *mut IBindableVector, oldItems: *mut IBindableVector, newIndex: i32, oldIndex: i32, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut NotifyCollectionChangedEventArgs) -> HRESULT
}}
impl INotifyCollectionChangedEventArgsFactory {
    #[inline] pub unsafe fn create_instance_with_all_parameters(&self, action: NotifyCollectionChangedAction, newItems: &IBindableVector, oldItems: &IBindableVector, newIndex: i32, oldIndex: i32, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<NotifyCollectionChangedEventArgs>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithAllParameters)(self as *const _ as *mut _, action, newItems as *const _ as *mut _, oldItems as *const _ as *mut _, newIndex, oldIndex, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_ENUM! { enum TypeKind: i32 {
    Primitive (TypeKind_Primitive) = 0, Metadata (TypeKind_Metadata) = 1, Custom (TypeKind_Custom) = 2,
}}
RT_STRUCT! { struct TypeName {
    Name: HSTRING, Kind: TypeKind,
}}
} // Windows.UI.Xaml.Interop
pub mod media { // Windows.UI.Xaml.Media
use ::prelude::*;
DEFINE_IID!(IID_IVisualTreeHelper, 616117731, 21191, 16705, 139, 172, 167, 61, 6, 19, 5, 105);
RT_INTERFACE!{interface IVisualTreeHelper(IVisualTreeHelperVtbl): IInspectable(IInspectableVtbl) [IID_IVisualTreeHelper] {
    
}}
DEFINE_IID!(IID_IVisualTreeHelperStatics, 3881261252, 53853, 19229, 151, 31, 89, 111, 23, 241, 43, 170);
RT_INTERFACE!{static interface IVisualTreeHelperStatics(IVisualTreeHelperStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IVisualTreeHelperStatics] {
    fn FindElementsInHostCoordinatesPoint(&self, intersectingPoint: ::rt::gen::windows::foundation::Point, subtree: *mut super::UIElement, out: *mut *mut ::rt::gen::windows::foundation::collections::IIterable<super::UIElement>) -> HRESULT,
    fn FindElementsInHostCoordinatesRect(&self, intersectingRect: ::rt::gen::windows::foundation::Rect, subtree: *mut super::UIElement, out: *mut *mut ::rt::gen::windows::foundation::collections::IIterable<super::UIElement>) -> HRESULT,
    fn FindAllElementsInHostCoordinatesPoint(&self, intersectingPoint: ::rt::gen::windows::foundation::Point, subtree: *mut super::UIElement, includeAllElements: bool, out: *mut *mut ::rt::gen::windows::foundation::collections::IIterable<super::UIElement>) -> HRESULT,
    fn FindAllElementsInHostCoordinatesRect(&self, intersectingRect: ::rt::gen::windows::foundation::Rect, subtree: *mut super::UIElement, includeAllElements: bool, out: *mut *mut ::rt::gen::windows::foundation::collections::IIterable<super::UIElement>) -> HRESULT,
    fn GetChild(&self, reference: *mut super::DependencyObject, childIndex: i32, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn GetChildrenCount(&self, reference: *mut super::DependencyObject, out: *mut i32) -> HRESULT,
    fn GetParent(&self, reference: *mut super::DependencyObject, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn DisconnectChildrenRecursive(&self, element: *mut super::UIElement) -> HRESULT
}}
impl IVisualTreeHelperStatics {
    #[inline] pub unsafe fn find_elements_in_host_coordinates_point(&self, intersectingPoint: ::rt::gen::windows::foundation::Point, subtree: &super::UIElement) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IIterable<super::UIElement>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindElementsInHostCoordinatesPoint)(self as *const _ as *mut _, intersectingPoint, subtree as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_elements_in_host_coordinates_rect(&self, intersectingRect: ::rt::gen::windows::foundation::Rect, subtree: &super::UIElement) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IIterable<super::UIElement>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindElementsInHostCoordinatesRect)(self as *const _ as *mut _, intersectingRect, subtree as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_all_elements_in_host_coordinates_point(&self, intersectingPoint: ::rt::gen::windows::foundation::Point, subtree: &super::UIElement, includeAllElements: bool) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IIterable<super::UIElement>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAllElementsInHostCoordinatesPoint)(self as *const _ as *mut _, intersectingPoint, subtree as *const _ as *mut _, includeAllElements, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_all_elements_in_host_coordinates_rect(&self, intersectingRect: ::rt::gen::windows::foundation::Rect, subtree: &super::UIElement, includeAllElements: bool) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IIterable<super::UIElement>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAllElementsInHostCoordinatesRect)(self as *const _ as *mut _, intersectingRect, subtree as *const _ as *mut _, includeAllElements, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_child(&self, reference: &super::DependencyObject, childIndex: i32) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetChild)(self as *const _ as *mut _, reference as *const _ as *mut _, childIndex, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_children_count(&self, reference: &super::DependencyObject) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetChildrenCount)(self as *const _ as *mut _, reference as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_parent(&self, reference: &super::DependencyObject) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetParent)(self as *const _ as *mut _, reference as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn disconnect_children_recursive(&self, element: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).DisconnectChildrenRecursive)(self as *const _ as *mut _, element as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVisualTreeHelperStatics2, 129814902, 34463, 17575, 135, 151, 33, 3, 164, 195, 228, 122);
RT_INTERFACE!{static interface IVisualTreeHelperStatics2(IVisualTreeHelperStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IVisualTreeHelperStatics2] {
    fn GetOpenPopups(&self, window: *mut super::Window, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<super::controls::primitives::Popup>) -> HRESULT
}}
impl IVisualTreeHelperStatics2 {
    #[inline] pub unsafe fn get_open_popups(&self, window: &super::Window) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<super::controls::primitives::Popup>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetOpenPopups)(self as *const _ as *mut _, window as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class VisualTreeHelper: IVisualTreeHelper}
impl RtActivatable<IVisualTreeHelperStatics2> for VisualTreeHelper {}
impl RtActivatable<IVisualTreeHelperStatics> for VisualTreeHelper {}
impl VisualTreeHelper {
    #[inline] pub fn get_open_popups(window: &super::Window) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<super::controls::primitives::Popup>>> { unsafe {
        <Self as RtActivatable<IVisualTreeHelperStatics2>>::get_activation_factory().get_open_popups(window)
    }}
    #[inline] pub fn find_elements_in_host_coordinates_point(intersectingPoint: ::rt::gen::windows::foundation::Point, subtree: &super::UIElement) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IIterable<super::UIElement>>> { unsafe {
        <Self as RtActivatable<IVisualTreeHelperStatics>>::get_activation_factory().find_elements_in_host_coordinates_point(intersectingPoint, subtree)
    }}
    #[inline] pub fn find_elements_in_host_coordinates_rect(intersectingRect: ::rt::gen::windows::foundation::Rect, subtree: &super::UIElement) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IIterable<super::UIElement>>> { unsafe {
        <Self as RtActivatable<IVisualTreeHelperStatics>>::get_activation_factory().find_elements_in_host_coordinates_rect(intersectingRect, subtree)
    }}
    #[inline] pub fn find_all_elements_in_host_coordinates_point(intersectingPoint: ::rt::gen::windows::foundation::Point, subtree: &super::UIElement, includeAllElements: bool) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IIterable<super::UIElement>>> { unsafe {
        <Self as RtActivatable<IVisualTreeHelperStatics>>::get_activation_factory().find_all_elements_in_host_coordinates_point(intersectingPoint, subtree, includeAllElements)
    }}
    #[inline] pub fn find_all_elements_in_host_coordinates_rect(intersectingRect: ::rt::gen::windows::foundation::Rect, subtree: &super::UIElement, includeAllElements: bool) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IIterable<super::UIElement>>> { unsafe {
        <Self as RtActivatable<IVisualTreeHelperStatics>>::get_activation_factory().find_all_elements_in_host_coordinates_rect(intersectingRect, subtree, includeAllElements)
    }}
    #[inline] pub fn get_child(reference: &super::DependencyObject, childIndex: i32) -> Result<ComPtr<super::DependencyObject>> { unsafe {
        <Self as RtActivatable<IVisualTreeHelperStatics>>::get_activation_factory().get_child(reference, childIndex)
    }}
    #[inline] pub fn get_children_count(reference: &super::DependencyObject) -> Result<i32> { unsafe {
        <Self as RtActivatable<IVisualTreeHelperStatics>>::get_activation_factory().get_children_count(reference)
    }}
    #[inline] pub fn get_parent(reference: &super::DependencyObject) -> Result<ComPtr<super::DependencyObject>> { unsafe {
        <Self as RtActivatable<IVisualTreeHelperStatics>>::get_activation_factory().get_parent(reference)
    }}
    #[inline] pub fn disconnect_children_recursive(element: &super::UIElement) -> Result<()> { unsafe {
        <Self as RtActivatable<IVisualTreeHelperStatics>>::get_activation_factory().disconnect_children_recursive(element)
    }}
}
DEFINE_CLSID!(VisualTreeHelper(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,86,105,115,117,97,108,84,114,101,101,72,101,108,112,101,114,0]) [CLSID_VisualTreeHelper]);
RT_ENUM! { enum MediaElementState: i32 {
    Closed (MediaElementState_Closed) = 0, Opening (MediaElementState_Opening) = 1, Buffering (MediaElementState_Buffering) = 2, Playing (MediaElementState_Playing) = 3, Paused (MediaElementState_Paused) = 4, Stopped (MediaElementState_Stopped) = 5,
}}
DEFINE_IID!(IID_IPartialMediaFailureDetectedEventArgs, 45505169, 58785, 17451, 136, 211, 45, 193, 39, 191, 197, 155);
RT_INTERFACE!{interface IPartialMediaFailureDetectedEventArgs(IPartialMediaFailureDetectedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPartialMediaFailureDetectedEventArgs] {
    #[cfg(feature="windows-media")] fn get_StreamKind(&self, out: *mut ::rt::gen::windows::media::playback::FailedMediaStreamKind) -> HRESULT
}}
impl IPartialMediaFailureDetectedEventArgs {
    #[cfg(feature="windows-media")] #[inline] pub unsafe fn get_stream_kind(&self) -> Result<::rt::gen::windows::media::playback::FailedMediaStreamKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StreamKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPartialMediaFailureDetectedEventArgs2, 1929857141, 35085, 16747, 185, 174, 232, 77, 253, 156, 75, 27);
RT_INTERFACE!{interface IPartialMediaFailureDetectedEventArgs2(IPartialMediaFailureDetectedEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IPartialMediaFailureDetectedEventArgs2] {
    fn get_ExtendedError(&self, out: *mut ::rt::gen::windows::foundation::HResult) -> HRESULT
}}
impl IPartialMediaFailureDetectedEventArgs2 {
    #[inline] pub unsafe fn get_extended_error(&self) -> Result<::rt::gen::windows::foundation::HResult> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExtendedError)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class PartialMediaFailureDetectedEventArgs: IPartialMediaFailureDetectedEventArgs}
impl RtActivatable<IActivationFactory> for PartialMediaFailureDetectedEventArgs {}
DEFINE_CLSID!(PartialMediaFailureDetectedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,80,97,114,116,105,97,108,77,101,100,105,97,70,97,105,108,117,114,101,68,101,116,101,99,116,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_PartialMediaFailureDetectedEventArgs]);
RT_ENUM! { enum AudioCategory: i32 {
    Other (AudioCategory_Other) = 0, ForegroundOnlyMedia (AudioCategory_ForegroundOnlyMedia) = 1, BackgroundCapableMedia (AudioCategory_BackgroundCapableMedia) = 2, Communications (AudioCategory_Communications) = 3, Alerts (AudioCategory_Alerts) = 4, SoundEffects (AudioCategory_SoundEffects) = 5, GameEffects (AudioCategory_GameEffects) = 6, GameMedia (AudioCategory_GameMedia) = 7, GameChat (AudioCategory_GameChat) = 8, Speech (AudioCategory_Speech) = 9, Movie (AudioCategory_Movie) = 10, Media (AudioCategory_Media) = 11,
}}
RT_ENUM! { enum AudioDeviceType: i32 {
    Console (AudioDeviceType_Console) = 0, Multimedia (AudioDeviceType_Multimedia) = 1, Communications (AudioDeviceType_Communications) = 2,
}}
RT_ENUM! { enum BrushMappingMode: i32 {
    Absolute (BrushMappingMode_Absolute) = 0, RelativeToBoundingBox (BrushMappingMode_RelativeToBoundingBox) = 1,
}}
RT_ENUM! { enum ColorInterpolationMode: i32 {
    ScRgbLinearInterpolation (ColorInterpolationMode_ScRgbLinearInterpolation) = 0, SRgbLinearInterpolation (ColorInterpolationMode_SRgbLinearInterpolation) = 1,
}}
RT_ENUM! { enum ElementCompositeMode: i32 {
    Inherit (ElementCompositeMode_Inherit) = 0, SourceOver (ElementCompositeMode_SourceOver) = 1, MinBlend (ElementCompositeMode_MinBlend) = 2,
}}
RT_ENUM! { enum FastPlayFallbackBehaviour: i32 {
    Skip (FastPlayFallbackBehaviour_Skip) = 0, Hide (FastPlayFallbackBehaviour_Hide) = 1, Disable (FastPlayFallbackBehaviour_Disable) = 2,
}}
RT_ENUM! { enum FillRule: i32 {
    EvenOdd (FillRule_EvenOdd) = 0, Nonzero (FillRule_Nonzero) = 1,
}}
RT_ENUM! { enum GradientSpreadMethod: i32 {
    Pad (GradientSpreadMethod_Pad) = 0, Reflect (GradientSpreadMethod_Reflect) = 1, Repeat (GradientSpreadMethod_Repeat) = 2,
}}
RT_ENUM! { enum MediaCanPlayResponse: i32 {
    NotSupported (MediaCanPlayResponse_NotSupported) = 0, Maybe (MediaCanPlayResponse_Maybe) = 1, Probably (MediaCanPlayResponse_Probably) = 2,
}}
RT_ENUM! { enum PenLineCap: i32 {
    Flat (PenLineCap_Flat) = 0, Square (PenLineCap_Square) = 1, Round (PenLineCap_Round) = 2, Triangle (PenLineCap_Triangle) = 3,
}}
RT_ENUM! { enum PenLineJoin: i32 {
    Miter (PenLineJoin_Miter) = 0, Bevel (PenLineJoin_Bevel) = 1, Round (PenLineJoin_Round) = 2,
}}
RT_ENUM! { enum Stereo3DVideoPackingMode: i32 {
    None (Stereo3DVideoPackingMode_None) = 0, SideBySide (Stereo3DVideoPackingMode_SideBySide) = 1, TopBottom (Stereo3DVideoPackingMode_TopBottom) = 2,
}}
RT_ENUM! { enum Stereo3DVideoRenderMode: i32 {
    Mono (Stereo3DVideoRenderMode_Mono) = 0, Stereo (Stereo3DVideoRenderMode_Stereo) = 1,
}}
RT_ENUM! { enum Stretch: i32 {
    None (Stretch_None) = 0, Fill (Stretch_Fill) = 1, Uniform (Stretch_Uniform) = 2, UniformToFill (Stretch_UniformToFill) = 3,
}}
RT_ENUM! { enum StyleSimulations: i32 {
    None (StyleSimulations_None) = 0, BoldSimulation (StyleSimulations_BoldSimulation) = 1, ItalicSimulation (StyleSimulations_ItalicSimulation) = 2, BoldItalicSimulation (StyleSimulations_BoldItalicSimulation) = 3,
}}
RT_ENUM! { enum SweepDirection: i32 {
    Counterclockwise (SweepDirection_Counterclockwise) = 0, Clockwise (SweepDirection_Clockwise) = 1,
}}
RT_STRUCT! { struct Matrix {
    M11: f64, M12: f64, M21: f64, M22: f64, OffsetX: f64, OffsetY: f64,
}}
DEFINE_IID!(IID_IMatrixHelper, 4090448002, 1717, 18632, 158, 178, 23, 99, 233, 54, 64, 56);
RT_INTERFACE!{interface IMatrixHelper(IMatrixHelperVtbl): IInspectable(IInspectableVtbl) [IID_IMatrixHelper] {
    
}}
DEFINE_IID!(IID_IMatrixHelperStatics, 3246786214, 14836, 19338, 132, 3, 40, 229, 229, 240, 51, 180);
RT_INTERFACE!{static interface IMatrixHelperStatics(IMatrixHelperStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMatrixHelperStatics] {
    fn get_Identity(&self, out: *mut Matrix) -> HRESULT,
    fn FromElements(&self, m11: f64, m12: f64, m21: f64, m22: f64, offsetX: f64, offsetY: f64, out: *mut Matrix) -> HRESULT,
    fn GetIsIdentity(&self, target: Matrix, out: *mut bool) -> HRESULT,
    fn Transform(&self, target: Matrix, point: ::rt::gen::windows::foundation::Point, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT
}}
impl IMatrixHelperStatics {
    #[inline] pub unsafe fn get_identity(&self) -> Result<Matrix> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Identity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn from_elements(&self, m11: f64, m12: f64, m21: f64, m22: f64, offsetX: f64, offsetY: f64) -> Result<Matrix> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).FromElements)(self as *const _ as *mut _, m11, m12, m21, m22, offsetX, offsetY, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_identity(&self, target: Matrix) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsIdentity)(self as *const _ as *mut _, target, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn transform(&self, target: Matrix, point: ::rt::gen::windows::foundation::Point) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Transform)(self as *const _ as *mut _, target, point, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class MatrixHelper: IMatrixHelper}
impl RtActivatable<IMatrixHelperStatics> for MatrixHelper {}
impl MatrixHelper {
    #[inline] pub fn get_identity() -> Result<Matrix> { unsafe {
        <Self as RtActivatable<IMatrixHelperStatics>>::get_activation_factory().get_identity()
    }}
    #[inline] pub fn from_elements(m11: f64, m12: f64, m21: f64, m22: f64, offsetX: f64, offsetY: f64) -> Result<Matrix> { unsafe {
        <Self as RtActivatable<IMatrixHelperStatics>>::get_activation_factory().from_elements(m11, m12, m21, m22, offsetX, offsetY)
    }}
    #[inline] pub fn get_is_identity(target: Matrix) -> Result<bool> { unsafe {
        <Self as RtActivatable<IMatrixHelperStatics>>::get_activation_factory().get_is_identity(target)
    }}
    #[inline] pub fn transform(target: Matrix, point: ::rt::gen::windows::foundation::Point) -> Result<::rt::gen::windows::foundation::Point> { unsafe {
        <Self as RtActivatable<IMatrixHelperStatics>>::get_activation_factory().transform(target, point)
    }}
}
DEFINE_CLSID!(MatrixHelper(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,77,97,116,114,105,120,72,101,108,112,101,114,0]) [CLSID_MatrixHelper]);
DEFINE_IID!(IID_RateChangedRoutedEventHandler, 149529175, 44549, 18587, 136, 57, 40, 198, 34, 93, 35, 73);
RT_DELEGATE!{delegate RateChangedRoutedEventHandler(RateChangedRoutedEventHandlerVtbl, RateChangedRoutedEventHandlerImpl) [IID_RateChangedRoutedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut RateChangedRoutedEventArgs) -> HRESULT
}}
impl RateChangedRoutedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &RateChangedRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_TimelineMarkerRoutedEventHandler, 1927477916, 28138, 19646, 161, 89, 6, 206, 149, 251, 236, 237);
RT_DELEGATE!{delegate TimelineMarkerRoutedEventHandler(TimelineMarkerRoutedEventHandlerVtbl, TimelineMarkerRoutedEventHandlerImpl) [IID_TimelineMarkerRoutedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut TimelineMarkerRoutedEventArgs) -> HRESULT
}}
impl TimelineMarkerRoutedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &TimelineMarkerRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class BrushCollection: ::rt::gen::windows::foundation::collections::IVector<Brush>}
impl RtActivatable<IActivationFactory> for BrushCollection {}
DEFINE_CLSID!(BrushCollection(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,66,114,117,115,104,67,111,108,108,101,99,116,105,111,110,0]) [CLSID_BrushCollection]);
DEFINE_IID!(IID_ICompositionTarget, 651149296, 28988, 19436, 136, 3, 225, 1, 247, 177, 78, 211);
RT_INTERFACE!{interface ICompositionTarget(ICompositionTargetVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionTarget] {
    
}}
DEFINE_IID!(IID_ICompositionTargetStatics, 723185725, 7890, 19289, 189, 0, 117, 148, 238, 146, 131, 43);
RT_INTERFACE!{static interface ICompositionTargetStatics(ICompositionTargetStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionTargetStatics] {
    fn add_Rendering(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Rendering(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_SurfaceContentsLost(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SurfaceContentsLost(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl ICompositionTargetStatics {
    #[inline] pub unsafe fn add_rendering(&self, value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Rendering)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_rendering(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Rendering)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_surface_contents_lost(&self, value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SurfaceContentsLost)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_surface_contents_lost(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SurfaceContentsLost)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class CompositionTarget: ICompositionTarget}
impl RtActivatable<ICompositionTargetStatics> for CompositionTarget {}
impl CompositionTarget {
    #[inline] pub fn add_rendering(value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> { unsafe {
        <Self as RtActivatable<ICompositionTargetStatics>>::get_activation_factory().add_rendering(value)
    }}
    #[inline] pub fn remove_rendering(token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> { unsafe {
        <Self as RtActivatable<ICompositionTargetStatics>>::get_activation_factory().remove_rendering(token)
    }}
    #[inline] pub fn add_surface_contents_lost(value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> { unsafe {
        <Self as RtActivatable<ICompositionTargetStatics>>::get_activation_factory().add_surface_contents_lost(value)
    }}
    #[inline] pub fn remove_surface_contents_lost(token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> { unsafe {
        <Self as RtActivatable<ICompositionTargetStatics>>::get_activation_factory().remove_surface_contents_lost(token)
    }}
}
DEFINE_CLSID!(CompositionTarget(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,67,111,109,112,111,115,105,116,105,111,110,84,97,114,103,101,116,0]) [CLSID_CompositionTarget]);
RT_CLASS!{class DoubleCollection: ::rt::gen::windows::foundation::collections::IVector<f64>}
impl RtActivatable<IActivationFactory> for DoubleCollection {}
DEFINE_CLSID!(DoubleCollection(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,68,111,117,98,108,101,67,111,108,108,101,99,116,105,111,110,0]) [CLSID_DoubleCollection]);
DEFINE_IID!(IID_IFontFamily, 2454093412, 54890, 19700, 147, 34, 61, 35, 179, 192, 195, 97);
RT_INTERFACE!{interface IFontFamily(IFontFamilyVtbl): IInspectable(IInspectableVtbl) [IID_IFontFamily] {
    fn get_Source(&self, out: *mut HSTRING) -> HRESULT
}}
impl IFontFamily {
    #[inline] pub unsafe fn get_source(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Source)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFontFamilyFactory, 3579851639, 15790, 19917, 175, 9, 249, 73, 142, 158, 198, 89);
RT_INTERFACE!{interface IFontFamilyFactory(IFontFamilyFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IFontFamilyFactory] {
    fn CreateInstanceWithName(&self, familyName: HSTRING, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut FontFamily) -> HRESULT
}}
impl IFontFamilyFactory {
    #[inline] pub unsafe fn create_instance_with_name(&self, familyName: &HStringArg, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<FontFamily>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithName)(self as *const _ as *mut _, familyName.get(), outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class FontFamily: IFontFamily}
impl RtActivatable<IFontFamilyStatics2> for FontFamily {}
impl FontFamily {
    #[inline] pub fn get_xaml_auto_font_family() -> Result<ComPtr<FontFamily>> { unsafe {
        <Self as RtActivatable<IFontFamilyStatics2>>::get_activation_factory().get_xaml_auto_font_family()
    }}
}
DEFINE_CLSID!(FontFamily(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,70,111,110,116,70,97,109,105,108,121,0]) [CLSID_FontFamily]);
DEFINE_IID!(IID_IFontFamilyStatics2, 1387100921, 14310, 17047, 162, 56, 151, 251, 106, 64, 141, 158);
RT_INTERFACE!{static interface IFontFamilyStatics2(IFontFamilyStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IFontFamilyStatics2] {
    fn get_XamlAutoFontFamily(&self, out: *mut *mut FontFamily) -> HRESULT
}}
impl IFontFamilyStatics2 {
    #[inline] pub unsafe fn get_xaml_auto_font_family(&self) -> Result<ComPtr<FontFamily>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XamlAutoFontFamily)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMediaTransportControlsThumbnailRequestedEventArgs, 3836260892, 58306, 18524, 174, 105, 241, 83, 123, 118, 117, 90);
RT_INTERFACE!{interface IMediaTransportControlsThumbnailRequestedEventArgs(IMediaTransportControlsThumbnailRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMediaTransportControlsThumbnailRequestedEventArgs] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn SetThumbnailImage(&self, source: *mut ::rt::gen::windows::storage::streams::IInputStream) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IMediaTransportControlsThumbnailRequestedEventArgs {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_thumbnail_image(&self, source: &::rt::gen::windows::storage::streams::IInputStream) -> Result<()> {
        let hr = ((*self.lpVtbl).SetThumbnailImage)(self as *const _ as *mut _, source as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class MediaTransportControlsThumbnailRequestedEventArgs: IMediaTransportControlsThumbnailRequestedEventArgs}
RT_CLASS!{class PointCollection: ::rt::gen::windows::foundation::collections::IVector<::rt::gen::windows::foundation::Point>}
impl RtActivatable<IActivationFactory> for PointCollection {}
DEFINE_CLSID!(PointCollection(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,80,111,105,110,116,67,111,108,108,101,99,116,105,111,110,0]) [CLSID_PointCollection]);
DEFINE_IID!(IID_IRenderingEventArgs, 1542968077, 38728, 19181, 131, 128, 215, 137, 14, 183, 118, 160);
RT_INTERFACE!{interface IRenderingEventArgs(IRenderingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IRenderingEventArgs] {
    fn get_RenderingTime(&self, out: *mut ::rt::gen::windows::foundation::TimeSpan) -> HRESULT
}}
impl IRenderingEventArgs {
    #[inline] pub unsafe fn get_rendering_time(&self) -> Result<::rt::gen::windows::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RenderingTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class RenderingEventArgs: IRenderingEventArgs}
RT_CLASS!{class TimelineMarkerCollection: ::rt::gen::windows::foundation::collections::IVector<TimelineMarker>}
impl RtActivatable<IActivationFactory> for TimelineMarkerCollection {}
DEFINE_CLSID!(TimelineMarkerCollection(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,84,105,109,101,108,105,110,101,77,97,114,107,101,114,67,111,108,108,101,99,116,105,111,110,0]) [CLSID_TimelineMarkerCollection]);
RT_CLASS!{class TransformCollection: ::rt::gen::windows::foundation::collections::IVector<Transform>}
impl RtActivatable<IActivationFactory> for TransformCollection {}
DEFINE_CLSID!(TransformCollection(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,84,114,97,110,115,102,111,114,109,67,111,108,108,101,99,116,105,111,110,0]) [CLSID_TransformCollection]);
DEFINE_IID!(IID_IBrush, 2282136353, 7686, 16940, 161, 204, 1, 105, 101, 89, 224, 33);
RT_INTERFACE!{interface IBrush(IBrushVtbl): IInspectable(IInspectableVtbl) [IID_IBrush] {
    fn get_Opacity(&self, out: *mut f64) -> HRESULT,
    fn put_Opacity(&self, value: f64) -> HRESULT,
    fn get_Transform(&self, out: *mut *mut Transform) -> HRESULT,
    fn put_Transform(&self, value: *mut Transform) -> HRESULT,
    fn get_RelativeTransform(&self, out: *mut *mut Transform) -> HRESULT,
    fn put_RelativeTransform(&self, value: *mut Transform) -> HRESULT
}}
impl IBrush {
    #[inline] pub unsafe fn get_opacity(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Opacity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_opacity(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Opacity)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transform(&self) -> Result<ComPtr<Transform>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Transform)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_transform(&self, value: &Transform) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Transform)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_relative_transform(&self) -> Result<ComPtr<Transform>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RelativeTransform)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_relative_transform(&self, value: &Transform) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RelativeTransform)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class Brush: IBrush}
impl RtActivatable<IBrushStatics> for Brush {}
impl Brush {
    #[inline] pub fn get_opacity_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBrushStatics>>::get_activation_factory().get_opacity_property()
    }}
    #[inline] pub fn get_transform_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBrushStatics>>::get_activation_factory().get_transform_property()
    }}
    #[inline] pub fn get_relative_transform_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBrushStatics>>::get_activation_factory().get_relative_transform_property()
    }}
}
DEFINE_CLSID!(Brush(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,66,114,117,115,104,0]) [CLSID_Brush]);
DEFINE_IID!(IID_IBrushStatics, 3876335874, 549, 18421, 178, 46, 4, 103, 97, 159, 106, 34);
RT_INTERFACE!{static interface IBrushStatics(IBrushStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBrushStatics] {
    fn get_OpacityProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TransformProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_RelativeTransformProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IBrushStatics {
    #[inline] pub unsafe fn get_opacity_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OpacityProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transform_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransformProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_relative_transform_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RelativeTransformProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBrushFactory, 966154402, 5371, 19343, 131, 230, 110, 61, 171, 18, 6, 155);
RT_INTERFACE!{interface IBrushFactory(IBrushFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IBrushFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut Brush) -> HRESULT
}}
impl IBrushFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<Brush>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICacheMode, 2564590353, 50937, 19883, 184, 56, 95, 213, 236, 140, 115, 80);
RT_INTERFACE!{interface ICacheMode(ICacheModeVtbl): IInspectable(IInspectableVtbl) [IID_ICacheMode] {
    
}}
RT_CLASS!{class CacheMode: ICacheMode}
DEFINE_IID!(IID_ICacheModeFactory, 3944713307, 2747, 20080, 184, 168, 98, 13, 13, 149, 58, 178);
RT_INTERFACE!{interface ICacheModeFactory(ICacheModeFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICacheModeFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut CacheMode) -> HRESULT
}}
impl ICacheModeFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<CacheMode>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGeneralTransform, 2691143863, 41708, 16735, 173, 226, 234, 222, 147, 51, 242, 199);
RT_INTERFACE!{interface IGeneralTransform(IGeneralTransformVtbl): IInspectable(IInspectableVtbl) [IID_IGeneralTransform] {
    fn get_Inverse(&self, out: *mut *mut GeneralTransform) -> HRESULT,
    fn TransformPoint(&self, point: ::rt::gen::windows::foundation::Point, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn TryTransform(&self, inPoint: ::rt::gen::windows::foundation::Point, outPoint: *mut ::rt::gen::windows::foundation::Point, out: *mut bool) -> HRESULT,
    fn TransformBounds(&self, rect: ::rt::gen::windows::foundation::Rect, out: *mut ::rt::gen::windows::foundation::Rect) -> HRESULT
}}
impl IGeneralTransform {
    #[inline] pub unsafe fn get_inverse(&self) -> Result<ComPtr<GeneralTransform>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Inverse)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn transform_point(&self, point: ::rt::gen::windows::foundation::Point) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TransformPoint)(self as *const _ as *mut _, point, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_transform(&self, inPoint: ::rt::gen::windows::foundation::Point) -> Result<(::rt::gen::windows::foundation::Point, bool)> {
        let mut outPoint = zeroed(); let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryTransform)(self as *const _ as *mut _, inPoint, &mut outPoint, &mut out);
        if hr == S_OK { Ok((outPoint, out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn transform_bounds(&self, rect: ::rt::gen::windows::foundation::Rect) -> Result<::rt::gen::windows::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TransformBounds)(self as *const _ as *mut _, rect, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGeneralTransformOverrides, 1326583939, 9423, 17700, 144, 173, 138, 66, 177, 193, 39, 131);
RT_INTERFACE!{interface IGeneralTransformOverrides(IGeneralTransformOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IGeneralTransformOverrides] {
    fn get_InverseCore(&self, out: *mut *mut GeneralTransform) -> HRESULT,
    fn TryTransformCore(&self, inPoint: ::rt::gen::windows::foundation::Point, outPoint: *mut ::rt::gen::windows::foundation::Point, out: *mut bool) -> HRESULT,
    fn TransformBoundsCore(&self, rect: ::rt::gen::windows::foundation::Rect, out: *mut ::rt::gen::windows::foundation::Rect) -> HRESULT
}}
impl IGeneralTransformOverrides {
    #[inline] pub unsafe fn get_inverse_core(&self) -> Result<ComPtr<GeneralTransform>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InverseCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_transform_core(&self, inPoint: ::rt::gen::windows::foundation::Point) -> Result<(::rt::gen::windows::foundation::Point, bool)> {
        let mut outPoint = zeroed(); let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryTransformCore)(self as *const _ as *mut _, inPoint, &mut outPoint, &mut out);
        if hr == S_OK { Ok((outPoint, out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn transform_bounds_core(&self, rect: ::rt::gen::windows::foundation::Rect) -> Result<::rt::gen::windows::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TransformBoundsCore)(self as *const _ as *mut _, rect, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class GeneralTransform: IGeneralTransform}
DEFINE_IID!(IID_IGeneralTransformFactory, 2049296688, 10692, 20017, 182, 249, 222, 221, 82, 228, 223, 27);
RT_INTERFACE!{interface IGeneralTransformFactory(IGeneralTransformFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGeneralTransformFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut GeneralTransform) -> HRESULT
}}
impl IGeneralTransformFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<GeneralTransform>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGeometry, 4195498121, 2765, 16763, 182, 45, 92, 161, 191, 77, 252, 14);
RT_INTERFACE!{interface IGeometry(IGeometryVtbl): IInspectable(IInspectableVtbl) [IID_IGeometry] {
    fn get_Transform(&self, out: *mut *mut Transform) -> HRESULT,
    fn put_Transform(&self, value: *mut Transform) -> HRESULT,
    fn get_Bounds(&self, out: *mut ::rt::gen::windows::foundation::Rect) -> HRESULT
}}
impl IGeometry {
    #[inline] pub unsafe fn get_transform(&self) -> Result<ComPtr<Transform>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Transform)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_transform(&self, value: &Transform) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Transform)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_bounds(&self) -> Result<::rt::gen::windows::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Bounds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGeometryStatics, 2054204044, 2822, 18015, 182, 55, 154, 71, 229, 167, 1, 17);
RT_INTERFACE!{static interface IGeometryStatics(IGeometryStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGeometryStatics] {
    fn get_Empty(&self, out: *mut *mut Geometry) -> HRESULT,
    fn get_StandardFlatteningTolerance(&self, out: *mut f64) -> HRESULT,
    fn get_TransformProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IGeometryStatics {
    #[inline] pub unsafe fn get_empty(&self) -> Result<ComPtr<Geometry>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Empty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_standard_flattening_tolerance(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StandardFlatteningTolerance)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transform_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransformProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class Geometry: IGeometry}
impl RtActivatable<IGeometryStatics> for Geometry {}
impl Geometry {
    #[inline] pub fn get_empty() -> Result<ComPtr<Geometry>> { unsafe {
        <Self as RtActivatable<IGeometryStatics>>::get_activation_factory().get_empty()
    }}
    #[inline] pub fn get_standard_flattening_tolerance() -> Result<f64> { unsafe {
        <Self as RtActivatable<IGeometryStatics>>::get_activation_factory().get_standard_flattening_tolerance()
    }}
    #[inline] pub fn get_transform_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGeometryStatics>>::get_activation_factory().get_transform_property()
    }}
}
DEFINE_CLSID!(Geometry(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,71,101,111,109,101,116,114,121,0]) [CLSID_Geometry]);
DEFINE_IID!(IID_IGeometryFactory, 4133334819, 54781, 17145, 179, 42, 146, 156, 90, 75, 84, 225);
RT_INTERFACE!{interface IGeometryFactory(IGeometryFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGeometryFactory] {
    
}}
DEFINE_IID!(IID_IImageSource, 1937699593, 59969, 19862, 167, 28, 152, 233, 142, 252, 171, 7);
RT_INTERFACE!{interface IImageSource(IImageSourceVtbl): IInspectable(IInspectableVtbl) [IID_IImageSource] {
    
}}
DEFINE_IID!(IID_IImageSourceFactory, 696172545, 9536, 20058, 171, 102, 136, 3, 93, 211, 221, 181);
RT_INTERFACE!{interface IImageSourceFactory(IImageSourceFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IImageSourceFactory] {
    
}}
RT_CLASS!{class ImageSource: IImageSource}
DEFINE_IID!(IID_IPathSegment, 4244271567, 40163, 18255, 129, 87, 16, 182, 67, 90, 97, 107);
RT_INTERFACE!{interface IPathSegment(IPathSegmentVtbl): IInspectable(IInspectableVtbl) [IID_IPathSegment] {
    
}}
DEFINE_IID!(IID_IPathSegmentFactory, 706480814, 60621, 17508, 161, 72, 111, 253, 179, 170, 40, 31);
RT_INTERFACE!{interface IPathSegmentFactory(IPathSegmentFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPathSegmentFactory] {
    
}}
RT_CLASS!{class PathSegment: IPathSegment}
DEFINE_IID!(IID_IProjection, 3007591767, 32569, 19716, 168, 156, 132, 67, 56, 202, 200, 151);
RT_INTERFACE!{interface IProjection(IProjectionVtbl): IInspectable(IInspectableVtbl) [IID_IProjection] {
    
}}
RT_CLASS!{class Projection: IProjection}
DEFINE_IID!(IID_IProjectionFactory, 3304234155, 24749, 20260, 189, 39, 157, 105, 195, 18, 124, 154);
RT_INTERFACE!{interface IProjectionFactory(IProjectionFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IProjectionFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut Projection) -> HRESULT
}}
impl IProjectionFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<Projection>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRateChangedRoutedEventArgs, 2417404527, 15528, 19584, 142, 47, 136, 81, 166, 143, 19, 31);
RT_INTERFACE!{interface IRateChangedRoutedEventArgs(IRateChangedRoutedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IRateChangedRoutedEventArgs] {
    
}}
RT_CLASS!{class RateChangedRoutedEventArgs: IRateChangedRoutedEventArgs}
impl RtActivatable<IActivationFactory> for RateChangedRoutedEventArgs {}
DEFINE_CLSID!(RateChangedRoutedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,82,97,116,101,67,104,97,110,103,101,100,82,111,117,116,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_RateChangedRoutedEventArgs]);
DEFINE_IID!(IID_ITimelineMarker, 2794385453, 17850, 20048, 140, 173, 170, 234, 58, 34, 122, 245);
RT_INTERFACE!{interface ITimelineMarker(ITimelineMarkerVtbl): IInspectable(IInspectableVtbl) [IID_ITimelineMarker] {
    fn get_Time(&self, out: *mut ::rt::gen::windows::foundation::TimeSpan) -> HRESULT,
    fn put_Time(&self, value: ::rt::gen::windows::foundation::TimeSpan) -> HRESULT,
    fn get_Type(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Type(&self, value: HSTRING) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Text(&self, value: HSTRING) -> HRESULT
}}
impl ITimelineMarker {
    #[inline] pub unsafe fn get_time(&self) -> Result<::rt::gen::windows::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Time)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_time(&self, value: ::rt::gen::windows::foundation::TimeSpan) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Time)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_type(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Type)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_type(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Type)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Text)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Text)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITimelineMarkerStatics, 3299799238, 5795, 18507, 135, 245, 101, 40, 184, 240, 74, 71);
RT_INTERFACE!{static interface ITimelineMarkerStatics(ITimelineMarkerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ITimelineMarkerStatics] {
    fn get_TimeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TypeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ITimelineMarkerStatics {
    #[inline] pub unsafe fn get_time_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TimeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_type_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TypeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class TimelineMarker: ITimelineMarker}
impl RtActivatable<ITimelineMarkerStatics> for TimelineMarker {}
impl RtActivatable<IActivationFactory> for TimelineMarker {}
impl TimelineMarker {
    #[inline] pub fn get_time_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITimelineMarkerStatics>>::get_activation_factory().get_time_property()
    }}
    #[inline] pub fn get_type_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITimelineMarkerStatics>>::get_activation_factory().get_type_property()
    }}
    #[inline] pub fn get_text_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITimelineMarkerStatics>>::get_activation_factory().get_text_property()
    }}
}
DEFINE_CLSID!(TimelineMarker(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,84,105,109,101,108,105,110,101,77,97,114,107,101,114,0]) [CLSID_TimelineMarker]);
DEFINE_IID!(IID_ITimelineMarkerRoutedEventArgs, 2084257523, 11400, 19868, 153, 182, 70, 205, 189, 72, 212, 193);
RT_INTERFACE!{interface ITimelineMarkerRoutedEventArgs(ITimelineMarkerRoutedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ITimelineMarkerRoutedEventArgs] {
    fn get_Marker(&self, out: *mut *mut TimelineMarker) -> HRESULT,
    fn put_Marker(&self, value: *mut TimelineMarker) -> HRESULT
}}
impl ITimelineMarkerRoutedEventArgs {
    #[inline] pub unsafe fn get_marker(&self) -> Result<ComPtr<TimelineMarker>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Marker)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_marker(&self, value: &TimelineMarker) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Marker)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class TimelineMarkerRoutedEventArgs: ITimelineMarkerRoutedEventArgs}
impl RtActivatable<IActivationFactory> for TimelineMarkerRoutedEventArgs {}
DEFINE_CLSID!(TimelineMarkerRoutedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,84,105,109,101,108,105,110,101,77,97,114,107,101,114,82,111,117,116,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_TimelineMarkerRoutedEventArgs]);
DEFINE_IID!(IID_IXamlLight, 214170655, 45863, 18968, 150, 72, 124, 132, 219, 38, 206, 34);
RT_INTERFACE!{interface IXamlLight(IXamlLightVtbl): IInspectable(IInspectableVtbl) [IID_IXamlLight] {
    
}}
DEFINE_IID!(IID_IXamlLightOverrides, 2086835911, 371, 18657, 183, 61, 127, 162, 22, 169, 172, 40);
RT_INTERFACE!{interface IXamlLightOverrides(IXamlLightOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IXamlLightOverrides] {
    fn GetId(&self, out: *mut HSTRING) -> HRESULT,
    fn OnConnected(&self, newElement: *mut super::UIElement) -> HRESULT,
    fn OnDisconnected(&self, oldElement: *mut super::UIElement) -> HRESULT
}}
impl IXamlLightOverrides {
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_connected(&self, newElement: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).OnConnected)(self as *const _ as *mut _, newElement as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_disconnected(&self, oldElement: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).OnDisconnected)(self as *const _ as *mut _, oldElement as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IXamlLightProtected, 1590632971, 4690, 17360, 151, 41, 110, 166, 146, 4, 104, 56);
RT_INTERFACE!{interface IXamlLightProtected(IXamlLightProtectedVtbl): IInspectable(IInspectableVtbl) [IID_IXamlLightProtected] {
    #[cfg(feature="windows-ui")] fn get_CompositionLight(&self, out: *mut *mut super::super::composition::CompositionLight) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_CompositionLight(&self, value: *mut super::super::composition::CompositionLight) -> HRESULT
}}
impl IXamlLightProtected {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_composition_light(&self) -> Result<ComPtr<super::super::composition::CompositionLight>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CompositionLight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_composition_light(&self, value: &super::super::composition::CompositionLight) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CompositionLight)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class XamlLight: IXamlLight}
impl RtActivatable<IXamlLightStatics> for XamlLight {}
impl XamlLight {
    #[inline] pub fn add_target_element(lightId: &HStringArg, element: &super::UIElement) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlLightStatics>>::get_activation_factory().add_target_element(lightId, element)
    }}
    #[inline] pub fn remove_target_element(lightId: &HStringArg, element: &super::UIElement) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlLightStatics>>::get_activation_factory().remove_target_element(lightId, element)
    }}
    #[inline] pub fn add_target_brush(lightId: &HStringArg, brush: &Brush) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlLightStatics>>::get_activation_factory().add_target_brush(lightId, brush)
    }}
    #[inline] pub fn remove_target_brush(lightId: &HStringArg, brush: &Brush) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlLightStatics>>::get_activation_factory().remove_target_brush(lightId, brush)
    }}
}
DEFINE_CLSID!(XamlLight(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,88,97,109,108,76,105,103,104,116,0]) [CLSID_XamlLight]);
DEFINE_IID!(IID_IXamlLightStatics, 3052051817, 46344, 20124, 189, 39, 107, 4, 75, 95, 120, 160);
RT_INTERFACE!{static interface IXamlLightStatics(IXamlLightStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IXamlLightStatics] {
    fn AddTargetElement(&self, lightId: HSTRING, element: *mut super::UIElement) -> HRESULT,
    fn RemoveTargetElement(&self, lightId: HSTRING, element: *mut super::UIElement) -> HRESULT,
    fn AddTargetBrush(&self, lightId: HSTRING, brush: *mut Brush) -> HRESULT,
    fn RemoveTargetBrush(&self, lightId: HSTRING, brush: *mut Brush) -> HRESULT
}}
impl IXamlLightStatics {
    #[inline] pub unsafe fn add_target_element(&self, lightId: &HStringArg, element: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).AddTargetElement)(self as *const _ as *mut _, lightId.get(), element as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_target_element(&self, lightId: &HStringArg, element: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).RemoveTargetElement)(self as *const _ as *mut _, lightId.get(), element as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_target_brush(&self, lightId: &HStringArg, brush: &Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).AddTargetBrush)(self as *const _ as *mut _, lightId.get(), brush as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_target_brush(&self, lightId: &HStringArg, brush: &Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).RemoveTargetBrush)(self as *const _ as *mut _, lightId.get(), brush as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IXamlLightFactory, 2279528296, 12373, 17336, 142, 246, 121, 141, 196, 194, 50, 154);
RT_INTERFACE!{interface IXamlLightFactory(IXamlLightFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IXamlLightFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut XamlLight) -> HRESULT
}}
impl IXamlLightFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<XamlLight>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBitmapCache, 2042765726, 17618, 17936, 151, 53, 155, 236, 131, 128, 158, 207);
RT_INTERFACE!{interface IBitmapCache(IBitmapCacheVtbl): IInspectable(IInspectableVtbl) [IID_IBitmapCache] {
    
}}
RT_CLASS!{class BitmapCache: IBitmapCache}
impl RtActivatable<IActivationFactory> for BitmapCache {}
DEFINE_CLSID!(BitmapCache(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,66,105,116,109,97,112,67,97,99,104,101,0]) [CLSID_BitmapCache]);
DEFINE_IID!(IID_IMatrix3DProjection, 1862525257, 49097, 19457, 181, 120, 80, 51, 140, 236, 151, 252);
RT_INTERFACE!{interface IMatrix3DProjection(IMatrix3DProjectionVtbl): IInspectable(IInspectableVtbl) [IID_IMatrix3DProjection] {
    fn get_ProjectionMatrix(&self, out: *mut media3d::Matrix3D) -> HRESULT,
    fn put_ProjectionMatrix(&self, value: media3d::Matrix3D) -> HRESULT
}}
impl IMatrix3DProjection {
    #[inline] pub unsafe fn get_projection_matrix(&self) -> Result<media3d::Matrix3D> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ProjectionMatrix)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_projection_matrix(&self, value: media3d::Matrix3D) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ProjectionMatrix)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMatrix3DProjectionStatics, 2929547413, 16876, 20023, 171, 170, 105, 244, 29, 47, 135, 107);
RT_INTERFACE!{static interface IMatrix3DProjectionStatics(IMatrix3DProjectionStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMatrix3DProjectionStatics] {
    fn get_ProjectionMatrixProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IMatrix3DProjectionStatics {
    #[inline] pub unsafe fn get_projection_matrix_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProjectionMatrixProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class Matrix3DProjection: IMatrix3DProjection}
impl RtActivatable<IMatrix3DProjectionStatics> for Matrix3DProjection {}
impl RtActivatable<IActivationFactory> for Matrix3DProjection {}
impl Matrix3DProjection {
    #[inline] pub fn get_projection_matrix_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMatrix3DProjectionStatics>>::get_activation_factory().get_projection_matrix_property()
    }}
}
DEFINE_CLSID!(Matrix3DProjection(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,77,97,116,114,105,120,51,68,80,114,111,106,101,99,116,105,111,110,0]) [CLSID_Matrix3DProjection]);
DEFINE_IID!(IID_IPlaneProjection, 3875023866, 26406, 18074, 178, 89, 165, 24, 131, 71, 202, 143);
RT_INTERFACE!{interface IPlaneProjection(IPlaneProjectionVtbl): IInspectable(IInspectableVtbl) [IID_IPlaneProjection] {
    fn get_LocalOffsetX(&self, out: *mut f64) -> HRESULT,
    fn put_LocalOffsetX(&self, value: f64) -> HRESULT,
    fn get_LocalOffsetY(&self, out: *mut f64) -> HRESULT,
    fn put_LocalOffsetY(&self, value: f64) -> HRESULT,
    fn get_LocalOffsetZ(&self, out: *mut f64) -> HRESULT,
    fn put_LocalOffsetZ(&self, value: f64) -> HRESULT,
    fn get_RotationX(&self, out: *mut f64) -> HRESULT,
    fn put_RotationX(&self, value: f64) -> HRESULT,
    fn get_RotationY(&self, out: *mut f64) -> HRESULT,
    fn put_RotationY(&self, value: f64) -> HRESULT,
    fn get_RotationZ(&self, out: *mut f64) -> HRESULT,
    fn put_RotationZ(&self, value: f64) -> HRESULT,
    fn get_CenterOfRotationX(&self, out: *mut f64) -> HRESULT,
    fn put_CenterOfRotationX(&self, value: f64) -> HRESULT,
    fn get_CenterOfRotationY(&self, out: *mut f64) -> HRESULT,
    fn put_CenterOfRotationY(&self, value: f64) -> HRESULT,
    fn get_CenterOfRotationZ(&self, out: *mut f64) -> HRESULT,
    fn put_CenterOfRotationZ(&self, value: f64) -> HRESULT,
    fn get_GlobalOffsetX(&self, out: *mut f64) -> HRESULT,
    fn put_GlobalOffsetX(&self, value: f64) -> HRESULT,
    fn get_GlobalOffsetY(&self, out: *mut f64) -> HRESULT,
    fn put_GlobalOffsetY(&self, value: f64) -> HRESULT,
    fn get_GlobalOffsetZ(&self, out: *mut f64) -> HRESULT,
    fn put_GlobalOffsetZ(&self, value: f64) -> HRESULT,
    fn get_ProjectionMatrix(&self, out: *mut media3d::Matrix3D) -> HRESULT
}}
impl IPlaneProjection {
    #[inline] pub unsafe fn get_local_offset_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LocalOffsetX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_local_offset_x(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LocalOffsetX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_local_offset_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LocalOffsetY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_local_offset_y(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LocalOffsetY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_local_offset_z(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LocalOffsetZ)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_local_offset_z(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LocalOffsetZ)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rotation_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RotationX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_rotation_x(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RotationX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rotation_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RotationY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_rotation_y(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RotationY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rotation_z(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RotationZ)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_rotation_z(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RotationZ)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_center_of_rotation_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CenterOfRotationX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_center_of_rotation_x(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CenterOfRotationX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_center_of_rotation_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CenterOfRotationY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_center_of_rotation_y(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CenterOfRotationY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_center_of_rotation_z(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CenterOfRotationZ)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_center_of_rotation_z(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CenterOfRotationZ)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_global_offset_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_GlobalOffsetX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_global_offset_x(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_GlobalOffsetX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_global_offset_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_GlobalOffsetY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_global_offset_y(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_GlobalOffsetY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_global_offset_z(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_GlobalOffsetZ)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_global_offset_z(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_GlobalOffsetZ)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_projection_matrix(&self) -> Result<media3d::Matrix3D> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ProjectionMatrix)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPlaneProjectionStatics, 2912001127, 15324, 18517, 137, 105, 209, 249, 163, 173, 194, 125);
RT_INTERFACE!{static interface IPlaneProjectionStatics(IPlaneProjectionStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPlaneProjectionStatics] {
    fn get_LocalOffsetXProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_LocalOffsetYProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_LocalOffsetZProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_RotationXProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_RotationYProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_RotationZProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CenterOfRotationXProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CenterOfRotationYProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CenterOfRotationZProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_GlobalOffsetXProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_GlobalOffsetYProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_GlobalOffsetZProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ProjectionMatrixProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IPlaneProjectionStatics {
    #[inline] pub unsafe fn get_local_offset_xproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LocalOffsetXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_local_offset_yproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LocalOffsetYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_local_offset_zproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LocalOffsetZProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rotation_xproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RotationXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rotation_yproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RotationYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rotation_zproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RotationZProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_center_of_rotation_xproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CenterOfRotationXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_center_of_rotation_yproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CenterOfRotationYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_center_of_rotation_zproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CenterOfRotationZProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_global_offset_xproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GlobalOffsetXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_global_offset_yproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GlobalOffsetYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_global_offset_zproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GlobalOffsetZProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_projection_matrix_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProjectionMatrixProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PlaneProjection: IPlaneProjection}
impl RtActivatable<IPlaneProjectionStatics> for PlaneProjection {}
impl RtActivatable<IActivationFactory> for PlaneProjection {}
impl PlaneProjection {
    #[inline] pub fn get_local_offset_xproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPlaneProjectionStatics>>::get_activation_factory().get_local_offset_xproperty()
    }}
    #[inline] pub fn get_local_offset_yproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPlaneProjectionStatics>>::get_activation_factory().get_local_offset_yproperty()
    }}
    #[inline] pub fn get_local_offset_zproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPlaneProjectionStatics>>::get_activation_factory().get_local_offset_zproperty()
    }}
    #[inline] pub fn get_rotation_xproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPlaneProjectionStatics>>::get_activation_factory().get_rotation_xproperty()
    }}
    #[inline] pub fn get_rotation_yproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPlaneProjectionStatics>>::get_activation_factory().get_rotation_yproperty()
    }}
    #[inline] pub fn get_rotation_zproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPlaneProjectionStatics>>::get_activation_factory().get_rotation_zproperty()
    }}
    #[inline] pub fn get_center_of_rotation_xproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPlaneProjectionStatics>>::get_activation_factory().get_center_of_rotation_xproperty()
    }}
    #[inline] pub fn get_center_of_rotation_yproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPlaneProjectionStatics>>::get_activation_factory().get_center_of_rotation_yproperty()
    }}
    #[inline] pub fn get_center_of_rotation_zproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPlaneProjectionStatics>>::get_activation_factory().get_center_of_rotation_zproperty()
    }}
    #[inline] pub fn get_global_offset_xproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPlaneProjectionStatics>>::get_activation_factory().get_global_offset_xproperty()
    }}
    #[inline] pub fn get_global_offset_yproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPlaneProjectionStatics>>::get_activation_factory().get_global_offset_yproperty()
    }}
    #[inline] pub fn get_global_offset_zproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPlaneProjectionStatics>>::get_activation_factory().get_global_offset_zproperty()
    }}
    #[inline] pub fn get_projection_matrix_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPlaneProjectionStatics>>::get_activation_factory().get_projection_matrix_property()
    }}
}
DEFINE_CLSID!(PlaneProjection(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,80,108,97,110,101,80,114,111,106,101,99,116,105,111,110,0]) [CLSID_PlaneProjection]);
DEFINE_IID!(IID_IRectangleGeometry, 2723815256, 50549, 16790, 145, 207, 159, 223, 177, 4, 69, 195);
RT_INTERFACE!{interface IRectangleGeometry(IRectangleGeometryVtbl): IInspectable(IInspectableVtbl) [IID_IRectangleGeometry] {
    fn get_Rect(&self, out: *mut ::rt::gen::windows::foundation::Rect) -> HRESULT,
    fn put_Rect(&self, value: ::rt::gen::windows::foundation::Rect) -> HRESULT
}}
impl IRectangleGeometry {
    #[inline] pub unsafe fn get_rect(&self) -> Result<::rt::gen::windows::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Rect)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_rect(&self, value: ::rt::gen::windows::foundation::Rect) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Rect)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class RectangleGeometry: IRectangleGeometry}
impl RtActivatable<IRectangleGeometryStatics> for RectangleGeometry {}
impl RtActivatable<IActivationFactory> for RectangleGeometry {}
impl RectangleGeometry {
    #[inline] pub fn get_rect_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRectangleGeometryStatics>>::get_activation_factory().get_rect_property()
    }}
}
DEFINE_CLSID!(RectangleGeometry(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,82,101,99,116,97,110,103,108,101,71,101,111,109,101,116,114,121,0]) [CLSID_RectangleGeometry]);
DEFINE_IID!(IID_IRectangleGeometryStatics, 931106234, 30978, 18659, 131, 190, 124, 128, 2, 166, 101, 60);
RT_INTERFACE!{static interface IRectangleGeometryStatics(IRectangleGeometryStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRectangleGeometryStatics] {
    fn get_RectProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IRectangleGeometryStatics {
    #[inline] pub unsafe fn get_rect_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RectProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISolidColorBrush, 2642741328, 26355, 18655, 154, 143, 130, 75, 213, 224, 112, 175);
RT_INTERFACE!{interface ISolidColorBrush(ISolidColorBrushVtbl): IInspectable(IInspectableVtbl) [IID_ISolidColorBrush] {
    #[cfg(feature="windows-ui")] fn get_Color(&self, out: *mut super::super::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_Color(&self, value: super::super::Color) -> HRESULT
}}
impl ISolidColorBrush {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_color(&self) -> Result<super::super::Color> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Color)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_color(&self, value: super::super::Color) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Color)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISolidColorBrushStatics, 3785776890, 11043, 16826, 185, 186, 112, 148, 236, 142, 78, 159);
RT_INTERFACE!{static interface ISolidColorBrushStatics(ISolidColorBrushStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISolidColorBrushStatics] {
    fn get_ColorProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ISolidColorBrushStatics {
    #[inline] pub unsafe fn get_color_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ColorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISolidColorBrushFactory, 3644182028, 34549, 19878, 138, 39, 177, 97, 158, 247, 249, 43);
RT_INTERFACE!{static interface ISolidColorBrushFactory(ISolidColorBrushFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISolidColorBrushFactory] {
    #[cfg(feature="windows-ui")] fn CreateInstanceWithColor(&self, color: super::super::Color, out: *mut *mut SolidColorBrush) -> HRESULT
}}
impl ISolidColorBrushFactory {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn create_instance_with_color(&self, color: super::super::Color) -> Result<ComPtr<SolidColorBrush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithColor)(self as *const _ as *mut _, color, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SolidColorBrush: ISolidColorBrush}
impl RtActivatable<ISolidColorBrushFactory> for SolidColorBrush {}
impl RtActivatable<ISolidColorBrushStatics> for SolidColorBrush {}
impl RtActivatable<IActivationFactory> for SolidColorBrush {}
impl SolidColorBrush {
    #[cfg(feature="windows-ui")] #[inline] pub fn create_instance_with_color(color: super::super::Color) -> Result<ComPtr<SolidColorBrush>> { unsafe {
        <Self as RtActivatable<ISolidColorBrushFactory>>::get_activation_factory().create_instance_with_color(color)
    }}
    #[inline] pub fn get_color_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISolidColorBrushStatics>>::get_activation_factory().get_color_property()
    }}
}
DEFINE_CLSID!(SolidColorBrush(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,83,111,108,105,100,67,111,108,111,114,66,114,117,115,104,0]) [CLSID_SolidColorBrush]);
DEFINE_IID!(IID_ITransform, 1308049528, 49110, 20177, 150, 130, 210, 253, 139, 242, 254, 111);
RT_INTERFACE!{interface ITransform(ITransformVtbl): IInspectable(IInspectableVtbl) [IID_ITransform] {
    
}}
RT_CLASS!{class Transform: ITransform}
DEFINE_IID!(IID_ITransformFactory, 445995622, 31988, 17184, 180, 22, 97, 129, 25, 47, 204, 109);
RT_INTERFACE!{interface ITransformFactory(ITransformFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ITransformFactory] {
    
}}
DEFINE_IID!(IID_ICompositeTransform, 3366205531, 62026, 18177, 162, 101, 167, 136, 70, 241, 66, 185);
RT_INTERFACE!{interface ICompositeTransform(ICompositeTransformVtbl): IInspectable(IInspectableVtbl) [IID_ICompositeTransform] {
    fn get_CenterX(&self, out: *mut f64) -> HRESULT,
    fn put_CenterX(&self, value: f64) -> HRESULT,
    fn get_CenterY(&self, out: *mut f64) -> HRESULT,
    fn put_CenterY(&self, value: f64) -> HRESULT,
    fn get_ScaleX(&self, out: *mut f64) -> HRESULT,
    fn put_ScaleX(&self, value: f64) -> HRESULT,
    fn get_ScaleY(&self, out: *mut f64) -> HRESULT,
    fn put_ScaleY(&self, value: f64) -> HRESULT,
    fn get_SkewX(&self, out: *mut f64) -> HRESULT,
    fn put_SkewX(&self, value: f64) -> HRESULT,
    fn get_SkewY(&self, out: *mut f64) -> HRESULT,
    fn put_SkewY(&self, value: f64) -> HRESULT,
    fn get_Rotation(&self, out: *mut f64) -> HRESULT,
    fn put_Rotation(&self, value: f64) -> HRESULT,
    fn get_TranslateX(&self, out: *mut f64) -> HRESULT,
    fn put_TranslateX(&self, value: f64) -> HRESULT,
    fn get_TranslateY(&self, out: *mut f64) -> HRESULT,
    fn put_TranslateY(&self, value: f64) -> HRESULT
}}
impl ICompositeTransform {
    #[inline] pub unsafe fn get_center_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CenterX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_center_x(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CenterX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_center_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CenterY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_center_y(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CenterY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scale_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScaleX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_scale_x(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ScaleX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scale_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScaleY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_scale_y(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ScaleY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_skew_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SkewX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_skew_x(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SkewX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_skew_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SkewY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_skew_y(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SkewY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rotation(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Rotation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_rotation(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Rotation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_translate_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TranslateX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_translate_x(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TranslateX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_translate_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TranslateY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_translate_y(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TranslateY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICompositeTransformStatics, 790170632, 33382, 18799, 150, 83, 161, 139, 212, 248, 54, 170);
RT_INTERFACE!{static interface ICompositeTransformStatics(ICompositeTransformStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICompositeTransformStatics] {
    fn get_CenterXProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CenterYProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ScaleXProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ScaleYProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SkewXProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SkewYProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_RotationProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TranslateXProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_TranslateYProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ICompositeTransformStatics {
    #[inline] pub unsafe fn get_center_xproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CenterXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_center_yproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CenterYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scale_xproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ScaleXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scale_yproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ScaleYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_skew_xproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SkewXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_skew_yproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SkewYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rotation_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RotationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_translate_xproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TranslateXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_translate_yproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TranslateYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class CompositeTransform: ICompositeTransform}
impl RtActivatable<ICompositeTransformStatics> for CompositeTransform {}
impl RtActivatable<IActivationFactory> for CompositeTransform {}
impl CompositeTransform {
    #[inline] pub fn get_center_xproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICompositeTransformStatics>>::get_activation_factory().get_center_xproperty()
    }}
    #[inline] pub fn get_center_yproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICompositeTransformStatics>>::get_activation_factory().get_center_yproperty()
    }}
    #[inline] pub fn get_scale_xproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICompositeTransformStatics>>::get_activation_factory().get_scale_xproperty()
    }}
    #[inline] pub fn get_scale_yproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICompositeTransformStatics>>::get_activation_factory().get_scale_yproperty()
    }}
    #[inline] pub fn get_skew_xproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICompositeTransformStatics>>::get_activation_factory().get_skew_xproperty()
    }}
    #[inline] pub fn get_skew_yproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICompositeTransformStatics>>::get_activation_factory().get_skew_yproperty()
    }}
    #[inline] pub fn get_rotation_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICompositeTransformStatics>>::get_activation_factory().get_rotation_property()
    }}
    #[inline] pub fn get_translate_xproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICompositeTransformStatics>>::get_activation_factory().get_translate_xproperty()
    }}
    #[inline] pub fn get_translate_yproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICompositeTransformStatics>>::get_activation_factory().get_translate_yproperty()
    }}
}
DEFINE_CLSID!(CompositeTransform(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,67,111,109,112,111,115,105,116,101,84,114,97,110,115,102,111,114,109,0]) [CLSID_CompositeTransform]);
DEFINE_IID!(IID_IMatrixTransform, 3992835409, 24557, 17916, 174, 98, 146, 164, 182, 207, 151, 7);
RT_INTERFACE!{interface IMatrixTransform(IMatrixTransformVtbl): IInspectable(IInspectableVtbl) [IID_IMatrixTransform] {
    fn get_Matrix(&self, out: *mut Matrix) -> HRESULT,
    fn put_Matrix(&self, value: Matrix) -> HRESULT
}}
impl IMatrixTransform {
    #[inline] pub unsafe fn get_matrix(&self) -> Result<Matrix> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Matrix)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_matrix(&self, value: Matrix) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Matrix)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMatrixTransformStatics, 1138765383, 5560, 18264, 187, 151, 125, 82, 66, 10, 204, 91);
RT_INTERFACE!{static interface IMatrixTransformStatics(IMatrixTransformStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMatrixTransformStatics] {
    fn get_MatrixProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IMatrixTransformStatics {
    #[inline] pub unsafe fn get_matrix_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MatrixProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class MatrixTransform: IMatrixTransform}
impl RtActivatable<IMatrixTransformStatics> for MatrixTransform {}
impl RtActivatable<IActivationFactory> for MatrixTransform {}
impl MatrixTransform {
    #[inline] pub fn get_matrix_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IMatrixTransformStatics>>::get_activation_factory().get_matrix_property()
    }}
}
DEFINE_CLSID!(MatrixTransform(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,77,97,116,114,105,120,84,114,97,110,115,102,111,114,109,0]) [CLSID_MatrixTransform]);
DEFINE_IID!(IID_IRotateTransform, 1754180025, 7758, 17814, 134, 227, 66, 139, 39, 51, 79, 175);
RT_INTERFACE!{interface IRotateTransform(IRotateTransformVtbl): IInspectable(IInspectableVtbl) [IID_IRotateTransform] {
    fn get_CenterX(&self, out: *mut f64) -> HRESULT,
    fn put_CenterX(&self, value: f64) -> HRESULT,
    fn get_CenterY(&self, out: *mut f64) -> HRESULT,
    fn put_CenterY(&self, value: f64) -> HRESULT,
    fn get_Angle(&self, out: *mut f64) -> HRESULT,
    fn put_Angle(&self, value: f64) -> HRESULT
}}
impl IRotateTransform {
    #[inline] pub unsafe fn get_center_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CenterX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_center_x(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CenterX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_center_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CenterY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_center_y(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CenterY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_angle(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Angle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_angle(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Angle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRotateTransformStatics, 2704403338, 20899, 16822, 185, 211, 161, 14, 66, 144, 84, 171);
RT_INTERFACE!{static interface IRotateTransformStatics(IRotateTransformStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRotateTransformStatics] {
    fn get_CenterXProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CenterYProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_AngleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IRotateTransformStatics {
    #[inline] pub unsafe fn get_center_xproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CenterXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_center_yproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CenterYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_angle_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AngleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class RotateTransform: IRotateTransform}
impl RtActivatable<IRotateTransformStatics> for RotateTransform {}
impl RtActivatable<IActivationFactory> for RotateTransform {}
impl RotateTransform {
    #[inline] pub fn get_center_xproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRotateTransformStatics>>::get_activation_factory().get_center_xproperty()
    }}
    #[inline] pub fn get_center_yproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRotateTransformStatics>>::get_activation_factory().get_center_yproperty()
    }}
    #[inline] pub fn get_angle_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRotateTransformStatics>>::get_activation_factory().get_angle_property()
    }}
}
DEFINE_CLSID!(RotateTransform(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,82,111,116,97,116,101,84,114,97,110,115,102,111,114,109,0]) [CLSID_RotateTransform]);
DEFINE_IID!(IID_IScaleTransform, 3983012237, 37742, 17323, 146, 154, 233, 205, 10, 81, 30, 82);
RT_INTERFACE!{interface IScaleTransform(IScaleTransformVtbl): IInspectable(IInspectableVtbl) [IID_IScaleTransform] {
    fn get_CenterX(&self, out: *mut f64) -> HRESULT,
    fn put_CenterX(&self, value: f64) -> HRESULT,
    fn get_CenterY(&self, out: *mut f64) -> HRESULT,
    fn put_CenterY(&self, value: f64) -> HRESULT,
    fn get_ScaleX(&self, out: *mut f64) -> HRESULT,
    fn put_ScaleX(&self, value: f64) -> HRESULT,
    fn get_ScaleY(&self, out: *mut f64) -> HRESULT,
    fn put_ScaleY(&self, value: f64) -> HRESULT
}}
impl IScaleTransform {
    #[inline] pub unsafe fn get_center_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CenterX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_center_x(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CenterX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_center_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CenterY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_center_y(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CenterY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scale_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScaleX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_scale_x(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ScaleX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scale_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScaleY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_scale_y(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ScaleY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IScaleTransformStatics, 2643736308, 16551, 18141, 151, 90, 7, 211, 55, 205, 133, 46);
RT_INTERFACE!{static interface IScaleTransformStatics(IScaleTransformStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IScaleTransformStatics] {
    fn get_CenterXProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CenterYProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ScaleXProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ScaleYProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IScaleTransformStatics {
    #[inline] pub unsafe fn get_center_xproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CenterXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_center_yproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CenterYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scale_xproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ScaleXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scale_yproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ScaleYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ScaleTransform: IScaleTransform}
impl RtActivatable<IScaleTransformStatics> for ScaleTransform {}
impl RtActivatable<IActivationFactory> for ScaleTransform {}
impl ScaleTransform {
    #[inline] pub fn get_center_xproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScaleTransformStatics>>::get_activation_factory().get_center_xproperty()
    }}
    #[inline] pub fn get_center_yproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScaleTransformStatics>>::get_activation_factory().get_center_yproperty()
    }}
    #[inline] pub fn get_scale_xproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScaleTransformStatics>>::get_activation_factory().get_scale_xproperty()
    }}
    #[inline] pub fn get_scale_yproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IScaleTransformStatics>>::get_activation_factory().get_scale_yproperty()
    }}
}
DEFINE_CLSID!(ScaleTransform(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,83,99,97,108,101,84,114,97,110,115,102,111,114,109,0]) [CLSID_ScaleTransform]);
DEFINE_IID!(IID_ISkewTransform, 1317681941, 31247, 17943, 158, 152, 30, 101, 189, 201, 33, 21);
RT_INTERFACE!{interface ISkewTransform(ISkewTransformVtbl): IInspectable(IInspectableVtbl) [IID_ISkewTransform] {
    fn get_CenterX(&self, out: *mut f64) -> HRESULT,
    fn put_CenterX(&self, value: f64) -> HRESULT,
    fn get_CenterY(&self, out: *mut f64) -> HRESULT,
    fn put_CenterY(&self, value: f64) -> HRESULT,
    fn get_AngleX(&self, out: *mut f64) -> HRESULT,
    fn put_AngleX(&self, value: f64) -> HRESULT,
    fn get_AngleY(&self, out: *mut f64) -> HRESULT,
    fn put_AngleY(&self, value: f64) -> HRESULT
}}
impl ISkewTransform {
    #[inline] pub unsafe fn get_center_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CenterX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_center_x(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CenterX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_center_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CenterY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_center_y(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CenterY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_angle_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AngleX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_angle_x(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AngleX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_angle_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AngleY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_angle_y(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AngleY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISkewTransformStatics, 3973127539, 22036, 19249, 182, 175, 190, 174, 16, 16, 86, 36);
RT_INTERFACE!{static interface ISkewTransformStatics(ISkewTransformStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISkewTransformStatics] {
    fn get_CenterXProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_CenterYProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_AngleXProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_AngleYProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ISkewTransformStatics {
    #[inline] pub unsafe fn get_center_xproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CenterXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_center_yproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CenterYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_angle_xproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AngleXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_angle_yproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AngleYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SkewTransform: ISkewTransform}
impl RtActivatable<ISkewTransformStatics> for SkewTransform {}
impl RtActivatable<IActivationFactory> for SkewTransform {}
impl SkewTransform {
    #[inline] pub fn get_center_xproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISkewTransformStatics>>::get_activation_factory().get_center_xproperty()
    }}
    #[inline] pub fn get_center_yproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISkewTransformStatics>>::get_activation_factory().get_center_yproperty()
    }}
    #[inline] pub fn get_angle_xproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISkewTransformStatics>>::get_activation_factory().get_angle_xproperty()
    }}
    #[inline] pub fn get_angle_yproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISkewTransformStatics>>::get_activation_factory().get_angle_yproperty()
    }}
}
DEFINE_CLSID!(SkewTransform(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,83,107,101,119,84,114,97,110,115,102,111,114,109,0]) [CLSID_SkewTransform]);
DEFINE_IID!(IID_ITransformGroup, 1665240268, 36141, 18231, 185, 81, 42, 252, 225, 221, 196, 196);
RT_INTERFACE!{interface ITransformGroup(ITransformGroupVtbl): IInspectable(IInspectableVtbl) [IID_ITransformGroup] {
    fn get_Children(&self, out: *mut *mut TransformCollection) -> HRESULT,
    fn put_Children(&self, value: *mut TransformCollection) -> HRESULT,
    fn get_Value(&self, out: *mut Matrix) -> HRESULT
}}
impl ITransformGroup {
    #[inline] pub unsafe fn get_children(&self) -> Result<ComPtr<TransformCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Children)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_children(&self, value: &TransformCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Children)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_value(&self) -> Result<Matrix> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Value)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITransformGroupStatics, 623980330, 53163, 19236, 151, 19, 91, 222, 173, 25, 41, 192);
RT_INTERFACE!{static interface ITransformGroupStatics(ITransformGroupStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ITransformGroupStatics] {
    fn get_ChildrenProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ITransformGroupStatics {
    #[inline] pub unsafe fn get_children_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ChildrenProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class TransformGroup: ITransformGroup}
impl RtActivatable<ITransformGroupStatics> for TransformGroup {}
impl RtActivatable<IActivationFactory> for TransformGroup {}
impl TransformGroup {
    #[inline] pub fn get_children_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITransformGroupStatics>>::get_activation_factory().get_children_property()
    }}
}
DEFINE_CLSID!(TransformGroup(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,84,114,97,110,115,102,111,114,109,71,114,111,117,112,0]) [CLSID_TransformGroup]);
DEFINE_IID!(IID_ITranslateTransform, 3379925084, 15414, 16937, 129, 123, 23, 143, 100, 192, 225, 19);
RT_INTERFACE!{interface ITranslateTransform(ITranslateTransformVtbl): IInspectable(IInspectableVtbl) [IID_ITranslateTransform] {
    fn get_X(&self, out: *mut f64) -> HRESULT,
    fn put_X(&self, value: f64) -> HRESULT,
    fn get_Y(&self, out: *mut f64) -> HRESULT,
    fn put_Y(&self, value: f64) -> HRESULT
}}
impl ITranslateTransform {
    #[inline] pub unsafe fn get_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_X)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_x(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_X)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Y)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_y(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Y)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITranslateTransformStatics, 4095322769, 57410, 16657, 156, 47, 210, 1, 48, 65, 35, 221);
RT_INTERFACE!{static interface ITranslateTransformStatics(ITranslateTransformStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ITranslateTransformStatics] {
    fn get_XProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_YProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ITranslateTransformStatics {
    #[inline] pub unsafe fn get_xproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_XProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_yproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_YProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class TranslateTransform: ITranslateTransform}
impl RtActivatable<ITranslateTransformStatics> for TranslateTransform {}
impl RtActivatable<IActivationFactory> for TranslateTransform {}
impl TranslateTransform {
    #[inline] pub fn get_xproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITranslateTransformStatics>>::get_activation_factory().get_xproperty()
    }}
    #[inline] pub fn get_yproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITranslateTransformStatics>>::get_activation_factory().get_yproperty()
    }}
}
DEFINE_CLSID!(TranslateTransform(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,84,114,97,110,115,108,97,116,101,84,114,97,110,115,102,111,114,109,0]) [CLSID_TranslateTransform]);
RT_ENUM! { enum AlignmentX: i32 {
    Left (AlignmentX_Left) = 0, Center (AlignmentX_Center) = 1, Right (AlignmentX_Right) = 2,
}}
RT_ENUM! { enum AlignmentY: i32 {
    Top (AlignmentY_Top) = 0, Center (AlignmentY_Center) = 1, Bottom (AlignmentY_Bottom) = 2,
}}
RT_ENUM! { enum LoadedImageSourceLoadStatus: i32 {
    Success (LoadedImageSourceLoadStatus_Success) = 0, NetworkError (LoadedImageSourceLoadStatus_NetworkError) = 1, InvalidFormat (LoadedImageSourceLoadStatus_InvalidFormat) = 2, Other (LoadedImageSourceLoadStatus_Other) = 3,
}}
RT_CLASS!{class GeometryCollection: ::rt::gen::windows::foundation::collections::IVector<Geometry>}
impl RtActivatable<IActivationFactory> for GeometryCollection {}
DEFINE_CLSID!(GeometryCollection(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,71,101,111,109,101,116,114,121,67,111,108,108,101,99,116,105,111,110,0]) [CLSID_GeometryCollection]);
RT_CLASS!{class GradientStopCollection: ::rt::gen::windows::foundation::collections::IVector<GradientStop>}
impl RtActivatable<IActivationFactory> for GradientStopCollection {}
DEFINE_CLSID!(GradientStopCollection(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,71,114,97,100,105,101,110,116,83,116,111,112,67,111,108,108,101,99,116,105,111,110,0]) [CLSID_GradientStopCollection]);
DEFINE_IID!(IID_ILoadedImageSourceLoadCompletedEventArgs, 449186590, 30775, 17545, 179, 229, 208, 213, 173, 10, 86, 196);
RT_INTERFACE!{interface ILoadedImageSourceLoadCompletedEventArgs(ILoadedImageSourceLoadCompletedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ILoadedImageSourceLoadCompletedEventArgs] {
    fn get_Status(&self, out: *mut LoadedImageSourceLoadStatus) -> HRESULT
}}
impl ILoadedImageSourceLoadCompletedEventArgs {
    #[inline] pub unsafe fn get_status(&self) -> Result<LoadedImageSourceLoadStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class LoadedImageSourceLoadCompletedEventArgs: ILoadedImageSourceLoadCompletedEventArgs}
DEFINE_IID!(IID_ILoadedImageSurface, 84706067, 26423, 17850, 133, 49, 51, 9, 79, 235, 239, 85);
RT_INTERFACE!{interface ILoadedImageSurface(ILoadedImageSurfaceVtbl): IInspectable(IInspectableVtbl) [IID_ILoadedImageSurface] {
    fn get_DecodedPhysicalSize(&self, out: *mut ::rt::gen::windows::foundation::Size) -> HRESULT,
    fn get_DecodedSize(&self, out: *mut ::rt::gen::windows::foundation::Size) -> HRESULT,
    fn get_NaturalSize(&self, out: *mut ::rt::gen::windows::foundation::Size) -> HRESULT,
    fn add_LoadCompleted(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<LoadedImageSurface, LoadedImageSourceLoadCompletedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LoadCompleted(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl ILoadedImageSurface {
    #[inline] pub unsafe fn get_decoded_physical_size(&self) -> Result<::rt::gen::windows::foundation::Size> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DecodedPhysicalSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_decoded_size(&self) -> Result<::rt::gen::windows::foundation::Size> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DecodedSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_natural_size(&self) -> Result<::rt::gen::windows::foundation::Size> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NaturalSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_load_completed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<LoadedImageSurface, LoadedImageSourceLoadCompletedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_LoadCompleted)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_load_completed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_LoadCompleted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class LoadedImageSurface: ILoadedImageSurface}
impl RtActivatable<ILoadedImageSurfaceStatics> for LoadedImageSurface {}
impl LoadedImageSurface {
    #[inline] pub fn start_load_from_uri_with_size(uri: &::rt::gen::windows::foundation::Uri, desiredMaxSize: ::rt::gen::windows::foundation::Size) -> Result<ComPtr<LoadedImageSurface>> { unsafe {
        <Self as RtActivatable<ILoadedImageSurfaceStatics>>::get_activation_factory().start_load_from_uri_with_size(uri, desiredMaxSize)
    }}
    #[inline] pub fn start_load_from_uri(uri: &::rt::gen::windows::foundation::Uri) -> Result<ComPtr<LoadedImageSurface>> { unsafe {
        <Self as RtActivatable<ILoadedImageSurfaceStatics>>::get_activation_factory().start_load_from_uri(uri)
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn start_load_from_stream_with_size(stream: &::rt::gen::windows::storage::streams::IRandomAccessStream, desiredMaxSize: ::rt::gen::windows::foundation::Size) -> Result<ComPtr<LoadedImageSurface>> { unsafe {
        <Self as RtActivatable<ILoadedImageSurfaceStatics>>::get_activation_factory().start_load_from_stream_with_size(stream, desiredMaxSize)
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn start_load_from_stream(stream: &::rt::gen::windows::storage::streams::IRandomAccessStream) -> Result<ComPtr<LoadedImageSurface>> { unsafe {
        <Self as RtActivatable<ILoadedImageSurfaceStatics>>::get_activation_factory().start_load_from_stream(stream)
    }}
}
DEFINE_CLSID!(LoadedImageSurface(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,76,111,97,100,101,100,73,109,97,103,101,83,117,114,102,97,99,101,0]) [CLSID_LoadedImageSurface]);
DEFINE_IID!(IID_ILoadedImageSurfaceStatics, 582544886, 33965, 16555, 147, 125, 72, 113, 97, 62, 118, 93);
RT_INTERFACE!{static interface ILoadedImageSurfaceStatics(ILoadedImageSurfaceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ILoadedImageSurfaceStatics] {
    fn StartLoadFromUriWithSize(&self, uri: *mut ::rt::gen::windows::foundation::Uri, desiredMaxSize: ::rt::gen::windows::foundation::Size, out: *mut *mut LoadedImageSurface) -> HRESULT,
    fn StartLoadFromUri(&self, uri: *mut ::rt::gen::windows::foundation::Uri, out: *mut *mut LoadedImageSurface) -> HRESULT,
    #[cfg(feature="windows-storage")] fn StartLoadFromStreamWithSize(&self, stream: *mut ::rt::gen::windows::storage::streams::IRandomAccessStream, desiredMaxSize: ::rt::gen::windows::foundation::Size, out: *mut *mut LoadedImageSurface) -> HRESULT,
    #[cfg(feature="windows-storage")] fn StartLoadFromStream(&self, stream: *mut ::rt::gen::windows::storage::streams::IRandomAccessStream, out: *mut *mut LoadedImageSurface) -> HRESULT
}}
impl ILoadedImageSurfaceStatics {
    #[inline] pub unsafe fn start_load_from_uri_with_size(&self, uri: &::rt::gen::windows::foundation::Uri, desiredMaxSize: ::rt::gen::windows::foundation::Size) -> Result<ComPtr<LoadedImageSurface>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).StartLoadFromUriWithSize)(self as *const _ as *mut _, uri as *const _ as *mut _, desiredMaxSize, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn start_load_from_uri(&self, uri: &::rt::gen::windows::foundation::Uri) -> Result<ComPtr<LoadedImageSurface>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).StartLoadFromUri)(self as *const _ as *mut _, uri as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn start_load_from_stream_with_size(&self, stream: &::rt::gen::windows::storage::streams::IRandomAccessStream, desiredMaxSize: ::rt::gen::windows::foundation::Size) -> Result<ComPtr<LoadedImageSurface>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).StartLoadFromStreamWithSize)(self as *const _ as *mut _, stream as *const _ as *mut _, desiredMaxSize, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn start_load_from_stream(&self, stream: &::rt::gen::windows::storage::streams::IRandomAccessStream) -> Result<ComPtr<LoadedImageSurface>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).StartLoadFromStream)(self as *const _ as *mut _, stream as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PathFigureCollection: ::rt::gen::windows::foundation::collections::IVector<PathFigure>}
impl RtActivatable<IActivationFactory> for PathFigureCollection {}
DEFINE_CLSID!(PathFigureCollection(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,80,97,116,104,70,105,103,117,114,101,67,111,108,108,101,99,116,105,111,110,0]) [CLSID_PathFigureCollection]);
RT_CLASS!{class PathSegmentCollection: ::rt::gen::windows::foundation::collections::IVector<PathSegment>}
impl RtActivatable<IActivationFactory> for PathSegmentCollection {}
DEFINE_CLSID!(PathSegmentCollection(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,80,97,116,104,83,101,103,109,101,110,116,67,111,108,108,101,99,116,105,111,110,0]) [CLSID_PathSegmentCollection]);
DEFINE_IID!(IID_IGradientStop, 1717519614, 11865, 19530, 171, 83, 7, 106, 16, 12, 205, 129);
RT_INTERFACE!{interface IGradientStop(IGradientStopVtbl): IInspectable(IInspectableVtbl) [IID_IGradientStop] {
    #[cfg(not(feature="windows-ui"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Color(&self, out: *mut super::super::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_Color(&self, value: super::super::Color) -> HRESULT,
    fn get_Offset(&self, out: *mut f64) -> HRESULT,
    fn put_Offset(&self, value: f64) -> HRESULT
}}
impl IGradientStop {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_color(&self) -> Result<super::super::Color> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Color)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_color(&self, value: super::super::Color) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Color)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Offset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Offset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGradientStopStatics, 1613393269, 24979, 20453, 142, 130, 199, 198, 246, 254, 186, 253);
RT_INTERFACE!{static interface IGradientStopStatics(IGradientStopStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGradientStopStatics] {
    fn get_ColorProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_OffsetProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IGradientStopStatics {
    #[inline] pub unsafe fn get_color_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ColorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_offset_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class GradientStop: IGradientStop}
impl RtActivatable<IGradientStopStatics> for GradientStop {}
impl RtActivatable<IActivationFactory> for GradientStop {}
impl GradientStop {
    #[inline] pub fn get_color_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGradientStopStatics>>::get_activation_factory().get_color_property()
    }}
    #[inline] pub fn get_offset_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGradientStopStatics>>::get_activation_factory().get_offset_property()
    }}
}
DEFINE_CLSID!(GradientStop(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,71,114,97,100,105,101,110,116,83,116,111,112,0]) [CLSID_GradientStop]);
DEFINE_IID!(IID_IPathFigure, 1570069644, 24489, 19930, 163, 204, 16, 252, 220, 170, 32, 215);
RT_INTERFACE!{interface IPathFigure(IPathFigureVtbl): IInspectable(IInspectableVtbl) [IID_IPathFigure] {
    fn get_Segments(&self, out: *mut *mut PathSegmentCollection) -> HRESULT,
    fn put_Segments(&self, value: *mut PathSegmentCollection) -> HRESULT,
    fn get_StartPoint(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn put_StartPoint(&self, value: ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn get_IsClosed(&self, out: *mut bool) -> HRESULT,
    fn put_IsClosed(&self, value: bool) -> HRESULT,
    fn get_IsFilled(&self, out: *mut bool) -> HRESULT,
    fn put_IsFilled(&self, value: bool) -> HRESULT
}}
impl IPathFigure {
    #[inline] pub unsafe fn get_segments(&self) -> Result<ComPtr<PathSegmentCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Segments)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_segments(&self, value: &PathSegmentCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Segments)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_start_point(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StartPoint)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_start_point(&self, value: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StartPoint)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_closed(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsClosed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_closed(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsClosed)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_filled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsFilled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_filled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsFilled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPathFigureStatics, 3053818329, 9109, 17175, 149, 82, 58, 88, 82, 111, 140, 123);
RT_INTERFACE!{static interface IPathFigureStatics(IPathFigureStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPathFigureStatics] {
    fn get_SegmentsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_StartPointProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsClosedProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsFilledProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IPathFigureStatics {
    #[inline] pub unsafe fn get_segments_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SegmentsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_start_point_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StartPointProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_closed_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsClosedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_filled_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsFilledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PathFigure: IPathFigure}
impl RtActivatable<IPathFigureStatics> for PathFigure {}
impl RtActivatable<IActivationFactory> for PathFigure {}
impl PathFigure {
    #[inline] pub fn get_segments_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPathFigureStatics>>::get_activation_factory().get_segments_property()
    }}
    #[inline] pub fn get_start_point_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPathFigureStatics>>::get_activation_factory().get_start_point_property()
    }}
    #[inline] pub fn get_is_closed_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPathFigureStatics>>::get_activation_factory().get_is_closed_property()
    }}
    #[inline] pub fn get_is_filled_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPathFigureStatics>>::get_activation_factory().get_is_filled_property()
    }}
}
DEFINE_CLSID!(PathFigure(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,80,97,116,104,70,105,103,117,114,101,0]) [CLSID_PathFigure]);
DEFINE_IID!(IID_IArcSegment, 127143007, 25595, 17513, 145, 190, 241, 9, 124, 22, 128, 82);
RT_INTERFACE!{interface IArcSegment(IArcSegmentVtbl): IInspectable(IInspectableVtbl) [IID_IArcSegment] {
    fn get_Point(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn put_Point(&self, value: ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn get_Size(&self, out: *mut ::rt::gen::windows::foundation::Size) -> HRESULT,
    fn put_Size(&self, value: ::rt::gen::windows::foundation::Size) -> HRESULT,
    fn get_RotationAngle(&self, out: *mut f64) -> HRESULT,
    fn put_RotationAngle(&self, value: f64) -> HRESULT,
    fn get_IsLargeArc(&self, out: *mut bool) -> HRESULT,
    fn put_IsLargeArc(&self, value: bool) -> HRESULT,
    fn get_SweepDirection(&self, out: *mut SweepDirection) -> HRESULT,
    fn put_SweepDirection(&self, value: SweepDirection) -> HRESULT
}}
impl IArcSegment {
    #[inline] pub unsafe fn get_point(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Point)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_point(&self, value: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Point)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_size(&self) -> Result<::rt::gen::windows::foundation::Size> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Size)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_size(&self, value: ::rt::gen::windows::foundation::Size) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Size)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rotation_angle(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RotationAngle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_rotation_angle(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RotationAngle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_large_arc(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsLargeArc)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_large_arc(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsLargeArc)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sweep_direction(&self) -> Result<SweepDirection> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SweepDirection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_sweep_direction(&self, value: SweepDirection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SweepDirection)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IArcSegmentStatics, 2184482670, 35433, 16900, 156, 18, 114, 7, 223, 49, 118, 67);
RT_INTERFACE!{static interface IArcSegmentStatics(IArcSegmentStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IArcSegmentStatics] {
    fn get_PointProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SizeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_RotationAngleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsLargeArcProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_SweepDirectionProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IArcSegmentStatics {
    #[inline] pub unsafe fn get_point_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_size_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SizeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rotation_angle_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RotationAngleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_large_arc_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsLargeArcProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sweep_direction_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SweepDirectionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ArcSegment: IArcSegment}
impl RtActivatable<IArcSegmentStatics> for ArcSegment {}
impl RtActivatable<IActivationFactory> for ArcSegment {}
impl ArcSegment {
    #[inline] pub fn get_point_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IArcSegmentStatics>>::get_activation_factory().get_point_property()
    }}
    #[inline] pub fn get_size_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IArcSegmentStatics>>::get_activation_factory().get_size_property()
    }}
    #[inline] pub fn get_rotation_angle_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IArcSegmentStatics>>::get_activation_factory().get_rotation_angle_property()
    }}
    #[inline] pub fn get_is_large_arc_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IArcSegmentStatics>>::get_activation_factory().get_is_large_arc_property()
    }}
    #[inline] pub fn get_sweep_direction_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IArcSegmentStatics>>::get_activation_factory().get_sweep_direction_property()
    }}
}
DEFINE_CLSID!(ArcSegment(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,114,99,83,101,103,109,101,110,116,0]) [CLSID_ArcSegment]);
DEFINE_IID!(IID_IBezierSegment, 2940975598, 35204, 18871, 129, 223, 63, 53, 153, 75, 149, 235);
RT_INTERFACE!{interface IBezierSegment(IBezierSegmentVtbl): IInspectable(IInspectableVtbl) [IID_IBezierSegment] {
    fn get_Point1(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn put_Point1(&self, value: ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn get_Point2(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn put_Point2(&self, value: ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn get_Point3(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn put_Point3(&self, value: ::rt::gen::windows::foundation::Point) -> HRESULT
}}
impl IBezierSegment {
    #[inline] pub unsafe fn get_point1(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Point1)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_point1(&self, value: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Point1)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_point2(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Point2)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_point2(&self, value: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Point2)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_point3(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Point3)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_point3(&self, value: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Point3)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBezierSegmentStatics, 3223878572, 5136, 17712, 132, 82, 28, 157, 10, 209, 243, 65);
RT_INTERFACE!{static interface IBezierSegmentStatics(IBezierSegmentStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBezierSegmentStatics] {
    fn get_Point1Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_Point2Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_Point3Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IBezierSegmentStatics {
    #[inline] pub unsafe fn get_point1_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Point1Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_point2_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Point2Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_point3_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Point3Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class BezierSegment: IBezierSegment}
impl RtActivatable<IBezierSegmentStatics> for BezierSegment {}
impl RtActivatable<IActivationFactory> for BezierSegment {}
impl BezierSegment {
    #[inline] pub fn get_point1_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBezierSegmentStatics>>::get_activation_factory().get_point1_property()
    }}
    #[inline] pub fn get_point2_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBezierSegmentStatics>>::get_activation_factory().get_point2_property()
    }}
    #[inline] pub fn get_point3_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBezierSegmentStatics>>::get_activation_factory().get_point3_property()
    }}
}
DEFINE_CLSID!(BezierSegment(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,66,101,122,105,101,114,83,101,103,109,101,110,116,0]) [CLSID_BezierSegment]);
DEFINE_IID!(IID_IEllipseGeometry, 3572898746, 20130, 16598, 170, 108, 141, 56, 170, 135, 101, 31);
RT_INTERFACE!{interface IEllipseGeometry(IEllipseGeometryVtbl): IInspectable(IInspectableVtbl) [IID_IEllipseGeometry] {
    fn get_Center(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn put_Center(&self, value: ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn get_RadiusX(&self, out: *mut f64) -> HRESULT,
    fn put_RadiusX(&self, value: f64) -> HRESULT,
    fn get_RadiusY(&self, out: *mut f64) -> HRESULT,
    fn put_RadiusY(&self, value: f64) -> HRESULT
}}
impl IEllipseGeometry {
    #[inline] pub unsafe fn get_center(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Center)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_center(&self, value: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Center)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_radius_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RadiusX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_radius_x(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RadiusX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_radius_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RadiusY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_radius_y(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RadiusY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEllipseGeometryStatics, 390388551, 63029, 19222, 174, 230, 224, 82, 166, 93, 239, 178);
RT_INTERFACE!{static interface IEllipseGeometryStatics(IEllipseGeometryStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IEllipseGeometryStatics] {
    fn get_CenterProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_RadiusXProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_RadiusYProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IEllipseGeometryStatics {
    #[inline] pub unsafe fn get_center_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CenterProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_radius_xproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RadiusXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_radius_yproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RadiusYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EllipseGeometry: IEllipseGeometry}
impl RtActivatable<IEllipseGeometryStatics> for EllipseGeometry {}
impl RtActivatable<IActivationFactory> for EllipseGeometry {}
impl EllipseGeometry {
    #[inline] pub fn get_center_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IEllipseGeometryStatics>>::get_activation_factory().get_center_property()
    }}
    #[inline] pub fn get_radius_xproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IEllipseGeometryStatics>>::get_activation_factory().get_radius_xproperty()
    }}
    #[inline] pub fn get_radius_yproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IEllipseGeometryStatics>>::get_activation_factory().get_radius_yproperty()
    }}
}
DEFINE_CLSID!(EllipseGeometry(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,69,108,108,105,112,115,101,71,101,111,109,101,116,114,121,0]) [CLSID_EllipseGeometry]);
DEFINE_IID!(IID_IGeometryGroup, 1428314721, 34423, 19596, 142, 70, 238, 61, 195, 85, 17, 75);
RT_INTERFACE!{interface IGeometryGroup(IGeometryGroupVtbl): IInspectable(IInspectableVtbl) [IID_IGeometryGroup] {
    fn get_FillRule(&self, out: *mut FillRule) -> HRESULT,
    fn put_FillRule(&self, value: FillRule) -> HRESULT,
    fn get_Children(&self, out: *mut *mut GeometryCollection) -> HRESULT,
    fn put_Children(&self, value: *mut GeometryCollection) -> HRESULT
}}
impl IGeometryGroup {
    #[inline] pub unsafe fn get_fill_rule(&self) -> Result<FillRule> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FillRule)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_fill_rule(&self, value: FillRule) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FillRule)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_children(&self) -> Result<ComPtr<GeometryCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Children)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_children(&self, value: &GeometryCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Children)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGeometryGroupStatics, 1456035316, 33942, 19382, 171, 240, 97, 123, 31, 231, 139, 69);
RT_INTERFACE!{static interface IGeometryGroupStatics(IGeometryGroupStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGeometryGroupStatics] {
    fn get_FillRuleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ChildrenProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IGeometryGroupStatics {
    #[inline] pub unsafe fn get_fill_rule_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FillRuleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_children_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ChildrenProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class GeometryGroup: IGeometryGroup}
impl RtActivatable<IGeometryGroupStatics> for GeometryGroup {}
impl RtActivatable<IActivationFactory> for GeometryGroup {}
impl GeometryGroup {
    #[inline] pub fn get_fill_rule_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGeometryGroupStatics>>::get_activation_factory().get_fill_rule_property()
    }}
    #[inline] pub fn get_children_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGeometryGroupStatics>>::get_activation_factory().get_children_property()
    }}
}
DEFINE_CLSID!(GeometryGroup(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,71,101,111,109,101,116,114,121,71,114,111,117,112,0]) [CLSID_GeometryGroup]);
DEFINE_IID!(IID_IGradientBrush, 560391839, 37722, 16785, 142, 60, 28, 141, 253, 252, 220, 120);
RT_INTERFACE!{interface IGradientBrush(IGradientBrushVtbl): IInspectable(IInspectableVtbl) [IID_IGradientBrush] {
    fn get_SpreadMethod(&self, out: *mut GradientSpreadMethod) -> HRESULT,
    fn put_SpreadMethod(&self, value: GradientSpreadMethod) -> HRESULT,
    fn get_MappingMode(&self, out: *mut BrushMappingMode) -> HRESULT,
    fn put_MappingMode(&self, value: BrushMappingMode) -> HRESULT,
    fn get_ColorInterpolationMode(&self, out: *mut ColorInterpolationMode) -> HRESULT,
    fn put_ColorInterpolationMode(&self, value: ColorInterpolationMode) -> HRESULT,
    fn get_GradientStops(&self, out: *mut *mut GradientStopCollection) -> HRESULT,
    fn put_GradientStops(&self, value: *mut GradientStopCollection) -> HRESULT
}}
impl IGradientBrush {
    #[inline] pub unsafe fn get_spread_method(&self) -> Result<GradientSpreadMethod> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SpreadMethod)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_spread_method(&self, value: GradientSpreadMethod) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SpreadMethod)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_mapping_mode(&self) -> Result<BrushMappingMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MappingMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_mapping_mode(&self, value: BrushMappingMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MappingMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_color_interpolation_mode(&self) -> Result<ColorInterpolationMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ColorInterpolationMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_color_interpolation_mode(&self, value: ColorInterpolationMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ColorInterpolationMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_gradient_stops(&self) -> Result<ComPtr<GradientStopCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GradientStops)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_gradient_stops(&self, value: &GradientStopCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_GradientStops)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGradientBrushStatics, 2518049273, 35764, 20076, 185, 35, 181, 215, 135, 224, 241, 169);
RT_INTERFACE!{static interface IGradientBrushStatics(IGradientBrushStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGradientBrushStatics] {
    fn get_SpreadMethodProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_MappingModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ColorInterpolationModeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_GradientStopsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IGradientBrushStatics {
    #[inline] pub unsafe fn get_spread_method_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SpreadMethodProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_mapping_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MappingModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_color_interpolation_mode_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ColorInterpolationModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_gradient_stops_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GradientStopsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGradientBrushFactory, 3980884426, 17853, 16689, 182, 37, 190, 134, 224, 124, 97, 18);
RT_INTERFACE!{interface IGradientBrushFactory(IGradientBrushFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGradientBrushFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut GradientBrush) -> HRESULT
}}
impl IGradientBrushFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<GradientBrush>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class GradientBrush: IGradientBrush}
impl RtActivatable<IGradientBrushStatics> for GradientBrush {}
impl GradientBrush {
    #[inline] pub fn get_spread_method_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGradientBrushStatics>>::get_activation_factory().get_spread_method_property()
    }}
    #[inline] pub fn get_mapping_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGradientBrushStatics>>::get_activation_factory().get_mapping_mode_property()
    }}
    #[inline] pub fn get_color_interpolation_mode_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGradientBrushStatics>>::get_activation_factory().get_color_interpolation_mode_property()
    }}
    #[inline] pub fn get_gradient_stops_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IGradientBrushStatics>>::get_activation_factory().get_gradient_stops_property()
    }}
}
DEFINE_CLSID!(GradientBrush(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,71,114,97,100,105,101,110,116,66,114,117,115,104,0]) [CLSID_GradientBrush]);
DEFINE_IID!(IID_ILineGeometry, 820892834, 36805, 16559, 167, 162, 194, 127, 231, 170, 19, 99);
RT_INTERFACE!{interface ILineGeometry(ILineGeometryVtbl): IInspectable(IInspectableVtbl) [IID_ILineGeometry] {
    fn get_StartPoint(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn put_StartPoint(&self, value: ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn get_EndPoint(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn put_EndPoint(&self, value: ::rt::gen::windows::foundation::Point) -> HRESULT
}}
impl ILineGeometry {
    #[inline] pub unsafe fn get_start_point(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StartPoint)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_start_point(&self, value: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StartPoint)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_end_point(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EndPoint)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_end_point(&self, value: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EndPoint)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ILineGeometryStatics, 1468720995, 21858, 20196, 135, 3, 234, 64, 54, 216, 145, 227);
RT_INTERFACE!{static interface ILineGeometryStatics(ILineGeometryStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ILineGeometryStatics] {
    fn get_StartPointProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_EndPointProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ILineGeometryStatics {
    #[inline] pub unsafe fn get_start_point_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StartPointProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_end_point_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EndPointProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class LineGeometry: ILineGeometry}
impl RtActivatable<ILineGeometryStatics> for LineGeometry {}
impl RtActivatable<IActivationFactory> for LineGeometry {}
impl LineGeometry {
    #[inline] pub fn get_start_point_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ILineGeometryStatics>>::get_activation_factory().get_start_point_property()
    }}
    #[inline] pub fn get_end_point_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ILineGeometryStatics>>::get_activation_factory().get_end_point_property()
    }}
}
DEFINE_CLSID!(LineGeometry(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,76,105,110,101,71,101,111,109,101,116,114,121,0]) [CLSID_LineGeometry]);
DEFINE_IID!(IID_ILineSegment, 4016713253, 16368, 17440, 164, 17, 113, 130, 164, 206, 203, 21);
RT_INTERFACE!{interface ILineSegment(ILineSegmentVtbl): IInspectable(IInspectableVtbl) [IID_ILineSegment] {
    fn get_Point(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn put_Point(&self, value: ::rt::gen::windows::foundation::Point) -> HRESULT
}}
impl ILineSegment {
    #[inline] pub unsafe fn get_point(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Point)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_point(&self, value: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Point)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ILineSegmentStatics, 2680860993, 1216, 19195, 135, 179, 232, 0, 185, 105, 184, 148);
RT_INTERFACE!{static interface ILineSegmentStatics(ILineSegmentStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ILineSegmentStatics] {
    fn get_PointProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ILineSegmentStatics {
    #[inline] pub unsafe fn get_point_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class LineSegment: ILineSegment}
impl RtActivatable<ILineSegmentStatics> for LineSegment {}
impl RtActivatable<IActivationFactory> for LineSegment {}
impl LineSegment {
    #[inline] pub fn get_point_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ILineSegmentStatics>>::get_activation_factory().get_point_property()
    }}
}
DEFINE_CLSID!(LineSegment(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,76,105,110,101,83,101,103,109,101,110,116,0]) [CLSID_LineSegment]);
DEFINE_IID!(IID_IPathGeometry, 136027640, 47846, 19403, 129, 60, 189, 224, 228, 109, 200, 183);
RT_INTERFACE!{interface IPathGeometry(IPathGeometryVtbl): IInspectable(IInspectableVtbl) [IID_IPathGeometry] {
    fn get_FillRule(&self, out: *mut FillRule) -> HRESULT,
    fn put_FillRule(&self, value: FillRule) -> HRESULT,
    fn get_Figures(&self, out: *mut *mut PathFigureCollection) -> HRESULT,
    fn put_Figures(&self, value: *mut PathFigureCollection) -> HRESULT
}}
impl IPathGeometry {
    #[inline] pub unsafe fn get_fill_rule(&self) -> Result<FillRule> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FillRule)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_fill_rule(&self, value: FillRule) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FillRule)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_figures(&self) -> Result<ComPtr<PathFigureCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Figures)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_figures(&self, value: &PathFigureCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Figures)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPathGeometryStatics, 3655699386, 11450, 18241, 143, 141, 49, 152, 207, 81, 134, 185);
RT_INTERFACE!{static interface IPathGeometryStatics(IPathGeometryStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPathGeometryStatics] {
    fn get_FillRuleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_FiguresProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IPathGeometryStatics {
    #[inline] pub unsafe fn get_fill_rule_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FillRuleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_figures_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FiguresProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PathGeometry: IPathGeometry}
impl RtActivatable<IPathGeometryStatics> for PathGeometry {}
impl RtActivatable<IActivationFactory> for PathGeometry {}
impl PathGeometry {
    #[inline] pub fn get_fill_rule_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPathGeometryStatics>>::get_activation_factory().get_fill_rule_property()
    }}
    #[inline] pub fn get_figures_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPathGeometryStatics>>::get_activation_factory().get_figures_property()
    }}
}
DEFINE_CLSID!(PathGeometry(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,80,97,116,104,71,101,111,109,101,116,114,121,0]) [CLSID_PathGeometry]);
DEFINE_IID!(IID_IPolyBezierSegment, 914379377, 14532, 19407, 150, 205, 2, 138, 109, 56, 175, 37);
RT_INTERFACE!{interface IPolyBezierSegment(IPolyBezierSegmentVtbl): IInspectable(IInspectableVtbl) [IID_IPolyBezierSegment] {
    fn get_Points(&self, out: *mut *mut PointCollection) -> HRESULT,
    fn put_Points(&self, value: *mut PointCollection) -> HRESULT
}}
impl IPolyBezierSegment {
    #[inline] pub unsafe fn get_points(&self) -> Result<ComPtr<PointCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Points)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_points(&self, value: &PointCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Points)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPolyBezierSegmentStatics, 496084698, 5266, 19148, 189, 102, 164, 150, 243, 216, 41, 214);
RT_INTERFACE!{static interface IPolyBezierSegmentStatics(IPolyBezierSegmentStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPolyBezierSegmentStatics] {
    fn get_PointsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IPolyBezierSegmentStatics {
    #[inline] pub unsafe fn get_points_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PolyBezierSegment: IPolyBezierSegment}
impl RtActivatable<IPolyBezierSegmentStatics> for PolyBezierSegment {}
impl RtActivatable<IActivationFactory> for PolyBezierSegment {}
impl PolyBezierSegment {
    #[inline] pub fn get_points_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPolyBezierSegmentStatics>>::get_activation_factory().get_points_property()
    }}
}
DEFINE_CLSID!(PolyBezierSegment(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,80,111,108,121,66,101,122,105,101,114,83,101,103,109,101,110,116,0]) [CLSID_PolyBezierSegment]);
DEFINE_IID!(IID_IPolyLineSegment, 1262059399, 41702, 18333, 189, 200, 111, 68, 100, 100, 104, 135);
RT_INTERFACE!{interface IPolyLineSegment(IPolyLineSegmentVtbl): IInspectable(IInspectableVtbl) [IID_IPolyLineSegment] {
    fn get_Points(&self, out: *mut *mut PointCollection) -> HRESULT,
    fn put_Points(&self, value: *mut PointCollection) -> HRESULT
}}
impl IPolyLineSegment {
    #[inline] pub unsafe fn get_points(&self) -> Result<ComPtr<PointCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Points)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_points(&self, value: &PointCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Points)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPolyLineSegmentStatics, 3595185287, 13297, 20080, 164, 127, 180, 152, 30, 246, 72, 162);
RT_INTERFACE!{static interface IPolyLineSegmentStatics(IPolyLineSegmentStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPolyLineSegmentStatics] {
    fn get_PointsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IPolyLineSegmentStatics {
    #[inline] pub unsafe fn get_points_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PolyLineSegment: IPolyLineSegment}
impl RtActivatable<IPolyLineSegmentStatics> for PolyLineSegment {}
impl RtActivatable<IActivationFactory> for PolyLineSegment {}
impl PolyLineSegment {
    #[inline] pub fn get_points_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPolyLineSegmentStatics>>::get_activation_factory().get_points_property()
    }}
}
DEFINE_CLSID!(PolyLineSegment(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,80,111,108,121,76,105,110,101,83,101,103,109,101,110,116,0]) [CLSID_PolyLineSegment]);
DEFINE_IID!(IID_IPolyQuadraticBezierSegment, 3713854845, 59099, 19606, 182, 161, 63, 206, 150, 233, 135, 166);
RT_INTERFACE!{interface IPolyQuadraticBezierSegment(IPolyQuadraticBezierSegmentVtbl): IInspectable(IInspectableVtbl) [IID_IPolyQuadraticBezierSegment] {
    fn get_Points(&self, out: *mut *mut PointCollection) -> HRESULT,
    fn put_Points(&self, value: *mut PointCollection) -> HRESULT
}}
impl IPolyQuadraticBezierSegment {
    #[inline] pub unsafe fn get_points(&self) -> Result<ComPtr<PointCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Points)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_points(&self, value: &PointCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Points)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPolyQuadraticBezierSegmentStatics, 4260752245, 31445, 19593, 129, 105, 140, 151, 134, 171, 217, 235);
RT_INTERFACE!{static interface IPolyQuadraticBezierSegmentStatics(IPolyQuadraticBezierSegmentStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPolyQuadraticBezierSegmentStatics] {
    fn get_PointsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IPolyQuadraticBezierSegmentStatics {
    #[inline] pub unsafe fn get_points_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PolyQuadraticBezierSegment: IPolyQuadraticBezierSegment}
impl RtActivatable<IPolyQuadraticBezierSegmentStatics> for PolyQuadraticBezierSegment {}
impl RtActivatable<IActivationFactory> for PolyQuadraticBezierSegment {}
impl PolyQuadraticBezierSegment {
    #[inline] pub fn get_points_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPolyQuadraticBezierSegmentStatics>>::get_activation_factory().get_points_property()
    }}
}
DEFINE_CLSID!(PolyQuadraticBezierSegment(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,80,111,108,121,81,117,97,100,114,97,116,105,99,66,101,122,105,101,114,83,101,103,109,101,110,116,0]) [CLSID_PolyQuadraticBezierSegment]);
DEFINE_IID!(IID_IQuadraticBezierSegment, 743479899, 48920, 17754, 160, 120, 145, 75, 82, 50, 216, 175);
RT_INTERFACE!{interface IQuadraticBezierSegment(IQuadraticBezierSegmentVtbl): IInspectable(IInspectableVtbl) [IID_IQuadraticBezierSegment] {
    fn get_Point1(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn put_Point1(&self, value: ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn get_Point2(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn put_Point2(&self, value: ::rt::gen::windows::foundation::Point) -> HRESULT
}}
impl IQuadraticBezierSegment {
    #[inline] pub unsafe fn get_point1(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Point1)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_point1(&self, value: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Point1)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_point2(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Point2)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_point2(&self, value: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Point2)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IQuadraticBezierSegmentStatics, 1774682744, 15371, 19279, 183, 162, 240, 3, 222, 212, 27, 176);
RT_INTERFACE!{static interface IQuadraticBezierSegmentStatics(IQuadraticBezierSegmentStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IQuadraticBezierSegmentStatics] {
    fn get_Point1Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_Point2Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IQuadraticBezierSegmentStatics {
    #[inline] pub unsafe fn get_point1_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Point1Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_point2_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Point2Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class QuadraticBezierSegment: IQuadraticBezierSegment}
impl RtActivatable<IQuadraticBezierSegmentStatics> for QuadraticBezierSegment {}
impl RtActivatable<IActivationFactory> for QuadraticBezierSegment {}
impl QuadraticBezierSegment {
    #[inline] pub fn get_point1_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IQuadraticBezierSegmentStatics>>::get_activation_factory().get_point1_property()
    }}
    #[inline] pub fn get_point2_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IQuadraticBezierSegmentStatics>>::get_activation_factory().get_point2_property()
    }}
}
DEFINE_CLSID!(QuadraticBezierSegment(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,81,117,97,100,114,97,116,105,99,66,101,122,105,101,114,83,101,103,109,101,110,116,0]) [CLSID_QuadraticBezierSegment]);
DEFINE_IID!(IID_ITileBrush, 3254898438, 52612, 18597, 150, 7, 102, 77, 115, 97, 205, 97);
RT_INTERFACE!{interface ITileBrush(ITileBrushVtbl): IInspectable(IInspectableVtbl) [IID_ITileBrush] {
    fn get_AlignmentX(&self, out: *mut AlignmentX) -> HRESULT,
    fn put_AlignmentX(&self, value: AlignmentX) -> HRESULT,
    fn get_AlignmentY(&self, out: *mut AlignmentY) -> HRESULT,
    fn put_AlignmentY(&self, value: AlignmentY) -> HRESULT,
    fn get_Stretch(&self, out: *mut Stretch) -> HRESULT,
    fn put_Stretch(&self, value: Stretch) -> HRESULT
}}
impl ITileBrush {
    #[inline] pub unsafe fn get_alignment_x(&self) -> Result<AlignmentX> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AlignmentX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_alignment_x(&self, value: AlignmentX) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AlignmentX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_alignment_y(&self) -> Result<AlignmentY> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AlignmentY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_alignment_y(&self, value: AlignmentY) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AlignmentY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stretch(&self) -> Result<Stretch> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Stretch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stretch(&self, value: Stretch) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Stretch)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITileBrushStatics, 882360923, 46434, 20072, 132, 53, 35, 153, 246, 235, 148, 213);
RT_INTERFACE!{static interface ITileBrushStatics(ITileBrushStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ITileBrushStatics] {
    fn get_AlignmentXProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_AlignmentYProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_StretchProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ITileBrushStatics {
    #[inline] pub unsafe fn get_alignment_xproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AlignmentXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_alignment_yproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AlignmentYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stretch_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StretchProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITileBrushFactory, 2853543804, 60778, 20403, 176, 20, 181, 199, 227, 121, 164, 222);
RT_INTERFACE!{interface ITileBrushFactory(ITileBrushFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ITileBrushFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut TileBrush) -> HRESULT
}}
impl ITileBrushFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<TileBrush>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class TileBrush: ITileBrush}
impl RtActivatable<ITileBrushStatics> for TileBrush {}
impl TileBrush {
    #[inline] pub fn get_alignment_xproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITileBrushStatics>>::get_activation_factory().get_alignment_xproperty()
    }}
    #[inline] pub fn get_alignment_yproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITileBrushStatics>>::get_activation_factory().get_alignment_yproperty()
    }}
    #[inline] pub fn get_stretch_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITileBrushStatics>>::get_activation_factory().get_stretch_property()
    }}
}
DEFINE_CLSID!(TileBrush(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,84,105,108,101,66,114,117,115,104,0]) [CLSID_TileBrush]);
DEFINE_IID!(IID_IXamlCompositionBrushBase, 65286873, 45916, 19065, 129, 28, 197, 101, 32, 4, 218, 14);
RT_INTERFACE!{interface IXamlCompositionBrushBase(IXamlCompositionBrushBaseVtbl): IInspectable(IInspectableVtbl) [IID_IXamlCompositionBrushBase] {
    #[cfg(feature="windows-ui")] fn get_FallbackColor(&self, out: *mut super::super::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_FallbackColor(&self, value: super::super::Color) -> HRESULT
}}
impl IXamlCompositionBrushBase {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_fallback_color(&self) -> Result<super::super::Color> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FallbackColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_fallback_color(&self, value: super::super::Color) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FallbackColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IXamlCompositionBrushBaseOverrides, 3515951089, 14516, 20129, 143, 51, 132, 150, 41, 164, 201, 193);
RT_INTERFACE!{interface IXamlCompositionBrushBaseOverrides(IXamlCompositionBrushBaseOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IXamlCompositionBrushBaseOverrides] {
    fn OnConnected(&self) -> HRESULT,
    fn OnDisconnected(&self) -> HRESULT
}}
impl IXamlCompositionBrushBaseOverrides {
    #[inline] pub unsafe fn on_connected(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).OnConnected)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn on_disconnected(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).OnDisconnected)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IXamlCompositionBrushBaseProtected, 353629144, 1111, 19996, 173, 119, 17, 193, 217, 135, 151, 67);
RT_INTERFACE!{interface IXamlCompositionBrushBaseProtected(IXamlCompositionBrushBaseProtectedVtbl): IInspectable(IInspectableVtbl) [IID_IXamlCompositionBrushBaseProtected] {
    #[cfg(feature="windows-ui")] fn get_CompositionBrush(&self, out: *mut *mut super::super::composition::CompositionBrush) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_CompositionBrush(&self, value: *mut super::super::composition::CompositionBrush) -> HRESULT
}}
impl IXamlCompositionBrushBaseProtected {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_composition_brush(&self) -> Result<ComPtr<super::super::composition::CompositionBrush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CompositionBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_composition_brush(&self, value: &super::super::composition::CompositionBrush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CompositionBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IXamlCompositionBrushBaseStatics, 1339333382, 1562, 17439, 185, 122, 173, 251, 212, 26, 230, 129);
RT_INTERFACE!{static interface IXamlCompositionBrushBaseStatics(IXamlCompositionBrushBaseStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IXamlCompositionBrushBaseStatics] {
    fn get_FallbackColorProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IXamlCompositionBrushBaseStatics {
    #[inline] pub unsafe fn get_fallback_color_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FallbackColorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IXamlCompositionBrushBaseFactory, 961480739, 9297, 20184, 189, 36, 72, 129, 73, 179, 66, 141);
RT_INTERFACE!{interface IXamlCompositionBrushBaseFactory(IXamlCompositionBrushBaseFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IXamlCompositionBrushBaseFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut XamlCompositionBrushBase) -> HRESULT
}}
impl IXamlCompositionBrushBaseFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<XamlCompositionBrushBase>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class XamlCompositionBrushBase: IXamlCompositionBrushBase}
impl RtActivatable<IXamlCompositionBrushBaseStatics> for XamlCompositionBrushBase {}
impl XamlCompositionBrushBase {
    #[inline] pub fn get_fallback_color_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IXamlCompositionBrushBaseStatics>>::get_activation_factory().get_fallback_color_property()
    }}
}
DEFINE_CLSID!(XamlCompositionBrushBase(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,88,97,109,108,67,111,109,112,111,115,105,116,105,111,110,66,114,117,115,104,66,97,115,101,0]) [CLSID_XamlCompositionBrushBase]);
DEFINE_IID!(IID_IImageBrush, 2681279351, 49450, 17555, 191, 125, 243, 168, 173, 116, 181, 84);
RT_INTERFACE!{interface IImageBrush(IImageBrushVtbl): IInspectable(IInspectableVtbl) [IID_IImageBrush] {
    fn get_ImageSource(&self, out: *mut *mut ImageSource) -> HRESULT,
    fn put_ImageSource(&self, value: *mut ImageSource) -> HRESULT,
    fn add_ImageFailed(&self, value: *mut super::ExceptionRoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ImageFailed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ImageOpened(&self, value: *mut super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ImageOpened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IImageBrush {
    #[inline] pub unsafe fn get_image_source(&self) -> Result<ComPtr<ImageSource>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ImageSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_image_source(&self, value: &ImageSource) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ImageSource)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_image_failed(&self, value: &super::ExceptionRoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ImageFailed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_image_failed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ImageFailed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_image_opened(&self, value: &super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ImageOpened)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_image_opened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ImageOpened)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IImageBrushStatics, 307605938, 56600, 17125, 137, 44, 234, 227, 12, 48, 91, 140);
RT_INTERFACE!{static interface IImageBrushStatics(IImageBrushStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IImageBrushStatics] {
    fn get_ImageSourceProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IImageBrushStatics {
    #[inline] pub unsafe fn get_image_source_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ImageSourceProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ImageBrush: IImageBrush}
impl RtActivatable<IImageBrushStatics> for ImageBrush {}
impl RtActivatable<IActivationFactory> for ImageBrush {}
impl ImageBrush {
    #[inline] pub fn get_image_source_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IImageBrushStatics>>::get_activation_factory().get_image_source_property()
    }}
}
DEFINE_CLSID!(ImageBrush(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,73,109,97,103,101,66,114,117,115,104,0]) [CLSID_ImageBrush]);
DEFINE_IID!(IID_ILinearGradientBrush, 2392248683, 48004, 19567, 157, 191, 157, 108, 92, 109, 156, 57);
RT_INTERFACE!{interface ILinearGradientBrush(ILinearGradientBrushVtbl): IInspectable(IInspectableVtbl) [IID_ILinearGradientBrush] {
    fn get_StartPoint(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn put_StartPoint(&self, value: ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn get_EndPoint(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn put_EndPoint(&self, value: ::rt::gen::windows::foundation::Point) -> HRESULT
}}
impl ILinearGradientBrush {
    #[inline] pub unsafe fn get_start_point(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StartPoint)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_start_point(&self, value: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StartPoint)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_end_point(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EndPoint)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_end_point(&self, value: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EndPoint)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ILinearGradientBrushStatics, 2063000836, 11715, 16611, 190, 11, 179, 20, 193, 60, 185, 145);
RT_INTERFACE!{static interface ILinearGradientBrushStatics(ILinearGradientBrushStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ILinearGradientBrushStatics] {
    fn get_StartPointProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_EndPointProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ILinearGradientBrushStatics {
    #[inline] pub unsafe fn get_start_point_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StartPointProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_end_point_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EndPointProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ILinearGradientBrushFactory, 182486556, 7802, 20461, 152, 87, 234, 140, 170, 121, 132, 144);
RT_INTERFACE!{static interface ILinearGradientBrushFactory(ILinearGradientBrushFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ILinearGradientBrushFactory] {
    fn CreateInstanceWithGradientStopCollectionAndAngle(&self, gradientStopCollection: *mut GradientStopCollection, angle: f64, out: *mut *mut LinearGradientBrush) -> HRESULT
}}
impl ILinearGradientBrushFactory {
    #[inline] pub unsafe fn create_instance_with_gradient_stop_collection_and_angle(&self, gradientStopCollection: &GradientStopCollection, angle: f64) -> Result<ComPtr<LinearGradientBrush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithGradientStopCollectionAndAngle)(self as *const _ as *mut _, gradientStopCollection as *const _ as *mut _, angle, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class LinearGradientBrush: ILinearGradientBrush}
impl RtActivatable<ILinearGradientBrushFactory> for LinearGradientBrush {}
impl RtActivatable<ILinearGradientBrushStatics> for LinearGradientBrush {}
impl RtActivatable<IActivationFactory> for LinearGradientBrush {}
impl LinearGradientBrush {
    #[inline] pub fn create_instance_with_gradient_stop_collection_and_angle(gradientStopCollection: &GradientStopCollection, angle: f64) -> Result<ComPtr<LinearGradientBrush>> { unsafe {
        <Self as RtActivatable<ILinearGradientBrushFactory>>::get_activation_factory().create_instance_with_gradient_stop_collection_and_angle(gradientStopCollection, angle)
    }}
    #[inline] pub fn get_start_point_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ILinearGradientBrushStatics>>::get_activation_factory().get_start_point_property()
    }}
    #[inline] pub fn get_end_point_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ILinearGradientBrushStatics>>::get_activation_factory().get_end_point_property()
    }}
}
DEFINE_CLSID!(LinearGradientBrush(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,76,105,110,101,97,114,71,114,97,100,105,101,110,116,66,114,117,115,104,0]) [CLSID_LinearGradientBrush]);
pub mod animation { // Windows.UI.Xaml.Media.Animation
use ::prelude::*;
RT_ENUM! { enum ClockState: i32 {
    Active (ClockState_Active) = 0, Filling (ClockState_Filling) = 1, Stopped (ClockState_Stopped) = 2,
}}
RT_ENUM! { enum EasingMode: i32 {
    EaseOut (EasingMode_EaseOut) = 0, EaseIn (EasingMode_EaseIn) = 1, EaseInOut (EasingMode_EaseInOut) = 2,
}}
RT_ENUM! { enum FillBehavior: i32 {
    HoldEnd (FillBehavior_HoldEnd) = 0, Stop (FillBehavior_Stop) = 1,
}}
RT_ENUM! { enum RepeatBehaviorType: i32 {
    Count (RepeatBehaviorType_Count) = 0, Duration (RepeatBehaviorType_Duration) = 1, Forever (RepeatBehaviorType_Forever) = 2,
}}
RT_STRUCT! { struct KeyTime {
    TimeSpan: ::rt::gen::windows::foundation::TimeSpan,
}}
DEFINE_IID!(IID_IKeyTimeHelper, 910419072, 18467, 18026, 171, 229, 94, 121, 200, 237, 119, 237);
RT_INTERFACE!{interface IKeyTimeHelper(IKeyTimeHelperVtbl): IInspectable(IInspectableVtbl) [IID_IKeyTimeHelper] {
    
}}
DEFINE_IID!(IID_IKeyTimeHelperStatics, 2141348140, 8873, 17897, 154, 247, 199, 65, 110, 255, 247, 165);
RT_INTERFACE!{static interface IKeyTimeHelperStatics(IKeyTimeHelperStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKeyTimeHelperStatics] {
    fn FromTimeSpan(&self, timeSpan: ::rt::gen::windows::foundation::TimeSpan, out: *mut KeyTime) -> HRESULT
}}
impl IKeyTimeHelperStatics {
    #[inline] pub unsafe fn from_time_span(&self, timeSpan: ::rt::gen::windows::foundation::TimeSpan) -> Result<KeyTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).FromTimeSpan)(self as *const _ as *mut _, timeSpan, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class KeyTimeHelper: IKeyTimeHelper}
impl RtActivatable<IKeyTimeHelperStatics> for KeyTimeHelper {}
impl KeyTimeHelper {
    #[inline] pub fn from_time_span(timeSpan: ::rt::gen::windows::foundation::TimeSpan) -> Result<KeyTime> { unsafe {
        <Self as RtActivatable<IKeyTimeHelperStatics>>::get_activation_factory().from_time_span(timeSpan)
    }}
}
DEFINE_CLSID!(KeyTimeHelper(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,75,101,121,84,105,109,101,72,101,108,112,101,114,0]) [CLSID_KeyTimeHelper]);
RT_STRUCT! { struct RepeatBehavior {
    Count: f64, Duration: ::rt::gen::windows::foundation::TimeSpan, Type: RepeatBehaviorType,
}}
DEFINE_IID!(IID_IRepeatBehaviorHelper, 1751362418, 18839, 18425, 135, 173, 55, 239, 183, 89, 147, 234);
RT_INTERFACE!{interface IRepeatBehaviorHelper(IRepeatBehaviorHelperVtbl): IInspectable(IInspectableVtbl) [IID_IRepeatBehaviorHelper] {
    
}}
DEFINE_IID!(IID_IRepeatBehaviorHelperStatics, 2054770739, 31219, 19929, 178, 103, 156, 245, 15, 181, 31, 132);
RT_INTERFACE!{static interface IRepeatBehaviorHelperStatics(IRepeatBehaviorHelperStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRepeatBehaviorHelperStatics] {
    fn get_Forever(&self, out: *mut RepeatBehavior) -> HRESULT,
    fn FromCount(&self, count: f64, out: *mut RepeatBehavior) -> HRESULT,
    fn FromDuration(&self, duration: ::rt::gen::windows::foundation::TimeSpan, out: *mut RepeatBehavior) -> HRESULT,
    fn GetHasCount(&self, target: RepeatBehavior, out: *mut bool) -> HRESULT,
    fn GetHasDuration(&self, target: RepeatBehavior, out: *mut bool) -> HRESULT,
    fn Equals(&self, target: RepeatBehavior, value: RepeatBehavior, out: *mut bool) -> HRESULT
}}
impl IRepeatBehaviorHelperStatics {
    #[inline] pub unsafe fn get_forever(&self) -> Result<RepeatBehavior> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Forever)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn from_count(&self, count: f64) -> Result<RepeatBehavior> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).FromCount)(self as *const _ as *mut _, count, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn from_duration(&self, duration: ::rt::gen::windows::foundation::TimeSpan) -> Result<RepeatBehavior> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).FromDuration)(self as *const _ as *mut _, duration, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_has_count(&self, target: RepeatBehavior) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetHasCount)(self as *const _ as *mut _, target, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_has_duration(&self, target: RepeatBehavior) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetHasDuration)(self as *const _ as *mut _, target, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn equals(&self, target: RepeatBehavior, value: RepeatBehavior) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Equals)(self as *const _ as *mut _, target, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class RepeatBehaviorHelper: IRepeatBehaviorHelper}
impl RtActivatable<IRepeatBehaviorHelperStatics> for RepeatBehaviorHelper {}
impl RepeatBehaviorHelper {
    #[inline] pub fn get_forever() -> Result<RepeatBehavior> { unsafe {
        <Self as RtActivatable<IRepeatBehaviorHelperStatics>>::get_activation_factory().get_forever()
    }}
    #[inline] pub fn from_count(count: f64) -> Result<RepeatBehavior> { unsafe {
        <Self as RtActivatable<IRepeatBehaviorHelperStatics>>::get_activation_factory().from_count(count)
    }}
    #[inline] pub fn from_duration(duration: ::rt::gen::windows::foundation::TimeSpan) -> Result<RepeatBehavior> { unsafe {
        <Self as RtActivatable<IRepeatBehaviorHelperStatics>>::get_activation_factory().from_duration(duration)
    }}
    #[inline] pub fn get_has_count(target: RepeatBehavior) -> Result<bool> { unsafe {
        <Self as RtActivatable<IRepeatBehaviorHelperStatics>>::get_activation_factory().get_has_count(target)
    }}
    #[inline] pub fn get_has_duration(target: RepeatBehavior) -> Result<bool> { unsafe {
        <Self as RtActivatable<IRepeatBehaviorHelperStatics>>::get_activation_factory().get_has_duration(target)
    }}
    #[inline] pub fn equals(target: RepeatBehavior, value: RepeatBehavior) -> Result<bool> { unsafe {
        <Self as RtActivatable<IRepeatBehaviorHelperStatics>>::get_activation_factory().equals(target, value)
    }}
}
DEFINE_CLSID!(RepeatBehaviorHelper(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,82,101,112,101,97,116,66,101,104,97,118,105,111,114,72,101,108,112,101,114,0]) [CLSID_RepeatBehaviorHelper]);
RT_CLASS!{class TransitionCollection: ::rt::gen::windows::foundation::collections::IVector<Transition>}
impl RtActivatable<IActivationFactory> for TransitionCollection {}
DEFINE_CLSID!(TransitionCollection(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,84,114,97,110,115,105,116,105,111,110,67,111,108,108,101,99,116,105,111,110,0]) [CLSID_TransitionCollection]);
RT_CLASS!{class DoubleKeyFrameCollection: ::rt::gen::windows::foundation::collections::IVector<DoubleKeyFrame>}
impl RtActivatable<IActivationFactory> for DoubleKeyFrameCollection {}
DEFINE_CLSID!(DoubleKeyFrameCollection(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,68,111,117,98,108,101,75,101,121,70,114,97,109,101,67,111,108,108,101,99,116,105,111,110,0]) [CLSID_DoubleKeyFrameCollection]);
RT_CLASS!{class ObjectKeyFrameCollection: ::rt::gen::windows::foundation::collections::IVector<ObjectKeyFrame>}
impl RtActivatable<IActivationFactory> for ObjectKeyFrameCollection {}
DEFINE_CLSID!(ObjectKeyFrameCollection(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,79,98,106,101,99,116,75,101,121,70,114,97,109,101,67,111,108,108,101,99,116,105,111,110,0]) [CLSID_ObjectKeyFrameCollection]);
RT_CLASS!{class TimelineCollection: ::rt::gen::windows::foundation::collections::IVector<Timeline>}
impl RtActivatable<IActivationFactory> for TimelineCollection {}
DEFINE_CLSID!(TimelineCollection(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,84,105,109,101,108,105,110,101,67,111,108,108,101,99,116,105,111,110,0]) [CLSID_TimelineCollection]);
DEFINE_IID!(IID_IDoubleKeyFrame, 1732531965, 59422, 20302, 180, 173, 10, 207, 237, 158, 205, 104);
RT_INTERFACE!{interface IDoubleKeyFrame(IDoubleKeyFrameVtbl): IInspectable(IInspectableVtbl) [IID_IDoubleKeyFrame] {
    fn get_Value(&self, out: *mut f64) -> HRESULT,
    fn put_Value(&self, value: f64) -> HRESULT,
    fn get_KeyTime(&self, out: *mut KeyTime) -> HRESULT,
    fn put_KeyTime(&self, value: KeyTime) -> HRESULT
}}
impl IDoubleKeyFrame {
    #[inline] pub unsafe fn get_value(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Value)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_value(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Value)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_key_time(&self) -> Result<KeyTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeyTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_key_time(&self, value: KeyTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_KeyTime)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDoubleKeyFrameStatics, 843465136, 32055, 17018, 173, 235, 67, 243, 139, 182, 26, 77);
RT_INTERFACE!{static interface IDoubleKeyFrameStatics(IDoubleKeyFrameStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDoubleKeyFrameStatics] {
    fn get_ValueProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_KeyTimeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IDoubleKeyFrameStatics {
    #[inline] pub unsafe fn get_value_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ValueProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_key_time_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeyTimeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDoubleKeyFrameFactory, 2895634115, 30008, 16569, 177, 82, 105, 111, 127, 191, 71, 34);
RT_INTERFACE!{interface IDoubleKeyFrameFactory(IDoubleKeyFrameFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IDoubleKeyFrameFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut DoubleKeyFrame) -> HRESULT
}}
impl IDoubleKeyFrameFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<DoubleKeyFrame>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class DoubleKeyFrame: IDoubleKeyFrame}
impl RtActivatable<IDoubleKeyFrameStatics> for DoubleKeyFrame {}
impl DoubleKeyFrame {
    #[inline] pub fn get_value_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDoubleKeyFrameStatics>>::get_activation_factory().get_value_property()
    }}
    #[inline] pub fn get_key_time_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDoubleKeyFrameStatics>>::get_activation_factory().get_key_time_property()
    }}
}
DEFINE_CLSID!(DoubleKeyFrame(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,68,111,117,98,108,101,75,101,121,70,114,97,109,101,0]) [CLSID_DoubleKeyFrame]);
DEFINE_IID!(IID_IEasingFunctionBase, 3238541375, 11266, 16721, 142, 205, 104, 221, 170, 63, 13, 155);
RT_INTERFACE!{interface IEasingFunctionBase(IEasingFunctionBaseVtbl): IInspectable(IInspectableVtbl) [IID_IEasingFunctionBase] {
    fn get_EasingMode(&self, out: *mut EasingMode) -> HRESULT,
    fn put_EasingMode(&self, value: EasingMode) -> HRESULT,
    fn Ease(&self, normalizedTime: f64, out: *mut f64) -> HRESULT
}}
impl IEasingFunctionBase {
    #[inline] pub unsafe fn get_easing_mode(&self) -> Result<EasingMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EasingMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_easing_mode(&self, value: EasingMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EasingMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn ease(&self, normalizedTime: f64) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Ease)(self as *const _ as *mut _, normalizedTime, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class EasingFunctionBase: IEasingFunctionBase}
impl RtActivatable<IEasingFunctionBaseStatics> for EasingFunctionBase {}
impl EasingFunctionBase {
    #[inline] pub fn get_easing_mode_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IEasingFunctionBaseStatics>>::get_activation_factory().get_easing_mode_property()
    }}
}
DEFINE_CLSID!(EasingFunctionBase(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,69,97,115,105,110,103,70,117,110,99,116,105,111,110,66,97,115,101,0]) [CLSID_EasingFunctionBase]);
DEFINE_IID!(IID_IEasingFunctionBaseStatics, 709898666, 11344, 18973, 187, 4, 215, 94, 7, 183, 21, 72);
RT_INTERFACE!{static interface IEasingFunctionBaseStatics(IEasingFunctionBaseStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IEasingFunctionBaseStatics] {
    fn get_EasingModeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IEasingFunctionBaseStatics {
    #[inline] pub unsafe fn get_easing_mode_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EasingModeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEasingFunctionBaseFactory, 405864042, 61467, 17376, 182, 31, 180, 82, 161, 198, 111, 210);
RT_INTERFACE!{interface IEasingFunctionBaseFactory(IEasingFunctionBaseFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IEasingFunctionBaseFactory] {
    
}}
DEFINE_IID!(IID_IKeySpline, 2007065531, 54730, 18994, 186, 11, 125, 255, 152, 142, 88, 160);
RT_INTERFACE!{interface IKeySpline(IKeySplineVtbl): IInspectable(IInspectableVtbl) [IID_IKeySpline] {
    fn get_ControlPoint1(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn put_ControlPoint1(&self, value: ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn get_ControlPoint2(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn put_ControlPoint2(&self, value: ::rt::gen::windows::foundation::Point) -> HRESULT
}}
impl IKeySpline {
    #[inline] pub unsafe fn get_control_point1(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ControlPoint1)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_control_point1(&self, value: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ControlPoint1)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_control_point2(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ControlPoint2)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_control_point2(&self, value: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ControlPoint2)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class KeySpline: IKeySpline}
impl RtActivatable<IActivationFactory> for KeySpline {}
DEFINE_CLSID!(KeySpline(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,75,101,121,83,112,108,105,110,101,0]) [CLSID_KeySpline]);
DEFINE_IID!(IID_INavigationTransitionInfo, 2846904465, 44618, 17266, 134, 37, 33, 183, 168, 185, 140, 164);
RT_INTERFACE!{interface INavigationTransitionInfo(INavigationTransitionInfoVtbl): IInspectable(IInspectableVtbl) [IID_INavigationTransitionInfo] {
    
}}
DEFINE_IID!(IID_INavigationTransitionInfoOverrides, 3645996650, 43472, 19447, 157, 176, 70, 51, 166, 157, 175, 242);
RT_INTERFACE!{interface INavigationTransitionInfoOverrides(INavigationTransitionInfoOverridesVtbl): IInspectable(IInspectableVtbl) [IID_INavigationTransitionInfoOverrides] {
    fn GetNavigationStateCore(&self, out: *mut HSTRING) -> HRESULT,
    fn SetNavigationStateCore(&self, navigationState: HSTRING) -> HRESULT
}}
impl INavigationTransitionInfoOverrides {
    #[inline] pub unsafe fn get_navigation_state_core(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetNavigationStateCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_navigation_state_core(&self, navigationState: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetNavigationStateCore)(self as *const _ as *mut _, navigationState.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_INavigationTransitionInfoFactory, 3992254677, 44899, 20395, 157, 74, 135, 146, 127, 130, 221, 107);
RT_INTERFACE!{interface INavigationTransitionInfoFactory(INavigationTransitionInfoFactoryVtbl): IInspectable(IInspectableVtbl) [IID_INavigationTransitionInfoFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut NavigationTransitionInfo) -> HRESULT
}}
impl INavigationTransitionInfoFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<NavigationTransitionInfo>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class NavigationTransitionInfo: INavigationTransitionInfo}
DEFINE_IID!(IID_IObjectKeyFrame, 2555553873, 34195, 18670, 166, 164, 213, 212, 114, 15, 2, 154);
RT_INTERFACE!{interface IObjectKeyFrame(IObjectKeyFrameVtbl): IInspectable(IInspectableVtbl) [IID_IObjectKeyFrame] {
    fn get_Value(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Value(&self, value: *mut IInspectable) -> HRESULT,
    fn get_KeyTime(&self, out: *mut KeyTime) -> HRESULT,
    fn put_KeyTime(&self, value: KeyTime) -> HRESULT
}}
impl IObjectKeyFrame {
    #[inline] pub unsafe fn get_value(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Value)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_value(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Value)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_key_time(&self) -> Result<KeyTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeyTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_key_time(&self, value: KeyTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_KeyTime)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IObjectKeyFrameStatics, 752265984, 21273, 17030, 142, 237, 78, 117, 94, 160, 207, 156);
RT_INTERFACE!{static interface IObjectKeyFrameStatics(IObjectKeyFrameStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IObjectKeyFrameStatics] {
    fn get_ValueProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_KeyTimeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IObjectKeyFrameStatics {
    #[inline] pub unsafe fn get_value_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ValueProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_key_time_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeyTimeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IObjectKeyFrameFactory, 371594302, 15981, 17624, 155, 154, 4, 174, 167, 15, 132, 146);
RT_INTERFACE!{interface IObjectKeyFrameFactory(IObjectKeyFrameFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IObjectKeyFrameFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ObjectKeyFrame) -> HRESULT
}}
impl IObjectKeyFrameFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ObjectKeyFrame>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class ObjectKeyFrame: IObjectKeyFrame}
impl RtActivatable<IObjectKeyFrameStatics> for ObjectKeyFrame {}
impl ObjectKeyFrame {
    #[inline] pub fn get_value_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IObjectKeyFrameStatics>>::get_activation_factory().get_value_property()
    }}
    #[inline] pub fn get_key_time_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IObjectKeyFrameStatics>>::get_activation_factory().get_key_time_property()
    }}
}
DEFINE_CLSID!(ObjectKeyFrame(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,79,98,106,101,99,116,75,101,121,70,114,97,109,101,0]) [CLSID_ObjectKeyFrame]);
DEFINE_IID!(IID_ITimeline, 197420508, 48717, 19725, 149, 73, 34, 8, 183, 21, 244, 13);
RT_INTERFACE!{interface ITimeline(ITimelineVtbl): IInspectable(IInspectableVtbl) [IID_ITimeline] {
    fn get_AutoReverse(&self, out: *mut bool) -> HRESULT,
    fn put_AutoReverse(&self, value: bool) -> HRESULT,
    fn get_BeginTime(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::TimeSpan>) -> HRESULT,
    fn put_BeginTime(&self, value: *mut ::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::TimeSpan>) -> HRESULT,
    fn get_Duration(&self, out: *mut super::super::Duration) -> HRESULT,
    fn put_Duration(&self, value: super::super::Duration) -> HRESULT,
    fn get_SpeedRatio(&self, out: *mut f64) -> HRESULT,
    fn put_SpeedRatio(&self, value: f64) -> HRESULT,
    fn get_FillBehavior(&self, out: *mut FillBehavior) -> HRESULT,
    fn put_FillBehavior(&self, value: FillBehavior) -> HRESULT,
    fn get_RepeatBehavior(&self, out: *mut RepeatBehavior) -> HRESULT,
    fn put_RepeatBehavior(&self, value: RepeatBehavior) -> HRESULT,
    fn add_Completed(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Completed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl ITimeline {
    #[inline] pub unsafe fn get_auto_reverse(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AutoReverse)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_auto_reverse(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AutoReverse)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_begin_time(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::TimeSpan>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BeginTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_begin_time(&self, value: &::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::TimeSpan>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BeginTime)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_duration(&self) -> Result<super::super::Duration> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Duration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_duration(&self, value: super::super::Duration) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Duration)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_speed_ratio(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SpeedRatio)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_speed_ratio(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SpeedRatio)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_fill_behavior(&self) -> Result<FillBehavior> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FillBehavior)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_fill_behavior(&self, value: FillBehavior) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FillBehavior)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_repeat_behavior(&self) -> Result<RepeatBehavior> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RepeatBehavior)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_repeat_behavior(&self, value: RepeatBehavior) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RepeatBehavior)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_completed(&self, value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Completed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_completed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Completed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITimelineStatics, 2835541326, 61200, 19823, 154, 64, 147, 203, 136, 149, 244, 229);
RT_INTERFACE!{static interface ITimelineStatics(ITimelineStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ITimelineStatics] {
    fn get_AllowDependentAnimations(&self, out: *mut bool) -> HRESULT,
    fn put_AllowDependentAnimations(&self, value: bool) -> HRESULT,
    fn get_AutoReverseProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_BeginTimeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_DurationProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_SpeedRatioProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_FillBehaviorProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_RepeatBehaviorProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl ITimelineStatics {
    #[inline] pub unsafe fn get_allow_dependent_animations(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AllowDependentAnimations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_allow_dependent_animations(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AllowDependentAnimations)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_auto_reverse_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AutoReverseProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_begin_time_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BeginTimeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_duration_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DurationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_speed_ratio_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SpeedRatioProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_fill_behavior_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FillBehaviorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_repeat_behavior_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RepeatBehaviorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITimelineFactory, 492223239, 48548, 18315, 138, 218, 235, 4, 213, 128, 205, 94);
RT_INTERFACE!{interface ITimelineFactory(ITimelineFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ITimelineFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut Timeline) -> HRESULT
}}
impl ITimelineFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<Timeline>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class Timeline: ITimeline}
impl RtActivatable<ITimelineStatics> for Timeline {}
impl Timeline {
    #[inline] pub fn get_allow_dependent_animations() -> Result<bool> { unsafe {
        <Self as RtActivatable<ITimelineStatics>>::get_activation_factory().get_allow_dependent_animations()
    }}
    #[inline] pub fn set_allow_dependent_animations(value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ITimelineStatics>>::get_activation_factory().set_allow_dependent_animations(value)
    }}
    #[inline] pub fn get_auto_reverse_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITimelineStatics>>::get_activation_factory().get_auto_reverse_property()
    }}
    #[inline] pub fn get_begin_time_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITimelineStatics>>::get_activation_factory().get_begin_time_property()
    }}
    #[inline] pub fn get_duration_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITimelineStatics>>::get_activation_factory().get_duration_property()
    }}
    #[inline] pub fn get_speed_ratio_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITimelineStatics>>::get_activation_factory().get_speed_ratio_property()
    }}
    #[inline] pub fn get_fill_behavior_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITimelineStatics>>::get_activation_factory().get_fill_behavior_property()
    }}
    #[inline] pub fn get_repeat_behavior_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ITimelineStatics>>::get_activation_factory().get_repeat_behavior_property()
    }}
}
DEFINE_CLSID!(Timeline(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,84,105,109,101,108,105,110,101,0]) [CLSID_Timeline]);
DEFINE_IID!(IID_ITransition, 1013415036, 464, 19918, 179, 51, 151, 111, 147, 49, 43, 8);
RT_INTERFACE!{interface ITransition(ITransitionVtbl): IInspectable(IInspectableVtbl) [IID_ITransition] {
    
}}
DEFINE_IID!(IID_ITransitionFactory, 3701125839, 15305, 17578, 179, 252, 136, 58, 131, 35, 58, 44);
RT_INTERFACE!{interface ITransitionFactory(ITransitionFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ITransitionFactory] {
    
}}
RT_CLASS!{class Transition: ITransition}
DEFINE_IID!(IID_IAddDeleteThemeTransition, 2917958958, 17444, 19883, 153, 193, 58, 4, 227, 106, 60, 72);
RT_INTERFACE!{interface IAddDeleteThemeTransition(IAddDeleteThemeTransitionVtbl): IInspectable(IInspectableVtbl) [IID_IAddDeleteThemeTransition] {
    
}}
RT_CLASS!{class AddDeleteThemeTransition: IAddDeleteThemeTransition}
impl RtActivatable<IActivationFactory> for AddDeleteThemeTransition {}
DEFINE_CLSID!(AddDeleteThemeTransition(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,65,100,100,68,101,108,101,116,101,84,104,101,109,101,84,114,97,110,115,105,116,105,111,110,0]) [CLSID_AddDeleteThemeTransition]);
DEFINE_IID!(IID_IBackEase, 3833042663, 63493, 19087, 129, 201, 56, 230, 71, 44, 170, 148);
RT_INTERFACE!{interface IBackEase(IBackEaseVtbl): IInspectable(IInspectableVtbl) [IID_IBackEase] {
    fn get_Amplitude(&self, out: *mut f64) -> HRESULT,
    fn put_Amplitude(&self, value: f64) -> HRESULT
}}
impl IBackEase {
    #[inline] pub unsafe fn get_amplitude(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Amplitude)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_amplitude(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Amplitude)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBackEaseStatics, 1014014719, 41120, 18310, 146, 108, 34, 50, 31, 143, 37, 183);
RT_INTERFACE!{static interface IBackEaseStatics(IBackEaseStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBackEaseStatics] {
    fn get_AmplitudeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IBackEaseStatics {
    #[inline] pub unsafe fn get_amplitude_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AmplitudeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class BackEase: IBackEase}
impl RtActivatable<IBackEaseStatics> for BackEase {}
impl RtActivatable<IActivationFactory> for BackEase {}
impl BackEase {
    #[inline] pub fn get_amplitude_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBackEaseStatics>>::get_activation_factory().get_amplitude_property()
    }}
}
DEFINE_CLSID!(BackEase(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,66,97,99,107,69,97,115,101,0]) [CLSID_BackEase]);
DEFINE_IID!(IID_IBeginStoryboard, 1679335373, 18924, 20050, 166, 246, 85, 50, 76, 146, 16, 83);
RT_INTERFACE!{interface IBeginStoryboard(IBeginStoryboardVtbl): IInspectable(IInspectableVtbl) [IID_IBeginStoryboard] {
    fn get_Storyboard(&self, out: *mut *mut Storyboard) -> HRESULT,
    fn put_Storyboard(&self, value: *mut Storyboard) -> HRESULT
}}
impl IBeginStoryboard {
    #[inline] pub unsafe fn get_storyboard(&self) -> Result<ComPtr<Storyboard>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Storyboard)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_storyboard(&self, value: &Storyboard) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Storyboard)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBeginStoryboardStatics, 315617676, 43665, 19530, 184, 47, 223, 52, 252, 87, 249, 75);
RT_INTERFACE!{static interface IBeginStoryboardStatics(IBeginStoryboardStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBeginStoryboardStatics] {
    fn get_StoryboardProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IBeginStoryboardStatics {
    #[inline] pub unsafe fn get_storyboard_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StoryboardProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class BeginStoryboard: IBeginStoryboard}
impl RtActivatable<IBeginStoryboardStatics> for BeginStoryboard {}
impl RtActivatable<IActivationFactory> for BeginStoryboard {}
impl BeginStoryboard {
    #[inline] pub fn get_storyboard_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBeginStoryboardStatics>>::get_activation_factory().get_storyboard_property()
    }}
}
DEFINE_CLSID!(BeginStoryboard(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,66,101,103,105,110,83,116,111,114,121,98,111,97,114,100,0]) [CLSID_BeginStoryboard]);
DEFINE_IID!(IID_IBounceEase, 737232462, 64625, 18413, 133, 161, 59, 169, 87, 119, 24, 180);
RT_INTERFACE!{interface IBounceEase(IBounceEaseVtbl): IInspectable(IInspectableVtbl) [IID_IBounceEase] {
    fn get_Bounces(&self, out: *mut i32) -> HRESULT,
    fn put_Bounces(&self, value: i32) -> HRESULT,
    fn get_Bounciness(&self, out: *mut f64) -> HRESULT,
    fn put_Bounciness(&self, value: f64) -> HRESULT
}}
impl IBounceEase {
    #[inline] pub unsafe fn get_bounces(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Bounces)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_bounces(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Bounces)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_bounciness(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Bounciness)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_bounciness(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Bounciness)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBounceEaseStatics, 3228573090, 20339, 16841, 178, 203, 46, 163, 16, 81, 7, 255);
RT_INTERFACE!{static interface IBounceEaseStatics(IBounceEaseStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBounceEaseStatics] {
    fn get_BouncesProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_BouncinessProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IBounceEaseStatics {
    #[inline] pub unsafe fn get_bounces_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BouncesProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_bounciness_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BouncinessProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class BounceEase: IBounceEase}
impl RtActivatable<IBounceEaseStatics> for BounceEase {}
impl RtActivatable<IActivationFactory> for BounceEase {}
impl BounceEase {
    #[inline] pub fn get_bounces_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBounceEaseStatics>>::get_activation_factory().get_bounces_property()
    }}
    #[inline] pub fn get_bounciness_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBounceEaseStatics>>::get_activation_factory().get_bounciness_property()
    }}
}
DEFINE_CLSID!(BounceEase(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,66,111,117,110,99,101,69,97,115,101,0]) [CLSID_BounceEase]);
DEFINE_IID!(IID_ICircleEase, 1403239858, 37239, 20078, 160, 67, 80, 130, 216, 137, 171, 31);
RT_INTERFACE!{interface ICircleEase(ICircleEaseVtbl): IInspectable(IInspectableVtbl) [IID_ICircleEase] {
    
}}
RT_CLASS!{class CircleEase: ICircleEase}
impl RtActivatable<IActivationFactory> for CircleEase {}
DEFINE_CLSID!(CircleEase(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,67,105,114,99,108,101,69,97,115,101,0]) [CLSID_CircleEase]);
DEFINE_IID!(IID_IColorAnimation, 3098446357, 3939, 18068, 148, 103, 189, 175, 172, 18, 83, 234);
RT_INTERFACE!{interface IColorAnimation(IColorAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IColorAnimation] {
    #[cfg(not(feature="windows-ui"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_From(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<super::super::super::Color>) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_From(&self, value: *mut ::rt::gen::windows::foundation::IReference<super::super::super::Color>) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_To(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<super::super::super::Color>) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_To(&self, value: *mut ::rt::gen::windows::foundation::IReference<super::super::super::Color>) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_By(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<super::super::super::Color>) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_By(&self, value: *mut ::rt::gen::windows::foundation::IReference<super::super::super::Color>) -> HRESULT,
    fn get_EasingFunction(&self, out: *mut *mut EasingFunctionBase) -> HRESULT,
    fn put_EasingFunction(&self, value: *mut EasingFunctionBase) -> HRESULT,
    fn get_EnableDependentAnimation(&self, out: *mut bool) -> HRESULT,
    fn put_EnableDependentAnimation(&self, value: bool) -> HRESULT
}}
impl IColorAnimation {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_from(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<super::super::super::Color>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_From)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_from(&self, value: &::rt::gen::windows::foundation::IReference<super::super::super::Color>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_From)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_to(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<super::super::super::Color>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_To)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_to(&self, value: &::rt::gen::windows::foundation::IReference<super::super::super::Color>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_To)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_by(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<super::super::super::Color>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_By)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_by(&self, value: &::rt::gen::windows::foundation::IReference<super::super::super::Color>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_By)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_easing_function(&self) -> Result<ComPtr<EasingFunctionBase>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EasingFunction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_easing_function(&self, value: &EasingFunctionBase) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EasingFunction)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_enable_dependent_animation(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EnableDependentAnimation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_enable_dependent_animation(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EnableDependentAnimation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IColorAnimationStatics, 1441461986, 34787, 20296, 149, 143, 133, 91, 47, 158, 169, 236);
RT_INTERFACE!{static interface IColorAnimationStatics(IColorAnimationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IColorAnimationStatics] {
    fn get_FromProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ToProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ByProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_EasingFunctionProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_EnableDependentAnimationProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IColorAnimationStatics {
    #[inline] pub unsafe fn get_from_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FromProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_to_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ToProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_by_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ByProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_easing_function_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EasingFunctionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_enable_dependent_animation_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EnableDependentAnimationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ColorAnimation: IColorAnimation}
impl RtActivatable<IColorAnimationStatics> for ColorAnimation {}
impl RtActivatable<IActivationFactory> for ColorAnimation {}
impl ColorAnimation {
    #[inline] pub fn get_from_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IColorAnimationStatics>>::get_activation_factory().get_from_property()
    }}
    #[inline] pub fn get_to_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IColorAnimationStatics>>::get_activation_factory().get_to_property()
    }}
    #[inline] pub fn get_by_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IColorAnimationStatics>>::get_activation_factory().get_by_property()
    }}
    #[inline] pub fn get_easing_function_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IColorAnimationStatics>>::get_activation_factory().get_easing_function_property()
    }}
    #[inline] pub fn get_enable_dependent_animation_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IColorAnimationStatics>>::get_activation_factory().get_enable_dependent_animation_property()
    }}
}
DEFINE_CLSID!(ColorAnimation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,67,111,108,111,114,65,110,105,109,97,116,105,111,110,0]) [CLSID_ColorAnimation]);
DEFINE_IID!(IID_IContentThemeTransition, 4134520259, 22805, 17277, 142, 59, 173, 248, 231, 240, 171, 87);
RT_INTERFACE!{interface IContentThemeTransition(IContentThemeTransitionVtbl): IInspectable(IInspectableVtbl) [IID_IContentThemeTransition] {
    fn get_HorizontalOffset(&self, out: *mut f64) -> HRESULT,
    fn put_HorizontalOffset(&self, value: f64) -> HRESULT,
    fn get_VerticalOffset(&self, out: *mut f64) -> HRESULT,
    fn put_VerticalOffset(&self, value: f64) -> HRESULT
}}
impl IContentThemeTransition {
    #[inline] pub unsafe fn get_horizontal_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_horizontal_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HorizontalOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_vertical_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_VerticalOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContentThemeTransitionStatics, 244245381, 39490, 17497, 175, 169, 51, 125, 196, 30, 21, 135);
RT_INTERFACE!{static interface IContentThemeTransitionStatics(IContentThemeTransitionStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IContentThemeTransitionStatics] {
    fn get_HorizontalOffsetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_VerticalOffsetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IContentThemeTransitionStatics {
    #[inline] pub unsafe fn get_horizontal_offset_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HorizontalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_offset_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VerticalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContentThemeTransition: IContentThemeTransition}
impl RtActivatable<IContentThemeTransitionStatics> for ContentThemeTransition {}
impl RtActivatable<IActivationFactory> for ContentThemeTransition {}
impl ContentThemeTransition {
    #[inline] pub fn get_horizontal_offset_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentThemeTransitionStatics>>::get_activation_factory().get_horizontal_offset_property()
    }}
    #[inline] pub fn get_vertical_offset_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContentThemeTransitionStatics>>::get_activation_factory().get_vertical_offset_property()
    }}
}
DEFINE_CLSID!(ContentThemeTransition(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,67,111,110,116,101,110,116,84,104,101,109,101,84,114,97,110,115,105,116,105,111,110,0]) [CLSID_ContentThemeTransition]);
DEFINE_IID!(IID_ICubicEase, 462748790, 56023, 17236, 177, 162, 121, 105, 251, 246, 167, 13);
RT_INTERFACE!{interface ICubicEase(ICubicEaseVtbl): IInspectable(IInspectableVtbl) [IID_ICubicEase] {
    
}}
RT_CLASS!{class CubicEase: ICubicEase}
impl RtActivatable<IActivationFactory> for CubicEase {}
DEFINE_CLSID!(CubicEase(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,67,117,98,105,99,69,97,115,101,0]) [CLSID_CubicEase]);
DEFINE_IID!(IID_IDiscreteDoubleKeyFrame, 4126482234, 44305, 18894, 142, 28, 8, 253, 241, 68, 116, 70);
RT_INTERFACE!{interface IDiscreteDoubleKeyFrame(IDiscreteDoubleKeyFrameVtbl): IInspectable(IInspectableVtbl) [IID_IDiscreteDoubleKeyFrame] {
    
}}
RT_CLASS!{class DiscreteDoubleKeyFrame: IDiscreteDoubleKeyFrame}
impl RtActivatable<IActivationFactory> for DiscreteDoubleKeyFrame {}
DEFINE_CLSID!(DiscreteDoubleKeyFrame(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,68,105,115,99,114,101,116,101,68,111,117,98,108,101,75,101,121,70,114,97,109,101,0]) [CLSID_DiscreteDoubleKeyFrame]);
DEFINE_IID!(IID_IDiscreteObjectKeyFrame, 3353140873, 61741, 19100, 129, 153, 231, 169, 236, 227, 164, 115);
RT_INTERFACE!{interface IDiscreteObjectKeyFrame(IDiscreteObjectKeyFrameVtbl): IInspectable(IInspectableVtbl) [IID_IDiscreteObjectKeyFrame] {
    
}}
RT_CLASS!{class DiscreteObjectKeyFrame: IDiscreteObjectKeyFrame}
impl RtActivatable<IActivationFactory> for DiscreteObjectKeyFrame {}
DEFINE_CLSID!(DiscreteObjectKeyFrame(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,68,105,115,99,114,101,116,101,79,98,106,101,99,116,75,101,121,70,114,97,109,101,0]) [CLSID_DiscreteObjectKeyFrame]);
DEFINE_IID!(IID_IDoubleAnimation, 2124365145, 3847, 19401, 151, 125, 3, 118, 63, 248, 21, 79);
RT_INTERFACE!{interface IDoubleAnimation(IDoubleAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IDoubleAnimation] {
    fn get_From(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<f64>) -> HRESULT,
    fn put_From(&self, value: *mut ::rt::gen::windows::foundation::IReference<f64>) -> HRESULT,
    fn get_To(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<f64>) -> HRESULT,
    fn put_To(&self, value: *mut ::rt::gen::windows::foundation::IReference<f64>) -> HRESULT,
    fn get_By(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<f64>) -> HRESULT,
    fn put_By(&self, value: *mut ::rt::gen::windows::foundation::IReference<f64>) -> HRESULT,
    fn get_EasingFunction(&self, out: *mut *mut EasingFunctionBase) -> HRESULT,
    fn put_EasingFunction(&self, value: *mut EasingFunctionBase) -> HRESULT,
    fn get_EnableDependentAnimation(&self, out: *mut bool) -> HRESULT,
    fn put_EnableDependentAnimation(&self, value: bool) -> HRESULT
}}
impl IDoubleAnimation {
    #[inline] pub unsafe fn get_from(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<f64>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_From)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_from(&self, value: &::rt::gen::windows::foundation::IReference<f64>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_From)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_to(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<f64>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_To)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_to(&self, value: &::rt::gen::windows::foundation::IReference<f64>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_To)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_by(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<f64>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_By)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_by(&self, value: &::rt::gen::windows::foundation::IReference<f64>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_By)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_easing_function(&self) -> Result<ComPtr<EasingFunctionBase>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EasingFunction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_easing_function(&self, value: &EasingFunctionBase) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EasingFunction)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_enable_dependent_animation(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EnableDependentAnimation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_enable_dependent_animation(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EnableDependentAnimation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDoubleAnimationStatics, 3799683933, 61713, 17335, 184, 36, 131, 43, 88, 215, 120, 107);
RT_INTERFACE!{static interface IDoubleAnimationStatics(IDoubleAnimationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDoubleAnimationStatics] {
    fn get_FromProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ToProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ByProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_EasingFunctionProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_EnableDependentAnimationProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IDoubleAnimationStatics {
    #[inline] pub unsafe fn get_from_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FromProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_to_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ToProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_by_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ByProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_easing_function_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EasingFunctionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_enable_dependent_animation_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EnableDependentAnimationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class DoubleAnimation: IDoubleAnimation}
impl RtActivatable<IDoubleAnimationStatics> for DoubleAnimation {}
impl RtActivatable<IActivationFactory> for DoubleAnimation {}
impl DoubleAnimation {
    #[inline] pub fn get_from_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDoubleAnimationStatics>>::get_activation_factory().get_from_property()
    }}
    #[inline] pub fn get_to_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDoubleAnimationStatics>>::get_activation_factory().get_to_property()
    }}
    #[inline] pub fn get_by_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDoubleAnimationStatics>>::get_activation_factory().get_by_property()
    }}
    #[inline] pub fn get_easing_function_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDoubleAnimationStatics>>::get_activation_factory().get_easing_function_property()
    }}
    #[inline] pub fn get_enable_dependent_animation_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDoubleAnimationStatics>>::get_activation_factory().get_enable_dependent_animation_property()
    }}
}
DEFINE_CLSID!(DoubleAnimation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,68,111,117,98,108,101,65,110,105,109,97,116,105,111,110,0]) [CLSID_DoubleAnimation]);
DEFINE_IID!(IID_IDoubleAnimationUsingKeyFrames, 1341022863, 49134, 20341, 131, 194, 169, 59, 57, 72, 132, 115);
RT_INTERFACE!{interface IDoubleAnimationUsingKeyFrames(IDoubleAnimationUsingKeyFramesVtbl): IInspectable(IInspectableVtbl) [IID_IDoubleAnimationUsingKeyFrames] {
    fn get_KeyFrames(&self, out: *mut *mut DoubleKeyFrameCollection) -> HRESULT,
    fn get_EnableDependentAnimation(&self, out: *mut bool) -> HRESULT,
    fn put_EnableDependentAnimation(&self, value: bool) -> HRESULT
}}
impl IDoubleAnimationUsingKeyFrames {
    #[inline] pub unsafe fn get_key_frames(&self) -> Result<ComPtr<DoubleKeyFrameCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeyFrames)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_enable_dependent_animation(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EnableDependentAnimation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_enable_dependent_animation(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EnableDependentAnimation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDoubleAnimationUsingKeyFramesStatics, 278655734, 50703, 18858, 171, 246, 246, 150, 212, 146, 17, 107);
RT_INTERFACE!{static interface IDoubleAnimationUsingKeyFramesStatics(IDoubleAnimationUsingKeyFramesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDoubleAnimationUsingKeyFramesStatics] {
    fn get_EnableDependentAnimationProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IDoubleAnimationUsingKeyFramesStatics {
    #[inline] pub unsafe fn get_enable_dependent_animation_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EnableDependentAnimationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class DoubleAnimationUsingKeyFrames: IDoubleAnimationUsingKeyFrames}
impl RtActivatable<IDoubleAnimationUsingKeyFramesStatics> for DoubleAnimationUsingKeyFrames {}
impl RtActivatable<IActivationFactory> for DoubleAnimationUsingKeyFrames {}
impl DoubleAnimationUsingKeyFrames {
    #[inline] pub fn get_enable_dependent_animation_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDoubleAnimationUsingKeyFramesStatics>>::get_activation_factory().get_enable_dependent_animation_property()
    }}
}
DEFINE_CLSID!(DoubleAnimationUsingKeyFrames(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,68,111,117,98,108,101,65,110,105,109,97,116,105,111,110,85,115,105,110,103,75,101,121,70,114,97,109,101,115,0]) [CLSID_DoubleAnimationUsingKeyFrames]);
DEFINE_IID!(IID_IEasingDoubleKeyFrame, 2522536845, 39508, 16648, 180, 255, 181, 165, 33, 44, 179, 56);
RT_INTERFACE!{interface IEasingDoubleKeyFrame(IEasingDoubleKeyFrameVtbl): IInspectable(IInspectableVtbl) [IID_IEasingDoubleKeyFrame] {
    fn get_EasingFunction(&self, out: *mut *mut EasingFunctionBase) -> HRESULT,
    fn put_EasingFunction(&self, value: *mut EasingFunctionBase) -> HRESULT
}}
impl IEasingDoubleKeyFrame {
    #[inline] pub unsafe fn get_easing_function(&self) -> Result<ComPtr<EasingFunctionBase>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EasingFunction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_easing_function(&self, value: &EasingFunctionBase) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EasingFunction)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEasingDoubleKeyFrameStatics, 3369326661, 56238, 20059, 139, 132, 217, 83, 115, 152, 229, 177);
RT_INTERFACE!{static interface IEasingDoubleKeyFrameStatics(IEasingDoubleKeyFrameStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IEasingDoubleKeyFrameStatics] {
    fn get_EasingFunctionProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IEasingDoubleKeyFrameStatics {
    #[inline] pub unsafe fn get_easing_function_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EasingFunctionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EasingDoubleKeyFrame: IEasingDoubleKeyFrame}
impl RtActivatable<IEasingDoubleKeyFrameStatics> for EasingDoubleKeyFrame {}
impl RtActivatable<IActivationFactory> for EasingDoubleKeyFrame {}
impl EasingDoubleKeyFrame {
    #[inline] pub fn get_easing_function_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IEasingDoubleKeyFrameStatics>>::get_activation_factory().get_easing_function_property()
    }}
}
DEFINE_CLSID!(EasingDoubleKeyFrame(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,69,97,115,105,110,103,68,111,117,98,108,101,75,101,121,70,114,97,109,101,0]) [CLSID_EasingDoubleKeyFrame]);
DEFINE_IID!(IID_IEdgeUIThemeTransition, 1552335259, 18903, 6636, 207, 25, 131, 167, 60, 109, 231, 94);
RT_INTERFACE!{interface IEdgeUIThemeTransition(IEdgeUIThemeTransitionVtbl): IInspectable(IInspectableVtbl) [IID_IEdgeUIThemeTransition] {
    fn get_Edge(&self, out: *mut super::super::controls::primitives::EdgeTransitionLocation) -> HRESULT,
    fn put_Edge(&self, value: super::super::controls::primitives::EdgeTransitionLocation) -> HRESULT
}}
impl IEdgeUIThemeTransition {
    #[inline] pub unsafe fn get_edge(&self) -> Result<super::super::controls::primitives::EdgeTransitionLocation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Edge)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_edge(&self, value: super::super::controls::primitives::EdgeTransitionLocation) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Edge)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEdgeUIThemeTransitionStatics, 379760955, 18181, 12331, 39, 198, 42, 172, 146, 246, 69, 172);
RT_INTERFACE!{static interface IEdgeUIThemeTransitionStatics(IEdgeUIThemeTransitionStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IEdgeUIThemeTransitionStatics] {
    fn get_EdgeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IEdgeUIThemeTransitionStatics {
    #[inline] pub unsafe fn get_edge_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EdgeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EdgeUIThemeTransition: IEdgeUIThemeTransition}
impl RtActivatable<IEdgeUIThemeTransitionStatics> for EdgeUIThemeTransition {}
impl RtActivatable<IActivationFactory> for EdgeUIThemeTransition {}
impl EdgeUIThemeTransition {
    #[inline] pub fn get_edge_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IEdgeUIThemeTransitionStatics>>::get_activation_factory().get_edge_property()
    }}
}
DEFINE_CLSID!(EdgeUIThemeTransition(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,69,100,103,101,85,73,84,104,101,109,101,84,114,97,110,115,105,116,105,111,110,0]) [CLSID_EdgeUIThemeTransition]);
DEFINE_IID!(IID_IElasticEase, 4015760780, 45238, 19052, 156, 168, 251, 66, 51, 241, 36, 89);
RT_INTERFACE!{interface IElasticEase(IElasticEaseVtbl): IInspectable(IInspectableVtbl) [IID_IElasticEase] {
    fn get_Oscillations(&self, out: *mut i32) -> HRESULT,
    fn put_Oscillations(&self, value: i32) -> HRESULT,
    fn get_Springiness(&self, out: *mut f64) -> HRESULT,
    fn put_Springiness(&self, value: f64) -> HRESULT
}}
impl IElasticEase {
    #[inline] pub unsafe fn get_oscillations(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Oscillations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_oscillations(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Oscillations)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_springiness(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Springiness)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_springiness(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Springiness)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IElasticEaseStatics, 2851432172, 65180, 19243, 142, 82, 187, 120, 93, 86, 33, 133);
RT_INTERFACE!{static interface IElasticEaseStatics(IElasticEaseStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IElasticEaseStatics] {
    fn get_OscillationsProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_SpringinessProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IElasticEaseStatics {
    #[inline] pub unsafe fn get_oscillations_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OscillationsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_springiness_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SpringinessProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ElasticEase: IElasticEase}
impl RtActivatable<IElasticEaseStatics> for ElasticEase {}
impl RtActivatable<IActivationFactory> for ElasticEase {}
impl ElasticEase {
    #[inline] pub fn get_oscillations_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IElasticEaseStatics>>::get_activation_factory().get_oscillations_property()
    }}
    #[inline] pub fn get_springiness_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IElasticEaseStatics>>::get_activation_factory().get_springiness_property()
    }}
}
DEFINE_CLSID!(ElasticEase(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,69,108,97,115,116,105,99,69,97,115,101,0]) [CLSID_ElasticEase]);
DEFINE_IID!(IID_IEntranceThemeTransition, 124357641, 43235, 16794, 160, 29, 116, 16, 160, 174, 142, 200);
RT_INTERFACE!{interface IEntranceThemeTransition(IEntranceThemeTransitionVtbl): IInspectable(IInspectableVtbl) [IID_IEntranceThemeTransition] {
    fn get_FromHorizontalOffset(&self, out: *mut f64) -> HRESULT,
    fn put_FromHorizontalOffset(&self, value: f64) -> HRESULT,
    fn get_FromVerticalOffset(&self, out: *mut f64) -> HRESULT,
    fn put_FromVerticalOffset(&self, value: f64) -> HRESULT,
    fn get_IsStaggeringEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsStaggeringEnabled(&self, value: bool) -> HRESULT
}}
impl IEntranceThemeTransition {
    #[inline] pub unsafe fn get_from_horizontal_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FromHorizontalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_from_horizontal_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FromHorizontalOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_from_vertical_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FromVerticalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_from_vertical_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FromVerticalOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_staggering_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsStaggeringEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_staggering_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsStaggeringEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEntranceThemeTransitionStatics, 936117623, 65432, 19181, 184, 110, 94, 194, 55, 2, 248, 119);
RT_INTERFACE!{static interface IEntranceThemeTransitionStatics(IEntranceThemeTransitionStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IEntranceThemeTransitionStatics] {
    fn get_FromHorizontalOffsetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_FromVerticalOffsetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_IsStaggeringEnabledProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IEntranceThemeTransitionStatics {
    #[inline] pub unsafe fn get_from_horizontal_offset_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FromHorizontalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_from_vertical_offset_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FromVerticalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_staggering_enabled_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsStaggeringEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EntranceThemeTransition: IEntranceThemeTransition}
impl RtActivatable<IEntranceThemeTransitionStatics> for EntranceThemeTransition {}
impl RtActivatable<IActivationFactory> for EntranceThemeTransition {}
impl EntranceThemeTransition {
    #[inline] pub fn get_from_horizontal_offset_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IEntranceThemeTransitionStatics>>::get_activation_factory().get_from_horizontal_offset_property()
    }}
    #[inline] pub fn get_from_vertical_offset_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IEntranceThemeTransitionStatics>>::get_activation_factory().get_from_vertical_offset_property()
    }}
    #[inline] pub fn get_is_staggering_enabled_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IEntranceThemeTransitionStatics>>::get_activation_factory().get_is_staggering_enabled_property()
    }}
}
DEFINE_CLSID!(EntranceThemeTransition(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,69,110,116,114,97,110,99,101,84,104,101,109,101,84,114,97,110,115,105,116,105,111,110,0]) [CLSID_EntranceThemeTransition]);
DEFINE_IID!(IID_IExponentialEase, 2092557341, 61627, 19402, 157, 165, 155, 163, 161, 23, 52, 196);
RT_INTERFACE!{interface IExponentialEase(IExponentialEaseVtbl): IInspectable(IInspectableVtbl) [IID_IExponentialEase] {
    fn get_Exponent(&self, out: *mut f64) -> HRESULT,
    fn put_Exponent(&self, value: f64) -> HRESULT
}}
impl IExponentialEase {
    #[inline] pub unsafe fn get_exponent(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Exponent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_exponent(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Exponent)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IExponentialEaseStatics, 4085180387, 42849, 17234, 154, 214, 112, 121, 69, 103, 88, 26);
RT_INTERFACE!{static interface IExponentialEaseStatics(IExponentialEaseStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IExponentialEaseStatics] {
    fn get_ExponentProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IExponentialEaseStatics {
    #[inline] pub unsafe fn get_exponent_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExponentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ExponentialEase: IExponentialEase}
impl RtActivatable<IExponentialEaseStatics> for ExponentialEase {}
impl RtActivatable<IActivationFactory> for ExponentialEase {}
impl ExponentialEase {
    #[inline] pub fn get_exponent_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IExponentialEaseStatics>>::get_activation_factory().get_exponent_property()
    }}
}
DEFINE_CLSID!(ExponentialEase(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,69,120,112,111,110,101,110,116,105,97,108,69,97,115,101,0]) [CLSID_ExponentialEase]);
DEFINE_IID!(IID_ILinearDoubleKeyFrame, 2399007333, 39547, 17181, 143, 12, 20, 197, 107, 94, 164, 217);
RT_INTERFACE!{interface ILinearDoubleKeyFrame(ILinearDoubleKeyFrameVtbl): IInspectable(IInspectableVtbl) [IID_ILinearDoubleKeyFrame] {
    
}}
RT_CLASS!{class LinearDoubleKeyFrame: ILinearDoubleKeyFrame}
impl RtActivatable<IActivationFactory> for LinearDoubleKeyFrame {}
DEFINE_CLSID!(LinearDoubleKeyFrame(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,76,105,110,101,97,114,68,111,117,98,108,101,75,101,121,70,114,97,109,101,0]) [CLSID_LinearDoubleKeyFrame]);
DEFINE_IID!(IID_IObjectAnimationUsingKeyFrames, 860499346, 46922, 19556, 185, 166, 88, 188, 250, 49, 79, 34);
RT_INTERFACE!{interface IObjectAnimationUsingKeyFrames(IObjectAnimationUsingKeyFramesVtbl): IInspectable(IInspectableVtbl) [IID_IObjectAnimationUsingKeyFrames] {
    fn get_KeyFrames(&self, out: *mut *mut ObjectKeyFrameCollection) -> HRESULT,
    fn get_EnableDependentAnimation(&self, out: *mut bool) -> HRESULT,
    fn put_EnableDependentAnimation(&self, value: bool) -> HRESULT
}}
impl IObjectAnimationUsingKeyFrames {
    #[inline] pub unsafe fn get_key_frames(&self) -> Result<ComPtr<ObjectKeyFrameCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeyFrames)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_enable_dependent_animation(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EnableDependentAnimation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_enable_dependent_animation(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EnableDependentAnimation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IObjectAnimationUsingKeyFramesStatics, 3950207362, 27377, 18851, 151, 182, 120, 62, 217, 116, 0, 254);
RT_INTERFACE!{static interface IObjectAnimationUsingKeyFramesStatics(IObjectAnimationUsingKeyFramesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IObjectAnimationUsingKeyFramesStatics] {
    fn get_EnableDependentAnimationProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IObjectAnimationUsingKeyFramesStatics {
    #[inline] pub unsafe fn get_enable_dependent_animation_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EnableDependentAnimationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ObjectAnimationUsingKeyFrames: IObjectAnimationUsingKeyFrames}
impl RtActivatable<IObjectAnimationUsingKeyFramesStatics> for ObjectAnimationUsingKeyFrames {}
impl RtActivatable<IActivationFactory> for ObjectAnimationUsingKeyFrames {}
impl ObjectAnimationUsingKeyFrames {
    #[inline] pub fn get_enable_dependent_animation_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IObjectAnimationUsingKeyFramesStatics>>::get_activation_factory().get_enable_dependent_animation_property()
    }}
}
DEFINE_CLSID!(ObjectAnimationUsingKeyFrames(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,79,98,106,101,99,116,65,110,105,109,97,116,105,111,110,85,115,105,110,103,75,101,121,70,114,97,109,101,115,0]) [CLSID_ObjectAnimationUsingKeyFrames]);
DEFINE_IID!(IID_IPaneThemeTransition, 1191766926, 19452, 60998, 212, 249, 112, 141, 239, 63, 187, 43);
RT_INTERFACE!{interface IPaneThemeTransition(IPaneThemeTransitionVtbl): IInspectable(IInspectableVtbl) [IID_IPaneThemeTransition] {
    fn get_Edge(&self, out: *mut super::super::controls::primitives::EdgeTransitionLocation) -> HRESULT,
    fn put_Edge(&self, value: super::super::controls::primitives::EdgeTransitionLocation) -> HRESULT
}}
impl IPaneThemeTransition {
    #[inline] pub unsafe fn get_edge(&self) -> Result<super::super::controls::primitives::EdgeTransitionLocation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Edge)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_edge(&self, value: super::super::controls::primitives::EdgeTransitionLocation) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Edge)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPaneThemeTransitionStatics, 829110319, 19428, 6039, 180, 92, 205, 144, 11, 190, 12, 170);
RT_INTERFACE!{static interface IPaneThemeTransitionStatics(IPaneThemeTransitionStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPaneThemeTransitionStatics] {
    fn get_EdgeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IPaneThemeTransitionStatics {
    #[inline] pub unsafe fn get_edge_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EdgeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PaneThemeTransition: IPaneThemeTransition}
impl RtActivatable<IPaneThemeTransitionStatics> for PaneThemeTransition {}
impl RtActivatable<IActivationFactory> for PaneThemeTransition {}
impl PaneThemeTransition {
    #[inline] pub fn get_edge_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPaneThemeTransitionStatics>>::get_activation_factory().get_edge_property()
    }}
}
DEFINE_CLSID!(PaneThemeTransition(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,80,97,110,101,84,104,101,109,101,84,114,97,110,115,105,116,105,111,110,0]) [CLSID_PaneThemeTransition]);
DEFINE_IID!(IID_IPointAnimation, 821052178, 30502, 20360, 184, 226, 47, 165, 69, 24, 150, 59);
RT_INTERFACE!{interface IPointAnimation(IPointAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IPointAnimation] {
    fn get_From(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::Point>) -> HRESULT,
    fn put_From(&self, value: *mut ::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::Point>) -> HRESULT,
    fn get_To(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::Point>) -> HRESULT,
    fn put_To(&self, value: *mut ::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::Point>) -> HRESULT,
    fn get_By(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::Point>) -> HRESULT,
    fn put_By(&self, value: *mut ::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::Point>) -> HRESULT,
    fn get_EasingFunction(&self, out: *mut *mut EasingFunctionBase) -> HRESULT,
    fn put_EasingFunction(&self, value: *mut EasingFunctionBase) -> HRESULT,
    fn get_EnableDependentAnimation(&self, out: *mut bool) -> HRESULT,
    fn put_EnableDependentAnimation(&self, value: bool) -> HRESULT
}}
impl IPointAnimation {
    #[inline] pub unsafe fn get_from(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::Point>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_From)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_from(&self, value: &::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::Point>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_From)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_to(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::Point>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_To)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_to(&self, value: &::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::Point>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_To)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_by(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::Point>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_By)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_by(&self, value: &::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::Point>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_By)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_easing_function(&self) -> Result<ComPtr<EasingFunctionBase>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EasingFunction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_easing_function(&self, value: &EasingFunctionBase) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EasingFunction)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_enable_dependent_animation(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EnableDependentAnimation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_enable_dependent_animation(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EnableDependentAnimation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPointAnimationStatics, 798602070, 59191, 16523, 160, 253, 50, 120, 38, 211, 34, 85);
RT_INTERFACE!{static interface IPointAnimationStatics(IPointAnimationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPointAnimationStatics] {
    fn get_FromProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ToProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ByProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_EasingFunctionProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_EnableDependentAnimationProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IPointAnimationStatics {
    #[inline] pub unsafe fn get_from_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FromProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_to_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ToProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_by_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ByProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_easing_function_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EasingFunctionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_enable_dependent_animation_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EnableDependentAnimationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PointAnimation: IPointAnimation}
impl RtActivatable<IPointAnimationStatics> for PointAnimation {}
impl RtActivatable<IActivationFactory> for PointAnimation {}
impl PointAnimation {
    #[inline] pub fn get_from_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPointAnimationStatics>>::get_activation_factory().get_from_property()
    }}
    #[inline] pub fn get_to_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPointAnimationStatics>>::get_activation_factory().get_to_property()
    }}
    #[inline] pub fn get_by_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPointAnimationStatics>>::get_activation_factory().get_by_property()
    }}
    #[inline] pub fn get_easing_function_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPointAnimationStatics>>::get_activation_factory().get_easing_function_property()
    }}
    #[inline] pub fn get_enable_dependent_animation_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPointAnimationStatics>>::get_activation_factory().get_enable_dependent_animation_property()
    }}
}
DEFINE_CLSID!(PointAnimation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,80,111,105,110,116,65,110,105,109,97,116,105,111,110,0]) [CLSID_PointAnimation]);
DEFINE_IID!(IID_IPopupThemeTransition, 1199846738, 17027, 21598, 199, 145, 38, 141, 202, 34, 206, 75);
RT_INTERFACE!{interface IPopupThemeTransition(IPopupThemeTransitionVtbl): IInspectable(IInspectableVtbl) [IID_IPopupThemeTransition] {
    fn get_FromHorizontalOffset(&self, out: *mut f64) -> HRESULT,
    fn put_FromHorizontalOffset(&self, value: f64) -> HRESULT,
    fn get_FromVerticalOffset(&self, out: *mut f64) -> HRESULT,
    fn put_FromVerticalOffset(&self, value: f64) -> HRESULT
}}
impl IPopupThemeTransition {
    #[inline] pub unsafe fn get_from_horizontal_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FromHorizontalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_from_horizontal_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FromHorizontalOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_from_vertical_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FromVerticalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_from_vertical_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FromVerticalOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPopupThemeTransitionStatics, 3852559374, 18701, 5381, 159, 107, 143, 175, 192, 68, 222, 197);
RT_INTERFACE!{static interface IPopupThemeTransitionStatics(IPopupThemeTransitionStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPopupThemeTransitionStatics] {
    fn get_FromHorizontalOffsetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_FromVerticalOffsetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IPopupThemeTransitionStatics {
    #[inline] pub unsafe fn get_from_horizontal_offset_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FromHorizontalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_from_vertical_offset_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FromVerticalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PopupThemeTransition: IPopupThemeTransition}
impl RtActivatable<IPopupThemeTransitionStatics> for PopupThemeTransition {}
impl RtActivatable<IActivationFactory> for PopupThemeTransition {}
impl PopupThemeTransition {
    #[inline] pub fn get_from_horizontal_offset_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPopupThemeTransitionStatics>>::get_activation_factory().get_from_horizontal_offset_property()
    }}
    #[inline] pub fn get_from_vertical_offset_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPopupThemeTransitionStatics>>::get_activation_factory().get_from_vertical_offset_property()
    }}
}
DEFINE_CLSID!(PopupThemeTransition(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,80,111,112,117,112,84,104,101,109,101,84,114,97,110,115,105,116,105,111,110,0]) [CLSID_PopupThemeTransition]);
DEFINE_IID!(IID_IPowerEase, 1774716281, 61151, 16475, 134, 128, 217, 96, 104, 128, 201, 55);
RT_INTERFACE!{interface IPowerEase(IPowerEaseVtbl): IInspectable(IInspectableVtbl) [IID_IPowerEase] {
    fn get_Power(&self, out: *mut f64) -> HRESULT,
    fn put_Power(&self, value: f64) -> HRESULT
}}
impl IPowerEase {
    #[inline] pub unsafe fn get_power(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Power)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_power(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Power)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPowerEaseStatics, 2778026243, 37282, 17932, 156, 65, 210, 143, 106, 147, 155, 218);
RT_INTERFACE!{static interface IPowerEaseStatics(IPowerEaseStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPowerEaseStatics] {
    fn get_PowerProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IPowerEaseStatics {
    #[inline] pub unsafe fn get_power_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PowerProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PowerEase: IPowerEase}
impl RtActivatable<IPowerEaseStatics> for PowerEase {}
impl RtActivatable<IActivationFactory> for PowerEase {}
impl PowerEase {
    #[inline] pub fn get_power_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPowerEaseStatics>>::get_activation_factory().get_power_property()
    }}
}
DEFINE_CLSID!(PowerEase(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,80,111,119,101,114,69,97,115,101,0]) [CLSID_PowerEase]);
DEFINE_IID!(IID_IQuadraticEase, 3780185745, 61293, 17648, 128, 61, 104, 209, 109, 224, 221, 252);
RT_INTERFACE!{interface IQuadraticEase(IQuadraticEaseVtbl): IInspectable(IInspectableVtbl) [IID_IQuadraticEase] {
    
}}
RT_CLASS!{class QuadraticEase: IQuadraticEase}
impl RtActivatable<IActivationFactory> for QuadraticEase {}
DEFINE_CLSID!(QuadraticEase(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,81,117,97,100,114,97,116,105,99,69,97,115,101,0]) [CLSID_QuadraticEase]);
DEFINE_IID!(IID_IQuarticEase, 3899230228, 65090, 18949, 181, 184, 8, 31, 65, 21, 120, 21);
RT_INTERFACE!{interface IQuarticEase(IQuarticEaseVtbl): IInspectable(IInspectableVtbl) [IID_IQuarticEase] {
    
}}
RT_CLASS!{class QuarticEase: IQuarticEase}
impl RtActivatable<IActivationFactory> for QuarticEase {}
DEFINE_CLSID!(QuarticEase(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,81,117,97,114,116,105,99,69,97,115,101,0]) [CLSID_QuarticEase]);
DEFINE_IID!(IID_IQuinticEase, 2465102139, 15433, 16648, 170, 17, 171, 120, 102, 3, 218, 33);
RT_INTERFACE!{interface IQuinticEase(IQuinticEaseVtbl): IInspectable(IInspectableVtbl) [IID_IQuinticEase] {
    
}}
RT_CLASS!{class QuinticEase: IQuinticEase}
impl RtActivatable<IActivationFactory> for QuinticEase {}
DEFINE_CLSID!(QuinticEase(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,81,117,105,110,116,105,99,69,97,115,101,0]) [CLSID_QuinticEase]);
DEFINE_IID!(IID_IReorderThemeTransition, 4060503148, 53330, 19153, 131, 98, 183, 27, 54, 223, 116, 151);
RT_INTERFACE!{interface IReorderThemeTransition(IReorderThemeTransitionVtbl): IInspectable(IInspectableVtbl) [IID_IReorderThemeTransition] {
    
}}
RT_CLASS!{class ReorderThemeTransition: IReorderThemeTransition}
impl RtActivatable<IActivationFactory> for ReorderThemeTransition {}
DEFINE_CLSID!(ReorderThemeTransition(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,82,101,111,114,100,101,114,84,104,101,109,101,84,114,97,110,115,105,116,105,111,110,0]) [CLSID_ReorderThemeTransition]);
DEFINE_IID!(IID_IRepositionThemeTransition, 2285017986, 39155, 17754, 172, 83, 46, 112, 131, 182, 226, 44);
RT_INTERFACE!{interface IRepositionThemeTransition(IRepositionThemeTransitionVtbl): IInspectable(IInspectableVtbl) [IID_IRepositionThemeTransition] {
    
}}
DEFINE_IID!(IID_IRepositionThemeTransition2, 3468683364, 56298, 17412, 142, 110, 222, 85, 173, 167, 82, 57);
RT_INTERFACE!{interface IRepositionThemeTransition2(IRepositionThemeTransition2Vtbl): IInspectable(IInspectableVtbl) [IID_IRepositionThemeTransition2] {
    fn get_IsStaggeringEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsStaggeringEnabled(&self, value: bool) -> HRESULT
}}
impl IRepositionThemeTransition2 {
    #[inline] pub unsafe fn get_is_staggering_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsStaggeringEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_staggering_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsStaggeringEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRepositionThemeTransitionStatics2, 2453727536, 2585, 18059, 140, 42, 104, 250, 180, 80, 0, 39);
RT_INTERFACE!{static interface IRepositionThemeTransitionStatics2(IRepositionThemeTransitionStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IRepositionThemeTransitionStatics2] {
    fn get_IsStaggeringEnabledProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IRepositionThemeTransitionStatics2 {
    #[inline] pub unsafe fn get_is_staggering_enabled_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsStaggeringEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class RepositionThemeTransition: IRepositionThemeTransition}
impl RtActivatable<IRepositionThemeTransitionStatics2> for RepositionThemeTransition {}
impl RtActivatable<IActivationFactory> for RepositionThemeTransition {}
impl RepositionThemeTransition {
    #[inline] pub fn get_is_staggering_enabled_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRepositionThemeTransitionStatics2>>::get_activation_factory().get_is_staggering_enabled_property()
    }}
}
DEFINE_CLSID!(RepositionThemeTransition(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,82,101,112,111,115,105,116,105,111,110,84,104,101,109,101,84,114,97,110,115,105,116,105,111,110,0]) [CLSID_RepositionThemeTransition]);
DEFINE_IID!(IID_ISineEase, 2839030114, 8971, 18906, 158, 13, 102, 73, 135, 137, 35, 67);
RT_INTERFACE!{interface ISineEase(ISineEaseVtbl): IInspectable(IInspectableVtbl) [IID_ISineEase] {
    
}}
RT_CLASS!{class SineEase: ISineEase}
impl RtActivatable<IActivationFactory> for SineEase {}
DEFINE_CLSID!(SineEase(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,83,105,110,101,69,97,115,101,0]) [CLSID_SineEase]);
DEFINE_IID!(IID_ISplineDoubleKeyFrame, 14101816, 27435, 18499, 131, 142, 200, 177, 21, 238, 200, 1);
RT_INTERFACE!{interface ISplineDoubleKeyFrame(ISplineDoubleKeyFrameVtbl): IInspectable(IInspectableVtbl) [IID_ISplineDoubleKeyFrame] {
    fn get_KeySpline(&self, out: *mut *mut KeySpline) -> HRESULT,
    fn put_KeySpline(&self, value: *mut KeySpline) -> HRESULT
}}
impl ISplineDoubleKeyFrame {
    #[inline] pub unsafe fn get_key_spline(&self) -> Result<ComPtr<KeySpline>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeySpline)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_key_spline(&self, value: &KeySpline) -> Result<()> {
        let hr = ((*self.lpVtbl).put_KeySpline)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISplineDoubleKeyFrameStatics, 101355516, 38751, 20046, 158, 199, 19, 197, 174, 224, 32, 98);
RT_INTERFACE!{static interface ISplineDoubleKeyFrameStatics(ISplineDoubleKeyFrameStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISplineDoubleKeyFrameStatics] {
    fn get_KeySplineProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl ISplineDoubleKeyFrameStatics {
    #[inline] pub unsafe fn get_key_spline_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeySplineProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SplineDoubleKeyFrame: ISplineDoubleKeyFrame}
impl RtActivatable<ISplineDoubleKeyFrameStatics> for SplineDoubleKeyFrame {}
impl RtActivatable<IActivationFactory> for SplineDoubleKeyFrame {}
impl SplineDoubleKeyFrame {
    #[inline] pub fn get_key_spline_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplineDoubleKeyFrameStatics>>::get_activation_factory().get_key_spline_property()
    }}
}
DEFINE_CLSID!(SplineDoubleKeyFrame(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,83,112,108,105,110,101,68,111,117,98,108,101,75,101,121,70,114,97,109,101,0]) [CLSID_SplineDoubleKeyFrame]);
DEFINE_IID!(IID_IStoryboard, 3562806894, 13716, 17934, 152, 26, 50, 39, 27, 211, 170, 6);
RT_INTERFACE!{interface IStoryboard(IStoryboardVtbl): IInspectable(IInspectableVtbl) [IID_IStoryboard] {
    fn get_Children(&self, out: *mut *mut TimelineCollection) -> HRESULT,
    fn Seek(&self, offset: ::rt::gen::windows::foundation::TimeSpan) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn Begin(&self) -> HRESULT,
    fn Pause(&self) -> HRESULT,
    fn Resume(&self) -> HRESULT,
    fn GetCurrentState(&self, out: *mut ClockState) -> HRESULT,
    fn GetCurrentTime(&self, out: *mut ::rt::gen::windows::foundation::TimeSpan) -> HRESULT,
    fn SeekAlignedToLastTick(&self, offset: ::rt::gen::windows::foundation::TimeSpan) -> HRESULT,
    fn SkipToFill(&self) -> HRESULT
}}
impl IStoryboard {
    #[inline] pub unsafe fn get_children(&self) -> Result<ComPtr<TimelineCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Children)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn seek(&self, offset: ::rt::gen::windows::foundation::TimeSpan) -> Result<()> {
        let hr = ((*self.lpVtbl).Seek)(self as *const _ as *mut _, offset);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn stop(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Stop)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn begin(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Begin)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn pause(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Pause)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn resume(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Resume)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_current_state(&self) -> Result<ClockState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetCurrentState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_current_time(&self) -> Result<::rt::gen::windows::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetCurrentTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn seek_aligned_to_last_tick(&self, offset: ::rt::gen::windows::foundation::TimeSpan) -> Result<()> {
        let hr = ((*self.lpVtbl).SeekAlignedToLastTick)(self as *const _ as *mut _, offset);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn skip_to_fill(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).SkipToFill)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class Storyboard: IStoryboard}
impl RtActivatable<IStoryboardStatics> for Storyboard {}
impl RtActivatable<IActivationFactory> for Storyboard {}
impl Storyboard {
    #[inline] pub fn get_target_property_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IStoryboardStatics>>::get_activation_factory().get_target_property_property()
    }}
    #[inline] pub fn get_target_property(element: &Timeline) -> Result<HString> { unsafe {
        <Self as RtActivatable<IStoryboardStatics>>::get_activation_factory().get_target_property(element)
    }}
    #[inline] pub fn set_target_property(element: &Timeline, path: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<IStoryboardStatics>>::get_activation_factory().set_target_property(element, path)
    }}
    #[inline] pub fn get_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IStoryboardStatics>>::get_activation_factory().get_target_name_property()
    }}
    #[inline] pub fn get_target_name(element: &Timeline) -> Result<HString> { unsafe {
        <Self as RtActivatable<IStoryboardStatics>>::get_activation_factory().get_target_name(element)
    }}
    #[inline] pub fn set_target_name(element: &Timeline, name: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<IStoryboardStatics>>::get_activation_factory().set_target_name(element, name)
    }}
    #[inline] pub fn set_target(timeline: &Timeline, target: &super::super::DependencyObject) -> Result<()> { unsafe {
        <Self as RtActivatable<IStoryboardStatics>>::get_activation_factory().set_target(timeline, target)
    }}
}
DEFINE_CLSID!(Storyboard(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,83,116,111,114,121,98,111,97,114,100,0]) [CLSID_Storyboard]);
DEFINE_IID!(IID_IStoryboardStatics, 3626960856, 29653, 17273, 189, 72, 126, 5, 24, 74, 139, 173);
RT_INTERFACE!{static interface IStoryboardStatics(IStoryboardStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IStoryboardStatics] {
    fn get_TargetPropertyProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn GetTargetProperty(&self, element: *mut Timeline, out: *mut HSTRING) -> HRESULT,
    fn SetTargetProperty(&self, element: *mut Timeline, path: HSTRING) -> HRESULT,
    fn get_TargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn GetTargetName(&self, element: *mut Timeline, out: *mut HSTRING) -> HRESULT,
    fn SetTargetName(&self, element: *mut Timeline, name: HSTRING) -> HRESULT,
    fn SetTarget(&self, timeline: *mut Timeline, target: *mut super::super::DependencyObject) -> HRESULT
}}
impl IStoryboardStatics {
    #[inline] pub unsafe fn get_target_property_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetPropertyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_target_property(&self, element: &Timeline) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetTargetProperty)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_property(&self, element: &Timeline, path: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetTargetProperty)(self as *const _ as *mut _, element as *const _ as *mut _, path.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_target_name(&self, element: &Timeline) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetTargetName)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_name(&self, element: &Timeline, name: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetTargetName)(self as *const _ as *mut _, element as *const _ as *mut _, name.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target(&self, timeline: &Timeline, target: &super::super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).SetTarget)(self as *const _ as *mut _, timeline as *const _ as *mut _, target as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_ENUM! { enum ConnectedAnimationComponent: i32 {
    OffsetX (ConnectedAnimationComponent_OffsetX) = 0, OffsetY (ConnectedAnimationComponent_OffsetY) = 1, CrossFade (ConnectedAnimationComponent_CrossFade) = 2, Scale (ConnectedAnimationComponent_Scale) = 3,
}}
RT_CLASS!{class ColorKeyFrameCollection: ::rt::gen::windows::foundation::collections::IVector<ColorKeyFrame>}
impl RtActivatable<IActivationFactory> for ColorKeyFrameCollection {}
DEFINE_CLSID!(ColorKeyFrameCollection(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,67,111,108,111,114,75,101,121,70,114,97,109,101,67,111,108,108,101,99,116,105,111,110,0]) [CLSID_ColorKeyFrameCollection]);
DEFINE_IID!(IID_IConnectedAnimation, 890790540, 62343, 19493, 172, 152, 68, 232, 108, 60, 173, 240);
RT_INTERFACE!{interface IConnectedAnimation(IConnectedAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IConnectedAnimation] {
    fn add_Completed(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<ConnectedAnimation, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Completed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn TryStart(&self, destination: *mut super::super::UIElement, out: *mut bool) -> HRESULT,
    fn Cancel(&self) -> HRESULT
}}
impl IConnectedAnimation {
    #[inline] pub unsafe fn add_completed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<ConnectedAnimation, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Completed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_completed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Completed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_start(&self, destination: &super::super::UIElement) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryStart)(self as *const _ as *mut _, destination as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn cancel(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Cancel)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ConnectedAnimation: IConnectedAnimation}
DEFINE_IID!(IID_IConnectedAnimation2, 1563397724, 22603, 19933, 182, 104, 151, 56, 145, 67, 20, 89);
RT_INTERFACE!{interface IConnectedAnimation2(IConnectedAnimation2Vtbl): IInspectable(IInspectableVtbl) [IID_IConnectedAnimation2] {
    fn get_IsScaleAnimationEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsScaleAnimationEnabled(&self, value: bool) -> HRESULT,
    fn TryStartWithCoordinatedElements(&self, destination: *mut super::super::UIElement, coordinatedElements: *mut ::rt::gen::windows::foundation::collections::IIterable<super::super::UIElement>, out: *mut bool) -> HRESULT,
    #[cfg(feature="windows-ui")] fn SetAnimationComponent(&self, component: ConnectedAnimationComponent, animation: *mut super::super::super::composition::ICompositionAnimationBase) -> HRESULT
}}
impl IConnectedAnimation2 {
    #[inline] pub unsafe fn get_is_scale_animation_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsScaleAnimationEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_scale_animation_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsScaleAnimationEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_start_with_coordinated_elements(&self, destination: &super::super::UIElement, coordinatedElements: &::rt::gen::windows::foundation::collections::IIterable<super::super::UIElement>) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryStartWithCoordinatedElements)(self as *const _ as *mut _, destination as *const _ as *mut _, coordinatedElements as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_animation_component(&self, component: ConnectedAnimationComponent, animation: &super::super::super::composition::ICompositionAnimationBase) -> Result<()> {
        let hr = ((*self.lpVtbl).SetAnimationComponent)(self as *const _ as *mut _, component, animation as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IConnectedAnimationService, 476607945, 6587, 19783, 185, 170, 102, 200, 2, 220, 185, 255);
RT_INTERFACE!{interface IConnectedAnimationService(IConnectedAnimationServiceVtbl): IInspectable(IInspectableVtbl) [IID_IConnectedAnimationService] {
    fn get_DefaultDuration(&self, out: *mut ::rt::gen::windows::foundation::TimeSpan) -> HRESULT,
    fn put_DefaultDuration(&self, value: ::rt::gen::windows::foundation::TimeSpan) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_DefaultEasingFunction(&self, out: *mut *mut super::super::super::composition::CompositionEasingFunction) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_DefaultEasingFunction(&self, value: *mut super::super::super::composition::CompositionEasingFunction) -> HRESULT,
    fn PrepareToAnimate(&self, key: HSTRING, source: *mut super::super::UIElement, out: *mut *mut ConnectedAnimation) -> HRESULT,
    fn GetAnimation(&self, key: HSTRING, out: *mut *mut ConnectedAnimation) -> HRESULT
}}
impl IConnectedAnimationService {
    #[inline] pub unsafe fn get_default_duration(&self) -> Result<::rt::gen::windows::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DefaultDuration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_default_duration(&self, value: ::rt::gen::windows::foundation::TimeSpan) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DefaultDuration)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_default_easing_function(&self) -> Result<ComPtr<super::super::super::composition::CompositionEasingFunction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DefaultEasingFunction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_default_easing_function(&self, value: &super::super::super::composition::CompositionEasingFunction) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DefaultEasingFunction)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn prepare_to_animate(&self, key: &HStringArg, source: &super::super::UIElement) -> Result<ComPtr<ConnectedAnimation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).PrepareToAnimate)(self as *const _ as *mut _, key.get(), source as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_animation(&self, key: &HStringArg) -> Result<ComPtr<ConnectedAnimation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAnimation)(self as *const _ as *mut _, key.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IConnectedAnimationServiceStatics, 3339161253, 54920, 16616, 143, 144, 150, 166, 39, 146, 115, 210);
RT_INTERFACE!{static interface IConnectedAnimationServiceStatics(IConnectedAnimationServiceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IConnectedAnimationServiceStatics] {
    fn GetForCurrentView(&self, out: *mut *mut ConnectedAnimationService) -> HRESULT
}}
impl IConnectedAnimationServiceStatics {
    #[inline] pub unsafe fn get_for_current_view(&self) -> Result<ComPtr<ConnectedAnimationService>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ConnectedAnimationService: IConnectedAnimationService}
impl RtActivatable<IConnectedAnimationServiceStatics> for ConnectedAnimationService {}
impl ConnectedAnimationService {
    #[inline] pub fn get_for_current_view() -> Result<ComPtr<ConnectedAnimationService>> { unsafe {
        <Self as RtActivatable<IConnectedAnimationServiceStatics>>::get_activation_factory().get_for_current_view()
    }}
}
DEFINE_CLSID!(ConnectedAnimationService(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,67,111,110,110,101,99,116,101,100,65,110,105,109,97,116,105,111,110,83,101,114,118,105,99,101,0]) [CLSID_ConnectedAnimationService]);
RT_CLASS!{class PointKeyFrameCollection: ::rt::gen::windows::foundation::collections::IVector<PointKeyFrame>}
impl RtActivatable<IActivationFactory> for PointKeyFrameCollection {}
DEFINE_CLSID!(PointKeyFrameCollection(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,80,111,105,110,116,75,101,121,70,114,97,109,101,67,111,108,108,101,99,116,105,111,110,0]) [CLSID_PointKeyFrameCollection]);
DEFINE_IID!(IID_IColorKeyFrame, 3038610137, 2320, 17801, 162, 132, 176, 201, 32, 88, 88, 233);
RT_INTERFACE!{interface IColorKeyFrame(IColorKeyFrameVtbl): IInspectable(IInspectableVtbl) [IID_IColorKeyFrame] {
    #[cfg(not(feature="windows-ui"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Value(&self, out: *mut super::super::super::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_Value(&self, value: super::super::super::Color) -> HRESULT,
    fn get_KeyTime(&self, out: *mut KeyTime) -> HRESULT,
    fn put_KeyTime(&self, value: KeyTime) -> HRESULT
}}
impl IColorKeyFrame {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_value(&self) -> Result<super::super::super::Color> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Value)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_value(&self, value: super::super::super::Color) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Value)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_key_time(&self) -> Result<KeyTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeyTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_key_time(&self, value: KeyTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_KeyTime)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IColorKeyFrameStatics, 3225661081, 8460, 17167, 157, 165, 223, 16, 130, 105, 32, 85);
RT_INTERFACE!{static interface IColorKeyFrameStatics(IColorKeyFrameStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IColorKeyFrameStatics] {
    fn get_ValueProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_KeyTimeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IColorKeyFrameStatics {
    #[inline] pub unsafe fn get_value_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ValueProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_key_time_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeyTimeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IColorKeyFrameFactory, 1989925002, 40187, 19069, 150, 196, 161, 231, 222, 111, 219, 75);
RT_INTERFACE!{interface IColorKeyFrameFactory(IColorKeyFrameFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IColorKeyFrameFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ColorKeyFrame) -> HRESULT
}}
impl IColorKeyFrameFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ColorKeyFrame>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class ColorKeyFrame: IColorKeyFrame}
impl RtActivatable<IColorKeyFrameStatics> for ColorKeyFrame {}
impl ColorKeyFrame {
    #[inline] pub fn get_value_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IColorKeyFrameStatics>>::get_activation_factory().get_value_property()
    }}
    #[inline] pub fn get_key_time_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IColorKeyFrameStatics>>::get_activation_factory().get_key_time_property()
    }}
}
DEFINE_CLSID!(ColorKeyFrame(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,67,111,108,111,114,75,101,121,70,114,97,109,101,0]) [CLSID_ColorKeyFrame]);
DEFINE_IID!(IID_IPointKeyFrame, 4241001729, 32642, 19886, 128, 38, 123, 126, 8, 104, 120, 179);
RT_INTERFACE!{interface IPointKeyFrame(IPointKeyFrameVtbl): IInspectable(IInspectableVtbl) [IID_IPointKeyFrame] {
    fn get_Value(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn put_Value(&self, value: ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn get_KeyTime(&self, out: *mut KeyTime) -> HRESULT,
    fn put_KeyTime(&self, value: KeyTime) -> HRESULT
}}
impl IPointKeyFrame {
    #[inline] pub unsafe fn get_value(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Value)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_value(&self, value: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Value)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_key_time(&self) -> Result<KeyTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeyTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_key_time(&self, value: KeyTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_KeyTime)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPointKeyFrameStatics, 2513378087, 31077, 19436, 185, 251, 251, 233, 75, 101, 81, 142);
RT_INTERFACE!{static interface IPointKeyFrameStatics(IPointKeyFrameStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPointKeyFrameStatics] {
    fn get_ValueProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_KeyTimeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IPointKeyFrameStatics {
    #[inline] pub unsafe fn get_value_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ValueProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_key_time_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeyTimeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPointKeyFrameFactory, 3407956959, 17002, 17298, 131, 85, 194, 174, 82, 133, 38, 35);
RT_INTERFACE!{interface IPointKeyFrameFactory(IPointKeyFrameFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPointKeyFrameFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut PointKeyFrame) -> HRESULT
}}
impl IPointKeyFrameFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<PointKeyFrame>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class PointKeyFrame: IPointKeyFrame}
impl RtActivatable<IPointKeyFrameStatics> for PointKeyFrame {}
impl PointKeyFrame {
    #[inline] pub fn get_value_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPointKeyFrameStatics>>::get_activation_factory().get_value_property()
    }}
    #[inline] pub fn get_key_time_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPointKeyFrameStatics>>::get_activation_factory().get_key_time_property()
    }}
}
DEFINE_CLSID!(PointKeyFrame(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,80,111,105,110,116,75,101,121,70,114,97,109,101,0]) [CLSID_PointKeyFrame]);
DEFINE_IID!(IID_IColorAnimationUsingKeyFrames, 4123534912, 5059, 17066, 154, 226, 126, 107, 81, 201, 47, 149);
RT_INTERFACE!{interface IColorAnimationUsingKeyFrames(IColorAnimationUsingKeyFramesVtbl): IInspectable(IInspectableVtbl) [IID_IColorAnimationUsingKeyFrames] {
    fn get_KeyFrames(&self, out: *mut *mut ColorKeyFrameCollection) -> HRESULT,
    fn get_EnableDependentAnimation(&self, out: *mut bool) -> HRESULT,
    fn put_EnableDependentAnimation(&self, value: bool) -> HRESULT
}}
impl IColorAnimationUsingKeyFrames {
    #[inline] pub unsafe fn get_key_frames(&self) -> Result<ComPtr<ColorKeyFrameCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeyFrames)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_enable_dependent_animation(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EnableDependentAnimation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_enable_dependent_animation(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EnableDependentAnimation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IColorAnimationUsingKeyFramesStatics, 3027385564, 38633, 18681, 141, 146, 155, 100, 139, 47, 28, 198);
RT_INTERFACE!{static interface IColorAnimationUsingKeyFramesStatics(IColorAnimationUsingKeyFramesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IColorAnimationUsingKeyFramesStatics] {
    fn get_EnableDependentAnimationProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IColorAnimationUsingKeyFramesStatics {
    #[inline] pub unsafe fn get_enable_dependent_animation_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EnableDependentAnimationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ColorAnimationUsingKeyFrames: IColorAnimationUsingKeyFrames}
impl RtActivatable<IColorAnimationUsingKeyFramesStatics> for ColorAnimationUsingKeyFrames {}
impl RtActivatable<IActivationFactory> for ColorAnimationUsingKeyFrames {}
impl ColorAnimationUsingKeyFrames {
    #[inline] pub fn get_enable_dependent_animation_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IColorAnimationUsingKeyFramesStatics>>::get_activation_factory().get_enable_dependent_animation_property()
    }}
}
DEFINE_CLSID!(ColorAnimationUsingKeyFrames(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,67,111,108,111,114,65,110,105,109,97,116,105,111,110,85,115,105,110,103,75,101,121,70,114,97,109,101,115,0]) [CLSID_ColorAnimationUsingKeyFrames]);
DEFINE_IID!(IID_IDiscreteColorKeyFrame, 587991284, 57442, 19633, 142, 42, 20, 9, 61, 115, 237, 140);
RT_INTERFACE!{interface IDiscreteColorKeyFrame(IDiscreteColorKeyFrameVtbl): IInspectable(IInspectableVtbl) [IID_IDiscreteColorKeyFrame] {
    
}}
RT_CLASS!{class DiscreteColorKeyFrame: IDiscreteColorKeyFrame}
impl RtActivatable<IActivationFactory> for DiscreteColorKeyFrame {}
DEFINE_CLSID!(DiscreteColorKeyFrame(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,68,105,115,99,114,101,116,101,67,111,108,111,114,75,101,121,70,114,97,109,101,0]) [CLSID_DiscreteColorKeyFrame]);
DEFINE_IID!(IID_IDiscretePointKeyFrame, 3769173773, 19522, 19088, 152, 58, 117, 245, 168, 58, 47, 190);
RT_INTERFACE!{interface IDiscretePointKeyFrame(IDiscretePointKeyFrameVtbl): IInspectable(IInspectableVtbl) [IID_IDiscretePointKeyFrame] {
    
}}
RT_CLASS!{class DiscretePointKeyFrame: IDiscretePointKeyFrame}
impl RtActivatable<IActivationFactory> for DiscretePointKeyFrame {}
DEFINE_CLSID!(DiscretePointKeyFrame(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,68,105,115,99,114,101,116,101,80,111,105,110,116,75,101,121,70,114,97,109,101,0]) [CLSID_DiscretePointKeyFrame]);
DEFINE_IID!(IID_IDragItemThemeAnimation, 209542581, 32470, 18761, 180, 230, 167, 140, 159, 79, 151, 141);
RT_INTERFACE!{interface IDragItemThemeAnimation(IDragItemThemeAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IDragItemThemeAnimation] {
    fn get_TargetName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TargetName(&self, value: HSTRING) -> HRESULT
}}
impl IDragItemThemeAnimation {
    #[inline] pub unsafe fn get_target_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDragItemThemeAnimationStatics, 1645787637, 314, 20401, 134, 252, 146, 188, 78, 141, 2, 65);
RT_INTERFACE!{static interface IDragItemThemeAnimationStatics(IDragItemThemeAnimationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDragItemThemeAnimationStatics] {
    fn get_TargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IDragItemThemeAnimationStatics {
    #[inline] pub unsafe fn get_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class DragItemThemeAnimation: IDragItemThemeAnimation}
impl RtActivatable<IDragItemThemeAnimationStatics> for DragItemThemeAnimation {}
impl RtActivatable<IActivationFactory> for DragItemThemeAnimation {}
impl DragItemThemeAnimation {
    #[inline] pub fn get_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDragItemThemeAnimationStatics>>::get_activation_factory().get_target_name_property()
    }}
}
DEFINE_CLSID!(DragItemThemeAnimation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,68,114,97,103,73,116,101,109,84,104,101,109,101,65,110,105,109,97,116,105,111,110,0]) [CLSID_DragItemThemeAnimation]);
DEFINE_IID!(IID_IDragOverThemeAnimation, 1928815351, 32337, 19051, 185, 55, 220, 75, 76, 28, 84, 88);
RT_INTERFACE!{interface IDragOverThemeAnimation(IDragOverThemeAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IDragOverThemeAnimation] {
    fn get_TargetName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TargetName(&self, value: HSTRING) -> HRESULT,
    fn get_ToOffset(&self, out: *mut f64) -> HRESULT,
    fn put_ToOffset(&self, value: f64) -> HRESULT,
    fn get_Direction(&self, out: *mut super::super::controls::primitives::AnimationDirection) -> HRESULT,
    fn put_Direction(&self, value: super::super::controls::primitives::AnimationDirection) -> HRESULT
}}
impl IDragOverThemeAnimation {
    #[inline] pub unsafe fn get_target_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_to_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ToOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_to_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ToOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_direction(&self) -> Result<super::super::controls::primitives::AnimationDirection> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Direction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_direction(&self, value: super::super::controls::primitives::AnimationDirection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Direction)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDragOverThemeAnimationStatics, 342883927, 15517, 16857, 165, 255, 141, 114, 57, 81, 104, 16);
RT_INTERFACE!{static interface IDragOverThemeAnimationStatics(IDragOverThemeAnimationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDragOverThemeAnimationStatics] {
    fn get_TargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ToOffsetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_DirectionProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IDragOverThemeAnimationStatics {
    #[inline] pub unsafe fn get_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_to_offset_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ToOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_direction_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DirectionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class DragOverThemeAnimation: IDragOverThemeAnimation}
impl RtActivatable<IDragOverThemeAnimationStatics> for DragOverThemeAnimation {}
impl RtActivatable<IActivationFactory> for DragOverThemeAnimation {}
impl DragOverThemeAnimation {
    #[inline] pub fn get_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDragOverThemeAnimationStatics>>::get_activation_factory().get_target_name_property()
    }}
    #[inline] pub fn get_to_offset_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDragOverThemeAnimationStatics>>::get_activation_factory().get_to_offset_property()
    }}
    #[inline] pub fn get_direction_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDragOverThemeAnimationStatics>>::get_activation_factory().get_direction_property()
    }}
}
DEFINE_CLSID!(DragOverThemeAnimation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,68,114,97,103,79,118,101,114,84,104,101,109,101,65,110,105,109,97,116,105,111,110,0]) [CLSID_DragOverThemeAnimation]);
DEFINE_IID!(IID_IDrillInThemeAnimation, 2962274340, 61906, 16824, 135, 186, 120, 3, 65, 38, 89, 76);
RT_INTERFACE!{interface IDrillInThemeAnimation(IDrillInThemeAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IDrillInThemeAnimation] {
    fn get_EntranceTargetName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_EntranceTargetName(&self, value: HSTRING) -> HRESULT,
    fn get_EntranceTarget(&self, out: *mut *mut super::super::DependencyObject) -> HRESULT,
    fn put_EntranceTarget(&self, value: *mut super::super::DependencyObject) -> HRESULT,
    fn get_ExitTargetName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ExitTargetName(&self, value: HSTRING) -> HRESULT,
    fn get_ExitTarget(&self, out: *mut *mut super::super::DependencyObject) -> HRESULT,
    fn put_ExitTarget(&self, value: *mut super::super::DependencyObject) -> HRESULT
}}
impl IDrillInThemeAnimation {
    #[inline] pub unsafe fn get_entrance_target_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EntranceTargetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_entrance_target_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EntranceTargetName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_entrance_target(&self) -> Result<ComPtr<super::super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EntranceTarget)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_entrance_target(&self, value: &super::super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EntranceTarget)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_exit_target_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExitTargetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_exit_target_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ExitTargetName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_exit_target(&self) -> Result<ComPtr<super::super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExitTarget)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_exit_target(&self, value: &super::super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ExitTarget)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDrillInThemeAnimationStatics, 3323978888, 41338, 19217, 181, 59, 164, 241, 160, 125, 75, 169);
RT_INTERFACE!{static interface IDrillInThemeAnimationStatics(IDrillInThemeAnimationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDrillInThemeAnimationStatics] {
    fn get_EntranceTargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_EntranceTargetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ExitTargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ExitTargetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IDrillInThemeAnimationStatics {
    #[inline] pub unsafe fn get_entrance_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EntranceTargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_entrance_target_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EntranceTargetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_exit_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExitTargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_exit_target_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExitTargetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class DrillInThemeAnimation: IDrillInThemeAnimation}
impl RtActivatable<IDrillInThemeAnimationStatics> for DrillInThemeAnimation {}
impl RtActivatable<IActivationFactory> for DrillInThemeAnimation {}
impl DrillInThemeAnimation {
    #[inline] pub fn get_entrance_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDrillInThemeAnimationStatics>>::get_activation_factory().get_entrance_target_name_property()
    }}
    #[inline] pub fn get_entrance_target_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDrillInThemeAnimationStatics>>::get_activation_factory().get_entrance_target_property()
    }}
    #[inline] pub fn get_exit_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDrillInThemeAnimationStatics>>::get_activation_factory().get_exit_target_name_property()
    }}
    #[inline] pub fn get_exit_target_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDrillInThemeAnimationStatics>>::get_activation_factory().get_exit_target_property()
    }}
}
DEFINE_CLSID!(DrillInThemeAnimation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,68,114,105,108,108,73,110,84,104,101,109,101,65,110,105,109,97,116,105,111,110,0]) [CLSID_DrillInThemeAnimation]);
DEFINE_IID!(IID_IDrillOutThemeAnimation, 3633368287, 1747, 20350, 142, 74, 79, 183, 110, 37, 97, 57);
RT_INTERFACE!{interface IDrillOutThemeAnimation(IDrillOutThemeAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IDrillOutThemeAnimation] {
    fn get_EntranceTargetName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_EntranceTargetName(&self, value: HSTRING) -> HRESULT,
    fn get_EntranceTarget(&self, out: *mut *mut super::super::DependencyObject) -> HRESULT,
    fn put_EntranceTarget(&self, value: *mut super::super::DependencyObject) -> HRESULT,
    fn get_ExitTargetName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ExitTargetName(&self, value: HSTRING) -> HRESULT,
    fn get_ExitTarget(&self, out: *mut *mut super::super::DependencyObject) -> HRESULT,
    fn put_ExitTarget(&self, value: *mut super::super::DependencyObject) -> HRESULT
}}
impl IDrillOutThemeAnimation {
    #[inline] pub unsafe fn get_entrance_target_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EntranceTargetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_entrance_target_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EntranceTargetName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_entrance_target(&self) -> Result<ComPtr<super::super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EntranceTarget)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_entrance_target(&self, value: &super::super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EntranceTarget)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_exit_target_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExitTargetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_exit_target_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ExitTargetName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_exit_target(&self) -> Result<ComPtr<super::super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExitTarget)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_exit_target(&self, value: &super::super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ExitTarget)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDrillOutThemeAnimationStatics, 3199589275, 9751, 18568, 128, 221, 114, 250, 123, 182, 250, 195);
RT_INTERFACE!{static interface IDrillOutThemeAnimationStatics(IDrillOutThemeAnimationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDrillOutThemeAnimationStatics] {
    fn get_EntranceTargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_EntranceTargetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ExitTargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ExitTargetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IDrillOutThemeAnimationStatics {
    #[inline] pub unsafe fn get_entrance_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EntranceTargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_entrance_target_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EntranceTargetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_exit_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExitTargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_exit_target_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExitTargetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class DrillOutThemeAnimation: IDrillOutThemeAnimation}
impl RtActivatable<IDrillOutThemeAnimationStatics> for DrillOutThemeAnimation {}
impl RtActivatable<IActivationFactory> for DrillOutThemeAnimation {}
impl DrillOutThemeAnimation {
    #[inline] pub fn get_entrance_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDrillOutThemeAnimationStatics>>::get_activation_factory().get_entrance_target_name_property()
    }}
    #[inline] pub fn get_entrance_target_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDrillOutThemeAnimationStatics>>::get_activation_factory().get_entrance_target_property()
    }}
    #[inline] pub fn get_exit_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDrillOutThemeAnimationStatics>>::get_activation_factory().get_exit_target_name_property()
    }}
    #[inline] pub fn get_exit_target_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDrillOutThemeAnimationStatics>>::get_activation_factory().get_exit_target_property()
    }}
}
DEFINE_CLSID!(DrillOutThemeAnimation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,68,114,105,108,108,79,117,116,84,104,101,109,101,65,110,105,109,97,116,105,111,110,0]) [CLSID_DrillOutThemeAnimation]);
DEFINE_IID!(IID_IDropTargetItemThemeAnimation, 411158888, 6180, 17963, 135, 232, 195, 87, 33, 43, 151, 123);
RT_INTERFACE!{interface IDropTargetItemThemeAnimation(IDropTargetItemThemeAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IDropTargetItemThemeAnimation] {
    fn get_TargetName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TargetName(&self, value: HSTRING) -> HRESULT
}}
impl IDropTargetItemThemeAnimation {
    #[inline] pub unsafe fn get_target_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDropTargetItemThemeAnimationStatics, 2927686790, 11862, 17683, 191, 24, 215, 116, 112, 22, 74, 229);
RT_INTERFACE!{static interface IDropTargetItemThemeAnimationStatics(IDropTargetItemThemeAnimationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDropTargetItemThemeAnimationStatics] {
    fn get_TargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IDropTargetItemThemeAnimationStatics {
    #[inline] pub unsafe fn get_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class DropTargetItemThemeAnimation: IDropTargetItemThemeAnimation}
impl RtActivatable<IDropTargetItemThemeAnimationStatics> for DropTargetItemThemeAnimation {}
impl RtActivatable<IActivationFactory> for DropTargetItemThemeAnimation {}
impl DropTargetItemThemeAnimation {
    #[inline] pub fn get_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IDropTargetItemThemeAnimationStatics>>::get_activation_factory().get_target_name_property()
    }}
}
DEFINE_CLSID!(DropTargetItemThemeAnimation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,68,114,111,112,84,97,114,103,101,116,73,116,101,109,84,104,101,109,101,65,110,105,109,97,116,105,111,110,0]) [CLSID_DropTargetItemThemeAnimation]);
DEFINE_IID!(IID_IEasingColorKeyFrame, 3342063152, 62649, 18740, 155, 221, 39, 172, 94, 209, 207, 216);
RT_INTERFACE!{interface IEasingColorKeyFrame(IEasingColorKeyFrameVtbl): IInspectable(IInspectableVtbl) [IID_IEasingColorKeyFrame] {
    fn get_EasingFunction(&self, out: *mut *mut EasingFunctionBase) -> HRESULT,
    fn put_EasingFunction(&self, value: *mut EasingFunctionBase) -> HRESULT
}}
impl IEasingColorKeyFrame {
    #[inline] pub unsafe fn get_easing_function(&self) -> Result<ComPtr<EasingFunctionBase>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EasingFunction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_easing_function(&self, value: &EasingFunctionBase) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EasingFunction)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEasingColorKeyFrameStatics, 1865955324, 36413, 17698, 155, 15, 0, 61, 184, 96, 152, 81);
RT_INTERFACE!{static interface IEasingColorKeyFrameStatics(IEasingColorKeyFrameStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IEasingColorKeyFrameStatics] {
    fn get_EasingFunctionProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IEasingColorKeyFrameStatics {
    #[inline] pub unsafe fn get_easing_function_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EasingFunctionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EasingColorKeyFrame: IEasingColorKeyFrame}
impl RtActivatable<IEasingColorKeyFrameStatics> for EasingColorKeyFrame {}
impl RtActivatable<IActivationFactory> for EasingColorKeyFrame {}
impl EasingColorKeyFrame {
    #[inline] pub fn get_easing_function_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IEasingColorKeyFrameStatics>>::get_activation_factory().get_easing_function_property()
    }}
}
DEFINE_CLSID!(EasingColorKeyFrame(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,69,97,115,105,110,103,67,111,108,111,114,75,101,121,70,114,97,109,101,0]) [CLSID_EasingColorKeyFrame]);
DEFINE_IID!(IID_IEasingPointKeyFrame, 3016299392, 26728, 16933, 167, 11, 57, 129, 204, 11, 41, 71);
RT_INTERFACE!{interface IEasingPointKeyFrame(IEasingPointKeyFrameVtbl): IInspectable(IInspectableVtbl) [IID_IEasingPointKeyFrame] {
    fn get_EasingFunction(&self, out: *mut *mut EasingFunctionBase) -> HRESULT,
    fn put_EasingFunction(&self, value: *mut EasingFunctionBase) -> HRESULT
}}
impl IEasingPointKeyFrame {
    #[inline] pub unsafe fn get_easing_function(&self) -> Result<ComPtr<EasingFunctionBase>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EasingFunction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_easing_function(&self, value: &EasingFunctionBase) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EasingFunction)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEasingPointKeyFrameStatics, 3794649028, 2060, 16428, 166, 181, 244, 141, 10, 152, 17, 107);
RT_INTERFACE!{static interface IEasingPointKeyFrameStatics(IEasingPointKeyFrameStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IEasingPointKeyFrameStatics] {
    fn get_EasingFunctionProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IEasingPointKeyFrameStatics {
    #[inline] pub unsafe fn get_easing_function_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EasingFunctionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EasingPointKeyFrame: IEasingPointKeyFrame}
impl RtActivatable<IEasingPointKeyFrameStatics> for EasingPointKeyFrame {}
impl RtActivatable<IActivationFactory> for EasingPointKeyFrame {}
impl EasingPointKeyFrame {
    #[inline] pub fn get_easing_function_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IEasingPointKeyFrameStatics>>::get_activation_factory().get_easing_function_property()
    }}
}
DEFINE_CLSID!(EasingPointKeyFrame(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,69,97,115,105,110,103,80,111,105,110,116,75,101,121,70,114,97,109,101,0]) [CLSID_EasingPointKeyFrame]);
DEFINE_IID!(IID_IFadeInThemeAnimation, 1833683189, 43288, 17527, 128, 120, 85, 76, 104, 129, 42, 184);
RT_INTERFACE!{interface IFadeInThemeAnimation(IFadeInThemeAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IFadeInThemeAnimation] {
    fn get_TargetName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TargetName(&self, value: HSTRING) -> HRESULT
}}
impl IFadeInThemeAnimation {
    #[inline] pub unsafe fn get_target_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFadeInThemeAnimationStatics, 2130778081, 48809, 18723, 178, 58, 13, 223, 77, 123, 135, 55);
RT_INTERFACE!{static interface IFadeInThemeAnimationStatics(IFadeInThemeAnimationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IFadeInThemeAnimationStatics] {
    fn get_TargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IFadeInThemeAnimationStatics {
    #[inline] pub unsafe fn get_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class FadeInThemeAnimation: IFadeInThemeAnimation}
impl RtActivatable<IFadeInThemeAnimationStatics> for FadeInThemeAnimation {}
impl RtActivatable<IActivationFactory> for FadeInThemeAnimation {}
impl FadeInThemeAnimation {
    #[inline] pub fn get_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFadeInThemeAnimationStatics>>::get_activation_factory().get_target_name_property()
    }}
}
DEFINE_CLSID!(FadeInThemeAnimation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,70,97,100,101,73,110,84,104,101,109,101,65,110,105,109,97,116,105,111,110,0]) [CLSID_FadeInThemeAnimation]);
DEFINE_IID!(IID_IFadeOutThemeAnimation, 2301062057, 65492, 17846, 155, 154, 206, 212, 137, 81, 231, 18);
RT_INTERFACE!{interface IFadeOutThemeAnimation(IFadeOutThemeAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IFadeOutThemeAnimation] {
    fn get_TargetName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TargetName(&self, value: HSTRING) -> HRESULT
}}
impl IFadeOutThemeAnimation {
    #[inline] pub unsafe fn get_target_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFadeOutThemeAnimationStatics, 4262963226, 16744, 20328, 162, 140, 229, 221, 152, 207, 104, 15);
RT_INTERFACE!{static interface IFadeOutThemeAnimationStatics(IFadeOutThemeAnimationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IFadeOutThemeAnimationStatics] {
    fn get_TargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IFadeOutThemeAnimationStatics {
    #[inline] pub unsafe fn get_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class FadeOutThemeAnimation: IFadeOutThemeAnimation}
impl RtActivatable<IFadeOutThemeAnimationStatics> for FadeOutThemeAnimation {}
impl RtActivatable<IActivationFactory> for FadeOutThemeAnimation {}
impl FadeOutThemeAnimation {
    #[inline] pub fn get_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IFadeOutThemeAnimationStatics>>::get_activation_factory().get_target_name_property()
    }}
}
DEFINE_CLSID!(FadeOutThemeAnimation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,70,97,100,101,79,117,116,84,104,101,109,101,65,110,105,109,97,116,105,111,110,0]) [CLSID_FadeOutThemeAnimation]);
DEFINE_IID!(IID_ILinearColorKeyFrame, 1727903471, 44161, 17937, 177, 210, 97, 245, 69, 152, 63, 3);
RT_INTERFACE!{interface ILinearColorKeyFrame(ILinearColorKeyFrameVtbl): IInspectable(IInspectableVtbl) [IID_ILinearColorKeyFrame] {
    
}}
RT_CLASS!{class LinearColorKeyFrame: ILinearColorKeyFrame}
impl RtActivatable<IActivationFactory> for LinearColorKeyFrame {}
DEFINE_CLSID!(LinearColorKeyFrame(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,76,105,110,101,97,114,67,111,108,111,114,75,101,121,70,114,97,109,101,0]) [CLSID_LinearColorKeyFrame]);
DEFINE_IID!(IID_ILinearPointKeyFrame, 3888756975, 44836, 18926, 132, 241, 168, 102, 0, 164, 227, 25);
RT_INTERFACE!{interface ILinearPointKeyFrame(ILinearPointKeyFrameVtbl): IInspectable(IInspectableVtbl) [IID_ILinearPointKeyFrame] {
    
}}
RT_CLASS!{class LinearPointKeyFrame: ILinearPointKeyFrame}
impl RtActivatable<IActivationFactory> for LinearPointKeyFrame {}
DEFINE_CLSID!(LinearPointKeyFrame(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,76,105,110,101,97,114,80,111,105,110,116,75,101,121,70,114,97,109,101,0]) [CLSID_LinearPointKeyFrame]);
DEFINE_IID!(IID_IPointAnimationUsingKeyFrames, 2610188146, 17514, 16848, 161, 41, 65, 166, 32, 244, 89, 93);
RT_INTERFACE!{interface IPointAnimationUsingKeyFrames(IPointAnimationUsingKeyFramesVtbl): IInspectable(IInspectableVtbl) [IID_IPointAnimationUsingKeyFrames] {
    fn get_KeyFrames(&self, out: *mut *mut PointKeyFrameCollection) -> HRESULT,
    fn get_EnableDependentAnimation(&self, out: *mut bool) -> HRESULT,
    fn put_EnableDependentAnimation(&self, value: bool) -> HRESULT
}}
impl IPointAnimationUsingKeyFrames {
    #[inline] pub unsafe fn get_key_frames(&self) -> Result<ComPtr<PointKeyFrameCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeyFrames)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_enable_dependent_animation(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EnableDependentAnimation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_enable_dependent_animation(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EnableDependentAnimation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPointAnimationUsingKeyFramesStatics, 1598377095, 9104, 18154, 186, 167, 118, 47, 75, 195, 13, 4);
RT_INTERFACE!{static interface IPointAnimationUsingKeyFramesStatics(IPointAnimationUsingKeyFramesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPointAnimationUsingKeyFramesStatics] {
    fn get_EnableDependentAnimationProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IPointAnimationUsingKeyFramesStatics {
    #[inline] pub unsafe fn get_enable_dependent_animation_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EnableDependentAnimationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PointAnimationUsingKeyFrames: IPointAnimationUsingKeyFrames}
impl RtActivatable<IPointAnimationUsingKeyFramesStatics> for PointAnimationUsingKeyFrames {}
impl RtActivatable<IActivationFactory> for PointAnimationUsingKeyFrames {}
impl PointAnimationUsingKeyFrames {
    #[inline] pub fn get_enable_dependent_animation_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPointAnimationUsingKeyFramesStatics>>::get_activation_factory().get_enable_dependent_animation_property()
    }}
}
DEFINE_CLSID!(PointAnimationUsingKeyFrames(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,80,111,105,110,116,65,110,105,109,97,116,105,111,110,85,115,105,110,103,75,101,121,70,114,97,109,101,115,0]) [CLSID_PointAnimationUsingKeyFrames]);
DEFINE_IID!(IID_IPointerDownThemeAnimation, 3046011214, 50333, 18312, 162, 51, 10, 232, 93, 153, 221, 90);
RT_INTERFACE!{interface IPointerDownThemeAnimation(IPointerDownThemeAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IPointerDownThemeAnimation] {
    fn get_TargetName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TargetName(&self, value: HSTRING) -> HRESULT
}}
impl IPointerDownThemeAnimation {
    #[inline] pub unsafe fn get_target_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPointerDownThemeAnimationStatics, 1671940987, 27974, 17556, 185, 74, 231, 47, 59, 73, 42, 97);
RT_INTERFACE!{static interface IPointerDownThemeAnimationStatics(IPointerDownThemeAnimationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPointerDownThemeAnimationStatics] {
    fn get_TargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IPointerDownThemeAnimationStatics {
    #[inline] pub unsafe fn get_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PointerDownThemeAnimation: IPointerDownThemeAnimation}
impl RtActivatable<IPointerDownThemeAnimationStatics> for PointerDownThemeAnimation {}
impl RtActivatable<IActivationFactory> for PointerDownThemeAnimation {}
impl PointerDownThemeAnimation {
    #[inline] pub fn get_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPointerDownThemeAnimationStatics>>::get_activation_factory().get_target_name_property()
    }}
}
DEFINE_CLSID!(PointerDownThemeAnimation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,80,111,105,110,116,101,114,68,111,119,110,84,104,101,109,101,65,110,105,109,97,116,105,111,110,0]) [CLSID_PointerDownThemeAnimation]);
DEFINE_IID!(IID_IPointerUpThemeAnimation, 3924414589, 25408, 18472, 173, 18, 105, 6, 148, 185, 145, 11);
RT_INTERFACE!{interface IPointerUpThemeAnimation(IPointerUpThemeAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IPointerUpThemeAnimation] {
    fn get_TargetName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TargetName(&self, value: HSTRING) -> HRESULT
}}
impl IPointerUpThemeAnimation {
    #[inline] pub unsafe fn get_target_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPointerUpThemeAnimationStatics, 2086768540, 31122, 16697, 139, 252, 8, 131, 185, 114, 122, 126);
RT_INTERFACE!{static interface IPointerUpThemeAnimationStatics(IPointerUpThemeAnimationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPointerUpThemeAnimationStatics] {
    fn get_TargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IPointerUpThemeAnimationStatics {
    #[inline] pub unsafe fn get_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PointerUpThemeAnimation: IPointerUpThemeAnimation}
impl RtActivatable<IPointerUpThemeAnimationStatics> for PointerUpThemeAnimation {}
impl RtActivatable<IActivationFactory> for PointerUpThemeAnimation {}
impl PointerUpThemeAnimation {
    #[inline] pub fn get_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPointerUpThemeAnimationStatics>>::get_activation_factory().get_target_name_property()
    }}
}
DEFINE_CLSID!(PointerUpThemeAnimation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,80,111,105,110,116,101,114,85,112,84,104,101,109,101,65,110,105,109,97,116,105,111,110,0]) [CLSID_PointerUpThemeAnimation]);
DEFINE_IID!(IID_IPopInThemeAnimation, 426326209, 7175, 19496, 136, 71, 249, 240, 85, 179, 40, 85);
RT_INTERFACE!{interface IPopInThemeAnimation(IPopInThemeAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IPopInThemeAnimation] {
    fn get_TargetName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TargetName(&self, value: HSTRING) -> HRESULT,
    fn get_FromHorizontalOffset(&self, out: *mut f64) -> HRESULT,
    fn put_FromHorizontalOffset(&self, value: f64) -> HRESULT,
    fn get_FromVerticalOffset(&self, out: *mut f64) -> HRESULT,
    fn put_FromVerticalOffset(&self, value: f64) -> HRESULT
}}
impl IPopInThemeAnimation {
    #[inline] pub unsafe fn get_target_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_from_horizontal_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FromHorizontalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_from_horizontal_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FromHorizontalOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_from_vertical_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FromVerticalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_from_vertical_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FromVerticalOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPopInThemeAnimationStatics, 4020935123, 8586, 18177, 151, 127, 241, 191, 174, 139, 166, 73);
RT_INTERFACE!{static interface IPopInThemeAnimationStatics(IPopInThemeAnimationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPopInThemeAnimationStatics] {
    fn get_TargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_FromHorizontalOffsetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_FromVerticalOffsetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IPopInThemeAnimationStatics {
    #[inline] pub unsafe fn get_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_from_horizontal_offset_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FromHorizontalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_from_vertical_offset_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FromVerticalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PopInThemeAnimation: IPopInThemeAnimation}
impl RtActivatable<IPopInThemeAnimationStatics> for PopInThemeAnimation {}
impl RtActivatable<IActivationFactory> for PopInThemeAnimation {}
impl PopInThemeAnimation {
    #[inline] pub fn get_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPopInThemeAnimationStatics>>::get_activation_factory().get_target_name_property()
    }}
    #[inline] pub fn get_from_horizontal_offset_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPopInThemeAnimationStatics>>::get_activation_factory().get_from_horizontal_offset_property()
    }}
    #[inline] pub fn get_from_vertical_offset_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPopInThemeAnimationStatics>>::get_activation_factory().get_from_vertical_offset_property()
    }}
}
DEFINE_CLSID!(PopInThemeAnimation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,80,111,112,73,110,84,104,101,109,101,65,110,105,109,97,116,105,111,110,0]) [CLSID_PopInThemeAnimation]);
DEFINE_IID!(IID_IPopOutThemeAnimation, 1200008009, 3656, 20097, 162, 229, 204, 90, 161, 158, 72, 211);
RT_INTERFACE!{interface IPopOutThemeAnimation(IPopOutThemeAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IPopOutThemeAnimation] {
    fn get_TargetName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TargetName(&self, value: HSTRING) -> HRESULT
}}
impl IPopOutThemeAnimation {
    #[inline] pub unsafe fn get_target_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPopOutThemeAnimationStatics, 491334665, 961, 17552, 153, 220, 144, 159, 234, 179, 87, 251);
RT_INTERFACE!{static interface IPopOutThemeAnimationStatics(IPopOutThemeAnimationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPopOutThemeAnimationStatics] {
    fn get_TargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IPopOutThemeAnimationStatics {
    #[inline] pub unsafe fn get_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PopOutThemeAnimation: IPopOutThemeAnimation}
impl RtActivatable<IPopOutThemeAnimationStatics> for PopOutThemeAnimation {}
impl RtActivatable<IActivationFactory> for PopOutThemeAnimation {}
impl PopOutThemeAnimation {
    #[inline] pub fn get_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPopOutThemeAnimationStatics>>::get_activation_factory().get_target_name_property()
    }}
}
DEFINE_CLSID!(PopOutThemeAnimation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,80,111,112,79,117,116,84,104,101,109,101,65,110,105,109,97,116,105,111,110,0]) [CLSID_PopOutThemeAnimation]);
DEFINE_IID!(IID_IRepositionThemeAnimation, 3973719272, 35141, 18761, 161, 191, 98, 16, 153, 101, 167, 233);
RT_INTERFACE!{interface IRepositionThemeAnimation(IRepositionThemeAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IRepositionThemeAnimation] {
    fn get_TargetName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TargetName(&self, value: HSTRING) -> HRESULT,
    fn get_FromHorizontalOffset(&self, out: *mut f64) -> HRESULT,
    fn put_FromHorizontalOffset(&self, value: f64) -> HRESULT,
    fn get_FromVerticalOffset(&self, out: *mut f64) -> HRESULT,
    fn put_FromVerticalOffset(&self, value: f64) -> HRESULT
}}
impl IRepositionThemeAnimation {
    #[inline] pub unsafe fn get_target_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_from_horizontal_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FromHorizontalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_from_horizontal_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FromHorizontalOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_from_vertical_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FromVerticalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_from_vertical_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FromVerticalOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRepositionThemeAnimationStatics, 1301459377, 34315, 19449, 165, 157, 30, 177, 204, 190, 143, 224);
RT_INTERFACE!{static interface IRepositionThemeAnimationStatics(IRepositionThemeAnimationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRepositionThemeAnimationStatics] {
    fn get_TargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_FromHorizontalOffsetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_FromVerticalOffsetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IRepositionThemeAnimationStatics {
    #[inline] pub unsafe fn get_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_from_horizontal_offset_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FromHorizontalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_from_vertical_offset_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FromVerticalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class RepositionThemeAnimation: IRepositionThemeAnimation}
impl RtActivatable<IRepositionThemeAnimationStatics> for RepositionThemeAnimation {}
impl RtActivatable<IActivationFactory> for RepositionThemeAnimation {}
impl RepositionThemeAnimation {
    #[inline] pub fn get_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRepositionThemeAnimationStatics>>::get_activation_factory().get_target_name_property()
    }}
    #[inline] pub fn get_from_horizontal_offset_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRepositionThemeAnimationStatics>>::get_activation_factory().get_from_horizontal_offset_property()
    }}
    #[inline] pub fn get_from_vertical_offset_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRepositionThemeAnimationStatics>>::get_activation_factory().get_from_vertical_offset_property()
    }}
}
DEFINE_CLSID!(RepositionThemeAnimation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,82,101,112,111,115,105,116,105,111,110,84,104,101,109,101,65,110,105,109,97,116,105,111,110,0]) [CLSID_RepositionThemeAnimation]);
DEFINE_IID!(IID_ISplineColorKeyFrame, 441080129, 8160, 18234, 142, 254, 67, 22, 216, 200, 98, 41);
RT_INTERFACE!{interface ISplineColorKeyFrame(ISplineColorKeyFrameVtbl): IInspectable(IInspectableVtbl) [IID_ISplineColorKeyFrame] {
    fn get_KeySpline(&self, out: *mut *mut KeySpline) -> HRESULT,
    fn put_KeySpline(&self, value: *mut KeySpline) -> HRESULT
}}
impl ISplineColorKeyFrame {
    #[inline] pub unsafe fn get_key_spline(&self) -> Result<ComPtr<KeySpline>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeySpline)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_key_spline(&self, value: &KeySpline) -> Result<()> {
        let hr = ((*self.lpVtbl).put_KeySpline)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISplineColorKeyFrameStatics, 1641142679, 34185, 20271, 143, 187, 125, 3, 237, 201, 141, 211);
RT_INTERFACE!{static interface ISplineColorKeyFrameStatics(ISplineColorKeyFrameStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISplineColorKeyFrameStatics] {
    fn get_KeySplineProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl ISplineColorKeyFrameStatics {
    #[inline] pub unsafe fn get_key_spline_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeySplineProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SplineColorKeyFrame: ISplineColorKeyFrame}
impl RtActivatable<ISplineColorKeyFrameStatics> for SplineColorKeyFrame {}
impl RtActivatable<IActivationFactory> for SplineColorKeyFrame {}
impl SplineColorKeyFrame {
    #[inline] pub fn get_key_spline_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplineColorKeyFrameStatics>>::get_activation_factory().get_key_spline_property()
    }}
}
DEFINE_CLSID!(SplineColorKeyFrame(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,83,112,108,105,110,101,67,111,108,111,114,75,101,121,70,114,97,109,101,0]) [CLSID_SplineColorKeyFrame]);
DEFINE_IID!(IID_ISplinePointKeyFrame, 253358854, 28726, 18767, 188, 60, 120, 13, 240, 204, 82, 74);
RT_INTERFACE!{interface ISplinePointKeyFrame(ISplinePointKeyFrameVtbl): IInspectable(IInspectableVtbl) [IID_ISplinePointKeyFrame] {
    fn get_KeySpline(&self, out: *mut *mut KeySpline) -> HRESULT,
    fn put_KeySpline(&self, value: *mut KeySpline) -> HRESULT
}}
impl ISplinePointKeyFrame {
    #[inline] pub unsafe fn get_key_spline(&self) -> Result<ComPtr<KeySpline>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeySpline)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_key_spline(&self, value: &KeySpline) -> Result<()> {
        let hr = ((*self.lpVtbl).put_KeySpline)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISplinePointKeyFrameStatics, 3917099714, 2682, 18278, 149, 203, 13, 105, 38, 17, 203, 76);
RT_INTERFACE!{static interface ISplinePointKeyFrameStatics(ISplinePointKeyFrameStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISplinePointKeyFrameStatics] {
    fn get_KeySplineProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl ISplinePointKeyFrameStatics {
    #[inline] pub unsafe fn get_key_spline_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeySplineProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SplinePointKeyFrame: ISplinePointKeyFrame}
impl RtActivatable<ISplinePointKeyFrameStatics> for SplinePointKeyFrame {}
impl RtActivatable<IActivationFactory> for SplinePointKeyFrame {}
impl SplinePointKeyFrame {
    #[inline] pub fn get_key_spline_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplinePointKeyFrameStatics>>::get_activation_factory().get_key_spline_property()
    }}
}
DEFINE_CLSID!(SplinePointKeyFrame(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,83,112,108,105,110,101,80,111,105,110,116,75,101,121,70,114,97,109,101,0]) [CLSID_SplinePointKeyFrame]);
DEFINE_IID!(IID_ISplitCloseThemeAnimation, 1333368088, 65337, 20112, 187, 116, 42, 189, 86, 2, 116, 2);
RT_INTERFACE!{interface ISplitCloseThemeAnimation(ISplitCloseThemeAnimationVtbl): IInspectable(IInspectableVtbl) [IID_ISplitCloseThemeAnimation] {
    fn get_OpenedTargetName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_OpenedTargetName(&self, value: HSTRING) -> HRESULT,
    fn get_OpenedTarget(&self, out: *mut *mut super::super::DependencyObject) -> HRESULT,
    fn put_OpenedTarget(&self, value: *mut super::super::DependencyObject) -> HRESULT,
    fn get_ClosedTargetName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ClosedTargetName(&self, value: HSTRING) -> HRESULT,
    fn get_ClosedTarget(&self, out: *mut *mut super::super::DependencyObject) -> HRESULT,
    fn put_ClosedTarget(&self, value: *mut super::super::DependencyObject) -> HRESULT,
    fn get_ContentTargetName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ContentTargetName(&self, value: HSTRING) -> HRESULT,
    fn get_ContentTarget(&self, out: *mut *mut super::super::DependencyObject) -> HRESULT,
    fn put_ContentTarget(&self, value: *mut super::super::DependencyObject) -> HRESULT,
    fn get_OpenedLength(&self, out: *mut f64) -> HRESULT,
    fn put_OpenedLength(&self, value: f64) -> HRESULT,
    fn get_ClosedLength(&self, out: *mut f64) -> HRESULT,
    fn put_ClosedLength(&self, value: f64) -> HRESULT,
    fn get_OffsetFromCenter(&self, out: *mut f64) -> HRESULT,
    fn put_OffsetFromCenter(&self, value: f64) -> HRESULT,
    fn get_ContentTranslationDirection(&self, out: *mut super::super::controls::primitives::AnimationDirection) -> HRESULT,
    fn put_ContentTranslationDirection(&self, value: super::super::controls::primitives::AnimationDirection) -> HRESULT,
    fn get_ContentTranslationOffset(&self, out: *mut f64) -> HRESULT,
    fn put_ContentTranslationOffset(&self, value: f64) -> HRESULT
}}
impl ISplitCloseThemeAnimation {
    #[inline] pub unsafe fn get_opened_target_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OpenedTargetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_opened_target_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OpenedTargetName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_opened_target(&self) -> Result<ComPtr<super::super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OpenedTarget)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_opened_target(&self, value: &super::super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OpenedTarget)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_closed_target_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ClosedTargetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_closed_target_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ClosedTargetName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_closed_target(&self) -> Result<ComPtr<super::super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ClosedTarget)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_closed_target(&self, value: &super::super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ClosedTarget)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_target_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTargetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_target_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentTargetName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_target(&self) -> Result<ComPtr<super::super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTarget)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_target(&self, value: &super::super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentTarget)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_opened_length(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OpenedLength)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_opened_length(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OpenedLength)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_closed_length(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ClosedLength)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_closed_length(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ClosedLength)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_offset_from_center(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OffsetFromCenter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_offset_from_center(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OffsetFromCenter)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_translation_direction(&self) -> Result<super::super::controls::primitives::AnimationDirection> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ContentTranslationDirection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_translation_direction(&self, value: super::super::controls::primitives::AnimationDirection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentTranslationDirection)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_translation_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ContentTranslationOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_translation_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentTranslationOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISplitCloseThemeAnimationStatics, 2057915881, 52379, 20112, 161, 26, 0, 80, 162, 33, 106, 158);
RT_INTERFACE!{static interface ISplitCloseThemeAnimationStatics(ISplitCloseThemeAnimationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISplitCloseThemeAnimationStatics] {
    fn get_OpenedTargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_OpenedTargetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ClosedTargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ClosedTargetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ContentTargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ContentTargetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_OpenedLengthProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ClosedLengthProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_OffsetFromCenterProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ContentTranslationDirectionProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ContentTranslationOffsetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl ISplitCloseThemeAnimationStatics {
    #[inline] pub unsafe fn get_opened_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OpenedTargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_opened_target_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OpenedTargetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_closed_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ClosedTargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_closed_target_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ClosedTargetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_target_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTargetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_opened_length_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OpenedLengthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_closed_length_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ClosedLengthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_offset_from_center_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OffsetFromCenterProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_translation_direction_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTranslationDirectionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_translation_offset_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTranslationOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SplitCloseThemeAnimation: ISplitCloseThemeAnimation}
impl RtActivatable<ISplitCloseThemeAnimationStatics> for SplitCloseThemeAnimation {}
impl RtActivatable<IActivationFactory> for SplitCloseThemeAnimation {}
impl SplitCloseThemeAnimation {
    #[inline] pub fn get_opened_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitCloseThemeAnimationStatics>>::get_activation_factory().get_opened_target_name_property()
    }}
    #[inline] pub fn get_opened_target_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitCloseThemeAnimationStatics>>::get_activation_factory().get_opened_target_property()
    }}
    #[inline] pub fn get_closed_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitCloseThemeAnimationStatics>>::get_activation_factory().get_closed_target_name_property()
    }}
    #[inline] pub fn get_closed_target_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitCloseThemeAnimationStatics>>::get_activation_factory().get_closed_target_property()
    }}
    #[inline] pub fn get_content_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitCloseThemeAnimationStatics>>::get_activation_factory().get_content_target_name_property()
    }}
    #[inline] pub fn get_content_target_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitCloseThemeAnimationStatics>>::get_activation_factory().get_content_target_property()
    }}
    #[inline] pub fn get_opened_length_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitCloseThemeAnimationStatics>>::get_activation_factory().get_opened_length_property()
    }}
    #[inline] pub fn get_closed_length_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitCloseThemeAnimationStatics>>::get_activation_factory().get_closed_length_property()
    }}
    #[inline] pub fn get_offset_from_center_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitCloseThemeAnimationStatics>>::get_activation_factory().get_offset_from_center_property()
    }}
    #[inline] pub fn get_content_translation_direction_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitCloseThemeAnimationStatics>>::get_activation_factory().get_content_translation_direction_property()
    }}
    #[inline] pub fn get_content_translation_offset_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitCloseThemeAnimationStatics>>::get_activation_factory().get_content_translation_offset_property()
    }}
}
DEFINE_CLSID!(SplitCloseThemeAnimation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,83,112,108,105,116,67,108,111,115,101,84,104,101,109,101,65,110,105,109,97,116,105,111,110,0]) [CLSID_SplitCloseThemeAnimation]);
DEFINE_IID!(IID_ISplitOpenThemeAnimation, 2019547050, 21590, 17977, 143, 210, 38, 186, 230, 165, 255, 228);
RT_INTERFACE!{interface ISplitOpenThemeAnimation(ISplitOpenThemeAnimationVtbl): IInspectable(IInspectableVtbl) [IID_ISplitOpenThemeAnimation] {
    fn get_OpenedTargetName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_OpenedTargetName(&self, value: HSTRING) -> HRESULT,
    fn get_OpenedTarget(&self, out: *mut *mut super::super::DependencyObject) -> HRESULT,
    fn put_OpenedTarget(&self, value: *mut super::super::DependencyObject) -> HRESULT,
    fn get_ClosedTargetName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ClosedTargetName(&self, value: HSTRING) -> HRESULT,
    fn get_ClosedTarget(&self, out: *mut *mut super::super::DependencyObject) -> HRESULT,
    fn put_ClosedTarget(&self, value: *mut super::super::DependencyObject) -> HRESULT,
    fn get_ContentTargetName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ContentTargetName(&self, value: HSTRING) -> HRESULT,
    fn get_ContentTarget(&self, out: *mut *mut super::super::DependencyObject) -> HRESULT,
    fn put_ContentTarget(&self, value: *mut super::super::DependencyObject) -> HRESULT,
    fn get_OpenedLength(&self, out: *mut f64) -> HRESULT,
    fn put_OpenedLength(&self, value: f64) -> HRESULT,
    fn get_ClosedLength(&self, out: *mut f64) -> HRESULT,
    fn put_ClosedLength(&self, value: f64) -> HRESULT,
    fn get_OffsetFromCenter(&self, out: *mut f64) -> HRESULT,
    fn put_OffsetFromCenter(&self, value: f64) -> HRESULT,
    fn get_ContentTranslationDirection(&self, out: *mut super::super::controls::primitives::AnimationDirection) -> HRESULT,
    fn put_ContentTranslationDirection(&self, value: super::super::controls::primitives::AnimationDirection) -> HRESULT,
    fn get_ContentTranslationOffset(&self, out: *mut f64) -> HRESULT,
    fn put_ContentTranslationOffset(&self, value: f64) -> HRESULT
}}
impl ISplitOpenThemeAnimation {
    #[inline] pub unsafe fn get_opened_target_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OpenedTargetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_opened_target_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OpenedTargetName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_opened_target(&self) -> Result<ComPtr<super::super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OpenedTarget)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_opened_target(&self, value: &super::super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OpenedTarget)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_closed_target_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ClosedTargetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_closed_target_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ClosedTargetName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_closed_target(&self) -> Result<ComPtr<super::super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ClosedTarget)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_closed_target(&self, value: &super::super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ClosedTarget)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_target_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTargetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_target_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentTargetName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_target(&self) -> Result<ComPtr<super::super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTarget)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_target(&self, value: &super::super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentTarget)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_opened_length(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OpenedLength)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_opened_length(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OpenedLength)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_closed_length(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ClosedLength)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_closed_length(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ClosedLength)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_offset_from_center(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OffsetFromCenter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_offset_from_center(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OffsetFromCenter)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_translation_direction(&self) -> Result<super::super::controls::primitives::AnimationDirection> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ContentTranslationDirection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_translation_direction(&self, value: super::super::controls::primitives::AnimationDirection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentTranslationDirection)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_translation_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ContentTranslationOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_translation_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentTranslationOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISplitOpenThemeAnimationStatics, 2370632329, 14993, 17805, 176, 251, 76, 173, 98, 92, 191, 141);
RT_INTERFACE!{static interface ISplitOpenThemeAnimationStatics(ISplitOpenThemeAnimationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISplitOpenThemeAnimationStatics] {
    fn get_OpenedTargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_OpenedTargetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ClosedTargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ClosedTargetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ContentTargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ContentTargetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_OpenedLengthProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ClosedLengthProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_OffsetFromCenterProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ContentTranslationDirectionProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ContentTranslationOffsetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl ISplitOpenThemeAnimationStatics {
    #[inline] pub unsafe fn get_opened_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OpenedTargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_opened_target_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OpenedTargetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_closed_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ClosedTargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_closed_target_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ClosedTargetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_target_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTargetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_opened_length_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OpenedLengthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_closed_length_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ClosedLengthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_offset_from_center_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OffsetFromCenterProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_translation_direction_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTranslationDirectionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_translation_offset_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentTranslationOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SplitOpenThemeAnimation: ISplitOpenThemeAnimation}
impl RtActivatable<ISplitOpenThemeAnimationStatics> for SplitOpenThemeAnimation {}
impl RtActivatable<IActivationFactory> for SplitOpenThemeAnimation {}
impl SplitOpenThemeAnimation {
    #[inline] pub fn get_opened_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitOpenThemeAnimationStatics>>::get_activation_factory().get_opened_target_name_property()
    }}
    #[inline] pub fn get_opened_target_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitOpenThemeAnimationStatics>>::get_activation_factory().get_opened_target_property()
    }}
    #[inline] pub fn get_closed_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitOpenThemeAnimationStatics>>::get_activation_factory().get_closed_target_name_property()
    }}
    #[inline] pub fn get_closed_target_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitOpenThemeAnimationStatics>>::get_activation_factory().get_closed_target_property()
    }}
    #[inline] pub fn get_content_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitOpenThemeAnimationStatics>>::get_activation_factory().get_content_target_name_property()
    }}
    #[inline] pub fn get_content_target_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitOpenThemeAnimationStatics>>::get_activation_factory().get_content_target_property()
    }}
    #[inline] pub fn get_opened_length_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitOpenThemeAnimationStatics>>::get_activation_factory().get_opened_length_property()
    }}
    #[inline] pub fn get_closed_length_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitOpenThemeAnimationStatics>>::get_activation_factory().get_closed_length_property()
    }}
    #[inline] pub fn get_offset_from_center_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitOpenThemeAnimationStatics>>::get_activation_factory().get_offset_from_center_property()
    }}
    #[inline] pub fn get_content_translation_direction_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitOpenThemeAnimationStatics>>::get_activation_factory().get_content_translation_direction_property()
    }}
    #[inline] pub fn get_content_translation_offset_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISplitOpenThemeAnimationStatics>>::get_activation_factory().get_content_translation_offset_property()
    }}
}
DEFINE_CLSID!(SplitOpenThemeAnimation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,83,112,108,105,116,79,112,101,110,84,104,101,109,101,65,110,105,109,97,116,105,111,110,0]) [CLSID_SplitOpenThemeAnimation]);
DEFINE_IID!(IID_ISwipeBackThemeAnimation, 2743747092, 3018, 19757, 149, 247, 206, 186, 87, 251, 175, 96);
RT_INTERFACE!{interface ISwipeBackThemeAnimation(ISwipeBackThemeAnimationVtbl): IInspectable(IInspectableVtbl) [IID_ISwipeBackThemeAnimation] {
    fn get_TargetName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TargetName(&self, value: HSTRING) -> HRESULT,
    fn get_FromHorizontalOffset(&self, out: *mut f64) -> HRESULT,
    fn put_FromHorizontalOffset(&self, value: f64) -> HRESULT,
    fn get_FromVerticalOffset(&self, out: *mut f64) -> HRESULT,
    fn put_FromVerticalOffset(&self, value: f64) -> HRESULT
}}
impl ISwipeBackThemeAnimation {
    #[inline] pub unsafe fn get_target_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_from_horizontal_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FromHorizontalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_from_horizontal_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FromHorizontalOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_from_vertical_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FromVerticalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_from_vertical_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FromVerticalOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISwipeBackThemeAnimationStatics, 1765749183, 19878, 18058, 140, 224, 153, 108, 154, 173, 66, 224);
RT_INTERFACE!{static interface ISwipeBackThemeAnimationStatics(ISwipeBackThemeAnimationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISwipeBackThemeAnimationStatics] {
    fn get_TargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_FromHorizontalOffsetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_FromVerticalOffsetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl ISwipeBackThemeAnimationStatics {
    #[inline] pub unsafe fn get_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_from_horizontal_offset_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FromHorizontalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_from_vertical_offset_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FromVerticalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SwipeBackThemeAnimation: ISwipeBackThemeAnimation}
impl RtActivatable<ISwipeBackThemeAnimationStatics> for SwipeBackThemeAnimation {}
impl RtActivatable<IActivationFactory> for SwipeBackThemeAnimation {}
impl SwipeBackThemeAnimation {
    #[inline] pub fn get_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISwipeBackThemeAnimationStatics>>::get_activation_factory().get_target_name_property()
    }}
    #[inline] pub fn get_from_horizontal_offset_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISwipeBackThemeAnimationStatics>>::get_activation_factory().get_from_horizontal_offset_property()
    }}
    #[inline] pub fn get_from_vertical_offset_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISwipeBackThemeAnimationStatics>>::get_activation_factory().get_from_vertical_offset_property()
    }}
}
DEFINE_CLSID!(SwipeBackThemeAnimation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,83,119,105,112,101,66,97,99,107,84,104,101,109,101,65,110,105,109,97,116,105,111,110,0]) [CLSID_SwipeBackThemeAnimation]);
DEFINE_IID!(IID_ISwipeHintThemeAnimation, 3452987328, 22542, 20032, 190, 152, 242, 2, 211, 216, 67, 101);
RT_INTERFACE!{interface ISwipeHintThemeAnimation(ISwipeHintThemeAnimationVtbl): IInspectable(IInspectableVtbl) [IID_ISwipeHintThemeAnimation] {
    fn get_TargetName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TargetName(&self, value: HSTRING) -> HRESULT,
    fn get_ToHorizontalOffset(&self, out: *mut f64) -> HRESULT,
    fn put_ToHorizontalOffset(&self, value: f64) -> HRESULT,
    fn get_ToVerticalOffset(&self, out: *mut f64) -> HRESULT,
    fn put_ToVerticalOffset(&self, value: f64) -> HRESULT
}}
impl ISwipeHintThemeAnimation {
    #[inline] pub unsafe fn get_target_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_to_horizontal_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ToHorizontalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_to_horizontal_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ToHorizontalOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_to_vertical_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ToVerticalOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_to_vertical_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ToVerticalOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISwipeHintThemeAnimationStatics, 601234007, 37141, 19811, 176, 74, 184, 159, 28, 116, 77, 192);
RT_INTERFACE!{static interface ISwipeHintThemeAnimationStatics(ISwipeHintThemeAnimationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISwipeHintThemeAnimationStatics] {
    fn get_TargetNameProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ToHorizontalOffsetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ToVerticalOffsetProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl ISwipeHintThemeAnimationStatics {
    #[inline] pub unsafe fn get_target_name_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_to_horizontal_offset_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ToHorizontalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_to_vertical_offset_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ToVerticalOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SwipeHintThemeAnimation: ISwipeHintThemeAnimation}
impl RtActivatable<ISwipeHintThemeAnimationStatics> for SwipeHintThemeAnimation {}
impl RtActivatable<IActivationFactory> for SwipeHintThemeAnimation {}
impl SwipeHintThemeAnimation {
    #[inline] pub fn get_target_name_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISwipeHintThemeAnimationStatics>>::get_activation_factory().get_target_name_property()
    }}
    #[inline] pub fn get_to_horizontal_offset_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISwipeHintThemeAnimationStatics>>::get_activation_factory().get_to_horizontal_offset_property()
    }}
    #[inline] pub fn get_to_vertical_offset_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISwipeHintThemeAnimationStatics>>::get_activation_factory().get_to_vertical_offset_property()
    }}
}
DEFINE_CLSID!(SwipeHintThemeAnimation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,83,119,105,112,101,72,105,110,116,84,104,101,109,101,65,110,105,109,97,116,105,111,110,0]) [CLSID_SwipeHintThemeAnimation]);
DEFINE_IID!(IID_ICommonNavigationTransitionInfo, 1345607314, 42325, 17956, 163, 97, 10, 145, 193, 112, 100, 115);
RT_INTERFACE!{interface ICommonNavigationTransitionInfo(ICommonNavigationTransitionInfoVtbl): IInspectable(IInspectableVtbl) [IID_ICommonNavigationTransitionInfo] {
    fn get_IsStaggeringEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsStaggeringEnabled(&self, value: bool) -> HRESULT
}}
impl ICommonNavigationTransitionInfo {
    #[inline] pub unsafe fn get_is_staggering_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsStaggeringEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_staggering_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsStaggeringEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICommonNavigationTransitionInfoStatics, 507444787, 20670, 17475, 136, 60, 229, 98, 114, 1, 194, 229);
RT_INTERFACE!{static interface ICommonNavigationTransitionInfoStatics(ICommonNavigationTransitionInfoStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICommonNavigationTransitionInfoStatics] {
    fn get_IsStaggeringEnabledProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_IsStaggerElementProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn GetIsStaggerElement(&self, element: *mut super::super::UIElement, out: *mut bool) -> HRESULT,
    fn SetIsStaggerElement(&self, element: *mut super::super::UIElement, value: bool) -> HRESULT
}}
impl ICommonNavigationTransitionInfoStatics {
    #[inline] pub unsafe fn get_is_staggering_enabled_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsStaggeringEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_stagger_element_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsStaggerElementProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_stagger_element(&self, element: &super::super::UIElement) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsStaggerElement)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_stagger_element(&self, element: &super::super::UIElement, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetIsStaggerElement)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class CommonNavigationTransitionInfo: ICommonNavigationTransitionInfo}
impl RtActivatable<ICommonNavigationTransitionInfoStatics> for CommonNavigationTransitionInfo {}
impl RtActivatable<IActivationFactory> for CommonNavigationTransitionInfo {}
impl CommonNavigationTransitionInfo {
    #[inline] pub fn get_is_staggering_enabled_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICommonNavigationTransitionInfoStatics>>::get_activation_factory().get_is_staggering_enabled_property()
    }}
    #[inline] pub fn get_is_stagger_element_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICommonNavigationTransitionInfoStatics>>::get_activation_factory().get_is_stagger_element_property()
    }}
    #[inline] pub fn get_is_stagger_element(element: &super::super::UIElement) -> Result<bool> { unsafe {
        <Self as RtActivatable<ICommonNavigationTransitionInfoStatics>>::get_activation_factory().get_is_stagger_element(element)
    }}
    #[inline] pub fn set_is_stagger_element(element: &super::super::UIElement, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ICommonNavigationTransitionInfoStatics>>::get_activation_factory().set_is_stagger_element(element, value)
    }}
}
DEFINE_CLSID!(CommonNavigationTransitionInfo(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,67,111,109,109,111,110,78,97,118,105,103,97,116,105,111,110,84,114,97,110,115,105,116,105,111,110,73,110,102,111,0]) [CLSID_CommonNavigationTransitionInfo]);
DEFINE_IID!(IID_IContinuumNavigationTransitionInfo, 1273093037, 35750, 16388, 132, 56, 138, 144, 23, 151, 133, 67);
RT_INTERFACE!{interface IContinuumNavigationTransitionInfo(IContinuumNavigationTransitionInfoVtbl): IInspectable(IInspectableVtbl) [IID_IContinuumNavigationTransitionInfo] {
    fn get_ExitElement(&self, out: *mut *mut super::super::UIElement) -> HRESULT,
    fn put_ExitElement(&self, value: *mut super::super::UIElement) -> HRESULT
}}
impl IContinuumNavigationTransitionInfo {
    #[inline] pub unsafe fn get_exit_element(&self) -> Result<ComPtr<super::super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExitElement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_exit_element(&self, value: &super::super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ExitElement)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContinuumNavigationTransitionInfoStatics, 1042668883, 45455, 19441, 179, 188, 146, 245, 22, 242, 153, 3);
RT_INTERFACE!{static interface IContinuumNavigationTransitionInfoStatics(IContinuumNavigationTransitionInfoStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IContinuumNavigationTransitionInfoStatics] {
    fn get_ExitElementProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_IsEntranceElementProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn GetIsEntranceElement(&self, element: *mut super::super::UIElement, out: *mut bool) -> HRESULT,
    fn SetIsEntranceElement(&self, element: *mut super::super::UIElement, value: bool) -> HRESULT,
    fn get_IsExitElementProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn GetIsExitElement(&self, element: *mut super::super::UIElement, out: *mut bool) -> HRESULT,
    fn SetIsExitElement(&self, element: *mut super::super::UIElement, value: bool) -> HRESULT,
    fn get_ExitElementContainerProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn GetExitElementContainer(&self, element: *mut super::super::controls::ListViewBase, out: *mut bool) -> HRESULT,
    fn SetExitElementContainer(&self, element: *mut super::super::controls::ListViewBase, value: bool) -> HRESULT
}}
impl IContinuumNavigationTransitionInfoStatics {
    #[inline] pub unsafe fn get_exit_element_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExitElementProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_entrance_element_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsEntranceElementProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_entrance_element(&self, element: &super::super::UIElement) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsEntranceElement)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_entrance_element(&self, element: &super::super::UIElement, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetIsEntranceElement)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_exit_element_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsExitElementProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_exit_element(&self, element: &super::super::UIElement) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsExitElement)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_exit_element(&self, element: &super::super::UIElement, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetIsExitElement)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_exit_element_container_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExitElementContainerProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_exit_element_container(&self, element: &super::super::controls::ListViewBase) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetExitElementContainer)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_exit_element_container(&self, element: &super::super::controls::ListViewBase, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetExitElementContainer)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ContinuumNavigationTransitionInfo: IContinuumNavigationTransitionInfo}
impl RtActivatable<IContinuumNavigationTransitionInfoStatics> for ContinuumNavigationTransitionInfo {}
impl RtActivatable<IActivationFactory> for ContinuumNavigationTransitionInfo {}
impl ContinuumNavigationTransitionInfo {
    #[inline] pub fn get_exit_element_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContinuumNavigationTransitionInfoStatics>>::get_activation_factory().get_exit_element_property()
    }}
    #[inline] pub fn get_is_entrance_element_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContinuumNavigationTransitionInfoStatics>>::get_activation_factory().get_is_entrance_element_property()
    }}
    #[inline] pub fn get_is_entrance_element(element: &super::super::UIElement) -> Result<bool> { unsafe {
        <Self as RtActivatable<IContinuumNavigationTransitionInfoStatics>>::get_activation_factory().get_is_entrance_element(element)
    }}
    #[inline] pub fn set_is_entrance_element(element: &super::super::UIElement, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IContinuumNavigationTransitionInfoStatics>>::get_activation_factory().set_is_entrance_element(element, value)
    }}
    #[inline] pub fn get_is_exit_element_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContinuumNavigationTransitionInfoStatics>>::get_activation_factory().get_is_exit_element_property()
    }}
    #[inline] pub fn get_is_exit_element(element: &super::super::UIElement) -> Result<bool> { unsafe {
        <Self as RtActivatable<IContinuumNavigationTransitionInfoStatics>>::get_activation_factory().get_is_exit_element(element)
    }}
    #[inline] pub fn set_is_exit_element(element: &super::super::UIElement, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IContinuumNavigationTransitionInfoStatics>>::get_activation_factory().set_is_exit_element(element, value)
    }}
    #[inline] pub fn get_exit_element_container_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IContinuumNavigationTransitionInfoStatics>>::get_activation_factory().get_exit_element_container_property()
    }}
    #[inline] pub fn get_exit_element_container(element: &super::super::controls::ListViewBase) -> Result<bool> { unsafe {
        <Self as RtActivatable<IContinuumNavigationTransitionInfoStatics>>::get_activation_factory().get_exit_element_container(element)
    }}
    #[inline] pub fn set_exit_element_container(element: &super::super::controls::ListViewBase, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IContinuumNavigationTransitionInfoStatics>>::get_activation_factory().set_exit_element_container(element, value)
    }}
}
DEFINE_CLSID!(ContinuumNavigationTransitionInfo(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,67,111,110,116,105,110,117,117,109,78,97,118,105,103,97,116,105,111,110,84,114,97,110,115,105,116,105,111,110,73,110,102,111,0]) [CLSID_ContinuumNavigationTransitionInfo]);
DEFINE_IID!(IID_IDrillInNavigationTransitionInfo, 998645786, 17875, 17979, 147, 158, 200, 89, 95, 67, 155, 204);
RT_INTERFACE!{interface IDrillInNavigationTransitionInfo(IDrillInNavigationTransitionInfoVtbl): IInspectable(IInspectableVtbl) [IID_IDrillInNavigationTransitionInfo] {
    
}}
RT_CLASS!{class DrillInNavigationTransitionInfo: IDrillInNavigationTransitionInfo}
impl RtActivatable<IActivationFactory> for DrillInNavigationTransitionInfo {}
DEFINE_CLSID!(DrillInNavigationTransitionInfo(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,68,114,105,108,108,73,110,78,97,118,105,103,97,116,105,111,110,84,114,97,110,115,105,116,105,111,110,73,110,102,111,0]) [CLSID_DrillInNavigationTransitionInfo]);
DEFINE_IID!(IID_IEntranceNavigationTransitionInfo, 1913267563, 7306, 16878, 130, 236, 138, 135, 192, 207, 71, 218);
RT_INTERFACE!{interface IEntranceNavigationTransitionInfo(IEntranceNavigationTransitionInfoVtbl): IInspectable(IInspectableVtbl) [IID_IEntranceNavigationTransitionInfo] {
    
}}
DEFINE_IID!(IID_IEntranceNavigationTransitionInfoStatics, 4182295162, 16585, 18079, 143, 51, 191, 69, 200, 129, 31, 33);
RT_INTERFACE!{static interface IEntranceNavigationTransitionInfoStatics(IEntranceNavigationTransitionInfoStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IEntranceNavigationTransitionInfoStatics] {
    fn get_IsTargetElementProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn GetIsTargetElement(&self, element: *mut super::super::UIElement, out: *mut bool) -> HRESULT,
    fn SetIsTargetElement(&self, element: *mut super::super::UIElement, value: bool) -> HRESULT
}}
impl IEntranceNavigationTransitionInfoStatics {
    #[inline] pub unsafe fn get_is_target_element_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsTargetElementProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_target_element(&self, element: &super::super::UIElement) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsTargetElement)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_target_element(&self, element: &super::super::UIElement, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetIsTargetElement)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class EntranceNavigationTransitionInfo: IEntranceNavigationTransitionInfo}
impl RtActivatable<IEntranceNavigationTransitionInfoStatics> for EntranceNavigationTransitionInfo {}
impl RtActivatable<IActivationFactory> for EntranceNavigationTransitionInfo {}
impl EntranceNavigationTransitionInfo {
    #[inline] pub fn get_is_target_element_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IEntranceNavigationTransitionInfoStatics>>::get_activation_factory().get_is_target_element_property()
    }}
    #[inline] pub fn get_is_target_element(element: &super::super::UIElement) -> Result<bool> { unsafe {
        <Self as RtActivatable<IEntranceNavigationTransitionInfoStatics>>::get_activation_factory().get_is_target_element(element)
    }}
    #[inline] pub fn set_is_target_element(element: &super::super::UIElement, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IEntranceNavigationTransitionInfoStatics>>::get_activation_factory().set_is_target_element(element, value)
    }}
}
DEFINE_CLSID!(EntranceNavigationTransitionInfo(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,69,110,116,114,97,110,99,101,78,97,118,105,103,97,116,105,111,110,84,114,97,110,115,105,116,105,111,110,73,110,102,111,0]) [CLSID_EntranceNavigationTransitionInfo]);
DEFINE_IID!(IID_INavigationThemeTransition, 2285077644, 20151, 16882, 135, 153, 158, 239, 10, 33, 59, 115);
RT_INTERFACE!{interface INavigationThemeTransition(INavigationThemeTransitionVtbl): IInspectable(IInspectableVtbl) [IID_INavigationThemeTransition] {
    fn get_DefaultNavigationTransitionInfo(&self, out: *mut *mut NavigationTransitionInfo) -> HRESULT,
    fn put_DefaultNavigationTransitionInfo(&self, value: *mut NavigationTransitionInfo) -> HRESULT
}}
impl INavigationThemeTransition {
    #[inline] pub unsafe fn get_default_navigation_transition_info(&self) -> Result<ComPtr<NavigationTransitionInfo>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DefaultNavigationTransitionInfo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_default_navigation_transition_info(&self, value: &NavigationTransitionInfo) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DefaultNavigationTransitionInfo)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_INavigationThemeTransitionStatics, 3928950496, 24160, 20366, 188, 175, 67, 20, 135, 162, 148, 171);
RT_INTERFACE!{static interface INavigationThemeTransitionStatics(INavigationThemeTransitionStaticsVtbl): IInspectable(IInspectableVtbl) [IID_INavigationThemeTransitionStatics] {
    fn get_DefaultNavigationTransitionInfoProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl INavigationThemeTransitionStatics {
    #[inline] pub unsafe fn get_default_navigation_transition_info_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DefaultNavigationTransitionInfoProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class NavigationThemeTransition: INavigationThemeTransition}
impl RtActivatable<INavigationThemeTransitionStatics> for NavigationThemeTransition {}
impl RtActivatable<IActivationFactory> for NavigationThemeTransition {}
impl NavigationThemeTransition {
    #[inline] pub fn get_default_navigation_transition_info_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<INavigationThemeTransitionStatics>>::get_activation_factory().get_default_navigation_transition_info_property()
    }}
}
DEFINE_CLSID!(NavigationThemeTransition(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,78,97,118,105,103,97,116,105,111,110,84,104,101,109,101,84,114,97,110,115,105,116,105,111,110,0]) [CLSID_NavigationThemeTransition]);
DEFINE_IID!(IID_ISlideNavigationTransitionInfo, 3601636727, 11779, 16479, 128, 237, 230, 43, 238, 243, 102, 143);
RT_INTERFACE!{interface ISlideNavigationTransitionInfo(ISlideNavigationTransitionInfoVtbl): IInspectable(IInspectableVtbl) [IID_ISlideNavigationTransitionInfo] {
    
}}
RT_CLASS!{class SlideNavigationTransitionInfo: ISlideNavigationTransitionInfo}
impl RtActivatable<IActivationFactory> for SlideNavigationTransitionInfo {}
DEFINE_CLSID!(SlideNavigationTransitionInfo(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,83,108,105,100,101,78,97,118,105,103,97,116,105,111,110,84,114,97,110,115,105,116,105,111,110,73,110,102,111,0]) [CLSID_SlideNavigationTransitionInfo]);
DEFINE_IID!(IID_ISuppressNavigationTransitionInfo, 609057548, 45495, 18545, 157, 62, 213, 98, 3, 163, 165, 180);
RT_INTERFACE!{interface ISuppressNavigationTransitionInfo(ISuppressNavigationTransitionInfoVtbl): IInspectable(IInspectableVtbl) [IID_ISuppressNavigationTransitionInfo] {
    
}}
RT_CLASS!{class SuppressNavigationTransitionInfo: ISuppressNavigationTransitionInfo}
impl RtActivatable<IActivationFactory> for SuppressNavigationTransitionInfo {}
DEFINE_CLSID!(SuppressNavigationTransitionInfo(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,65,110,105,109,97,116,105,111,110,46,83,117,112,112,114,101,115,115,78,97,118,105,103,97,116,105,111,110,84,114,97,110,115,105,116,105,111,110,73,110,102,111,0]) [CLSID_SuppressNavigationTransitionInfo]);
} // Windows.UI.Xaml.Media.Animation
pub mod imaging { // Windows.UI.Xaml.Media.Imaging
use ::prelude::*;
RT_ENUM! { enum BitmapCreateOptions: u32 {
    None (BitmapCreateOptions_None) = 0, IgnoreImageCache (BitmapCreateOptions_IgnoreImageCache) = 8,
}}
RT_ENUM! { enum DecodePixelType: i32 {
    Physical (DecodePixelType_Physical) = 0, Logical (DecodePixelType_Logical) = 1,
}}
DEFINE_IID!(IID_DownloadProgressEventHandler, 448458275, 29934, 19655, 153, 186, 177, 113, 227, 205, 166, 30);
RT_DELEGATE!{delegate DownloadProgressEventHandler(DownloadProgressEventHandlerVtbl, DownloadProgressEventHandlerImpl) [IID_DownloadProgressEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut DownloadProgressEventArgs) -> HRESULT
}}
impl DownloadProgressEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &DownloadProgressEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class DownloadProgressEventArgs: IDownloadProgressEventArgs}
DEFINE_IID!(IID_IDownloadProgressEventArgs, 1930551508, 65172, 20080, 155, 144, 205, 212, 122, 194, 58, 251);
RT_INTERFACE!{interface IDownloadProgressEventArgs(IDownloadProgressEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDownloadProgressEventArgs] {
    fn get_Progress(&self, out: *mut i32) -> HRESULT,
    fn put_Progress(&self, value: i32) -> HRESULT
}}
impl IDownloadProgressEventArgs {
    #[inline] pub unsafe fn get_progress(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Progress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_progress(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Progress)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBitmapSource, 601383953, 8239, 16818, 140, 91, 168, 163, 179, 51, 128, 11);
RT_INTERFACE!{interface IBitmapSource(IBitmapSourceVtbl): IInspectable(IInspectableVtbl) [IID_IBitmapSource] {
    fn get_PixelWidth(&self, out: *mut i32) -> HRESULT,
    fn get_PixelHeight(&self, out: *mut i32) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SetSource(&self, streamSource: *mut ::rt::gen::windows::storage::streams::IRandomAccessStream) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SetSourceAsync(&self, streamSource: *mut ::rt::gen::windows::storage::streams::IRandomAccessStream, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IBitmapSource {
    #[inline] pub unsafe fn get_pixel_width(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PixelWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pixel_height(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PixelHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_source(&self, streamSource: &::rt::gen::windows::storage::streams::IRandomAccessStream) -> Result<()> {
        let hr = ((*self.lpVtbl).SetSource)(self as *const _ as *mut _, streamSource as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_source_async(&self, streamSource: &::rt::gen::windows::storage::streams::IRandomAccessStream) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SetSourceAsync)(self as *const _ as *mut _, streamSource as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBitmapSourceStatics, 2593954177, 33403, 20049, 137, 27, 138, 21, 181, 17, 132, 45);
RT_INTERFACE!{static interface IBitmapSourceStatics(IBitmapSourceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBitmapSourceStatics] {
    fn get_PixelWidthProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_PixelHeightProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IBitmapSourceStatics {
    #[inline] pub unsafe fn get_pixel_width_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PixelWidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pixel_height_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PixelHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBitmapSourceFactory, 3795862030, 54439, 18852, 160, 180, 165, 159, 221, 119, 229, 8);
RT_INTERFACE!{interface IBitmapSourceFactory(IBitmapSourceFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IBitmapSourceFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut BitmapSource) -> HRESULT
}}
impl IBitmapSourceFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<BitmapSource>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class BitmapSource: IBitmapSource}
impl RtActivatable<IBitmapSourceStatics> for BitmapSource {}
impl BitmapSource {
    #[inline] pub fn get_pixel_width_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBitmapSourceStatics>>::get_activation_factory().get_pixel_width_property()
    }}
    #[inline] pub fn get_pixel_height_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBitmapSourceStatics>>::get_activation_factory().get_pixel_height_property()
    }}
}
DEFINE_CLSID!(BitmapSource(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,73,109,97,103,105,110,103,46,66,105,116,109,97,112,83,111,117,114,99,101,0]) [CLSID_BitmapSource]);
DEFINE_IID!(IID_IRenderTargetBitmap, 1343090305, 35132, 19466, 143, 236, 70, 120, 172, 113, 117, 137);
RT_INTERFACE!{interface IRenderTargetBitmap(IRenderTargetBitmapVtbl): IInspectable(IInspectableVtbl) [IID_IRenderTargetBitmap] {
    fn get_PixelWidth(&self, out: *mut i32) -> HRESULT,
    fn get_PixelHeight(&self, out: *mut i32) -> HRESULT,
    fn RenderAsync(&self, element: *mut super::super::UIElement, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn RenderToSizeAsync(&self, element: *mut super::super::UIElement, scaledWidth: i32, scaledHeight: i32, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetPixelsAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::storage::streams::IBuffer>) -> HRESULT
}}
impl IRenderTargetBitmap {
    #[inline] pub unsafe fn get_pixel_width(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PixelWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pixel_height(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PixelHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn render_async(&self, element: &super::super::UIElement) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RenderAsync)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn render_to_size_async(&self, element: &super::super::UIElement, scaledWidth: i32, scaledHeight: i32) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RenderToSizeAsync)(self as *const _ as *mut _, element as *const _ as *mut _, scaledWidth, scaledHeight, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_pixels_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::storage::streams::IBuffer>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetPixelsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRenderTargetBitmapStatics, 4037144558, 49457, 19776, 156, 71, 247, 215, 207, 43, 7, 127);
RT_INTERFACE!{static interface IRenderTargetBitmapStatics(IRenderTargetBitmapStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRenderTargetBitmapStatics] {
    fn get_PixelWidthProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_PixelHeightProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IRenderTargetBitmapStatics {
    #[inline] pub unsafe fn get_pixel_width_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PixelWidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pixel_height_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PixelHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class RenderTargetBitmap: IRenderTargetBitmap}
impl RtActivatable<IRenderTargetBitmapStatics> for RenderTargetBitmap {}
impl RtActivatable<IActivationFactory> for RenderTargetBitmap {}
impl RenderTargetBitmap {
    #[inline] pub fn get_pixel_width_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRenderTargetBitmapStatics>>::get_activation_factory().get_pixel_width_property()
    }}
    #[inline] pub fn get_pixel_height_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRenderTargetBitmapStatics>>::get_activation_factory().get_pixel_height_property()
    }}
}
DEFINE_CLSID!(RenderTargetBitmap(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,73,109,97,103,105,110,103,46,82,101,110,100,101,114,84,97,114,103,101,116,66,105,116,109,97,112,0]) [CLSID_RenderTargetBitmap]);
DEFINE_IID!(IID_ISurfaceImageSource, 1660408854, 50964, 19532, 130, 115, 248, 57, 188, 88, 19, 92);
RT_INTERFACE!{interface ISurfaceImageSource(ISurfaceImageSourceVtbl): IInspectable(IInspectableVtbl) [IID_ISurfaceImageSource] {
    
}}
DEFINE_IID!(IID_ISurfaceImageSourceFactory, 984752426, 61285, 19039, 191, 172, 115, 153, 62, 140, 18, 201);
RT_INTERFACE!{interface ISurfaceImageSourceFactory(ISurfaceImageSourceFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISurfaceImageSourceFactory] {
    fn CreateInstanceWithDimensions(&self, pixelWidth: i32, pixelHeight: i32, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut SurfaceImageSource) -> HRESULT,
    fn CreateInstanceWithDimensionsAndOpacity(&self, pixelWidth: i32, pixelHeight: i32, isOpaque: bool, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut SurfaceImageSource) -> HRESULT
}}
impl ISurfaceImageSourceFactory {
    #[inline] pub unsafe fn create_instance_with_dimensions(&self, pixelWidth: i32, pixelHeight: i32, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<SurfaceImageSource>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithDimensions)(self as *const _ as *mut _, pixelWidth, pixelHeight, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_instance_with_dimensions_and_opacity(&self, pixelWidth: i32, pixelHeight: i32, isOpaque: bool, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<SurfaceImageSource>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithDimensionsAndOpacity)(self as *const _ as *mut _, pixelWidth, pixelHeight, isOpaque, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class SurfaceImageSource: ISurfaceImageSource}
DEFINE_IID!(IID_IBitmapImage, 833565297, 58292, 17453, 163, 65, 76, 2, 38, 178, 114, 91);
RT_INTERFACE!{interface IBitmapImage(IBitmapImageVtbl): IInspectable(IInspectableVtbl) [IID_IBitmapImage] {
    fn get_CreateOptions(&self, out: *mut BitmapCreateOptions) -> HRESULT,
    fn put_CreateOptions(&self, value: BitmapCreateOptions) -> HRESULT,
    fn get_UriSource(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn put_UriSource(&self, value: *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn get_DecodePixelWidth(&self, out: *mut i32) -> HRESULT,
    fn put_DecodePixelWidth(&self, value: i32) -> HRESULT,
    fn get_DecodePixelHeight(&self, out: *mut i32) -> HRESULT,
    fn put_DecodePixelHeight(&self, value: i32) -> HRESULT,
    fn add_DownloadProgress(&self, value: *mut DownloadProgressEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DownloadProgress(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ImageOpened(&self, value: *mut super::super::RoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ImageOpened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ImageFailed(&self, value: *mut super::super::ExceptionRoutedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ImageFailed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IBitmapImage {
    #[inline] pub unsafe fn get_create_options(&self) -> Result<BitmapCreateOptions> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CreateOptions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_create_options(&self, value: BitmapCreateOptions) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CreateOptions)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_uri_source(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UriSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_uri_source(&self, value: &::rt::gen::windows::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_UriSource)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_decode_pixel_width(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DecodePixelWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_decode_pixel_width(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DecodePixelWidth)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_decode_pixel_height(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DecodePixelHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_decode_pixel_height(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DecodePixelHeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_download_progress(&self, value: &DownloadProgressEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DownloadProgress)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_download_progress(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DownloadProgress)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_image_opened(&self, value: &super::super::RoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ImageOpened)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_image_opened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ImageOpened)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_image_failed(&self, value: &super::super::ExceptionRoutedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ImageFailed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_image_failed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ImageFailed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBitmapImageStatics, 2653430083, 28904, 17276, 159, 164, 44, 191, 41, 92, 255, 132);
RT_INTERFACE!{static interface IBitmapImageStatics(IBitmapImageStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBitmapImageStatics] {
    fn get_CreateOptionsProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_UriSourceProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_DecodePixelWidthProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_DecodePixelHeightProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IBitmapImageStatics {
    #[inline] pub unsafe fn get_create_options_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CreateOptionsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_uri_source_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UriSourceProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_decode_pixel_width_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DecodePixelWidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_decode_pixel_height_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DecodePixelHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBitmapImageFactory, 3373476216, 18448, 20062, 128, 135, 3, 103, 30, 230, 13, 133);
RT_INTERFACE!{static interface IBitmapImageFactory(IBitmapImageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IBitmapImageFactory] {
    fn CreateInstanceWithUriSource(&self, uriSource: *mut ::rt::gen::windows::foundation::Uri, out: *mut *mut BitmapImage) -> HRESULT
}}
impl IBitmapImageFactory {
    #[inline] pub unsafe fn create_instance_with_uri_source(&self, uriSource: &::rt::gen::windows::foundation::Uri) -> Result<ComPtr<BitmapImage>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithUriSource)(self as *const _ as *mut _, uriSource as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBitmapImage2, 275366326, 35995, 18274, 190, 61, 117, 159, 86, 152, 242, 179);
RT_INTERFACE!{interface IBitmapImage2(IBitmapImage2Vtbl): IInspectable(IInspectableVtbl) [IID_IBitmapImage2] {
    fn get_DecodePixelType(&self, out: *mut DecodePixelType) -> HRESULT,
    fn put_DecodePixelType(&self, value: DecodePixelType) -> HRESULT
}}
impl IBitmapImage2 {
    #[inline] pub unsafe fn get_decode_pixel_type(&self) -> Result<DecodePixelType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DecodePixelType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_decode_pixel_type(&self, value: DecodePixelType) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DecodePixelType)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBitmapImageStatics2, 3321190250, 30127, 16804, 184, 147, 143, 233, 31, 238, 40, 130);
RT_INTERFACE!{static interface IBitmapImageStatics2(IBitmapImageStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IBitmapImageStatics2] {
    fn get_DecodePixelTypeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IBitmapImageStatics2 {
    #[inline] pub unsafe fn get_decode_pixel_type_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DecodePixelTypeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBitmapImage3, 4057886502, 15475, 17727, 167, 186, 155, 133, 193, 139, 55, 51);
RT_INTERFACE!{interface IBitmapImage3(IBitmapImage3Vtbl): IInspectable(IInspectableVtbl) [IID_IBitmapImage3] {
    fn get_IsAnimatedBitmap(&self, out: *mut bool) -> HRESULT,
    fn get_IsPlaying(&self, out: *mut bool) -> HRESULT,
    fn get_AutoPlay(&self, out: *mut bool) -> HRESULT,
    fn put_AutoPlay(&self, value: bool) -> HRESULT,
    fn Play(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT
}}
impl IBitmapImage3 {
    #[inline] pub unsafe fn get_is_animated_bitmap(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsAnimatedBitmap)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_playing(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsPlaying)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_auto_play(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AutoPlay)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_auto_play(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AutoPlay)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn play(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Play)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn stop(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Stop)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class BitmapImage: IBitmapImage}
impl RtActivatable<IBitmapImageFactory> for BitmapImage {}
impl RtActivatable<IBitmapImageStatics2> for BitmapImage {}
impl RtActivatable<IBitmapImageStatics> for BitmapImage {}
impl RtActivatable<IBitmapImageStatics3> for BitmapImage {}
impl RtActivatable<IActivationFactory> for BitmapImage {}
impl BitmapImage {
    #[inline] pub fn create_instance_with_uri_source(uriSource: &::rt::gen::windows::foundation::Uri) -> Result<ComPtr<BitmapImage>> { unsafe {
        <Self as RtActivatable<IBitmapImageFactory>>::get_activation_factory().create_instance_with_uri_source(uriSource)
    }}
    #[inline] pub fn get_decode_pixel_type_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBitmapImageStatics2>>::get_activation_factory().get_decode_pixel_type_property()
    }}
    #[inline] pub fn get_create_options_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBitmapImageStatics>>::get_activation_factory().get_create_options_property()
    }}
    #[inline] pub fn get_uri_source_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBitmapImageStatics>>::get_activation_factory().get_uri_source_property()
    }}
    #[inline] pub fn get_decode_pixel_width_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBitmapImageStatics>>::get_activation_factory().get_decode_pixel_width_property()
    }}
    #[inline] pub fn get_decode_pixel_height_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBitmapImageStatics>>::get_activation_factory().get_decode_pixel_height_property()
    }}
    #[inline] pub fn get_is_animated_bitmap_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBitmapImageStatics3>>::get_activation_factory().get_is_animated_bitmap_property()
    }}
    #[inline] pub fn get_is_playing_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBitmapImageStatics3>>::get_activation_factory().get_is_playing_property()
    }}
    #[inline] pub fn get_auto_play_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IBitmapImageStatics3>>::get_activation_factory().get_auto_play_property()
    }}
}
DEFINE_CLSID!(BitmapImage(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,73,109,97,103,105,110,103,46,66,105,116,109,97,112,73,109,97,103,101,0]) [CLSID_BitmapImage]);
DEFINE_IID!(IID_IBitmapImageStatics3, 725934861, 63189, 17425, 168, 205, 191, 118, 3, 196, 250, 160);
RT_INTERFACE!{static interface IBitmapImageStatics3(IBitmapImageStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IBitmapImageStatics3] {
    fn get_IsAnimatedBitmapProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_IsPlayingProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_AutoPlayProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IBitmapImageStatics3 {
    #[inline] pub unsafe fn get_is_animated_bitmap_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsAnimatedBitmapProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_playing_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsPlayingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_auto_play_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AutoPlayProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVirtualSurfaceImageSource, 1248927722, 49068, 4576, 160, 106, 157, 228, 71, 36, 1, 155);
RT_INTERFACE!{interface IVirtualSurfaceImageSource(IVirtualSurfaceImageSourceVtbl): IInspectable(IInspectableVtbl) [IID_IVirtualSurfaceImageSource] {
    
}}
DEFINE_IID!(IID_IVirtualSurfaceImageSourceFactory, 984752426, 49068, 4576, 138, 146, 105, 228, 71, 36, 1, 155);
RT_INTERFACE!{static interface IVirtualSurfaceImageSourceFactory(IVirtualSurfaceImageSourceFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IVirtualSurfaceImageSourceFactory] {
    fn CreateInstanceWithDimensions(&self, pixelWidth: i32, pixelHeight: i32, out: *mut *mut VirtualSurfaceImageSource) -> HRESULT,
    fn CreateInstanceWithDimensionsAndOpacity(&self, pixelWidth: i32, pixelHeight: i32, isOpaque: bool, out: *mut *mut VirtualSurfaceImageSource) -> HRESULT
}}
impl IVirtualSurfaceImageSourceFactory {
    #[inline] pub unsafe fn create_instance_with_dimensions(&self, pixelWidth: i32, pixelHeight: i32) -> Result<ComPtr<VirtualSurfaceImageSource>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithDimensions)(self as *const _ as *mut _, pixelWidth, pixelHeight, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_instance_with_dimensions_and_opacity(&self, pixelWidth: i32, pixelHeight: i32, isOpaque: bool) -> Result<ComPtr<VirtualSurfaceImageSource>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithDimensionsAndOpacity)(self as *const _ as *mut _, pixelWidth, pixelHeight, isOpaque, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class VirtualSurfaceImageSource: IVirtualSurfaceImageSource}
impl RtActivatable<IVirtualSurfaceImageSourceFactory> for VirtualSurfaceImageSource {}
impl VirtualSurfaceImageSource {
    #[inline] pub fn create_instance_with_dimensions(pixelWidth: i32, pixelHeight: i32) -> Result<ComPtr<VirtualSurfaceImageSource>> { unsafe {
        <Self as RtActivatable<IVirtualSurfaceImageSourceFactory>>::get_activation_factory().create_instance_with_dimensions(pixelWidth, pixelHeight)
    }}
    #[inline] pub fn create_instance_with_dimensions_and_opacity(pixelWidth: i32, pixelHeight: i32, isOpaque: bool) -> Result<ComPtr<VirtualSurfaceImageSource>> { unsafe {
        <Self as RtActivatable<IVirtualSurfaceImageSourceFactory>>::get_activation_factory().create_instance_with_dimensions_and_opacity(pixelWidth, pixelHeight, isOpaque)
    }}
}
DEFINE_CLSID!(VirtualSurfaceImageSource(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,73,109,97,103,105,110,103,46,86,105,114,116,117,97,108,83,117,114,102,97,99,101,73,109,97,103,101,83,111,117,114,99,101,0]) [CLSID_VirtualSurfaceImageSource]);
DEFINE_IID!(IID_IWriteableBitmap, 3205201519, 57212, 19077, 132, 19, 161, 33, 98, 133, 131, 92);
RT_INTERFACE!{interface IWriteableBitmap(IWriteableBitmapVtbl): IInspectable(IInspectableVtbl) [IID_IWriteableBitmap] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_PixelBuffer(&self, out: *mut *mut ::rt::gen::windows::storage::streams::IBuffer) -> HRESULT,
    fn Invalidate(&self) -> HRESULT
}}
impl IWriteableBitmap {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_pixel_buffer(&self) -> Result<ComPtr<::rt::gen::windows::storage::streams::IBuffer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PixelBuffer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn invalidate(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Invalidate)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWriteableBitmapFactory, 1432611761, 16114, 17093, 156, 109, 28, 245, 220, 192, 65, 255);
RT_INTERFACE!{static interface IWriteableBitmapFactory(IWriteableBitmapFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IWriteableBitmapFactory] {
    fn CreateInstanceWithDimensions(&self, pixelWidth: i32, pixelHeight: i32, out: *mut *mut WriteableBitmap) -> HRESULT
}}
impl IWriteableBitmapFactory {
    #[inline] pub unsafe fn create_instance_with_dimensions(&self, pixelWidth: i32, pixelHeight: i32) -> Result<ComPtr<WriteableBitmap>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithDimensions)(self as *const _ as *mut _, pixelWidth, pixelHeight, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class WriteableBitmap: IWriteableBitmap}
impl RtActivatable<IWriteableBitmapFactory> for WriteableBitmap {}
impl WriteableBitmap {
    #[inline] pub fn create_instance_with_dimensions(pixelWidth: i32, pixelHeight: i32) -> Result<ComPtr<WriteableBitmap>> { unsafe {
        <Self as RtActivatable<IWriteableBitmapFactory>>::get_activation_factory().create_instance_with_dimensions(pixelWidth, pixelHeight)
    }}
}
DEFINE_CLSID!(WriteableBitmap(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,73,109,97,103,105,110,103,46,87,114,105,116,101,97,98,108,101,66,105,116,109,97,112,0]) [CLSID_WriteableBitmap]);
RT_ENUM! { enum SvgImageSourceLoadStatus: i32 {
    Success (SvgImageSourceLoadStatus_Success) = 0, NetworkError (SvgImageSourceLoadStatus_NetworkError) = 1, InvalidFormat (SvgImageSourceLoadStatus_InvalidFormat) = 2, Other (SvgImageSourceLoadStatus_Other) = 3,
}}
DEFINE_IID!(IID_ISvgImageSourceFailedEventArgs, 1757098352, 15564, 16437, 172, 1, 152, 52, 84, 61, 116, 78);
RT_INTERFACE!{interface ISvgImageSourceFailedEventArgs(ISvgImageSourceFailedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISvgImageSourceFailedEventArgs] {
    fn get_Status(&self, out: *mut SvgImageSourceLoadStatus) -> HRESULT
}}
impl ISvgImageSourceFailedEventArgs {
    #[inline] pub unsafe fn get_status(&self) -> Result<SvgImageSourceLoadStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class SvgImageSourceFailedEventArgs: ISvgImageSourceFailedEventArgs}
DEFINE_IID!(IID_ISvgImageSourceOpenedEventArgs, 2247052310, 29838, 16392, 149, 199, 106, 35, 221, 115, 22, 219);
RT_INTERFACE!{interface ISvgImageSourceOpenedEventArgs(ISvgImageSourceOpenedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISvgImageSourceOpenedEventArgs] {
    
}}
RT_CLASS!{class SvgImageSourceOpenedEventArgs: ISvgImageSourceOpenedEventArgs}
DEFINE_IID!(IID_IXamlRenderingBackgroundTask, 1566566826, 21310, 17592, 169, 117, 252, 95, 30, 59, 255, 82);
RT_INTERFACE!{interface IXamlRenderingBackgroundTask(IXamlRenderingBackgroundTaskVtbl): IInspectable(IInspectableVtbl) [IID_IXamlRenderingBackgroundTask] {
    
}}
DEFINE_IID!(IID_IXamlRenderingBackgroundTaskOverrides, 2620025239, 43272, 18193, 180, 178, 169, 96, 219, 61, 142, 90);
RT_INTERFACE!{interface IXamlRenderingBackgroundTaskOverrides(IXamlRenderingBackgroundTaskOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IXamlRenderingBackgroundTaskOverrides] {
    #[cfg(feature="windows-applicationmodel")] fn OnRun(&self, taskInstance: *mut ::rt::gen::windows::applicationmodel::background::IBackgroundTaskInstance) -> HRESULT
}}
impl IXamlRenderingBackgroundTaskOverrides {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub unsafe fn on_run(&self, taskInstance: &::rt::gen::windows::applicationmodel::background::IBackgroundTaskInstance) -> Result<()> {
        let hr = ((*self.lpVtbl).OnRun)(self as *const _ as *mut _, taskInstance as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IXamlRenderingBackgroundTaskFactory, 2748431203, 14584, 19875, 159, 202, 253, 129, 40, 162, 203, 249);
RT_INTERFACE!{interface IXamlRenderingBackgroundTaskFactory(IXamlRenderingBackgroundTaskFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IXamlRenderingBackgroundTaskFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut XamlRenderingBackgroundTask) -> HRESULT
}}
impl IXamlRenderingBackgroundTaskFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<XamlRenderingBackgroundTask>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class XamlRenderingBackgroundTask: IXamlRenderingBackgroundTask}
DEFINE_IID!(IID_ISoftwareBitmapSource, 3537739472, 54213, 16470, 145, 181, 183, 193, 209, 232, 19, 14);
RT_INTERFACE!{interface ISoftwareBitmapSource(ISoftwareBitmapSourceVtbl): IInspectable(IInspectableVtbl) [IID_ISoftwareBitmapSource] {
    #[cfg(feature="windows-graphics")] fn SetBitmapAsync(&self, softwareBitmap: *mut ::rt::gen::windows::graphics::imaging::SoftwareBitmap, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl ISoftwareBitmapSource {
    #[cfg(feature="windows-graphics")] #[inline] pub unsafe fn set_bitmap_async(&self, softwareBitmap: &::rt::gen::windows::graphics::imaging::SoftwareBitmap) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SetBitmapAsync)(self as *const _ as *mut _, softwareBitmap as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SoftwareBitmapSource: ISoftwareBitmapSource}
impl RtActivatable<IActivationFactory> for SoftwareBitmapSource {}
DEFINE_CLSID!(SoftwareBitmapSource(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,73,109,97,103,105,110,103,46,83,111,102,116,119,97,114,101,66,105,116,109,97,112,83,111,117,114,99,101,0]) [CLSID_SoftwareBitmapSource]);
DEFINE_IID!(IID_ISvgImageSource, 65130179, 3240, 19022, 141, 124, 200, 8, 160, 131, 133, 134);
RT_INTERFACE!{interface ISvgImageSource(ISvgImageSourceVtbl): IInspectable(IInspectableVtbl) [IID_ISvgImageSource] {
    fn get_UriSource(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn put_UriSource(&self, value: *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn get_RasterizePixelWidth(&self, out: *mut f64) -> HRESULT,
    fn put_RasterizePixelWidth(&self, value: f64) -> HRESULT,
    fn get_RasterizePixelHeight(&self, out: *mut f64) -> HRESULT,
    fn put_RasterizePixelHeight(&self, value: f64) -> HRESULT,
    fn add_Opened(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<SvgImageSource, SvgImageSourceOpenedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Opened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_OpenFailed(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<SvgImageSource, SvgImageSourceFailedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_OpenFailed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SetSourceAsync(&self, streamSource: *mut ::rt::gen::windows::storage::streams::IRandomAccessStream, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<SvgImageSourceLoadStatus>) -> HRESULT
}}
impl ISvgImageSource {
    #[inline] pub unsafe fn get_uri_source(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UriSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_uri_source(&self, value: &::rt::gen::windows::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_UriSource)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rasterize_pixel_width(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RasterizePixelWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_rasterize_pixel_width(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RasterizePixelWidth)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rasterize_pixel_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RasterizePixelHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_rasterize_pixel_height(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RasterizePixelHeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_opened(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<SvgImageSource, SvgImageSourceOpenedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Opened)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_opened(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Opened)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_open_failed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<SvgImageSource, SvgImageSourceFailedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_OpenFailed)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_open_failed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_OpenFailed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_source_async(&self, streamSource: &::rt::gen::windows::storage::streams::IRandomAccessStream) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<SvgImageSourceLoadStatus>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SetSourceAsync)(self as *const _ as *mut _, streamSource as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SvgImageSource: ISvgImageSource}
impl RtActivatable<ISvgImageSourceStatics> for SvgImageSource {}
impl SvgImageSource {
    #[inline] pub fn get_uri_source_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISvgImageSourceStatics>>::get_activation_factory().get_uri_source_property()
    }}
    #[inline] pub fn get_rasterize_pixel_width_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISvgImageSourceStatics>>::get_activation_factory().get_rasterize_pixel_width_property()
    }}
    #[inline] pub fn get_rasterize_pixel_height_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ISvgImageSourceStatics>>::get_activation_factory().get_rasterize_pixel_height_property()
    }}
}
DEFINE_CLSID!(SvgImageSource(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,73,109,97,103,105,110,103,46,83,118,103,73,109,97,103,101,83,111,117,114,99,101,0]) [CLSID_SvgImageSource]);
DEFINE_IID!(IID_ISvgImageSourceStatics, 2623944910, 48849, 19115, 172, 187, 211, 226, 24, 93, 49, 90);
RT_INTERFACE!{static interface ISvgImageSourceStatics(ISvgImageSourceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISvgImageSourceStatics] {
    fn get_UriSourceProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_RasterizePixelWidthProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_RasterizePixelHeightProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl ISvgImageSourceStatics {
    #[inline] pub unsafe fn get_uri_source_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UriSourceProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rasterize_pixel_width_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RasterizePixelWidthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rasterize_pixel_height_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RasterizePixelHeightProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISvgImageSourceFactory, 3348425191, 53027, 19826, 191, 26, 223, 170, 22, 216, 234, 82);
RT_INTERFACE!{interface ISvgImageSourceFactory(ISvgImageSourceFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISvgImageSourceFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut SvgImageSource) -> HRESULT,
    fn CreateInstanceWithUriSource(&self, uriSource: *mut ::rt::gen::windows::foundation::Uri, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut SvgImageSource) -> HRESULT
}}
impl ISvgImageSourceFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<SvgImageSource>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_instance_with_uri_source(&self, uriSource: &::rt::gen::windows::foundation::Uri, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<SvgImageSource>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithUriSource)(self as *const _ as *mut _, uriSource as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
} // Windows.UI.Xaml.Media.Imaging
pub mod media3d { // Windows.UI.Xaml.Media.Media3D
use ::prelude::*;
RT_STRUCT! { struct Matrix3D {
    M11: f64, M12: f64, M13: f64, M14: f64, M21: f64, M22: f64, M23: f64, M24: f64, M31: f64, M32: f64, M33: f64, M34: f64, OffsetX: f64, OffsetY: f64, OffsetZ: f64, M44: f64,
}}
DEFINE_IID!(IID_IMatrix3DHelper, 3834384623, 39207, 19611, 130, 19, 7, 119, 85, 18, 186, 4);
RT_INTERFACE!{interface IMatrix3DHelper(IMatrix3DHelperVtbl): IInspectable(IInspectableVtbl) [IID_IMatrix3DHelper] {
    
}}
DEFINE_IID!(IID_IMatrix3DHelperStatics, 2456048734, 57688, 20084, 136, 153, 104, 145, 96, 189, 47, 140);
RT_INTERFACE!{static interface IMatrix3DHelperStatics(IMatrix3DHelperStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMatrix3DHelperStatics] {
    fn get_Identity(&self, out: *mut Matrix3D) -> HRESULT,
    fn Multiply(&self, matrix1: Matrix3D, matrix2: Matrix3D, out: *mut Matrix3D) -> HRESULT,
    fn FromElements(&self, m11: f64, m12: f64, m13: f64, m14: f64, m21: f64, m22: f64, m23: f64, m24: f64, m31: f64, m32: f64, m33: f64, m34: f64, offsetX: f64, offsetY: f64, offsetZ: f64, m44: f64, out: *mut Matrix3D) -> HRESULT,
    fn GetHasInverse(&self, target: Matrix3D, out: *mut bool) -> HRESULT,
    fn GetIsIdentity(&self, target: Matrix3D, out: *mut bool) -> HRESULT,
    fn Invert(&self, target: Matrix3D, out: *mut Matrix3D) -> HRESULT
}}
impl IMatrix3DHelperStatics {
    #[inline] pub unsafe fn get_identity(&self) -> Result<Matrix3D> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Identity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn multiply(&self, matrix1: Matrix3D, matrix2: Matrix3D) -> Result<Matrix3D> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Multiply)(self as *const _ as *mut _, matrix1, matrix2, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn from_elements(&self, m11: f64, m12: f64, m13: f64, m14: f64, m21: f64, m22: f64, m23: f64, m24: f64, m31: f64, m32: f64, m33: f64, m34: f64, offsetX: f64, offsetY: f64, offsetZ: f64, m44: f64) -> Result<Matrix3D> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).FromElements)(self as *const _ as *mut _, m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, offsetX, offsetY, offsetZ, m44, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_has_inverse(&self, target: Matrix3D) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetHasInverse)(self as *const _ as *mut _, target, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_identity(&self, target: Matrix3D) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsIdentity)(self as *const _ as *mut _, target, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn invert(&self, target: Matrix3D) -> Result<Matrix3D> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Invert)(self as *const _ as *mut _, target, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class Matrix3DHelper: IMatrix3DHelper}
impl RtActivatable<IMatrix3DHelperStatics> for Matrix3DHelper {}
impl Matrix3DHelper {
    #[inline] pub fn get_identity() -> Result<Matrix3D> { unsafe {
        <Self as RtActivatable<IMatrix3DHelperStatics>>::get_activation_factory().get_identity()
    }}
    #[inline] pub fn multiply(matrix1: Matrix3D, matrix2: Matrix3D) -> Result<Matrix3D> { unsafe {
        <Self as RtActivatable<IMatrix3DHelperStatics>>::get_activation_factory().multiply(matrix1, matrix2)
    }}
    #[inline] pub fn from_elements(m11: f64, m12: f64, m13: f64, m14: f64, m21: f64, m22: f64, m23: f64, m24: f64, m31: f64, m32: f64, m33: f64, m34: f64, offsetX: f64, offsetY: f64, offsetZ: f64, m44: f64) -> Result<Matrix3D> { unsafe {
        <Self as RtActivatable<IMatrix3DHelperStatics>>::get_activation_factory().from_elements(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, offsetX, offsetY, offsetZ, m44)
    }}
    #[inline] pub fn get_has_inverse(target: Matrix3D) -> Result<bool> { unsafe {
        <Self as RtActivatable<IMatrix3DHelperStatics>>::get_activation_factory().get_has_inverse(target)
    }}
    #[inline] pub fn get_is_identity(target: Matrix3D) -> Result<bool> { unsafe {
        <Self as RtActivatable<IMatrix3DHelperStatics>>::get_activation_factory().get_is_identity(target)
    }}
    #[inline] pub fn invert(target: Matrix3D) -> Result<Matrix3D> { unsafe {
        <Self as RtActivatable<IMatrix3DHelperStatics>>::get_activation_factory().invert(target)
    }}
}
DEFINE_CLSID!(Matrix3DHelper(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,77,101,100,105,97,51,68,46,77,97,116,114,105,120,51,68,72,101,108,112,101,114,0]) [CLSID_Matrix3DHelper]);
DEFINE_IID!(IID_ITransform3D, 2923353146, 43516, 19505, 134, 205, 86, 217, 202, 37, 26, 105);
RT_INTERFACE!{interface ITransform3D(ITransform3DVtbl): IInspectable(IInspectableVtbl) [IID_ITransform3D] {
    
}}
RT_CLASS!{class Transform3D: ITransform3D}
DEFINE_IID!(IID_ITransform3DFactory, 86777722, 36211, 18637, 187, 184, 208, 4, 52, 202, 174, 93);
RT_INTERFACE!{interface ITransform3DFactory(ITransform3DFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ITransform3DFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut Transform3D) -> HRESULT
}}
impl ITransform3DFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<Transform3D>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICompositeTransform3D, 2306329345, 44941, 19189, 176, 132, 192, 142, 185, 112, 74, 190);
RT_INTERFACE!{interface ICompositeTransform3D(ICompositeTransform3DVtbl): IInspectable(IInspectableVtbl) [IID_ICompositeTransform3D] {
    fn get_CenterX(&self, out: *mut f64) -> HRESULT,
    fn put_CenterX(&self, value: f64) -> HRESULT,
    fn get_CenterY(&self, out: *mut f64) -> HRESULT,
    fn put_CenterY(&self, value: f64) -> HRESULT,
    fn get_CenterZ(&self, out: *mut f64) -> HRESULT,
    fn put_CenterZ(&self, value: f64) -> HRESULT,
    fn get_RotationX(&self, out: *mut f64) -> HRESULT,
    fn put_RotationX(&self, value: f64) -> HRESULT,
    fn get_RotationY(&self, out: *mut f64) -> HRESULT,
    fn put_RotationY(&self, value: f64) -> HRESULT,
    fn get_RotationZ(&self, out: *mut f64) -> HRESULT,
    fn put_RotationZ(&self, value: f64) -> HRESULT,
    fn get_ScaleX(&self, out: *mut f64) -> HRESULT,
    fn put_ScaleX(&self, value: f64) -> HRESULT,
    fn get_ScaleY(&self, out: *mut f64) -> HRESULT,
    fn put_ScaleY(&self, value: f64) -> HRESULT,
    fn get_ScaleZ(&self, out: *mut f64) -> HRESULT,
    fn put_ScaleZ(&self, value: f64) -> HRESULT,
    fn get_TranslateX(&self, out: *mut f64) -> HRESULT,
    fn put_TranslateX(&self, value: f64) -> HRESULT,
    fn get_TranslateY(&self, out: *mut f64) -> HRESULT,
    fn put_TranslateY(&self, value: f64) -> HRESULT,
    fn get_TranslateZ(&self, out: *mut f64) -> HRESULT,
    fn put_TranslateZ(&self, value: f64) -> HRESULT
}}
impl ICompositeTransform3D {
    #[inline] pub unsafe fn get_center_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CenterX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_center_x(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CenterX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_center_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CenterY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_center_y(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CenterY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_center_z(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CenterZ)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_center_z(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CenterZ)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rotation_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RotationX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_rotation_x(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RotationX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rotation_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RotationY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_rotation_y(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RotationY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rotation_z(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RotationZ)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_rotation_z(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RotationZ)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scale_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScaleX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_scale_x(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ScaleX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scale_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScaleY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_scale_y(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ScaleY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scale_z(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScaleZ)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_scale_z(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ScaleZ)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_translate_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TranslateX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_translate_x(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TranslateX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_translate_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TranslateY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_translate_y(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TranslateY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_translate_z(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TranslateZ)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_translate_z(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TranslateZ)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICompositeTransform3DStatics, 3720301927, 10789, 18675, 152, 8, 197, 30, 195, 213, 91, 236);
RT_INTERFACE!{static interface ICompositeTransform3DStatics(ICompositeTransform3DStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICompositeTransform3DStatics] {
    fn get_CenterXProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_CenterYProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_CenterZProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_RotationXProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_RotationYProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_RotationZProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ScaleXProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ScaleYProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_ScaleZProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_TranslateXProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_TranslateYProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_TranslateZProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl ICompositeTransform3DStatics {
    #[inline] pub unsafe fn get_center_xproperty(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CenterXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_center_yproperty(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CenterYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_center_zproperty(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CenterZProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rotation_xproperty(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RotationXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rotation_yproperty(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RotationYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rotation_zproperty(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RotationZProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scale_xproperty(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ScaleXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scale_yproperty(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ScaleYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_scale_zproperty(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ScaleZProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_translate_xproperty(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TranslateXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_translate_yproperty(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TranslateYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_translate_zproperty(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TranslateZProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class CompositeTransform3D: ICompositeTransform3D}
impl RtActivatable<ICompositeTransform3DStatics> for CompositeTransform3D {}
impl RtActivatable<IActivationFactory> for CompositeTransform3D {}
impl CompositeTransform3D {
    #[inline] pub fn get_center_xproperty() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICompositeTransform3DStatics>>::get_activation_factory().get_center_xproperty()
    }}
    #[inline] pub fn get_center_yproperty() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICompositeTransform3DStatics>>::get_activation_factory().get_center_yproperty()
    }}
    #[inline] pub fn get_center_zproperty() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICompositeTransform3DStatics>>::get_activation_factory().get_center_zproperty()
    }}
    #[inline] pub fn get_rotation_xproperty() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICompositeTransform3DStatics>>::get_activation_factory().get_rotation_xproperty()
    }}
    #[inline] pub fn get_rotation_yproperty() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICompositeTransform3DStatics>>::get_activation_factory().get_rotation_yproperty()
    }}
    #[inline] pub fn get_rotation_zproperty() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICompositeTransform3DStatics>>::get_activation_factory().get_rotation_zproperty()
    }}
    #[inline] pub fn get_scale_xproperty() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICompositeTransform3DStatics>>::get_activation_factory().get_scale_xproperty()
    }}
    #[inline] pub fn get_scale_yproperty() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICompositeTransform3DStatics>>::get_activation_factory().get_scale_yproperty()
    }}
    #[inline] pub fn get_scale_zproperty() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICompositeTransform3DStatics>>::get_activation_factory().get_scale_zproperty()
    }}
    #[inline] pub fn get_translate_xproperty() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICompositeTransform3DStatics>>::get_activation_factory().get_translate_xproperty()
    }}
    #[inline] pub fn get_translate_yproperty() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICompositeTransform3DStatics>>::get_activation_factory().get_translate_yproperty()
    }}
    #[inline] pub fn get_translate_zproperty() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICompositeTransform3DStatics>>::get_activation_factory().get_translate_zproperty()
    }}
}
DEFINE_CLSID!(CompositeTransform3D(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,77,101,100,105,97,51,68,46,67,111,109,112,111,115,105,116,101,84,114,97,110,115,102,111,114,109,51,68,0]) [CLSID_CompositeTransform3D]);
DEFINE_IID!(IID_IPerspectiveTransform3D, 2591773482, 12537, 16545, 150, 201, 197, 157, 135, 249, 90, 195);
RT_INTERFACE!{interface IPerspectiveTransform3D(IPerspectiveTransform3DVtbl): IInspectable(IInspectableVtbl) [IID_IPerspectiveTransform3D] {
    fn get_Depth(&self, out: *mut f64) -> HRESULT,
    fn put_Depth(&self, value: f64) -> HRESULT,
    fn get_OffsetX(&self, out: *mut f64) -> HRESULT,
    fn put_OffsetX(&self, value: f64) -> HRESULT,
    fn get_OffsetY(&self, out: *mut f64) -> HRESULT,
    fn put_OffsetY(&self, value: f64) -> HRESULT
}}
impl IPerspectiveTransform3D {
    #[inline] pub unsafe fn get_depth(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Depth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_depth(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Depth)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_offset_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OffsetX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_offset_x(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OffsetX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_offset_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OffsetY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_offset_y(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OffsetY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPerspectiveTransform3DStatics, 2389664768, 25100, 18631, 132, 77, 63, 9, 132, 218, 91, 23);
RT_INTERFACE!{static interface IPerspectiveTransform3DStatics(IPerspectiveTransform3DStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPerspectiveTransform3DStatics] {
    fn get_DepthProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_OffsetXProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_OffsetYProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IPerspectiveTransform3DStatics {
    #[inline] pub unsafe fn get_depth_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DepthProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_offset_xproperty(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OffsetXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_offset_yproperty(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OffsetYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PerspectiveTransform3D: IPerspectiveTransform3D}
impl RtActivatable<IPerspectiveTransform3DStatics> for PerspectiveTransform3D {}
impl RtActivatable<IActivationFactory> for PerspectiveTransform3D {}
impl PerspectiveTransform3D {
    #[inline] pub fn get_depth_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPerspectiveTransform3DStatics>>::get_activation_factory().get_depth_property()
    }}
    #[inline] pub fn get_offset_xproperty() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPerspectiveTransform3DStatics>>::get_activation_factory().get_offset_xproperty()
    }}
    #[inline] pub fn get_offset_yproperty() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPerspectiveTransform3DStatics>>::get_activation_factory().get_offset_yproperty()
    }}
}
DEFINE_CLSID!(PerspectiveTransform3D(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,101,100,105,97,46,77,101,100,105,97,51,68,46,80,101,114,115,112,101,99,116,105,118,101,84,114,97,110,115,102,111,114,109,51,68,0]) [CLSID_PerspectiveTransform3D]);
} // Windows.UI.Xaml.Media.Media3D
} // Windows.UI.Xaml.Media
pub mod automation { // Windows.UI.Xaml.Automation
use ::prelude::*;
RT_ENUM! { enum AnnotationType: i32 {
    Unknown (AnnotationType_Unknown) = 60000, SpellingError (AnnotationType_SpellingError) = 60001, GrammarError (AnnotationType_GrammarError) = 60002, Comment (AnnotationType_Comment) = 60003, FormulaError (AnnotationType_FormulaError) = 60004, TrackChanges (AnnotationType_TrackChanges) = 60005, Header (AnnotationType_Header) = 60006, Footer (AnnotationType_Footer) = 60007, Highlighted (AnnotationType_Highlighted) = 60008, Endnote (AnnotationType_Endnote) = 60009, Footnote (AnnotationType_Footnote) = 60010, InsertionChange (AnnotationType_InsertionChange) = 60011, DeletionChange (AnnotationType_DeletionChange) = 60012, MoveChange (AnnotationType_MoveChange) = 60013, FormatChange (AnnotationType_FormatChange) = 60014, UnsyncedChange (AnnotationType_UnsyncedChange) = 60015, EditingLockedChange (AnnotationType_EditingLockedChange) = 60016, ExternalChange (AnnotationType_ExternalChange) = 60017, ConflictingChange (AnnotationType_ConflictingChange) = 60018, Author (AnnotationType_Author) = 60019, AdvancedProofingIssue (AnnotationType_AdvancedProofingIssue) = 60020, DataValidationError (AnnotationType_DataValidationError) = 60021, CircularReferenceError (AnnotationType_CircularReferenceError) = 60022,
}}
RT_ENUM! { enum AutomationTextEditChangeType: i32 {
    None (AutomationTextEditChangeType_None) = 0, AutoCorrect (AutomationTextEditChangeType_AutoCorrect) = 1, Composition (AutomationTextEditChangeType_Composition) = 2, CompositionFinalized (AutomationTextEditChangeType_CompositionFinalized) = 3,
}}
RT_ENUM! { enum DockPosition: i32 {
    Top (DockPosition_Top) = 0, Left (DockPosition_Left) = 1, Bottom (DockPosition_Bottom) = 2, Right (DockPosition_Right) = 3, Fill (DockPosition_Fill) = 4, None (DockPosition_None) = 5,
}}
RT_ENUM! { enum ExpandCollapseState: i32 {
    Collapsed (ExpandCollapseState_Collapsed) = 0, Expanded (ExpandCollapseState_Expanded) = 1, PartiallyExpanded (ExpandCollapseState_PartiallyExpanded) = 2, LeafNode (ExpandCollapseState_LeafNode) = 3,
}}
RT_ENUM! { enum RowOrColumnMajor: i32 {
    RowMajor (RowOrColumnMajor_RowMajor) = 0, ColumnMajor (RowOrColumnMajor_ColumnMajor) = 1, Indeterminate (RowOrColumnMajor_Indeterminate) = 2,
}}
RT_ENUM! { enum ScrollAmount: i32 {
    LargeDecrement (ScrollAmount_LargeDecrement) = 0, SmallDecrement (ScrollAmount_SmallDecrement) = 1, NoAmount (ScrollAmount_NoAmount) = 2, LargeIncrement (ScrollAmount_LargeIncrement) = 3, SmallIncrement (ScrollAmount_SmallIncrement) = 4,
}}
RT_ENUM! { enum SupportedTextSelection: i32 {
    None (SupportedTextSelection_None) = 0, Single (SupportedTextSelection_Single) = 1, Multiple (SupportedTextSelection_Multiple) = 2,
}}
RT_ENUM! { enum SynchronizedInputType: i32 {
    KeyUp (SynchronizedInputType_KeyUp) = 1, KeyDown (SynchronizedInputType_KeyDown) = 2, LeftMouseUp (SynchronizedInputType_LeftMouseUp) = 4, LeftMouseDown (SynchronizedInputType_LeftMouseDown) = 8, RightMouseUp (SynchronizedInputType_RightMouseUp) = 16, RightMouseDown (SynchronizedInputType_RightMouseDown) = 32,
}}
RT_ENUM! { enum ToggleState: i32 {
    Off (ToggleState_Off) = 0, On (ToggleState_On) = 1, Indeterminate (ToggleState_Indeterminate) = 2,
}}
RT_ENUM! { enum WindowInteractionState: i32 {
    Running (WindowInteractionState_Running) = 0, Closing (WindowInteractionState_Closing) = 1, ReadyForUserInteraction (WindowInteractionState_ReadyForUserInteraction) = 2, BlockedByModalWindow (WindowInteractionState_BlockedByModalWindow) = 3, NotResponding (WindowInteractionState_NotResponding) = 4,
}}
RT_ENUM! { enum WindowVisualState: i32 {
    Normal (WindowVisualState_Normal) = 0, Maximized (WindowVisualState_Maximized) = 1, Minimized (WindowVisualState_Minimized) = 2,
}}
RT_ENUM! { enum ZoomUnit: i32 {
    NoAmount (ZoomUnit_NoAmount) = 0, LargeDecrement (ZoomUnit_LargeDecrement) = 1, SmallDecrement (ZoomUnit_SmallDecrement) = 2, LargeIncrement (ZoomUnit_LargeIncrement) = 3, SmallIncrement (ZoomUnit_SmallIncrement) = 4,
}}
DEFINE_IID!(IID_IAnnotationPatternIdentifiers, 3564478657, 18610, 20032, 166, 207, 61, 196, 182, 56, 192, 222);
RT_INTERFACE!{interface IAnnotationPatternIdentifiers(IAnnotationPatternIdentifiersVtbl): IInspectable(IInspectableVtbl) [IID_IAnnotationPatternIdentifiers] {
    
}}
DEFINE_IID!(IID_IAnnotationPatternIdentifiersStatics, 3773014877, 53607, 18140, 149, 171, 51, 10, 246, 26, 235, 181);
RT_INTERFACE!{static interface IAnnotationPatternIdentifiersStatics(IAnnotationPatternIdentifiersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAnnotationPatternIdentifiersStatics] {
    fn get_AnnotationTypeIdProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_AnnotationTypeNameProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_AuthorProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_DateTimeProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_TargetProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl IAnnotationPatternIdentifiersStatics {
    #[inline] pub unsafe fn get_annotation_type_id_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AnnotationTypeIdProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_annotation_type_name_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AnnotationTypeNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_author_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AuthorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_date_time_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DateTimeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_target_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AutomationProperty: IAutomationProperty}
RT_CLASS!{class AnnotationPatternIdentifiers: IAnnotationPatternIdentifiers}
impl RtActivatable<IAnnotationPatternIdentifiersStatics> for AnnotationPatternIdentifiers {}
impl AnnotationPatternIdentifiers {
    #[inline] pub fn get_annotation_type_id_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAnnotationPatternIdentifiersStatics>>::get_activation_factory().get_annotation_type_id_property()
    }}
    #[inline] pub fn get_annotation_type_name_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAnnotationPatternIdentifiersStatics>>::get_activation_factory().get_annotation_type_name_property()
    }}
    #[inline] pub fn get_author_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAnnotationPatternIdentifiersStatics>>::get_activation_factory().get_author_property()
    }}
    #[inline] pub fn get_date_time_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAnnotationPatternIdentifiersStatics>>::get_activation_factory().get_date_time_property()
    }}
    #[inline] pub fn get_target_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAnnotationPatternIdentifiersStatics>>::get_activation_factory().get_target_property()
    }}
}
DEFINE_CLSID!(AnnotationPatternIdentifiers(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,65,110,110,111,116,97,116,105,111,110,80,97,116,116,101,114,110,73,100,101,110,116,105,102,105,101,114,115,0]) [CLSID_AnnotationPatternIdentifiers]);
DEFINE_IID!(IID_IAutomationElementIdentifiers, 3867829199, 17221, 20013, 138, 106, 73, 204, 225, 250, 45, 204);
RT_INTERFACE!{interface IAutomationElementIdentifiers(IAutomationElementIdentifiersVtbl): IInspectable(IInspectableVtbl) [IID_IAutomationElementIdentifiers] {
    
}}
DEFINE_IID!(IID_IAutomationElementIdentifiersStatics, 1162426783, 33600, 19815, 185, 191, 140, 42, 198, 160, 119, 58);
RT_INTERFACE!{static interface IAutomationElementIdentifiersStatics(IAutomationElementIdentifiersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAutomationElementIdentifiersStatics] {
    fn get_AcceleratorKeyProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_AccessKeyProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_AutomationIdProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_BoundingRectangleProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_ClassNameProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_ClickablePointProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_ControlTypeProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_HasKeyboardFocusProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_HelpTextProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_IsContentElementProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_IsControlElementProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_IsEnabledProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_IsKeyboardFocusableProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_IsOffscreenProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_IsPasswordProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_IsRequiredForFormProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_ItemStatusProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_ItemTypeProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_LabeledByProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_LocalizedControlTypeProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_NameProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_OrientationProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_LiveSettingProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl IAutomationElementIdentifiersStatics {
    #[inline] pub unsafe fn get_accelerator_key_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AcceleratorKeyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_access_key_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AccessKeyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_automation_id_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AutomationIdProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_bounding_rectangle_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BoundingRectangleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_class_name_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ClassNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_clickable_point_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ClickablePointProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_control_type_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ControlTypeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_has_keyboard_focus_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HasKeyboardFocusProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_help_text_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HelpTextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_content_element_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsContentElementProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_control_element_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsControlElementProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_enabled_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsEnabledProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_keyboard_focusable_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsKeyboardFocusableProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_offscreen_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsOffscreenProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_password_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsPasswordProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_required_for_form_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsRequiredForFormProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_status_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemStatusProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_type_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemTypeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_labeled_by_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LabeledByProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_localized_control_type_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LocalizedControlTypeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_name_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OrientationProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_live_setting_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LiveSettingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationElementIdentifiersStatics2, 3050025442, 54623, 18089, 158, 218, 26, 71, 66, 81, 93, 195);
RT_INTERFACE!{static interface IAutomationElementIdentifiersStatics2(IAutomationElementIdentifiersStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IAutomationElementIdentifiersStatics2] {
    fn get_ControlledPeersProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl IAutomationElementIdentifiersStatics2 {
    #[inline] pub unsafe fn get_controlled_peers_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ControlledPeersProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationElementIdentifiersStatics3, 257736381, 46059, 16515, 173, 199, 12, 47, 57, 187, 53, 67);
RT_INTERFACE!{static interface IAutomationElementIdentifiersStatics3(IAutomationElementIdentifiersStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IAutomationElementIdentifiersStatics3] {
    fn get_PositionInSetProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_SizeOfSetProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_LevelProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_AnnotationsProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl IAutomationElementIdentifiersStatics3 {
    #[inline] pub unsafe fn get_position_in_set_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PositionInSetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_size_of_set_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SizeOfSetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_level_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LevelProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_annotations_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AnnotationsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationElementIdentifiersStatics4, 1526013813, 22803, 19832, 179, 48, 166, 245, 11, 115, 237, 155);
RT_INTERFACE!{static interface IAutomationElementIdentifiersStatics4(IAutomationElementIdentifiersStatics4Vtbl): IInspectable(IInspectableVtbl) [IID_IAutomationElementIdentifiersStatics4] {
    fn get_LandmarkTypeProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_LocalizedLandmarkTypeProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl IAutomationElementIdentifiersStatics4 {
    #[inline] pub unsafe fn get_landmark_type_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LandmarkTypeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_localized_landmark_type_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LocalizedLandmarkTypeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationElementIdentifiersStatics5, 2557116934, 56921, 17145, 161, 231, 98, 184, 175, 158, 117, 109);
RT_INTERFACE!{static interface IAutomationElementIdentifiersStatics5(IAutomationElementIdentifiersStatics5Vtbl): IInspectable(IInspectableVtbl) [IID_IAutomationElementIdentifiersStatics5] {
    fn get_IsPeripheralProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_IsDataValidForFormProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_FullDescriptionProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_DescribedByProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_FlowsToProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_FlowsFromProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl IAutomationElementIdentifiersStatics5 {
    #[inline] pub unsafe fn get_is_peripheral_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsPeripheralProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_data_valid_for_form_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsDataValidForFormProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_full_description_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FullDescriptionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_described_by_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DescribedByProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_flows_to_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FlowsToProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_flows_from_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FlowsFromProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationElementIdentifiersStatics6, 3729960973, 33576, 20142, 128, 53, 248, 219, 153, 200, 186, 196);
RT_INTERFACE!{static interface IAutomationElementIdentifiersStatics6(IAutomationElementIdentifiersStatics6Vtbl): IInspectable(IInspectableVtbl) [IID_IAutomationElementIdentifiersStatics6] {
    fn get_CultureProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl IAutomationElementIdentifiersStatics6 {
    #[inline] pub unsafe fn get_culture_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CultureProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AutomationElementIdentifiers: IAutomationElementIdentifiers}
impl RtActivatable<IAutomationElementIdentifiersStatics2> for AutomationElementIdentifiers {}
impl RtActivatable<IAutomationElementIdentifiersStatics> for AutomationElementIdentifiers {}
impl RtActivatable<IAutomationElementIdentifiersStatics3> for AutomationElementIdentifiers {}
impl RtActivatable<IAutomationElementIdentifiersStatics5> for AutomationElementIdentifiers {}
impl RtActivatable<IAutomationElementIdentifiersStatics4> for AutomationElementIdentifiers {}
impl RtActivatable<IAutomationElementIdentifiersStatics6> for AutomationElementIdentifiers {}
impl AutomationElementIdentifiers {
    #[inline] pub fn get_controlled_peers_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics2>>::get_activation_factory().get_controlled_peers_property()
    }}
    #[inline] pub fn get_accelerator_key_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_accelerator_key_property()
    }}
    #[inline] pub fn get_access_key_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_access_key_property()
    }}
    #[inline] pub fn get_automation_id_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_automation_id_property()
    }}
    #[inline] pub fn get_bounding_rectangle_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_bounding_rectangle_property()
    }}
    #[inline] pub fn get_class_name_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_class_name_property()
    }}
    #[inline] pub fn get_clickable_point_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_clickable_point_property()
    }}
    #[inline] pub fn get_control_type_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_control_type_property()
    }}
    #[inline] pub fn get_has_keyboard_focus_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_has_keyboard_focus_property()
    }}
    #[inline] pub fn get_help_text_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_help_text_property()
    }}
    #[inline] pub fn get_is_content_element_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_is_content_element_property()
    }}
    #[inline] pub fn get_is_control_element_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_is_control_element_property()
    }}
    #[inline] pub fn get_is_enabled_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_is_enabled_property()
    }}
    #[inline] pub fn get_is_keyboard_focusable_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_is_keyboard_focusable_property()
    }}
    #[inline] pub fn get_is_offscreen_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_is_offscreen_property()
    }}
    #[inline] pub fn get_is_password_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_is_password_property()
    }}
    #[inline] pub fn get_is_required_for_form_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_is_required_for_form_property()
    }}
    #[inline] pub fn get_item_status_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_item_status_property()
    }}
    #[inline] pub fn get_item_type_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_item_type_property()
    }}
    #[inline] pub fn get_labeled_by_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_labeled_by_property()
    }}
    #[inline] pub fn get_localized_control_type_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_localized_control_type_property()
    }}
    #[inline] pub fn get_name_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_name_property()
    }}
    #[inline] pub fn get_orientation_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_orientation_property()
    }}
    #[inline] pub fn get_live_setting_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics>>::get_activation_factory().get_live_setting_property()
    }}
    #[inline] pub fn get_position_in_set_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics3>>::get_activation_factory().get_position_in_set_property()
    }}
    #[inline] pub fn get_size_of_set_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics3>>::get_activation_factory().get_size_of_set_property()
    }}
    #[inline] pub fn get_level_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics3>>::get_activation_factory().get_level_property()
    }}
    #[inline] pub fn get_annotations_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics3>>::get_activation_factory().get_annotations_property()
    }}
    #[inline] pub fn get_is_peripheral_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics5>>::get_activation_factory().get_is_peripheral_property()
    }}
    #[inline] pub fn get_is_data_valid_for_form_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics5>>::get_activation_factory().get_is_data_valid_for_form_property()
    }}
    #[inline] pub fn get_full_description_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics5>>::get_activation_factory().get_full_description_property()
    }}
    #[inline] pub fn get_described_by_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics5>>::get_activation_factory().get_described_by_property()
    }}
    #[inline] pub fn get_flows_to_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics5>>::get_activation_factory().get_flows_to_property()
    }}
    #[inline] pub fn get_flows_from_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics5>>::get_activation_factory().get_flows_from_property()
    }}
    #[inline] pub fn get_landmark_type_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics4>>::get_activation_factory().get_landmark_type_property()
    }}
    #[inline] pub fn get_localized_landmark_type_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics4>>::get_activation_factory().get_localized_landmark_type_property()
    }}
    #[inline] pub fn get_culture_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IAutomationElementIdentifiersStatics6>>::get_activation_factory().get_culture_property()
    }}
}
DEFINE_CLSID!(AutomationElementIdentifiers(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,65,117,116,111,109,97,116,105,111,110,69,108,101,109,101,110,116,73,100,101,110,116,105,102,105,101,114,115,0]) [CLSID_AutomationElementIdentifiers]);
DEFINE_IID!(IID_IAutomationProperties, 1758929708, 58914, 18665, 175, 11, 31, 250, 51, 204, 92, 186);
RT_INTERFACE!{interface IAutomationProperties(IAutomationPropertiesVtbl): IInspectable(IInspectableVtbl) [IID_IAutomationProperties] {
    
}}
DEFINE_IID!(IID_IAutomationPropertiesStatics, 3055091067, 13008, 18800, 156, 66, 124, 3, 154, 199, 190, 120);
RT_INTERFACE!{static interface IAutomationPropertiesStatics(IAutomationPropertiesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPropertiesStatics] {
    fn get_AcceleratorKeyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetAcceleratorKey(&self, element: *mut super::DependencyObject, out: *mut HSTRING) -> HRESULT,
    fn SetAcceleratorKey(&self, element: *mut super::DependencyObject, value: HSTRING) -> HRESULT,
    fn get_AccessKeyProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetAccessKey(&self, element: *mut super::DependencyObject, out: *mut HSTRING) -> HRESULT,
    fn SetAccessKey(&self, element: *mut super::DependencyObject, value: HSTRING) -> HRESULT,
    fn get_AutomationIdProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetAutomationId(&self, element: *mut super::DependencyObject, out: *mut HSTRING) -> HRESULT,
    fn SetAutomationId(&self, element: *mut super::DependencyObject, value: HSTRING) -> HRESULT,
    fn get_HelpTextProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetHelpText(&self, element: *mut super::DependencyObject, out: *mut HSTRING) -> HRESULT,
    fn SetHelpText(&self, element: *mut super::DependencyObject, value: HSTRING) -> HRESULT,
    fn get_IsRequiredForFormProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetIsRequiredForForm(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetIsRequiredForForm(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_ItemStatusProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetItemStatus(&self, element: *mut super::DependencyObject, out: *mut HSTRING) -> HRESULT,
    fn SetItemStatus(&self, element: *mut super::DependencyObject, value: HSTRING) -> HRESULT,
    fn get_ItemTypeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetItemType(&self, element: *mut super::DependencyObject, out: *mut HSTRING) -> HRESULT,
    fn SetItemType(&self, element: *mut super::DependencyObject, value: HSTRING) -> HRESULT,
    fn get_LabeledByProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetLabeledBy(&self, element: *mut super::DependencyObject, out: *mut *mut super::UIElement) -> HRESULT,
    fn SetLabeledBy(&self, element: *mut super::DependencyObject, value: *mut super::UIElement) -> HRESULT,
    fn get_NameProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetName(&self, element: *mut super::DependencyObject, out: *mut HSTRING) -> HRESULT,
    fn SetName(&self, element: *mut super::DependencyObject, value: HSTRING) -> HRESULT,
    fn get_LiveSettingProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetLiveSetting(&self, element: *mut super::DependencyObject, out: *mut peers::AutomationLiveSetting) -> HRESULT,
    fn SetLiveSetting(&self, element: *mut super::DependencyObject, value: peers::AutomationLiveSetting) -> HRESULT
}}
impl IAutomationPropertiesStatics {
    #[inline] pub unsafe fn get_accelerator_key_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AcceleratorKeyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_accelerator_key(&self, element: &super::DependencyObject) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAcceleratorKey)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_accelerator_key(&self, element: &super::DependencyObject, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetAcceleratorKey)(self as *const _ as *mut _, element as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_access_key_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AccessKeyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_access_key(&self, element: &super::DependencyObject) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAccessKey)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_access_key(&self, element: &super::DependencyObject, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetAccessKey)(self as *const _ as *mut _, element as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_automation_id_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AutomationIdProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_automation_id(&self, element: &super::DependencyObject) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAutomationId)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_automation_id(&self, element: &super::DependencyObject, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetAutomationId)(self as *const _ as *mut _, element as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_help_text_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HelpTextProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_help_text(&self, element: &super::DependencyObject) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetHelpText)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_help_text(&self, element: &super::DependencyObject, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetHelpText)(self as *const _ as *mut _, element as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_required_for_form_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsRequiredForFormProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_required_for_form(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsRequiredForForm)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_required_for_form(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetIsRequiredForForm)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_status_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemStatusProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_status(&self, element: &super::DependencyObject) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetItemStatus)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_item_status(&self, element: &super::DependencyObject, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetItemStatus)(self as *const _ as *mut _, element as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_type_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemTypeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_type(&self, element: &super::DependencyObject) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetItemType)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_item_type(&self, element: &super::DependencyObject, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetItemType)(self as *const _ as *mut _, element as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_labeled_by_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LabeledByProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_labeled_by(&self, element: &super::DependencyObject) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetLabeledBy)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_labeled_by(&self, element: &super::DependencyObject, value: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).SetLabeledBy)(self as *const _ as *mut _, element as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_name_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_name(&self, element: &super::DependencyObject) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetName)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_name(&self, element: &super::DependencyObject, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetName)(self as *const _ as *mut _, element as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_live_setting_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LiveSettingProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_live_setting(&self, element: &super::DependencyObject) -> Result<peers::AutomationLiveSetting> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetLiveSetting)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_live_setting(&self, element: &super::DependencyObject, value: peers::AutomationLiveSetting) -> Result<()> {
        let hr = ((*self.lpVtbl).SetLiveSetting)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationPropertiesStatics2, 964056191, 28809, 18433, 143, 29, 170, 183, 128, 144, 209, 160);
RT_INTERFACE!{static interface IAutomationPropertiesStatics2(IAutomationPropertiesStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPropertiesStatics2] {
    fn get_AccessibilityViewProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetAccessibilityView(&self, element: *mut super::DependencyObject, out: *mut peers::AccessibilityView) -> HRESULT,
    fn SetAccessibilityView(&self, element: *mut super::DependencyObject, value: peers::AccessibilityView) -> HRESULT,
    fn get_ControlledPeersProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetControlledPeers(&self, element: *mut super::DependencyObject, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<super::UIElement>) -> HRESULT
}}
impl IAutomationPropertiesStatics2 {
    #[inline] pub unsafe fn get_accessibility_view_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AccessibilityViewProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_accessibility_view(&self, element: &super::DependencyObject) -> Result<peers::AccessibilityView> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetAccessibilityView)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_accessibility_view(&self, element: &super::DependencyObject, value: peers::AccessibilityView) -> Result<()> {
        let hr = ((*self.lpVtbl).SetAccessibilityView)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_controlled_peers_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ControlledPeersProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_controlled_peers(&self, element: &super::DependencyObject) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<super::UIElement>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetControlledPeers)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationPropertiesStatics3, 2071320373, 23729, 17069, 155, 87, 95, 171, 168, 193, 134, 127);
RT_INTERFACE!{static interface IAutomationPropertiesStatics3(IAutomationPropertiesStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPropertiesStatics3] {
    fn get_PositionInSetProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetPositionInSet(&self, element: *mut super::DependencyObject, out: *mut i32) -> HRESULT,
    fn SetPositionInSet(&self, element: *mut super::DependencyObject, value: i32) -> HRESULT,
    fn get_SizeOfSetProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetSizeOfSet(&self, element: *mut super::DependencyObject, out: *mut i32) -> HRESULT,
    fn SetSizeOfSet(&self, element: *mut super::DependencyObject, value: i32) -> HRESULT,
    fn get_LevelProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetLevel(&self, element: *mut super::DependencyObject, out: *mut i32) -> HRESULT,
    fn SetLevel(&self, element: *mut super::DependencyObject, value: i32) -> HRESULT,
    fn get_AnnotationsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetAnnotations(&self, element: *mut super::DependencyObject, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<AutomationAnnotation>) -> HRESULT
}}
impl IAutomationPropertiesStatics3 {
    #[inline] pub unsafe fn get_position_in_set_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PositionInSetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_position_in_set(&self, element: &super::DependencyObject) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetPositionInSet)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_position_in_set(&self, element: &super::DependencyObject, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPositionInSet)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_size_of_set_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SizeOfSetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_size_of_set(&self, element: &super::DependencyObject) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetSizeOfSet)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_size_of_set(&self, element: &super::DependencyObject, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetSizeOfSet)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_level_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LevelProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_level(&self, element: &super::DependencyObject) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetLevel)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_level(&self, element: &super::DependencyObject, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetLevel)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_annotations_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AnnotationsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_annotations(&self, element: &super::DependencyObject) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<AutomationAnnotation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAnnotations)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationPropertiesStatics4, 4158006869, 12570, 19324, 161, 49, 82, 78, 137, 205, 60, 249);
RT_INTERFACE!{static interface IAutomationPropertiesStatics4(IAutomationPropertiesStatics4Vtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPropertiesStatics4] {
    fn get_LandmarkTypeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetLandmarkType(&self, element: *mut super::DependencyObject, out: *mut peers::AutomationLandmarkType) -> HRESULT,
    fn SetLandmarkType(&self, element: *mut super::DependencyObject, value: peers::AutomationLandmarkType) -> HRESULT,
    fn get_LocalizedLandmarkTypeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetLocalizedLandmarkType(&self, element: *mut super::DependencyObject, out: *mut HSTRING) -> HRESULT,
    fn SetLocalizedLandmarkType(&self, element: *mut super::DependencyObject, value: HSTRING) -> HRESULT
}}
impl IAutomationPropertiesStatics4 {
    #[inline] pub unsafe fn get_landmark_type_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LandmarkTypeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_landmark_type(&self, element: &super::DependencyObject) -> Result<peers::AutomationLandmarkType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetLandmarkType)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_landmark_type(&self, element: &super::DependencyObject, value: peers::AutomationLandmarkType) -> Result<()> {
        let hr = ((*self.lpVtbl).SetLandmarkType)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_localized_landmark_type_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LocalizedLandmarkTypeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_localized_landmark_type(&self, element: &super::DependencyObject) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetLocalizedLandmarkType)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_localized_landmark_type(&self, element: &super::DependencyObject, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetLocalizedLandmarkType)(self as *const _ as *mut _, element as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationPropertiesStatics5, 199449382, 51449, 16802, 180, 219, 230, 167, 163, 43, 12, 52);
RT_INTERFACE!{static interface IAutomationPropertiesStatics5(IAutomationPropertiesStatics5Vtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPropertiesStatics5] {
    fn get_IsPeripheralProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetIsPeripheral(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetIsPeripheral(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_IsDataValidForFormProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetIsDataValidForForm(&self, element: *mut super::DependencyObject, out: *mut bool) -> HRESULT,
    fn SetIsDataValidForForm(&self, element: *mut super::DependencyObject, value: bool) -> HRESULT,
    fn get_FullDescriptionProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetFullDescription(&self, element: *mut super::DependencyObject, out: *mut HSTRING) -> HRESULT,
    fn SetFullDescription(&self, element: *mut super::DependencyObject, value: HSTRING) -> HRESULT,
    fn get_LocalizedControlTypeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetLocalizedControlType(&self, element: *mut super::DependencyObject, out: *mut HSTRING) -> HRESULT,
    fn SetLocalizedControlType(&self, element: *mut super::DependencyObject, value: HSTRING) -> HRESULT,
    fn get_DescribedByProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetDescribedBy(&self, element: *mut super::DependencyObject, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<super::DependencyObject>) -> HRESULT,
    fn get_FlowsToProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetFlowsTo(&self, element: *mut super::DependencyObject, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<super::DependencyObject>) -> HRESULT,
    fn get_FlowsFromProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetFlowsFrom(&self, element: *mut super::DependencyObject, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<super::DependencyObject>) -> HRESULT
}}
impl IAutomationPropertiesStatics5 {
    #[inline] pub unsafe fn get_is_peripheral_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsPeripheralProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_peripheral(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsPeripheral)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_peripheral(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetIsPeripheral)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_data_valid_for_form_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsDataValidForFormProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_data_valid_for_form(&self, element: &super::DependencyObject) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIsDataValidForForm)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_data_valid_for_form(&self, element: &super::DependencyObject, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetIsDataValidForForm)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_full_description_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FullDescriptionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_full_description(&self, element: &super::DependencyObject) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetFullDescription)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_full_description(&self, element: &super::DependencyObject, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetFullDescription)(self as *const _ as *mut _, element as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_localized_control_type_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LocalizedControlTypeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_localized_control_type(&self, element: &super::DependencyObject) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetLocalizedControlType)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_localized_control_type(&self, element: &super::DependencyObject, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetLocalizedControlType)(self as *const _ as *mut _, element as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_described_by_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DescribedByProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_described_by(&self, element: &super::DependencyObject) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<super::DependencyObject>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDescribedBy)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_flows_to_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FlowsToProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_flows_to(&self, element: &super::DependencyObject) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<super::DependencyObject>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetFlowsTo)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_flows_from_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FlowsFromProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_flows_from(&self, element: &super::DependencyObject) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<super::DependencyObject>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetFlowsFrom)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationPropertiesStatics6, 3323855631, 60233, 20061, 176, 18, 76, 28, 150, 195, 144, 27);
RT_INTERFACE!{static interface IAutomationPropertiesStatics6(IAutomationPropertiesStatics6Vtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPropertiesStatics6] {
    fn get_CultureProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetCulture(&self, element: *mut super::DependencyObject, out: *mut i32) -> HRESULT,
    fn SetCulture(&self, element: *mut super::DependencyObject, value: i32) -> HRESULT
}}
impl IAutomationPropertiesStatics6 {
    #[inline] pub unsafe fn get_culture_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CultureProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_culture(&self, element: &super::DependencyObject) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetCulture)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_culture(&self, element: &super::DependencyObject, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetCulture)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class AutomationProperties: IAutomationProperties}
impl RtActivatable<IAutomationPropertiesStatics6> for AutomationProperties {}
impl RtActivatable<IAutomationPropertiesStatics3> for AutomationProperties {}
impl RtActivatable<IAutomationPropertiesStatics4> for AutomationProperties {}
impl RtActivatable<IAutomationPropertiesStatics2> for AutomationProperties {}
impl RtActivatable<IAutomationPropertiesStatics5> for AutomationProperties {}
impl RtActivatable<IAutomationPropertiesStatics> for AutomationProperties {}
impl AutomationProperties {
    #[inline] pub fn get_culture_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics6>>::get_activation_factory().get_culture_property()
    }}
    #[inline] pub fn get_culture(element: &super::DependencyObject) -> Result<i32> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics6>>::get_activation_factory().get_culture(element)
    }}
    #[inline] pub fn set_culture(element: &super::DependencyObject, value: i32) -> Result<()> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics6>>::get_activation_factory().set_culture(element, value)
    }}
    #[inline] pub fn get_position_in_set_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics3>>::get_activation_factory().get_position_in_set_property()
    }}
    #[inline] pub fn get_position_in_set(element: &super::DependencyObject) -> Result<i32> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics3>>::get_activation_factory().get_position_in_set(element)
    }}
    #[inline] pub fn set_position_in_set(element: &super::DependencyObject, value: i32) -> Result<()> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics3>>::get_activation_factory().set_position_in_set(element, value)
    }}
    #[inline] pub fn get_size_of_set_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics3>>::get_activation_factory().get_size_of_set_property()
    }}
    #[inline] pub fn get_size_of_set(element: &super::DependencyObject) -> Result<i32> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics3>>::get_activation_factory().get_size_of_set(element)
    }}
    #[inline] pub fn set_size_of_set(element: &super::DependencyObject, value: i32) -> Result<()> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics3>>::get_activation_factory().set_size_of_set(element, value)
    }}
    #[inline] pub fn get_level_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics3>>::get_activation_factory().get_level_property()
    }}
    #[inline] pub fn get_level(element: &super::DependencyObject) -> Result<i32> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics3>>::get_activation_factory().get_level(element)
    }}
    #[inline] pub fn set_level(element: &super::DependencyObject, value: i32) -> Result<()> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics3>>::get_activation_factory().set_level(element, value)
    }}
    #[inline] pub fn get_annotations_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics3>>::get_activation_factory().get_annotations_property()
    }}
    #[inline] pub fn get_annotations(element: &super::DependencyObject) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<AutomationAnnotation>>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics3>>::get_activation_factory().get_annotations(element)
    }}
    #[inline] pub fn get_landmark_type_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics4>>::get_activation_factory().get_landmark_type_property()
    }}
    #[inline] pub fn get_landmark_type(element: &super::DependencyObject) -> Result<peers::AutomationLandmarkType> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics4>>::get_activation_factory().get_landmark_type(element)
    }}
    #[inline] pub fn set_landmark_type(element: &super::DependencyObject, value: peers::AutomationLandmarkType) -> Result<()> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics4>>::get_activation_factory().set_landmark_type(element, value)
    }}
    #[inline] pub fn get_localized_landmark_type_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics4>>::get_activation_factory().get_localized_landmark_type_property()
    }}
    #[inline] pub fn get_localized_landmark_type(element: &super::DependencyObject) -> Result<HString> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics4>>::get_activation_factory().get_localized_landmark_type(element)
    }}
    #[inline] pub fn set_localized_landmark_type(element: &super::DependencyObject, value: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics4>>::get_activation_factory().set_localized_landmark_type(element, value)
    }}
    #[inline] pub fn get_accessibility_view_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics2>>::get_activation_factory().get_accessibility_view_property()
    }}
    #[inline] pub fn get_accessibility_view(element: &super::DependencyObject) -> Result<peers::AccessibilityView> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics2>>::get_activation_factory().get_accessibility_view(element)
    }}
    #[inline] pub fn set_accessibility_view(element: &super::DependencyObject, value: peers::AccessibilityView) -> Result<()> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics2>>::get_activation_factory().set_accessibility_view(element, value)
    }}
    #[inline] pub fn get_controlled_peers_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics2>>::get_activation_factory().get_controlled_peers_property()
    }}
    #[inline] pub fn get_controlled_peers(element: &super::DependencyObject) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<super::UIElement>>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics2>>::get_activation_factory().get_controlled_peers(element)
    }}
    #[inline] pub fn get_is_peripheral_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics5>>::get_activation_factory().get_is_peripheral_property()
    }}
    #[inline] pub fn get_is_peripheral(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics5>>::get_activation_factory().get_is_peripheral(element)
    }}
    #[inline] pub fn set_is_peripheral(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics5>>::get_activation_factory().set_is_peripheral(element, value)
    }}
    #[inline] pub fn get_is_data_valid_for_form_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics5>>::get_activation_factory().get_is_data_valid_for_form_property()
    }}
    #[inline] pub fn get_is_data_valid_for_form(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics5>>::get_activation_factory().get_is_data_valid_for_form(element)
    }}
    #[inline] pub fn set_is_data_valid_for_form(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics5>>::get_activation_factory().set_is_data_valid_for_form(element, value)
    }}
    #[inline] pub fn get_full_description_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics5>>::get_activation_factory().get_full_description_property()
    }}
    #[inline] pub fn get_full_description(element: &super::DependencyObject) -> Result<HString> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics5>>::get_activation_factory().get_full_description(element)
    }}
    #[inline] pub fn set_full_description(element: &super::DependencyObject, value: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics5>>::get_activation_factory().set_full_description(element, value)
    }}
    #[inline] pub fn get_localized_control_type_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics5>>::get_activation_factory().get_localized_control_type_property()
    }}
    #[inline] pub fn get_localized_control_type(element: &super::DependencyObject) -> Result<HString> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics5>>::get_activation_factory().get_localized_control_type(element)
    }}
    #[inline] pub fn set_localized_control_type(element: &super::DependencyObject, value: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics5>>::get_activation_factory().set_localized_control_type(element, value)
    }}
    #[inline] pub fn get_described_by_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics5>>::get_activation_factory().get_described_by_property()
    }}
    #[inline] pub fn get_described_by(element: &super::DependencyObject) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<super::DependencyObject>>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics5>>::get_activation_factory().get_described_by(element)
    }}
    #[inline] pub fn get_flows_to_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics5>>::get_activation_factory().get_flows_to_property()
    }}
    #[inline] pub fn get_flows_to(element: &super::DependencyObject) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<super::DependencyObject>>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics5>>::get_activation_factory().get_flows_to(element)
    }}
    #[inline] pub fn get_flows_from_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics5>>::get_activation_factory().get_flows_from_property()
    }}
    #[inline] pub fn get_flows_from(element: &super::DependencyObject) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<super::DependencyObject>>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics5>>::get_activation_factory().get_flows_from(element)
    }}
    #[inline] pub fn get_accelerator_key_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().get_accelerator_key_property()
    }}
    #[inline] pub fn get_accelerator_key(element: &super::DependencyObject) -> Result<HString> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().get_accelerator_key(element)
    }}
    #[inline] pub fn set_accelerator_key(element: &super::DependencyObject, value: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().set_accelerator_key(element, value)
    }}
    #[inline] pub fn get_access_key_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().get_access_key_property()
    }}
    #[inline] pub fn get_access_key(element: &super::DependencyObject) -> Result<HString> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().get_access_key(element)
    }}
    #[inline] pub fn set_access_key(element: &super::DependencyObject, value: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().set_access_key(element, value)
    }}
    #[inline] pub fn get_automation_id_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().get_automation_id_property()
    }}
    #[inline] pub fn get_automation_id(element: &super::DependencyObject) -> Result<HString> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().get_automation_id(element)
    }}
    #[inline] pub fn set_automation_id(element: &super::DependencyObject, value: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().set_automation_id(element, value)
    }}
    #[inline] pub fn get_help_text_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().get_help_text_property()
    }}
    #[inline] pub fn get_help_text(element: &super::DependencyObject) -> Result<HString> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().get_help_text(element)
    }}
    #[inline] pub fn set_help_text(element: &super::DependencyObject, value: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().set_help_text(element, value)
    }}
    #[inline] pub fn get_is_required_for_form_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().get_is_required_for_form_property()
    }}
    #[inline] pub fn get_is_required_for_form(element: &super::DependencyObject) -> Result<bool> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().get_is_required_for_form(element)
    }}
    #[inline] pub fn set_is_required_for_form(element: &super::DependencyObject, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().set_is_required_for_form(element, value)
    }}
    #[inline] pub fn get_item_status_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().get_item_status_property()
    }}
    #[inline] pub fn get_item_status(element: &super::DependencyObject) -> Result<HString> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().get_item_status(element)
    }}
    #[inline] pub fn set_item_status(element: &super::DependencyObject, value: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().set_item_status(element, value)
    }}
    #[inline] pub fn get_item_type_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().get_item_type_property()
    }}
    #[inline] pub fn get_item_type(element: &super::DependencyObject) -> Result<HString> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().get_item_type(element)
    }}
    #[inline] pub fn set_item_type(element: &super::DependencyObject, value: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().set_item_type(element, value)
    }}
    #[inline] pub fn get_labeled_by_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().get_labeled_by_property()
    }}
    #[inline] pub fn get_labeled_by(element: &super::DependencyObject) -> Result<ComPtr<super::UIElement>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().get_labeled_by(element)
    }}
    #[inline] pub fn set_labeled_by(element: &super::DependencyObject, value: &super::UIElement) -> Result<()> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().set_labeled_by(element, value)
    }}
    #[inline] pub fn get_name_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().get_name_property()
    }}
    #[inline] pub fn get_name(element: &super::DependencyObject) -> Result<HString> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().get_name(element)
    }}
    #[inline] pub fn set_name(element: &super::DependencyObject, value: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().set_name(element, value)
    }}
    #[inline] pub fn get_live_setting_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().get_live_setting_property()
    }}
    #[inline] pub fn get_live_setting(element: &super::DependencyObject) -> Result<peers::AutomationLiveSetting> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().get_live_setting(element)
    }}
    #[inline] pub fn set_live_setting(element: &super::DependencyObject, value: peers::AutomationLiveSetting) -> Result<()> { unsafe {
        <Self as RtActivatable<IAutomationPropertiesStatics>>::get_activation_factory().set_live_setting(element, value)
    }}
}
DEFINE_CLSID!(AutomationProperties(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,65,117,116,111,109,97,116,105,111,110,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_AutomationProperties]);
DEFINE_IID!(IID_IAutomationProperty, 3056015707, 12839, 19990, 149, 52, 221, 236, 227, 13, 219, 70);
RT_INTERFACE!{interface IAutomationProperty(IAutomationPropertyVtbl): IInspectable(IInspectableVtbl) [IID_IAutomationProperty] {
    
}}
DEFINE_IID!(IID_IDockPatternIdentifiers, 3436704998, 58617, 18431, 189, 231, 55, 139, 17, 247, 142, 9);
RT_INTERFACE!{interface IDockPatternIdentifiers(IDockPatternIdentifiersVtbl): IInspectable(IInspectableVtbl) [IID_IDockPatternIdentifiers] {
    
}}
DEFINE_IID!(IID_IDockPatternIdentifiersStatics, 730276956, 60800, 20453, 142, 180, 112, 138, 57, 200, 65, 229);
RT_INTERFACE!{static interface IDockPatternIdentifiersStatics(IDockPatternIdentifiersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDockPatternIdentifiersStatics] {
    fn get_DockPositionProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl IDockPatternIdentifiersStatics {
    #[inline] pub unsafe fn get_dock_position_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DockPositionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class DockPatternIdentifiers: IDockPatternIdentifiers}
impl RtActivatable<IDockPatternIdentifiersStatics> for DockPatternIdentifiers {}
impl DockPatternIdentifiers {
    #[inline] pub fn get_dock_position_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IDockPatternIdentifiersStatics>>::get_activation_factory().get_dock_position_property()
    }}
}
DEFINE_CLSID!(DockPatternIdentifiers(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,68,111,99,107,80,97,116,116,101,114,110,73,100,101,110,116,105,102,105,101,114,115,0]) [CLSID_DockPatternIdentifiers]);
DEFINE_IID!(IID_IDragPatternIdentifiers, 1650911621, 19719, 20096, 130, 235, 143, 150, 105, 10, 26, 12);
RT_INTERFACE!{interface IDragPatternIdentifiers(IDragPatternIdentifiersVtbl): IInspectable(IInspectableVtbl) [IID_IDragPatternIdentifiers] {
    
}}
DEFINE_IID!(IID_IDragPatternIdentifiersStatics, 704984989, 5973, 16514, 157, 144, 70, 241, 65, 29, 121, 134);
RT_INTERFACE!{static interface IDragPatternIdentifiersStatics(IDragPatternIdentifiersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDragPatternIdentifiersStatics] {
    fn get_DropEffectProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_DropEffectsProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_GrabbedItemsProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_IsGrabbedProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl IDragPatternIdentifiersStatics {
    #[inline] pub unsafe fn get_drop_effect_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DropEffectProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drop_effects_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DropEffectsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_grabbed_items_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GrabbedItemsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_grabbed_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsGrabbedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class DragPatternIdentifiers: IDragPatternIdentifiers}
impl RtActivatable<IDragPatternIdentifiersStatics> for DragPatternIdentifiers {}
impl DragPatternIdentifiers {
    #[inline] pub fn get_drop_effect_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IDragPatternIdentifiersStatics>>::get_activation_factory().get_drop_effect_property()
    }}
    #[inline] pub fn get_drop_effects_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IDragPatternIdentifiersStatics>>::get_activation_factory().get_drop_effects_property()
    }}
    #[inline] pub fn get_grabbed_items_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IDragPatternIdentifiersStatics>>::get_activation_factory().get_grabbed_items_property()
    }}
    #[inline] pub fn get_is_grabbed_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IDragPatternIdentifiersStatics>>::get_activation_factory().get_is_grabbed_property()
    }}
}
DEFINE_CLSID!(DragPatternIdentifiers(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,68,114,97,103,80,97,116,116,101,114,110,73,100,101,110,116,105,102,105,101,114,115,0]) [CLSID_DragPatternIdentifiers]);
DEFINE_IID!(IID_IDropTargetPatternIdentifiers, 294015283, 42750, 17972, 189, 24, 14, 246, 18, 183, 178, 8);
RT_INTERFACE!{interface IDropTargetPatternIdentifiers(IDropTargetPatternIdentifiersVtbl): IInspectable(IInspectableVtbl) [IID_IDropTargetPatternIdentifiers] {
    
}}
DEFINE_IID!(IID_IDropTargetPatternIdentifiersStatics, 459879172, 35323, 19210, 148, 82, 202, 44, 102, 170, 249, 243);
RT_INTERFACE!{static interface IDropTargetPatternIdentifiersStatics(IDropTargetPatternIdentifiersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDropTargetPatternIdentifiersStatics] {
    fn get_DropTargetEffectProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_DropTargetEffectsProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl IDropTargetPatternIdentifiersStatics {
    #[inline] pub unsafe fn get_drop_target_effect_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DropTargetEffectProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drop_target_effects_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DropTargetEffectsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class DropTargetPatternIdentifiers: IDropTargetPatternIdentifiers}
impl RtActivatable<IDropTargetPatternIdentifiersStatics> for DropTargetPatternIdentifiers {}
impl DropTargetPatternIdentifiers {
    #[inline] pub fn get_drop_target_effect_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IDropTargetPatternIdentifiersStatics>>::get_activation_factory().get_drop_target_effect_property()
    }}
    #[inline] pub fn get_drop_target_effects_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IDropTargetPatternIdentifiersStatics>>::get_activation_factory().get_drop_target_effects_property()
    }}
}
DEFINE_CLSID!(DropTargetPatternIdentifiers(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,68,114,111,112,84,97,114,103,101,116,80,97,116,116,101,114,110,73,100,101,110,116,105,102,105,101,114,115,0]) [CLSID_DropTargetPatternIdentifiers]);
DEFINE_IID!(IID_IExpandCollapsePatternIdentifiers, 2953231040, 29979, 19797, 146, 203, 97, 62, 193, 189, 245, 208);
RT_INTERFACE!{interface IExpandCollapsePatternIdentifiers(IExpandCollapsePatternIdentifiersVtbl): IInspectable(IInspectableVtbl) [IID_IExpandCollapsePatternIdentifiers] {
    
}}
DEFINE_IID!(IID_IExpandCollapsePatternIdentifiersStatics, 3615584212, 28384, 20280, 142, 20, 86, 239, 33, 173, 172, 253);
RT_INTERFACE!{static interface IExpandCollapsePatternIdentifiersStatics(IExpandCollapsePatternIdentifiersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IExpandCollapsePatternIdentifiersStatics] {
    fn get_ExpandCollapseStateProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl IExpandCollapsePatternIdentifiersStatics {
    #[inline] pub unsafe fn get_expand_collapse_state_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExpandCollapseStateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ExpandCollapsePatternIdentifiers: IExpandCollapsePatternIdentifiers}
impl RtActivatable<IExpandCollapsePatternIdentifiersStatics> for ExpandCollapsePatternIdentifiers {}
impl ExpandCollapsePatternIdentifiers {
    #[inline] pub fn get_expand_collapse_state_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IExpandCollapsePatternIdentifiersStatics>>::get_activation_factory().get_expand_collapse_state_property()
    }}
}
DEFINE_CLSID!(ExpandCollapsePatternIdentifiers(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,69,120,112,97,110,100,67,111,108,108,97,112,115,101,80,97,116,116,101,114,110,73,100,101,110,116,105,102,105,101,114,115,0]) [CLSID_ExpandCollapsePatternIdentifiers]);
DEFINE_IID!(IID_IGridItemPatternIdentifiers, 1970750705, 12933, 20401, 128, 59, 37, 69, 189, 67, 21, 153);
RT_INTERFACE!{interface IGridItemPatternIdentifiers(IGridItemPatternIdentifiersVtbl): IInspectable(IInspectableVtbl) [IID_IGridItemPatternIdentifiers] {
    
}}
DEFINE_IID!(IID_IGridItemPatternIdentifiersStatics, 561849346, 24134, 19809, 135, 148, 184, 238, 142, 119, 71, 20);
RT_INTERFACE!{static interface IGridItemPatternIdentifiersStatics(IGridItemPatternIdentifiersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGridItemPatternIdentifiersStatics] {
    fn get_ColumnProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_ColumnSpanProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_ContainingGridProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_RowProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_RowSpanProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl IGridItemPatternIdentifiersStatics {
    #[inline] pub unsafe fn get_column_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ColumnProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_column_span_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ColumnSpanProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_containing_grid_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContainingGridProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_row_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RowProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_row_span_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RowSpanProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class GridItemPatternIdentifiers: IGridItemPatternIdentifiers}
impl RtActivatable<IGridItemPatternIdentifiersStatics> for GridItemPatternIdentifiers {}
impl GridItemPatternIdentifiers {
    #[inline] pub fn get_column_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IGridItemPatternIdentifiersStatics>>::get_activation_factory().get_column_property()
    }}
    #[inline] pub fn get_column_span_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IGridItemPatternIdentifiersStatics>>::get_activation_factory().get_column_span_property()
    }}
    #[inline] pub fn get_containing_grid_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IGridItemPatternIdentifiersStatics>>::get_activation_factory().get_containing_grid_property()
    }}
    #[inline] pub fn get_row_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IGridItemPatternIdentifiersStatics>>::get_activation_factory().get_row_property()
    }}
    #[inline] pub fn get_row_span_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IGridItemPatternIdentifiersStatics>>::get_activation_factory().get_row_span_property()
    }}
}
DEFINE_CLSID!(GridItemPatternIdentifiers(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,71,114,105,100,73,116,101,109,80,97,116,116,101,114,110,73,100,101,110,116,105,102,105,101,114,115,0]) [CLSID_GridItemPatternIdentifiers]);
DEFINE_IID!(IID_IGridPatternIdentifiers, 3372390415, 38597, 17676, 144, 68, 126, 82, 194, 79, 158, 148);
RT_INTERFACE!{interface IGridPatternIdentifiers(IGridPatternIdentifiersVtbl): IInspectable(IInspectableVtbl) [IID_IGridPatternIdentifiers] {
    
}}
DEFINE_IID!(IID_IGridPatternIdentifiersStatics, 2076463859, 41345, 16695, 141, 233, 31, 155, 26, 131, 32, 237);
RT_INTERFACE!{static interface IGridPatternIdentifiersStatics(IGridPatternIdentifiersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGridPatternIdentifiersStatics] {
    fn get_ColumnCountProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_RowCountProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl IGridPatternIdentifiersStatics {
    #[inline] pub unsafe fn get_column_count_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ColumnCountProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_row_count_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RowCountProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class GridPatternIdentifiers: IGridPatternIdentifiers}
impl RtActivatable<IGridPatternIdentifiersStatics> for GridPatternIdentifiers {}
impl GridPatternIdentifiers {
    #[inline] pub fn get_column_count_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IGridPatternIdentifiersStatics>>::get_activation_factory().get_column_count_property()
    }}
    #[inline] pub fn get_row_count_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IGridPatternIdentifiersStatics>>::get_activation_factory().get_row_count_property()
    }}
}
DEFINE_CLSID!(GridPatternIdentifiers(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,71,114,105,100,80,97,116,116,101,114,110,73,100,101,110,116,105,102,105,101,114,115,0]) [CLSID_GridPatternIdentifiers]);
DEFINE_IID!(IID_IMultipleViewPatternIdentifiers, 1566364600, 7698, 18571, 176, 234, 94, 108, 184, 152, 22, 225);
RT_INTERFACE!{interface IMultipleViewPatternIdentifiers(IMultipleViewPatternIdentifiersVtbl): IInspectable(IInspectableVtbl) [IID_IMultipleViewPatternIdentifiers] {
    
}}
DEFINE_IID!(IID_IMultipleViewPatternIdentifiersStatics, 2848958063, 27524, 19825, 158, 72, 215, 100, 211, 188, 218, 142);
RT_INTERFACE!{static interface IMultipleViewPatternIdentifiersStatics(IMultipleViewPatternIdentifiersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMultipleViewPatternIdentifiersStatics] {
    fn get_CurrentViewProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_SupportedViewsProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl IMultipleViewPatternIdentifiersStatics {
    #[inline] pub unsafe fn get_current_view_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CurrentViewProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_supported_views_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SupportedViewsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class MultipleViewPatternIdentifiers: IMultipleViewPatternIdentifiers}
impl RtActivatable<IMultipleViewPatternIdentifiersStatics> for MultipleViewPatternIdentifiers {}
impl MultipleViewPatternIdentifiers {
    #[inline] pub fn get_current_view_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IMultipleViewPatternIdentifiersStatics>>::get_activation_factory().get_current_view_property()
    }}
    #[inline] pub fn get_supported_views_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IMultipleViewPatternIdentifiersStatics>>::get_activation_factory().get_supported_views_property()
    }}
}
DEFINE_CLSID!(MultipleViewPatternIdentifiers(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,77,117,108,116,105,112,108,101,86,105,101,119,80,97,116,116,101,114,110,73,100,101,110,116,105,102,105,101,114,115,0]) [CLSID_MultipleViewPatternIdentifiers]);
DEFINE_IID!(IID_IRangeValuePatternIdentifiers, 4168486725, 13257, 18045, 188, 158, 209, 81, 82, 99, 172, 225);
RT_INTERFACE!{interface IRangeValuePatternIdentifiers(IRangeValuePatternIdentifiersVtbl): IInspectable(IInspectableVtbl) [IID_IRangeValuePatternIdentifiers] {
    
}}
DEFINE_IID!(IID_IRangeValuePatternIdentifiersStatics, 3458417935, 7207, 17791, 184, 21, 122, 94, 70, 134, 61, 187);
RT_INTERFACE!{static interface IRangeValuePatternIdentifiersStatics(IRangeValuePatternIdentifiersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRangeValuePatternIdentifiersStatics] {
    fn get_IsReadOnlyProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_LargeChangeProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_MaximumProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_MinimumProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_SmallChangeProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_ValueProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl IRangeValuePatternIdentifiersStatics {
    #[inline] pub unsafe fn get_is_read_only_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsReadOnlyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_large_change_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LargeChangeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_maximum_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaximumProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_minimum_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MinimumProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_small_change_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SmallChangeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_value_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ValueProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class RangeValuePatternIdentifiers: IRangeValuePatternIdentifiers}
impl RtActivatable<IRangeValuePatternIdentifiersStatics> for RangeValuePatternIdentifiers {}
impl RangeValuePatternIdentifiers {
    #[inline] pub fn get_is_read_only_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IRangeValuePatternIdentifiersStatics>>::get_activation_factory().get_is_read_only_property()
    }}
    #[inline] pub fn get_large_change_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IRangeValuePatternIdentifiersStatics>>::get_activation_factory().get_large_change_property()
    }}
    #[inline] pub fn get_maximum_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IRangeValuePatternIdentifiersStatics>>::get_activation_factory().get_maximum_property()
    }}
    #[inline] pub fn get_minimum_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IRangeValuePatternIdentifiersStatics>>::get_activation_factory().get_minimum_property()
    }}
    #[inline] pub fn get_small_change_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IRangeValuePatternIdentifiersStatics>>::get_activation_factory().get_small_change_property()
    }}
    #[inline] pub fn get_value_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IRangeValuePatternIdentifiersStatics>>::get_activation_factory().get_value_property()
    }}
}
DEFINE_CLSID!(RangeValuePatternIdentifiers(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,82,97,110,103,101,86,97,108,117,101,80,97,116,116,101,114,110,73,100,101,110,116,105,102,105,101,114,115,0]) [CLSID_RangeValuePatternIdentifiers]);
DEFINE_IID!(IID_IScrollPatternIdentifiers, 912986115, 16988, 18769, 174, 131, 213, 33, 231, 59, 198, 150);
RT_INTERFACE!{interface IScrollPatternIdentifiers(IScrollPatternIdentifiersVtbl): IInspectable(IInspectableVtbl) [IID_IScrollPatternIdentifiers] {
    
}}
DEFINE_IID!(IID_IScrollPatternIdentifiersStatics, 1274601633, 64383, 20388, 131, 179, 207, 174, 177, 3, 166, 133);
RT_INTERFACE!{static interface IScrollPatternIdentifiersStatics(IScrollPatternIdentifiersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IScrollPatternIdentifiersStatics] {
    fn get_HorizontallyScrollableProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_HorizontalScrollPercentProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_HorizontalViewSizeProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_NoScroll(&self, out: *mut f64) -> HRESULT,
    fn get_VerticallyScrollableProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_VerticalScrollPercentProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_VerticalViewSizeProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl IScrollPatternIdentifiersStatics {
    #[inline] pub unsafe fn get_horizontally_scrollable_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HorizontallyScrollableProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_scroll_percent_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HorizontalScrollPercentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_view_size_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HorizontalViewSizeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_no_scroll(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NoScroll)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertically_scrollable_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VerticallyScrollableProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_scroll_percent_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VerticalScrollPercentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_view_size_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VerticalViewSizeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ScrollPatternIdentifiers: IScrollPatternIdentifiers}
impl RtActivatable<IScrollPatternIdentifiersStatics> for ScrollPatternIdentifiers {}
impl ScrollPatternIdentifiers {
    #[inline] pub fn get_horizontally_scrollable_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IScrollPatternIdentifiersStatics>>::get_activation_factory().get_horizontally_scrollable_property()
    }}
    #[inline] pub fn get_horizontal_scroll_percent_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IScrollPatternIdentifiersStatics>>::get_activation_factory().get_horizontal_scroll_percent_property()
    }}
    #[inline] pub fn get_horizontal_view_size_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IScrollPatternIdentifiersStatics>>::get_activation_factory().get_horizontal_view_size_property()
    }}
    #[inline] pub fn get_no_scroll() -> Result<f64> { unsafe {
        <Self as RtActivatable<IScrollPatternIdentifiersStatics>>::get_activation_factory().get_no_scroll()
    }}
    #[inline] pub fn get_vertically_scrollable_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IScrollPatternIdentifiersStatics>>::get_activation_factory().get_vertically_scrollable_property()
    }}
    #[inline] pub fn get_vertical_scroll_percent_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IScrollPatternIdentifiersStatics>>::get_activation_factory().get_vertical_scroll_percent_property()
    }}
    #[inline] pub fn get_vertical_view_size_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IScrollPatternIdentifiersStatics>>::get_activation_factory().get_vertical_view_size_property()
    }}
}
DEFINE_CLSID!(ScrollPatternIdentifiers(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,83,99,114,111,108,108,80,97,116,116,101,114,110,73,100,101,110,116,105,102,105,101,114,115,0]) [CLSID_ScrollPatternIdentifiers]);
DEFINE_IID!(IID_ISelectionItemPatternIdentifiers, 766485530, 16120, 19381, 160, 43, 62, 225, 178, 39, 71, 64);
RT_INTERFACE!{interface ISelectionItemPatternIdentifiers(ISelectionItemPatternIdentifiersVtbl): IInspectable(IInspectableVtbl) [IID_ISelectionItemPatternIdentifiers] {
    
}}
DEFINE_IID!(IID_ISelectionItemPatternIdentifiersStatics, 2836975971, 18558, 20030, 159, 134, 123, 68, 172, 190, 39, 206);
RT_INTERFACE!{static interface ISelectionItemPatternIdentifiersStatics(ISelectionItemPatternIdentifiersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISelectionItemPatternIdentifiersStatics] {
    fn get_IsSelectedProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_SelectionContainerProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl ISelectionItemPatternIdentifiersStatics {
    #[inline] pub unsafe fn get_is_selected_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsSelectedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_container_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionContainerProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SelectionItemPatternIdentifiers: ISelectionItemPatternIdentifiers}
impl RtActivatable<ISelectionItemPatternIdentifiersStatics> for SelectionItemPatternIdentifiers {}
impl SelectionItemPatternIdentifiers {
    #[inline] pub fn get_is_selected_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<ISelectionItemPatternIdentifiersStatics>>::get_activation_factory().get_is_selected_property()
    }}
    #[inline] pub fn get_selection_container_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<ISelectionItemPatternIdentifiersStatics>>::get_activation_factory().get_selection_container_property()
    }}
}
DEFINE_CLSID!(SelectionItemPatternIdentifiers(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,83,101,108,101,99,116,105,111,110,73,116,101,109,80,97,116,116,101,114,110,73,100,101,110,116,105,102,105,101,114,115,0]) [CLSID_SelectionItemPatternIdentifiers]);
DEFINE_IID!(IID_ISelectionPatternIdentifiers, 1252421552, 58359, 18271, 183, 141, 248, 168, 59, 183, 48, 196);
RT_INTERFACE!{interface ISelectionPatternIdentifiers(ISelectionPatternIdentifiersVtbl): IInspectable(IInspectableVtbl) [IID_ISelectionPatternIdentifiers] {
    
}}
DEFINE_IID!(IID_ISelectionPatternIdentifiersStatics, 2466470732, 27472, 16545, 178, 63, 92, 120, 221, 189, 71, 154);
RT_INTERFACE!{static interface ISelectionPatternIdentifiersStatics(ISelectionPatternIdentifiersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISelectionPatternIdentifiersStatics] {
    fn get_CanSelectMultipleProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_IsSelectionRequiredProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_SelectionProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl ISelectionPatternIdentifiersStatics {
    #[inline] pub unsafe fn get_can_select_multiple_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CanSelectMultipleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_selection_required_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsSelectionRequiredProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SelectionPatternIdentifiers: ISelectionPatternIdentifiers}
impl RtActivatable<ISelectionPatternIdentifiersStatics> for SelectionPatternIdentifiers {}
impl SelectionPatternIdentifiers {
    #[inline] pub fn get_can_select_multiple_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<ISelectionPatternIdentifiersStatics>>::get_activation_factory().get_can_select_multiple_property()
    }}
    #[inline] pub fn get_is_selection_required_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<ISelectionPatternIdentifiersStatics>>::get_activation_factory().get_is_selection_required_property()
    }}
    #[inline] pub fn get_selection_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<ISelectionPatternIdentifiersStatics>>::get_activation_factory().get_selection_property()
    }}
}
DEFINE_CLSID!(SelectionPatternIdentifiers(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,83,101,108,101,99,116,105,111,110,80,97,116,116,101,114,110,73,100,101,110,116,105,102,105,101,114,115,0]) [CLSID_SelectionPatternIdentifiers]);
DEFINE_IID!(IID_ISpreadsheetItemPatternIdentifiers, 2218032665, 51787, 18082, 167, 148, 200, 121, 40, 163, 177, 171);
RT_INTERFACE!{interface ISpreadsheetItemPatternIdentifiers(ISpreadsheetItemPatternIdentifiersVtbl): IInspectable(IInspectableVtbl) [IID_ISpreadsheetItemPatternIdentifiers] {
    
}}
DEFINE_IID!(IID_ISpreadsheetItemPatternIdentifiersStatics, 1130727289, 21376, 20242, 180, 104, 180, 243, 104, 173, 68, 153);
RT_INTERFACE!{static interface ISpreadsheetItemPatternIdentifiersStatics(ISpreadsheetItemPatternIdentifiersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISpreadsheetItemPatternIdentifiersStatics] {
    fn get_FormulaProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl ISpreadsheetItemPatternIdentifiersStatics {
    #[inline] pub unsafe fn get_formula_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FormulaProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SpreadsheetItemPatternIdentifiers: ISpreadsheetItemPatternIdentifiers}
impl RtActivatable<ISpreadsheetItemPatternIdentifiersStatics> for SpreadsheetItemPatternIdentifiers {}
impl SpreadsheetItemPatternIdentifiers {
    #[inline] pub fn get_formula_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<ISpreadsheetItemPatternIdentifiersStatics>>::get_activation_factory().get_formula_property()
    }}
}
DEFINE_CLSID!(SpreadsheetItemPatternIdentifiers(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,83,112,114,101,97,100,115,104,101,101,116,73,116,101,109,80,97,116,116,101,114,110,73,100,101,110,116,105,102,105,101,114,115,0]) [CLSID_SpreadsheetItemPatternIdentifiers]);
DEFINE_IID!(IID_IStylesPatternIdentifiers, 2967790081, 59549, 17259, 130, 135, 79, 121, 3, 70, 104, 121);
RT_INTERFACE!{interface IStylesPatternIdentifiers(IStylesPatternIdentifiersVtbl): IInspectable(IInspectableVtbl) [IID_IStylesPatternIdentifiers] {
    
}}
DEFINE_IID!(IID_IStylesPatternIdentifiersStatics, 1384793466, 48188, 19784, 148, 175, 31, 104, 112, 60, 162, 150);
RT_INTERFACE!{static interface IStylesPatternIdentifiersStatics(IStylesPatternIdentifiersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IStylesPatternIdentifiersStatics] {
    fn get_ExtendedPropertiesProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_FillColorProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_FillPatternColorProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_FillPatternStyleProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_ShapeProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_StyleIdProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_StyleNameProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl IStylesPatternIdentifiersStatics {
    #[inline] pub unsafe fn get_extended_properties_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExtendedPropertiesProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_fill_color_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FillColorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_fill_pattern_color_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FillPatternColorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_fill_pattern_style_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FillPatternStyleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_shape_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ShapeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_style_id_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StyleIdProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_style_name_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StyleNameProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class StylesPatternIdentifiers: IStylesPatternIdentifiers}
impl RtActivatable<IStylesPatternIdentifiersStatics> for StylesPatternIdentifiers {}
impl StylesPatternIdentifiers {
    #[inline] pub fn get_extended_properties_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IStylesPatternIdentifiersStatics>>::get_activation_factory().get_extended_properties_property()
    }}
    #[inline] pub fn get_fill_color_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IStylesPatternIdentifiersStatics>>::get_activation_factory().get_fill_color_property()
    }}
    #[inline] pub fn get_fill_pattern_color_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IStylesPatternIdentifiersStatics>>::get_activation_factory().get_fill_pattern_color_property()
    }}
    #[inline] pub fn get_fill_pattern_style_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IStylesPatternIdentifiersStatics>>::get_activation_factory().get_fill_pattern_style_property()
    }}
    #[inline] pub fn get_shape_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IStylesPatternIdentifiersStatics>>::get_activation_factory().get_shape_property()
    }}
    #[inline] pub fn get_style_id_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IStylesPatternIdentifiersStatics>>::get_activation_factory().get_style_id_property()
    }}
    #[inline] pub fn get_style_name_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IStylesPatternIdentifiersStatics>>::get_activation_factory().get_style_name_property()
    }}
}
DEFINE_CLSID!(StylesPatternIdentifiers(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,83,116,121,108,101,115,80,97,116,116,101,114,110,73,100,101,110,116,105,102,105,101,114,115,0]) [CLSID_StylesPatternIdentifiers]);
DEFINE_IID!(IID_ITableItemPatternIdentifiers, 3274106285, 32887, 19556, 152, 228, 232, 59, 207, 27, 67, 137);
RT_INTERFACE!{interface ITableItemPatternIdentifiers(ITableItemPatternIdentifiersVtbl): IInspectable(IInspectableVtbl) [IID_ITableItemPatternIdentifiers] {
    
}}
DEFINE_IID!(IID_ITableItemPatternIdentifiersStatics, 616872227, 59810, 19945, 178, 164, 168, 178, 45, 11, 227, 98);
RT_INTERFACE!{static interface ITableItemPatternIdentifiersStatics(ITableItemPatternIdentifiersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ITableItemPatternIdentifiersStatics] {
    fn get_ColumnHeaderItemsProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_RowHeaderItemsProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl ITableItemPatternIdentifiersStatics {
    #[inline] pub unsafe fn get_column_header_items_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ColumnHeaderItemsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_row_header_items_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RowHeaderItemsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class TableItemPatternIdentifiers: ITableItemPatternIdentifiers}
impl RtActivatable<ITableItemPatternIdentifiersStatics> for TableItemPatternIdentifiers {}
impl TableItemPatternIdentifiers {
    #[inline] pub fn get_column_header_items_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<ITableItemPatternIdentifiersStatics>>::get_activation_factory().get_column_header_items_property()
    }}
    #[inline] pub fn get_row_header_items_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<ITableItemPatternIdentifiersStatics>>::get_activation_factory().get_row_header_items_property()
    }}
}
DEFINE_CLSID!(TableItemPatternIdentifiers(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,84,97,98,108,101,73,116,101,109,80,97,116,116,101,114,110,73,100,101,110,116,105,102,105,101,114,115,0]) [CLSID_TableItemPatternIdentifiers]);
DEFINE_IID!(IID_ITablePatternIdentifiers, 953222398, 3340, 16682, 191, 141, 81, 237, 230, 131, 186, 245);
RT_INTERFACE!{interface ITablePatternIdentifiers(ITablePatternIdentifiersVtbl): IInspectable(IInspectableVtbl) [IID_ITablePatternIdentifiers] {
    
}}
DEFINE_IID!(IID_ITablePatternIdentifiersStatics, 1963408677, 13001, 18691, 174, 207, 220, 53, 4, 203, 210, 68);
RT_INTERFACE!{static interface ITablePatternIdentifiersStatics(ITablePatternIdentifiersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ITablePatternIdentifiersStatics] {
    fn get_ColumnHeadersProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_RowHeadersProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_RowOrColumnMajorProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl ITablePatternIdentifiersStatics {
    #[inline] pub unsafe fn get_column_headers_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ColumnHeadersProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_row_headers_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RowHeadersProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_row_or_column_major_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RowOrColumnMajorProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class TablePatternIdentifiers: ITablePatternIdentifiers}
impl RtActivatable<ITablePatternIdentifiersStatics> for TablePatternIdentifiers {}
impl TablePatternIdentifiers {
    #[inline] pub fn get_column_headers_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<ITablePatternIdentifiersStatics>>::get_activation_factory().get_column_headers_property()
    }}
    #[inline] pub fn get_row_headers_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<ITablePatternIdentifiersStatics>>::get_activation_factory().get_row_headers_property()
    }}
    #[inline] pub fn get_row_or_column_major_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<ITablePatternIdentifiersStatics>>::get_activation_factory().get_row_or_column_major_property()
    }}
}
DEFINE_CLSID!(TablePatternIdentifiers(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,84,97,98,108,101,80,97,116,116,101,114,110,73,100,101,110,116,105,102,105,101,114,115,0]) [CLSID_TablePatternIdentifiers]);
DEFINE_IID!(IID_ITogglePatternIdentifiers, 2115575659, 13524, 19175, 131, 172, 41, 248, 136, 130, 217, 133);
RT_INTERFACE!{interface ITogglePatternIdentifiers(ITogglePatternIdentifiersVtbl): IInspectable(IInspectableVtbl) [IID_ITogglePatternIdentifiers] {
    
}}
DEFINE_IID!(IID_ITogglePatternIdentifiersStatics, 3354875204, 5285, 20271, 146, 252, 118, 5, 36, 222, 6, 234);
RT_INTERFACE!{static interface ITogglePatternIdentifiersStatics(ITogglePatternIdentifiersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ITogglePatternIdentifiersStatics] {
    fn get_ToggleStateProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl ITogglePatternIdentifiersStatics {
    #[inline] pub unsafe fn get_toggle_state_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ToggleStateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class TogglePatternIdentifiers: ITogglePatternIdentifiers}
impl RtActivatable<ITogglePatternIdentifiersStatics> for TogglePatternIdentifiers {}
impl TogglePatternIdentifiers {
    #[inline] pub fn get_toggle_state_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<ITogglePatternIdentifiersStatics>>::get_activation_factory().get_toggle_state_property()
    }}
}
DEFINE_CLSID!(TogglePatternIdentifiers(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,84,111,103,103,108,101,80,97,116,116,101,114,110,73,100,101,110,116,105,102,105,101,114,115,0]) [CLSID_TogglePatternIdentifiers]);
DEFINE_IID!(IID_ITransformPattern2Identifiers, 145399869, 56999, 16431, 128, 151, 154, 39, 131, 214, 14, 93);
RT_INTERFACE!{interface ITransformPattern2Identifiers(ITransformPattern2IdentifiersVtbl): IInspectable(IInspectableVtbl) [IID_ITransformPattern2Identifiers] {
    
}}
DEFINE_IID!(IID_ITransformPattern2IdentifiersStatics, 2023110212, 4592, 18044, 167, 43, 93, 172, 65, 193, 246, 254);
RT_INTERFACE!{static interface ITransformPattern2IdentifiersStatics(ITransformPattern2IdentifiersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ITransformPattern2IdentifiersStatics] {
    fn get_CanZoomProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_ZoomLevelProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_MaxZoomProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_MinZoomProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl ITransformPattern2IdentifiersStatics {
    #[inline] pub unsafe fn get_can_zoom_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CanZoomProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoom_level_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ZoomLevelProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_zoom_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxZoomProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_zoom_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MinZoomProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class TransformPattern2Identifiers: ITransformPattern2Identifiers}
impl RtActivatable<ITransformPattern2IdentifiersStatics> for TransformPattern2Identifiers {}
impl TransformPattern2Identifiers {
    #[inline] pub fn get_can_zoom_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<ITransformPattern2IdentifiersStatics>>::get_activation_factory().get_can_zoom_property()
    }}
    #[inline] pub fn get_zoom_level_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<ITransformPattern2IdentifiersStatics>>::get_activation_factory().get_zoom_level_property()
    }}
    #[inline] pub fn get_max_zoom_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<ITransformPattern2IdentifiersStatics>>::get_activation_factory().get_max_zoom_property()
    }}
    #[inline] pub fn get_min_zoom_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<ITransformPattern2IdentifiersStatics>>::get_activation_factory().get_min_zoom_property()
    }}
}
DEFINE_CLSID!(TransformPattern2Identifiers(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,84,114,97,110,115,102,111,114,109,80,97,116,116,101,114,110,50,73,100,101,110,116,105,102,105,101,114,115,0]) [CLSID_TransformPattern2Identifiers]);
DEFINE_IID!(IID_ITransformPatternIdentifiers, 3826342796, 50120, 18999, 185, 148, 39, 9, 167, 129, 22, 101);
RT_INTERFACE!{interface ITransformPatternIdentifiers(ITransformPatternIdentifiersVtbl): IInspectable(IInspectableVtbl) [IID_ITransformPatternIdentifiers] {
    
}}
DEFINE_IID!(IID_ITransformPatternIdentifiersStatics, 1165028779, 55045, 16580, 161, 220, 233, 172, 252, 239, 133, 246);
RT_INTERFACE!{static interface ITransformPatternIdentifiersStatics(ITransformPatternIdentifiersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ITransformPatternIdentifiersStatics] {
    fn get_CanMoveProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_CanResizeProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_CanRotateProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl ITransformPatternIdentifiersStatics {
    #[inline] pub unsafe fn get_can_move_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CanMoveProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_resize_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CanResizeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_rotate_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CanRotateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class TransformPatternIdentifiers: ITransformPatternIdentifiers}
impl RtActivatable<ITransformPatternIdentifiersStatics> for TransformPatternIdentifiers {}
impl TransformPatternIdentifiers {
    #[inline] pub fn get_can_move_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<ITransformPatternIdentifiersStatics>>::get_activation_factory().get_can_move_property()
    }}
    #[inline] pub fn get_can_resize_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<ITransformPatternIdentifiersStatics>>::get_activation_factory().get_can_resize_property()
    }}
    #[inline] pub fn get_can_rotate_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<ITransformPatternIdentifiersStatics>>::get_activation_factory().get_can_rotate_property()
    }}
}
DEFINE_CLSID!(TransformPatternIdentifiers(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,84,114,97,110,115,102,111,114,109,80,97,116,116,101,114,110,73,100,101,110,116,105,102,105,101,114,115,0]) [CLSID_TransformPatternIdentifiers]);
DEFINE_IID!(IID_IValuePatternIdentifiers, 1113323084, 21299, 20033, 180, 112, 43, 173, 20, 236, 208, 133);
RT_INTERFACE!{interface IValuePatternIdentifiers(IValuePatternIdentifiersVtbl): IInspectable(IInspectableVtbl) [IID_IValuePatternIdentifiers] {
    
}}
DEFINE_IID!(IID_IValuePatternIdentifiersStatics, 3259492599, 44492, 17423, 177, 35, 51, 120, 138, 64, 82, 90);
RT_INTERFACE!{static interface IValuePatternIdentifiersStatics(IValuePatternIdentifiersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IValuePatternIdentifiersStatics] {
    fn get_IsReadOnlyProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_ValueProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl IValuePatternIdentifiersStatics {
    #[inline] pub unsafe fn get_is_read_only_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsReadOnlyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_value_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ValueProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ValuePatternIdentifiers: IValuePatternIdentifiers}
impl RtActivatable<IValuePatternIdentifiersStatics> for ValuePatternIdentifiers {}
impl ValuePatternIdentifiers {
    #[inline] pub fn get_is_read_only_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IValuePatternIdentifiersStatics>>::get_activation_factory().get_is_read_only_property()
    }}
    #[inline] pub fn get_value_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IValuePatternIdentifiersStatics>>::get_activation_factory().get_value_property()
    }}
}
DEFINE_CLSID!(ValuePatternIdentifiers(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,86,97,108,117,101,80,97,116,116,101,114,110,73,100,101,110,116,105,102,105,101,114,115,0]) [CLSID_ValuePatternIdentifiers]);
DEFINE_IID!(IID_IWindowPatternIdentifiers, 972524468, 28722, 16866, 183, 158, 39, 183, 74, 134, 40, 222);
RT_INTERFACE!{interface IWindowPatternIdentifiers(IWindowPatternIdentifiersVtbl): IInspectable(IInspectableVtbl) [IID_IWindowPatternIdentifiers] {
    
}}
DEFINE_IID!(IID_IWindowPatternIdentifiersStatics, 131116294, 25346, 19753, 135, 139, 25, 218, 3, 252, 34, 141);
RT_INTERFACE!{static interface IWindowPatternIdentifiersStatics(IWindowPatternIdentifiersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IWindowPatternIdentifiersStatics] {
    fn get_CanMaximizeProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_CanMinimizeProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_IsModalProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_IsTopmostProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_WindowInteractionStateProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT,
    fn get_WindowVisualStateProperty(&self, out: *mut *mut AutomationProperty) -> HRESULT
}}
impl IWindowPatternIdentifiersStatics {
    #[inline] pub unsafe fn get_can_maximize_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CanMaximizeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_minimize_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CanMinimizeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_modal_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsModalProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_topmost_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsTopmostProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_window_interaction_state_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_WindowInteractionStateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_window_visual_state_property(&self) -> Result<ComPtr<AutomationProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_WindowVisualStateProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class WindowPatternIdentifiers: IWindowPatternIdentifiers}
impl RtActivatable<IWindowPatternIdentifiersStatics> for WindowPatternIdentifiers {}
impl WindowPatternIdentifiers {
    #[inline] pub fn get_can_maximize_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IWindowPatternIdentifiersStatics>>::get_activation_factory().get_can_maximize_property()
    }}
    #[inline] pub fn get_can_minimize_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IWindowPatternIdentifiersStatics>>::get_activation_factory().get_can_minimize_property()
    }}
    #[inline] pub fn get_is_modal_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IWindowPatternIdentifiersStatics>>::get_activation_factory().get_is_modal_property()
    }}
    #[inline] pub fn get_is_topmost_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IWindowPatternIdentifiersStatics>>::get_activation_factory().get_is_topmost_property()
    }}
    #[inline] pub fn get_window_interaction_state_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IWindowPatternIdentifiersStatics>>::get_activation_factory().get_window_interaction_state_property()
    }}
    #[inline] pub fn get_window_visual_state_property() -> Result<ComPtr<AutomationProperty>> { unsafe {
        <Self as RtActivatable<IWindowPatternIdentifiersStatics>>::get_activation_factory().get_window_visual_state_property()
    }}
}
DEFINE_CLSID!(WindowPatternIdentifiers(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,87,105,110,100,111,119,80,97,116,116,101,114,110,73,100,101,110,116,105,102,105,101,114,115,0]) [CLSID_WindowPatternIdentifiers]);
DEFINE_IID!(IID_IAutomationAnnotation, 4215025866, 984, 17944, 145, 191, 228, 216, 79, 74, 243, 24);
RT_INTERFACE!{interface IAutomationAnnotation(IAutomationAnnotationVtbl): IInspectable(IInspectableVtbl) [IID_IAutomationAnnotation] {
    fn get_Type(&self, out: *mut AnnotationType) -> HRESULT,
    fn put_Type(&self, value: AnnotationType) -> HRESULT,
    fn get_Element(&self, out: *mut *mut super::UIElement) -> HRESULT,
    fn put_Element(&self, value: *mut super::UIElement) -> HRESULT
}}
impl IAutomationAnnotation {
    #[inline] pub unsafe fn get_type(&self) -> Result<AnnotationType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Type)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_type(&self, value: AnnotationType) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Type)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_element(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Element)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_element(&self, value: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Element)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class AutomationAnnotation: IAutomationAnnotation}
impl RtActivatable<IAutomationAnnotationFactory> for AutomationAnnotation {}
impl RtActivatable<IAutomationAnnotationStatics> for AutomationAnnotation {}
impl RtActivatable<IActivationFactory> for AutomationAnnotation {}
impl AutomationAnnotation {
    #[inline] pub fn create_instance(type_: AnnotationType) -> Result<ComPtr<AutomationAnnotation>> { unsafe {
        <Self as RtActivatable<IAutomationAnnotationFactory>>::get_activation_factory().create_instance(type_)
    }}
    #[inline] pub fn create_with_element_parameter(type_: AnnotationType, element: &super::UIElement) -> Result<ComPtr<AutomationAnnotation>> { unsafe {
        <Self as RtActivatable<IAutomationAnnotationFactory>>::get_activation_factory().create_with_element_parameter(type_, element)
    }}
    #[inline] pub fn get_type_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationAnnotationStatics>>::get_activation_factory().get_type_property()
    }}
    #[inline] pub fn get_element_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationAnnotationStatics>>::get_activation_factory().get_element_property()
    }}
}
DEFINE_CLSID!(AutomationAnnotation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,65,117,116,111,109,97,116,105,111,110,65,110,110,111,116,97,116,105,111,110,0]) [CLSID_AutomationAnnotation]);
DEFINE_IID!(IID_IAutomationAnnotationStatics, 3842239159, 20197, 18635, 181, 184, 187, 205, 70, 201, 209, 218);
RT_INTERFACE!{static interface IAutomationAnnotationStatics(IAutomationAnnotationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAutomationAnnotationStatics] {
    fn get_TypeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ElementProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IAutomationAnnotationStatics {
    #[inline] pub unsafe fn get_type_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TypeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_element_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ElementProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationAnnotationFactory, 1225194066, 56768, 20073, 183, 107, 1, 157, 146, 141, 130, 47);
RT_INTERFACE!{static interface IAutomationAnnotationFactory(IAutomationAnnotationFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAutomationAnnotationFactory] {
    fn CreateInstance(&self, type_: AnnotationType, out: *mut *mut AutomationAnnotation) -> HRESULT,
    fn CreateWithElementParameter(&self, type_: AnnotationType, element: *mut super::UIElement, out: *mut *mut AutomationAnnotation) -> HRESULT
}}
impl IAutomationAnnotationFactory {
    #[inline] pub unsafe fn create_instance(&self, type_: AnnotationType) -> Result<ComPtr<AutomationAnnotation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, type_, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_with_element_parameter(&self, type_: AnnotationType, element: &super::UIElement) -> Result<ComPtr<AutomationAnnotation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithElementParameter)(self as *const _ as *mut _, type_, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum AutomationActiveEnd: i32 {
    None (AutomationActiveEnd_None) = 0, Start (AutomationActiveEnd_Start) = 1, End (AutomationActiveEnd_End) = 2,
}}
RT_ENUM! { enum AutomationAnimationStyle: i32 {
    None (AutomationAnimationStyle_None) = 0, LasVegasLights (AutomationAnimationStyle_LasVegasLights) = 1, BlinkingBackground (AutomationAnimationStyle_BlinkingBackground) = 2, SparkleText (AutomationAnimationStyle_SparkleText) = 3, MarchingBlackAnts (AutomationAnimationStyle_MarchingBlackAnts) = 4, MarchingRedAnts (AutomationAnimationStyle_MarchingRedAnts) = 5, Shimmer (AutomationAnimationStyle_Shimmer) = 6, Other (AutomationAnimationStyle_Other) = 7,
}}
RT_ENUM! { enum AutomationBulletStyle: i32 {
    None (AutomationBulletStyle_None) = 0, HollowRoundBullet (AutomationBulletStyle_HollowRoundBullet) = 1, FilledRoundBullet (AutomationBulletStyle_FilledRoundBullet) = 2, HollowSquareBullet (AutomationBulletStyle_HollowSquareBullet) = 3, FilledSquareBullet (AutomationBulletStyle_FilledSquareBullet) = 4, DashBullet (AutomationBulletStyle_DashBullet) = 5, Other (AutomationBulletStyle_Other) = 6,
}}
RT_ENUM! { enum AutomationCaretBidiMode: i32 {
    LTR (AutomationCaretBidiMode_LTR) = 0, RTL (AutomationCaretBidiMode_RTL) = 1,
}}
RT_ENUM! { enum AutomationCaretPosition: i32 {
    Unknown (AutomationCaretPosition_Unknown) = 0, EndOfLine (AutomationCaretPosition_EndOfLine) = 1, BeginningOfLine (AutomationCaretPosition_BeginningOfLine) = 2,
}}
RT_ENUM! { enum AutomationFlowDirections: i32 {
    Default (AutomationFlowDirections_Default) = 0, RightToLeft (AutomationFlowDirections_RightToLeft) = 1, BottomToTop (AutomationFlowDirections_BottomToTop) = 2, Vertical (AutomationFlowDirections_Vertical) = 3,
}}
RT_ENUM! { enum AutomationOutlineStyles: i32 {
    None (AutomationOutlineStyles_None) = 0, Outline (AutomationOutlineStyles_Outline) = 1, Shadow (AutomationOutlineStyles_Shadow) = 2, Engraved (AutomationOutlineStyles_Engraved) = 3, Embossed (AutomationOutlineStyles_Embossed) = 4,
}}
RT_ENUM! { enum AutomationStyleId: i32 {
    Heading1 (AutomationStyleId_Heading1) = 70001, Heading2 (AutomationStyleId_Heading2) = 70002, Heading3 (AutomationStyleId_Heading3) = 70003, Heading4 (AutomationStyleId_Heading4) = 70004, Heading5 (AutomationStyleId_Heading5) = 70005, Heading6 (AutomationStyleId_Heading6) = 70006, Heading7 (AutomationStyleId_Heading7) = 70007, Heading8 (AutomationStyleId_Heading8) = 70008, Heading9 (AutomationStyleId_Heading9) = 70009, Title (AutomationStyleId_Title) = 70010, Subtitle (AutomationStyleId_Subtitle) = 70011, Normal (AutomationStyleId_Normal) = 70012, Emphasis (AutomationStyleId_Emphasis) = 70013, Quote (AutomationStyleId_Quote) = 70014, BulletedList (AutomationStyleId_BulletedList) = 70015,
}}
RT_ENUM! { enum AutomationTextDecorationLineStyle: i32 {
    None (AutomationTextDecorationLineStyle_None) = 0, Single (AutomationTextDecorationLineStyle_Single) = 1, WordsOnly (AutomationTextDecorationLineStyle_WordsOnly) = 2, Double (AutomationTextDecorationLineStyle_Double) = 3, Dot (AutomationTextDecorationLineStyle_Dot) = 4, Dash (AutomationTextDecorationLineStyle_Dash) = 5, DashDot (AutomationTextDecorationLineStyle_DashDot) = 6, DashDotDot (AutomationTextDecorationLineStyle_DashDotDot) = 7, Wavy (AutomationTextDecorationLineStyle_Wavy) = 8, ThickSingle (AutomationTextDecorationLineStyle_ThickSingle) = 9, DoubleWavy (AutomationTextDecorationLineStyle_DoubleWavy) = 10, ThickWavy (AutomationTextDecorationLineStyle_ThickWavy) = 11, LongDash (AutomationTextDecorationLineStyle_LongDash) = 12, ThickDash (AutomationTextDecorationLineStyle_ThickDash) = 13, ThickDashDot (AutomationTextDecorationLineStyle_ThickDashDot) = 14, ThickDashDotDot (AutomationTextDecorationLineStyle_ThickDashDotDot) = 15, ThickDot (AutomationTextDecorationLineStyle_ThickDot) = 16, ThickLongDash (AutomationTextDecorationLineStyle_ThickLongDash) = 17, Other (AutomationTextDecorationLineStyle_Other) = 18,
}}
pub mod peers { // Windows.UI.Xaml.Automation.Peers
use ::prelude::*;
DEFINE_IID!(IID_IItemAutomationPeer, 2503750902, 15153, 18343, 179, 191, 37, 211, 174, 153, 195, 23);
RT_INTERFACE!{interface IItemAutomationPeer(IItemAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IItemAutomationPeer] {
    fn get_Item(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn get_ItemsControlAutomationPeer(&self, out: *mut *mut ItemsControlAutomationPeer) -> HRESULT
}}
impl IItemAutomationPeer {
    #[inline] pub unsafe fn get_item(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Item)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_items_control_automation_peer(&self) -> Result<ComPtr<ItemsControlAutomationPeer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemsControlAutomationPeer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemAutomationPeerFactory, 688279667, 56893, 19775, 151, 180, 77, 111, 157, 83, 68, 77);
RT_INTERFACE!{interface IItemAutomationPeerFactory(IItemAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IItemAutomationPeerFactory] {
    fn CreateInstanceWithParentAndItem(&self, item: *mut IInspectable, parent: *mut ItemsControlAutomationPeer, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ItemAutomationPeer) -> HRESULT
}}
impl IItemAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_parent_and_item(&self, item: &IInspectable, parent: &ItemsControlAutomationPeer, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ItemAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithParentAndItem)(self as *const _ as *mut _, item as *const _ as *mut _, parent as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IButtonBaseAutomationPeer, 2767435190, 30085, 19979, 150, 210, 8, 207, 111, 40, 190, 250);
RT_INTERFACE!{interface IButtonBaseAutomationPeer(IButtonBaseAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IButtonBaseAutomationPeer] {
    
}}
DEFINE_IID!(IID_IButtonBaseAutomationPeerFactory, 2315520286, 59058, 19552, 167, 89, 193, 60, 164, 81, 101, 237);
RT_INTERFACE!{interface IButtonBaseAutomationPeerFactory(IButtonBaseAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IButtonBaseAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::primitives::ButtonBase, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ButtonBaseAutomationPeer) -> HRESULT
}}
impl IButtonBaseAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::primitives::ButtonBase, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ButtonBaseAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICaptureElementAutomationPeer, 3703852768, 64069, 17862, 139, 183, 50, 13, 128, 143, 89, 88);
RT_INTERFACE!{interface ICaptureElementAutomationPeer(ICaptureElementAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_ICaptureElementAutomationPeer] {
    
}}
DEFINE_IID!(IID_ICaptureElementAutomationPeerFactory, 2610097992, 34281, 18537, 177, 117, 143, 124, 244, 90, 109, 159);
RT_INTERFACE!{interface ICaptureElementAutomationPeerFactory(ICaptureElementAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICaptureElementAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::CaptureElement, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut CaptureElementAutomationPeer) -> HRESULT
}}
impl ICaptureElementAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::CaptureElement, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<CaptureElementAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IComboBoxItemAutomationPeer, 316524398, 38226, 17514, 130, 238, 147, 140, 195, 113, 128, 15);
RT_INTERFACE!{interface IComboBoxItemAutomationPeer(IComboBoxItemAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IComboBoxItemAutomationPeer] {
    
}}
DEFINE_IID!(IID_IComboBoxItemAutomationPeerFactory, 323667964, 14714, 16447, 166, 236, 28, 232, 190, 218, 21, 229);
RT_INTERFACE!{interface IComboBoxItemAutomationPeerFactory(IComboBoxItemAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IComboBoxItemAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::ComboBoxItem, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ComboBoxItemAutomationPeer) -> HRESULT
}}
impl IComboBoxItemAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::ComboBoxItem, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ComboBoxItemAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFlipViewItemAutomationPeer, 3358602462, 64008, 19411, 174, 178, 210, 229, 191, 160, 77, 249);
RT_INTERFACE!{interface IFlipViewItemAutomationPeer(IFlipViewItemAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IFlipViewItemAutomationPeer] {
    
}}
DEFINE_IID!(IID_IFlipViewItemAutomationPeerFactory, 1762693974, 53477, 19472, 160, 156, 173, 11, 241, 176, 203, 1);
RT_INTERFACE!{interface IFlipViewItemAutomationPeerFactory(IFlipViewItemAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IFlipViewItemAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::FlipViewItem, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut FlipViewItemAutomationPeer) -> HRESULT
}}
impl IFlipViewItemAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::FlipViewItem, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<FlipViewItemAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGroupItemAutomationPeer, 420806253, 1856, 16950, 158, 225, 56, 207, 25, 193, 195, 136);
RT_INTERFACE!{interface IGroupItemAutomationPeer(IGroupItemAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IGroupItemAutomationPeer] {
    
}}
DEFINE_IID!(IID_IGroupItemAutomationPeerFactory, 1453737319, 61980, 19600, 179, 121, 21, 162, 124, 127, 132, 9);
RT_INTERFACE!{interface IGroupItemAutomationPeerFactory(IGroupItemAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGroupItemAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::GroupItem, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut GroupItemAutomationPeer) -> HRESULT
}}
impl IGroupItemAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::GroupItem, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<GroupItemAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IImageAutomationPeer, 2601238412, 24738, 18623, 171, 44, 26, 82, 164, 81, 210, 212);
RT_INTERFACE!{interface IImageAutomationPeer(IImageAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IImageAutomationPeer] {
    
}}
DEFINE_IID!(IID_IImageAutomationPeerFactory, 2419081219, 26749, 18367, 179, 162, 75, 171, 202, 216, 239, 80);
RT_INTERFACE!{interface IImageAutomationPeerFactory(IImageAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IImageAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::Image, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ImageAutomationPeer) -> HRESULT
}}
impl IImageAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::Image, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ImageAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemsControlAutomationPeer, 2531748849, 14327, 16520, 146, 93, 101, 38, 142, 131, 227, 77);
RT_INTERFACE!{interface IItemsControlAutomationPeer(IItemsControlAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IItemsControlAutomationPeer] {
    
}}
DEFINE_IID!(IID_IItemsControlAutomationPeerFactory, 1077453401, 11802, 18890, 165, 51, 198, 79, 24, 21, 119, 230);
RT_INTERFACE!{interface IItemsControlAutomationPeerFactory(IItemsControlAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IItemsControlAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::ItemsControl, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ItemsControlAutomationPeer) -> HRESULT
}}
impl IItemsControlAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::ItemsControl, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ItemsControlAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemsControlAutomationPeer2, 3297610007, 38312, 18360, 165, 23, 191, 137, 26, 108, 3, 155);
RT_INTERFACE!{interface IItemsControlAutomationPeer2(IItemsControlAutomationPeer2Vtbl): IInspectable(IInspectableVtbl) [IID_IItemsControlAutomationPeer2] {
    fn CreateItemAutomationPeer(&self, item: *mut IInspectable, out: *mut *mut ItemAutomationPeer) -> HRESULT
}}
impl IItemsControlAutomationPeer2 {
    #[inline] pub unsafe fn create_item_automation_peer(&self, item: &IInspectable) -> Result<ComPtr<ItemAutomationPeer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateItemAutomationPeer)(self as *const _ as *mut _, item as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemsControlAutomationPeerOverrides2, 907919592, 46447, 17897, 128, 254, 16, 160, 251, 15, 225, 119);
RT_INTERFACE!{interface IItemsControlAutomationPeerOverrides2(IItemsControlAutomationPeerOverrides2Vtbl): IInspectable(IInspectableVtbl) [IID_IItemsControlAutomationPeerOverrides2] {
    fn OnCreateItemAutomationPeer(&self, item: *mut IInspectable, out: *mut *mut ItemAutomationPeer) -> HRESULT
}}
impl IItemsControlAutomationPeerOverrides2 {
    #[inline] pub unsafe fn on_create_item_automation_peer(&self, item: &IInspectable) -> Result<ComPtr<ItemAutomationPeer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).OnCreateItemAutomationPeer)(self as *const _ as *mut _, item as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListBoxItemAutomationPeer, 466018758, 10647, 17119, 153, 235, 146, 188, 29, 209, 73, 251);
RT_INTERFACE!{interface IListBoxItemAutomationPeer(IListBoxItemAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IListBoxItemAutomationPeer] {
    
}}
DEFINE_IID!(IID_IListBoxItemAutomationPeerFactory, 1352637912, 45226, 17471, 161, 16, 65, 32, 154, 244, 79, 28);
RT_INTERFACE!{interface IListBoxItemAutomationPeerFactory(IListBoxItemAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IListBoxItemAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::ListBoxItem, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ListBoxItemAutomationPeer) -> HRESULT
}}
impl IListBoxItemAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::ListBoxItem, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ListBoxItemAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMediaTransportControlsAutomationPeer, 2746060179, 31224, 18776, 163, 200, 152, 13, 239, 184, 61, 21);
RT_INTERFACE!{interface IMediaTransportControlsAutomationPeer(IMediaTransportControlsAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IMediaTransportControlsAutomationPeer] {
    
}}
DEFINE_IID!(IID_IMediaTransportControlsAutomationPeerFactory, 4095520771, 57603, 19120, 129, 42, 160, 143, 189, 181, 112, 206);
RT_INTERFACE!{interface IMediaTransportControlsAutomationPeerFactory(IMediaTransportControlsAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMediaTransportControlsAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::MediaTransportControls, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut MediaTransportControlsAutomationPeer) -> HRESULT
}}
impl IMediaTransportControlsAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::MediaTransportControls, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<MediaTransportControlsAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPasswordBoxAutomationPeer, 1750009438, 15859, 19359, 130, 173, 136, 25, 219, 59, 33, 138);
RT_INTERFACE!{interface IPasswordBoxAutomationPeer(IPasswordBoxAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IPasswordBoxAutomationPeer] {
    
}}
DEFINE_IID!(IID_IPasswordBoxAutomationPeerFactory, 2889711326, 56484, 18460, 181, 32, 74, 155, 63, 59, 23, 156);
RT_INTERFACE!{interface IPasswordBoxAutomationPeerFactory(IPasswordBoxAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPasswordBoxAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::PasswordBox, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut PasswordBoxAutomationPeer) -> HRESULT
}}
impl IPasswordBoxAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::PasswordBox, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<PasswordBoxAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IProgressRingAutomationPeer, 3157286638, 14803, 20203, 172, 51, 35, 148, 222, 18, 62, 46);
RT_INTERFACE!{interface IProgressRingAutomationPeer(IProgressRingAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IProgressRingAutomationPeer] {
    
}}
DEFINE_IID!(IID_IProgressRingAutomationPeerFactory, 4091224139, 5502, 16572, 149, 147, 85, 188, 92, 113, 164, 246);
RT_INTERFACE!{interface IProgressRingAutomationPeerFactory(IProgressRingAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IProgressRingAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::ProgressRing, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ProgressRingAutomationPeer) -> HRESULT
}}
impl IProgressRingAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::ProgressRing, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ProgressRingAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRangeBaseAutomationPeer, 3830756681, 19244, 17069, 176, 75, 211, 89, 71, 209, 238, 80);
RT_INTERFACE!{interface IRangeBaseAutomationPeer(IRangeBaseAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IRangeBaseAutomationPeer] {
    
}}
DEFINE_IID!(IID_IRangeBaseAutomationPeerFactory, 2189194753, 12408, 17529, 149, 234, 145, 55, 76, 160, 98, 7);
RT_INTERFACE!{interface IRangeBaseAutomationPeerFactory(IRangeBaseAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IRangeBaseAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::primitives::RangeBase, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut RangeBaseAutomationPeer) -> HRESULT
}}
impl IRangeBaseAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::primitives::RangeBase, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<RangeBaseAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichTextBlockAutomationPeer, 2476743324, 38409, 16890, 130, 243, 144, 156, 9, 244, 154, 114);
RT_INTERFACE!{interface IRichTextBlockAutomationPeer(IRichTextBlockAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IRichTextBlockAutomationPeer] {
    
}}
DEFINE_IID!(IID_IRichTextBlockAutomationPeerFactory, 540585569, 5001, 18042, 174, 214, 55, 51, 77, 169, 98, 43);
RT_INTERFACE!{interface IRichTextBlockAutomationPeerFactory(IRichTextBlockAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IRichTextBlockAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::RichTextBlock, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut RichTextBlockAutomationPeer) -> HRESULT
}}
impl IRichTextBlockAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::RichTextBlock, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<RichTextBlockAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichTextBlockOverflowAutomationPeer, 2358919322, 10038, 17275, 171, 54, 161, 106, 32, 47, 16, 93);
RT_INTERFACE!{interface IRichTextBlockOverflowAutomationPeer(IRichTextBlockOverflowAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IRichTextBlockOverflowAutomationPeer] {
    
}}
DEFINE_IID!(IID_IRichTextBlockOverflowAutomationPeerFactory, 3177100899, 11284, 18021, 173, 239, 242, 176, 51, 148, 123, 235);
RT_INTERFACE!{interface IRichTextBlockOverflowAutomationPeerFactory(IRichTextBlockOverflowAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IRichTextBlockOverflowAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::RichTextBlockOverflow, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut RichTextBlockOverflowAutomationPeer) -> HRESULT
}}
impl IRichTextBlockOverflowAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::RichTextBlockOverflow, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<RichTextBlockOverflowAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISelectorItemAutomationPeer, 2928358519, 34314, 17851, 191, 124, 225, 178, 116, 25, 209, 221);
RT_INTERFACE!{interface ISelectorItemAutomationPeer(ISelectorItemAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_ISelectorItemAutomationPeer] {
    
}}
DEFINE_IID!(IID_ISelectorItemAutomationPeerFactory, 1725427195, 30829, 17250, 169, 100, 235, 251, 33, 119, 108, 48);
RT_INTERFACE!{interface ISelectorItemAutomationPeerFactory(ISelectorItemAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISelectorItemAutomationPeerFactory] {
    fn CreateInstanceWithParentAndItem(&self, item: *mut IInspectable, parent: *mut SelectorAutomationPeer, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut SelectorItemAutomationPeer) -> HRESULT
}}
impl ISelectorItemAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_parent_and_item(&self, item: &IInspectable, parent: &SelectorAutomationPeer, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<SelectorItemAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithParentAndItem)(self as *const _ as *mut _, item as *const _ as *mut _, parent as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISemanticZoomAutomationPeer, 1009757292, 43383, 18428, 180, 78, 39, 84, 192, 178, 190, 169);
RT_INTERFACE!{interface ISemanticZoomAutomationPeer(ISemanticZoomAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_ISemanticZoomAutomationPeer] {
    
}}
DEFINE_IID!(IID_ISemanticZoomAutomationPeerFactory, 4112045133, 42131, 17558, 176, 119, 150, 116, 199, 244, 197, 250);
RT_INTERFACE!{interface ISemanticZoomAutomationPeerFactory(ISemanticZoomAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISemanticZoomAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::SemanticZoom, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut SemanticZoomAutomationPeer) -> HRESULT
}}
impl ISemanticZoomAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::SemanticZoom, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<SemanticZoomAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISettingsFlyoutAutomationPeer, 3504213211, 12495, 18342, 165, 235, 156, 119, 240, 176, 214, 221);
RT_INTERFACE!{interface ISettingsFlyoutAutomationPeer(ISettingsFlyoutAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_ISettingsFlyoutAutomationPeer] {
    
}}
DEFINE_IID!(IID_ISettingsFlyoutAutomationPeerFactory, 4182205117, 35348, 16612, 148, 167, 63, 51, 201, 34, 233, 69);
RT_INTERFACE!{interface ISettingsFlyoutAutomationPeerFactory(ISettingsFlyoutAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISettingsFlyoutAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::SettingsFlyout, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut SettingsFlyoutAutomationPeer) -> HRESULT
}}
impl ISettingsFlyoutAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::SettingsFlyout, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<SettingsFlyoutAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextBlockAutomationPeer, 3189790709, 26389, 20073, 160, 80, 146, 189, 12, 226, 50, 169);
RT_INTERFACE!{interface ITextBlockAutomationPeer(ITextBlockAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_ITextBlockAutomationPeer] {
    
}}
DEFINE_IID!(IID_ITextBlockAutomationPeerFactory, 1992266315, 31904, 19201, 188, 92, 168, 207, 77, 54, 145, 222);
RT_INTERFACE!{interface ITextBlockAutomationPeerFactory(ITextBlockAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ITextBlockAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::TextBlock, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut TextBlockAutomationPeer) -> HRESULT
}}
impl ITextBlockAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::TextBlock, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<TextBlockAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextBoxAutomationPeer, 978263200, 24157, 19750, 144, 103, 231, 64, 191, 101, 122, 159);
RT_INTERFACE!{interface ITextBoxAutomationPeer(ITextBoxAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_ITextBoxAutomationPeer] {
    
}}
DEFINE_IID!(IID_ITextBoxAutomationPeerFactory, 32555111, 38507, 16688, 184, 114, 70, 158, 66, 189, 74, 127);
RT_INTERFACE!{interface ITextBoxAutomationPeerFactory(ITextBoxAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ITextBoxAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::TextBox, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut TextBoxAutomationPeer) -> HRESULT
}}
impl ITextBoxAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::TextBox, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<TextBoxAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IThumbAutomationPeer, 3693693365, 46174, 19821, 137, 47, 217, 66, 44, 149, 14, 251);
RT_INTERFACE!{interface IThumbAutomationPeer(IThumbAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IThumbAutomationPeer] {
    
}}
DEFINE_IID!(IID_IThumbAutomationPeerFactory, 2533835775, 44865, 17920, 181, 93, 38, 212, 61, 248, 96, 225);
RT_INTERFACE!{interface IThumbAutomationPeerFactory(IThumbAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IThumbAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::primitives::Thumb, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ThumbAutomationPeer) -> HRESULT
}}
impl IThumbAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::primitives::Thumb, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ThumbAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IToggleSwitchAutomationPeer, 3222401396, 59550, 18320, 191, 154, 120, 235, 181, 245, 158, 159);
RT_INTERFACE!{interface IToggleSwitchAutomationPeer(IToggleSwitchAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IToggleSwitchAutomationPeer] {
    
}}
DEFINE_IID!(IID_IToggleSwitchAutomationPeerFactory, 838415331, 65272, 17433, 157, 245, 217, 239, 113, 150, 234, 52);
RT_INTERFACE!{interface IToggleSwitchAutomationPeerFactory(IToggleSwitchAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IToggleSwitchAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::ToggleSwitch, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ToggleSwitchAutomationPeer) -> HRESULT
}}
impl IToggleSwitchAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::ToggleSwitch, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ToggleSwitchAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IButtonAutomationPeer, 4218941374, 14828, 17672, 138, 195, 81, 161, 66, 64, 39, 215);
RT_INTERFACE!{interface IButtonAutomationPeer(IButtonAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IButtonAutomationPeer] {
    
}}
DEFINE_IID!(IID_IButtonAutomationPeerFactory, 1071357769, 62635, 18304, 134, 68, 3, 55, 98, 153, 161, 117);
RT_INTERFACE!{interface IButtonAutomationPeerFactory(IButtonAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IButtonAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::Button, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ButtonAutomationPeer) -> HRESULT
}}
impl IButtonAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::Button, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ButtonAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IComboBoxItemDataAutomationPeer, 1341091314, 10396, 19460, 131, 27, 90, 102, 140, 109, 113, 4);
RT_INTERFACE!{interface IComboBoxItemDataAutomationPeer(IComboBoxItemDataAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IComboBoxItemDataAutomationPeer] {
    
}}
DEFINE_IID!(IID_IComboBoxItemDataAutomationPeerFactory, 346608886, 18074, 16826, 157, 147, 68, 161, 165, 93, 168, 114);
RT_INTERFACE!{interface IComboBoxItemDataAutomationPeerFactory(IComboBoxItemDataAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IComboBoxItemDataAutomationPeerFactory] {
    fn CreateInstanceWithParentAndItem(&self, item: *mut IInspectable, parent: *mut ComboBoxAutomationPeer, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ComboBoxItemDataAutomationPeer) -> HRESULT
}}
impl IComboBoxItemDataAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_parent_and_item(&self, item: &IInspectable, parent: &ComboBoxAutomationPeer, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ComboBoxItemDataAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithParentAndItem)(self as *const _ as *mut _, item as *const _ as *mut _, parent as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFlipViewItemDataAutomationPeer, 2962776437, 188, 16664, 138, 111, 22, 238, 156, 21, 217, 104);
RT_INTERFACE!{interface IFlipViewItemDataAutomationPeer(IFlipViewItemDataAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IFlipViewItemDataAutomationPeer] {
    
}}
DEFINE_IID!(IID_IFlipViewItemDataAutomationPeerFactory, 1015432083, 2794, 20088, 188, 17, 183, 117, 202, 196, 17, 76);
RT_INTERFACE!{interface IFlipViewItemDataAutomationPeerFactory(IFlipViewItemDataAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IFlipViewItemDataAutomationPeerFactory] {
    fn CreateInstanceWithParentAndItem(&self, item: *mut IInspectable, parent: *mut FlipViewAutomationPeer, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut FlipViewItemDataAutomationPeer) -> HRESULT
}}
impl IFlipViewItemDataAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_parent_and_item(&self, item: &IInspectable, parent: &FlipViewAutomationPeer, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<FlipViewItemDataAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithParentAndItem)(self as *const _ as *mut _, item as *const _ as *mut _, parent as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IHyperlinkButtonAutomationPeer, 2860186801, 3807, 18137, 170, 158, 14, 178, 29, 20, 0, 151);
RT_INTERFACE!{interface IHyperlinkButtonAutomationPeer(IHyperlinkButtonAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IHyperlinkButtonAutomationPeer] {
    
}}
DEFINE_IID!(IID_IHyperlinkButtonAutomationPeerFactory, 1505498721, 49538, 18863, 149, 38, 68, 184, 142, 98, 132, 85);
RT_INTERFACE!{interface IHyperlinkButtonAutomationPeerFactory(IHyperlinkButtonAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IHyperlinkButtonAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::HyperlinkButton, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut HyperlinkButtonAutomationPeer) -> HRESULT
}}
impl IHyperlinkButtonAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::HyperlinkButton, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<HyperlinkButtonAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListBoxItemDataAutomationPeer, 4252852206, 64992, 18474, 128, 132, 220, 235, 186, 91, 152, 6);
RT_INTERFACE!{interface IListBoxItemDataAutomationPeer(IListBoxItemDataAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IListBoxItemDataAutomationPeer] {
    
}}
DEFINE_IID!(IID_IListBoxItemDataAutomationPeerFactory, 3616689686, 48525, 18018, 169, 149, 32, 255, 154, 5, 96, 147);
RT_INTERFACE!{interface IListBoxItemDataAutomationPeerFactory(IListBoxItemDataAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IListBoxItemDataAutomationPeerFactory] {
    fn CreateInstanceWithParentAndItem(&self, item: *mut IInspectable, parent: *mut ListBoxAutomationPeer, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ListBoxItemDataAutomationPeer) -> HRESULT
}}
impl IListBoxItemDataAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_parent_and_item(&self, item: &IInspectable, parent: &ListBoxAutomationPeer, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ListBoxItemDataAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithParentAndItem)(self as *const _ as *mut _, item as *const _ as *mut _, parent as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IProgressBarAutomationPeer, 2482278278, 55360, 20406, 172, 47, 95, 119, 155, 133, 75, 13);
RT_INTERFACE!{interface IProgressBarAutomationPeer(IProgressBarAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IProgressBarAutomationPeer] {
    
}}
DEFINE_IID!(IID_IProgressBarAutomationPeerFactory, 910588331, 47119, 16820, 142, 234, 47, 82, 81, 188, 115, 156);
RT_INTERFACE!{interface IProgressBarAutomationPeerFactory(IProgressBarAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IProgressBarAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::ProgressBar, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ProgressBarAutomationPeer) -> HRESULT
}}
impl IProgressBarAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::ProgressBar, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ProgressBarAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRepeatButtonAutomationPeer, 702814933, 43180, 20106, 131, 216, 9, 227, 126, 5, 66, 87);
RT_INTERFACE!{interface IRepeatButtonAutomationPeer(IRepeatButtonAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IRepeatButtonAutomationPeer] {
    
}}
DEFINE_IID!(IID_IRepeatButtonAutomationPeerFactory, 1785723348, 22366, 20064, 189, 214, 236, 20, 65, 155, 79, 246);
RT_INTERFACE!{interface IRepeatButtonAutomationPeerFactory(IRepeatButtonAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IRepeatButtonAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::primitives::RepeatButton, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut RepeatButtonAutomationPeer) -> HRESULT
}}
impl IRepeatButtonAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::primitives::RepeatButton, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<RepeatButtonAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IScrollBarAutomationPeer, 1776337769, 48103, 16882, 135, 202, 170, 216, 19, 254, 85, 14);
RT_INTERFACE!{interface IScrollBarAutomationPeer(IScrollBarAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IScrollBarAutomationPeer] {
    
}}
DEFINE_IID!(IID_IScrollBarAutomationPeerFactory, 3778027792, 45035, 17813, 142, 61, 237, 192, 132, 74, 43, 33);
RT_INTERFACE!{interface IScrollBarAutomationPeerFactory(IScrollBarAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IScrollBarAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::primitives::ScrollBar, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ScrollBarAutomationPeer) -> HRESULT
}}
impl IScrollBarAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::primitives::ScrollBar, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ScrollBarAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISelectorAutomationPeer, 371902505, 28949, 17388, 179, 131, 167, 183, 22, 68, 6, 157);
RT_INTERFACE!{interface ISelectorAutomationPeer(ISelectorAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_ISelectorAutomationPeer] {
    
}}
DEFINE_IID!(IID_ISelectorAutomationPeerFactory, 2068993606, 33435, 19916, 189, 82, 90, 141, 3, 153, 56, 122);
RT_INTERFACE!{interface ISelectorAutomationPeerFactory(ISelectorAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISelectorAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::primitives::Selector, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut SelectorAutomationPeer) -> HRESULT
}}
impl ISelectorAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::primitives::Selector, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<SelectorAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISliderAutomationPeer, 3962569050, 54801, 18128, 174, 79, 110, 207, 39, 223, 186, 165);
RT_INTERFACE!{interface ISliderAutomationPeer(ISliderAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_ISliderAutomationPeer] {
    
}}
DEFINE_IID!(IID_ISliderAutomationPeerFactory, 2535161942, 39546, 19961, 149, 250, 111, 92, 4, 201, 28, 172);
RT_INTERFACE!{interface ISliderAutomationPeerFactory(ISliderAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISliderAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::Slider, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut SliderAutomationPeer) -> HRESULT
}}
impl ISliderAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::Slider, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<SliderAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IToggleButtonAutomationPeer, 1658578629, 48138, 17851, 191, 119, 234, 15, 21, 2, 137, 31);
RT_INTERFACE!{interface IToggleButtonAutomationPeer(IToggleButtonAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IToggleButtonAutomationPeer] {
    
}}
DEFINE_IID!(IID_IToggleButtonAutomationPeerFactory, 3374419140, 44363, 19715, 166, 164, 125, 89, 230, 54, 0, 4);
RT_INTERFACE!{interface IToggleButtonAutomationPeerFactory(IToggleButtonAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IToggleButtonAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::primitives::ToggleButton, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ToggleButtonAutomationPeer) -> HRESULT
}}
impl IToggleButtonAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::primitives::ToggleButton, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ToggleButtonAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICheckBoxAutomationPeer, 3944070210, 49321, 18118, 172, 36, 184, 61, 228, 41, 199, 51);
RT_INTERFACE!{interface ICheckBoxAutomationPeer(ICheckBoxAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_ICheckBoxAutomationPeer] {
    
}}
DEFINE_IID!(IID_ICheckBoxAutomationPeerFactory, 3076290397, 60303, 17647, 162, 124, 226, 106, 199, 222, 131, 51);
RT_INTERFACE!{interface ICheckBoxAutomationPeerFactory(ICheckBoxAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICheckBoxAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::CheckBox, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut CheckBoxAutomationPeer) -> HRESULT
}}
impl ICheckBoxAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::CheckBox, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<CheckBoxAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IComboBoxAutomationPeer, 2125729035, 30149, 16995, 186, 106, 212, 165, 79, 176, 242, 57);
RT_INTERFACE!{interface IComboBoxAutomationPeer(IComboBoxAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IComboBoxAutomationPeer] {
    
}}
DEFINE_IID!(IID_IComboBoxAutomationPeerFactory, 160324365, 7056, 16569, 155, 227, 178, 50, 103, 235, 19, 207);
RT_INTERFACE!{interface IComboBoxAutomationPeerFactory(IComboBoxAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IComboBoxAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::ComboBox, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ComboBoxAutomationPeer) -> HRESULT
}}
impl IComboBoxAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::ComboBox, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ComboBoxAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFlipViewAutomationPeer, 2394961210, 17028, 19200, 174, 248, 162, 104, 142, 165, 227, 196);
RT_INTERFACE!{interface IFlipViewAutomationPeer(IFlipViewAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IFlipViewAutomationPeer] {
    
}}
DEFINE_IID!(IID_IFlipViewAutomationPeerFactory, 1133882125, 36227, 18492, 136, 235, 226, 97, 123, 13, 41, 63);
RT_INTERFACE!{interface IFlipViewAutomationPeerFactory(IFlipViewAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IFlipViewAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::FlipView, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut FlipViewAutomationPeer) -> HRESULT
}}
impl IFlipViewAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::FlipView, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<FlipViewAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListBoxAutomationPeer, 2362496520, 46082, 19054, 189, 154, 52, 63, 136, 69, 235, 50);
RT_INTERFACE!{interface IListBoxAutomationPeer(IListBoxAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IListBoxAutomationPeer] {
    
}}
DEFINE_IID!(IID_IListBoxAutomationPeerFactory, 3795198341, 32246, 18935, 138, 188, 76, 51, 241, 163, 212, 110);
RT_INTERFACE!{interface IListBoxAutomationPeerFactory(IListBoxAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IListBoxAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::ListBox, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ListBoxAutomationPeer) -> HRESULT
}}
impl IListBoxAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::ListBox, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ListBoxAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRadioButtonAutomationPeer, 2120900312, 2864, 18243, 177, 2, 220, 223, 84, 142, 49, 49);
RT_INTERFACE!{interface IRadioButtonAutomationPeer(IRadioButtonAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IRadioButtonAutomationPeer] {
    
}}
DEFINE_IID!(IID_IRadioButtonAutomationPeerFactory, 1228981501, 15752, 18890, 143, 49, 146, 65, 135, 175, 11, 254);
RT_INTERFACE!{interface IRadioButtonAutomationPeerFactory(IRadioButtonAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IRadioButtonAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::RadioButton, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut RadioButtonAutomationPeer) -> HRESULT
}}
impl IRadioButtonAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::RadioButton, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<RadioButtonAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBarAutomationPeer, 2336935915, 35322, 20243, 132, 190, 53, 202, 91, 124, 149, 144);
RT_INTERFACE!{interface IAppBarAutomationPeer(IAppBarAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IAppBarAutomationPeer] {
    
}}
DEFINE_IID!(IID_IAppBarAutomationPeerFactory, 2204169442, 58262, 17687, 175, 93, 244, 207, 52, 197, 78, 223);
RT_INTERFACE!{interface IAppBarAutomationPeerFactory(IAppBarAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAppBarAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::AppBar, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut AppBarAutomationPeer) -> HRESULT
}}
impl IAppBarAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::AppBar, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<AppBarAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutoSuggestBoxAutomationPeer, 791855874, 63899, 18717, 151, 38, 165, 225, 129, 100, 62, 250);
RT_INTERFACE!{interface IAutoSuggestBoxAutomationPeer(IAutoSuggestBoxAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IAutoSuggestBoxAutomationPeer] {
    
}}
DEFINE_IID!(IID_IAutoSuggestBoxAutomationPeerFactory, 2147772489, 6375, 17525, 179, 98, 75, 189, 83, 210, 69, 98);
RT_INTERFACE!{static interface IAutoSuggestBoxAutomationPeerFactory(IAutoSuggestBoxAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAutoSuggestBoxAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::AutoSuggestBox, out: *mut *mut AutoSuggestBoxAutomationPeer) -> HRESULT
}}
impl IAutoSuggestBoxAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::AutoSuggestBox) -> Result<ComPtr<AutoSuggestBoxAutomationPeer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDatePickerAutomationPeer, 3497866623, 41145, 17884, 153, 26, 118, 197, 5, 231, 208, 245);
RT_INTERFACE!{interface IDatePickerAutomationPeer(IDatePickerAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IDatePickerAutomationPeer] {
    
}}
DEFINE_IID!(IID_IDatePickerAutomationPeerFactory, 3848699161, 37207, 17462, 159, 77, 127, 185, 145, 116, 180, 142);
RT_INTERFACE!{interface IDatePickerAutomationPeerFactory(IDatePickerAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IDatePickerAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::DatePicker, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut DatePickerAutomationPeer) -> HRESULT
}}
impl IDatePickerAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::DatePicker, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<DatePickerAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFlyoutPresenterAutomationPeer, 2685943988, 24522, 17775, 152, 234, 48, 14, 180, 11, 88, 94);
RT_INTERFACE!{interface IFlyoutPresenterAutomationPeer(IFlyoutPresenterAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IFlyoutPresenterAutomationPeer] {
    
}}
DEFINE_IID!(IID_IFlyoutPresenterAutomationPeerFactory, 4082111839, 35108, 17600, 186, 68, 101, 63, 231, 159, 30, 251);
RT_INTERFACE!{interface IFlyoutPresenterAutomationPeerFactory(IFlyoutPresenterAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IFlyoutPresenterAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::FlyoutPresenter, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut FlyoutPresenterAutomationPeer) -> HRESULT
}}
impl IFlyoutPresenterAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::FlyoutPresenter, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<FlyoutPresenterAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGridViewItemAutomationPeer, 2481925383, 13420, 16742, 164, 186, 188, 106, 24, 30, 127, 51);
RT_INTERFACE!{interface IGridViewItemAutomationPeer(IGridViewItemAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IGridViewItemAutomationPeer] {
    
}}
DEFINE_IID!(IID_IGridViewItemAutomationPeerFactory, 4211000182, 61998, 18029, 145, 60, 174, 36, 204, 219, 22, 15);
RT_INTERFACE!{interface IGridViewItemAutomationPeerFactory(IGridViewItemAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGridViewItemAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::GridViewItem, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut GridViewItemAutomationPeer) -> HRESULT
}}
impl IGridViewItemAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::GridViewItem, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<GridViewItemAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IHubAutomationPeer, 1306452054, 20156, 17952, 160, 93, 144, 62, 60, 154, 78, 173);
RT_INTERFACE!{interface IHubAutomationPeer(IHubAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IHubAutomationPeer] {
    
}}
DEFINE_IID!(IID_IHubAutomationPeerFactory, 3345142847, 31197, 17390, 135, 119, 141, 8, 179, 154, 160, 101);
RT_INTERFACE!{interface IHubAutomationPeerFactory(IHubAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IHubAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::Hub, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut HubAutomationPeer) -> HRESULT
}}
impl IHubAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::Hub, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<HubAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IHubSectionAutomationPeer, 383328247, 29745, 19842, 131, 206, 207, 163, 25, 43, 15, 24);
RT_INTERFACE!{interface IHubSectionAutomationPeer(IHubSectionAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IHubSectionAutomationPeer] {
    
}}
DEFINE_IID!(IID_IHubSectionAutomationPeerFactory, 3331205096, 6124, 17193, 145, 174, 45, 11, 35, 57, 212, 152);
RT_INTERFACE!{interface IHubSectionAutomationPeerFactory(IHubSectionAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IHubSectionAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::HubSection, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut HubSectionAutomationPeer) -> HRESULT
}}
impl IHubSectionAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::HubSection, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<HubSectionAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewBaseHeaderItemAutomationPeer, 2092480306, 49648, 19004, 188, 20, 133, 221, 72, 222, 219, 133);
RT_INTERFACE!{interface IListViewBaseHeaderItemAutomationPeer(IListViewBaseHeaderItemAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IListViewBaseHeaderItemAutomationPeer] {
    
}}
DEFINE_IID!(IID_IListViewBaseHeaderItemAutomationPeerFactory, 1089247583, 54833, 16388, 131, 46, 109, 134, 67, 229, 21, 97);
RT_INTERFACE!{interface IListViewBaseHeaderItemAutomationPeerFactory(IListViewBaseHeaderItemAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IListViewBaseHeaderItemAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::ListViewBaseHeaderItem, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ListViewBaseHeaderItemAutomationPeer) -> HRESULT
}}
impl IListViewBaseHeaderItemAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::ListViewBaseHeaderItem, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ListViewBaseHeaderItemAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewItemAutomationPeer, 3390131824, 41325, 19721, 161, 207, 24, 86, 239, 152, 169, 236);
RT_INTERFACE!{interface IListViewItemAutomationPeer(IListViewItemAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IListViewItemAutomationPeer] {
    
}}
DEFINE_IID!(IID_IListViewItemAutomationPeerFactory, 3296590784, 64204, 16420, 167, 59, 23, 236, 78, 102, 38, 84);
RT_INTERFACE!{interface IListViewItemAutomationPeerFactory(IListViewItemAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IListViewItemAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::ListViewItem, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ListViewItemAutomationPeer) -> HRESULT
}}
impl IListViewItemAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::ListViewItem, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ListViewItemAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMediaElementAutomationPeer, 3121323970, 42722, 16805, 177, 122, 209, 89, 70, 19, 239, 186);
RT_INTERFACE!{interface IMediaElementAutomationPeer(IMediaElementAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IMediaElementAutomationPeer] {
    
}}
DEFINE_IID!(IID_IMediaElementAutomationPeerFactory, 2997697320, 30069, 16755, 155, 199, 128, 54, 122, 22, 78, 210);
RT_INTERFACE!{interface IMediaElementAutomationPeerFactory(IMediaElementAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMediaElementAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::MediaElement, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut MediaElementAutomationPeer) -> HRESULT
}}
impl IMediaElementAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::MediaElement, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<MediaElementAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMediaPlayerElementAutomationPeer, 46060041, 16229, 20445, 181, 202, 196, 117, 13, 78, 110, 164);
RT_INTERFACE!{interface IMediaPlayerElementAutomationPeer(IMediaPlayerElementAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IMediaPlayerElementAutomationPeer] {
    
}}
DEFINE_IID!(IID_IMediaPlayerElementAutomationPeerFactory, 142901367, 33455, 19737, 177, 112, 40, 42, 158, 14, 127, 55);
RT_INTERFACE!{interface IMediaPlayerElementAutomationPeerFactory(IMediaPlayerElementAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMediaPlayerElementAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::MediaPlayerElement, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut MediaPlayerElementAutomationPeer) -> HRESULT
}}
impl IMediaPlayerElementAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::MediaPlayerElement, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<MediaPlayerElementAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMenuFlyoutItemAutomationPeer, 532780130, 8671, 17774, 170, 17, 143, 172, 107, 75, 42, 246);
RT_INTERFACE!{interface IMenuFlyoutItemAutomationPeer(IMenuFlyoutItemAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutItemAutomationPeer] {
    
}}
DEFINE_IID!(IID_IMenuFlyoutItemAutomationPeerFactory, 3498835128, 8401, 17880, 162, 194, 47, 19, 13, 247, 20, 224);
RT_INTERFACE!{interface IMenuFlyoutItemAutomationPeerFactory(IMenuFlyoutItemAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutItemAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::MenuFlyoutItem, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut MenuFlyoutItemAutomationPeer) -> HRESULT
}}
impl IMenuFlyoutItemAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::MenuFlyoutItem, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<MenuFlyoutItemAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRichEditBoxAutomationPeer, 3332332548, 5870, 18042, 168, 51, 195, 218, 132, 88, 173, 100);
RT_INTERFACE!{interface IRichEditBoxAutomationPeer(IRichEditBoxAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IRichEditBoxAutomationPeer] {
    
}}
DEFINE_IID!(IID_IRichEditBoxAutomationPeerFactory, 1965851545, 53910, 19847, 144, 32, 164, 117, 14, 136, 91, 60);
RT_INTERFACE!{interface IRichEditBoxAutomationPeerFactory(IRichEditBoxAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IRichEditBoxAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::RichEditBox, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut RichEditBoxAutomationPeer) -> HRESULT
}}
impl IRichEditBoxAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::RichEditBox, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<RichEditBoxAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IScrollViewerAutomationPeer, 3649434201, 6921, 20104, 136, 253, 66, 23, 80, 220, 107, 69);
RT_INTERFACE!{interface IScrollViewerAutomationPeer(IScrollViewerAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IScrollViewerAutomationPeer] {
    
}}
DEFINE_IID!(IID_IScrollViewerAutomationPeerFactory, 655228797, 55661, 18681, 163, 106, 194, 82, 170, 156, 70, 112);
RT_INTERFACE!{interface IScrollViewerAutomationPeerFactory(IScrollViewerAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IScrollViewerAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::ScrollViewer, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ScrollViewerAutomationPeer) -> HRESULT
}}
impl IScrollViewerAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::ScrollViewer, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ScrollViewerAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISearchBoxAutomationPeer, 2235568548, 6310, 20272, 147, 155, 136, 113, 175, 163, 245, 233);
RT_INTERFACE!{interface ISearchBoxAutomationPeer(ISearchBoxAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_ISearchBoxAutomationPeer] {
    
}}
DEFINE_IID!(IID_ISearchBoxAutomationPeerFactory, 3015709744, 32682, 16827, 142, 145, 124, 118, 28, 82, 103, 241);
RT_INTERFACE!{interface ISearchBoxAutomationPeerFactory(ISearchBoxAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISearchBoxAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::SearchBox, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut SearchBoxAutomationPeer) -> HRESULT
}}
impl ISearchBoxAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::SearchBox, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<SearchBoxAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITimePickerAutomationPeer, 2755478767, 12933, 19959, 180, 164, 228, 205, 243, 106, 58, 23);
RT_INTERFACE!{interface ITimePickerAutomationPeer(ITimePickerAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_ITimePickerAutomationPeer] {
    
}}
DEFINE_IID!(IID_ITimePickerAutomationPeerFactory, 2542757489, 18424, 16551, 158, 33, 104, 18, 139, 22, 180, 253);
RT_INTERFACE!{interface ITimePickerAutomationPeerFactory(ITimePickerAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ITimePickerAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::TimePicker, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut TimePickerAutomationPeer) -> HRESULT
}}
impl ITimePickerAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::TimePicker, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<TimePickerAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IToggleMenuFlyoutItemAutomationPeer, 1800923902, 27377, 18691, 131, 115, 52, 55, 191, 53, 35, 69);
RT_INTERFACE!{interface IToggleMenuFlyoutItemAutomationPeer(IToggleMenuFlyoutItemAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IToggleMenuFlyoutItemAutomationPeer] {
    
}}
DEFINE_IID!(IID_IToggleMenuFlyoutItemAutomationPeerFactory, 2486586231, 36716, 18487, 170, 227, 148, 208, 16, 216, 209, 98);
RT_INTERFACE!{interface IToggleMenuFlyoutItemAutomationPeerFactory(IToggleMenuFlyoutItemAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IToggleMenuFlyoutItemAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::ToggleMenuFlyoutItem, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ToggleMenuFlyoutItemAutomationPeer) -> HRESULT
}}
impl IToggleMenuFlyoutItemAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::ToggleMenuFlyoutItem, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ToggleMenuFlyoutItemAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGridViewHeaderItemAutomationPeer, 3822907194, 57482, 18663, 178, 58, 43, 229, 182, 110, 71, 78);
RT_INTERFACE!{interface IGridViewHeaderItemAutomationPeer(IGridViewHeaderItemAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IGridViewHeaderItemAutomationPeer] {
    
}}
DEFINE_IID!(IID_IGridViewHeaderItemAutomationPeerFactory, 746632402, 65474, 16727, 136, 221, 89, 205, 146, 227, 151, 21);
RT_INTERFACE!{interface IGridViewHeaderItemAutomationPeerFactory(IGridViewHeaderItemAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGridViewHeaderItemAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::GridViewHeaderItem, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut GridViewHeaderItemAutomationPeer) -> HRESULT
}}
impl IGridViewHeaderItemAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::GridViewHeaderItem, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<GridViewHeaderItemAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGridViewItemDataAutomationPeer, 4092888719, 10708, 16532, 140, 84, 234, 97, 168, 130, 148, 164);
RT_INTERFACE!{interface IGridViewItemDataAutomationPeer(IGridViewItemDataAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IGridViewItemDataAutomationPeer] {
    
}}
DEFINE_IID!(IID_IGridViewItemDataAutomationPeerFactory, 2791209608, 30477, 16428, 153, 111, 103, 80, 106, 242, 164, 175);
RT_INTERFACE!{interface IGridViewItemDataAutomationPeerFactory(IGridViewItemDataAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGridViewItemDataAutomationPeerFactory] {
    fn CreateInstanceWithParentAndItem(&self, item: *mut IInspectable, parent: *mut GridViewAutomationPeer, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut GridViewItemDataAutomationPeer) -> HRESULT
}}
impl IGridViewItemDataAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_parent_and_item(&self, item: &IInspectable, parent: &GridViewAutomationPeer, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<GridViewItemDataAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithParentAndItem)(self as *const _ as *mut _, item as *const _ as *mut _, parent as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewHeaderItemAutomationPeer, 1739267659, 44385, 19592, 186, 69, 15, 58, 141, 6, 31, 143);
RT_INTERFACE!{interface IListViewHeaderItemAutomationPeer(IListViewHeaderItemAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IListViewHeaderItemAutomationPeer] {
    
}}
DEFINE_IID!(IID_IListViewHeaderItemAutomationPeerFactory, 124159636, 11429, 19428, 168, 185, 89, 45, 72, 247, 96, 135);
RT_INTERFACE!{interface IListViewHeaderItemAutomationPeerFactory(IListViewHeaderItemAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IListViewHeaderItemAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::ListViewHeaderItem, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ListViewHeaderItemAutomationPeer) -> HRESULT
}}
impl IListViewHeaderItemAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::ListViewHeaderItem, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ListViewHeaderItemAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewItemDataAutomationPeer, 363386877, 55205, 19052, 150, 60, 111, 124, 228, 100, 103, 26);
RT_INTERFACE!{interface IListViewItemDataAutomationPeer(IListViewItemDataAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IListViewItemDataAutomationPeer] {
    
}}
DEFINE_IID!(IID_IListViewItemDataAutomationPeerFactory, 3504018107, 55061, 17699, 172, 192, 30, 16, 114, 216, 227, 43);
RT_INTERFACE!{interface IListViewItemDataAutomationPeerFactory(IListViewItemDataAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IListViewItemDataAutomationPeerFactory] {
    fn CreateInstanceWithParentAndItem(&self, item: *mut IInspectable, parent: *mut ListViewBaseAutomationPeer, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ListViewItemDataAutomationPeer) -> HRESULT
}}
impl IListViewItemDataAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_parent_and_item(&self, item: &IInspectable, parent: &ListViewBaseAutomationPeer, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ListViewItemDataAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithParentAndItem)(self as *const _ as *mut _, item as *const _ as *mut _, parent as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMenuFlyoutPresenterAutomationPeer, 3796150385, 64699, 18684, 138, 147, 65, 234, 19, 75, 83, 206);
RT_INTERFACE!{interface IMenuFlyoutPresenterAutomationPeer(IMenuFlyoutPresenterAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutPresenterAutomationPeer] {
    
}}
DEFINE_IID!(IID_IMenuFlyoutPresenterAutomationPeerFactory, 129308461, 30237, 17707, 158, 109, 250, 42, 139, 224, 173, 38);
RT_INTERFACE!{interface IMenuFlyoutPresenterAutomationPeerFactory(IMenuFlyoutPresenterAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMenuFlyoutPresenterAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::MenuFlyoutPresenter, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut MenuFlyoutPresenterAutomationPeer) -> HRESULT
}}
impl IMenuFlyoutPresenterAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::MenuFlyoutPresenter, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<MenuFlyoutPresenterAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBarButtonAutomationPeer, 1144152754, 20333, 19318, 157, 46, 62, 255, 119, 126, 136, 100);
RT_INTERFACE!{interface IAppBarButtonAutomationPeer(IAppBarButtonAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IAppBarButtonAutomationPeer] {
    
}}
DEFINE_IID!(IID_IAppBarButtonAutomationPeerFactory, 2934977578, 44215, 17116, 151, 227, 132, 112, 113, 134, 95, 214);
RT_INTERFACE!{interface IAppBarButtonAutomationPeerFactory(IAppBarButtonAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAppBarButtonAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::AppBarButton, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut AppBarButtonAutomationPeer) -> HRESULT
}}
impl IAppBarButtonAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::AppBarButton, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<AppBarButtonAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBarToggleButtonAutomationPeer, 2221207469, 38485, 19199, 149, 80, 99, 174, 158, 200, 254, 156);
RT_INTERFACE!{interface IAppBarToggleButtonAutomationPeer(IAppBarToggleButtonAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IAppBarToggleButtonAutomationPeer] {
    
}}
DEFINE_IID!(IID_IAppBarToggleButtonAutomationPeerFactory, 3606647709, 705, 16929, 149, 145, 125, 78, 254, 183, 71, 1);
RT_INTERFACE!{interface IAppBarToggleButtonAutomationPeerFactory(IAppBarToggleButtonAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAppBarToggleButtonAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::AppBarToggleButton, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut AppBarToggleButtonAutomationPeer) -> HRESULT
}}
impl IAppBarToggleButtonAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::AppBarToggleButton, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<AppBarToggleButtonAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewBaseAutomationPeer, 2280420937, 47165, 20053, 154, 253, 189, 131, 94, 116, 143, 92);
RT_INTERFACE!{interface IListViewBaseAutomationPeer(IListViewBaseAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IListViewBaseAutomationPeer] {
    
}}
DEFINE_IID!(IID_IListViewBaseAutomationPeerFactory, 1892926142, 35152, 17991, 147, 98, 253, 0, 47, 143, 248, 46);
RT_INTERFACE!{interface IListViewBaseAutomationPeerFactory(IListViewBaseAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IListViewBaseAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::ListViewBase, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ListViewBaseAutomationPeer) -> HRESULT
}}
impl IListViewBaseAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::ListViewBase, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ListViewBaseAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGridViewAutomationPeer, 474218916, 55633, 18890, 143, 130, 199, 243, 198, 6, 129, 176);
RT_INTERFACE!{interface IGridViewAutomationPeer(IGridViewAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IGridViewAutomationPeer] {
    
}}
DEFINE_IID!(IID_IGridViewAutomationPeerFactory, 2328517085, 8871, 18432, 137, 75, 193, 244, 133, 243, 137, 83);
RT_INTERFACE!{interface IGridViewAutomationPeerFactory(IGridViewAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGridViewAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::GridView, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut GridViewAutomationPeer) -> HRESULT
}}
impl IGridViewAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::GridView, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<GridViewAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IListViewAutomationPeer, 1942932615, 49372, 16992, 145, 72, 117, 233, 134, 74, 114, 48);
RT_INTERFACE!{interface IListViewAutomationPeer(IListViewAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IListViewAutomationPeer] {
    
}}
DEFINE_IID!(IID_IListViewAutomationPeerFactory, 1710461300, 60066, 20036, 139, 230, 76, 202, 40, 205, 2, 136);
RT_INTERFACE!{interface IListViewAutomationPeerFactory(IListViewAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IListViewAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::ListView, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ListViewAutomationPeer) -> HRESULT
}}
impl IListViewAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::ListView, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ListViewAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_ENUM! { enum AccessibilityView: i32 {
    Raw (AccessibilityView_Raw) = 0, Control (AccessibilityView_Control) = 1, Content (AccessibilityView_Content) = 2,
}}
RT_ENUM! { enum AutomationControlType: i32 {
    Button (AutomationControlType_Button) = 0, Calendar (AutomationControlType_Calendar) = 1, CheckBox (AutomationControlType_CheckBox) = 2, ComboBox (AutomationControlType_ComboBox) = 3, Edit (AutomationControlType_Edit) = 4, Hyperlink (AutomationControlType_Hyperlink) = 5, Image (AutomationControlType_Image) = 6, ListItem (AutomationControlType_ListItem) = 7, List (AutomationControlType_List) = 8, Menu (AutomationControlType_Menu) = 9, MenuBar (AutomationControlType_MenuBar) = 10, MenuItem (AutomationControlType_MenuItem) = 11, ProgressBar (AutomationControlType_ProgressBar) = 12, RadioButton (AutomationControlType_RadioButton) = 13, ScrollBar (AutomationControlType_ScrollBar) = 14, Slider (AutomationControlType_Slider) = 15, Spinner (AutomationControlType_Spinner) = 16, StatusBar (AutomationControlType_StatusBar) = 17, Tab (AutomationControlType_Tab) = 18, TabItem (AutomationControlType_TabItem) = 19, Text (AutomationControlType_Text) = 20, ToolBar (AutomationControlType_ToolBar) = 21, ToolTip (AutomationControlType_ToolTip) = 22, Tree (AutomationControlType_Tree) = 23, TreeItem (AutomationControlType_TreeItem) = 24, Custom (AutomationControlType_Custom) = 25, Group (AutomationControlType_Group) = 26, Thumb (AutomationControlType_Thumb) = 27, DataGrid (AutomationControlType_DataGrid) = 28, DataItem (AutomationControlType_DataItem) = 29, Document (AutomationControlType_Document) = 30, SplitButton (AutomationControlType_SplitButton) = 31, Window (AutomationControlType_Window) = 32, Pane (AutomationControlType_Pane) = 33, Header (AutomationControlType_Header) = 34, HeaderItem (AutomationControlType_HeaderItem) = 35, Table (AutomationControlType_Table) = 36, TitleBar (AutomationControlType_TitleBar) = 37, Separator (AutomationControlType_Separator) = 38, SemanticZoom (AutomationControlType_SemanticZoom) = 39, AppBar (AutomationControlType_AppBar) = 40,
}}
RT_ENUM! { enum AutomationEvents: i32 {
    ToolTipOpened (AutomationEvents_ToolTipOpened) = 0, ToolTipClosed (AutomationEvents_ToolTipClosed) = 1, MenuOpened (AutomationEvents_MenuOpened) = 2, MenuClosed (AutomationEvents_MenuClosed) = 3, AutomationFocusChanged (AutomationEvents_AutomationFocusChanged) = 4, InvokePatternOnInvoked (AutomationEvents_InvokePatternOnInvoked) = 5, SelectionItemPatternOnElementAddedToSelection (AutomationEvents_SelectionItemPatternOnElementAddedToSelection) = 6, SelectionItemPatternOnElementRemovedFromSelection (AutomationEvents_SelectionItemPatternOnElementRemovedFromSelection) = 7, SelectionItemPatternOnElementSelected (AutomationEvents_SelectionItemPatternOnElementSelected) = 8, SelectionPatternOnInvalidated (AutomationEvents_SelectionPatternOnInvalidated) = 9, TextPatternOnTextSelectionChanged (AutomationEvents_TextPatternOnTextSelectionChanged) = 10, TextPatternOnTextChanged (AutomationEvents_TextPatternOnTextChanged) = 11, AsyncContentLoaded (AutomationEvents_AsyncContentLoaded) = 12, PropertyChanged (AutomationEvents_PropertyChanged) = 13, StructureChanged (AutomationEvents_StructureChanged) = 14, DragStart (AutomationEvents_DragStart) = 15, DragCancel (AutomationEvents_DragCancel) = 16, DragComplete (AutomationEvents_DragComplete) = 17, DragEnter (AutomationEvents_DragEnter) = 18, DragLeave (AutomationEvents_DragLeave) = 19, Dropped (AutomationEvents_Dropped) = 20, LiveRegionChanged (AutomationEvents_LiveRegionChanged) = 21, InputReachedTarget (AutomationEvents_InputReachedTarget) = 22, InputReachedOtherElement (AutomationEvents_InputReachedOtherElement) = 23, InputDiscarded (AutomationEvents_InputDiscarded) = 24, WindowClosed (AutomationEvents_WindowClosed) = 25, WindowOpened (AutomationEvents_WindowOpened) = 26, ConversionTargetChanged (AutomationEvents_ConversionTargetChanged) = 27, TextEditTextChanged (AutomationEvents_TextEditTextChanged) = 28, LayoutInvalidated (AutomationEvents_LayoutInvalidated) = 29,
}}
RT_ENUM! { enum AutomationLandmarkType: i32 {
    None (AutomationLandmarkType_None) = 0, Custom (AutomationLandmarkType_Custom) = 1, Form (AutomationLandmarkType_Form) = 2, Main (AutomationLandmarkType_Main) = 3, Navigation (AutomationLandmarkType_Navigation) = 4, Search (AutomationLandmarkType_Search) = 5,
}}
RT_ENUM! { enum AutomationLiveSetting: i32 {
    Off (AutomationLiveSetting_Off) = 0, Polite (AutomationLiveSetting_Polite) = 1, Assertive (AutomationLiveSetting_Assertive) = 2,
}}
RT_ENUM! { enum AutomationNavigationDirection: i32 {
    Parent (AutomationNavigationDirection_Parent) = 0, NextSibling (AutomationNavigationDirection_NextSibling) = 1, PreviousSibling (AutomationNavigationDirection_PreviousSibling) = 2, FirstChild (AutomationNavigationDirection_FirstChild) = 3, LastChild (AutomationNavigationDirection_LastChild) = 4,
}}
RT_ENUM! { enum AutomationOrientation: i32 {
    None (AutomationOrientation_None) = 0, Horizontal (AutomationOrientation_Horizontal) = 1, Vertical (AutomationOrientation_Vertical) = 2,
}}
RT_ENUM! { enum AutomationStructureChangeType: i32 {
    ChildAdded (AutomationStructureChangeType_ChildAdded) = 0, ChildRemoved (AutomationStructureChangeType_ChildRemoved) = 1, ChildrenInvalidated (AutomationStructureChangeType_ChildrenInvalidated) = 2, ChildrenBulkAdded (AutomationStructureChangeType_ChildrenBulkAdded) = 3, ChildrenBulkRemoved (AutomationStructureChangeType_ChildrenBulkRemoved) = 4, ChildrenReordered (AutomationStructureChangeType_ChildrenReordered) = 5,
}}
RT_ENUM! { enum PatternInterface: i32 {
    Invoke (PatternInterface_Invoke) = 0, Selection (PatternInterface_Selection) = 1, Value (PatternInterface_Value) = 2, RangeValue (PatternInterface_RangeValue) = 3, Scroll (PatternInterface_Scroll) = 4, ScrollItem (PatternInterface_ScrollItem) = 5, ExpandCollapse (PatternInterface_ExpandCollapse) = 6, Grid (PatternInterface_Grid) = 7, GridItem (PatternInterface_GridItem) = 8, MultipleView (PatternInterface_MultipleView) = 9, Window (PatternInterface_Window) = 10, SelectionItem (PatternInterface_SelectionItem) = 11, Dock (PatternInterface_Dock) = 12, Table (PatternInterface_Table) = 13, TableItem (PatternInterface_TableItem) = 14, Toggle (PatternInterface_Toggle) = 15, Transform (PatternInterface_Transform) = 16, Text (PatternInterface_Text) = 17, ItemContainer (PatternInterface_ItemContainer) = 18, VirtualizedItem (PatternInterface_VirtualizedItem) = 19, Text2 (PatternInterface_Text2) = 20, TextChild (PatternInterface_TextChild) = 21, TextRange (PatternInterface_TextRange) = 22, Annotation (PatternInterface_Annotation) = 23, Drag (PatternInterface_Drag) = 24, DropTarget (PatternInterface_DropTarget) = 25, ObjectModel (PatternInterface_ObjectModel) = 26, Spreadsheet (PatternInterface_Spreadsheet) = 27, SpreadsheetItem (PatternInterface_SpreadsheetItem) = 28, Styles (PatternInterface_Styles) = 29, Transform2 (PatternInterface_Transform2) = 30, SynchronizedInput (PatternInterface_SynchronizedInput) = 31, TextEdit (PatternInterface_TextEdit) = 32, CustomNavigation (PatternInterface_CustomNavigation) = 33,
}}
RT_STRUCT! { struct RawElementProviderRuntimeId {
    Part1: u32, Part2: u32,
}}
DEFINE_IID!(IID_IAutomationPeer, 900384890, 25326, 19774, 162, 76, 43, 200, 67, 45, 104, 183);
RT_INTERFACE!{interface IAutomationPeer(IAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPeer] {
    fn get_EventsSource(&self, out: *mut *mut AutomationPeer) -> HRESULT,
    fn put_EventsSource(&self, value: *mut AutomationPeer) -> HRESULT,
    fn GetPattern(&self, patternInterface: PatternInterface, out: *mut *mut IInspectable) -> HRESULT,
    fn RaiseAutomationEvent(&self, eventId: AutomationEvents) -> HRESULT,
    fn RaisePropertyChangedEvent(&self, automationProperty: *mut super::AutomationProperty, oldValue: *mut IInspectable, newValue: *mut IInspectable) -> HRESULT,
    fn GetAcceleratorKey(&self, out: *mut HSTRING) -> HRESULT,
    fn GetAccessKey(&self, out: *mut HSTRING) -> HRESULT,
    fn GetAutomationControlType(&self, out: *mut AutomationControlType) -> HRESULT,
    fn GetAutomationId(&self, out: *mut HSTRING) -> HRESULT,
    fn GetBoundingRectangle(&self, out: *mut ::rt::gen::windows::foundation::Rect) -> HRESULT,
    fn GetChildren(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<AutomationPeer>) -> HRESULT,
    fn GetClassName(&self, out: *mut HSTRING) -> HRESULT,
    fn GetClickablePoint(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn GetHelpText(&self, out: *mut HSTRING) -> HRESULT,
    fn GetItemStatus(&self, out: *mut HSTRING) -> HRESULT,
    fn GetItemType(&self, out: *mut HSTRING) -> HRESULT,
    fn GetLabeledBy(&self, out: *mut *mut AutomationPeer) -> HRESULT,
    fn GetLocalizedControlType(&self, out: *mut HSTRING) -> HRESULT,
    fn GetName(&self, out: *mut HSTRING) -> HRESULT,
    fn GetOrientation(&self, out: *mut AutomationOrientation) -> HRESULT,
    fn HasKeyboardFocus(&self, out: *mut bool) -> HRESULT,
    fn IsContentElement(&self, out: *mut bool) -> HRESULT,
    fn IsControlElement(&self, out: *mut bool) -> HRESULT,
    fn IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn IsKeyboardFocusable(&self, out: *mut bool) -> HRESULT,
    fn IsOffscreen(&self, out: *mut bool) -> HRESULT,
    fn IsPassword(&self, out: *mut bool) -> HRESULT,
    fn IsRequiredForForm(&self, out: *mut bool) -> HRESULT,
    fn SetFocus(&self) -> HRESULT,
    fn GetParent(&self, out: *mut *mut AutomationPeer) -> HRESULT,
    fn InvalidatePeer(&self) -> HRESULT,
    fn GetPeerFromPoint(&self, point: ::rt::gen::windows::foundation::Point, out: *mut *mut AutomationPeer) -> HRESULT,
    fn GetLiveSetting(&self, out: *mut AutomationLiveSetting) -> HRESULT
}}
impl IAutomationPeer {
    #[inline] pub unsafe fn get_events_source(&self) -> Result<ComPtr<AutomationPeer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EventsSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_events_source(&self, value: &AutomationPeer) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EventsSource)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pattern(&self, patternInterface: PatternInterface) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetPattern)(self as *const _ as *mut _, patternInterface, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn raise_automation_event(&self, eventId: AutomationEvents) -> Result<()> {
        let hr = ((*self.lpVtbl).RaiseAutomationEvent)(self as *const _ as *mut _, eventId);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn raise_property_changed_event(&self, automationProperty: &super::AutomationProperty, oldValue: &IInspectable, newValue: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).RaisePropertyChangedEvent)(self as *const _ as *mut _, automationProperty as *const _ as *mut _, oldValue as *const _ as *mut _, newValue as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_accelerator_key(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAcceleratorKey)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_access_key(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAccessKey)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_automation_control_type(&self) -> Result<AutomationControlType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetAutomationControlType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_automation_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAutomationId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_bounding_rectangle(&self) -> Result<::rt::gen::windows::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetBoundingRectangle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_children(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<AutomationPeer>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetChildren)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_class_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetClassName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_clickable_point(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetClickablePoint)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_help_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetHelpText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_status(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetItemStatus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_type(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetItemType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_labeled_by(&self) -> Result<ComPtr<AutomationPeer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetLabeledBy)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_localized_control_type(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetLocalizedControlType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation(&self) -> Result<AutomationOrientation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetOrientation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn has_keyboard_focus(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).HasKeyboardFocus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_content_element(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsContentElement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_control_element(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsControlElement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_keyboard_focusable(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsKeyboardFocusable)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_offscreen(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsOffscreen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_password(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsPassword)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_required_for_form(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsRequiredForForm)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_focus(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).SetFocus)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_parent(&self) -> Result<ComPtr<AutomationPeer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetParent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn invalidate_peer(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).InvalidatePeer)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_peer_from_point(&self, point: ::rt::gen::windows::foundation::Point) -> Result<ComPtr<AutomationPeer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetPeerFromPoint)(self as *const _ as *mut _, point, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_live_setting(&self) -> Result<AutomationLiveSetting> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetLiveSetting)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationPeerOverrides, 3198762599, 56302, 20347, 175, 13, 167, 154, 174, 83, 51, 191);
RT_INTERFACE!{interface IAutomationPeerOverrides(IAutomationPeerOverridesVtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPeerOverrides] {
    fn GetPatternCore(&self, patternInterface: PatternInterface, out: *mut *mut IInspectable) -> HRESULT,
    fn GetAcceleratorKeyCore(&self, out: *mut HSTRING) -> HRESULT,
    fn GetAccessKeyCore(&self, out: *mut HSTRING) -> HRESULT,
    fn GetAutomationControlTypeCore(&self, out: *mut AutomationControlType) -> HRESULT,
    fn GetAutomationIdCore(&self, out: *mut HSTRING) -> HRESULT,
    fn GetBoundingRectangleCore(&self, out: *mut ::rt::gen::windows::foundation::Rect) -> HRESULT,
    fn GetChildrenCore(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<AutomationPeer>) -> HRESULT,
    fn GetClassNameCore(&self, out: *mut HSTRING) -> HRESULT,
    fn GetClickablePointCore(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn GetHelpTextCore(&self, out: *mut HSTRING) -> HRESULT,
    fn GetItemStatusCore(&self, out: *mut HSTRING) -> HRESULT,
    fn GetItemTypeCore(&self, out: *mut HSTRING) -> HRESULT,
    fn GetLabeledByCore(&self, out: *mut *mut AutomationPeer) -> HRESULT,
    fn GetLocalizedControlTypeCore(&self, out: *mut HSTRING) -> HRESULT,
    fn GetNameCore(&self, out: *mut HSTRING) -> HRESULT,
    fn GetOrientationCore(&self, out: *mut AutomationOrientation) -> HRESULT,
    fn HasKeyboardFocusCore(&self, out: *mut bool) -> HRESULT,
    fn IsContentElementCore(&self, out: *mut bool) -> HRESULT,
    fn IsControlElementCore(&self, out: *mut bool) -> HRESULT,
    fn IsEnabledCore(&self, out: *mut bool) -> HRESULT,
    fn IsKeyboardFocusableCore(&self, out: *mut bool) -> HRESULT,
    fn IsOffscreenCore(&self, out: *mut bool) -> HRESULT,
    fn IsPasswordCore(&self, out: *mut bool) -> HRESULT,
    fn IsRequiredForFormCore(&self, out: *mut bool) -> HRESULT,
    fn SetFocusCore(&self) -> HRESULT,
    fn GetPeerFromPointCore(&self, point: ::rt::gen::windows::foundation::Point, out: *mut *mut AutomationPeer) -> HRESULT,
    fn GetLiveSettingCore(&self, out: *mut AutomationLiveSetting) -> HRESULT
}}
impl IAutomationPeerOverrides {
    #[inline] pub unsafe fn get_pattern_core(&self, patternInterface: PatternInterface) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetPatternCore)(self as *const _ as *mut _, patternInterface, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_accelerator_key_core(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAcceleratorKeyCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_access_key_core(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAccessKeyCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_automation_control_type_core(&self) -> Result<AutomationControlType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetAutomationControlTypeCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_automation_id_core(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAutomationIdCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_bounding_rectangle_core(&self) -> Result<::rt::gen::windows::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetBoundingRectangleCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_children_core(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<AutomationPeer>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetChildrenCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_class_name_core(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetClassNameCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_clickable_point_core(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetClickablePointCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_help_text_core(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetHelpTextCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_status_core(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetItemStatusCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_type_core(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetItemTypeCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_labeled_by_core(&self) -> Result<ComPtr<AutomationPeer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetLabeledByCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_localized_control_type_core(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetLocalizedControlTypeCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_name_core(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetNameCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_orientation_core(&self) -> Result<AutomationOrientation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetOrientationCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn has_keyboard_focus_core(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).HasKeyboardFocusCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_content_element_core(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsContentElementCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_control_element_core(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsControlElementCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_enabled_core(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsEnabledCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_keyboard_focusable_core(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsKeyboardFocusableCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_offscreen_core(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsOffscreenCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_password_core(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsPasswordCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_required_for_form_core(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsRequiredForFormCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_focus_core(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).SetFocusCore)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_peer_from_point_core(&self, point: ::rt::gen::windows::foundation::Point) -> Result<ComPtr<AutomationPeer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetPeerFromPointCore)(self as *const _ as *mut _, point, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_live_setting_core(&self) -> Result<AutomationLiveSetting> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetLiveSettingCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationPeerProtected, 4105440850, 25647, 17961, 165, 74, 234, 93, 35, 73, 196, 72);
RT_INTERFACE!{interface IAutomationPeerProtected(IAutomationPeerProtectedVtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPeerProtected] {
    fn PeerFromProvider(&self, provider: *mut super::provider::IRawElementProviderSimple, out: *mut *mut AutomationPeer) -> HRESULT,
    fn ProviderFromPeer(&self, peer: *mut AutomationPeer, out: *mut *mut super::provider::IRawElementProviderSimple) -> HRESULT
}}
impl IAutomationPeerProtected {
    #[inline] pub unsafe fn peer_from_provider(&self, provider: &super::provider::IRawElementProviderSimple) -> Result<ComPtr<AutomationPeer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).PeerFromProvider)(self as *const _ as *mut _, provider as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn provider_from_peer(&self, peer: &AutomationPeer) -> Result<ComPtr<super::provider::IRawElementProviderSimple>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ProviderFromPeer)(self as *const _ as *mut _, peer as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationPeerStatics, 1445953456, 41777, 19100, 157, 236, 191, 183, 88, 111, 255, 255);
RT_INTERFACE!{static interface IAutomationPeerStatics(IAutomationPeerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPeerStatics] {
    fn ListenerExists(&self, eventId: AutomationEvents, out: *mut bool) -> HRESULT
}}
impl IAutomationPeerStatics {
    #[inline] pub unsafe fn listener_exists(&self, eventId: AutomationEvents) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).ListenerExists)(self as *const _ as *mut _, eventId, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationPeerFactory, 549614917, 43147, 17352, 188, 36, 206, 169, 218, 253, 4, 163);
RT_INTERFACE!{interface IAutomationPeerFactory(IAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPeerFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut AutomationPeer) -> HRESULT
}}
impl IAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<AutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationPeer2, 3927935431, 60405, 19128, 136, 247, 104, 13, 130, 29, 172, 97);
RT_INTERFACE!{interface IAutomationPeer2(IAutomationPeer2Vtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPeer2] {
    
}}
DEFINE_IID!(IID_IAutomationPeerOverrides2, 637757482, 40358, 16419, 180, 150, 73, 110, 94, 242, 40, 210);
RT_INTERFACE!{interface IAutomationPeerOverrides2(IAutomationPeerOverrides2Vtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPeerOverrides2] {
    fn ShowContextMenuCore(&self) -> HRESULT,
    fn GetControlledPeersCore(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<AutomationPeer>) -> HRESULT
}}
impl IAutomationPeerOverrides2 {
    #[inline] pub unsafe fn show_context_menu_core(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ShowContextMenuCore)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_controlled_peers_core(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<AutomationPeer>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetControlledPeersCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationPeer3, 3553606007, 132, 16855, 162, 33, 40, 21, 141, 59, 195, 44);
RT_INTERFACE!{interface IAutomationPeer3(IAutomationPeer3Vtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPeer3] {
    fn Navigate(&self, direction: AutomationNavigationDirection, out: *mut *mut IInspectable) -> HRESULT,
    fn GetElementFromPoint(&self, pointInWindowCoordinates: ::rt::gen::windows::foundation::Point, out: *mut *mut IInspectable) -> HRESULT,
    fn GetFocusedElement(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn ShowContextMenu(&self) -> HRESULT,
    fn GetControlledPeers(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<AutomationPeer>) -> HRESULT,
    fn GetAnnotations(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<AutomationPeerAnnotation>) -> HRESULT,
    fn SetParent(&self, peer: *mut AutomationPeer) -> HRESULT,
    fn RaiseTextEditTextChangedEvent(&self, automationTextEditChangeType: super::AutomationTextEditChangeType, changedData: *mut ::rt::gen::windows::foundation::collections::IVectorView<HString>) -> HRESULT,
    fn GetPositionInSet(&self, out: *mut i32) -> HRESULT,
    fn GetSizeOfSet(&self, out: *mut i32) -> HRESULT,
    fn GetLevel(&self, out: *mut i32) -> HRESULT,
    fn RaiseStructureChangedEvent(&self, structureChangeType: AutomationStructureChangeType, child: *mut AutomationPeer) -> HRESULT
}}
impl IAutomationPeer3 {
    #[inline] pub unsafe fn navigate(&self, direction: AutomationNavigationDirection) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Navigate)(self as *const _ as *mut _, direction, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_element_from_point(&self, pointInWindowCoordinates: ::rt::gen::windows::foundation::Point) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetElementFromPoint)(self as *const _ as *mut _, pointInWindowCoordinates, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focused_element(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetFocusedElement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_context_menu(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ShowContextMenu)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_controlled_peers(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<AutomationPeer>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetControlledPeers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_annotations(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<AutomationPeerAnnotation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAnnotations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_parent(&self, peer: &AutomationPeer) -> Result<()> {
        let hr = ((*self.lpVtbl).SetParent)(self as *const _ as *mut _, peer as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn raise_text_edit_text_changed_event(&self, automationTextEditChangeType: super::AutomationTextEditChangeType, changedData: &::rt::gen::windows::foundation::collections::IVectorView<HString>) -> Result<()> {
        let hr = ((*self.lpVtbl).RaiseTextEditTextChangedEvent)(self as *const _ as *mut _, automationTextEditChangeType, changedData as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_position_in_set(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetPositionInSet)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_size_of_set(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetSizeOfSet)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_level(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetLevel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn raise_structure_changed_event(&self, structureChangeType: AutomationStructureChangeType, child: &AutomationPeer) -> Result<()> {
        let hr = ((*self.lpVtbl).RaiseStructureChangedEvent)(self as *const _ as *mut _, structureChangeType, child as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationPeerOverrides3, 3069232301, 19769, 18918, 187, 145, 217, 36, 238, 253, 133, 56);
RT_INTERFACE!{interface IAutomationPeerOverrides3(IAutomationPeerOverrides3Vtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPeerOverrides3] {
    fn NavigateCore(&self, direction: AutomationNavigationDirection, out: *mut *mut IInspectable) -> HRESULT,
    fn GetElementFromPointCore(&self, pointInWindowCoordinates: ::rt::gen::windows::foundation::Point, out: *mut *mut IInspectable) -> HRESULT,
    fn GetFocusedElementCore(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn GetAnnotationsCore(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<AutomationPeerAnnotation>) -> HRESULT,
    fn GetPositionInSetCore(&self, out: *mut i32) -> HRESULT,
    fn GetSizeOfSetCore(&self, out: *mut i32) -> HRESULT,
    fn GetLevelCore(&self, out: *mut i32) -> HRESULT
}}
impl IAutomationPeerOverrides3 {
    #[inline] pub unsafe fn navigate_core(&self, direction: AutomationNavigationDirection) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).NavigateCore)(self as *const _ as *mut _, direction, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_element_from_point_core(&self, pointInWindowCoordinates: ::rt::gen::windows::foundation::Point) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetElementFromPointCore)(self as *const _ as *mut _, pointInWindowCoordinates, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focused_element_core(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetFocusedElementCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_annotations_core(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<AutomationPeerAnnotation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAnnotationsCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_position_in_set_core(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetPositionInSetCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_size_of_set_core(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetSizeOfSetCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_level_core(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetLevelCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationPeerStatics3, 1462523668, 32647, 17009, 129, 159, 108, 244, 196, 208, 34, 208);
RT_INTERFACE!{static interface IAutomationPeerStatics3(IAutomationPeerStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPeerStatics3] {
    fn GenerateRawElementProviderRuntimeId(&self, out: *mut RawElementProviderRuntimeId) -> HRESULT
}}
impl IAutomationPeerStatics3 {
    #[inline] pub unsafe fn generate_raw_element_provider_runtime_id(&self) -> Result<RawElementProviderRuntimeId> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GenerateRawElementProviderRuntimeId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationPeer4, 1981605714, 29633, 20292, 190, 117, 67, 196, 158, 192, 212, 213);
RT_INTERFACE!{interface IAutomationPeer4(IAutomationPeer4Vtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPeer4] {
    fn GetLandmarkType(&self, out: *mut AutomationLandmarkType) -> HRESULT,
    fn GetLocalizedLandmarkType(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAutomationPeer4 {
    #[inline] pub unsafe fn get_landmark_type(&self) -> Result<AutomationLandmarkType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetLandmarkType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_localized_landmark_type(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetLocalizedLandmarkType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationPeerOverrides4, 2978401698, 23878, 19405, 168, 17, 38, 154, 209, 91, 58, 238);
RT_INTERFACE!{interface IAutomationPeerOverrides4(IAutomationPeerOverrides4Vtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPeerOverrides4] {
    fn GetLandmarkTypeCore(&self, out: *mut AutomationLandmarkType) -> HRESULT,
    fn GetLocalizedLandmarkTypeCore(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAutomationPeerOverrides4 {
    #[inline] pub unsafe fn get_landmark_type_core(&self) -> Result<AutomationLandmarkType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetLandmarkTypeCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_localized_landmark_type_core(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetLocalizedLandmarkTypeCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationPeer5, 4130529734, 2623, 17780, 159, 239, 205, 193, 81, 118, 86, 116);
RT_INTERFACE!{interface IAutomationPeer5(IAutomationPeer5Vtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPeer5] {
    fn IsPeripheral(&self, out: *mut bool) -> HRESULT,
    fn IsDataValidForForm(&self, out: *mut bool) -> HRESULT,
    fn GetFullDescription(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAutomationPeer5 {
    #[inline] pub unsafe fn is_peripheral(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsPeripheral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_data_valid_for_form(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsDataValidForForm)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_full_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetFullDescription)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationPeerOverrides5, 746880133, 30750, 18935, 159, 239, 185, 225, 77, 1, 71, 7);
RT_INTERFACE!{interface IAutomationPeerOverrides5(IAutomationPeerOverrides5Vtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPeerOverrides5] {
    fn IsPeripheralCore(&self, out: *mut bool) -> HRESULT,
    fn IsDataValidForFormCore(&self, out: *mut bool) -> HRESULT,
    fn GetFullDescriptionCore(&self, out: *mut HSTRING) -> HRESULT,
    fn GetDescribedByCore(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IIterable<AutomationPeer>) -> HRESULT,
    fn GetFlowsToCore(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IIterable<AutomationPeer>) -> HRESULT,
    fn GetFlowsFromCore(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IIterable<AutomationPeer>) -> HRESULT
}}
impl IAutomationPeerOverrides5 {
    #[inline] pub unsafe fn is_peripheral_core(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsPeripheralCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_data_valid_for_form_core(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsDataValidForFormCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_full_description_core(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetFullDescriptionCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_described_by_core(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IIterable<AutomationPeer>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDescribedByCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_flows_to_core(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IIterable<AutomationPeer>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetFlowsToCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_flows_from_core(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IIterable<AutomationPeer>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetFlowsFromCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationPeer6, 3405275279, 5119, 17147, 134, 109, 34, 32, 100, 52, 204, 107);
RT_INTERFACE!{interface IAutomationPeer6(IAutomationPeer6Vtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPeer6] {
    fn GetCulture(&self, out: *mut i32) -> HRESULT
}}
impl IAutomationPeer6 {
    #[inline] pub unsafe fn get_culture(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetCulture)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationPeerOverrides6, 3918244839, 63231, 17484, 156, 13, 39, 126, 175, 10, 217, 192);
RT_INTERFACE!{interface IAutomationPeerOverrides6(IAutomationPeerOverrides6Vtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPeerOverrides6] {
    fn GetCultureCore(&self, out: *mut i32) -> HRESULT
}}
impl IAutomationPeerOverrides6 {
    #[inline] pub unsafe fn get_culture_core(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetCultureCore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class AutomationPeer: IAutomationPeer}
impl RtActivatable<IAutomationPeerStatics3> for AutomationPeer {}
impl RtActivatable<IAutomationPeerStatics> for AutomationPeer {}
impl AutomationPeer {
    #[inline] pub fn generate_raw_element_provider_runtime_id() -> Result<RawElementProviderRuntimeId> { unsafe {
        <Self as RtActivatable<IAutomationPeerStatics3>>::get_activation_factory().generate_raw_element_provider_runtime_id()
    }}
    #[inline] pub fn listener_exists(eventId: AutomationEvents) -> Result<bool> { unsafe {
        <Self as RtActivatable<IAutomationPeerStatics>>::get_activation_factory().listener_exists(eventId)
    }}
}
DEFINE_CLSID!(AutomationPeer(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,80,101,101,114,115,46,65,117,116,111,109,97,116,105,111,110,80,101,101,114,0]) [CLSID_AutomationPeer]);
DEFINE_IID!(IID_IAutomationPeerAnnotation, 205873249, 21199, 17402, 130, 248, 7, 241, 55, 53, 30, 90);
RT_INTERFACE!{interface IAutomationPeerAnnotation(IAutomationPeerAnnotationVtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPeerAnnotation] {
    fn get_Type(&self, out: *mut super::AnnotationType) -> HRESULT,
    fn put_Type(&self, value: super::AnnotationType) -> HRESULT,
    fn get_Peer(&self, out: *mut *mut AutomationPeer) -> HRESULT,
    fn put_Peer(&self, value: *mut AutomationPeer) -> HRESULT
}}
impl IAutomationPeerAnnotation {
    #[inline] pub unsafe fn get_type(&self) -> Result<super::AnnotationType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Type)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_type(&self, value: super::AnnotationType) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Type)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_peer(&self) -> Result<ComPtr<AutomationPeer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Peer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_peer(&self, value: &AutomationPeer) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Peer)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class AutomationPeerAnnotation: IAutomationPeerAnnotation}
impl RtActivatable<IAutomationPeerAnnotationFactory> for AutomationPeerAnnotation {}
impl RtActivatable<IAutomationPeerAnnotationStatics> for AutomationPeerAnnotation {}
impl RtActivatable<IActivationFactory> for AutomationPeerAnnotation {}
impl AutomationPeerAnnotation {
    #[inline] pub fn create_instance(type_: super::AnnotationType) -> Result<ComPtr<AutomationPeerAnnotation>> { unsafe {
        <Self as RtActivatable<IAutomationPeerAnnotationFactory>>::get_activation_factory().create_instance(type_)
    }}
    #[inline] pub fn create_with_peer_parameter(type_: super::AnnotationType, peer: &AutomationPeer) -> Result<ComPtr<AutomationPeerAnnotation>> { unsafe {
        <Self as RtActivatable<IAutomationPeerAnnotationFactory>>::get_activation_factory().create_with_peer_parameter(type_, peer)
    }}
    #[inline] pub fn get_type_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPeerAnnotationStatics>>::get_activation_factory().get_type_property()
    }}
    #[inline] pub fn get_peer_property() -> Result<ComPtr<super::super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IAutomationPeerAnnotationStatics>>::get_activation_factory().get_peer_property()
    }}
}
DEFINE_CLSID!(AutomationPeerAnnotation(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,80,101,101,114,115,46,65,117,116,111,109,97,116,105,111,110,80,101,101,114,65,110,110,111,116,97,116,105,111,110,0]) [CLSID_AutomationPeerAnnotation]);
DEFINE_IID!(IID_IAutomationPeerAnnotationStatics, 2282334333, 2482, 19781, 183, 139, 29, 59, 59, 9, 246, 97);
RT_INTERFACE!{static interface IAutomationPeerAnnotationStatics(IAutomationPeerAnnotationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPeerAnnotationStatics] {
    fn get_TypeProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT,
    fn get_PeerProperty(&self, out: *mut *mut super::super::DependencyProperty) -> HRESULT
}}
impl IAutomationPeerAnnotationStatics {
    #[inline] pub unsafe fn get_type_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TypeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_peer_property(&self) -> Result<ComPtr<super::super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PeerProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAutomationPeerAnnotationFactory, 4120658846, 50779, 17357, 144, 9, 3, 252, 2, 51, 99, 167);
RT_INTERFACE!{static interface IAutomationPeerAnnotationFactory(IAutomationPeerAnnotationFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAutomationPeerAnnotationFactory] {
    fn CreateInstance(&self, type_: super::AnnotationType, out: *mut *mut AutomationPeerAnnotation) -> HRESULT,
    fn CreateWithPeerParameter(&self, type_: super::AnnotationType, peer: *mut AutomationPeer, out: *mut *mut AutomationPeerAnnotation) -> HRESULT
}}
impl IAutomationPeerAnnotationFactory {
    #[inline] pub unsafe fn create_instance(&self, type_: super::AnnotationType) -> Result<ComPtr<AutomationPeerAnnotation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, type_, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_with_peer_parameter(&self, type_: super::AnnotationType, peer: &AutomationPeer) -> Result<ComPtr<AutomationPeerAnnotation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithPeerParameter)(self as *const _ as *mut _, type_, peer as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFrameworkElementAutomationPeer, 3104495489, 49131, 17489, 189, 71, 159, 58, 99, 235, 210, 74);
RT_INTERFACE!{interface IFrameworkElementAutomationPeer(IFrameworkElementAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IFrameworkElementAutomationPeer] {
    fn get_Owner(&self, out: *mut *mut super::super::UIElement) -> HRESULT
}}
impl IFrameworkElementAutomationPeer {
    #[inline] pub unsafe fn get_owner(&self) -> Result<ComPtr<super::super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Owner)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFrameworkElementAutomationPeerStatics, 3116415383, 10272, 17569, 165, 168, 155, 128, 30, 220, 38, 158);
RT_INTERFACE!{static interface IFrameworkElementAutomationPeerStatics(IFrameworkElementAutomationPeerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IFrameworkElementAutomationPeerStatics] {
    fn FromElement(&self, element: *mut super::super::UIElement, out: *mut *mut AutomationPeer) -> HRESULT,
    fn CreatePeerForElement(&self, element: *mut super::super::UIElement, out: *mut *mut AutomationPeer) -> HRESULT
}}
impl IFrameworkElementAutomationPeerStatics {
    #[inline] pub unsafe fn from_element(&self, element: &super::super::UIElement) -> Result<ComPtr<AutomationPeer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FromElement)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_peer_for_element(&self, element: &super::super::UIElement) -> Result<ComPtr<AutomationPeer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreatePeerForElement)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFrameworkElementAutomationPeerFactory, 230275260, 47122, 18659, 175, 31, 219, 197, 118, 0, 195, 37);
RT_INTERFACE!{interface IFrameworkElementAutomationPeerFactory(IFrameworkElementAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IFrameworkElementAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::FrameworkElement, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut FrameworkElementAutomationPeer) -> HRESULT
}}
impl IFrameworkElementAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::FrameworkElement, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<FrameworkElementAutomationPeer>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class FrameworkElementAutomationPeer: IFrameworkElementAutomationPeer}
impl RtActivatable<IFrameworkElementAutomationPeerStatics> for FrameworkElementAutomationPeer {}
impl FrameworkElementAutomationPeer {
    #[inline] pub fn from_element(element: &super::super::UIElement) -> Result<ComPtr<AutomationPeer>> { unsafe {
        <Self as RtActivatable<IFrameworkElementAutomationPeerStatics>>::get_activation_factory().from_element(element)
    }}
    #[inline] pub fn create_peer_for_element(element: &super::super::UIElement) -> Result<ComPtr<AutomationPeer>> { unsafe {
        <Self as RtActivatable<IFrameworkElementAutomationPeerStatics>>::get_activation_factory().create_peer_for_element(element)
    }}
}
DEFINE_CLSID!(FrameworkElementAutomationPeer(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,80,101,101,114,115,46,70,114,97,109,101,119,111,114,107,69,108,101,109,101,110,116,65,117,116,111,109,97,116,105,111,110,80,101,101,114,0]) [CLSID_FrameworkElementAutomationPeer]);
RT_CLASS!{class ButtonBaseAutomationPeer: IButtonBaseAutomationPeer}
RT_CLASS!{class CaptureElementAutomationPeer: ICaptureElementAutomationPeer}
RT_CLASS!{class ComboBoxItemAutomationPeer: IComboBoxItemAutomationPeer}
RT_CLASS!{class FlipViewItemAutomationPeer: IFlipViewItemAutomationPeer}
RT_CLASS!{class GroupItemAutomationPeer: IGroupItemAutomationPeer}
RT_CLASS!{class ImageAutomationPeer: IImageAutomationPeer}
RT_CLASS!{class ListBoxItemAutomationPeer: IListBoxItemAutomationPeer}
RT_CLASS!{class MediaTransportControlsAutomationPeer: IMediaTransportControlsAutomationPeer}
RT_CLASS!{class PasswordBoxAutomationPeer: IPasswordBoxAutomationPeer}
RT_CLASS!{class ProgressRingAutomationPeer: IProgressRingAutomationPeer}
RT_CLASS!{class RichTextBlockAutomationPeer: IRichTextBlockAutomationPeer}
RT_CLASS!{class RichTextBlockOverflowAutomationPeer: IRichTextBlockOverflowAutomationPeer}
RT_CLASS!{class SettingsFlyoutAutomationPeer: ISettingsFlyoutAutomationPeer}
RT_CLASS!{class TextBlockAutomationPeer: ITextBlockAutomationPeer}
RT_CLASS!{class TextBoxAutomationPeer: ITextBoxAutomationPeer}
RT_CLASS!{class ThumbAutomationPeer: IThumbAutomationPeer}
RT_CLASS!{class AutoSuggestBoxAutomationPeer: IAutoSuggestBoxAutomationPeer}
impl RtActivatable<IAutoSuggestBoxAutomationPeerFactory> for AutoSuggestBoxAutomationPeer {}
impl AutoSuggestBoxAutomationPeer {
    #[inline] pub fn create_instance_with_owner(owner: &super::super::controls::AutoSuggestBox) -> Result<ComPtr<AutoSuggestBoxAutomationPeer>> { unsafe {
        <Self as RtActivatable<IAutoSuggestBoxAutomationPeerFactory>>::get_activation_factory().create_instance_with_owner(owner)
    }}
}
DEFINE_CLSID!(AutoSuggestBoxAutomationPeer(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,80,101,101,114,115,46,65,117,116,111,83,117,103,103,101,115,116,66,111,120,65,117,116,111,109,97,116,105,111,110,80,101,101,114,0]) [CLSID_AutoSuggestBoxAutomationPeer]);
RT_CLASS!{class DatePickerAutomationPeer: IDatePickerAutomationPeer}
RT_CLASS!{class FlyoutPresenterAutomationPeer: IFlyoutPresenterAutomationPeer}
RT_CLASS!{class GridViewItemAutomationPeer: IGridViewItemAutomationPeer}
RT_CLASS!{class HubAutomationPeer: IHubAutomationPeer}
RT_CLASS!{class ListViewBaseHeaderItemAutomationPeer: IListViewBaseHeaderItemAutomationPeer}
RT_CLASS!{class ListViewItemAutomationPeer: IListViewItemAutomationPeer}
RT_CLASS!{class MediaElementAutomationPeer: IMediaElementAutomationPeer}
RT_CLASS!{class MediaPlayerElementAutomationPeer: IMediaPlayerElementAutomationPeer}
RT_CLASS!{class RichEditBoxAutomationPeer: IRichEditBoxAutomationPeer}
RT_CLASS!{class SearchBoxAutomationPeer: ISearchBoxAutomationPeer}
RT_CLASS!{class TimePickerAutomationPeer: ITimePickerAutomationPeer}
RT_CLASS!{class GridViewHeaderItemAutomationPeer: IGridViewHeaderItemAutomationPeer}
RT_CLASS!{class ListViewHeaderItemAutomationPeer: IListViewHeaderItemAutomationPeer}
RT_CLASS!{class ButtonAutomationPeer: IButtonAutomationPeer}
RT_CLASS!{class HyperlinkButtonAutomationPeer: IHyperlinkButtonAutomationPeer}
RT_CLASS!{class RepeatButtonAutomationPeer: IRepeatButtonAutomationPeer}
RT_CLASS!{class MenuFlyoutItemAutomationPeer: IMenuFlyoutItemAutomationPeer}
RT_CLASS!{class AppBarButtonAutomationPeer: IAppBarButtonAutomationPeer}
RT_CLASS!{class ItemsControlAutomationPeer: IItemsControlAutomationPeer}
RT_CLASS!{class MenuFlyoutPresenterAutomationPeer: IMenuFlyoutPresenterAutomationPeer}
RT_CLASS!{class RangeBaseAutomationPeer: IRangeBaseAutomationPeer}
RT_CLASS!{class ProgressBarAutomationPeer: IProgressBarAutomationPeer}
RT_CLASS!{class ScrollBarAutomationPeer: IScrollBarAutomationPeer}
RT_CLASS!{class SliderAutomationPeer: ISliderAutomationPeer}
RT_CLASS!{class HubSectionAutomationPeer: IHubSectionAutomationPeer}
RT_CLASS!{class ScrollViewerAutomationPeer: IScrollViewerAutomationPeer}
RT_CLASS!{class SelectorAutomationPeer: ISelectorAutomationPeer}
RT_CLASS!{class FlipViewAutomationPeer: IFlipViewAutomationPeer}
RT_CLASS!{class ListBoxAutomationPeer: IListBoxAutomationPeer}
RT_CLASS!{class ListViewBaseAutomationPeer: IListViewBaseAutomationPeer}
RT_CLASS!{class GridViewAutomationPeer: IGridViewAutomationPeer}
RT_CLASS!{class ListViewAutomationPeer: IListViewAutomationPeer}
RT_CLASS!{class SemanticZoomAutomationPeer: ISemanticZoomAutomationPeer}
RT_CLASS!{class ToggleSwitchAutomationPeer: IToggleSwitchAutomationPeer}
RT_CLASS!{class ToggleButtonAutomationPeer: IToggleButtonAutomationPeer}
RT_CLASS!{class CheckBoxAutomationPeer: ICheckBoxAutomationPeer}
RT_CLASS!{class RadioButtonAutomationPeer: IRadioButtonAutomationPeer}
RT_CLASS!{class ToggleMenuFlyoutItemAutomationPeer: IToggleMenuFlyoutItemAutomationPeer}
RT_CLASS!{class AppBarToggleButtonAutomationPeer: IAppBarToggleButtonAutomationPeer}
RT_CLASS!{class ItemAutomationPeer: IItemAutomationPeer}
RT_CLASS!{class SelectorItemAutomationPeer: ISelectorItemAutomationPeer}
RT_CLASS!{class ComboBoxItemDataAutomationPeer: IComboBoxItemDataAutomationPeer}
RT_CLASS!{class FlipViewItemDataAutomationPeer: IFlipViewItemDataAutomationPeer}
RT_CLASS!{class ListBoxItemDataAutomationPeer: IListBoxItemDataAutomationPeer}
RT_CLASS!{class GridViewItemDataAutomationPeer: IGridViewItemDataAutomationPeer}
RT_CLASS!{class ListViewItemDataAutomationPeer: IListViewItemDataAutomationPeer}
RT_CLASS!{class ComboBoxAutomationPeer: IComboBoxAutomationPeer}
RT_CLASS!{class AppBarAutomationPeer: IAppBarAutomationPeer}
DEFINE_IID!(IID_IInkToolbarAutomationPeer, 305900196, 62184, 19403, 147, 130, 93, 253, 209, 31, 228, 95);
RT_INTERFACE!{interface IInkToolbarAutomationPeer(IInkToolbarAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IInkToolbarAutomationPeer] {
    
}}
RT_CLASS!{class InkToolbarAutomationPeer: IInkToolbarAutomationPeer}
DEFINE_IID!(IID_IMapControlAutomationPeer, 1113321188, 62184, 19403, 147, 130, 93, 253, 209, 31, 228, 95);
RT_INTERFACE!{interface IMapControlAutomationPeer(IMapControlAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IMapControlAutomationPeer] {
    
}}
RT_CLASS!{class MapControlAutomationPeer: IMapControlAutomationPeer}
DEFINE_IID!(IID_ILoopingSelectorItemDataAutomationPeer, 4015423026, 31954, 19762, 149, 144, 31, 88, 141, 94, 243, 141);
RT_INTERFACE!{interface ILoopingSelectorItemDataAutomationPeer(ILoopingSelectorItemDataAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_ILoopingSelectorItemDataAutomationPeer] {
    
}}
RT_CLASS!{class LoopingSelectorItemDataAutomationPeer: ILoopingSelectorItemDataAutomationPeer}
DEFINE_IID!(IID_IDatePickerFlyoutPresenterAutomationPeer, 1965747512, 49855, 18560, 130, 178, 166, 192, 94, 144, 193, 53);
RT_INTERFACE!{interface IDatePickerFlyoutPresenterAutomationPeer(IDatePickerFlyoutPresenterAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IDatePickerFlyoutPresenterAutomationPeer] {
    
}}
RT_CLASS!{class DatePickerFlyoutPresenterAutomationPeer: IDatePickerFlyoutPresenterAutomationPeer}
DEFINE_IID!(IID_IListPickerFlyoutPresenterAutomationPeer, 1457511512, 9109, 16480, 128, 71, 142, 164, 99, 105, 138, 36);
RT_INTERFACE!{interface IListPickerFlyoutPresenterAutomationPeer(IListPickerFlyoutPresenterAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IListPickerFlyoutPresenterAutomationPeer] {
    
}}
RT_CLASS!{class ListPickerFlyoutPresenterAutomationPeer: IListPickerFlyoutPresenterAutomationPeer}
DEFINE_IID!(IID_ILoopingSelectorAutomationPeer, 1353975498, 47849, 18454, 138, 58, 12, 180, 249, 100, 120, 162);
RT_INTERFACE!{interface ILoopingSelectorAutomationPeer(ILoopingSelectorAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_ILoopingSelectorAutomationPeer] {
    
}}
RT_CLASS!{class LoopingSelectorAutomationPeer: ILoopingSelectorAutomationPeer}
DEFINE_IID!(IID_ILoopingSelectorItemAutomationPeer, 3556403391, 1231, 20300, 141, 62, 71, 128, 161, 157, 71, 136);
RT_INTERFACE!{interface ILoopingSelectorItemAutomationPeer(ILoopingSelectorItemAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_ILoopingSelectorItemAutomationPeer] {
    
}}
RT_CLASS!{class LoopingSelectorItemAutomationPeer: ILoopingSelectorItemAutomationPeer}
DEFINE_IID!(IID_IPickerFlyoutPresenterAutomationPeer, 675367927, 33666, 20142, 147, 193, 214, 240, 53, 170, 129, 85);
RT_INTERFACE!{interface IPickerFlyoutPresenterAutomationPeer(IPickerFlyoutPresenterAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IPickerFlyoutPresenterAutomationPeer] {
    
}}
RT_CLASS!{class PickerFlyoutPresenterAutomationPeer: IPickerFlyoutPresenterAutomationPeer}
DEFINE_IID!(IID_IPivotItemAutomationPeer, 440549805, 23893, 19751, 180, 15, 45, 55, 80, 111, 190, 120);
RT_INTERFACE!{interface IPivotItemAutomationPeer(IPivotItemAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IPivotItemAutomationPeer] {
    
}}
DEFINE_IID!(IID_IPivotItemAutomationPeerFactory, 4068541553, 6207, 16747, 180, 26, 30, 90, 149, 138, 145, 244);
RT_INTERFACE!{static interface IPivotItemAutomationPeerFactory(IPivotItemAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPivotItemAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::PivotItem, out: *mut *mut PivotItemAutomationPeer) -> HRESULT
}}
impl IPivotItemAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::PivotItem) -> Result<ComPtr<PivotItemAutomationPeer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PivotItemAutomationPeer: IPivotItemAutomationPeer}
impl RtActivatable<IPivotItemAutomationPeerFactory> for PivotItemAutomationPeer {}
impl PivotItemAutomationPeer {
    #[inline] pub fn create_instance_with_owner(owner: &super::super::controls::PivotItem) -> Result<ComPtr<PivotItemAutomationPeer>> { unsafe {
        <Self as RtActivatable<IPivotItemAutomationPeerFactory>>::get_activation_factory().create_instance_with_owner(owner)
    }}
}
DEFINE_CLSID!(PivotItemAutomationPeer(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,80,101,101,114,115,46,80,105,118,111,116,73,116,101,109,65,117,116,111,109,97,116,105,111,110,80,101,101,114,0]) [CLSID_PivotItemAutomationPeer]);
DEFINE_IID!(IID_IPivotItemDataAutomationPeer, 2728638344, 59933, 18615, 136, 238, 240, 139, 106, 160, 127, 238);
RT_INTERFACE!{interface IPivotItemDataAutomationPeer(IPivotItemDataAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IPivotItemDataAutomationPeer] {
    
}}
DEFINE_IID!(IID_IPivotItemDataAutomationPeerFactory, 1366959232, 54198, 16686, 130, 182, 148, 160, 168, 76, 19, 176);
RT_INTERFACE!{static interface IPivotItemDataAutomationPeerFactory(IPivotItemDataAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPivotItemDataAutomationPeerFactory] {
    fn CreateInstanceWithParentAndItem(&self, item: *mut IInspectable, parent: *mut PivotAutomationPeer, out: *mut *mut PivotItemDataAutomationPeer) -> HRESULT
}}
impl IPivotItemDataAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_parent_and_item(&self, item: &IInspectable, parent: &PivotAutomationPeer) -> Result<ComPtr<PivotItemDataAutomationPeer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithParentAndItem)(self as *const _ as *mut _, item as *const _ as *mut _, parent as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PivotItemDataAutomationPeer: IPivotItemDataAutomationPeer}
impl RtActivatable<IPivotItemDataAutomationPeerFactory> for PivotItemDataAutomationPeer {}
impl PivotItemDataAutomationPeer {
    #[inline] pub fn create_instance_with_parent_and_item(item: &IInspectable, parent: &PivotAutomationPeer) -> Result<ComPtr<PivotItemDataAutomationPeer>> { unsafe {
        <Self as RtActivatable<IPivotItemDataAutomationPeerFactory>>::get_activation_factory().create_instance_with_parent_and_item(item, parent)
    }}
}
DEFINE_CLSID!(PivotItemDataAutomationPeer(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,80,101,101,114,115,46,80,105,118,111,116,73,116,101,109,68,97,116,97,65,117,116,111,109,97,116,105,111,110,80,101,101,114,0]) [CLSID_PivotItemDataAutomationPeer]);
DEFINE_IID!(IID_ITimePickerFlyoutPresenterAutomationPeer, 3667127847, 33521, 18177, 135, 6, 190, 41, 123, 240, 96, 67);
RT_INTERFACE!{interface ITimePickerFlyoutPresenterAutomationPeer(ITimePickerFlyoutPresenterAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_ITimePickerFlyoutPresenterAutomationPeer] {
    
}}
RT_CLASS!{class TimePickerFlyoutPresenterAutomationPeer: ITimePickerFlyoutPresenterAutomationPeer}
DEFINE_IID!(IID_IPivotAutomationPeer, 3876956408, 15261, 16428, 129, 226, 110, 145, 46, 245, 137, 129);
RT_INTERFACE!{interface IPivotAutomationPeer(IPivotAutomationPeerVtbl): IInspectable(IInspectableVtbl) [IID_IPivotAutomationPeer] {
    
}}
RT_CLASS!{class PivotAutomationPeer: IPivotAutomationPeer}
impl RtActivatable<IPivotAutomationPeerFactory> for PivotAutomationPeer {}
impl PivotAutomationPeer {
    #[inline] pub fn create_instance_with_owner(owner: &super::super::controls::Pivot) -> Result<ComPtr<PivotAutomationPeer>> { unsafe {
        <Self as RtActivatable<IPivotAutomationPeerFactory>>::get_activation_factory().create_instance_with_owner(owner)
    }}
}
DEFINE_CLSID!(PivotAutomationPeer(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,65,117,116,111,109,97,116,105,111,110,46,80,101,101,114,115,46,80,105,118,111,116,65,117,116,111,109,97,116,105,111,110,80,101,101,114,0]) [CLSID_PivotAutomationPeer]);
DEFINE_IID!(IID_IPivotAutomationPeerFactory, 1056837524, 3217, 17217, 185, 172, 27, 86, 180, 230, 184, 79);
RT_INTERFACE!{static interface IPivotAutomationPeerFactory(IPivotAutomationPeerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPivotAutomationPeerFactory] {
    fn CreateInstanceWithOwner(&self, owner: *mut super::super::controls::Pivot, out: *mut *mut PivotAutomationPeer) -> HRESULT
}}
impl IPivotAutomationPeerFactory {
    #[inline] pub unsafe fn create_instance_with_owner(&self, owner: &super::super::controls::Pivot) -> Result<ComPtr<PivotAutomationPeer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithOwner)(self as *const _ as *mut _, owner as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
} // Windows.UI.Xaml.Automation.Peers
pub mod text { // Windows.UI.Xaml.Automation.Text
use ::prelude::*;
RT_ENUM! { enum TextPatternRangeEndpoint: i32 {
    Start (TextPatternRangeEndpoint_Start) = 0, End (TextPatternRangeEndpoint_End) = 1,
}}
RT_ENUM! { enum TextUnit: i32 {
    Character (TextUnit_Character) = 0, Format (TextUnit_Format) = 1, Word (TextUnit_Word) = 2, Line (TextUnit_Line) = 3, Paragraph (TextUnit_Paragraph) = 4, Page (TextUnit_Page) = 5, Document (TextUnit_Document) = 6,
}}
} // Windows.UI.Xaml.Automation.Text
pub mod provider { // Windows.UI.Xaml.Automation.Provider
use ::prelude::*;
DEFINE_IID!(IID_IAnnotationProvider, 2512000023, 17463, 17691, 148, 97, 5, 10, 73, 181, 157, 6);
RT_INTERFACE!{interface IAnnotationProvider(IAnnotationProviderVtbl): IInspectable(IInspectableVtbl) [IID_IAnnotationProvider] {
    fn get_AnnotationTypeId(&self, out: *mut i32) -> HRESULT,
    fn get_AnnotationTypeName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Author(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DateTime(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Target(&self, out: *mut *mut IRawElementProviderSimple) -> HRESULT
}}
impl IAnnotationProvider {
    #[inline] pub unsafe fn get_annotation_type_id(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AnnotationTypeId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_annotation_type_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AnnotationTypeName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_author(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Author)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_date_time(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DateTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_target(&self) -> Result<ComPtr<IRawElementProviderSimple>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Target)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDockProvider, 1220690936, 30897, 17568, 172, 95, 117, 7, 87, 188, 222, 60);
RT_INTERFACE!{interface IDockProvider(IDockProviderVtbl): IInspectable(IInspectableVtbl) [IID_IDockProvider] {
    fn get_DockPosition(&self, out: *mut super::DockPosition) -> HRESULT,
    fn SetDockPosition(&self, dockPosition: super::DockPosition) -> HRESULT
}}
impl IDockProvider {
    #[inline] pub unsafe fn get_dock_position(&self) -> Result<super::DockPosition> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DockPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_dock_position(&self, dockPosition: super::DockPosition) -> Result<()> {
        let hr = ((*self.lpVtbl).SetDockPosition)(self as *const _ as *mut _, dockPosition);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDragProvider, 779585193, 32764, 20311, 185, 101, 30, 241, 243, 115, 245, 70);
RT_INTERFACE!{interface IDragProvider(IDragProviderVtbl): IInspectable(IInspectableVtbl) [IID_IDragProvider] {
    fn get_IsGrabbed(&self, out: *mut bool) -> HRESULT,
    fn get_DropEffect(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DropEffects(&self, outSize: *mut u32, out: *mut *mut HSTRING) -> HRESULT,
    fn GetGrabbedItems(&self, outSize: *mut u32, out: *mut *mut *mut IRawElementProviderSimple) -> HRESULT
}}
impl IDragProvider {
    #[inline] pub unsafe fn get_is_grabbed(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsGrabbed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drop_effect(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DropEffect)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drop_effects(&self) -> Result<ComArray<HString>> {
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DropEffects)(self as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_grabbed_items(&self) -> Result<ComArray<IRawElementProviderSimple>> {
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetGrabbedItems)(self as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDropTargetProvider, 2049203165, 46168, 20448, 152, 200, 170, 200, 157, 245, 109, 97);
RT_INTERFACE!{interface IDropTargetProvider(IDropTargetProviderVtbl): IInspectable(IInspectableVtbl) [IID_IDropTargetProvider] {
    fn get_DropEffect(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DropEffects(&self, outSize: *mut u32, out: *mut *mut HSTRING) -> HRESULT
}}
impl IDropTargetProvider {
    #[inline] pub unsafe fn get_drop_effect(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DropEffect)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drop_effects(&self) -> Result<ComArray<HString>> {
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DropEffects)(self as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IExpandCollapseProvider, 1236042649, 54822, 17731, 148, 185, 166, 217, 169, 89, 58, 246);
RT_INTERFACE!{interface IExpandCollapseProvider(IExpandCollapseProviderVtbl): IInspectable(IInspectableVtbl) [IID_IExpandCollapseProvider] {
    fn get_ExpandCollapseState(&self, out: *mut super::ExpandCollapseState) -> HRESULT,
    fn Collapse(&self) -> HRESULT,
    fn Expand(&self) -> HRESULT
}}
impl IExpandCollapseProvider {
    #[inline] pub unsafe fn get_expand_collapse_state(&self) -> Result<super::ExpandCollapseState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExpandCollapseState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn collapse(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Collapse)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn expand(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Expand)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGridItemProvider, 4294142012, 29703, 17851, 169, 54, 223, 62, 214, 211, 131, 125);
RT_INTERFACE!{interface IGridItemProvider(IGridItemProviderVtbl): IInspectable(IInspectableVtbl) [IID_IGridItemProvider] {
    fn get_Column(&self, out: *mut i32) -> HRESULT,
    fn get_ColumnSpan(&self, out: *mut i32) -> HRESULT,
    fn get_ContainingGrid(&self, out: *mut *mut IRawElementProviderSimple) -> HRESULT,
    fn get_Row(&self, out: *mut i32) -> HRESULT,
    fn get_RowSpan(&self, out: *mut i32) -> HRESULT
}}
impl IGridItemProvider {
    #[inline] pub unsafe fn get_column(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Column)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_column_span(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ColumnSpan)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_containing_grid(&self) -> Result<ComPtr<IRawElementProviderSimple>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContainingGrid)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_row(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Row)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_row_span(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RowSpan)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGridProvider, 2338502560, 37676, 17552, 154, 19, 2, 253, 179, 154, 143, 91);
RT_INTERFACE!{interface IGridProvider(IGridProviderVtbl): IInspectable(IInspectableVtbl) [IID_IGridProvider] {
    fn get_ColumnCount(&self, out: *mut i32) -> HRESULT,
    fn get_RowCount(&self, out: *mut i32) -> HRESULT,
    fn GetItem(&self, row: i32, column: i32, out: *mut *mut IRawElementProviderSimple) -> HRESULT
}}
impl IGridProvider {
    #[inline] pub unsafe fn get_column_count(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ColumnCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_row_count(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RowCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item(&self, row: i32, column: i32) -> Result<ComPtr<IRawElementProviderSimple>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetItem)(self as *const _ as *mut _, row, column, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IInvokeProvider, 4157710727, 45372, 17728, 176, 158, 103, 120, 226, 220, 155, 165);
RT_INTERFACE!{interface IInvokeProvider(IInvokeProviderVtbl): IInspectable(IInspectableVtbl) [IID_IInvokeProvider] {
    fn Invoke(&self) -> HRESULT
}}
impl IInvokeProvider {
    #[inline] pub unsafe fn invoke(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemContainerProvider, 4015839301, 57812, 16628, 186, 213, 199, 250, 212, 74, 112, 62);
RT_INTERFACE!{interface IItemContainerProvider(IItemContainerProviderVtbl): IInspectable(IInspectableVtbl) [IID_IItemContainerProvider] {
    fn FindItemByProperty(&self, startAfter: *mut IRawElementProviderSimple, automationProperty: *mut super::AutomationProperty, value: *mut IInspectable, out: *mut *mut IRawElementProviderSimple) -> HRESULT
}}
impl IItemContainerProvider {
    #[inline] pub unsafe fn find_item_by_property(&self, startAfter: &IRawElementProviderSimple, automationProperty: &super::AutomationProperty, value: &IInspectable) -> Result<ComPtr<IRawElementProviderSimple>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindItemByProperty)(self as *const _ as *mut _, startAfter as *const _ as *mut _, automationProperty as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMultipleViewProvider, 3491029398, 3664, 18499, 165, 210, 194, 40, 151, 200, 132, 90);
RT_INTERFACE!{interface IMultipleViewProvider(IMultipleViewProviderVtbl): IInspectable(IInspectableVtbl) [IID_IMultipleViewProvider] {
    fn get_CurrentView(&self, out: *mut i32) -> HRESULT,
    fn GetSupportedViews(&self, outSize: *mut u32, out: *mut *mut i32) -> HRESULT,
    fn GetViewName(&self, viewId: i32, out: *mut HSTRING) -> HRESULT,
    fn SetCurrentView(&self, viewId: i32) -> HRESULT
}}
impl IMultipleViewProvider {
    #[inline] pub unsafe fn get_current_view(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_supported_views(&self) -> Result<ComArray<i32>> {
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetSupportedViews)(self as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_view_name(&self, viewId: i32) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetViewName)(self as *const _ as *mut _, viewId, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_current_view(&self, viewId: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetCurrentView)(self as *const _ as *mut _, viewId);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IObjectModelProvider, 3284809401, 1939, 20176, 187, 244, 159, 244, 224, 249, 143, 128);
RT_INTERFACE!{interface IObjectModelProvider(IObjectModelProviderVtbl): IInspectable(IInspectableVtbl) [IID_IObjectModelProvider] {
    fn GetUnderlyingObjectModel(&self, out: *mut *mut IInspectable) -> HRESULT
}}
impl IObjectModelProvider {
    #[inline] pub unsafe fn get_underlying_object_model(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetUnderlyingObjectModel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRangeValueProvider, 2206872744, 32095, 16505, 175, 3, 195, 208, 21, 233, 52, 19);
RT_INTERFACE!{interface IRangeValueProvider(IRangeValueProviderVtbl): IInspectable(IInspectableVtbl) [IID_IRangeValueProvider] {
    fn get_IsReadOnly(&self, out: *mut bool) -> HRESULT,
    fn get_LargeChange(&self, out: *mut f64) -> HRESULT,
    fn get_Maximum(&self, out: *mut f64) -> HRESULT,
    fn get_Minimum(&self, out: *mut f64) -> HRESULT,
    fn get_SmallChange(&self, out: *mut f64) -> HRESULT,
    fn get_Value(&self, out: *mut f64) -> HRESULT,
    fn SetValue(&self, value: f64) -> HRESULT
}}
impl IRangeValueProvider {
    #[inline] pub unsafe fn get_is_read_only(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsReadOnly)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_large_change(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LargeChange)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_maximum(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Maximum)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_minimum(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Minimum)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_small_change(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SmallChange)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_value(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Value)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_value(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).SetValue)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IScrollItemProvider, 2587803792, 23852, 20034, 158, 230, 157, 88, 219, 16, 11, 85);
RT_INTERFACE!{interface IScrollItemProvider(IScrollItemProviderVtbl): IInspectable(IInspectableVtbl) [IID_IScrollItemProvider] {
    fn ScrollIntoView(&self) -> HRESULT
}}
impl IScrollItemProvider {
    #[inline] pub unsafe fn scroll_into_view(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ScrollIntoView)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IScrollProvider, 927724929, 30486, 19388, 130, 235, 217, 151, 0, 110, 169, 153);
RT_INTERFACE!{interface IScrollProvider(IScrollProviderVtbl): IInspectable(IInspectableVtbl) [IID_IScrollProvider] {
    fn get_HorizontallyScrollable(&self, out: *mut bool) -> HRESULT,
    fn get_HorizontalScrollPercent(&self, out: *mut f64) -> HRESULT,
    fn get_HorizontalViewSize(&self, out: *mut f64) -> HRESULT,
    fn get_VerticallyScrollable(&self, out: *mut bool) -> HRESULT,
    fn get_VerticalScrollPercent(&self, out: *mut f64) -> HRESULT,
    fn get_VerticalViewSize(&self, out: *mut f64) -> HRESULT,
    fn Scroll(&self, horizontalAmount: super::ScrollAmount, verticalAmount: super::ScrollAmount) -> HRESULT,
    fn SetScrollPercent(&self, horizontalPercent: f64, verticalPercent: f64) -> HRESULT
}}
impl IScrollProvider {
    #[inline] pub unsafe fn get_horizontally_scrollable(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontallyScrollable)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_scroll_percent(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalScrollPercent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_horizontal_view_size(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalViewSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertically_scrollable(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticallyScrollable)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_scroll_percent(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalScrollPercent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_vertical_view_size(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalViewSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn scroll(&self, horizontalAmount: super::ScrollAmount, verticalAmount: super::ScrollAmount) -> Result<()> {
        let hr = ((*self.lpVtbl).Scroll)(self as *const _ as *mut _, horizontalAmount, verticalAmount);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_scroll_percent(&self, horizontalPercent: f64, verticalPercent: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).SetScrollPercent)(self as *const _ as *mut _, horizontalPercent, verticalPercent);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISelectionItemProvider, 1783199681, 33549, 17106, 191, 98, 4, 46, 189, 222, 204, 25);
RT_INTERFACE!{interface ISelectionItemProvider(ISelectionItemProviderVtbl): IInspectable(IInspectableVtbl) [IID_ISelectionItemProvider] {
    fn get_IsSelected(&self, out: *mut bool) -> HRESULT,
    fn get_SelectionContainer(&self, out: *mut *mut IRawElementProviderSimple) -> HRESULT,
    fn AddToSelection(&self) -> HRESULT,
    fn RemoveFromSelection(&self) -> HRESULT,
    fn Select(&self) -> HRESULT
}}
impl ISelectionItemProvider {
    #[inline] pub unsafe fn get_is_selected(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSelected)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_container(&self) -> Result<ComPtr<IRawElementProviderSimple>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionContainer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_to_selection(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).AddToSelection)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_from_selection(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).RemoveFromSelection)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn select(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Select)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISelectionProvider, 520196042, 47428, 17301, 141, 225, 136, 246, 116, 175, 81, 211);
RT_INTERFACE!{interface ISelectionProvider(ISelectionProviderVtbl): IInspectable(IInspectableVtbl) [IID_ISelectionProvider] {
    fn get_CanSelectMultiple(&self, out: *mut bool) -> HRESULT,
    fn get_IsSelectionRequired(&self, out: *mut bool) -> HRESULT,
    fn GetSelection(&self, outSize: *mut u32, out: *mut *mut *mut IRawElementProviderSimple) -> HRESULT
}}
impl ISelectionProvider {
    #[inline] pub unsafe fn get_can_select_multiple(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanSelectMultiple)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_selection_required(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSelectionRequired)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection(&self) -> Result<ComArray<IRawElementProviderSimple>> {
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetSelection)(self as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISpreadsheetItemProvider, 3957231506, 24597, 18470, 183, 25, 71, 82, 26, 129, 198, 126);
RT_INTERFACE!{interface ISpreadsheetItemProvider(ISpreadsheetItemProviderVtbl): IInspectable(IInspectableVtbl) [IID_ISpreadsheetItemProvider] {
    fn get_Formula(&self, out: *mut HSTRING) -> HRESULT,
    fn GetAnnotationObjects(&self, outSize: *mut u32, out: *mut *mut *mut IRawElementProviderSimple) -> HRESULT,
    fn GetAnnotationTypes(&self, outSize: *mut u32, out: *mut *mut super::AnnotationType) -> HRESULT
}}
impl ISpreadsheetItemProvider {
    #[inline] pub unsafe fn get_formula(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Formula)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_annotation_objects(&self) -> Result<ComArray<IRawElementProviderSimple>> {
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAnnotationObjects)(self as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_annotation_types(&self) -> Result<ComArray<super::AnnotationType>> {
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAnnotationTypes)(self as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISpreadsheetProvider, 355831955, 48537, 19709, 159, 7, 59, 20, 179, 21, 226, 61);
RT_INTERFACE!{interface ISpreadsheetProvider(ISpreadsheetProviderVtbl): IInspectable(IInspectableVtbl) [IID_ISpreadsheetProvider] {
    fn GetItemByName(&self, name: HSTRING, out: *mut *mut IRawElementProviderSimple) -> HRESULT
}}
impl ISpreadsheetProvider {
    #[inline] pub unsafe fn get_item_by_name(&self, name: &HStringArg) -> Result<ComPtr<IRawElementProviderSimple>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetItemByName)(self as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IStylesProvider, 442202647, 31745, 19436, 156, 212, 45, 250, 125, 194, 70, 205);
RT_INTERFACE!{interface IStylesProvider(IStylesProviderVtbl): IInspectable(IInspectableVtbl) [IID_IStylesProvider] {
    fn get_ExtendedProperties(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FillColor(&self, out: *mut super::super::super::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FillPatternColor(&self, out: *mut super::super::super::Color) -> HRESULT,
    fn get_FillPatternStyle(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Shape(&self, out: *mut HSTRING) -> HRESULT,
    fn get_StyleId(&self, out: *mut i32) -> HRESULT,
    fn get_StyleName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IStylesProvider {
    #[inline] pub unsafe fn get_extended_properties(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExtendedProperties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_fill_color(&self) -> Result<super::super::super::Color> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FillColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_fill_pattern_color(&self) -> Result<super::super::super::Color> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FillPatternColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_fill_pattern_style(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FillPatternStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_shape(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Shape)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_style_id(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StyleId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_style_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StyleName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISynchronizedInputProvider, 1029754571, 55892, 19107, 185, 21, 227, 36, 68, 39, 212, 172);
RT_INTERFACE!{interface ISynchronizedInputProvider(ISynchronizedInputProviderVtbl): IInspectable(IInspectableVtbl) [IID_ISynchronizedInputProvider] {
    fn Cancel(&self) -> HRESULT,
    fn StartListening(&self, inputType: super::SynchronizedInputType) -> HRESULT
}}
impl ISynchronizedInputProvider {
    #[inline] pub unsafe fn cancel(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Cancel)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn start_listening(&self, inputType: super::SynchronizedInputType) -> Result<()> {
        let hr = ((*self.lpVtbl).StartListening)(self as *const _ as *mut _, inputType);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITableItemProvider, 992758221, 7650, 20194, 163, 225, 251, 85, 53, 89, 209, 93);
RT_INTERFACE!{interface ITableItemProvider(ITableItemProviderVtbl): IInspectable(IInspectableVtbl) [IID_ITableItemProvider] {
    fn GetColumnHeaderItems(&self, outSize: *mut u32, out: *mut *mut *mut IRawElementProviderSimple) -> HRESULT,
    fn GetRowHeaderItems(&self, outSize: *mut u32, out: *mut *mut *mut IRawElementProviderSimple) -> HRESULT
}}
impl ITableItemProvider {
    #[inline] pub unsafe fn get_column_header_items(&self) -> Result<ComArray<IRawElementProviderSimple>> {
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetColumnHeaderItems)(self as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_row_header_items(&self) -> Result<ComArray<IRawElementProviderSimple>> {
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetRowHeaderItems)(self as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITableProvider, 2056180633, 26660, 17813, 186, 179, 70, 75, 201, 160, 68, 23);
RT_INTERFACE!{interface ITableProvider(ITableProviderVtbl): IInspectable(IInspectableVtbl) [IID_ITableProvider] {
    fn get_RowOrColumnMajor(&self, out: *mut super::RowOrColumnMajor) -> HRESULT,
    fn GetColumnHeaders(&self, outSize: *mut u32, out: *mut *mut *mut IRawElementProviderSimple) -> HRESULT,
    fn GetRowHeaders(&self, outSize: *mut u32, out: *mut *mut *mut IRawElementProviderSimple) -> HRESULT
}}
impl ITableProvider {
    #[inline] pub unsafe fn get_row_or_column_major(&self) -> Result<super::RowOrColumnMajor> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RowOrColumnMajor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_column_headers(&self) -> Result<ComArray<IRawElementProviderSimple>> {
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetColumnHeaders)(self as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_row_headers(&self) -> Result<ComArray<IRawElementProviderSimple>> {
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetRowHeaders)(self as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextChildProvider, 288604982, 43163, 16688, 155, 230, 85, 227, 51, 52, 245, 87);
RT_INTERFACE!{interface ITextChildProvider(ITextChildProviderVtbl): IInspectable(IInspectableVtbl) [IID_ITextChildProvider] {
    fn get_TextContainer(&self, out: *mut *mut IRawElementProviderSimple) -> HRESULT,
    fn get_TextRange(&self, out: *mut *mut ITextRangeProvider) -> HRESULT
}}
impl ITextChildProvider {
    #[inline] pub unsafe fn get_text_container(&self) -> Result<ComPtr<IRawElementProviderSimple>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextContainer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_range(&self) -> Result<ComPtr<ITextRangeProvider>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextRange)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextRangeProvider, 41183373, 1769, 20326, 148, 70, 40, 165, 190, 152, 251, 208);
RT_INTERFACE!{interface ITextRangeProvider(ITextRangeProviderVtbl): IInspectable(IInspectableVtbl) [IID_ITextRangeProvider] {
    fn Clone(&self, out: *mut *mut ITextRangeProvider) -> HRESULT,
    fn Compare(&self, textRangeProvider: *mut ITextRangeProvider, out: *mut bool) -> HRESULT,
    fn CompareEndpoints(&self, endpoint: super::text::TextPatternRangeEndpoint, textRangeProvider: *mut ITextRangeProvider, targetEndpoint: super::text::TextPatternRangeEndpoint, out: *mut i32) -> HRESULT,
    fn ExpandToEnclosingUnit(&self, unit: super::text::TextUnit) -> HRESULT,
    fn FindAttribute(&self, attributeId: i32, value: *mut IInspectable, backward: bool, out: *mut *mut ITextRangeProvider) -> HRESULT,
    fn FindText(&self, text: HSTRING, backward: bool, ignoreCase: bool, out: *mut *mut ITextRangeProvider) -> HRESULT,
    fn GetAttributeValue(&self, attributeId: i32, out: *mut *mut IInspectable) -> HRESULT,
    fn GetBoundingRectangles(&self, returnValueSize: *mut u32, returnValue: *mut *mut f64) -> HRESULT,
    fn GetEnclosingElement(&self, out: *mut *mut IRawElementProviderSimple) -> HRESULT,
    fn GetText(&self, maxLength: i32, out: *mut HSTRING) -> HRESULT,
    fn Move(&self, unit: super::text::TextUnit, count: i32, out: *mut i32) -> HRESULT,
    fn MoveEndpointByUnit(&self, endpoint: super::text::TextPatternRangeEndpoint, unit: super::text::TextUnit, count: i32, out: *mut i32) -> HRESULT,
    fn MoveEndpointByRange(&self, endpoint: super::text::TextPatternRangeEndpoint, textRangeProvider: *mut ITextRangeProvider, targetEndpoint: super::text::TextPatternRangeEndpoint) -> HRESULT,
    fn Select(&self) -> HRESULT,
    fn AddToSelection(&self) -> HRESULT,
    fn RemoveFromSelection(&self) -> HRESULT,
    fn ScrollIntoView(&self, alignToTop: bool) -> HRESULT,
    fn GetChildren(&self, outSize: *mut u32, out: *mut *mut *mut IRawElementProviderSimple) -> HRESULT
}}
impl ITextRangeProvider {
    #[inline] pub unsafe fn clone(&self) -> Result<ComPtr<ITextRangeProvider>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Clone)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn compare(&self, textRangeProvider: &ITextRangeProvider) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Compare)(self as *const _ as *mut _, textRangeProvider as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn compare_endpoints(&self, endpoint: super::text::TextPatternRangeEndpoint, textRangeProvider: &ITextRangeProvider, targetEndpoint: super::text::TextPatternRangeEndpoint) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).CompareEndpoints)(self as *const _ as *mut _, endpoint, textRangeProvider as *const _ as *mut _, targetEndpoint, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn expand_to_enclosing_unit(&self, unit: super::text::TextUnit) -> Result<()> {
        let hr = ((*self.lpVtbl).ExpandToEnclosingUnit)(self as *const _ as *mut _, unit);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_attribute(&self, attributeId: i32, value: &IInspectable, backward: bool) -> Result<ComPtr<ITextRangeProvider>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAttribute)(self as *const _ as *mut _, attributeId, value as *const _ as *mut _, backward, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_text(&self, text: &HStringArg, backward: bool, ignoreCase: bool) -> Result<ComPtr<ITextRangeProvider>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindText)(self as *const _ as *mut _, text.get(), backward, ignoreCase, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_attribute_value(&self, attributeId: i32) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAttributeValue)(self as *const _ as *mut _, attributeId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_bounding_rectangles(&self) -> Result<ComArray<f64>> {
        let mut returnValueSize = 0; let mut returnValue = null_mut();
        let hr = ((*self.lpVtbl).GetBoundingRectangles)(self as *const _ as *mut _, &mut returnValueSize, &mut returnValue);
        if hr == S_OK { Ok(ComArray::from_raw(returnValueSize, returnValue)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_enclosing_element(&self) -> Result<ComPtr<IRawElementProviderSimple>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetEnclosingElement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text(&self, maxLength: i32) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetText)(self as *const _ as *mut _, maxLength, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn move_(&self, unit: super::text::TextUnit, count: i32) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Move)(self as *const _ as *mut _, unit, count, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn move_endpoint_by_unit(&self, endpoint: super::text::TextPatternRangeEndpoint, unit: super::text::TextUnit, count: i32) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).MoveEndpointByUnit)(self as *const _ as *mut _, endpoint, unit, count, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn move_endpoint_by_range(&self, endpoint: super::text::TextPatternRangeEndpoint, textRangeProvider: &ITextRangeProvider, targetEndpoint: super::text::TextPatternRangeEndpoint) -> Result<()> {
        let hr = ((*self.lpVtbl).MoveEndpointByRange)(self as *const _ as *mut _, endpoint, textRangeProvider as *const _ as *mut _, targetEndpoint);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn select(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Select)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_to_selection(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).AddToSelection)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_from_selection(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).RemoveFromSelection)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn scroll_into_view(&self, alignToTop: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).ScrollIntoView)(self as *const _ as *mut _, alignToTop);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_children(&self) -> Result<ComArray<IRawElementProviderSimple>> {
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetChildren)(self as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextProvider, 3680222367, 18439, 20266, 134, 120, 27, 19, 243, 198, 14, 34);
RT_INTERFACE!{interface ITextProvider(ITextProviderVtbl): IInspectable(IInspectableVtbl) [IID_ITextProvider] {
    fn get_DocumentRange(&self, out: *mut *mut ITextRangeProvider) -> HRESULT,
    fn get_SupportedTextSelection(&self, out: *mut super::SupportedTextSelection) -> HRESULT,
    fn GetSelection(&self, outSize: *mut u32, out: *mut *mut *mut ITextRangeProvider) -> HRESULT,
    fn GetVisibleRanges(&self, outSize: *mut u32, out: *mut *mut *mut ITextRangeProvider) -> HRESULT,
    fn RangeFromChild(&self, childElement: *mut IRawElementProviderSimple, out: *mut *mut ITextRangeProvider) -> HRESULT,
    fn RangeFromPoint(&self, screenLocation: ::rt::gen::windows::foundation::Point, out: *mut *mut ITextRangeProvider) -> HRESULT
}}
impl ITextProvider {
    #[inline] pub unsafe fn get_document_range(&self) -> Result<ComPtr<ITextRangeProvider>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DocumentRange)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_supported_text_selection(&self) -> Result<super::SupportedTextSelection> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SupportedTextSelection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection(&self) -> Result<ComArray<ITextRangeProvider>> {
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetSelection)(self as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_visible_ranges(&self) -> Result<ComArray<ITextRangeProvider>> {
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetVisibleRanges)(self as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn range_from_child(&self, childElement: &IRawElementProviderSimple) -> Result<ComPtr<ITextRangeProvider>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RangeFromChild)(self as *const _ as *mut _, childElement as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn range_from_point(&self, screenLocation: ::rt::gen::windows::foundation::Point) -> Result<ComPtr<ITextRangeProvider>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RangeFromPoint)(self as *const _ as *mut _, screenLocation, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextProvider2, 3743238332, 1159, 20095, 157, 94, 240, 158, 119, 228, 18, 70);
RT_INTERFACE!{interface ITextProvider2(ITextProvider2Vtbl): IInspectable(IInspectableVtbl) [IID_ITextProvider2] {
    fn RangeFromAnnotation(&self, annotationElement: *mut IRawElementProviderSimple, out: *mut *mut ITextRangeProvider) -> HRESULT,
    fn GetCaretRange(&self, isActive: *mut bool, out: *mut *mut ITextRangeProvider) -> HRESULT
}}
impl ITextProvider2 {
    #[inline] pub unsafe fn range_from_annotation(&self, annotationElement: &IRawElementProviderSimple) -> Result<ComPtr<ITextRangeProvider>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RangeFromAnnotation)(self as *const _ as *mut _, annotationElement as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_caret_range(&self) -> Result<(bool, ComPtr<ITextRangeProvider>)> {
        let mut isActive = zeroed(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetCaretRange)(self as *const _ as *mut _, &mut isActive, &mut out);
        if hr == S_OK { Ok((isActive, ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextRangeProvider2, 3552460283, 40788, 17986, 167, 165, 92, 24, 213, 238, 42, 63);
RT_INTERFACE!{interface ITextRangeProvider2(ITextRangeProvider2Vtbl): IInspectable(IInspectableVtbl) [IID_ITextRangeProvider2] {
    fn ShowContextMenu(&self) -> HRESULT
}}
impl ITextRangeProvider2 {
    #[inline] pub unsafe fn show_context_menu(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ShowContextMenu)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IToggleProvider, 2478342800, 25967, 17655, 174, 175, 120, 184, 249, 68, 208, 98);
RT_INTERFACE!{interface IToggleProvider(IToggleProviderVtbl): IInspectable(IInspectableVtbl) [IID_IToggleProvider] {
    fn get_ToggleState(&self, out: *mut super::ToggleState) -> HRESULT,
    fn Toggle(&self) -> HRESULT
}}
impl IToggleProvider {
    #[inline] pub unsafe fn get_toggle_state(&self) -> Result<super::ToggleState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ToggleState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn toggle(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Toggle)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITransformProvider, 2036797405, 63145, 19045, 175, 23, 134, 29, 183, 153, 162, 218);
RT_INTERFACE!{interface ITransformProvider(ITransformProviderVtbl): IInspectable(IInspectableVtbl) [IID_ITransformProvider] {
    fn get_CanMove(&self, out: *mut bool) -> HRESULT,
    fn get_CanResize(&self, out: *mut bool) -> HRESULT,
    fn get_CanRotate(&self, out: *mut bool) -> HRESULT,
    fn Move(&self, x: f64, y: f64) -> HRESULT,
    fn Resize(&self, width: f64, height: f64) -> HRESULT,
    fn Rotate(&self, degrees: f64) -> HRESULT
}}
impl ITransformProvider {
    #[inline] pub unsafe fn get_can_move(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanMove)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_resize(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanResize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_rotate(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanRotate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn move_(&self, x: f64, y: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).Move)(self as *const _ as *mut _, x, y);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn resize(&self, width: f64, height: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).Resize)(self as *const _ as *mut _, width, height);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn rotate(&self, degrees: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).Rotate)(self as *const _ as *mut _, degrees);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITransformProvider2, 2830178134, 41887, 20119, 140, 125, 193, 234, 141, 214, 51, 197);
RT_INTERFACE!{interface ITransformProvider2(ITransformProvider2Vtbl): IInspectable(IInspectableVtbl) [IID_ITransformProvider2] {
    fn get_CanZoom(&self, out: *mut bool) -> HRESULT,
    fn get_ZoomLevel(&self, out: *mut f64) -> HRESULT,
    fn get_MaxZoom(&self, out: *mut f64) -> HRESULT,
    fn get_MinZoom(&self, out: *mut f64) -> HRESULT,
    fn Zoom(&self, zoom: f64) -> HRESULT,
    fn ZoomByUnit(&self, zoomUnit: super::ZoomUnit) -> HRESULT
}}
impl ITransformProvider2 {
    #[inline] pub unsafe fn get_can_zoom(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanZoom)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_zoom_level(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ZoomLevel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_zoom(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxZoom)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_zoom(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinZoom)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn zoom(&self, zoom: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).Zoom)(self as *const _ as *mut _, zoom);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn zoom_by_unit(&self, zoomUnit: super::ZoomUnit) -> Result<()> {
        let hr = ((*self.lpVtbl).ZoomByUnit)(self as *const _ as *mut _, zoomUnit);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IValueProvider, 545699751, 44046, 18385, 171, 155, 42, 100, 41, 42, 253, 248);
RT_INTERFACE!{interface IValueProvider(IValueProviderVtbl): IInspectable(IInspectableVtbl) [IID_IValueProvider] {
    fn get_IsReadOnly(&self, out: *mut bool) -> HRESULT,
    fn get_Value(&self, out: *mut HSTRING) -> HRESULT,
    fn SetValue(&self, value: HSTRING) -> HRESULT
}}
impl IValueProvider {
    #[inline] pub unsafe fn get_is_read_only(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsReadOnly)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_value(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Value)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_value(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetValue)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVirtualizedItemProvider, 399810635, 54872, 18656, 165, 116, 90, 81, 108, 88, 223, 167);
RT_INTERFACE!{interface IVirtualizedItemProvider(IVirtualizedItemProviderVtbl): IInspectable(IInspectableVtbl) [IID_IVirtualizedItemProvider] {
    fn Realize(&self) -> HRESULT
}}
impl IVirtualizedItemProvider {
    #[inline] pub unsafe fn realize(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Realize)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWindowProvider, 464161597, 14543, 16730, 133, 211, 32, 228, 58, 14, 193, 177);
RT_INTERFACE!{interface IWindowProvider(IWindowProviderVtbl): IInspectable(IInspectableVtbl) [IID_IWindowProvider] {
    fn get_IsModal(&self, out: *mut bool) -> HRESULT,
    fn get_IsTopmost(&self, out: *mut bool) -> HRESULT,
    fn get_Maximizable(&self, out: *mut bool) -> HRESULT,
    fn get_Minimizable(&self, out: *mut bool) -> HRESULT,
    fn get_InteractionState(&self, out: *mut super::WindowInteractionState) -> HRESULT,
    fn get_VisualState(&self, out: *mut super::WindowVisualState) -> HRESULT,
    fn Close(&self) -> HRESULT,
    fn SetVisualState(&self, state: super::WindowVisualState) -> HRESULT,
    fn WaitForInputIdle(&self, milliseconds: i32, out: *mut bool) -> HRESULT
}}
impl IWindowProvider {
    #[inline] pub unsafe fn get_is_modal(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsModal)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_topmost(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTopmost)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_maximizable(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Maximizable)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_minimizable(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Minimizable)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_interaction_state(&self) -> Result<super::WindowInteractionState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InteractionState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_visual_state(&self) -> Result<super::WindowVisualState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VisualState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn close(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Close)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_visual_state(&self, state: super::WindowVisualState) -> Result<()> {
        let hr = ((*self.lpVtbl).SetVisualState)(self as *const _ as *mut _, state);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn wait_for_input_idle(&self, milliseconds: i32) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).WaitForInputIdle)(self as *const _ as *mut _, milliseconds, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IIRawElementProviderSimple, 3967099428, 39799, 18208, 187, 33, 74, 200, 159, 219, 26, 253);
RT_INTERFACE!{interface IIRawElementProviderSimple(IIRawElementProviderSimpleVtbl): IInspectable(IInspectableVtbl) [IID_IIRawElementProviderSimple] {
    
}}
RT_CLASS!{class IRawElementProviderSimple: IIRawElementProviderSimple}
DEFINE_IID!(IID_ICustomNavigationProvider, 735618768, 12195, 18199, 178, 140, 73, 23, 206, 84, 146, 141);
RT_INTERFACE!{interface ICustomNavigationProvider(ICustomNavigationProviderVtbl): IInspectable(IInspectableVtbl) [IID_ICustomNavigationProvider] {
    fn NavigateCustom(&self, direction: super::peers::AutomationNavigationDirection, out: *mut *mut IInspectable) -> HRESULT
}}
impl ICustomNavigationProvider {
    #[inline] pub unsafe fn navigate_custom(&self, direction: super::peers::AutomationNavigationDirection) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).NavigateCustom)(self as *const _ as *mut _, direction, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITextEditProvider, 3929408948, 14853, 16398, 181, 249, 78, 145, 180, 15, 97, 118);
RT_INTERFACE!{interface ITextEditProvider(ITextEditProviderVtbl): IInspectable(IInspectableVtbl) [IID_ITextEditProvider] {
    fn GetActiveComposition(&self, out: *mut *mut ITextRangeProvider) -> HRESULT,
    fn GetConversionTarget(&self, out: *mut *mut ITextRangeProvider) -> HRESULT
}}
impl ITextEditProvider {
    #[inline] pub unsafe fn get_active_composition(&self) -> Result<ComPtr<ITextRangeProvider>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetActiveComposition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_conversion_target(&self) -> Result<ComPtr<ITextRangeProvider>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetConversionTarget)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
} // Windows.UI.Xaml.Automation.Provider
} // Windows.UI.Xaml.Automation
pub mod data { // Windows.UI.Xaml.Data
use ::prelude::*;
DEFINE_IID!(IID_IItemsRangeInfo, 4032779877, 29181, 17826, 190, 19, 160, 129, 210, 148, 166, 141);
RT_INTERFACE!{interface IItemsRangeInfo(IItemsRangeInfoVtbl): IInspectable(IInspectableVtbl) [IID_IItemsRangeInfo] {
    fn RangesChanged(&self, visibleRange: *mut ItemIndexRange, trackedItems: *mut ::rt::gen::windows::foundation::collections::IVectorView<ItemIndexRange>) -> HRESULT
}}
impl IItemsRangeInfo {
    #[inline] pub unsafe fn ranges_changed(&self, visibleRange: &ItemIndexRange, trackedItems: &::rt::gen::windows::foundation::collections::IVectorView<ItemIndexRange>) -> Result<()> {
        let hr = ((*self.lpVtbl).RangesChanged)(self as *const _ as *mut _, visibleRange as *const _ as *mut _, trackedItems as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISelectionInfo, 772983430, 57837, 16965, 190, 73, 32, 126, 66, 174, 197, 36);
RT_INTERFACE!{interface ISelectionInfo(ISelectionInfoVtbl): IInspectable(IInspectableVtbl) [IID_ISelectionInfo] {
    fn SelectRange(&self, itemIndexRange: *mut ItemIndexRange) -> HRESULT,
    fn DeselectRange(&self, itemIndexRange: *mut ItemIndexRange) -> HRESULT,
    fn IsSelected(&self, index: i32, out: *mut bool) -> HRESULT,
    fn GetSelectedRanges(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<ItemIndexRange>) -> HRESULT
}}
impl ISelectionInfo {
    #[inline] pub unsafe fn select_range(&self, itemIndexRange: &ItemIndexRange) -> Result<()> {
        let hr = ((*self.lpVtbl).SelectRange)(self as *const _ as *mut _, itemIndexRange as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn deselect_range(&self, itemIndexRange: &ItemIndexRange) -> Result<()> {
        let hr = ((*self.lpVtbl).DeselectRange)(self as *const _ as *mut _, itemIndexRange as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_selected(&self, index: i32) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsSelected)(self as *const _ as *mut _, index, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_ranges(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<ItemIndexRange>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetSelectedRanges)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum BindingMode: i32 {
    OneWay (BindingMode_OneWay) = 1, OneTime (BindingMode_OneTime) = 2, TwoWay (BindingMode_TwoWay) = 3,
}}
RT_ENUM! { enum RelativeSourceMode: i32 {
    None (RelativeSourceMode_None) = 0, TemplatedParent (RelativeSourceMode_TemplatedParent) = 1, Self_ (RelativeSourceMode_Self) = 2,
}}
RT_ENUM! { enum UpdateSourceTrigger: i32 {
    Default (UpdateSourceTrigger_Default) = 0, PropertyChanged (UpdateSourceTrigger_PropertyChanged) = 1, Explicit (UpdateSourceTrigger_Explicit) = 2,
}}
RT_STRUCT! { struct LoadMoreItemsResult {
    Count: u32,
}}
DEFINE_IID!(IID_CurrentChangingEventHandler, 4085812664, 5023, 19918, 141, 201, 247, 241, 68, 77, 17, 133);
RT_DELEGATE!{delegate CurrentChangingEventHandler(CurrentChangingEventHandlerVtbl, CurrentChangingEventHandlerImpl) [IID_CurrentChangingEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut CurrentChangingEventArgs) -> HRESULT
}}
impl CurrentChangingEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &CurrentChangingEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class CurrentChangingEventArgs: ICurrentChangingEventArgs}
DEFINE_IID!(IID_PropertyChangedEventHandler, 1358011414, 2594, 19854, 160, 137, 30, 169, 149, 22, 87, 210);
RT_DELEGATE!{delegate PropertyChangedEventHandler(PropertyChangedEventHandlerVtbl, PropertyChangedEventHandlerImpl) [IID_PropertyChangedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut PropertyChangedEventArgs) -> HRESULT
}}
impl PropertyChangedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &PropertyChangedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class PropertyChangedEventArgs: IPropertyChangedEventArgs}
DEFINE_IID!(IID_ICustomProperty, 819630784, 9192, 17056, 174, 124, 115, 74, 14, 93, 39, 130);
RT_INTERFACE!{interface ICustomProperty(ICustomPropertyVtbl): IInspectable(IInspectableVtbl) [IID_ICustomProperty] {
    fn get_Type(&self, out: *mut super::interop::TypeName) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn GetValue(&self, target: *mut IInspectable, out: *mut *mut IInspectable) -> HRESULT,
    fn SetValue(&self, target: *mut IInspectable, value: *mut IInspectable) -> HRESULT,
    fn GetIndexedValue(&self, target: *mut IInspectable, index: *mut IInspectable, out: *mut *mut IInspectable) -> HRESULT,
    fn SetIndexedValue(&self, target: *mut IInspectable, value: *mut IInspectable, index: *mut IInspectable) -> HRESULT,
    fn get_CanWrite(&self, out: *mut bool) -> HRESULT,
    fn get_CanRead(&self, out: *mut bool) -> HRESULT
}}
impl ICustomProperty {
    #[inline] pub unsafe fn get_type(&self) -> Result<super::interop::TypeName> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Type)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_value(&self, target: &IInspectable) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetValue)(self as *const _ as *mut _, target as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_value(&self, target: &IInspectable, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).SetValue)(self as *const _ as *mut _, target as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_indexed_value(&self, target: &IInspectable, index: &IInspectable) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetIndexedValue)(self as *const _ as *mut _, target as *const _ as *mut _, index as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_indexed_value(&self, target: &IInspectable, value: &IInspectable, index: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).SetIndexedValue)(self as *const _ as *mut _, target as *const _ as *mut _, value as *const _ as *mut _, index as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_write(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanWrite)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_read(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanRead)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICustomPropertyProvider, 2089965397, 15944, 17076, 134, 119, 118, 55, 34, 103, 3, 63);
RT_INTERFACE!{interface ICustomPropertyProvider(ICustomPropertyProviderVtbl): IInspectable(IInspectableVtbl) [IID_ICustomPropertyProvider] {
    fn GetCustomProperty(&self, name: HSTRING, out: *mut *mut ICustomProperty) -> HRESULT,
    fn GetIndexedProperty(&self, name: HSTRING, type_: super::interop::TypeName, out: *mut *mut ICustomProperty) -> HRESULT,
    fn GetStringRepresentation(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Type(&self, out: *mut super::interop::TypeName) -> HRESULT
}}
impl ICustomPropertyProvider {
    #[inline] pub unsafe fn get_custom_property(&self, name: &HStringArg) -> Result<ComPtr<ICustomProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetCustomProperty)(self as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_indexed_property(&self, name: &HStringArg, type_: super::interop::TypeName) -> Result<ComPtr<ICustomProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetIndexedProperty)(self as *const _ as *mut _, name.get(), type_, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_string_representation(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetStringRepresentation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_type(&self) -> Result<super::interop::TypeName> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Type)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_INotifyPropertyChanged, 3480606364, 62196, 18539, 179, 2, 187, 76, 9, 186, 235, 250);
RT_INTERFACE!{interface INotifyPropertyChanged(INotifyPropertyChangedVtbl): IInspectable(IInspectableVtbl) [IID_INotifyPropertyChanged] {
    fn add_PropertyChanged(&self, value: *mut PropertyChangedEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PropertyChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl INotifyPropertyChanged {
    #[inline] pub unsafe fn add_property_changed(&self, value: &PropertyChangedEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PropertyChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_property_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PropertyChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISupportIncrementalLoading, 2136926610, 30356, 20076, 165, 27, 227, 75, 244, 61, 231, 67);
RT_INTERFACE!{interface ISupportIncrementalLoading(ISupportIncrementalLoadingVtbl): IInspectable(IInspectableVtbl) [IID_ISupportIncrementalLoading] {
    fn LoadMoreItemsAsync(&self, count: u32, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<LoadMoreItemsResult>) -> HRESULT,
    fn get_HasMoreItems(&self, out: *mut bool) -> HRESULT
}}
impl ISupportIncrementalLoading {
    #[inline] pub unsafe fn load_more_items_async(&self, count: u32) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<LoadMoreItemsResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).LoadMoreItemsAsync)(self as *const _ as *mut _, count, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_has_more_items(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HasMoreItems)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IValueConverter, 3874684656, 1810, 18559, 179, 19, 243, 0, 184, 215, 154, 161);
RT_INTERFACE!{interface IValueConverter(IValueConverterVtbl): IInspectable(IInspectableVtbl) [IID_IValueConverter] {
    fn Convert(&self, value: *mut IInspectable, targetType: super::interop::TypeName, parameter: *mut IInspectable, language: HSTRING, out: *mut *mut IInspectable) -> HRESULT,
    fn ConvertBack(&self, value: *mut IInspectable, targetType: super::interop::TypeName, parameter: *mut IInspectable, language: HSTRING, out: *mut *mut IInspectable) -> HRESULT
}}
impl IValueConverter {
    #[inline] pub unsafe fn convert(&self, value: &IInspectable, targetType: super::interop::TypeName, parameter: &IInspectable, language: &HStringArg) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Convert)(self as *const _ as *mut _, value as *const _ as *mut _, targetType, parameter as *const _ as *mut _, language.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn convert_back(&self, value: &IInspectable, targetType: super::interop::TypeName, parameter: &IInspectable, language: &HStringArg) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ConvertBack)(self as *const _ as *mut _, value as *const _ as *mut _, targetType, parameter as *const _ as *mut _, language.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBindingExpressionBase, 4260180308, 59732, 20327, 143, 182, 110, 215, 155, 58, 28, 179);
RT_INTERFACE!{interface IBindingExpressionBase(IBindingExpressionBaseVtbl): IInspectable(IInspectableVtbl) [IID_IBindingExpressionBase] {
    
}}
DEFINE_IID!(IID_IBindingExpressionBaseFactory, 3933279911, 49881, 17269, 180, 113, 102, 185, 196, 140, 121, 48);
RT_INTERFACE!{interface IBindingExpressionBaseFactory(IBindingExpressionBaseFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IBindingExpressionBaseFactory] {
    
}}
RT_CLASS!{class BindingExpressionBase: IBindingExpressionBase}
DEFINE_IID!(IID_IBindingOperations, 1879037752, 38969, 16796, 161, 122, 75, 54, 4, 225, 82, 78);
RT_INTERFACE!{interface IBindingOperations(IBindingOperationsVtbl): IInspectable(IInspectableVtbl) [IID_IBindingOperations] {
    
}}
DEFINE_IID!(IID_IBindingOperationsStatics, 3780505459, 38304, 19115, 140, 125, 42, 71, 218, 7, 60, 121);
RT_INTERFACE!{static interface IBindingOperationsStatics(IBindingOperationsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBindingOperationsStatics] {
    fn SetBinding(&self, target: *mut super::DependencyObject, dp: *mut super::DependencyProperty, binding: *mut BindingBase) -> HRESULT
}}
impl IBindingOperationsStatics {
    #[inline] pub unsafe fn set_binding(&self, target: &super::DependencyObject, dp: &super::DependencyProperty, binding: &BindingBase) -> Result<()> {
        let hr = ((*self.lpVtbl).SetBinding)(self as *const _ as *mut _, target as *const _ as *mut _, dp as *const _ as *mut _, binding as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class BindingOperations: IBindingOperations}
impl RtActivatable<IBindingOperationsStatics> for BindingOperations {}
impl BindingOperations {
    #[inline] pub fn set_binding(target: &super::DependencyObject, dp: &super::DependencyProperty, binding: &BindingBase) -> Result<()> { unsafe {
        <Self as RtActivatable<IBindingOperationsStatics>>::get_activation_factory().set_binding(target, dp, binding)
    }}
}
DEFINE_CLSID!(BindingOperations(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,68,97,116,97,46,66,105,110,100,105,110,103,79,112,101,114,97,116,105,111,110,115,0]) [CLSID_BindingOperations]);
DEFINE_IID!(IID_ICurrentChangingEventArgs, 4186512937, 20940, 18397, 165, 185, 53, 220, 73, 20, 175, 105);
RT_INTERFACE!{interface ICurrentChangingEventArgs(ICurrentChangingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICurrentChangingEventArgs] {
    fn get_Cancel(&self, out: *mut bool) -> HRESULT,
    fn put_Cancel(&self, value: bool) -> HRESULT,
    fn get_IsCancelable(&self, out: *mut bool) -> HRESULT
}}
impl ICurrentChangingEventArgs {
    #[inline] pub unsafe fn get_cancel(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cancel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_cancel(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Cancel)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_cancelable(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCancelable)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICurrentChangingEventArgsFactory, 356237038, 25331, 18639, 129, 131, 139, 226, 109, 227, 166, 110);
RT_INTERFACE!{interface ICurrentChangingEventArgsFactory(ICurrentChangingEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICurrentChangingEventArgsFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut CurrentChangingEventArgs) -> HRESULT,
    fn CreateWithCancelableParameter(&self, isCancelable: bool, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut CurrentChangingEventArgs) -> HRESULT
}}
impl ICurrentChangingEventArgsFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<CurrentChangingEventArgs>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_with_cancelable_parameter(&self, isCancelable: bool, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<CurrentChangingEventArgs>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithCancelableParameter)(self as *const _ as *mut _, isCancelable, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPropertyChangedEventArgs, 1328785824, 23796, 18340, 177, 111, 215, 250, 175, 23, 69, 126);
RT_INTERFACE!{interface IPropertyChangedEventArgs(IPropertyChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPropertyChangedEventArgs] {
    fn get_PropertyName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPropertyChangedEventArgs {
    #[inline] pub unsafe fn get_property_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PropertyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPropertyChangedEventArgsFactory, 1842125827, 57543, 20206, 142, 169, 55, 227, 64, 110, 235, 28);
RT_INTERFACE!{interface IPropertyChangedEventArgsFactory(IPropertyChangedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPropertyChangedEventArgsFactory] {
    fn CreateInstance(&self, name: HSTRING, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut PropertyChangedEventArgs) -> HRESULT
}}
impl IPropertyChangedEventArgsFactory {
    #[inline] pub unsafe fn create_instance(&self, name: &HStringArg, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<PropertyChangedEventArgs>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, name.get(), outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBindingBase, 361341611, 15637, 18876, 164, 71, 138, 84, 72, 229, 136, 112);
RT_INTERFACE!{interface IBindingBase(IBindingBaseVtbl): IInspectable(IInspectableVtbl) [IID_IBindingBase] {
    
}}
RT_CLASS!{class BindingBase: IBindingBase}
DEFINE_IID!(IID_IBindingBaseFactory, 584776762, 30465, 18022, 161, 186, 152, 89, 189, 207, 236, 52);
RT_INTERFACE!{interface IBindingBaseFactory(IBindingBaseFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IBindingBaseFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut BindingBase) -> HRESULT
}}
impl IBindingBaseFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<BindingBase>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBindingExpression, 1365907877, 49917, 19102, 159, 211, 154, 164, 47, 153, 90, 60);
RT_INTERFACE!{interface IBindingExpression(IBindingExpressionVtbl): IInspectable(IInspectableVtbl) [IID_IBindingExpression] {
    fn get_DataItem(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn get_ParentBinding(&self, out: *mut *mut Binding) -> HRESULT,
    fn UpdateSource(&self) -> HRESULT
}}
impl IBindingExpression {
    #[inline] pub unsafe fn get_data_item(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DataItem)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_parent_binding(&self) -> Result<ComPtr<Binding>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ParentBinding)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn update_source(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).UpdateSource)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class BindingExpression: IBindingExpression}
DEFINE_IID!(IID_IBindingExpressionFactory, 481647833, 56178, 16563, 162, 181, 36, 238, 110, 165, 195, 40);
RT_INTERFACE!{interface IBindingExpressionFactory(IBindingExpressionFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IBindingExpressionFactory] {
    
}}
DEFINE_IID!(IID_IRelativeSource, 597151364, 10274, 18490, 180, 153, 208, 240, 49, 224, 108, 107);
RT_INTERFACE!{interface IRelativeSource(IRelativeSourceVtbl): IInspectable(IInspectableVtbl) [IID_IRelativeSource] {
    fn get_Mode(&self, out: *mut RelativeSourceMode) -> HRESULT,
    fn put_Mode(&self, value: RelativeSourceMode) -> HRESULT
}}
impl IRelativeSource {
    #[inline] pub unsafe fn get_mode(&self) -> Result<RelativeSourceMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Mode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_mode(&self, value: RelativeSourceMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Mode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRelativeSourceFactory, 4018377421, 17518, 20371, 170, 203, 155, 18, 85, 87, 116, 96);
RT_INTERFACE!{interface IRelativeSourceFactory(IRelativeSourceFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IRelativeSourceFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut RelativeSource) -> HRESULT
}}
impl IRelativeSourceFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<RelativeSource>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class RelativeSource: IRelativeSource}
DEFINE_IID!(IID_IBinding, 1064963179, 53263, 18224, 140, 29, 72, 225, 108, 70, 249, 202);
RT_INTERFACE!{interface IBinding(IBindingVtbl): IInspectable(IInspectableVtbl) [IID_IBinding] {
    fn get_Path(&self, out: *mut *mut super::PropertyPath) -> HRESULT,
    fn put_Path(&self, value: *mut super::PropertyPath) -> HRESULT,
    fn get_Mode(&self, out: *mut BindingMode) -> HRESULT,
    fn put_Mode(&self, value: BindingMode) -> HRESULT,
    fn get_Source(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Source(&self, value: *mut IInspectable) -> HRESULT,
    fn get_RelativeSource(&self, out: *mut *mut RelativeSource) -> HRESULT,
    fn put_RelativeSource(&self, value: *mut RelativeSource) -> HRESULT,
    fn get_ElementName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ElementName(&self, value: HSTRING) -> HRESULT,
    fn get_Converter(&self, out: *mut *mut IValueConverter) -> HRESULT,
    fn put_Converter(&self, value: *mut IValueConverter) -> HRESULT,
    fn get_ConverterParameter(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_ConverterParameter(&self, value: *mut IInspectable) -> HRESULT,
    fn get_ConverterLanguage(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ConverterLanguage(&self, value: HSTRING) -> HRESULT
}}
impl IBinding {
    #[inline] pub unsafe fn get_path(&self) -> Result<ComPtr<super::PropertyPath>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Path)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_path(&self, value: &super::PropertyPath) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Path)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_mode(&self) -> Result<BindingMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Mode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_mode(&self, value: BindingMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Mode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_source(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Source)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_source(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Source)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_relative_source(&self) -> Result<ComPtr<RelativeSource>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RelativeSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_relative_source(&self, value: &RelativeSource) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RelativeSource)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_element_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ElementName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_element_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ElementName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_converter(&self) -> Result<ComPtr<IValueConverter>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Converter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_converter(&self, value: &IValueConverter) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Converter)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_converter_parameter(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ConverterParameter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_converter_parameter(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ConverterParameter)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_converter_language(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ConverterLanguage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_converter_language(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ConverterLanguage)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBindingFactory, 4282563336, 50078, 20350, 132, 52, 161, 86, 144, 131, 136, 60);
RT_INTERFACE!{interface IBindingFactory(IBindingFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IBindingFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut Binding) -> HRESULT
}}
impl IBindingFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<Binding>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBinding2, 888762315, 1030, 18611, 158, 130, 243, 51, 236, 76, 105, 16);
RT_INTERFACE!{interface IBinding2(IBinding2Vtbl): IInspectable(IInspectableVtbl) [IID_IBinding2] {
    fn get_FallbackValue(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_FallbackValue(&self, value: *mut IInspectable) -> HRESULT,
    fn get_TargetNullValue(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_TargetNullValue(&self, value: *mut IInspectable) -> HRESULT,
    fn get_UpdateSourceTrigger(&self, out: *mut UpdateSourceTrigger) -> HRESULT,
    fn put_UpdateSourceTrigger(&self, value: UpdateSourceTrigger) -> HRESULT
}}
impl IBinding2 {
    #[inline] pub unsafe fn get_fallback_value(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FallbackValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_fallback_value(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FallbackValue)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_target_null_value(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetNullValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_null_value(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetNullValue)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_update_source_trigger(&self) -> Result<UpdateSourceTrigger> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_UpdateSourceTrigger)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_update_source_trigger(&self, value: UpdateSourceTrigger) -> Result<()> {
        let hr = ((*self.lpVtbl).put_UpdateSourceTrigger)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class Binding: IBinding}
DEFINE_IID!(IID_ICollectionView, 2347286500, 56303, 17631, 129, 38, 163, 26, 137, 18, 29, 220);
RT_INTERFACE!{interface ICollectionView(ICollectionViewVtbl): IInspectable(IInspectableVtbl) [IID_ICollectionView] {
    fn get_CurrentItem(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn get_CurrentPosition(&self, out: *mut i32) -> HRESULT,
    fn get_IsCurrentAfterLast(&self, out: *mut bool) -> HRESULT,
    fn get_IsCurrentBeforeFirst(&self, out: *mut bool) -> HRESULT,
    fn get_CollectionGroups(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IObservableVector<IInspectable>) -> HRESULT,
    fn get_HasMoreItems(&self, out: *mut bool) -> HRESULT,
    fn add_CurrentChanged(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CurrentChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_CurrentChanging(&self, value: *mut CurrentChangingEventHandler, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CurrentChanging(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn MoveCurrentTo(&self, item: *mut IInspectable, out: *mut bool) -> HRESULT,
    fn MoveCurrentToPosition(&self, index: i32, out: *mut bool) -> HRESULT,
    fn MoveCurrentToFirst(&self, out: *mut bool) -> HRESULT,
    fn MoveCurrentToLast(&self, out: *mut bool) -> HRESULT,
    fn MoveCurrentToNext(&self, out: *mut bool) -> HRESULT,
    fn MoveCurrentToPrevious(&self, out: *mut bool) -> HRESULT,
    fn LoadMoreItemsAsync(&self, count: u32, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<LoadMoreItemsResult>) -> HRESULT
}}
impl ICollectionView {
    #[inline] pub unsafe fn get_current_item(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CurrentItem)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_current_position(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CurrentPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_current_after_last(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCurrentAfterLast)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_current_before_first(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCurrentBeforeFirst)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_collection_groups(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IObservableVector<IInspectable>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CollectionGroups)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_has_more_items(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HasMoreItems)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_current_changed(&self, value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CurrentChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_current_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_CurrentChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_current_changing(&self, value: &CurrentChangingEventHandler) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CurrentChanging)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_current_changing(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_CurrentChanging)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn move_current_to(&self, item: &IInspectable) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).MoveCurrentTo)(self as *const _ as *mut _, item as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn move_current_to_position(&self, index: i32) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).MoveCurrentToPosition)(self as *const _ as *mut _, index, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn move_current_to_first(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).MoveCurrentToFirst)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn move_current_to_last(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).MoveCurrentToLast)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn move_current_to_next(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).MoveCurrentToNext)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn move_current_to_previous(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).MoveCurrentToPrevious)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn load_more_items_async(&self, count: u32) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<LoadMoreItemsResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).LoadMoreItemsAsync)(self as *const _ as *mut _, count, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICollectionViewFactory, 886352628, 36466, 18768, 145, 146, 236, 208, 125, 57, 157, 10);
RT_INTERFACE!{interface ICollectionViewFactory(ICollectionViewFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICollectionViewFactory] {
    fn CreateView(&self, out: *mut *mut ICollectionView) -> HRESULT
}}
impl ICollectionViewFactory {
    #[inline] pub unsafe fn create_view(&self) -> Result<ComPtr<ICollectionView>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICollectionViewGroup, 2114042328, 55221, 18614, 179, 28, 91, 181, 189, 245, 240, 155);
RT_INTERFACE!{interface ICollectionViewGroup(ICollectionViewGroupVtbl): IInspectable(IInspectableVtbl) [IID_ICollectionViewGroup] {
    fn get_Group(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn get_GroupItems(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IObservableVector<IInspectable>) -> HRESULT
}}
impl ICollectionViewGroup {
    #[inline] pub unsafe fn get_group(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Group)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_group_items(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IObservableVector<IInspectable>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GroupItems)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemIndexRange, 2209887422, 1411, 18982, 155, 100, 139, 244, 162, 246, 87, 4);
RT_INTERFACE!{interface IItemIndexRange(IItemIndexRangeVtbl): IInspectable(IInspectableVtbl) [IID_IItemIndexRange] {
    fn get_FirstIndex(&self, out: *mut i32) -> HRESULT,
    fn get_Length(&self, out: *mut u32) -> HRESULT,
    fn get_LastIndex(&self, out: *mut i32) -> HRESULT
}}
impl IItemIndexRange {
    #[inline] pub unsafe fn get_first_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FirstIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_length(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Length)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_last_index(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LastIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IItemIndexRangeFactory, 2263008320, 11898, 19581, 166, 100, 232, 171, 240, 123, 252, 126);
RT_INTERFACE!{interface IItemIndexRangeFactory(IItemIndexRangeFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IItemIndexRangeFactory] {
    fn CreateInstance(&self, firstIndex: i32, length: u32, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ItemIndexRange) -> HRESULT
}}
impl IItemIndexRangeFactory {
    #[inline] pub unsafe fn create_instance(&self, firstIndex: i32, length: u32, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ItemIndexRange>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, firstIndex, length, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class ItemIndexRange: IItemIndexRange}
DEFINE_IID!(IID_ICollectionViewSource, 2791969094, 54011, 20141, 190, 159, 53, 120, 164, 102, 220, 254);
RT_INTERFACE!{interface ICollectionViewSource(ICollectionViewSourceVtbl): IInspectable(IInspectableVtbl) [IID_ICollectionViewSource] {
    fn get_Source(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Source(&self, value: *mut IInspectable) -> HRESULT,
    fn get_View(&self, out: *mut *mut ICollectionView) -> HRESULT,
    fn get_IsSourceGrouped(&self, out: *mut bool) -> HRESULT,
    fn put_IsSourceGrouped(&self, value: bool) -> HRESULT,
    fn get_ItemsPath(&self, out: *mut *mut super::PropertyPath) -> HRESULT,
    fn put_ItemsPath(&self, value: *mut super::PropertyPath) -> HRESULT
}}
impl ICollectionViewSource {
    #[inline] pub unsafe fn get_source(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Source)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_source(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Source)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_view(&self) -> Result<ComPtr<ICollectionView>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_View)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_source_grouped(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSourceGrouped)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_source_grouped(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSourceGrouped)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_items_path(&self) -> Result<ComPtr<super::PropertyPath>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemsPath)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_items_path(&self, value: &super::PropertyPath) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ItemsPath)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICollectionViewSourceStatics, 389678864, 18095, 19468, 129, 139, 33, 182, 239, 129, 191, 101);
RT_INTERFACE!{static interface ICollectionViewSourceStatics(ICollectionViewSourceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICollectionViewSourceStatics] {
    fn get_SourceProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ViewProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_IsSourceGroupedProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_ItemsPathProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ICollectionViewSourceStatics {
    #[inline] pub unsafe fn get_source_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourceProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_view_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ViewProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_source_grouped_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsSourceGroupedProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_items_path_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemsPathProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class CollectionViewSource: ICollectionViewSource}
impl RtActivatable<ICollectionViewSourceStatics> for CollectionViewSource {}
impl RtActivatable<IActivationFactory> for CollectionViewSource {}
impl CollectionViewSource {
    #[inline] pub fn get_source_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICollectionViewSourceStatics>>::get_activation_factory().get_source_property()
    }}
    #[inline] pub fn get_view_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICollectionViewSourceStatics>>::get_activation_factory().get_view_property()
    }}
    #[inline] pub fn get_is_source_grouped_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICollectionViewSourceStatics>>::get_activation_factory().get_is_source_grouped_property()
    }}
    #[inline] pub fn get_items_path_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ICollectionViewSourceStatics>>::get_activation_factory().get_items_path_property()
    }}
}
DEFINE_CLSID!(CollectionViewSource(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,68,97,116,97,46,67,111,108,108,101,99,116,105,111,110,86,105,101,119,83,111,117,114,99,101,0]) [CLSID_CollectionViewSource]);
} // Windows.UI.Xaml.Data
pub mod hosting { // Windows.UI.Xaml.Hosting
use ::prelude::*;
DEFINE_IID!(IID_IElementCompositionPreview, 3069290102, 53222, 18092, 172, 246, 196, 104, 123, 182, 94, 96);
RT_INTERFACE!{interface IElementCompositionPreview(IElementCompositionPreviewVtbl): IInspectable(IInspectableVtbl) [IID_IElementCompositionPreview] {
    
}}
DEFINE_IID!(IID_IElementCompositionPreviewStatics, 147401528, 60569, 19541, 188, 133, 161, 193, 128, 178, 118, 70);
RT_INTERFACE!{static interface IElementCompositionPreviewStatics(IElementCompositionPreviewStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IElementCompositionPreviewStatics] {
    #[cfg(feature="windows-ui")] fn GetElementVisual(&self, element: *mut super::UIElement, out: *mut *mut super::super::composition::Visual) -> HRESULT,
    #[cfg(feature="windows-ui")] fn GetElementChildVisual(&self, element: *mut super::UIElement, out: *mut *mut super::super::composition::Visual) -> HRESULT,
    #[cfg(feature="windows-ui")] fn SetElementChildVisual(&self, element: *mut super::UIElement, visual: *mut super::super::composition::Visual) -> HRESULT,
    #[cfg(feature="windows-ui")] fn GetScrollViewerManipulationPropertySet(&self, scrollViewer: *mut super::controls::ScrollViewer, out: *mut *mut super::super::composition::CompositionPropertySet) -> HRESULT
}}
impl IElementCompositionPreviewStatics {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_element_visual(&self, element: &super::UIElement) -> Result<ComPtr<super::super::composition::Visual>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetElementVisual)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_element_child_visual(&self, element: &super::UIElement) -> Result<ComPtr<super::super::composition::Visual>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetElementChildVisual)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_element_child_visual(&self, element: &super::UIElement, visual: &super::super::composition::Visual) -> Result<()> {
        let hr = ((*self.lpVtbl).SetElementChildVisual)(self as *const _ as *mut _, element as *const _ as *mut _, visual as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_scroll_viewer_manipulation_property_set(&self, scrollViewer: &super::controls::ScrollViewer) -> Result<ComPtr<super::super::composition::CompositionPropertySet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetScrollViewerManipulationPropertySet)(self as *const _ as *mut _, scrollViewer as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IElementCompositionPreviewStatics2, 605327291, 9174, 20279, 186, 12, 7, 51, 231, 153, 114, 45);
RT_INTERFACE!{static interface IElementCompositionPreviewStatics2(IElementCompositionPreviewStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IElementCompositionPreviewStatics2] {
    #[cfg(feature="windows-ui")] fn SetImplicitShowAnimation(&self, element: *mut super::UIElement, animation: *mut super::super::composition::ICompositionAnimationBase) -> HRESULT,
    #[cfg(feature="windows-ui")] fn SetImplicitHideAnimation(&self, element: *mut super::UIElement, animation: *mut super::super::composition::ICompositionAnimationBase) -> HRESULT,
    fn SetIsTranslationEnabled(&self, element: *mut super::UIElement, value: bool) -> HRESULT,
    #[cfg(feature="windows-ui")] fn GetPointerPositionPropertySet(&self, targetElement: *mut super::UIElement, out: *mut *mut super::super::composition::CompositionPropertySet) -> HRESULT
}}
impl IElementCompositionPreviewStatics2 {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_implicit_show_animation(&self, element: &super::UIElement, animation: &super::super::composition::ICompositionAnimationBase) -> Result<()> {
        let hr = ((*self.lpVtbl).SetImplicitShowAnimation)(self as *const _ as *mut _, element as *const _ as *mut _, animation as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_implicit_hide_animation(&self, element: &super::UIElement, animation: &super::super::composition::ICompositionAnimationBase) -> Result<()> {
        let hr = ((*self.lpVtbl).SetImplicitHideAnimation)(self as *const _ as *mut _, element as *const _ as *mut _, animation as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_translation_enabled(&self, element: &super::UIElement, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetIsTranslationEnabled)(self as *const _ as *mut _, element as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_pointer_position_property_set(&self, targetElement: &super::UIElement) -> Result<ComPtr<super::super::composition::CompositionPropertySet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetPointerPositionPropertySet)(self as *const _ as *mut _, targetElement as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ElementCompositionPreview: IElementCompositionPreview}
impl RtActivatable<IElementCompositionPreviewStatics> for ElementCompositionPreview {}
impl RtActivatable<IElementCompositionPreviewStatics2> for ElementCompositionPreview {}
impl ElementCompositionPreview {
    #[cfg(feature="windows-ui")] #[inline] pub fn get_element_visual(element: &super::UIElement) -> Result<ComPtr<super::super::composition::Visual>> { unsafe {
        <Self as RtActivatable<IElementCompositionPreviewStatics>>::get_activation_factory().get_element_visual(element)
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_element_child_visual(element: &super::UIElement) -> Result<ComPtr<super::super::composition::Visual>> { unsafe {
        <Self as RtActivatable<IElementCompositionPreviewStatics>>::get_activation_factory().get_element_child_visual(element)
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_element_child_visual(element: &super::UIElement, visual: &super::super::composition::Visual) -> Result<()> { unsafe {
        <Self as RtActivatable<IElementCompositionPreviewStatics>>::get_activation_factory().set_element_child_visual(element, visual)
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_scroll_viewer_manipulation_property_set(scrollViewer: &super::controls::ScrollViewer) -> Result<ComPtr<super::super::composition::CompositionPropertySet>> { unsafe {
        <Self as RtActivatable<IElementCompositionPreviewStatics>>::get_activation_factory().get_scroll_viewer_manipulation_property_set(scrollViewer)
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_implicit_show_animation(element: &super::UIElement, animation: &super::super::composition::ICompositionAnimationBase) -> Result<()> { unsafe {
        <Self as RtActivatable<IElementCompositionPreviewStatics2>>::get_activation_factory().set_implicit_show_animation(element, animation)
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_implicit_hide_animation(element: &super::UIElement, animation: &super::super::composition::ICompositionAnimationBase) -> Result<()> { unsafe {
        <Self as RtActivatable<IElementCompositionPreviewStatics2>>::get_activation_factory().set_implicit_hide_animation(element, animation)
    }}
    #[inline] pub fn set_is_translation_enabled(element: &super::UIElement, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IElementCompositionPreviewStatics2>>::get_activation_factory().set_is_translation_enabled(element, value)
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_pointer_position_property_set(targetElement: &super::UIElement) -> Result<ComPtr<super::super::composition::CompositionPropertySet>> { unsafe {
        <Self as RtActivatable<IElementCompositionPreviewStatics2>>::get_activation_factory().get_pointer_position_property_set(targetElement)
    }}
}
DEFINE_CLSID!(ElementCompositionPreview(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,72,111,115,116,105,110,103,46,69,108,101,109,101,110,116,67,111,109,112,111,115,105,116,105,111,110,80,114,101,118,105,101,119,0]) [CLSID_ElementCompositionPreview]);
RT_STRUCT! { struct HostingContract {
    
}}
DEFINE_IID!(IID_IXamlUIPresenterHost, 2868610253, 40813, 20352, 172, 44, 14, 108, 185, 243, 22, 89);
RT_INTERFACE!{interface IXamlUIPresenterHost(IXamlUIPresenterHostVtbl): IInspectable(IInspectableVtbl) [IID_IXamlUIPresenterHost] {
    fn ResolveFileResource(&self, path: HSTRING, out: *mut HSTRING) -> HRESULT
}}
impl IXamlUIPresenterHost {
    #[inline] pub unsafe fn resolve_file_resource(&self, path: &HStringArg) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ResolveFileResource)(self as *const _ as *mut _, path.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IXamlUIPresenterHost2, 1633244786, 31908, 18977, 181, 106, 136, 244, 129, 35, 136, 202);
RT_INTERFACE!{interface IXamlUIPresenterHost2(IXamlUIPresenterHost2Vtbl): IInspectable(IInspectableVtbl) [IID_IXamlUIPresenterHost2] {
    fn GetGenericXamlFilePath(&self, out: *mut HSTRING) -> HRESULT
}}
impl IXamlUIPresenterHost2 {
    #[inline] pub unsafe fn get_generic_xaml_file_path(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetGenericXamlFilePath)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IXamlUIPresenterHost3, 2973930175, 29472, 16827, 159, 38, 77, 111, 211, 77, 180, 90);
RT_INTERFACE!{interface IXamlUIPresenterHost3(IXamlUIPresenterHost3Vtbl): IInspectable(IInspectableVtbl) [IID_IXamlUIPresenterHost3] {
    fn ResolveDictionaryResource(&self, dictionary: *mut super::ResourceDictionary, dictionaryKey: *mut IInspectable, suggestedValue: *mut IInspectable, out: *mut *mut IInspectable) -> HRESULT
}}
impl IXamlUIPresenterHost3 {
    #[inline] pub unsafe fn resolve_dictionary_resource(&self, dictionary: &super::ResourceDictionary, dictionaryKey: &IInspectable, suggestedValue: &IInspectable) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ResolveDictionaryResource)(self as *const _ as *mut _, dictionary as *const _ as *mut _, dictionaryKey as *const _ as *mut _, suggestedValue as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IXamlUIPresenter, 2803143754, 5657, 20422, 179, 27, 137, 81, 46, 240, 34, 162);
RT_INTERFACE!{interface IXamlUIPresenter(IXamlUIPresenterVtbl): IInspectable(IInspectableVtbl) [IID_IXamlUIPresenter] {
    fn get_RootElement(&self, out: *mut *mut super::UIElement) -> HRESULT,
    fn put_RootElement(&self, value: *mut super::UIElement) -> HRESULT,
    fn get_ThemeKey(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ThemeKey(&self, value: HSTRING) -> HRESULT,
    fn get_ThemeResourcesXaml(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ThemeResourcesXaml(&self, value: HSTRING) -> HRESULT,
    fn SetSize(&self, width: i32, height: i32) -> HRESULT,
    fn Render(&self) -> HRESULT,
    fn Present(&self) -> HRESULT
}}
impl IXamlUIPresenter {
    #[inline] pub unsafe fn get_root_element(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RootElement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_root_element(&self, value: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RootElement)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_theme_key(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ThemeKey)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_theme_key(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ThemeKey)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_theme_resources_xaml(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ThemeResourcesXaml)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_theme_resources_xaml(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ThemeResourcesXaml)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_size(&self, width: i32, height: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetSize)(self as *const _ as *mut _, width, height);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn render(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Render)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn present(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Present)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IXamlUIPresenterStatics, 1911220936, 17889, 16786, 133, 170, 58, 66, 46, 221, 35, 207);
RT_INTERFACE!{static interface IXamlUIPresenterStatics(IXamlUIPresenterStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IXamlUIPresenterStatics] {
    fn get_CompleteTimelinesAutomatically(&self, out: *mut bool) -> HRESULT,
    fn put_CompleteTimelinesAutomatically(&self, value: bool) -> HRESULT,
    fn SetHost(&self, host: *mut IXamlUIPresenterHost) -> HRESULT,
    fn NotifyWindowSizeChanged(&self) -> HRESULT
}}
impl IXamlUIPresenterStatics {
    #[inline] pub unsafe fn get_complete_timelines_automatically(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CompleteTimelinesAutomatically)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_complete_timelines_automatically(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CompleteTimelinesAutomatically)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_host(&self, host: &IXamlUIPresenterHost) -> Result<()> {
        let hr = ((*self.lpVtbl).SetHost)(self as *const _ as *mut _, host as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn notify_window_size_changed(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).NotifyWindowSizeChanged)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IXamlUIPresenterStatics2, 1550543058, 53020, 20307, 191, 9, 106, 116, 95, 122, 151, 3);
RT_INTERFACE!{static interface IXamlUIPresenterStatics2(IXamlUIPresenterStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IXamlUIPresenterStatics2] {
    fn GetFlyoutPlacementTargetInfo(&self, placementTarget: *mut super::FrameworkElement, preferredPlacement: super::controls::primitives::FlyoutPlacementMode, targetPreferredPlacement: *mut super::controls::primitives::FlyoutPlacementMode, allowFallbacks: *mut bool, out: *mut ::rt::gen::windows::foundation::Rect) -> HRESULT,
    fn GetFlyoutPlacement(&self, placementTargetBounds: ::rt::gen::windows::foundation::Rect, controlSize: ::rt::gen::windows::foundation::Size, minControlSize: ::rt::gen::windows::foundation::Size, containerRect: ::rt::gen::windows::foundation::Rect, targetPreferredPlacement: super::controls::primitives::FlyoutPlacementMode, allowFallbacks: bool, chosenPlacement: *mut super::controls::primitives::FlyoutPlacementMode, out: *mut ::rt::gen::windows::foundation::Rect) -> HRESULT
}}
impl IXamlUIPresenterStatics2 {
    #[inline] pub unsafe fn get_flyout_placement_target_info(&self, placementTarget: &super::FrameworkElement, preferredPlacement: super::controls::primitives::FlyoutPlacementMode) -> Result<(super::controls::primitives::FlyoutPlacementMode, bool, ::rt::gen::windows::foundation::Rect)> {
        let mut targetPreferredPlacement = zeroed(); let mut allowFallbacks = zeroed(); let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetFlyoutPlacementTargetInfo)(self as *const _ as *mut _, placementTarget as *const _ as *mut _, preferredPlacement, &mut targetPreferredPlacement, &mut allowFallbacks, &mut out);
        if hr == S_OK { Ok((targetPreferredPlacement, allowFallbacks, out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_flyout_placement(&self, placementTargetBounds: ::rt::gen::windows::foundation::Rect, controlSize: ::rt::gen::windows::foundation::Size, minControlSize: ::rt::gen::windows::foundation::Size, containerRect: ::rt::gen::windows::foundation::Rect, targetPreferredPlacement: super::controls::primitives::FlyoutPlacementMode, allowFallbacks: bool) -> Result<(super::controls::primitives::FlyoutPlacementMode, ::rt::gen::windows::foundation::Rect)> {
        let mut chosenPlacement = zeroed(); let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetFlyoutPlacement)(self as *const _ as *mut _, placementTargetBounds, controlSize, minControlSize, containerRect, targetPreferredPlacement, allowFallbacks, &mut chosenPlacement, &mut out);
        if hr == S_OK { Ok((chosenPlacement, out)) } else { err(hr) }
    }
}
RT_CLASS!{class XamlUIPresenter: IXamlUIPresenter}
impl RtActivatable<IXamlUIPresenterStatics2> for XamlUIPresenter {}
impl RtActivatable<IXamlUIPresenterStatics> for XamlUIPresenter {}
impl XamlUIPresenter {
    #[inline] pub fn get_flyout_placement_target_info(placementTarget: &super::FrameworkElement, preferredPlacement: super::controls::primitives::FlyoutPlacementMode) -> Result<(super::controls::primitives::FlyoutPlacementMode, bool, ::rt::gen::windows::foundation::Rect)> { unsafe {
        <Self as RtActivatable<IXamlUIPresenterStatics2>>::get_activation_factory().get_flyout_placement_target_info(placementTarget, preferredPlacement)
    }}
    #[inline] pub fn get_flyout_placement(placementTargetBounds: ::rt::gen::windows::foundation::Rect, controlSize: ::rt::gen::windows::foundation::Size, minControlSize: ::rt::gen::windows::foundation::Size, containerRect: ::rt::gen::windows::foundation::Rect, targetPreferredPlacement: super::controls::primitives::FlyoutPlacementMode, allowFallbacks: bool) -> Result<(super::controls::primitives::FlyoutPlacementMode, ::rt::gen::windows::foundation::Rect)> { unsafe {
        <Self as RtActivatable<IXamlUIPresenterStatics2>>::get_activation_factory().get_flyout_placement(placementTargetBounds, controlSize, minControlSize, containerRect, targetPreferredPlacement, allowFallbacks)
    }}
    #[inline] pub fn get_complete_timelines_automatically() -> Result<bool> { unsafe {
        <Self as RtActivatable<IXamlUIPresenterStatics>>::get_activation_factory().get_complete_timelines_automatically()
    }}
    #[inline] pub fn set_complete_timelines_automatically(value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlUIPresenterStatics>>::get_activation_factory().set_complete_timelines_automatically(value)
    }}
    #[inline] pub fn set_host(host: &IXamlUIPresenterHost) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlUIPresenterStatics>>::get_activation_factory().set_host(host)
    }}
    #[inline] pub fn notify_window_size_changed() -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlUIPresenterStatics>>::get_activation_factory().notify_window_size_changed()
    }}
}
DEFINE_CLSID!(XamlUIPresenter(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,72,111,115,116,105,110,103,46,88,97,109,108,85,73,80,114,101,115,101,110,116,101,114,0]) [CLSID_XamlUIPresenter]);
} // Windows.UI.Xaml.Hosting
pub mod input { // Windows.UI.Xaml.Input
use ::prelude::*;
RT_ENUM! { enum FocusInputDeviceKind: i32 {
    None (FocusInputDeviceKind_None) = 0, Mouse (FocusInputDeviceKind_Mouse) = 1, Touch (FocusInputDeviceKind_Touch) = 2, Pen (FocusInputDeviceKind_Pen) = 3, Keyboard (FocusInputDeviceKind_Keyboard) = 4, GameController (FocusInputDeviceKind_GameController) = 5,
}}
RT_ENUM! { enum FocusNavigationDirection: i32 {
    Next (FocusNavigationDirection_Next) = 0, Previous (FocusNavigationDirection_Previous) = 1, Up (FocusNavigationDirection_Up) = 2, Down (FocusNavigationDirection_Down) = 3, Left (FocusNavigationDirection_Left) = 4, Right (FocusNavigationDirection_Right) = 5, None (FocusNavigationDirection_None) = 6,
}}
RT_ENUM! { enum InputScopeNameValue: i32 {
    Default (InputScopeNameValue_Default) = 0, Url (InputScopeNameValue_Url) = 1, EmailSmtpAddress (InputScopeNameValue_EmailSmtpAddress) = 5, PersonalFullName (InputScopeNameValue_PersonalFullName) = 7, CurrencyAmountAndSymbol (InputScopeNameValue_CurrencyAmountAndSymbol) = 20, CurrencyAmount (InputScopeNameValue_CurrencyAmount) = 21, DateMonthNumber (InputScopeNameValue_DateMonthNumber) = 23, DateDayNumber (InputScopeNameValue_DateDayNumber) = 24, DateYear (InputScopeNameValue_DateYear) = 25, Digits (InputScopeNameValue_Digits) = 28, Number (InputScopeNameValue_Number) = 29, Password (InputScopeNameValue_Password) = 31, TelephoneNumber (InputScopeNameValue_TelephoneNumber) = 32, TelephoneCountryCode (InputScopeNameValue_TelephoneCountryCode) = 33, TelephoneAreaCode (InputScopeNameValue_TelephoneAreaCode) = 34, TelephoneLocalNumber (InputScopeNameValue_TelephoneLocalNumber) = 35, TimeHour (InputScopeNameValue_TimeHour) = 37, TimeMinutesOrSeconds (InputScopeNameValue_TimeMinutesOrSeconds) = 38, NumberFullWidth (InputScopeNameValue_NumberFullWidth) = 39, AlphanumericHalfWidth (InputScopeNameValue_AlphanumericHalfWidth) = 40, AlphanumericFullWidth (InputScopeNameValue_AlphanumericFullWidth) = 41, Hiragana (InputScopeNameValue_Hiragana) = 44, KatakanaHalfWidth (InputScopeNameValue_KatakanaHalfWidth) = 45, KatakanaFullWidth (InputScopeNameValue_KatakanaFullWidth) = 46, Hanja (InputScopeNameValue_Hanja) = 47, HangulHalfWidth (InputScopeNameValue_HangulHalfWidth) = 48, HangulFullWidth (InputScopeNameValue_HangulFullWidth) = 49, Search (InputScopeNameValue_Search) = 50, Formula (InputScopeNameValue_Formula) = 51, SearchIncremental (InputScopeNameValue_SearchIncremental) = 52, ChineseHalfWidth (InputScopeNameValue_ChineseHalfWidth) = 53, ChineseFullWidth (InputScopeNameValue_ChineseFullWidth) = 54, NativeScript (InputScopeNameValue_NativeScript) = 55, Text (InputScopeNameValue_Text) = 57, Chat (InputScopeNameValue_Chat) = 58, NameOrPhoneNumber (InputScopeNameValue_NameOrPhoneNumber) = 59, EmailNameOrAddress (InputScopeNameValue_EmailNameOrAddress) = 60, Maps (InputScopeNameValue_Maps) = 62, NumericPassword (InputScopeNameValue_NumericPassword) = 63, NumericPin (InputScopeNameValue_NumericPin) = 64, AlphanumericPin (InputScopeNameValue_AlphanumericPin) = 65, FormulaNumber (InputScopeNameValue_FormulaNumber) = 67, ChatWithoutEmoji (InputScopeNameValue_ChatWithoutEmoji) = 68,
}}
RT_ENUM! { enum KeyboardNavigationMode: i32 {
    Local (KeyboardNavigationMode_Local) = 0, Cycle (KeyboardNavigationMode_Cycle) = 1, Once (KeyboardNavigationMode_Once) = 2,
}}
RT_ENUM! { enum KeyTipPlacementMode: i32 {
    Auto (KeyTipPlacementMode_Auto) = 0, Bottom (KeyTipPlacementMode_Bottom) = 1, Top (KeyTipPlacementMode_Top) = 2, Left (KeyTipPlacementMode_Left) = 3, Right (KeyTipPlacementMode_Right) = 4, Center (KeyTipPlacementMode_Center) = 5, Hidden (KeyTipPlacementMode_Hidden) = 6,
}}
RT_ENUM! { enum ManipulationModes: u32 {
    None (ManipulationModes_None) = 0, TranslateX (ManipulationModes_TranslateX) = 1, TranslateY (ManipulationModes_TranslateY) = 2, TranslateRailsX (ManipulationModes_TranslateRailsX) = 4, TranslateRailsY (ManipulationModes_TranslateRailsY) = 8, Rotate (ManipulationModes_Rotate) = 16, Scale (ManipulationModes_Scale) = 32, TranslateInertia (ManipulationModes_TranslateInertia) = 64, RotateInertia (ManipulationModes_RotateInertia) = 128, ScaleInertia (ManipulationModes_ScaleInertia) = 256, All (ManipulationModes_All) = 65535, System (ManipulationModes_System) = 65536,
}}
RT_ENUM! { enum XYFocusKeyboardNavigationMode: i32 {
    Auto (XYFocusKeyboardNavigationMode_Auto) = 0, Enabled (XYFocusKeyboardNavigationMode_Enabled) = 1, Disabled (XYFocusKeyboardNavigationMode_Disabled) = 2,
}}
RT_ENUM! { enum XYFocusNavigationStrategy: i32 {
    Auto (XYFocusNavigationStrategy_Auto) = 0, Projection (XYFocusNavigationStrategy_Projection) = 1, NavigationDirectionDistance (XYFocusNavigationStrategy_NavigationDirectionDistance) = 2, RectilinearDistance (XYFocusNavigationStrategy_RectilinearDistance) = 3,
}}
RT_ENUM! { enum XYFocusNavigationStrategyOverride: i32 {
    None (XYFocusNavigationStrategyOverride_None) = 0, Auto (XYFocusNavigationStrategyOverride_Auto) = 1, Projection (XYFocusNavigationStrategyOverride_Projection) = 2, NavigationDirectionDistance (XYFocusNavigationStrategyOverride_NavigationDirectionDistance) = 3, RectilinearDistance (XYFocusNavigationStrategyOverride_RectilinearDistance) = 4,
}}
DEFINE_IID!(IID_DoubleTappedEventHandler, 824496165, 1191, 19781, 130, 94, 130, 4, 166, 36, 219, 244);
RT_DELEGATE!{delegate DoubleTappedEventHandler(DoubleTappedEventHandlerVtbl, DoubleTappedEventHandlerImpl) [IID_DoubleTappedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut DoubleTappedRoutedEventArgs) -> HRESULT
}}
impl DoubleTappedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &DoubleTappedRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_HoldingEventHandler, 3970862285, 36446, 20414, 152, 70, 48, 166, 55, 10, 252, 223);
RT_DELEGATE!{delegate HoldingEventHandler(HoldingEventHandlerVtbl, HoldingEventHandlerImpl) [IID_HoldingEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut HoldingRoutedEventArgs) -> HRESULT
}}
impl HoldingEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &HoldingRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_KeyEventHandler, 2086916837, 31246, 19986, 185, 106, 119, 21, 170, 111, 241, 200);
RT_DELEGATE!{delegate KeyEventHandler(KeyEventHandlerVtbl, KeyEventHandlerImpl) [IID_KeyEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut KeyRoutedEventArgs) -> HRESULT
}}
impl KeyEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &KeyRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ManipulationCompletedEventHandler, 955206415, 5368, 17119, 154, 30, 164, 188, 196, 175, 119, 244);
RT_DELEGATE!{delegate ManipulationCompletedEventHandler(ManipulationCompletedEventHandlerVtbl, ManipulationCompletedEventHandlerImpl) [IID_ManipulationCompletedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut ManipulationCompletedRoutedEventArgs) -> HRESULT
}}
impl ManipulationCompletedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &ManipulationCompletedRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ManipulationDeltaEventHandler, 2853265611, 57273, 19542, 171, 220, 113, 27, 99, 200, 235, 148);
RT_DELEGATE!{delegate ManipulationDeltaEventHandler(ManipulationDeltaEventHandlerVtbl, ManipulationDeltaEventHandlerImpl) [IID_ManipulationDeltaEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut ManipulationDeltaRoutedEventArgs) -> HRESULT
}}
impl ManipulationDeltaEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &ManipulationDeltaRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ManipulationInertiaStartingEventHandler, 3550307106, 31900, 18459, 130, 123, 200, 178, 217, 187, 111, 199);
RT_DELEGATE!{delegate ManipulationInertiaStartingEventHandler(ManipulationInertiaStartingEventHandlerVtbl, ManipulationInertiaStartingEventHandlerImpl) [IID_ManipulationInertiaStartingEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut ManipulationInertiaStartingRoutedEventArgs) -> HRESULT
}}
impl ManipulationInertiaStartingEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &ManipulationInertiaStartingRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ManipulationStartedEventHandler, 4169352696, 57507, 19426, 185, 12, 220, 32, 230, 216, 190, 176);
RT_DELEGATE!{delegate ManipulationStartedEventHandler(ManipulationStartedEventHandlerVtbl, ManipulationStartedEventHandlerImpl) [IID_ManipulationStartedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut ManipulationStartedRoutedEventArgs) -> HRESULT
}}
impl ManipulationStartedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &ManipulationStartedRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ManipulationStartingEventHandler, 282112078, 49124, 17099, 130, 60, 63, 236, 216, 119, 14, 248);
RT_DELEGATE!{delegate ManipulationStartingEventHandler(ManipulationStartingEventHandlerVtbl, ManipulationStartingEventHandlerImpl) [IID_ManipulationStartingEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut ManipulationStartingRoutedEventArgs) -> HRESULT
}}
impl ManipulationStartingEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &ManipulationStartingRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_PointerEventHandler, 3828898089, 49156, 19407, 137, 112, 53, 148, 134, 227, 159, 136);
RT_DELEGATE!{delegate PointerEventHandler(PointerEventHandlerVtbl, PointerEventHandlerImpl) [IID_PointerEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut PointerRoutedEventArgs) -> HRESULT
}}
impl PointerEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &PointerRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_RightTappedEventHandler, 624074850, 62535, 18768, 156, 70, 241, 227, 74, 44, 34, 56);
RT_DELEGATE!{delegate RightTappedEventHandler(RightTappedEventHandlerVtbl, RightTappedEventHandlerImpl) [IID_RightTappedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut RightTappedRoutedEventArgs) -> HRESULT
}}
impl RightTappedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &RightTappedRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_TappedEventHandler, 1759068364, 40944, 18894, 177, 65, 63, 7, 236, 71, 123, 151);
RT_DELEGATE!{delegate TappedEventHandler(TappedEventHandlerVtbl, TappedEventHandlerImpl) [IID_TappedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut TappedRoutedEventArgs) -> HRESULT
}}
impl TappedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IInspectable, e: &TappedRoutedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class Pointer: IPointer}
RT_CLASS!{class AccessKeyDisplayRequestedEventArgs: IAccessKeyDisplayRequestedEventArgs}
impl RtActivatable<IActivationFactory> for AccessKeyDisplayRequestedEventArgs {}
DEFINE_CLSID!(AccessKeyDisplayRequestedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,73,110,112,117,116,46,65,99,99,101,115,115,75,101,121,68,105,115,112,108,97,121,82,101,113,117,101,115,116,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_AccessKeyDisplayRequestedEventArgs]);
RT_CLASS!{class AccessKeyDisplayDismissedEventArgs: IAccessKeyDisplayDismissedEventArgs}
impl RtActivatable<IActivationFactory> for AccessKeyDisplayDismissedEventArgs {}
DEFINE_CLSID!(AccessKeyDisplayDismissedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,73,110,112,117,116,46,65,99,99,101,115,115,75,101,121,68,105,115,112,108,97,121,68,105,115,109,105,115,115,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_AccessKeyDisplayDismissedEventArgs]);
RT_CLASS!{class AccessKeyInvokedEventArgs: IAccessKeyInvokedEventArgs}
impl RtActivatable<IActivationFactory> for AccessKeyInvokedEventArgs {}
DEFINE_CLSID!(AccessKeyInvokedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,73,110,112,117,116,46,65,99,99,101,115,115,75,101,121,73,110,118,111,107,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_AccessKeyInvokedEventArgs]);
DEFINE_IID!(IID_ICommand, 3853464898, 51815, 16513, 153, 91, 112, 157, 209, 55, 146, 223);
RT_INTERFACE!{interface ICommand(ICommandVtbl): IInspectable(IInspectableVtbl) [IID_ICommand] {
    fn add_CanExecuteChanged(&self, value: *mut ::rt::gen::windows::foundation::EventHandler<IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CanExecuteChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn CanExecute(&self, parameter: *mut IInspectable, out: *mut bool) -> HRESULT,
    fn Execute(&self, parameter: *mut IInspectable) -> HRESULT
}}
impl ICommand {
    #[inline] pub unsafe fn add_can_execute_changed(&self, value: &::rt::gen::windows::foundation::EventHandler<IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CanExecuteChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_can_execute_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_CanExecuteChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn can_execute(&self, parameter: &IInspectable) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).CanExecute)(self as *const _ as *mut _, parameter as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn execute(&self, parameter: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).Execute)(self as *const _ as *mut _, parameter as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAccessKeyDisplayDismissedEventArgs, 2321616326, 55085, 19624, 159, 102, 85, 111, 53, 181, 19, 218);
RT_INTERFACE!{interface IAccessKeyDisplayDismissedEventArgs(IAccessKeyDisplayDismissedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAccessKeyDisplayDismissedEventArgs] {
    
}}
DEFINE_IID!(IID_IAccessKeyDisplayRequestedEventArgs, 201825877, 5118, 19715, 166, 29, 225, 47, 6, 86, 114, 134);
RT_INTERFACE!{interface IAccessKeyDisplayRequestedEventArgs(IAccessKeyDisplayRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAccessKeyDisplayRequestedEventArgs] {
    fn get_PressedKeys(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAccessKeyDisplayRequestedEventArgs {
    #[inline] pub unsafe fn get_pressed_keys(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PressedKeys)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAccessKeyInvokedEventArgs, 3488206231, 50968, 16529, 183, 221, 173, 241, 192, 114, 177, 225);
RT_INTERFACE!{interface IAccessKeyInvokedEventArgs(IAccessKeyInvokedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAccessKeyInvokedEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT
}}
impl IAccessKeyInvokedEventArgs {
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAccessKeyManager, 3972625328, 12009, 19228, 152, 215, 110, 14, 129, 109, 51, 75);
RT_INTERFACE!{interface IAccessKeyManager(IAccessKeyManagerVtbl): IInspectable(IInspectableVtbl) [IID_IAccessKeyManager] {
    
}}
DEFINE_IID!(IID_IAccessKeyManagerStatics, 1285615590, 55752, 20156, 180, 199, 48, 209, 131, 138, 129, 241);
RT_INTERFACE!{static interface IAccessKeyManagerStatics(IAccessKeyManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAccessKeyManagerStatics] {
    fn get_IsDisplayModeEnabled(&self, out: *mut bool) -> HRESULT,
    fn add_IsDisplayModeEnabledChanged(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<IInspectable, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_IsDisplayModeEnabledChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn ExitDisplayMode(&self) -> HRESULT
}}
impl IAccessKeyManagerStatics {
    #[inline] pub unsafe fn get_is_display_mode_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsDisplayModeEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_is_display_mode_enabled_changed(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<IInspectable, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_IsDisplayModeEnabledChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_is_display_mode_enabled_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_IsDisplayModeEnabledChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn exit_display_mode(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ExitDisplayMode)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAccessKeyManagerStatics2, 2519446932, 10931, 18373, 149, 75, 112, 146, 243, 85, 247, 151);
RT_INTERFACE!{static interface IAccessKeyManagerStatics2(IAccessKeyManagerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IAccessKeyManagerStatics2] {
    fn get_AreKeyTipsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_AreKeyTipsEnabled(&self, value: bool) -> HRESULT
}}
impl IAccessKeyManagerStatics2 {
    #[inline] pub unsafe fn get_are_key_tips_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AreKeyTipsEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_are_key_tips_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AreKeyTipsEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class AccessKeyManager: IAccessKeyManager}
impl RtActivatable<IAccessKeyManagerStatics> for AccessKeyManager {}
impl RtActivatable<IAccessKeyManagerStatics2> for AccessKeyManager {}
impl AccessKeyManager {
    #[inline] pub fn get_is_display_mode_enabled() -> Result<bool> { unsafe {
        <Self as RtActivatable<IAccessKeyManagerStatics>>::get_activation_factory().get_is_display_mode_enabled()
    }}
    #[inline] pub fn add_is_display_mode_enabled_changed(value: &::rt::gen::windows::foundation::TypedEventHandler<IInspectable, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> { unsafe {
        <Self as RtActivatable<IAccessKeyManagerStatics>>::get_activation_factory().add_is_display_mode_enabled_changed(value)
    }}
    #[inline] pub fn remove_is_display_mode_enabled_changed(token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> { unsafe {
        <Self as RtActivatable<IAccessKeyManagerStatics>>::get_activation_factory().remove_is_display_mode_enabled_changed(token)
    }}
    #[inline] pub fn exit_display_mode() -> Result<()> { unsafe {
        <Self as RtActivatable<IAccessKeyManagerStatics>>::get_activation_factory().exit_display_mode()
    }}
    #[inline] pub fn get_are_key_tips_enabled() -> Result<bool> { unsafe {
        <Self as RtActivatable<IAccessKeyManagerStatics2>>::get_activation_factory().get_are_key_tips_enabled()
    }}
    #[inline] pub fn set_are_key_tips_enabled(value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IAccessKeyManagerStatics2>>::get_activation_factory().set_are_key_tips_enabled(value)
    }}
}
DEFINE_CLSID!(AccessKeyManager(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,73,110,112,117,116,46,65,99,99,101,115,115,75,101,121,77,97,110,97,103,101,114,0]) [CLSID_AccessKeyManager]);
DEFINE_IID!(IID_IInertiaExpansionBehavior, 1964869605, 36162, 17605, 150, 94, 60, 211, 12, 201, 214, 247);
RT_INTERFACE!{interface IInertiaExpansionBehavior(IInertiaExpansionBehaviorVtbl): IInspectable(IInspectableVtbl) [IID_IInertiaExpansionBehavior] {
    fn get_DesiredDeceleration(&self, out: *mut f64) -> HRESULT,
    fn put_DesiredDeceleration(&self, value: f64) -> HRESULT,
    fn get_DesiredExpansion(&self, out: *mut f64) -> HRESULT,
    fn put_DesiredExpansion(&self, value: f64) -> HRESULT
}}
impl IInertiaExpansionBehavior {
    #[inline] pub unsafe fn get_desired_deceleration(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DesiredDeceleration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_desired_deceleration(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DesiredDeceleration)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_desired_expansion(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DesiredExpansion)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_desired_expansion(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DesiredExpansion)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class InertiaExpansionBehavior: IInertiaExpansionBehavior}
DEFINE_IID!(IID_IInertiaRotationBehavior, 1112341294, 48125, 17957, 174, 120, 32, 198, 91, 241, 239, 175);
RT_INTERFACE!{interface IInertiaRotationBehavior(IInertiaRotationBehaviorVtbl): IInspectable(IInspectableVtbl) [IID_IInertiaRotationBehavior] {
    fn get_DesiredDeceleration(&self, out: *mut f64) -> HRESULT,
    fn put_DesiredDeceleration(&self, value: f64) -> HRESULT,
    fn get_DesiredRotation(&self, out: *mut f64) -> HRESULT,
    fn put_DesiredRotation(&self, value: f64) -> HRESULT
}}
impl IInertiaRotationBehavior {
    #[inline] pub unsafe fn get_desired_deceleration(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DesiredDeceleration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_desired_deceleration(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DesiredDeceleration)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_desired_rotation(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DesiredRotation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_desired_rotation(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DesiredRotation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class InertiaRotationBehavior: IInertiaRotationBehavior}
DEFINE_IID!(IID_IInertiaTranslationBehavior, 1171498258, 15154, 18562, 164, 194, 236, 250, 45, 75, 109, 240);
RT_INTERFACE!{interface IInertiaTranslationBehavior(IInertiaTranslationBehaviorVtbl): IInspectable(IInspectableVtbl) [IID_IInertiaTranslationBehavior] {
    fn get_DesiredDeceleration(&self, out: *mut f64) -> HRESULT,
    fn put_DesiredDeceleration(&self, value: f64) -> HRESULT,
    fn get_DesiredDisplacement(&self, out: *mut f64) -> HRESULT,
    fn put_DesiredDisplacement(&self, value: f64) -> HRESULT
}}
impl IInertiaTranslationBehavior {
    #[inline] pub unsafe fn get_desired_deceleration(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DesiredDeceleration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_desired_deceleration(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DesiredDeceleration)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_desired_displacement(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DesiredDisplacement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_desired_displacement(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DesiredDisplacement)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class InertiaTranslationBehavior: IInertiaTranslationBehavior}
DEFINE_IID!(IID_IManipulationPivot, 775436453, 59074, 18840, 130, 172, 24, 116, 139, 20, 22, 102);
RT_INTERFACE!{interface IManipulationPivot(IManipulationPivotVtbl): IInspectable(IInspectableVtbl) [IID_IManipulationPivot] {
    fn get_Center(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn put_Center(&self, value: ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn get_Radius(&self, out: *mut f64) -> HRESULT,
    fn put_Radius(&self, value: f64) -> HRESULT
}}
impl IManipulationPivot {
    #[inline] pub unsafe fn get_center(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Center)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_center(&self, value: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Center)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_radius(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Radius)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_radius(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Radius)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IManipulationPivotFactory, 1829089337, 14082, 17302, 173, 155, 168, 37, 239, 166, 58, 59);
RT_INTERFACE!{static interface IManipulationPivotFactory(IManipulationPivotFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IManipulationPivotFactory] {
    fn CreateInstanceWithCenterAndRadius(&self, center: ::rt::gen::windows::foundation::Point, radius: f64, out: *mut *mut ManipulationPivot) -> HRESULT
}}
impl IManipulationPivotFactory {
    #[inline] pub unsafe fn create_instance_with_center_and_radius(&self, center: ::rt::gen::windows::foundation::Point, radius: f64) -> Result<ComPtr<ManipulationPivot>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceWithCenterAndRadius)(self as *const _ as *mut _, center, radius, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ManipulationPivot: IManipulationPivot}
impl RtActivatable<IManipulationPivotFactory> for ManipulationPivot {}
impl RtActivatable<IActivationFactory> for ManipulationPivot {}
impl ManipulationPivot {
    #[inline] pub fn create_instance_with_center_and_radius(center: ::rt::gen::windows::foundation::Point, radius: f64) -> Result<ComPtr<ManipulationPivot>> { unsafe {
        <Self as RtActivatable<IManipulationPivotFactory>>::get_activation_factory().create_instance_with_center_and_radius(center, radius)
    }}
}
DEFINE_CLSID!(ManipulationPivot(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,73,110,112,117,116,46,77,97,110,105,112,117,108,97,116,105,111,110,80,105,118,111,116,0]) [CLSID_ManipulationPivot]);
DEFINE_IID!(IID_IPointer, 1592325023, 29821, 16753, 144, 230, 205, 55, 169, 223, 251, 17);
RT_INTERFACE!{interface IPointer(IPointerVtbl): IInspectable(IInspectableVtbl) [IID_IPointer] {
    fn get_PointerId(&self, out: *mut u32) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_PointerDeviceType(&self, out: *mut ::rt::gen::windows::devices::input::PointerDeviceType) -> HRESULT,
    fn get_IsInContact(&self, out: *mut bool) -> HRESULT,
    fn get_IsInRange(&self, out: *mut bool) -> HRESULT
}}
impl IPointer {
    #[inline] pub unsafe fn get_pointer_id(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_pointer_device_type(&self) -> Result<::rt::gen::windows::devices::input::PointerDeviceType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerDeviceType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_in_contact(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsInContact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_in_range(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsInRange)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContextRequestedEventArgs, 1113689610, 7350, 18171, 131, 116, 10, 236, 104, 170, 94, 81);
RT_INTERFACE!{interface IContextRequestedEventArgs(IContextRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContextRequestedEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn TryGetPosition(&self, relativeTo: *mut super::UIElement, point: *mut ::rt::gen::windows::foundation::Point, out: *mut bool) -> HRESULT
}}
impl IContextRequestedEventArgs {
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_get_position(&self, relativeTo: &super::UIElement) -> Result<(::rt::gen::windows::foundation::Point, bool)> {
        let mut point = zeroed(); let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryGetPosition)(self as *const _ as *mut _, relativeTo as *const _ as *mut _, &mut point, &mut out);
        if hr == S_OK { Ok((point, out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContextRequestedEventArgs: IContextRequestedEventArgs}
impl RtActivatable<IActivationFactory> for ContextRequestedEventArgs {}
DEFINE_CLSID!(ContextRequestedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,73,110,112,117,116,46,67,111,110,116,101,120,116,82,101,113,117,101,115,116,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_ContextRequestedEventArgs]);
DEFINE_IID!(IID_IDoubleTappedRoutedEventArgs, 2940224548, 9951, 17652, 135, 20, 147, 89, 36, 155, 98, 211);
RT_INTERFACE!{interface IDoubleTappedRoutedEventArgs(IDoubleTappedRoutedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDoubleTappedRoutedEventArgs] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_PointerDeviceType(&self, out: *mut ::rt::gen::windows::devices::input::PointerDeviceType) -> HRESULT,
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn GetPosition(&self, relativeTo: *mut super::UIElement, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT
}}
impl IDoubleTappedRoutedEventArgs {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_pointer_device_type(&self) -> Result<::rt::gen::windows::devices::input::PointerDeviceType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerDeviceType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_position(&self, relativeTo: &super::UIElement) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetPosition)(self as *const _ as *mut _, relativeTo as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class DoubleTappedRoutedEventArgs: IDoubleTappedRoutedEventArgs}
impl RtActivatable<IActivationFactory> for DoubleTappedRoutedEventArgs {}
DEFINE_CLSID!(DoubleTappedRoutedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,73,110,112,117,116,46,68,111,117,98,108,101,84,97,112,112,101,100,82,111,117,116,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_DoubleTappedRoutedEventArgs]);
DEFINE_IID!(IID_IGettingFocusEventArgs, 4194679246, 50812, 19432, 143, 212, 196, 77, 103, 135, 126, 13);
RT_INTERFACE!{interface IGettingFocusEventArgs(IGettingFocusEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IGettingFocusEventArgs] {
    fn get_OldFocusedElement(&self, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn get_NewFocusedElement(&self, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn put_NewFocusedElement(&self, value: *mut super::DependencyObject) -> HRESULT,
    fn get_FocusState(&self, out: *mut super::FocusState) -> HRESULT,
    fn get_Direction(&self, out: *mut FocusNavigationDirection) -> HRESULT,
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn get_InputDevice(&self, out: *mut FocusInputDeviceKind) -> HRESULT,
    fn get_Cancel(&self, out: *mut bool) -> HRESULT,
    fn put_Cancel(&self, value: bool) -> HRESULT
}}
impl IGettingFocusEventArgs {
    #[inline] pub unsafe fn get_old_focused_element(&self) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OldFocusedElement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_new_focused_element(&self) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NewFocusedElement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_new_focused_element(&self, value: &super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_NewFocusedElement)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_state(&self) -> Result<super::FocusState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FocusState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_direction(&self) -> Result<FocusNavigationDirection> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Direction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_input_device(&self) -> Result<FocusInputDeviceKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InputDevice)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_cancel(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cancel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_cancel(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Cancel)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class GettingFocusEventArgs: IGettingFocusEventArgs}
DEFINE_IID!(IID_IHoldingRoutedEventArgs, 3259432739, 55309, 17630, 141, 185, 13, 129, 94, 38, 154, 192);
RT_INTERFACE!{interface IHoldingRoutedEventArgs(IHoldingRoutedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IHoldingRoutedEventArgs] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_PointerDeviceType(&self, out: *mut ::rt::gen::windows::devices::input::PointerDeviceType) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_HoldingState(&self, out: *mut super::super::input::HoldingState) -> HRESULT,
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn GetPosition(&self, relativeTo: *mut super::UIElement, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT
}}
impl IHoldingRoutedEventArgs {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_pointer_device_type(&self) -> Result<::rt::gen::windows::devices::input::PointerDeviceType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerDeviceType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_holding_state(&self) -> Result<super::super::input::HoldingState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HoldingState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_position(&self, relativeTo: &super::UIElement) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetPosition)(self as *const _ as *mut _, relativeTo as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class HoldingRoutedEventArgs: IHoldingRoutedEventArgs}
impl RtActivatable<IActivationFactory> for HoldingRoutedEventArgs {}
DEFINE_CLSID!(HoldingRoutedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,73,110,112,117,116,46,72,111,108,100,105,110,103,82,111,117,116,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_HoldingRoutedEventArgs]);
DEFINE_IID!(IID_IInputScope, 1544521203, 63960, 16928, 182, 102, 4, 93, 7, 77, 155, 250);
RT_INTERFACE!{interface IInputScope(IInputScopeVtbl): IInspectable(IInspectableVtbl) [IID_IInputScope] {
    fn get_Names(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<InputScopeName>) -> HRESULT
}}
impl IInputScope {
    #[inline] pub unsafe fn get_names(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<InputScopeName>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Names)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class InputScope: IInputScope}
impl RtActivatable<IActivationFactory> for InputScope {}
DEFINE_CLSID!(InputScope(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,73,110,112,117,116,46,73,110,112,117,116,83,99,111,112,101,0]) [CLSID_InputScope]);
DEFINE_IID!(IID_IInputScopeName, 4248725911, 2299, 19642, 160, 33, 121, 45, 117, 137, 253, 90);
RT_INTERFACE!{interface IInputScopeName(IInputScopeNameVtbl): IInspectable(IInspectableVtbl) [IID_IInputScopeName] {
    fn get_NameValue(&self, out: *mut InputScopeNameValue) -> HRESULT,
    fn put_NameValue(&self, value: InputScopeNameValue) -> HRESULT
}}
impl IInputScopeName {
    #[inline] pub unsafe fn get_name_value(&self) -> Result<InputScopeNameValue> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NameValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_name_value(&self, value: InputScopeNameValue) -> Result<()> {
        let hr = ((*self.lpVtbl).put_NameValue)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class InputScopeName: IInputScopeName}
impl RtActivatable<IInputScopeNameFactory> for InputScopeName {}
impl RtActivatable<IActivationFactory> for InputScopeName {}
impl InputScopeName {
    #[inline] pub fn create_instance(nameValue: InputScopeNameValue) -> Result<ComPtr<InputScopeName>> { unsafe {
        <Self as RtActivatable<IInputScopeNameFactory>>::get_activation_factory().create_instance(nameValue)
    }}
}
DEFINE_CLSID!(InputScopeName(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,73,110,112,117,116,46,73,110,112,117,116,83,99,111,112,101,78,97,109,101,0]) [CLSID_InputScopeName]);
DEFINE_IID!(IID_IInputScopeNameFactory, 1245756242, 19415, 20052, 134, 23, 28, 218, 138, 30, 218, 127);
RT_INTERFACE!{static interface IInputScopeNameFactory(IInputScopeNameFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInputScopeNameFactory] {
    fn CreateInstance(&self, nameValue: InputScopeNameValue, out: *mut *mut InputScopeName) -> HRESULT
}}
impl IInputScopeNameFactory {
    #[inline] pub unsafe fn create_instance(&self, nameValue: InputScopeNameValue) -> Result<ComPtr<InputScopeName>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, nameValue, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IKeyRoutedEventArgs, 3570220542, 16505, 17129, 163, 154, 48, 149, 211, 240, 73, 198);
RT_INTERFACE!{interface IKeyRoutedEventArgs(IKeyRoutedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IKeyRoutedEventArgs] {
    #[cfg(not(feature="windows-system"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-system")] fn get_Key(&self, out: *mut ::rt::gen::windows::system::VirtualKey) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_KeyStatus(&self, out: *mut super::super::core::CorePhysicalKeyStatus) -> HRESULT,
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT
}}
impl IKeyRoutedEventArgs {
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_key(&self) -> Result<::rt::gen::windows::system::VirtualKey> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Key)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_key_status(&self) -> Result<super::super::core::CorePhysicalKeyStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeyStatus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IKeyRoutedEventArgs2, 453170554, 38452, 20244, 145, 178, 19, 62, 66, 253, 179, 205);
RT_INTERFACE!{interface IKeyRoutedEventArgs2(IKeyRoutedEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IKeyRoutedEventArgs2] {
    #[cfg(feature="windows-system")] fn get_OriginalKey(&self, out: *mut ::rt::gen::windows::system::VirtualKey) -> HRESULT
}}
impl IKeyRoutedEventArgs2 {
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_original_key(&self) -> Result<::rt::gen::windows::system::VirtualKey> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OriginalKey)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IKeyRoutedEventArgs3, 662304180, 51777, 16667, 168, 239, 244, 252, 120, 231, 128, 87);
RT_INTERFACE!{interface IKeyRoutedEventArgs3(IKeyRoutedEventArgs3Vtbl): IInspectable(IInspectableVtbl) [IID_IKeyRoutedEventArgs3] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IKeyRoutedEventArgs3 {
    #[inline] pub unsafe fn get_device_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DeviceId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class KeyRoutedEventArgs: IKeyRoutedEventArgs}
DEFINE_IID!(IID_ILosingFocusEventArgs, 4193682375, 55177, 18219, 170, 147, 109, 65, 5, 230, 218, 190);
RT_INTERFACE!{interface ILosingFocusEventArgs(ILosingFocusEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ILosingFocusEventArgs] {
    fn get_OldFocusedElement(&self, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn get_NewFocusedElement(&self, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn put_NewFocusedElement(&self, value: *mut super::DependencyObject) -> HRESULT,
    fn get_FocusState(&self, out: *mut super::FocusState) -> HRESULT,
    fn get_Direction(&self, out: *mut FocusNavigationDirection) -> HRESULT,
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn get_InputDevice(&self, out: *mut FocusInputDeviceKind) -> HRESULT,
    fn get_Cancel(&self, out: *mut bool) -> HRESULT,
    fn put_Cancel(&self, value: bool) -> HRESULT
}}
impl ILosingFocusEventArgs {
    #[inline] pub unsafe fn get_old_focused_element(&self) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OldFocusedElement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_new_focused_element(&self) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NewFocusedElement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_new_focused_element(&self, value: &super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_NewFocusedElement)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_focus_state(&self) -> Result<super::FocusState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FocusState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_direction(&self) -> Result<FocusNavigationDirection> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Direction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_input_device(&self) -> Result<FocusInputDeviceKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InputDevice)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_cancel(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cancel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_cancel(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Cancel)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class LosingFocusEventArgs: ILosingFocusEventArgs}
DEFINE_IID!(IID_IManipulationCompletedRoutedEventArgs, 3048053539, 12097, 18830, 131, 25, 1, 94, 232, 167, 83, 70);
RT_INTERFACE!{interface IManipulationCompletedRoutedEventArgs(IManipulationCompletedRoutedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IManipulationCompletedRoutedEventArgs] {
    fn get_Container(&self, out: *mut *mut super::UIElement) -> HRESULT,
    fn get_Position(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn get_IsInertial(&self, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Cumulative(&self, out: *mut super::super::input::ManipulationDelta) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Velocities(&self, out: *mut super::super::input::ManipulationVelocities) -> HRESULT,
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    #[cfg(feature="windows-devices")] fn get_PointerDeviceType(&self, out: *mut ::rt::gen::windows::devices::input::PointerDeviceType) -> HRESULT
}}
impl IManipulationCompletedRoutedEventArgs {
    #[inline] pub unsafe fn get_container(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Container)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_position(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_inertial(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsInertial)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_cumulative(&self) -> Result<super::super::input::ManipulationDelta> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cumulative)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_velocities(&self) -> Result<super::super::input::ManipulationVelocities> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Velocities)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_pointer_device_type(&self) -> Result<::rt::gen::windows::devices::input::PointerDeviceType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerDeviceType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class ManipulationCompletedRoutedEventArgs: IManipulationCompletedRoutedEventArgs}
impl RtActivatable<IActivationFactory> for ManipulationCompletedRoutedEventArgs {}
DEFINE_CLSID!(ManipulationCompletedRoutedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,73,110,112,117,116,46,77,97,110,105,112,117,108,97,116,105,111,110,67,111,109,112,108,101,116,101,100,82,111,117,116,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_ManipulationCompletedRoutedEventArgs]);
DEFINE_IID!(IID_IManipulationDeltaRoutedEventArgs, 1074616212, 19567, 18717, 130, 214, 53, 23, 16, 147, 153, 198);
RT_INTERFACE!{interface IManipulationDeltaRoutedEventArgs(IManipulationDeltaRoutedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IManipulationDeltaRoutedEventArgs] {
    fn get_Container(&self, out: *mut *mut super::UIElement) -> HRESULT,
    fn get_Position(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn get_IsInertial(&self, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Delta(&self, out: *mut super::super::input::ManipulationDelta) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Cumulative(&self, out: *mut super::super::input::ManipulationDelta) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Velocities(&self, out: *mut super::super::input::ManipulationVelocities) -> HRESULT,
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_PointerDeviceType(&self, out: *mut ::rt::gen::windows::devices::input::PointerDeviceType) -> HRESULT,
    fn Complete(&self) -> HRESULT
}}
impl IManipulationDeltaRoutedEventArgs {
    #[inline] pub unsafe fn get_container(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Container)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_position(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_inertial(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsInertial)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_delta(&self) -> Result<super::super::input::ManipulationDelta> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Delta)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_cumulative(&self) -> Result<super::super::input::ManipulationDelta> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cumulative)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_velocities(&self) -> Result<super::super::input::ManipulationVelocities> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Velocities)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_pointer_device_type(&self) -> Result<::rt::gen::windows::devices::input::PointerDeviceType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerDeviceType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn complete(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ManipulationDeltaRoutedEventArgs: IManipulationDeltaRoutedEventArgs}
impl RtActivatable<IActivationFactory> for ManipulationDeltaRoutedEventArgs {}
DEFINE_CLSID!(ManipulationDeltaRoutedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,73,110,112,117,116,46,77,97,110,105,112,117,108,97,116,105,111,110,68,101,108,116,97,82,111,117,116,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_ManipulationDeltaRoutedEventArgs]);
DEFINE_IID!(IID_IManipulationInertiaStartingRoutedEventArgs, 610963881, 51779, 19467, 172, 239, 129, 232, 184, 20, 117, 32);
RT_INTERFACE!{interface IManipulationInertiaStartingRoutedEventArgs(IManipulationInertiaStartingRoutedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IManipulationInertiaStartingRoutedEventArgs] {
    fn get_Container(&self, out: *mut *mut super::UIElement) -> HRESULT,
    fn get_ExpansionBehavior(&self, out: *mut *mut InertiaExpansionBehavior) -> HRESULT,
    fn put_ExpansionBehavior(&self, value: *mut InertiaExpansionBehavior) -> HRESULT,
    fn get_RotationBehavior(&self, out: *mut *mut InertiaRotationBehavior) -> HRESULT,
    fn put_RotationBehavior(&self, value: *mut InertiaRotationBehavior) -> HRESULT,
    fn get_TranslationBehavior(&self, out: *mut *mut InertiaTranslationBehavior) -> HRESULT,
    fn put_TranslationBehavior(&self, value: *mut InertiaTranslationBehavior) -> HRESULT,
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy9(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_PointerDeviceType(&self, out: *mut ::rt::gen::windows::devices::input::PointerDeviceType) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_Delta(&self, out: *mut super::super::input::ManipulationDelta) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_Cumulative(&self, out: *mut super::super::input::ManipulationDelta) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_Velocities(&self, out: *mut super::super::input::ManipulationVelocities) -> HRESULT
}}
impl IManipulationInertiaStartingRoutedEventArgs {
    #[inline] pub unsafe fn get_container(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Container)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_expansion_behavior(&self) -> Result<ComPtr<InertiaExpansionBehavior>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExpansionBehavior)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_expansion_behavior(&self, value: &InertiaExpansionBehavior) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ExpansionBehavior)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rotation_behavior(&self) -> Result<ComPtr<InertiaRotationBehavior>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RotationBehavior)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_rotation_behavior(&self, value: &InertiaRotationBehavior) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RotationBehavior)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_translation_behavior(&self) -> Result<ComPtr<InertiaTranslationBehavior>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TranslationBehavior)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_translation_behavior(&self, value: &InertiaTranslationBehavior) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TranslationBehavior)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_pointer_device_type(&self) -> Result<::rt::gen::windows::devices::input::PointerDeviceType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerDeviceType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_delta(&self) -> Result<super::super::input::ManipulationDelta> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Delta)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_cumulative(&self) -> Result<super::super::input::ManipulationDelta> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cumulative)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_velocities(&self) -> Result<super::super::input::ManipulationVelocities> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Velocities)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class ManipulationInertiaStartingRoutedEventArgs: IManipulationInertiaStartingRoutedEventArgs}
impl RtActivatable<IActivationFactory> for ManipulationInertiaStartingRoutedEventArgs {}
DEFINE_CLSID!(ManipulationInertiaStartingRoutedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,73,110,112,117,116,46,77,97,110,105,112,117,108,97,116,105,111,110,73,110,101,114,116,105,97,83,116,97,114,116,105,110,103,82,111,117,116,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_ManipulationInertiaStartingRoutedEventArgs]);
DEFINE_IID!(IID_IManipulationStartedRoutedEventArgs, 1571924485, 40832, 18614, 174, 108, 79, 17, 157, 232, 255, 19);
RT_INTERFACE!{interface IManipulationStartedRoutedEventArgs(IManipulationStartedRoutedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IManipulationStartedRoutedEventArgs] {
    fn get_Container(&self, out: *mut *mut super::UIElement) -> HRESULT,
    fn get_Position(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_PointerDeviceType(&self, out: *mut ::rt::gen::windows::devices::input::PointerDeviceType) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Cumulative(&self, out: *mut super::super::input::ManipulationDelta) -> HRESULT,
    fn Complete(&self) -> HRESULT
}}
impl IManipulationStartedRoutedEventArgs {
    #[inline] pub unsafe fn get_container(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Container)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_position(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_pointer_device_type(&self) -> Result<::rt::gen::windows::devices::input::PointerDeviceType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerDeviceType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_cumulative(&self) -> Result<super::super::input::ManipulationDelta> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cumulative)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn complete(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ManipulationStartedRoutedEventArgs: IManipulationStartedRoutedEventArgs}
DEFINE_IID!(IID_IManipulationStartedRoutedEventArgsFactory, 2227296935, 29298, 17507, 182, 195, 164, 11, 155, 161, 81, 252);
RT_INTERFACE!{interface IManipulationStartedRoutedEventArgsFactory(IManipulationStartedRoutedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IManipulationStartedRoutedEventArgsFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut ManipulationStartedRoutedEventArgs) -> HRESULT
}}
impl IManipulationStartedRoutedEventArgsFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<ManipulationStartedRoutedEventArgs>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IManipulationStartingRoutedEventArgs, 416691895, 21412, 19477, 164, 152, 243, 169, 202, 33, 42, 66);
RT_INTERFACE!{interface IManipulationStartingRoutedEventArgs(IManipulationStartingRoutedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IManipulationStartingRoutedEventArgs] {
    fn get_Mode(&self, out: *mut ManipulationModes) -> HRESULT,
    fn put_Mode(&self, value: ManipulationModes) -> HRESULT,
    fn get_Container(&self, out: *mut *mut super::UIElement) -> HRESULT,
    fn put_Container(&self, value: *mut super::UIElement) -> HRESULT,
    fn get_Pivot(&self, out: *mut *mut ManipulationPivot) -> HRESULT,
    fn put_Pivot(&self, value: *mut ManipulationPivot) -> HRESULT,
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT
}}
impl IManipulationStartingRoutedEventArgs {
    #[inline] pub unsafe fn get_mode(&self) -> Result<ManipulationModes> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Mode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_mode(&self, value: ManipulationModes) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Mode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_container(&self) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Container)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_container(&self, value: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Container)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pivot(&self) -> Result<ComPtr<ManipulationPivot>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Pivot)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_pivot(&self, value: &ManipulationPivot) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Pivot)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ManipulationStartingRoutedEventArgs: IManipulationStartingRoutedEventArgs}
impl RtActivatable<IActivationFactory> for ManipulationStartingRoutedEventArgs {}
DEFINE_CLSID!(ManipulationStartingRoutedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,73,110,112,117,116,46,77,97,110,105,112,117,108,97,116,105,111,110,83,116,97,114,116,105,110,103,82,111,117,116,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_ManipulationStartingRoutedEventArgs]);
DEFINE_IID!(IID_INoFocusCandidateFoundEventArgs, 3962962343, 4103, 18681, 182, 179, 237, 11, 234, 83, 147, 125);
RT_INTERFACE!{interface INoFocusCandidateFoundEventArgs(INoFocusCandidateFoundEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_INoFocusCandidateFoundEventArgs] {
    fn get_Direction(&self, out: *mut FocusNavigationDirection) -> HRESULT,
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn get_InputDevice(&self, out: *mut FocusInputDeviceKind) -> HRESULT
}}
impl INoFocusCandidateFoundEventArgs {
    #[inline] pub unsafe fn get_direction(&self) -> Result<FocusNavigationDirection> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Direction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_input_device(&self) -> Result<FocusInputDeviceKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InputDevice)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class NoFocusCandidateFoundEventArgs: INoFocusCandidateFoundEventArgs}
DEFINE_IID!(IID_IPointerRoutedEventArgs, 3663892234, 38738, 18914, 189, 226, 73, 236, 202, 185, 25, 77);
RT_INTERFACE!{interface IPointerRoutedEventArgs(IPointerRoutedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPointerRoutedEventArgs] {
    fn get_Pointer(&self, out: *mut *mut Pointer) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-system")] fn get_KeyModifiers(&self, out: *mut ::rt::gen::windows::system::VirtualKeyModifiers) -> HRESULT,
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    #[cfg(feature="windows-ui")] fn GetCurrentPoint(&self, relativeTo: *mut super::UIElement, out: *mut *mut super::super::input::PointerPoint) -> HRESULT,
    #[cfg(feature="windows-ui")] fn GetIntermediatePoints(&self, relativeTo: *mut super::UIElement, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<super::super::input::PointerPoint>) -> HRESULT
}}
impl IPointerRoutedEventArgs {
    #[inline] pub unsafe fn get_pointer(&self) -> Result<ComPtr<Pointer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Pointer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_key_modifiers(&self) -> Result<::rt::gen::windows::system::VirtualKeyModifiers> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeyModifiers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_current_point(&self, relativeTo: &super::UIElement) -> Result<ComPtr<super::super::input::PointerPoint>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetCurrentPoint)(self as *const _ as *mut _, relativeTo as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_intermediate_points(&self, relativeTo: &super::UIElement) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<super::super::input::PointerPoint>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetIntermediatePoints)(self as *const _ as *mut _, relativeTo as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PointerRoutedEventArgs: IPointerRoutedEventArgs}
DEFINE_IID!(IID_IRightTappedRoutedEventArgs, 1748272797, 31701, 16435, 178, 55, 23, 47, 121, 171, 227, 147);
RT_INTERFACE!{interface IRightTappedRoutedEventArgs(IRightTappedRoutedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IRightTappedRoutedEventArgs] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_PointerDeviceType(&self, out: *mut ::rt::gen::windows::devices::input::PointerDeviceType) -> HRESULT,
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn GetPosition(&self, relativeTo: *mut super::UIElement, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT
}}
impl IRightTappedRoutedEventArgs {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_pointer_device_type(&self) -> Result<::rt::gen::windows::devices::input::PointerDeviceType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerDeviceType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_position(&self, relativeTo: &super::UIElement) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetPosition)(self as *const _ as *mut _, relativeTo as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class RightTappedRoutedEventArgs: IRightTappedRoutedEventArgs}
impl RtActivatable<IActivationFactory> for RightTappedRoutedEventArgs {}
DEFINE_CLSID!(RightTappedRoutedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,73,110,112,117,116,46,82,105,103,104,116,84,97,112,112,101,100,82,111,117,116,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_RightTappedRoutedEventArgs]);
DEFINE_IID!(IID_ITappedRoutedEventArgs, 2694440638, 58916, 17818, 187, 29, 224, 92, 115, 226, 204, 102);
RT_INTERFACE!{interface ITappedRoutedEventArgs(ITappedRoutedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ITappedRoutedEventArgs] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_PointerDeviceType(&self, out: *mut ::rt::gen::windows::devices::input::PointerDeviceType) -> HRESULT,
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn GetPosition(&self, relativeTo: *mut super::UIElement, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT
}}
impl ITappedRoutedEventArgs {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_pointer_device_type(&self) -> Result<::rt::gen::windows::devices::input::PointerDeviceType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerDeviceType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_position(&self, relativeTo: &super::UIElement) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetPosition)(self as *const _ as *mut _, relativeTo as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class TappedRoutedEventArgs: ITappedRoutedEventArgs}
impl RtActivatable<IActivationFactory> for TappedRoutedEventArgs {}
DEFINE_CLSID!(TappedRoutedEventArgs(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,73,110,112,117,116,46,84,97,112,112,101,100,82,111,117,116,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_TappedRoutedEventArgs]);
DEFINE_IID!(IID_IFindNextElementOptions, 3632980523, 18114, 16892, 137, 126, 181, 150, 25, 119, 184, 157);
RT_INTERFACE!{interface IFindNextElementOptions(IFindNextElementOptionsVtbl): IInspectable(IInspectableVtbl) [IID_IFindNextElementOptions] {
    fn get_SearchRoot(&self, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn put_SearchRoot(&self, value: *mut super::DependencyObject) -> HRESULT,
    fn get_ExclusionRect(&self, out: *mut ::rt::gen::windows::foundation::Rect) -> HRESULT,
    fn put_ExclusionRect(&self, value: ::rt::gen::windows::foundation::Rect) -> HRESULT,
    fn get_HintRect(&self, out: *mut ::rt::gen::windows::foundation::Rect) -> HRESULT,
    fn put_HintRect(&self, value: ::rt::gen::windows::foundation::Rect) -> HRESULT,
    fn get_XYFocusNavigationStrategyOverride(&self, out: *mut XYFocusNavigationStrategyOverride) -> HRESULT,
    fn put_XYFocusNavigationStrategyOverride(&self, value: XYFocusNavigationStrategyOverride) -> HRESULT
}}
impl IFindNextElementOptions {
    #[inline] pub unsafe fn get_search_root(&self) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SearchRoot)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_search_root(&self, value: &super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SearchRoot)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_exclusion_rect(&self) -> Result<::rt::gen::windows::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExclusionRect)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_exclusion_rect(&self, value: ::rt::gen::windows::foundation::Rect) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ExclusionRect)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_hint_rect(&self) -> Result<::rt::gen::windows::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HintRect)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_hint_rect(&self, value: ::rt::gen::windows::foundation::Rect) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HintRect)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xyfocus_navigation_strategy_override(&self) -> Result<XYFocusNavigationStrategyOverride> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_XYFocusNavigationStrategyOverride)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_xyfocus_navigation_strategy_override(&self, value: XYFocusNavigationStrategyOverride) -> Result<()> {
        let hr = ((*self.lpVtbl).put_XYFocusNavigationStrategyOverride)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class FindNextElementOptions: IFindNextElementOptions}
impl RtActivatable<IActivationFactory> for FindNextElementOptions {}
DEFINE_CLSID!(FindNextElementOptions(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,73,110,112,117,116,46,70,105,110,100,78,101,120,116,69,108,101,109,101,110,116,79,112,116,105,111,110,115,0]) [CLSID_FindNextElementOptions]);
DEFINE_IID!(IID_IFocusManager, 3359896843, 15235, 19873, 157, 111, 85, 124, 17, 105, 243, 65);
RT_INTERFACE!{interface IFocusManager(IFocusManagerVtbl): IInspectable(IInspectableVtbl) [IID_IFocusManager] {
    
}}
DEFINE_IID!(IID_IFocusManagerStatics, 516739878, 33154, 17538, 130, 106, 9, 24, 233, 237, 154, 247);
RT_INTERFACE!{static interface IFocusManagerStatics(IFocusManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IFocusManagerStatics] {
    fn GetFocusedElement(&self, out: *mut *mut IInspectable) -> HRESULT
}}
impl IFocusManagerStatics {
    #[inline] pub unsafe fn get_focused_element(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetFocusedElement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFocusManagerStatics2, 2837501793, 56711, 20273, 190, 218, 239, 65, 127, 231, 192, 74);
RT_INTERFACE!{static interface IFocusManagerStatics2(IFocusManagerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IFocusManagerStatics2] {
    fn TryMoveFocus(&self, focusNavigationDirection: FocusNavigationDirection, out: *mut bool) -> HRESULT
}}
impl IFocusManagerStatics2 {
    #[inline] pub unsafe fn try_move_focus(&self, focusNavigationDirection: FocusNavigationDirection) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryMoveFocus)(self as *const _ as *mut _, focusNavigationDirection, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFocusManagerStatics3, 1619025599, 45385, 16765, 131, 241, 186, 235, 86, 14, 42, 71);
RT_INTERFACE!{static interface IFocusManagerStatics3(IFocusManagerStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IFocusManagerStatics3] {
    fn FindNextFocusableElement(&self, focusNavigationDirection: FocusNavigationDirection, out: *mut *mut super::UIElement) -> HRESULT,
    fn FindNextFocusableElementWithHint(&self, focusNavigationDirection: FocusNavigationDirection, hintRect: ::rt::gen::windows::foundation::Rect, out: *mut *mut super::UIElement) -> HRESULT
}}
impl IFocusManagerStatics3 {
    #[inline] pub unsafe fn find_next_focusable_element(&self, focusNavigationDirection: FocusNavigationDirection) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindNextFocusableElement)(self as *const _ as *mut _, focusNavigationDirection, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_next_focusable_element_with_hint(&self, focusNavigationDirection: FocusNavigationDirection, hintRect: ::rt::gen::windows::foundation::Rect) -> Result<ComPtr<super::UIElement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindNextFocusableElementWithHint)(self as *const _ as *mut _, focusNavigationDirection, hintRect, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFocusManagerStatics4, 690450076, 7276, 16714, 186, 28, 150, 239, 213, 150, 43, 205);
RT_INTERFACE!{static interface IFocusManagerStatics4(IFocusManagerStatics4Vtbl): IInspectable(IInspectableVtbl) [IID_IFocusManagerStatics4] {
    fn TryMoveFocusWithOptions(&self, focusNavigationDirection: FocusNavigationDirection, focusNavigationOptions: *mut FindNextElementOptions, out: *mut bool) -> HRESULT,
    fn FindNextElement(&self, focusNavigationDirection: FocusNavigationDirection, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn FindFirstFocusableElement(&self, searchScope: *mut super::DependencyObject, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn FindLastFocusableElement(&self, searchScope: *mut super::DependencyObject, out: *mut *mut super::DependencyObject) -> HRESULT,
    fn FindNextElementWithOptions(&self, focusNavigationDirection: FocusNavigationDirection, focusNavigationOptions: *mut FindNextElementOptions, out: *mut *mut super::DependencyObject) -> HRESULT
}}
impl IFocusManagerStatics4 {
    #[inline] pub unsafe fn try_move_focus_with_options(&self, focusNavigationDirection: FocusNavigationDirection, focusNavigationOptions: &FindNextElementOptions) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryMoveFocusWithOptions)(self as *const _ as *mut _, focusNavigationDirection, focusNavigationOptions as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_next_element(&self, focusNavigationDirection: FocusNavigationDirection) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindNextElement)(self as *const _ as *mut _, focusNavigationDirection, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_first_focusable_element(&self, searchScope: &super::DependencyObject) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindFirstFocusableElement)(self as *const _ as *mut _, searchScope as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_last_focusable_element(&self, searchScope: &super::DependencyObject) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindLastFocusableElement)(self as *const _ as *mut _, searchScope as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_next_element_with_options(&self, focusNavigationDirection: FocusNavigationDirection, focusNavigationOptions: &FindNextElementOptions) -> Result<ComPtr<super::DependencyObject>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindNextElementWithOptions)(self as *const _ as *mut _, focusNavigationDirection, focusNavigationOptions as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class FocusManager: IFocusManager}
impl RtActivatable<IFocusManagerStatics2> for FocusManager {}
impl RtActivatable<IFocusManagerStatics> for FocusManager {}
impl RtActivatable<IFocusManagerStatics4> for FocusManager {}
impl RtActivatable<IFocusManagerStatics3> for FocusManager {}
impl FocusManager {
    #[inline] pub fn try_move_focus(focusNavigationDirection: FocusNavigationDirection) -> Result<bool> { unsafe {
        <Self as RtActivatable<IFocusManagerStatics2>>::get_activation_factory().try_move_focus(focusNavigationDirection)
    }}
    #[inline] pub fn get_focused_element() -> Result<ComPtr<IInspectable>> { unsafe {
        <Self as RtActivatable<IFocusManagerStatics>>::get_activation_factory().get_focused_element()
    }}
    #[inline] pub fn try_move_focus_with_options(focusNavigationDirection: FocusNavigationDirection, focusNavigationOptions: &FindNextElementOptions) -> Result<bool> { unsafe {
        <Self as RtActivatable<IFocusManagerStatics4>>::get_activation_factory().try_move_focus_with_options(focusNavigationDirection, focusNavigationOptions)
    }}
    #[inline] pub fn find_next_element(focusNavigationDirection: FocusNavigationDirection) -> Result<ComPtr<super::DependencyObject>> { unsafe {
        <Self as RtActivatable<IFocusManagerStatics4>>::get_activation_factory().find_next_element(focusNavigationDirection)
    }}
    #[inline] pub fn find_first_focusable_element(searchScope: &super::DependencyObject) -> Result<ComPtr<super::DependencyObject>> { unsafe {
        <Self as RtActivatable<IFocusManagerStatics4>>::get_activation_factory().find_first_focusable_element(searchScope)
    }}
    #[inline] pub fn find_last_focusable_element(searchScope: &super::DependencyObject) -> Result<ComPtr<super::DependencyObject>> { unsafe {
        <Self as RtActivatable<IFocusManagerStatics4>>::get_activation_factory().find_last_focusable_element(searchScope)
    }}
    #[inline] pub fn find_next_element_with_options(focusNavigationDirection: FocusNavigationDirection, focusNavigationOptions: &FindNextElementOptions) -> Result<ComPtr<super::DependencyObject>> { unsafe {
        <Self as RtActivatable<IFocusManagerStatics4>>::get_activation_factory().find_next_element_with_options(focusNavigationDirection, focusNavigationOptions)
    }}
    #[inline] pub fn find_next_focusable_element(focusNavigationDirection: FocusNavigationDirection) -> Result<ComPtr<super::UIElement>> { unsafe {
        <Self as RtActivatable<IFocusManagerStatics3>>::get_activation_factory().find_next_focusable_element(focusNavigationDirection)
    }}
    #[inline] pub fn find_next_focusable_element_with_hint(focusNavigationDirection: FocusNavigationDirection, hintRect: ::rt::gen::windows::foundation::Rect) -> Result<ComPtr<super::UIElement>> { unsafe {
        <Self as RtActivatable<IFocusManagerStatics3>>::get_activation_factory().find_next_focusable_element_with_hint(focusNavigationDirection, hintRect)
    }}
}
DEFINE_CLSID!(FocusManager(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,73,110,112,117,116,46,70,111,99,117,115,77,97,110,97,103,101,114,0]) [CLSID_FocusManager]);
} // Windows.UI.Xaml.Input
pub mod markup { // Windows.UI.Xaml.Markup
use ::prelude::*;
RT_STRUCT! { struct XamlBinaryWriterErrorInformation {
    InputStreamIndex: u32, LineNumber: u32, LinePosition: u32,
}}
RT_STRUCT! { struct XmlnsDefinition {
    XmlNamespace: HSTRING, Namespace: HSTRING,
}}
DEFINE_IID!(IID_IComponentConnector, 4135127431, 59109, 18418, 146, 198, 236, 204, 228, 186, 21, 154);
RT_INTERFACE!{interface IComponentConnector(IComponentConnectorVtbl): IInspectable(IInspectableVtbl) [IID_IComponentConnector] {
    fn Connect(&self, connectionId: i32, target: *mut IInspectable) -> HRESULT
}}
impl IComponentConnector {
    #[inline] pub unsafe fn connect(&self, connectionId: i32, target: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).Connect)(self as *const _ as *mut _, connectionId, target as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IComponentConnector2, 3700373131, 60620, 18830, 177, 57, 145, 20, 34, 84, 215, 174);
RT_INTERFACE!{interface IComponentConnector2(IComponentConnector2Vtbl): IInspectable(IInspectableVtbl) [IID_IComponentConnector2] {
    fn GetBindingConnector(&self, connectionId: i32, target: *mut IInspectable, out: *mut *mut IComponentConnector) -> HRESULT
}}
impl IComponentConnector2 {
    #[inline] pub unsafe fn get_binding_connector(&self, connectionId: i32, target: &IInspectable) -> Result<ComPtr<IComponentConnector>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetBindingConnector)(self as *const _ as *mut _, connectionId, target as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IXamlMember, 3309434252, 17321, 16918, 183, 24, 224, 177, 27, 20, 233, 62);
RT_INTERFACE!{interface IXamlMember(IXamlMemberVtbl): IInspectable(IInspectableVtbl) [IID_IXamlMember] {
    fn get_IsAttachable(&self, out: *mut bool) -> HRESULT,
    fn get_IsDependencyProperty(&self, out: *mut bool) -> HRESULT,
    fn get_IsReadOnly(&self, out: *mut bool) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TargetType(&self, out: *mut *mut IXamlType) -> HRESULT,
    fn get_Type(&self, out: *mut *mut IXamlType) -> HRESULT,
    fn GetValue(&self, instance: *mut IInspectable, out: *mut *mut IInspectable) -> HRESULT,
    fn SetValue(&self, instance: *mut IInspectable, value: *mut IInspectable) -> HRESULT
}}
impl IXamlMember {
    #[inline] pub unsafe fn get_is_attachable(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsAttachable)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_dependency_property(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsDependencyProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_read_only(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsReadOnly)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_target_type(&self) -> Result<ComPtr<IXamlType>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_type(&self) -> Result<ComPtr<IXamlType>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Type)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_value(&self, instance: &IInspectable) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetValue)(self as *const _ as *mut _, instance as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_value(&self, instance: &IInspectable, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).SetValue)(self as *const _ as *mut _, instance as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IXamlType, 2032200369, 41701, 18330, 189, 80, 108, 239, 60, 11, 73, 112);
RT_INTERFACE!{interface IXamlType(IXamlTypeVtbl): IInspectable(IInspectableVtbl) [IID_IXamlType] {
    fn get_BaseType(&self, out: *mut *mut IXamlType) -> HRESULT,
    fn get_ContentProperty(&self, out: *mut *mut IXamlMember) -> HRESULT,
    fn get_FullName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsArray(&self, out: *mut bool) -> HRESULT,
    fn get_IsCollection(&self, out: *mut bool) -> HRESULT,
    fn get_IsConstructible(&self, out: *mut bool) -> HRESULT,
    fn get_IsDictionary(&self, out: *mut bool) -> HRESULT,
    fn get_IsMarkupExtension(&self, out: *mut bool) -> HRESULT,
    fn get_IsBindable(&self, out: *mut bool) -> HRESULT,
    fn get_ItemType(&self, out: *mut *mut IXamlType) -> HRESULT,
    fn get_KeyType(&self, out: *mut *mut IXamlType) -> HRESULT,
    fn get_UnderlyingType(&self, out: *mut super::interop::TypeName) -> HRESULT,
    fn ActivateInstance(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn CreateFromString(&self, value: HSTRING, out: *mut *mut IInspectable) -> HRESULT,
    fn GetMember(&self, name: HSTRING, out: *mut *mut IXamlMember) -> HRESULT,
    fn AddToVector(&self, instance: *mut IInspectable, value: *mut IInspectable) -> HRESULT,
    fn AddToMap(&self, instance: *mut IInspectable, key: *mut IInspectable, value: *mut IInspectable) -> HRESULT,
    fn RunInitializer(&self) -> HRESULT
}}
impl IXamlType {
    #[inline] pub unsafe fn get_base_type(&self) -> Result<ComPtr<IXamlType>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BaseType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_property(&self) -> Result<ComPtr<IXamlMember>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_full_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FullName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_array(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsArray)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_collection(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCollection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_constructible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsConstructible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_dictionary(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsDictionary)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_markup_extension(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsMarkupExtension)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_bindable(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsBindable)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_type(&self) -> Result<ComPtr<IXamlType>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_key_type(&self) -> Result<ComPtr<IXamlType>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KeyType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_underlying_type(&self) -> Result<super::interop::TypeName> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_UnderlyingType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn activate_instance(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ActivateInstance)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_from_string(&self, value: &HStringArg) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateFromString)(self as *const _ as *mut _, value.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_member(&self, name: &HStringArg) -> Result<ComPtr<IXamlMember>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMember)(self as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_to_vector(&self, instance: &IInspectable, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).AddToVector)(self as *const _ as *mut _, instance as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_to_map(&self, instance: &IInspectable, key: &IInspectable, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).AddToMap)(self as *const _ as *mut _, instance as *const _ as *mut _, key as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn run_initializer(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).RunInitializer)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IXamlMetadataProvider, 3010878825, 26789, 19250, 136, 97, 253, 185, 12, 31, 88, 54);
RT_INTERFACE!{interface IXamlMetadataProvider(IXamlMetadataProviderVtbl): IInspectable(IInspectableVtbl) [IID_IXamlMetadataProvider] {
    fn GetXamlType(&self, type_: super::interop::TypeName, out: *mut *mut IXamlType) -> HRESULT,
    fn GetXamlTypeByFullName(&self, fullName: HSTRING, out: *mut *mut IXamlType) -> HRESULT,
    fn GetXmlnsDefinitions(&self, outSize: *mut u32, out: *mut *mut XmlnsDefinition) -> HRESULT
}}
impl IXamlMetadataProvider {
    #[inline] pub unsafe fn get_xaml_type(&self, type_: super::interop::TypeName) -> Result<ComPtr<IXamlType>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetXamlType)(self as *const _ as *mut _, type_, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xaml_type_by_full_name(&self, fullName: &HStringArg) -> Result<ComPtr<IXamlType>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetXamlTypeByFullName)(self as *const _ as *mut _, fullName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_xmlns_definitions(&self) -> Result<ComArray<XmlnsDefinition>> {
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetXmlnsDefinitions)(self as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IXamlBinaryWriter, 2191338195, 25098, 18166, 132, 93, 67, 106, 5, 146, 113, 0);
RT_INTERFACE!{interface IXamlBinaryWriter(IXamlBinaryWriterVtbl): IInspectable(IInspectableVtbl) [IID_IXamlBinaryWriter] {
    
}}
DEFINE_IID!(IID_IXamlBinaryWriterStatics, 227463290, 39810, 19112, 182, 139, 2, 111, 45, 225, 204, 134);
RT_INTERFACE!{static interface IXamlBinaryWriterStatics(IXamlBinaryWriterStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IXamlBinaryWriterStatics] {
    #[cfg(feature="windows-storage")] fn Write(&self, inputStreams: *mut ::rt::gen::windows::foundation::collections::IVector<::rt::gen::windows::storage::streams::IRandomAccessStream>, outputStreams: *mut ::rt::gen::windows::foundation::collections::IVector<::rt::gen::windows::storage::streams::IRandomAccessStream>, xamlMetadataProvider: *mut IXamlMetadataProvider, out: *mut XamlBinaryWriterErrorInformation) -> HRESULT
}}
impl IXamlBinaryWriterStatics {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn write(&self, inputStreams: &::rt::gen::windows::foundation::collections::IVector<::rt::gen::windows::storage::streams::IRandomAccessStream>, outputStreams: &::rt::gen::windows::foundation::collections::IVector<::rt::gen::windows::storage::streams::IRandomAccessStream>, xamlMetadataProvider: &IXamlMetadataProvider) -> Result<XamlBinaryWriterErrorInformation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Write)(self as *const _ as *mut _, inputStreams as *const _ as *mut _, outputStreams as *const _ as *mut _, xamlMetadataProvider as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class XamlBinaryWriter: IXamlBinaryWriter}
impl RtActivatable<IXamlBinaryWriterStatics> for XamlBinaryWriter {}
impl XamlBinaryWriter {
    #[cfg(feature="windows-storage")] #[inline] pub fn write(inputStreams: &::rt::gen::windows::foundation::collections::IVector<::rt::gen::windows::storage::streams::IRandomAccessStream>, outputStreams: &::rt::gen::windows::foundation::collections::IVector<::rt::gen::windows::storage::streams::IRandomAccessStream>, xamlMetadataProvider: &IXamlMetadataProvider) -> Result<XamlBinaryWriterErrorInformation> { unsafe {
        <Self as RtActivatable<IXamlBinaryWriterStatics>>::get_activation_factory().write(inputStreams, outputStreams, xamlMetadataProvider)
    }}
}
DEFINE_CLSID!(XamlBinaryWriter(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,97,114,107,117,112,46,88,97,109,108,66,105,110,97,114,121,87,114,105,116,101,114,0]) [CLSID_XamlBinaryWriter]);
DEFINE_IID!(IID_IXamlReader, 607603953, 52459, 18623, 165, 20, 65, 176, 24, 111, 132, 194);
RT_INTERFACE!{interface IXamlReader(IXamlReaderVtbl): IInspectable(IInspectableVtbl) [IID_IXamlReader] {
    
}}
DEFINE_IID!(IID_IXamlReaderStatics, 2559690429, 21327, 18773, 184, 90, 138, 141, 192, 220, 166, 2);
RT_INTERFACE!{static interface IXamlReaderStatics(IXamlReaderStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IXamlReaderStatics] {
    fn Load(&self, xaml: HSTRING, out: *mut *mut IInspectable) -> HRESULT,
    fn LoadWithInitialTemplateValidation(&self, xaml: HSTRING, out: *mut *mut IInspectable) -> HRESULT
}}
impl IXamlReaderStatics {
    #[inline] pub unsafe fn load(&self, xaml: &HStringArg) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Load)(self as *const _ as *mut _, xaml.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn load_with_initial_template_validation(&self, xaml: &HStringArg) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).LoadWithInitialTemplateValidation)(self as *const _ as *mut _, xaml.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class XamlReader: IXamlReader}
impl RtActivatable<IXamlReaderStatics> for XamlReader {}
impl XamlReader {
    #[inline] pub fn load(xaml: &HStringArg) -> Result<ComPtr<IInspectable>> { unsafe {
        <Self as RtActivatable<IXamlReaderStatics>>::get_activation_factory().load(xaml)
    }}
    #[inline] pub fn load_with_initial_template_validation(xaml: &HStringArg) -> Result<ComPtr<IInspectable>> { unsafe {
        <Self as RtActivatable<IXamlReaderStatics>>::get_activation_factory().load_with_initial_template_validation(xaml)
    }}
}
DEFINE_CLSID!(XamlReader(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,97,114,107,117,112,46,88,97,109,108,82,101,97,100,101,114,0]) [CLSID_XamlReader]);
DEFINE_IID!(IID_IDataTemplateComponent, 138583496, 35504, 18247, 170, 154, 254, 173, 252, 141, 168, 225);
RT_INTERFACE!{interface IDataTemplateComponent(IDataTemplateComponentVtbl): IInspectable(IInspectableVtbl) [IID_IDataTemplateComponent] {
    fn Recycle(&self) -> HRESULT,
    fn ProcessBindings(&self, item: *mut IInspectable, itemIndex: i32, phase: i32, nextPhase: *mut i32) -> HRESULT
}}
impl IDataTemplateComponent {
    #[inline] pub unsafe fn recycle(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Recycle)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn process_bindings(&self, item: &IInspectable, itemIndex: i32, phase: i32) -> Result<i32> {
        let mut nextPhase = zeroed();
        let hr = ((*self.lpVtbl).ProcessBindings)(self as *const _ as *mut _, item as *const _ as *mut _, itemIndex, phase, &mut nextPhase);
        if hr == S_OK { Ok(nextPhase) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IXamlBindingHelper, 4205247238, 35513, 20215, 138, 231, 251, 211, 11, 191, 208, 109);
RT_INTERFACE!{interface IXamlBindingHelper(IXamlBindingHelperVtbl): IInspectable(IInspectableVtbl) [IID_IXamlBindingHelper] {
    
}}
DEFINE_IID!(IID_IXamlBindingHelperStatics, 4133288817, 51212, 20474, 134, 238, 85, 135, 84, 238, 51, 109);
RT_INTERFACE!{static interface IXamlBindingHelperStatics(IXamlBindingHelperStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IXamlBindingHelperStatics] {
    fn get_DataTemplateComponentProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn GetDataTemplateComponent(&self, element: *mut super::DependencyObject, out: *mut *mut IDataTemplateComponent) -> HRESULT,
    fn SetDataTemplateComponent(&self, element: *mut super::DependencyObject, value: *mut IDataTemplateComponent) -> HRESULT,
    fn SuspendRendering(&self, target: *mut super::UIElement) -> HRESULT,
    fn ResumeRendering(&self, target: *mut super::UIElement) -> HRESULT,
    fn ConvertValue(&self, type_: super::interop::TypeName, value: *mut IInspectable, out: *mut *mut IInspectable) -> HRESULT,
    fn SetPropertyFromString(&self, dependencyObject: *mut IInspectable, propertyToSet: *mut super::DependencyProperty, value: HSTRING) -> HRESULT,
    fn SetPropertyFromBoolean(&self, dependencyObject: *mut IInspectable, propertyToSet: *mut super::DependencyProperty, value: bool) -> HRESULT,
    fn SetPropertyFromChar16(&self, dependencyObject: *mut IInspectable, propertyToSet: *mut super::DependencyProperty, value: Char) -> HRESULT,
    fn SetPropertyFromDateTime(&self, dependencyObject: *mut IInspectable, propertyToSet: *mut super::DependencyProperty, value: ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn SetPropertyFromDouble(&self, dependencyObject: *mut IInspectable, propertyToSet: *mut super::DependencyProperty, value: f64) -> HRESULT,
    fn SetPropertyFromInt32(&self, dependencyObject: *mut IInspectable, propertyToSet: *mut super::DependencyProperty, value: i32) -> HRESULT,
    fn SetPropertyFromUInt32(&self, dependencyObject: *mut IInspectable, propertyToSet: *mut super::DependencyProperty, value: u32) -> HRESULT,
    fn SetPropertyFromInt64(&self, dependencyObject: *mut IInspectable, propertyToSet: *mut super::DependencyProperty, value: i64) -> HRESULT,
    fn SetPropertyFromUInt64(&self, dependencyObject: *mut IInspectable, propertyToSet: *mut super::DependencyProperty, value: u64) -> HRESULT,
    fn SetPropertyFromSingle(&self, dependencyObject: *mut IInspectable, propertyToSet: *mut super::DependencyProperty, value: f32) -> HRESULT,
    fn SetPropertyFromPoint(&self, dependencyObject: *mut IInspectable, propertyToSet: *mut super::DependencyProperty, value: ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn SetPropertyFromRect(&self, dependencyObject: *mut IInspectable, propertyToSet: *mut super::DependencyProperty, value: ::rt::gen::windows::foundation::Rect) -> HRESULT,
    fn SetPropertyFromSize(&self, dependencyObject: *mut IInspectable, propertyToSet: *mut super::DependencyProperty, value: ::rt::gen::windows::foundation::Size) -> HRESULT,
    fn SetPropertyFromTimeSpan(&self, dependencyObject: *mut IInspectable, propertyToSet: *mut super::DependencyProperty, value: ::rt::gen::windows::foundation::TimeSpan) -> HRESULT,
    fn SetPropertyFromByte(&self, dependencyObject: *mut IInspectable, propertyToSet: *mut super::DependencyProperty, value: u8) -> HRESULT,
    fn SetPropertyFromUri(&self, dependencyObject: *mut IInspectable, propertyToSet: *mut super::DependencyProperty, value: *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn SetPropertyFromObject(&self, dependencyObject: *mut IInspectable, propertyToSet: *mut super::DependencyProperty, value: *mut IInspectable) -> HRESULT
}}
impl IXamlBindingHelperStatics {
    #[inline] pub unsafe fn get_data_template_component_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DataTemplateComponentProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_data_template_component(&self, element: &super::DependencyObject) -> Result<ComPtr<IDataTemplateComponent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDataTemplateComponent)(self as *const _ as *mut _, element as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_data_template_component(&self, element: &super::DependencyObject, value: &IDataTemplateComponent) -> Result<()> {
        let hr = ((*self.lpVtbl).SetDataTemplateComponent)(self as *const _ as *mut _, element as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn suspend_rendering(&self, target: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).SuspendRendering)(self as *const _ as *mut _, target as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn resume_rendering(&self, target: &super::UIElement) -> Result<()> {
        let hr = ((*self.lpVtbl).ResumeRendering)(self as *const _ as *mut _, target as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn convert_value(&self, type_: super::interop::TypeName, value: &IInspectable) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ConvertValue)(self as *const _ as *mut _, type_, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_property_from_string(&self, dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPropertyFromString)(self as *const _ as *mut _, dependencyObject as *const _ as *mut _, propertyToSet as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_property_from_boolean(&self, dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPropertyFromBoolean)(self as *const _ as *mut _, dependencyObject as *const _ as *mut _, propertyToSet as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_property_from_char16(&self, dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: Char) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPropertyFromChar16)(self as *const _ as *mut _, dependencyObject as *const _ as *mut _, propertyToSet as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_property_from_date_time(&self, dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: ::rt::gen::windows::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPropertyFromDateTime)(self as *const _ as *mut _, dependencyObject as *const _ as *mut _, propertyToSet as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_property_from_double(&self, dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPropertyFromDouble)(self as *const _ as *mut _, dependencyObject as *const _ as *mut _, propertyToSet as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_property_from_int32(&self, dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPropertyFromInt32)(self as *const _ as *mut _, dependencyObject as *const _ as *mut _, propertyToSet as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_property_from_uint32(&self, dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: u32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPropertyFromUInt32)(self as *const _ as *mut _, dependencyObject as *const _ as *mut _, propertyToSet as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_property_from_int64(&self, dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: i64) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPropertyFromInt64)(self as *const _ as *mut _, dependencyObject as *const _ as *mut _, propertyToSet as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_property_from_uint64(&self, dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: u64) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPropertyFromUInt64)(self as *const _ as *mut _, dependencyObject as *const _ as *mut _, propertyToSet as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_property_from_single(&self, dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: f32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPropertyFromSingle)(self as *const _ as *mut _, dependencyObject as *const _ as *mut _, propertyToSet as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_property_from_point(&self, dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPropertyFromPoint)(self as *const _ as *mut _, dependencyObject as *const _ as *mut _, propertyToSet as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_property_from_rect(&self, dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: ::rt::gen::windows::foundation::Rect) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPropertyFromRect)(self as *const _ as *mut _, dependencyObject as *const _ as *mut _, propertyToSet as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_property_from_size(&self, dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: ::rt::gen::windows::foundation::Size) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPropertyFromSize)(self as *const _ as *mut _, dependencyObject as *const _ as *mut _, propertyToSet as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_property_from_time_span(&self, dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: ::rt::gen::windows::foundation::TimeSpan) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPropertyFromTimeSpan)(self as *const _ as *mut _, dependencyObject as *const _ as *mut _, propertyToSet as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_property_from_byte(&self, dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: u8) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPropertyFromByte)(self as *const _ as *mut _, dependencyObject as *const _ as *mut _, propertyToSet as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_property_from_uri(&self, dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: &::rt::gen::windows::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPropertyFromUri)(self as *const _ as *mut _, dependencyObject as *const _ as *mut _, propertyToSet as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_property_from_object(&self, dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPropertyFromObject)(self as *const _ as *mut _, dependencyObject as *const _ as *mut _, propertyToSet as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class XamlBindingHelper: IXamlBindingHelper}
impl RtActivatable<IXamlBindingHelperStatics> for XamlBindingHelper {}
impl XamlBindingHelper {
    #[inline] pub fn get_data_template_component_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().get_data_template_component_property()
    }}
    #[inline] pub fn get_data_template_component(element: &super::DependencyObject) -> Result<ComPtr<IDataTemplateComponent>> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().get_data_template_component(element)
    }}
    #[inline] pub fn set_data_template_component(element: &super::DependencyObject, value: &IDataTemplateComponent) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().set_data_template_component(element, value)
    }}
    #[inline] pub fn suspend_rendering(target: &super::UIElement) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().suspend_rendering(target)
    }}
    #[inline] pub fn resume_rendering(target: &super::UIElement) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().resume_rendering(target)
    }}
    #[inline] pub fn convert_value(type_: super::interop::TypeName, value: &IInspectable) -> Result<ComPtr<IInspectable>> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().convert_value(type_, value)
    }}
    #[inline] pub fn set_property_from_string(dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().set_property_from_string(dependencyObject, propertyToSet, value)
    }}
    #[inline] pub fn set_property_from_boolean(dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().set_property_from_boolean(dependencyObject, propertyToSet, value)
    }}
    #[inline] pub fn set_property_from_char16(dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: Char) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().set_property_from_char16(dependencyObject, propertyToSet, value)
    }}
    #[inline] pub fn set_property_from_date_time(dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: ::rt::gen::windows::foundation::DateTime) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().set_property_from_date_time(dependencyObject, propertyToSet, value)
    }}
    #[inline] pub fn set_property_from_double(dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: f64) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().set_property_from_double(dependencyObject, propertyToSet, value)
    }}
    #[inline] pub fn set_property_from_int32(dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: i32) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().set_property_from_int32(dependencyObject, propertyToSet, value)
    }}
    #[inline] pub fn set_property_from_uint32(dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: u32) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().set_property_from_uint32(dependencyObject, propertyToSet, value)
    }}
    #[inline] pub fn set_property_from_int64(dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: i64) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().set_property_from_int64(dependencyObject, propertyToSet, value)
    }}
    #[inline] pub fn set_property_from_uint64(dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: u64) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().set_property_from_uint64(dependencyObject, propertyToSet, value)
    }}
    #[inline] pub fn set_property_from_single(dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: f32) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().set_property_from_single(dependencyObject, propertyToSet, value)
    }}
    #[inline] pub fn set_property_from_point(dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: ::rt::gen::windows::foundation::Point) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().set_property_from_point(dependencyObject, propertyToSet, value)
    }}
    #[inline] pub fn set_property_from_rect(dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: ::rt::gen::windows::foundation::Rect) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().set_property_from_rect(dependencyObject, propertyToSet, value)
    }}
    #[inline] pub fn set_property_from_size(dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: ::rt::gen::windows::foundation::Size) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().set_property_from_size(dependencyObject, propertyToSet, value)
    }}
    #[inline] pub fn set_property_from_time_span(dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: ::rt::gen::windows::foundation::TimeSpan) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().set_property_from_time_span(dependencyObject, propertyToSet, value)
    }}
    #[inline] pub fn set_property_from_byte(dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: u8) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().set_property_from_byte(dependencyObject, propertyToSet, value)
    }}
    #[inline] pub fn set_property_from_uri(dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: &::rt::gen::windows::foundation::Uri) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().set_property_from_uri(dependencyObject, propertyToSet, value)
    }}
    #[inline] pub fn set_property_from_object(dependencyObject: &IInspectable, propertyToSet: &super::DependencyProperty, value: &IInspectable) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlBindingHelperStatics>>::get_activation_factory().set_property_from_object(dependencyObject, propertyToSet, value)
    }}
}
DEFINE_CLSID!(XamlBindingHelper(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,97,114,107,117,112,46,88,97,109,108,66,105,110,100,105,110,103,72,101,108,112,101,114,0]) [CLSID_XamlBindingHelper]);
DEFINE_IID!(IID_IXamlMarkupHelper, 3504760636, 21314, 17647, 133, 167, 237, 50, 122, 115, 157, 154);
RT_INTERFACE!{interface IXamlMarkupHelper(IXamlMarkupHelperVtbl): IInspectable(IInspectableVtbl) [IID_IXamlMarkupHelper] {
    
}}
DEFINE_IID!(IID_IXamlMarkupHelperStatics, 3384555301, 62287, 17500, 129, 162, 107, 114, 165, 232, 240, 114);
RT_INTERFACE!{static interface IXamlMarkupHelperStatics(IXamlMarkupHelperStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IXamlMarkupHelperStatics] {
    fn UnloadObject(&self, element: *mut super::DependencyObject) -> HRESULT
}}
impl IXamlMarkupHelperStatics {
    #[inline] pub unsafe fn unload_object(&self, element: &super::DependencyObject) -> Result<()> {
        let hr = ((*self.lpVtbl).UnloadObject)(self as *const _ as *mut _, element as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class XamlMarkupHelper: IXamlMarkupHelper}
impl RtActivatable<IXamlMarkupHelperStatics> for XamlMarkupHelper {}
impl XamlMarkupHelper {
    #[inline] pub fn unload_object(element: &super::DependencyObject) -> Result<()> { unsafe {
        <Self as RtActivatable<IXamlMarkupHelperStatics>>::get_activation_factory().unload_object(element)
    }}
}
DEFINE_CLSID!(XamlMarkupHelper(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,77,97,114,107,117,112,46,88,97,109,108,77,97,114,107,117,112,72,101,108,112,101,114,0]) [CLSID_XamlMarkupHelper]);
} // Windows.UI.Xaml.Markup
pub mod resources { // Windows.UI.Xaml.Resources
use ::prelude::*;
DEFINE_IID!(IID_ICustomXamlResourceLoader, 1360692395, 19080, 16799, 133, 46, 84, 8, 59, 144, 176, 120);
RT_INTERFACE!{interface ICustomXamlResourceLoader(ICustomXamlResourceLoaderVtbl): IInspectable(IInspectableVtbl) [IID_ICustomXamlResourceLoader] {
    
}}
DEFINE_IID!(IID_ICustomXamlResourceLoaderOverrides, 4166117777, 44802, 18152, 154, 248, 66, 123, 126, 191, 233, 248);
RT_INTERFACE!{interface ICustomXamlResourceLoaderOverrides(ICustomXamlResourceLoaderOverridesVtbl): IInspectable(IInspectableVtbl) [IID_ICustomXamlResourceLoaderOverrides] {
    fn GetResource(&self, resourceId: HSTRING, objectType: HSTRING, propertyName: HSTRING, propertyType: HSTRING, out: *mut *mut IInspectable) -> HRESULT
}}
impl ICustomXamlResourceLoaderOverrides {
    #[inline] pub unsafe fn get_resource(&self, resourceId: &HStringArg, objectType: &HStringArg, propertyName: &HStringArg, propertyType: &HStringArg) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetResource)(self as *const _ as *mut _, resourceId.get(), objectType.get(), propertyName.get(), propertyType.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICustomXamlResourceLoaderStatics, 575665687, 58588, 19495, 173, 50, 219, 147, 213, 208, 229, 218);
RT_INTERFACE!{static interface ICustomXamlResourceLoaderStatics(ICustomXamlResourceLoaderStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICustomXamlResourceLoaderStatics] {
    fn get_Current(&self, out: *mut *mut CustomXamlResourceLoader) -> HRESULT,
    fn put_Current(&self, value: *mut CustomXamlResourceLoader) -> HRESULT
}}
impl ICustomXamlResourceLoaderStatics {
    #[inline] pub unsafe fn get_current(&self) -> Result<ComPtr<CustomXamlResourceLoader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Current)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_current(&self, value: &CustomXamlResourceLoader) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Current)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class CustomXamlResourceLoader: ICustomXamlResourceLoader}
impl RtActivatable<ICustomXamlResourceLoaderStatics> for CustomXamlResourceLoader {}
impl CustomXamlResourceLoader {
    #[inline] pub fn get_current() -> Result<ComPtr<CustomXamlResourceLoader>> { unsafe {
        <Self as RtActivatable<ICustomXamlResourceLoaderStatics>>::get_activation_factory().get_current()
    }}
    #[inline] pub fn set_current(value: &CustomXamlResourceLoader) -> Result<()> { unsafe {
        <Self as RtActivatable<ICustomXamlResourceLoaderStatics>>::get_activation_factory().set_current(value)
    }}
}
DEFINE_CLSID!(CustomXamlResourceLoader(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,82,101,115,111,117,114,99,101,115,46,67,117,115,116,111,109,88,97,109,108,82,101,115,111,117,114,99,101,76,111,97,100,101,114,0]) [CLSID_CustomXamlResourceLoader]);
DEFINE_IID!(IID_ICustomXamlResourceLoaderFactory, 1543339593, 30854, 17651, 142, 211, 111, 236, 4, 99, 237, 105);
RT_INTERFACE!{interface ICustomXamlResourceLoaderFactory(ICustomXamlResourceLoaderFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICustomXamlResourceLoaderFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut CustomXamlResourceLoader) -> HRESULT
}}
impl ICustomXamlResourceLoaderFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<CustomXamlResourceLoader>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
} // Windows.UI.Xaml.Resources
pub mod shapes { // Windows.UI.Xaml.Shapes
use ::prelude::*;
DEFINE_IID!(IID_IShape, 2020551541, 39584, 17741, 174, 6, 162, 70, 110, 55, 200, 50);
RT_INTERFACE!{interface IShape(IShapeVtbl): IInspectable(IInspectableVtbl) [IID_IShape] {
    fn get_Fill(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_Fill(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_Stroke(&self, out: *mut *mut super::media::Brush) -> HRESULT,
    fn put_Stroke(&self, value: *mut super::media::Brush) -> HRESULT,
    fn get_StrokeMiterLimit(&self, out: *mut f64) -> HRESULT,
    fn put_StrokeMiterLimit(&self, value: f64) -> HRESULT,
    fn get_StrokeThickness(&self, out: *mut f64) -> HRESULT,
    fn put_StrokeThickness(&self, value: f64) -> HRESULT,
    fn get_StrokeStartLineCap(&self, out: *mut super::media::PenLineCap) -> HRESULT,
    fn put_StrokeStartLineCap(&self, value: super::media::PenLineCap) -> HRESULT,
    fn get_StrokeEndLineCap(&self, out: *mut super::media::PenLineCap) -> HRESULT,
    fn put_StrokeEndLineCap(&self, value: super::media::PenLineCap) -> HRESULT,
    fn get_StrokeLineJoin(&self, out: *mut super::media::PenLineJoin) -> HRESULT,
    fn put_StrokeLineJoin(&self, value: super::media::PenLineJoin) -> HRESULT,
    fn get_StrokeDashOffset(&self, out: *mut f64) -> HRESULT,
    fn put_StrokeDashOffset(&self, value: f64) -> HRESULT,
    fn get_StrokeDashCap(&self, out: *mut super::media::PenLineCap) -> HRESULT,
    fn put_StrokeDashCap(&self, value: super::media::PenLineCap) -> HRESULT,
    fn get_StrokeDashArray(&self, out: *mut *mut super::media::DoubleCollection) -> HRESULT,
    fn put_StrokeDashArray(&self, value: *mut super::media::DoubleCollection) -> HRESULT,
    fn get_Stretch(&self, out: *mut super::media::Stretch) -> HRESULT,
    fn put_Stretch(&self, value: super::media::Stretch) -> HRESULT,
    fn get_GeometryTransform(&self, out: *mut *mut super::media::Transform) -> HRESULT
}}
impl IShape {
    #[inline] pub unsafe fn get_fill(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Fill)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_fill(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Fill)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke(&self) -> Result<ComPtr<super::media::Brush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Stroke)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stroke(&self, value: &super::media::Brush) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Stroke)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_miter_limit(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StrokeMiterLimit)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stroke_miter_limit(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StrokeMiterLimit)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_thickness(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StrokeThickness)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stroke_thickness(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StrokeThickness)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_start_line_cap(&self) -> Result<super::media::PenLineCap> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StrokeStartLineCap)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stroke_start_line_cap(&self, value: super::media::PenLineCap) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StrokeStartLineCap)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_end_line_cap(&self) -> Result<super::media::PenLineCap> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StrokeEndLineCap)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stroke_end_line_cap(&self, value: super::media::PenLineCap) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StrokeEndLineCap)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_line_join(&self) -> Result<super::media::PenLineJoin> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StrokeLineJoin)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stroke_line_join(&self, value: super::media::PenLineJoin) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StrokeLineJoin)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_dash_offset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StrokeDashOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stroke_dash_offset(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StrokeDashOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_dash_cap(&self) -> Result<super::media::PenLineCap> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StrokeDashCap)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stroke_dash_cap(&self, value: super::media::PenLineCap) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StrokeDashCap)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_dash_array(&self) -> Result<ComPtr<super::media::DoubleCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StrokeDashArray)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stroke_dash_array(&self, value: &super::media::DoubleCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StrokeDashArray)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stretch(&self) -> Result<super::media::Stretch> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Stretch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_stretch(&self, value: super::media::Stretch) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Stretch)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_geometry_transform(&self) -> Result<ComPtr<super::media::Transform>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GeometryTransform)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IShapeStatics, 494619733, 40435, 18652, 145, 148, 157, 48, 111, 170, 96, 137);
RT_INTERFACE!{static interface IShapeStatics(IShapeStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IShapeStatics] {
    fn get_FillProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_StrokeProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_StrokeMiterLimitProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_StrokeThicknessProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_StrokeStartLineCapProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_StrokeEndLineCapProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_StrokeLineJoinProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_StrokeDashOffsetProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_StrokeDashCapProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_StrokeDashArrayProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_StretchProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IShapeStatics {
    #[inline] pub unsafe fn get_fill_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FillProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StrokeProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_miter_limit_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StrokeMiterLimitProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_thickness_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StrokeThicknessProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_start_line_cap_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StrokeStartLineCapProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_end_line_cap_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StrokeEndLineCapProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_line_join_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StrokeLineJoinProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_dash_offset_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StrokeDashOffsetProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_dash_cap_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StrokeDashCapProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stroke_dash_array_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StrokeDashArrayProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_stretch_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StretchProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IShapeFactory, 1265726995, 63146, 18645, 149, 136, 225, 209, 136, 234, 203, 201);
RT_INTERFACE!{interface IShapeFactory(IShapeFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IShapeFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut Shape) -> HRESULT
}}
impl IShapeFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<Shape>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IShape2, 2535755194, 18930, 18852, 165, 221, 22, 77, 248, 36, 219, 20);
RT_INTERFACE!{interface IShape2(IShape2Vtbl): IInspectable(IInspectableVtbl) [IID_IShape2] {
    #[cfg(feature="windows-ui")] fn GetAlphaMask(&self, out: *mut *mut super::super::composition::CompositionBrush) -> HRESULT
}}
impl IShape2 {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_alpha_mask(&self) -> Result<ComPtr<super::super::composition::CompositionBrush>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAlphaMask)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class Shape: IShape}
impl RtActivatable<IShapeStatics> for Shape {}
impl Shape {
    #[inline] pub fn get_fill_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IShapeStatics>>::get_activation_factory().get_fill_property()
    }}
    #[inline] pub fn get_stroke_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IShapeStatics>>::get_activation_factory().get_stroke_property()
    }}
    #[inline] pub fn get_stroke_miter_limit_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IShapeStatics>>::get_activation_factory().get_stroke_miter_limit_property()
    }}
    #[inline] pub fn get_stroke_thickness_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IShapeStatics>>::get_activation_factory().get_stroke_thickness_property()
    }}
    #[inline] pub fn get_stroke_start_line_cap_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IShapeStatics>>::get_activation_factory().get_stroke_start_line_cap_property()
    }}
    #[inline] pub fn get_stroke_end_line_cap_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IShapeStatics>>::get_activation_factory().get_stroke_end_line_cap_property()
    }}
    #[inline] pub fn get_stroke_line_join_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IShapeStatics>>::get_activation_factory().get_stroke_line_join_property()
    }}
    #[inline] pub fn get_stroke_dash_offset_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IShapeStatics>>::get_activation_factory().get_stroke_dash_offset_property()
    }}
    #[inline] pub fn get_stroke_dash_cap_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IShapeStatics>>::get_activation_factory().get_stroke_dash_cap_property()
    }}
    #[inline] pub fn get_stroke_dash_array_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IShapeStatics>>::get_activation_factory().get_stroke_dash_array_property()
    }}
    #[inline] pub fn get_stretch_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IShapeStatics>>::get_activation_factory().get_stretch_property()
    }}
}
DEFINE_CLSID!(Shape(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,83,104,97,112,101,115,46,83,104,97,112,101,0]) [CLSID_Shape]);
DEFINE_IID!(IID_IEllipse, 1893751492, 54157, 19371, 131, 31, 74, 34, 239, 82, 172, 134);
RT_INTERFACE!{interface IEllipse(IEllipseVtbl): IInspectable(IInspectableVtbl) [IID_IEllipse] {
    
}}
RT_CLASS!{class Ellipse: IEllipse}
impl RtActivatable<IActivationFactory> for Ellipse {}
DEFINE_CLSID!(Ellipse(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,83,104,97,112,101,115,46,69,108,108,105,112,115,101,0]) [CLSID_Ellipse]);
DEFINE_IID!(IID_ILine, 1185235773, 20475, 18655, 135, 50, 78, 21, 200, 52, 129, 107);
RT_INTERFACE!{interface ILine(ILineVtbl): IInspectable(IInspectableVtbl) [IID_ILine] {
    fn get_X1(&self, out: *mut f64) -> HRESULT,
    fn put_X1(&self, value: f64) -> HRESULT,
    fn get_Y1(&self, out: *mut f64) -> HRESULT,
    fn put_Y1(&self, value: f64) -> HRESULT,
    fn get_X2(&self, out: *mut f64) -> HRESULT,
    fn put_X2(&self, value: f64) -> HRESULT,
    fn get_Y2(&self, out: *mut f64) -> HRESULT,
    fn put_Y2(&self, value: f64) -> HRESULT
}}
impl ILine {
    #[inline] pub unsafe fn get_x1(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_X1)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_x1(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_X1)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_y1(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Y1)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_y1(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Y1)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_x2(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_X2)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_x2(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_X2)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_y2(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Y2)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_y2(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Y2)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ILineStatics, 645665341, 28324, 19536, 139, 29, 80, 32, 122, 255, 30, 138);
RT_INTERFACE!{static interface ILineStatics(ILineStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ILineStatics] {
    fn get_X1Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_Y1Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_X2Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_Y2Property(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl ILineStatics {
    #[inline] pub unsafe fn get_x1_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_X1Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_y1_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Y1Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_x2_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_X2Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_y2_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Y2Property)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class Line: ILine}
impl RtActivatable<ILineStatics> for Line {}
impl RtActivatable<IActivationFactory> for Line {}
impl Line {
    #[inline] pub fn get_x1_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ILineStatics>>::get_activation_factory().get_x1_property()
    }}
    #[inline] pub fn get_y1_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ILineStatics>>::get_activation_factory().get_y1_property()
    }}
    #[inline] pub fn get_x2_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ILineStatics>>::get_activation_factory().get_x2_property()
    }}
    #[inline] pub fn get_y2_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<ILineStatics>>::get_activation_factory().get_y2_property()
    }}
}
DEFINE_CLSID!(Line(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,83,104,97,112,101,115,46,76,105,110,101,0]) [CLSID_Line]);
DEFINE_IID!(IID_IPath, 2022192649, 15703, 20284, 184, 165, 108, 171, 202, 201, 113, 31);
RT_INTERFACE!{interface IPath(IPathVtbl): IInspectable(IInspectableVtbl) [IID_IPath] {
    fn get_Data(&self, out: *mut *mut super::media::Geometry) -> HRESULT,
    fn put_Data(&self, value: *mut super::media::Geometry) -> HRESULT
}}
impl IPath {
    #[inline] pub unsafe fn get_data(&self) -> Result<ComPtr<super::media::Geometry>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Data)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_data(&self, value: &super::media::Geometry) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Data)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPathStatics, 4129809821, 34780, 16706, 129, 241, 151, 252, 127, 248, 100, 28);
RT_INTERFACE!{static interface IPathStatics(IPathStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPathStatics] {
    fn get_DataProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IPathStatics {
    #[inline] pub unsafe fn get_data_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DataProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPathFactory, 591439075, 23174, 20422, 154, 80, 203, 185, 59, 130, 135, 102);
RT_INTERFACE!{interface IPathFactory(IPathFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPathFactory] {
    fn CreateInstance(&self, outer: *mut IInspectable, inner: *mut *mut IInspectable, out: *mut *mut Path) -> HRESULT
}}
impl IPathFactory {
    #[inline] pub unsafe fn create_instance(&self, outer: &IInspectable) -> Result<(ComPtr<IInspectable>, ComPtr<Path>)> {
        let mut inner = null_mut(); let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, outer as *const _ as *mut _, &mut inner, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap(inner), ComPtr::wrap(out))) } else { err(hr) }
    }
}
RT_CLASS!{class Path: IPath}
impl RtActivatable<IPathStatics> for Path {}
impl Path {
    #[inline] pub fn get_data_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPathStatics>>::get_activation_factory().get_data_property()
    }}
}
DEFINE_CLSID!(Path(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,83,104,97,112,101,115,46,80,97,116,104,0]) [CLSID_Path]);
DEFINE_IID!(IID_IPolygon, 3816119321, 11853, 19404, 141, 52, 134, 135, 25, 87, 250, 1);
RT_INTERFACE!{interface IPolygon(IPolygonVtbl): IInspectable(IInspectableVtbl) [IID_IPolygon] {
    fn get_FillRule(&self, out: *mut super::media::FillRule) -> HRESULT,
    fn put_FillRule(&self, value: super::media::FillRule) -> HRESULT,
    fn get_Points(&self, out: *mut *mut super::media::PointCollection) -> HRESULT,
    fn put_Points(&self, value: *mut super::media::PointCollection) -> HRESULT
}}
impl IPolygon {
    #[inline] pub unsafe fn get_fill_rule(&self) -> Result<super::media::FillRule> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FillRule)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_fill_rule(&self, value: super::media::FillRule) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FillRule)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_points(&self) -> Result<ComPtr<super::media::PointCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Points)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_points(&self, value: &super::media::PointCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Points)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPolygonStatics, 908757675, 54371, 17254, 158, 26, 190, 186, 114, 129, 15, 183);
RT_INTERFACE!{static interface IPolygonStatics(IPolygonStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPolygonStatics] {
    fn get_FillRuleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PointsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IPolygonStatics {
    #[inline] pub unsafe fn get_fill_rule_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FillRuleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_points_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class Polygon: IPolygon}
impl RtActivatable<IPolygonStatics> for Polygon {}
impl RtActivatable<IActivationFactory> for Polygon {}
impl Polygon {
    #[inline] pub fn get_fill_rule_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPolygonStatics>>::get_activation_factory().get_fill_rule_property()
    }}
    #[inline] pub fn get_points_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPolygonStatics>>::get_activation_factory().get_points_property()
    }}
}
DEFINE_CLSID!(Polygon(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,83,104,97,112,101,115,46,80,111,108,121,103,111,110,0]) [CLSID_Polygon]);
DEFINE_IID!(IID_IPolyline, 2447139576, 17075, 18419, 132, 118, 197, 81, 36, 167, 196, 198);
RT_INTERFACE!{interface IPolyline(IPolylineVtbl): IInspectable(IInspectableVtbl) [IID_IPolyline] {
    fn get_FillRule(&self, out: *mut super::media::FillRule) -> HRESULT,
    fn put_FillRule(&self, value: super::media::FillRule) -> HRESULT,
    fn get_Points(&self, out: *mut *mut super::media::PointCollection) -> HRESULT,
    fn put_Points(&self, value: *mut super::media::PointCollection) -> HRESULT
}}
impl IPolyline {
    #[inline] pub unsafe fn get_fill_rule(&self) -> Result<super::media::FillRule> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FillRule)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_fill_rule(&self, value: super::media::FillRule) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FillRule)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_points(&self) -> Result<ComPtr<super::media::PointCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Points)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_points(&self, value: &super::media::PointCollection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Points)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPolylineStatics, 3349818577, 41580, 17328, 170, 165, 130, 47, 166, 74, 17, 185);
RT_INTERFACE!{static interface IPolylineStatics(IPolylineStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPolylineStatics] {
    fn get_FillRuleProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_PointsProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IPolylineStatics {
    #[inline] pub unsafe fn get_fill_rule_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FillRuleProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_points_property(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointsProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class Polyline: IPolyline}
impl RtActivatable<IPolylineStatics> for Polyline {}
impl RtActivatable<IActivationFactory> for Polyline {}
impl Polyline {
    #[inline] pub fn get_fill_rule_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPolylineStatics>>::get_activation_factory().get_fill_rule_property()
    }}
    #[inline] pub fn get_points_property() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IPolylineStatics>>::get_activation_factory().get_points_property()
    }}
}
DEFINE_CLSID!(Polyline(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,83,104,97,112,101,115,46,80,111,108,121,108,105,110,101,0]) [CLSID_Polyline]);
DEFINE_IID!(IID_IRectangle, 2237383216, 35345, 19992, 161, 54, 75, 194, 28, 120, 39, 176);
RT_INTERFACE!{interface IRectangle(IRectangleVtbl): IInspectable(IInspectableVtbl) [IID_IRectangle] {
    fn get_RadiusX(&self, out: *mut f64) -> HRESULT,
    fn put_RadiusX(&self, value: f64) -> HRESULT,
    fn get_RadiusY(&self, out: *mut f64) -> HRESULT,
    fn put_RadiusY(&self, value: f64) -> HRESULT
}}
impl IRectangle {
    #[inline] pub unsafe fn get_radius_x(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RadiusX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_radius_x(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RadiusX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_radius_y(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RadiusY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_radius_y(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RadiusY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRectangleStatics, 2670045779, 47930, 19516, 137, 219, 111, 188, 13, 31, 160, 204);
RT_INTERFACE!{static interface IRectangleStatics(IRectangleStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRectangleStatics] {
    fn get_RadiusXProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT,
    fn get_RadiusYProperty(&self, out: *mut *mut super::DependencyProperty) -> HRESULT
}}
impl IRectangleStatics {
    #[inline] pub unsafe fn get_radius_xproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RadiusXProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_radius_yproperty(&self) -> Result<ComPtr<super::DependencyProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RadiusYProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class Rectangle: IRectangle}
impl RtActivatable<IRectangleStatics> for Rectangle {}
impl RtActivatable<IActivationFactory> for Rectangle {}
impl Rectangle {
    #[inline] pub fn get_radius_xproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRectangleStatics>>::get_activation_factory().get_radius_xproperty()
    }}
    #[inline] pub fn get_radius_yproperty() -> Result<ComPtr<super::DependencyProperty>> { unsafe {
        <Self as RtActivatable<IRectangleStatics>>::get_activation_factory().get_radius_yproperty()
    }}
}
DEFINE_CLSID!(Rectangle(&[87,105,110,100,111,119,115,46,85,73,46,88,97,109,108,46,83,104,97,112,101,115,46,82,101,99,116,97,110,103,108,101,0]) [CLSID_Rectangle]);
} // Windows.UI.Xaml.Shapes
